[{"task_id":"HumanEval_0","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵥⵟⵟⴰ ⵏ ⵓⴽⵜⵜⵓⵔ. \/\/ ⵣⵣⵔⴰⵢ ⵎⴽ ⴳ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏⵏ, ⵍⵍⴰⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵢⴰⴹⵏⵉⵏ ⵢⵓⴳⵔⵏ \/\/\/ >>> has_close_elements(numbers: [1.0, 2.0, 3.0], threshold: 0.5)\n\/\/\/ false\n\/\/\/ >>> has_close_elements(numbers: [1.0, 2.8, 3.0, 4.0, 5.0, 2.0], threshold: 0.3)\n\/\/\/ true\nfunc has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n","canonical_solution":"func has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n    let sortedNumbers = numbers.sorted()\n    for i in 0..<sortedNumbers.count - 1 {\n        if sortedNumbers[i+1] - sortedNumbers[i] < threshold {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.3) == true)\nassert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.05) == false)\nassert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.95) == true)\nassert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.8) == false)\nassert(has_close_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0], threshold: 0.1) == true)\nassert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 1.0) == true)\nassert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 0.5) == false)"},{"task_id":"HumanEval_1","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵓⵔ ⴷⴰ ⵏⵙⵙⴽⵜⵉ ⴽⵔⴰ ⵏ ⵡⴰⵏⵙⴰ ⴳ ⵜⵣⵍⵉⵜ ⵏ ⵓⵙⴽⵛⵎ. \/\/ ⵜⵔⴰⴱⴱⵓⵜⵉⵏ ⵉⴱⴹⴰⵏ ⴳⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ (ⵢⴰⵜⵜⵓⵇⵇⵏ ⴽⵓ ⵢⴰⵏ ⵏ ⵓⴱⵕⴰⴽⵉⵙ ⵉⵍⵍⴰⵏ) ⴷ ⵓⵔ ⴳⵉⵏⵜ ⴳⵔⵙⵏⵜ \/\/ ⴰⴷ ⵏⵙⴱⴹ ⵜⴰⵔⴰⴱⴱⵓⵜ ⴰⴷ ⵖⵔ ⵜⵉⴼⵉⵏⴰⵖ ⵉⵥⵍⵉⵏ ⴷ ⴰⴷ ⵏⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵜⵉⵏⵏⴰ. \/\/ ⴰⵙⴽⵛⵎ ⵙ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵏ ⵉⴽⵛⵛⵓⵎⵏ ⵉⵎⵣⴳⵓⵏⵏ. ⴰⵡⵜⵜⴰⵙ ⵏⵏⴽ ⵉⴳⴰ ⴰⴷ \/\/\/ >>> separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\")\n\/\/\/ [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string: String) -> [String] {\n","canonical_solution":"func separate_paren_groups(paren_string: String) -> [String] {\n    var results = [String]()\n    var currentGroup = \"\"\n    var balance = 0\n\n    for char in paren_string {\n        \/\/ Ignore spaces\n        if char == \" \" {\n            continue\n        }\n        \n        if char == \"(\" {\n            balance += 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n\n        currentGroup.append(char)\n\n        if balance == 0 && !currentGroup.isEmpty {\n            results.append(currentGroup)\n            currentGroup = \"\"\n        }\n    }\n    \n    return results\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"},{"task_id":"HumanEval_2","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⴷ ⵢⴰⴽⵣ ⵓⴳⵣⵣⵓⵎ ⴰⵎⵔⴰⵡ ⵏ ⵡⵓⵟⵟⵓⵏ. \/\/ (ⴰⴳⵣⵣⵓⵎ ⵏ ⵓⵃⴹⵓ ⴰⵀⴰ ⵉⵎⵥⵥⵉⵢⵏ ⵙⴳ 1). \/\/ ⴷ ⵓⴳⵣⵣⵓⵎ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ (ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⵉⵎⵥⵥⵉⵢⵏ ⵙⴳ ⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⴼⴽⴰⵏ) ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⵔⴰⵡⵏ \/\/ ⴰⵛⴽⵓ ⵏⵜⵜⴰⵜ ⴷ ⴰⵎⴹⴰⵏ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴹⴼⵓⵕ, ⵏⵣⵎⵔ ⴰⴷ ⵏⵙⴱⴹ \/\/\/ >>> truncate_number(number: 3.5)\n\/\/\/ 0.5\nfunc truncate_number(number: Double) -> Double {\n","canonical_solution":"func truncate_number(number: Double) -> Double {\n    return number - Double(Int(number))\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"},{"task_id":"HumanEval_3","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴳ ⵓⵙⴰⵜⵉ ⴷⵖ, ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵙⴽⵔ ⵜⵎⵔⵙⵍⵜ true. ⵎⴽ ⵓⵔ ⵜⴽⴽⴰ, ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵙⴽⵔ false. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⴼⵍⴷ ⵎⴽ ⴳ ⴽⵔⴰ ⵏ ⵜⴰⵙⴳⴰ ⵢⴰⴳⴳⵡⴰⵔ ⵓⵎⵉⴹⴰⵏ ⵏ ⵓⴽⵓⵏⵟⵓⵔ ⵏⴽ ⴷⴷⴰⵡ ⵏ ⵓⵎⵢⴰ, ⴷ \/\/ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵉⴳⴰⵏ ⵏ ⵜⵎⴳⴳⵉⵜⵉⵏ ⵏ ⵓⵙⵙⴰⵔⵓ ⴷ ⵓⵙⵙⴰⵢ ⴳ ⵢⴰⵏ ⵓⴽⵓⵏⵟⵓⵔ ⵏ ⵍⴱⴰⵏⴽ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵙ \/\/\/ >>> below_zero(operations: [1, 2, 3])\n\/\/\/ false\n\/\/\/ >>> below_zero(operations: [1, 2, -4, 5])\n\/\/\/ true\nfunc below_zero(operations: [Int]) -> Bool {\n","canonical_solution":"func below_zero(operations: [Int]) -> Bool {\n    var balance = 0\n    for operation in operations {\n        balance += operation\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(below_zero(operations: [] as [Int]) == false)\nassert(below_zero(operations: [1, 2, -3, 1, 2, -3]) == false)\nassert(below_zero(operations: [1, 2, -4, 5, 6]) == true)\nassert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -4]) == false)\nassert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -5]) == true)\nassert(below_zero(operations: [1, -2, 2, -2, 5, -5, 4, -4]) == true)"},{"task_id":"HumanEval_4","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ MAD = ⴰⵙⵖⵏ. x - x_mean. \/\/ ⴰⵙⴽⴽⵉⵍ ⴷ ⵜⵏⵇⵇⵉⴹⵜ ⵜⴰⵏⴰⵎⵎⴰⵙⵜ (ⴰⵎⵎⴰⵙⵙ ⴳ ⵡⴰⴷⴷⴰⴷ ⴰⴷ): \/\/ ⴰⵎⵣⴰⵔⴰⵢ ⴰⵖⴰⵔⴰⵏ ⴰⵎⵎⵉⴷ ⵉⴳⴰ ⴰⵎⵣⴰⵔⴰⵢ ⴰⵖⴰⵔⴰⵏ ⴰⵎⵏⵉⴳ ⴳⵔ ⴽⵓ \/\/ ⴰⵜⵜⴰⵢⵏ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵜⵔⴰⴱⴱⵓⵜ ⵏ ⵉⵏⵖⵎⵉⵙⵏ ⴰⴷ. \/\/ ⵉ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵏ ⵓⴽⵛⵛⵓⵎ, ⵙⵙⵉⴹⵏ ⴰⵎⵏⵣⴰⵢ ⴰⵖⴰⵔⴰⵏ \/\/\/ >>> mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0])\n\/\/\/ 1.0\nfunc mean_absolute_deviation(numbers: [Double]) -> Double {\n","canonical_solution":"func mean_absolute_deviation(numbers: [Double]) -> Double {\n    guard !numbers.isEmpty else { return 0.0 }\n    \n    let mean = numbers.reduce(0.0, +) \/ Double(numbers.count)\n    let absoluteDifferences = numbers.map { abs($0 - mean) }\n    let mad = absoluteDifferences.reduce(0.0, +) \/ Double(absoluteDifferences.count)\n    \n    return mad\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(mean_absolute_deviation(numbers: [1.0, 2.0]) == 0.5)\nassert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0]) == 1.0)\nassert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2)"},{"task_id":"HumanEval_5","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙⵙⴽⵛⵎ ⴰⵎⴹⴰⵏ \"ⴷⵉⵍⵉⵜⵔ\" ⴳⵔ ⴽⵓ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⴹⴼⴰⵕⵏ ⵏ ⵓⵎⵙⴷⵉ ⵏ ⵓⵙⴽⵛⵎ \"ⴹⵉⵍⵉⵜⵔ\" \/\/\/ >>> intersperse(numbers: [] as [Int], delimeter: 4)\n\/\/\/ [] as [Int]\n\/\/\/ >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\/\/\/ [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n","canonical_solution":"func intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n    guard !numbers.isEmpty else { return [] }\n    \n    var result: [Int] = []\n    \n    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n    }\n    \n    \/\/ Remove the last added delimiter\n    result.removeLast()\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"},{"task_id":"HumanEval_6","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ (() (()) ⵖⵓⵔⵙ ⵙⵉⵏ ⵉⵙⵡⵉⵔⵏ ⵏ ⵓⵖⵔⵔⴰⴱⵓ ⴳ ⵜⵉⵣⵉ ⵏⵏⴰ ⴳ ((())) ⵖⵓⵔⵙ ⴽⵕⴰⴹ. \/\/ ⵉ ⴽⵓ ⵢⴰⵏ ⴳ ⵜⵔⴰⴱⴱⵓⵜ, ⵙⵙⵓⴼⵖ ⴰⵙⵡⵉⵔ ⵏ ⵓⵙⵎⵓⵏ ⵏ ⵜⴱⵕⴰⵏⴽⵉⵙⵜⵉⵏ. \/\/ ⴰⵙⴽⵛⵎ ⵏ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵜⵓⵎ ⵉⵙⵎⴷⵢⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵉ ⵜⴱⵕⴰⵏⴽⵉⵙⵉⵏ ⵉⵜⵜⵓⵙⵏⵎⵍⴰⵏ ⵉⵜⵜⵓⵣⵍⴰⵢⵏ ⵙ ⵉⵎⵏⵉⴷⵏ. \/\/\/ >>> parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\")\n\/\/\/ [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String) -> [Int] {\n","canonical_solution":"func parse_nested_parens(paren_string: String) -> [Int] {\n    let groups = paren_string.split(separator: \" \")\n    var depths: [Int] = []\n    \n    for group in groups {\n        var maxDepth = 0\n        var currentDepth = 0\n        \n        for char in group {\n            if char == \"(\" {\n                currentDepth += 1\n                if currentDepth > maxDepth {\n                    maxDepth = currentDepth\n                }\n            } else if char == \")\" {\n                currentDepth -= 1\n            }\n        }\n        \n        depths.append(maxDepth)\n    }\n    \n    return depths\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\") == [4])"},{"task_id":"HumanEval_7","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙⵙⵓⴼⵖ ⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵅⵙ ⵡⵉⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵉⵣⵉⵏ \/\/\/ >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n\/\/\/ [] as [String]\n\/\/\/ >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n\/\/\/ [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n","canonical_solution":"func filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter { $0.contains(substring) }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"},{"task_id":"HumanEval_8","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵓⵎⴹⴰⵏ ⵏ ⵜⴷⵔⴼⵉ ⴰⵎⵢⴰ 0 ⴷ ⵓⵙⴼⴰⵔ ⵏ ⵜⴷⵔⴼⵉ ⴰⵎⵢⴰ 1. \/\/ ⵉ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴰⴷ ⵏⵔⴰⵔ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵖⵣⵓ ⴷ ⵓⵙⵢⴰⴼⵓ ⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵙⵏⵙⵍ. \/\/\/ >>> sum_product(numbers: [] as [Int])\n\/\/\/ (0, 1)\n\/\/\/ >>> sum_product(numbers: [1, 2, 3, 4])\n\/\/\/ (10, 24)\nfunc sum_product(numbers: [Int]) -> (Int, Int) {\n","canonical_solution":"func sum_product(numbers: [Int]) -> (Int, Int) {\n    let sum = numbers.reduce(0, +)\n    let product = numbers.reduce(1, *)\n    return (sum, product)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_product(numbers: [] as [Int]) == (0, 1))\nassert(sum_product(numbers: [1, 1, 1]) == (3, 1))\nassert(sum_product(numbers: [100, 0]) == (100, 0))\nassert(sum_product(numbers: [3, 5, 7]) == (15, 105))\nassert(sum_product(numbers: [10]) == (10, 10))"},{"task_id":"HumanEval_9","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴳ ⵓⵙⵓⵔⵙ. \/\/ ⵙⴳ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵓⴽⵜⵜⴰⵢ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵢⴰⴼⴰⵏ ⴰⵔ ⵜⵉⵣⵉ ⵏⵏⴰ ⵔⴰⴷ ⵉⵜⵜⵢⴰⴼⴰ.\/\/\/ >>> rolling_max(numbers: [1, 2, 3, 2, 3, 4, 2])\n\/\/\/ [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int]) -> [Int] {\n","canonical_solution":"func rolling_max(numbers: [Int]) -> [Int] {\n    var result = [Int]()\n    var currentMax: Int? = nil\n    for number in numbers {\n        if let max = currentMax {\n            currentMax = max > number ? max : number\n        } else {\n            currentMax = number\n        }\n        result.append(currentMax!)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"},{"task_id":"HumanEval_10","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ - ⵙⵙⵎⵓⵏ ⴳ ⵜⴳⵉⵔⴰ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵓⵣⵡⵍ ⵏⵏⴰ ⵉⵜⵜⵓⵢⴰⵍⵙⵏ ⴷⴰⵜ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵓⴱⴰⵍⵉⵏⴷⵔⵓⵎ. \/\/ - ⵥⵕ ⵜⴰⴳⵓⵔⵉ ⵜⴰⵖⵣⵉⴼⵜ ⵏ ⵓⵖⵉⵍⵓⴼ ⵉⵜⵜⵓⵢⴰⴼⴰⵏ ⵏⵏⴰ ⵉⴳⴰⵏ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ. \/\/ ⵜⴰⵡⵏⴳⵉⵎⵜ ⵏ ⴰⵍⴳⵓⵔⵉⵜⵎ ⵜⴳⴰ ⵜⵣⵔⴼⴰⵏⵜ: \/\/ ⵥⵕ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ ⵜⴰⵔⵓⵙⵜ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵙ ⵢⴰⵏ ⵓⵖⵉⵍⵓⴼ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ. \/\/\/ >>> make_palindrome(string: \"\")\n\/\/\/ \"\"\n\/\/\/ >>> make_palindrome(string: \"cat\")\n\/\/\/ \"catac\"\n\/\/\/ >>> make_palindrome(string: \"cata\")\n\/\/\/ \"catac\"\nfunc make_palindrome(string: String) -> String {\n","canonical_solution":"func make_palindrome(string: String) -> String {\n    func isPalindrome(_ s: String) -> Bool {\n        return s == String(s.reversed())\n    }\n    \n    if string.isEmpty || isPalindrome(string) {\n        return string\n    }\n    \n    for i in stride(from: string.count, through: 0, by: -1) {\n        let suffixIndex = string.index(string.startIndex, offsetBy: i)\n        let suffix = String(string[suffixIndex..<string.endIndex])\n        if isPalindrome(suffix) {\n            let prefix = String(string[string.startIndex..<suffixIndex])\n            return string + String(prefix.reversed())\n        }\n    }\n    \n    return string\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"},{"task_id":"HumanEval_11","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙⴽⵔ XOR ⴱⵉⵏⴰⵔⵉ ⵅⴼ ⵉⵙⴽⴽⵉⵍⵏ ⴰⴷ ⵏ ⵓⵙⴽⵛⵎ ⴷ ⵜⵔⴰⵔⵓⵜ ⵏ ⵜⵢⴰⴼⵓⵜ ⴰⵡⴷ ⵙ ⵜⴰⵍⵖⴰ. \/\/ ⴰⵙⴽⵛⵎ ⴳⴰⵏ ⵙⵏⴰⵜ ⵜⵣⵍⵖⵉⵡⵉⵏ a ⴷ b ⴳ ⵍⵍⴰⵏⵜ 1 ⴷ 0 ⵅⴰⵙ.\/\/\/ >>> string_xor(a: \"010\", b: \"110\")\n\/\/\/ \"100\"\nfunc string_xor(a: String, b: String) -> String {\n","canonical_solution":"func string_xor(a: String, b: String) -> String {\n    let charactersA = Array(a)\n    let charactersB = Array(b)\n    var result = \"\"\n\n    for i in 0..<charactersA.count {\n        let bitA = charactersA[i]\n        let bitB = charactersB[i]\n        \n        if bitA != bitB {\n            result.append(\"1\")\n        } else {\n            result.append(\"0\")\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"},{"task_id":"HumanEval_12","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵜⵉⴼⵉⵏⴰⵖ ⵏ ⵜⵉⵖⵣⵉ ⵉⵎⵎⵔⵡⴰⵙⵏ. ⵔⴰⴷ ⵏⵔⴰⵔ nil ⴳ ⵡⴰⴷⴷⴰⴷ ⵏ ⵓⵙⵏⵙⵉ ⵏ ⵓⵙⴽⵛⵎ ⵉⴳⴰⵏ ⵡⴰⴽⴰⵍ. \/\/ ⵙⴳ ⵓⵎⵙⴰⵙⴰ ⵏ ⵉⵙⴽⴽⵉⵍⵏ, ⵙⵙⵓⴼⵖ ⴰⵎⵣⵡⴰⵔⵓ ⴳ ⵡⴰⴷⴷⴰⴷ ⵏ ⴽⵉⴳⴰⵏ \/\/\/ >>> longest(strings: [] as [String])\n\/\/\/ nil\n\/\/\/ >>> longest(strings: [\"a\", \"b\", \"c\"])\n\/\/\/ \"a\"\n\/\/\/ >>> longest(strings: [\"a\", \"bb\", \"ccc\"])\n\/\/\/ \"ccc\"\nfunc longest(strings: [String]) -> String? {\n","canonical_solution":"func longest(strings: [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n    var longestString = strings[0]\n    for string in strings {\n        if string.count > longestString.count {\n            longestString = string\n        }\n    }\n    return longestString\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"},{"task_id":"HumanEval_13","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⴷ ⵏⵔⴰⵔ ⴰⵎⵟⵟⵓ ⴰⵎⵛⵛⴰⵔⵏ ⴰⵅⴰⵜⴰⵔ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⴷ b \/\/\/ >>> greatest_common_divisor(a: 3, b: 5)\n\/\/\/ 1\n\/\/\/ >>> greatest_common_divisor(a: 25, b: 15)\n\/\/\/ 5\nfunc greatest_common_divisor(a: Int, b: Int) -> Int {\n","canonical_solution":"func greatest_common_divisor(a: Int, b: Int) -> Int {\n    if b == 0 {\n        return a\n    } else {\n        return greatest_common_divisor(a: b, b: a % b)\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(greatest_common_divisor(a: 3, b: 7) == 1)\nassert(greatest_common_divisor(a: 10, b: 15) == 5)\nassert(greatest_common_divisor(a: 49, b: 14) == 7)\nassert(greatest_common_divisor(a: 144, b: 60) == 12)"},{"task_id":"HumanEval_14","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⴰⵙⵏⵙⵍ ⵏ ⴽⵓⵍⵍⵓ ⵉⵙⵏⴼⴰⵔⵏ ⵙⴳ ⵓⵥⵥⵉⴹⵕ ⴰⵔ ⵓⵣⵣⵓⵣⵔ ⵏ ⵜⵣⵍⵉⵜ ⵏ ⵓⵙⴽⵛⵎ \/\/\/ >>> all_prefixes(string: \"abc\")\n\/\/\/ [\"a\", \"ab\", \"abc\"]\nfunc all_prefixes(string: String) -> [String] {\n","canonical_solution":"func all_prefixes(string: String) -> [String] {\n    var prefixes: [String] = []\n    for i in 1...string.count {\n        let prefix = String(string.prefix(i))\n        prefixes.append(prefix)\n    }\n    return prefixes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"},{"task_id":"HumanEval_15","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵜⵜⵓⵙⵏⴽⴰⴷⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ ⴳ ⵓⵎⵣⵡⴰⵔⵓ ⵙⴳ 0 ⴰⵔ n. \/\/\/ >>> string_sequence(n: 0)\n\/\/\/ \"0\"\n\/\/\/ >>> string_sequence(n: 5)\n\/\/\/ \"0 1 2 3 4 5\"\nfunc string_sequence(n: Int) -> String {\n","canonical_solution":"func string_sequence(n: Int) -> String {\n    return (0...n).map { String($0) }.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_sequence(n: 0) == \"0\")\nassert(string_sequence(n: 3) == \"0 1 2 3\")\nassert(string_sequence(n: 10) == \"0 1 2 3 4 5 6 7 8 9 10\")"},{"task_id":"HumanEval_16","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵖⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵙⵙⵏⴼⵍ ⵎⵏⵏⴰⵡ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ (ⵓⵔ ⵉⵥⵍⵉ ⵙ ⵡⴰⴷⴷⴰⴷ) ⵉⵙ ⴷⴰⵔⵙ \/\/\/ >>> count_distinct_characters(string: \"xyzXYZ\")\n\/\/\/ 3\n\/\/\/ >>> count_distinct_characters(string: \"Jerry\")\n\/\/\/ 4\nfunc count_distinct_characters(string: String) -> Int {\n","canonical_solution":"func count_distinct_characters(string: String) -> Int {\n    let lowercasedString = string.lowercased()\n    let distinctCharacters = Set(lowercasedString)\n    return distinctCharacters.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_distinct_characters(string: \"\") == 0)\nassert(count_distinct_characters(string: \"abcde\") == 5)\nassert(count_distinct_characters(string: \"abcdecadeCADE\") == 5)\nassert(count_distinct_characters(string: \"aaaaAAAAaaaa\") == 1)\nassert(count_distinct_characters(string: \"Jerry jERRY JeRRRY\") == 5)"},{"task_id":"HumanEval_17","nl":"tzm_Tfng","pl":"swift","prompt":"\n\" 'ⴽⵓⴹⴰⴽⴰ \" ' - ⴰⵖⵓⵢⵢⵉ ⵏ ⴽⴽⵓⵥ, ⵉⵇⵇⵉⵎ ⵢⴰⵏ ⵓⴽⵓⴷ \"oǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧoǧ\"o\" - ⴰⵖⵏⵏⵉⵊ ⴰⴽⴽⵡ, ⴷⴰ ⵉⵜⵜⴳⴳⴰⵔ ⴽⴽⵓⵥ ⵏ ⵉⵔⵖⴰⵏ \/\/ ⵀⴰ ⵢⴰⵏ ⵓⵎⵣⵔⵓⵢ: \/ ⵓⵔ ⴷ ⴰⵎⴳⴳⴰⵔⵓ.\/\/ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴼⵙⵉ ⵜⴰⵡⴰⵍⵜ ⴰⴷ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⴰⵙⵏⵙⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵉⴽⴽ ⵏ ⴽⵓ ⵢⴰⵏ \/\/ ⴰⵙⴽⵛⵎ ⵏ ⵜⵡⵓⵔⵉ ⴰⴷ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵜⵓⵎ ⵉⵙⵎⴷⵢⴰⵏ ⵜⵉⵙⵏⴰⵜⵉⵏ ⵏ ⵓⵥⴰⵡⴰⵏ ⵙ ⵢⴰⵜ ⵜⵍⵖⴰ ⵏ ASCII ⵉⵥⵍⵉⵏ. \/\/\/ >>> parse_music(music_string: \"o o| .| o| o| .| .| .| .| o o\")\n\/\/\/ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string: String) -> [Int] {\n","canonical_solution":"func parse_music(music_string: String) -> [Int] {\n    let notes = music_string.split(separator: \" \")\n    var beats: [Int] = []\n    \n    for note in notes {\n        switch note {\n        case \"o\":\n            beats.append(4)\n        case \"o|\":\n            beats.append(2)\n        case \".|\":\n            beats.append(1)\n        default:\n            continue\n        }\n    }\n    \n    return beats\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"},{"task_id":"HumanEval_18","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵥⵕ ⵎⵏⵏⴰⵡⵜ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵥⴹⴰⵕ ⴰⴷ ⵢⴰⴼ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵎⵣⵡⴰⵔⵓ ⴳ ⵓⵡⵉⴽⵉ ⴰⵎⵣⵡⴰⵔⵓ. ⵥⵕ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵉⵜⵜⵎⵙⴰⵙⴰⵏ.\/\/\/ >>> how_many_times(string: \"\", substring: \"a\")\n\/\/\/ 0\n\/\/\/ >>> how_many_times(string: \"aaa\", substring: \"a\")\n\/\/\/ 3\n\/\/\/ >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n\/\/\/ 3\nfunc how_many_times(string: String, substring: String) -> Int {\n","canonical_solution":"func how_many_times(string: String, substring: String) -> Int {\n    guard !substring.isEmpty else { return 0 }\n    \n    var count = 0\n    var startIndex = string.startIndex\n    \n    while let range = string.range(of: substring, range: startIndex..<string.endIndex) {\n        count += 1\n        startIndex = string.index(after: range.lowerBound)\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"},{"task_id":"HumanEval_19","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵉⵎⴹⴰⵏⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙⴳ ⵉⵎⵥⵥⵢⴰⵏⵏ ⴰⵔ ⵉⵎⵇⵇⵔⴰⵏⵏ \/\/ ⵉⵙⵜⴰⵢⵏ ⵉⵣⵔⴼⴰⵏ ⴳⴰⵏ 'ⵙⵢⴰ', 'ⵢⵉⵡⵏ', ' ⵙⵉⵏ', ' ⴽⵕⴰⴹ', ' ⴽⴽⵓⵥ', ' ⵙⵎⵎⵓⵙ', 'ⵚⴹⵉⵚ', 'ⴰⵙⵙⴰ', 'ⴰⵙⴰ' ⴷ 'ⴰⵥⴰ'. \/\/ ⴰⵙⴽⵛⵎ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ \"ⵙⵢⴰ\" ⴰⵔ \"ⵜⵥⴰ\".\/\/\/ >>> sort_numbers(numbers: \"three one five\")\n\/\/\/ \"one three five\"\nfunc sort_numbers(numbers: String) -> String {\n","canonical_solution":"func sort_numbers(numbers: String) -> String {\n    \/\/ Mapping of word numbers to digits\n    let numberWords: [String: Int] = [\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    ]\n\n    \/\/ Split the input string into words\n    let words = numbers.split(separator: \" \")\n\n    \/\/ Sort the words based on their corresponding number values\n    let sortedWords = words.sorted { \n        numberWords[String($0)]! < numberWords[String($1)]! \n    }\n\n    \/\/ Join the sorted words back into a single string\n    return sortedWords.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_numbers(numbers: \"\") == \"\")\nassert(sort_numbers(numbers: \"three\") == \"three\")\nassert(sort_numbers(numbers: \"three five nine\") == \"three five nine\")\nassert(sort_numbers(numbers: \"five zero four seven nine eight\") == \"zero four five seven eight nine\")\nassert(sort_numbers(numbers: \"six five four three two one zero\") == \"zero one two three four five six\")"},{"task_id":"HumanEval_20","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵡⵉⵢⵢⴰⴹ ⴷ ⴰⵔ ⵜⵜ ⵏⵙⵙⴽⵛⵎ ⵙ ⵓⴹⴼⴼⵓⵕ (ⵉⴹ ⴰⵎⵥⵥⵢⴰⵏ, ⵓⴹⴼⵓⵕ ⴰⵎⵇⵔⴰⵏ).\/\/ ⵙⴳ ⵓⵎⵙⴷⵉ ⵏ ⵡⵓⵟⵟⵓⵏⵏ (ⵙ ⵓⴳⴳⴰⵔ ⵏ ⵙⵉⵏ) ⵉⵙⵜⴰⵢ ⴷ ⵢⴰⴽⴽⴰ ⵙⵉⵏ ⵏⵏⴰ ⵢⵜⵜⵎⴰⵥⵏ ⴽⵓ ⵢⴰⵏ \/\/\/ >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/\/ (2.0, 2.2)\n\/\/\/ >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/\/ (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n","canonical_solution":"func find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    \/\/ Sort the array to bring closest numbers next to each other\n    let sortedNumbers = numbers.sorted()\n    \n    \/\/ Initialize variables to keep track of the smallest difference and the pair\n    var minDifference = Double.greatestFiniteMagnitude\n    var closestPair: (Double, Double) = (0.0, 0.0)\n    \n    \/\/ Iterate over the sorted numbers to find the smallest difference\n    for i in 0..<sortedNumbers.count - 1 {\n        let num1 = sortedNumbers[i]\n        let num2 = sortedNumbers[i + 1]\n        let difference = abs(num1 - num2)\n        \n        if difference < minDifference {\n            minDifference = difference\n            closestPair = (num1, num2)\n        }\n    }\n    \n    return closestPair\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"},{"task_id":"HumanEval_21","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵢⵏⵏⴰⵖ ⴰⵙ ⴰⵎⴹⴰⵏ ⴰⵎⵥⵥⵢⴰⵏ ⴰⴷ ⵉⴳⴰⵏ 0 ⴷ ⴰⵎⴹⴰⵏ ⴰⵎⵇⵔⴰⵏ ⴰⴷ ⵉⴳⴰⵏ 1 \/\/ ⴰⵟⵟⴰⵙ ⵏ ⵡⵓⵟⵟⵓⵏⵏ (ⵙ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⴷⵖⴰⵔ), ⵙⵙⵎⵔⵙⵏ ⴰⵙⵏⴼⵍ ⴰⵎⵏⵣⵓ ⵉ ⵓⵙⵏⴼⵍ ⴰⴷ, \/\/\/ >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/\/ [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n","canonical_solution":"func rescale_to_unit(numbers: [Double]) -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    \n    let minValue = numbers.min()!\n    let maxValue = numbers.max()!\n    let range = maxValue - minValue\n    \n    guard range != 0 else {\n        return numbers.map { _ in 0.0 }\n    }\n    \n    return numbers.map { ($0 - minValue) \/ range }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"},{"task_id":"HumanEval_22","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙⵙⵓⴼⵖ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⴽⵔⴰ ⵏ ⵡⴰⵜⵉⴳⵏ ⵏ ⵙⵡⵉⴼⵜⵜⵓⵏ ⵖⴰⵙ ⵉ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ \/\/\/ >>> filter_integers(values: [\"a\", 3.14, 5])\n\/\/\/ [5]\n\/\/\/ >>> filter_integers(values: [1, 2, 3, \"abc\", [:] as [AnyHashable : AnyHashable], [] as [AnyHashable]])\n\/\/\/ [1, 2, 3]\nfunc filter_integers(values: [AnyHashable]) -> [Int] {\n","canonical_solution":"func filter_integers(values: [AnyHashable]) -> [Int] {\n    return values.compactMap { $0 as? Int }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_integers(values: [] as [AnyHashable]) == [] as [Int])\nassert(filter_integers(values: [4, [:] as [AnyHashable : AnyHashable], [] as [AnyHashable], 23.2, 9, \"adasd\"]) == [4, 9])\nassert(filter_integers(values: [3, \"c\", 3, 3, \"a\", \"b\"]) == [3, 3, 3])"},{"task_id":"HumanEval_23","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⴷ ⵉⵔⴰⵔ ⵜⵉⵖⵣⵉ ⵏ ⵜⵉⴼⵉⵏⴰⵖ \/\/\/ >>> strlen(string: \"\")\n\/\/\/ 0\n\/\/\/ >>> strlen(string: \"abc\")\n\/\/\/ 3\nfunc strlen(string: String) -> Int {\n","canonical_solution":"func strlen(string: String) -> Int {\n    return string.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(strlen(string: \"\") == 0)\nassert(strlen(string: \"x\") == 1)\nassert(strlen(string: \"asdasnakj\") == 9)"},{"task_id":"HumanEval_24","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉ ⵓⵎⴹⴰⵏ n, ⵥⵕ ⴰⵎⴹⴰⵏ ⴰⵅⴰⵜⴰⵔ ⵏⵏⴰ ⵉⵜⵜⴱⴹⵓⵏ n ⵙ ⵉⵎⵉⴽ, ⴷ ⵉⵎⵥⵥⵉⵏ ⵓⴳⴳⴰⵔ ⵏ n \/\/\/ >>> largest_divisor(n: 15)\n\/\/\/ 5\nfunc largest_divisor(n: Int) -> Int {\n","canonical_solution":"func largest_divisor(n: Int) -> Int {\n    for i in stride(from: n \/ 2, to: 0, by: -1) {\n        if n % i == 0 {\n            return i\n        }\n    }\n    return 1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_divisor(n: 3) == 1)\nassert(largest_divisor(n: 7) == 1)\nassert(largest_divisor(n: 10) == 5)\nassert(largest_divisor(n: 100) == 50)\nassert(largest_divisor(n: 49) == 7)"},{"task_id":"HumanEval_25","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⵙⴽⵛⵎ ⴰⵎⵢⴰⴼⵓ ⵏ ⴽⵓⵍⵍⵓ ⵉⵎⴳⴳⵉⵜⵏ \/\/ ⴽⵓ ⵢⴰⵏ ⴳ ⵉⵎⴳⴳⵉⵜⵏ ⴰⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰ ⵙ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⴷⴰ ⵉⵜⵜⵓⴳⴰ ⴳ ⵓⵙⴼⵙⵔ. \/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⴰⵙⵏⵙⵍ ⵏ ⵉⵎⴳⴳⵉⵜⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵙⵙⵓⴷⵙ ⵙⴳ ⵉⵎⵥⵥⵉⵏ ⴰⵔ ⵉⵎⵇⵇⵔⴰⵏ. \/\/\/ >>> factorize(n: 8)\n\/\/\/ [2, 2, 2]\n\/\/\/ >>> factorize(n: 25)\n\/\/\/ [5, 5]\n\/\/\/ >>> factorize(n: 70)\n\/\/\/ [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n","canonical_solution":"func factorize(n: Int) -> [Int] {\n    guard n > 1 else { return [] }\n    var number = n\n    var factors: [Int] = []\n    var divisor = 2\n    \n    while number >= divisor {\n        while number % divisor == 0 {\n            factors.append(divisor)\n            number \/= divisor\n        }\n        divisor += 1\n    }\n    \n    return factors\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"},{"task_id":"HumanEval_26","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵃⴹⵓ ⵓⵍⵓⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵙ ⵓⵍⵓⴳ ⵏ ⵓⵙⴽⵛⵎ. \/\/ ⵙⴳ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⴽⵓⵍⵍⵓ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵉⵜⵜⵊⵕⴰⵏ ⵓⴳⴳⴰⵔ ⵏ ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ. \/\/\/ >>> remove_duplicates(numbers: [1, 2, 3, 2, 4])\n\/\/\/ [1, 3, 4]\nfunc remove_duplicates(numbers: [Int]) -> [Int] {\n","canonical_solution":"func remove_duplicates(numbers: [Int]) -> [Int] {\n    var elementCount = [Int: Int]()\n    for number in numbers {\n        elementCount[number, default: 0] += 1\n    }\n    return numbers.filter { elementCount[$0] == 1 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_duplicates(numbers: [] as [Int]) == [] as [Int])\nassert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"},{"task_id":"HumanEval_27","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉ ⵢⴰⵏ ⵓⴽⵜⵓⵎ, ⵙⵙⵓⵜⵍ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵉⵏ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴷ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵉⵏⵏ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵉⵏⵏ. \/\/\/ >>> flip_case(string: \"Hello\")\n\/\/\/ \"hELLO\"\nfunc flip_case(string: String) -> String {\n","canonical_solution":"func flip_case(string: String) -> String {\n    return String(string.map { character in\n        if character.isLowercase {\n            return character.uppercased()\n        } else if character.isUppercase {\n            return character.lowercased()\n        } else {\n            return String(character)\n        }\n    }.joined())\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(flip_case(string: \"\") == \"\")\nassert(flip_case(string: \"Hello!\") == \"hELLO!\")\nassert(flip_case(string: \"These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")"},{"task_id":"HumanEval_28","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵙⵎⵓⵏ ⵏ ⵜⵓⴳⵜ ⵏ ⵉⵙⵉⴹⵏ ⴳ ⵢⴰⵏ ⵓⵙⵉⴹⵏ \/\/\/ >>> concatenate(strings: [] as [String])\n\/\/\/ \"\"\n\/\/\/ >>> concatenate(strings: [\"a\", \"b\", \"c\"])\n\/\/\/ \"abc\"\nfunc concatenate(strings: [String]) -> String {\n","canonical_solution":"func concatenate(strings: [String]) -> String {\n    return strings.joined()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(concatenate(strings: [] as [String]) == \"\")\nassert(concatenate(strings: [\"x\", \"y\", \"z\"]) == \"xyz\")\nassert(concatenate(strings: [\"x\", \"y\", \"z\", \"w\", \"k\"]) == \"xyzwk\")"},{"task_id":"HumanEval_29","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵓⵙⴽⵛⵎ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⵉⵙⵙⵏⵜⵉⵢⵏ ⵙ ⵢⴰⵏ ⵓⵙⴽⴽⵉⵍ ⵏ ⵓⵙⵏⵜⵉ. \/\/\/ >>> filter_by_prefix(strings: [] as [String], prefix: \"a\")\n\/\/\/ [] as [String]\n\/\/\/ >>> filter_by_prefix(strings: [\"abc\", \"bcd\", \"cde\", \"array\"], prefix: \"a\")\n\/\/\/ [\"abc\", \"array\"]\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String] {\n","canonical_solution":"func filter_by_prefix(strings: [String], prefix: String) -> [String] {\n    return strings.filter { $0.hasPrefix(prefix) }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"},{"task_id":"HumanEval_30","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵖⴰⵙ ⵉⵎⴹⴰⵏ ⵉⵎⵏⵉⴷⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ. \/\/\/ >>> get_positive(l: [-1, 2, -4, 5, 6])\n\/\/\/ [2, 5, 6]\n\/\/\/ >>> get_positive(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ [5, 3, 2, 3, 9, 123, 1]\nfunc get_positive(l: [Int]) -> [Int] {\n","canonical_solution":"func get_positive(l: [Int]) -> [Int] {\n    return l.filter { $0 > 0 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_positive(l: [-1, -2, 4, 5, 6]) == [4, 5, 6])\nassert(get_positive(l: [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])\nassert(get_positive(l: [-1, -2]) == [] as [Int])\nassert(get_positive(l: [] as [Int]) == [] as [Int])"},{"task_id":"HumanEval_31","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ. \/\/\/ >>> is_prime(n: 6)\n\/\/\/ false\n\/\/\/ >>> is_prime(n: 101)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 11)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 13441)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 61)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 4)\n\/\/\/ false\n\/\/\/ >>> is_prime(n: 1)\n\/\/\/ false\nfunc is_prime(n: Int) -> Bool {\n","canonical_solution":"func is_prime(n: Int) -> Bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false\n    }\n    var i = 5\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false\n        }\n        i += 6\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_prime(n: 6) == false)\nassert(is_prime(n: 101) == true)\nassert(is_prime(n: 11) == true)\nassert(is_prime(n: 13441) == true)\nassert(is_prime(n: 61) == true)\nassert(is_prime(n: 4) == false)\nassert(is_prime(n: 1) == false)\nassert(is_prime(n: 5) == true)\nassert(is_prime(n: 11) == true)\nassert(is_prime(n: 17) == true)\nassert(is_prime(n: 85) == false)\nassert(is_prime(n: 77) == false)\nassert(is_prime(n: 255379) == false)"},{"task_id":"HumanEval_33","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉ ⵡⴰⵜⵉⴳⵏ ⵏ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵙⴰⵙⴰⵏ ⵏ l, ⵎⴰⵛⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ. \/\/ l' ⴷⴰ ⵢⴰⴽⵣ l ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵏⵏⴰ ⵓⵔ ⵏⵣⴹⴰⵔ ⴰⴷ ⵏⴱⴹⵓ ⵙ ⴽⵕⴰⴹ, ⵎⴰⵛⴰ ⵜⵉⵏⵉⴳⵉⵏ ⵏⵏⵙ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵏⵏⴰ ⵏⵣⴹⴰⵔ ⴰⴷ ⵏⴱⴹⵓ ⵙ ⴽⵕⴰⴹ ⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ \/\/ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⴷⴰ ⵜⴻⵜⵜⵓⵎⵢⵓⴷⴷⵙ ⴰⵙⵔⵔⵓⵙ l ⴰⵔ ⵜⵔⴰⵔ ⴰⵙⵔⵔⵓⵙ l' ⵣⵓⵏⴷ \/\/\/ >>> sort_third(l: [1, 2, 3])\n\/\/\/ [1, 2, 3]\n\/\/\/ >>> sort_third(l: [5, 6, 3, 4, 8, 9, 2])\n\/\/\/ [2, 6, 3, 4, 8, 9, 5]\nfunc sort_third(l: [Int]) -> [Int] {\n","canonical_solution":"func sort_third(l: [Int]) -> [Int] {\n    \/\/ Collect indices and their values where index is divisible by 3\n    var divisibleByThreeValues: [(index: Int, value: Int)] = []\n    for (index, value) in l.enumerated() where index % 3 == 0 {\n        divisibleByThreeValues.append((index, value))\n    }\n    \n    \/\/ Sort the values that were at the indices divisible by 3\n    let sortedValues = divisibleByThreeValues.map { $0.value }.sorted()\n    \n    \/\/ Create a mutable copy of original array to modify\n    var result = l\n    \n    \/\/ Replace the sorted values back into their original indices\n    for (i, sortedValue) in sortedValues.enumerated() {\n        result[divisibleByThreeValues[i].index] = sortedValue\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5])\nassert(sort_third(l: [5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5])\nassert(sort_third(l: [5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5])\nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1])"},{"task_id":"HumanEval_34","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⵉⵡⴰⵏⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⴳ ⵢⴰⵏ ⵓⵙⵏⵙⵉ \/\/\/ >>> unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ [0, 2, 3, 5, 9, 123]\nfunc unique(l: [Int]) -> [Int] {\n","canonical_solution":"func unique(l: [Int]) -> [Int] {\n    return Array(Set(l)).sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])"},{"task_id":"HumanEval_35","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⵔⵙⴰⵍ ⵏ ⵓⴳⴳⴰⵔ ⴳ ⵓⵎⵙⴳⵏⴰⴼ. \/\/\/ >>> max_element(l: [1, 2, 3])\n\/\/\/ 3\n\/\/\/ >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ 123\nfunc max_element(l: [Int]) -> Int {\n","canonical_solution":"func max_element(l: [Int]) -> Int {\n    guard let max = l.max() else {\n        fatalError(\"Array should not be empty\")\n    }\n    return max\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"},{"task_id":"HumanEval_36","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⴷ ⵢⴰⴽⵣ ⴰⵎⴹⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵜⵜⵓⵢⴰⵔⴰⵏ ⵓⵟⵟⵓⵏ 7 ⴳ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵥⵥⵉⵏ ⵏⵏⴰ ⵓⵔ ⵏⵏⵉⵏ n ⵏⵏⴰ ⵉⵜⵜⵓⵢⴰⵔⴰⵏ ⵙ 11 ⵏⵖ 13. \/\/\/ >>> fizz_buzz(n: 50)\n\/\/\/ 0\n\/\/\/ >>> fizz_buzz(n: 78)\n\/\/\/ 2\n\/\/\/ >>> fizz_buzz(n: 79)\n\/\/\/ 3\nfunc fizz_buzz(n: Int) -> Int {\n","canonical_solution":"func fizz_buzz(n: Int) -> Int {\n    var count = 0\n    for number in 0..<n {\n        if number % 11 == 0 || number % 13 == 0 {\n            var current = number\n            while current > 0 {\n                if current % 10 == 7 {\n                    count += 1\n                }\n                current \/= 10\n            }\n        }\n    }\n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fizz_buzz(n: 50) == 0)\nassert(fizz_buzz(n: 78) == 2)\nassert(fizz_buzz(n: 79) == 3)\nassert(fizz_buzz(n: 100) == 3)\nassert(fizz_buzz(n: 200) == 6)\nassert(fizz_buzz(n: 4000) == 192)\nassert(fizz_buzz(n: 10000) == 639)\nassert(fizz_buzz(n: 100000) == 8026)"},{"task_id":"HumanEval_37","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉ ⵡⴰⵜⵉⴳⵏ ⵏ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏ l, ⵎⴰⵛⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ. \/\/ ⵍ' ⴷⴰ ⵢⴰⴽⵣⵏ ⵉ ⵍ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵎⴰⵛⴰ ⵡⴰⵜⵉⴳⵏ ⵏⵏⵙ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ \/\/ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⴷⴰ ⵜⴻⵜⵜⵓⵎⵢⵓⴷⴷⵙ ⴰⵙⵔⵔⵓⵙ l ⴰⵔ ⵜⵔⴰⵔ ⴰⵙⵔⵔⵓⵙ l' ⵣⵓⵏⴷ \/\/\/ >>> sort_even(l: [1, 2, 3])\n\/\/\/ [1, 2, 3]\n\/\/\/ >>> sort_even(l: [5, 6, 3, 4])\n\/\/\/ [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n","canonical_solution":"func sort_even(l: [Int]) -> [Int] {\n    var evenIndicesValues = [Int]()\n    \n    \/\/ Collect values from even indices\n    for (index, value) in l.enumerated() {\n        if index % 2 == 0 {\n            evenIndicesValues.append(value)\n        }\n    }\n    \n    \/\/ Sort the collected even indices values\n    evenIndicesValues.sort()\n    \n    var result = l\n    var evenIndex = 0\n    \n    \/\/ Replace even-indexed elements in result with sorted values\n    for i in 0..<result.count {\n        if i % 2 == 0 {\n            result[i] = evenIndicesValues[evenIndex]\n            evenIndex += 1\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"},{"task_id":"HumanEval_39","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ prime_fib ⴷⴰ ⵢⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ n-ⵜⵏ ⵡⵉ-ⵏⵏⴰ ⵉⴳⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⴷ ⵉⴳⴰ ⴰⵡⴷ ⴰⵎⵣⵡⴰⵔⵓ. \/\/\/ >>> prime_fib(n: 1)\n\/\/\/ 2\n\/\/\/ >>> prime_fib(n: 2)\n\/\/\/ 3\n\/\/\/ >>> prime_fib(n: 3)\n\/\/\/ 5\n\/\/\/ >>> prime_fib(n: 4)\n\/\/\/ 13\n\/\/\/ >>> prime_fib(n: 5)\n\/\/\/ 89\nfunc prime_fib(n: Int) -> Int {\n","canonical_solution":"func isPrime(_ num: Int) -> Bool {\n    if num <= 1 { return false }\n    if num <= 3 { return true }\n    if num % 2 == 0 || num % 3 == 0 { return false }\n    var i = 5\n    while i * i <= num {\n        if num % i == 0 || num % (i + 2) == 0 {\n            return false\n        }\n        i += 6\n    }\n    return true\n}\n\nfunc generateFibonacci(n: Int) -> [Int] {\n    var fibs = [1, 2]\n    var next = fibs[0] + fibs[1]\n    while fibs.count < n || !isPrime(next) {\n        fibs.append(next)\n        next = fibs[fibs.count - 1] + fibs[fibs.count - 2]\n    }\n    return fibs\n}\n\nfunc prime_fib(n: Int) -> Int {\n    var count = 0\n    var fibs = generateFibonacci(n: n)\n    for fib in fibs {\n        if isPrime(fib) {\n            count += 1\n            if count == n {\n                return fib\n            }\n        }\n    }\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_fib(n: 1) == 2)\nassert(prime_fib(n: 2) == 3)\nassert(prime_fib(n: 3) == 5)\nassert(prime_fib(n: 4) == 13)\nassert(prime_fib(n: 5) == 89)\nassert(prime_fib(n: 6) == 233)\nassert(prime_fib(n: 7) == 1597)\nassert(prime_fib(n: 8) == 28657)\nassert(prime_fib(n: 9) == 514229)\nassert(prime_fib(n: 10) == 433494437)"},{"task_id":"HumanEval_40","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵖⵎⵉⵙ ⵏ ⵓⵎⵢⴰ, ⴷ ⵡⴰⵍⴰ ⵏ ⵓⵢⴰ. \/\/ ⴷⴰ ⵢⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ ⵏⵏⴰ \/\/ triple_sum_to_zero ⴷⴰ ⵉⵜⵜⴰⵙⵉ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ. \/\/\/ >>> triples_sum_to_zero(l: [1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(l: [1, 3, -2, 1])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(l: [1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(l: [1])\n\/\/\/ false\nfunc triples_sum_to_zero(l: [Int]) -> Bool {\n","canonical_solution":"func triples_sum_to_zero(l: [Int]) -> Bool {\n    let count = l.count\n    if count < 3 {\n        return false\n    }\n    \n    let sortedArray = l.sorted()\n    \n    for i in 0..<count - 2 {\n        var left = i + 1\n        var right = count - 1\n        \n        while left < right {\n            let currentSum = sortedArray[i] + sortedArray[left] + sortedArray[right]\n            if currentSum == 0 {\n                return true\n            } else if currentSum < 0 {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triples_sum_to_zero(l: [1, 3, 5, 0]) == false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -1]) == false)\nassert(triples_sum_to_zero(l: [1, 3, -2, 1]) == true)\nassert(triples_sum_to_zero(l: [1, 2, 3, 7]) == false)\nassert(triples_sum_to_zero(l: [1, 2, 5, 7]) == false)\nassert(triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7]) == true)\nassert(triples_sum_to_zero(l: [1]) == false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -100]) == false)\nassert(triples_sum_to_zero(l: [100, 3, 5, -100]) == false)"},{"task_id":"HumanEval_41","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⴷⴰ ⵜⵙⵙⵓⴼⵖ ⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵏⵖⵉ ⴰⴷ. \/\/ ⴳ ⵓⴱⵔⵉⴷ ⵏⵏⵙⵏ ⴰⵎⵎ ⵉⵙ ⵓⵔ ⵜⵜⵓⵥⴹⴰⵕⵏ ⴰⴷ ⵜⵜⵓⵥⴹⴰⵕⵏ. ⵎⴰⵛⴰ, ⵍⵍⴰⵏⵜ ⵜⴽⴰⵔⵉⵏⵉⵏ ⵜⵉⴷⵓⵙⵏⵉⵏ ⴷ ⵉⴷⵓⵙⵏⵉⵏ ⴱⴰⵀⵔⴰ, ⴷ ⵙ ⵡⴰⵢⴰ, ⴰⵔ ⵙⵓⵍ ⵙⵙⵓⴷⵓⵏ.\/\/ ⵍⵍⵉⵖ ⵜⵙⵙⵓⵜⵍ ⵢⴰⵜ ⵜⴽⴰⵔⴹⴰ ⵍⵍⵉ ⵢⵎⵓⵙⵙⵓⵏ ⵙ ⵓⵣⵍⵎⴰⴹ ⵙ ⵓⵣⵔⴼ ⵢⴰⵜ ⵜⴽⴰⵔⴹⴰ ⵍⵍⵉ ⵢⵎⵓⵙⵙⵓⵏ ⵙ ⵓⵣⵔⴼ ⵙ ⵓⵣⵍⵎⴰⴹ. ⵔⴰⴷ ⵏⵉⵏⵉ ⵉⵙ ⴷⴰ ⵜⵜⵎⵓⵙⵙⵓⵏ ⵙⵏⴰⵜ ⵏ ⵜⴽⴰⵔⴹⵉⵡⵉⵏ.ⵔⴰⴷ ⵙⵡⵓⵔⵉⵏ ⵙ ⵓⵣⵔⴼ ⵙ ⵓⵥⵍⵎⴰⴹ. ⵔⴰⴷ ⵙⵏⵓⵍⴼⵓⵏ ⵙⵏⴰⵜ ⵜⵔⵓⴱⴱⴰ ⵏ ⵜⴽⴰⵔⴹⵉⵡⵉⵏ ⵣⵉ ⵡⵣⵔⴼ.\/\/ ⴷⴰ ⵙⵙⵓⴷⵓⵏ n ⵏ ⵜⴽⴰⵔⵉⵏ ⵙⴳ ⵓⵥⵍⵎⴰⴹ ⵖⵔ ⵓⵢⴼⴼⵓⵙ; ⴳ ⵢⴰⵜ ⵜⵉⵣⵉ, ⵜⴰⵔⴰⴱⴱⵓⵜ ⵏ ⵜⴽⴰⵔⵉⵏ ⴹⴰⴹⵏⵉⵏ ⵏ n ⵏ ⵜⴽⴰⵔⵉⵏ \/\/ ⵙⵙⵏⵖ ⵢⴰⵏ ⵓⴱⵔⵉⴷ ⵉⴳⴰⵏ ⵜⴰⵖⴰⵔⴰⵙⵜ ⵜⴰⵣⴳⵣⴰⵡⵜ ⵜⴰⵖⵣⵣⵉⴼⵜ. func car_race_collision(n: Int) -> Int {\n","canonical_solution":"func car_race_collision(n: Int) -> Int {\n    return n\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(car_race_collision(n: 2) == 4)\nassert(car_race_collision(n: 3) == 9)\nassert(car_race_collision(n: 4) == 16)\nassert(car_race_collision(n: 8) == 64)\nassert(car_race_collision(n: 10) == 100)"},{"task_id":"HumanEval_42","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵙ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵢⴰⵔⴰⵏ ⵙ 1. \/\/\/ >>> incr_list(l: [1, 2, 3])\n\/\/\/ [2, 3, 4]\n\/\/\/ >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n","canonical_solution":"func incr_list(l: [Int]) -> [Int] {\n    return l.map { $0 + 1 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"},{"task_id":"HumanEval_43","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵖⵎⵉⵙ ⵏ ⵓⵎⵢⴰ, ⴷ ⵡⴰⵍⴰ ⵏ ⵓⵢⴰ. \/\/ ⴷⴰ ⵢⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ ⵏⵏⴰ \/\/ pairs_sum_to_zero ⴷⴰ ⵉⵜⵜⴰⵙⵉ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ. \/\/\/ >>> pairs_sum_to_zero(l: [1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [1, 3, -2, 1])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7])\n\/\/\/ true\n\/\/\/ >>> pairs_sum_to_zero(l: [1])\n\/\/\/ false\nfunc pairs_sum_to_zero(l: [Int]) -> Bool {\n","canonical_solution":"func pairs_sum_to_zero(l: [Int]) -> Bool {\n    var set = Set<Int>()\n    for num in l {\n        if set.contains(-num) {\n            return true\n        }\n        set.insert(num)\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pairs_sum_to_zero(l: [1, 3, 5, 0]) == false)\nassert(pairs_sum_to_zero(l: [1, 3, -2, 1]) == false)\nassert(pairs_sum_to_zero(l: [1, 2, 3, 7]) == false)\nassert(pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7]) == true)\nassert(pairs_sum_to_zero(l: [1]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 30]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 31]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 30]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 31]) == false)"},{"task_id":"HumanEval_44","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴹⴰⵏⵏ ⵏ ⵜⵔⵙⴰⵍ ⵎⵥⵥⵉⵢⵏ ⴳ 10 \/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⴰⵙⵎⴷⵢⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵏⴼⵍ. \/\/ ⵙⵏⴼⵍ ⵜⴰⵙⵉⵍⴰ ⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵛⵛⵓⵎ x ⵙ ⵜⴰⵙⵉⵍⴰ. \/\/\/ >>> change_base(x: 8, base: 3)\n\/\/\/ \"22\"\n\/\/\/ >>> change_base(x: 8, base: 2)\n\/\/\/ \"1000\"\n\/\/\/ >>> change_base(x: 7, base: 2)\n\/\/\/ \"111\"\nfunc change_base(x: Int, base: Int) -> String {\n","canonical_solution":"func change_base(x: Int, base: Int) -> String {\n    guard base > 1 && base < 10 else {\n        return \"\"\n    }\n    \n    var number = x\n    var result = \"\"\n    \n    repeat {\n        let remainder = number % base\n        result = \"\\(remainder)\" + result\n        number \/= base\n    } while number > 0\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(change_base(x: 8, base: 3) == \"22\")\nassert(change_base(x: 9, base: 3) == \"100\")\nassert(change_base(x: 234, base: 2) == \"11101010\")\nassert(change_base(x: 16, base: 2) == \"10000\")\nassert(change_base(x: 8, base: 2) == \"1000\")\nassert(change_base(x: 7, base: 2) == \"111\")\nassert(change_base(x: 2, base: 3) == \"2\")\nassert(change_base(x: 3, base: 4) == \"3\")\nassert(change_base(x: 4, base: 5) == \"4\")\nassert(change_base(x: 5, base: 6) == \"5\")\nassert(change_base(x: 6, base: 7) == \"6\")\nassert(change_base(x: 7, base: 8) == \"7\")"},{"task_id":"HumanEval_45","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵖⵣⵉ ⵏ ⵓⴳⴰⴼⴰ ⴷ ⵢⵉⴳⵔ ⵏ ⵓⴽⵎⵓⵔ ⵏ ⵓⴽⵎⵓⵔ ⵏ ⵢⴰⵏ ⵓⴽⵕⴰⴹ. \/\/\/ >>> triangle_area(a: 5, h: 3)\n\/\/\/ 7.5\nfunc triangle_area(a: Int, h: Int) -> Double {\n","canonical_solution":"func triangle_area(a: Int, h: Int) -> Double {\n    return 0.5 * Double(a) * Double(h)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(a: 5, h: 3) == 7.5)\nassert(triangle_area(a: 2, h: 2) == 2.0)\nassert(triangle_area(a: 10, h: 8) == 40.0)"},{"task_id":"HumanEval_46","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵉⴹⵏ ⴰⵎⵏⵣⵓ ⵡⵉⵙⵙ n ⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ fib4. ⵓⵔ ⵜⵙⵙⵎⵔⵙ ⴰⵙⵏⵓⵍⴼⵓ. \/\/ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). \/\/ fib4(3) -> 0 \/\/ fib4(2) -> 2 \/\/ fib4(1) -> 0 \/\/ fib4(0) -> 0 \/\/ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ Fib4 ⵜⴳⴰ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵣⵓⵏⴷ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ: \/\/\/ >>> fib4(n: 5)\n\/\/\/ 4\n\/\/\/ >>> fib4(n: 6)\n\/\/\/ 8\n\/\/\/ >>> fib4(n: 7)\n\/\/\/ 14\nfunc fib4(n: Int) -> Int {\n","canonical_solution":"func fib4(n: Int) -> Int {\n    if n == 0 || n == 1 || n == 3 {\n        return 0\n    } else if n == 2 {\n        return 2\n    }\n    \n    var fibs = [0, 0, 2, 0]\n    \n    for i in 4...n {\n        let nextFib = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4]\n        fibs.append(nextFib)\n    }\n    \n    return fibs[n]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fib4(n: 5) == 4)\nassert(fib4(n: 8) == 28)\nassert(fib4(n: 10) == 104)\nassert(fib4(n: 12) == 386)"},{"task_id":"HumanEval_47","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⴰⵎⵎⴰⵙ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ l. \/\/\/ >>> median(l: [3, 1, 2, 4, 5])\n\/\/\/ 3\n\/\/\/ >>> median(l: [-10, 4, 6, 1000, 10, 20])\n\/\/\/ 15.0\nfunc median(l: [Int]) -> Double {\n","canonical_solution":"func median(l: [Int]) -> Double {\n    let sorted = l.sorted()\n    let count = sorted.count\n    if count % 2 == 0 {\n        return Double(sorted[count \/ 2 - 1] + sorted[count \/ 2]) \/ 2.0\n    } else {\n        return Double(sorted[count \/ 2])\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"},{"task_id":"HumanEval_48","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴷⴰ ⵉⵜⵜⵉⵔⵉ ⵎⴽ ⵜⴳⴰ ⵜⵓⵙⴷⵉⴷⵜ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵢⴰⵜ ⵜⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ \/\/\/ >>> is_palindrome(text: \"\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"aba\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"aaaaa\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"zbcd\")\n\/\/\/ false\nfunc is_palindrome(text: String) -> Bool {\n","canonical_solution":"func is_palindrome(text: String) -> Bool {\n    return text == String(text.reversed())\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_palindrome(text: \"\") == true)\nassert(is_palindrome(text: \"aba\") == true)\nassert(is_palindrome(text: \"aaaaa\") == true)\nassert(is_palindrome(text: \"zbcd\") == false)\nassert(is_palindrome(text: \"xywyx\") == true)\nassert(is_palindrome(text: \"xywyz\") == false)\nassert(is_palindrome(text: \"xywzx\") == false)"},{"task_id":"HumanEval_49","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙⴽⵔ 2^n modulo p (ⴰⴷ ⵜⵙⵙⵏⴷ ⵉⵎⴹⴰⵏⵏ). \/\/\/ >>> modp(n: 3, p: 5)\n\/\/\/ 3\n\/\/\/ >>> modp(n: 1101, p: 101)\n\/\/\/ 2\n\/\/\/ >>> modp(n: 0, p: 101)\n\/\/\/ 1\n\/\/\/ >>> modp(n: 3, p: 11)\n\/\/\/ 8\n\/\/\/ >>> modp(n: 100, p: 101)\n\/\/\/ 1\nfunc modp(n: Int, p: Int) -> Int {\n","canonical_solution":"func modp(n: Int, p: Int) -> Int {\n    return Int(pow(2.0, Double(n)).truncatingRemainder(dividingBy: Double(p)))\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"},{"task_id":"HumanEval_51","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ remove_vowels ⵜⴳⴰ ⵢⴰⵜ ⵜⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵙⵉⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴰⵔ ⵜⵙⴽⴰⵔ ⵜⵉⴼⵉⵏⴰⵖ ⴱⵍⴰ ⵜⵉⴼⵉⵏⴰⵖ. \/\/\/ >>> remove_vowels(text: \"\")\n\/\/\/ \"\"\n\/\/\/ >>> remove_vowels(text: \"abcdef\")\n\/\/\/ \"bcdf\"\n\/\/\/ >>> remove_vowels(text: \"aaaaa\")\n\/\/\/ \"\"\n\/\/\/ >>> remove_vowels(text: \"aaBAA\")\n\/\/\/ \"B\"\n\/\/\/ >>> remove_vowels(text: \"zbcd\")\n\/\/\/ \"zbcd\"\nfunc remove_vowels(text: String) -> String {\n","canonical_solution":"func remove_vowels(text: String) -> String {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    return String(text.filter { !vowels.contains($0) })\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_vowels(text: \"\") == \"\")\nassert(remove_vowels(text: \"abcdef\\nghijklm\") == \"bcdf\\nghjklm\")\nassert(remove_vowels(text: \"fedcba\") == \"fdcb\")\nassert(remove_vowels(text: \"eeeee\") == \"\")\nassert(remove_vowels(text: \"acBAA\") == \"cB\")\nassert(remove_vowels(text: \"EcBOO\") == \"cB\")\nassert(remove_vowels(text: \"ybcd\") == \"ybcd\")"},{"task_id":"HumanEval_52","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ true ⵎⴽ ⴷⴰ ⴳⴰⵏ ⵉⵎⴹⴰⵏ ⴰⴽⴽⵡ ⴳ ⵓⵎⵙⴳⴷⴰⵍ l ⴷⴷⴰⵡ ⵏ ⵓⴽⵜⵜⵓⵔ t. \/\/\/ >>> below_threshold(l: [1, 2, 4, 10], t: 100)\n\/\/\/ true\n\/\/\/ >>> below_threshold(l: [1, 20, 4, 10], t: 5)\n\/\/\/ false\nfunc below_threshold(l: [Int], t: Int) -> Bool {\n","canonical_solution":"func below_threshold(l: [Int], t: Int) -> Bool {\n    for number in l {\n        if number >= t {\n            return false\n        }\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(below_threshold(l: [1, 2, 4, 10], t: 100) == true)\nassert(below_threshold(l: [1, 20, 4, 10], t: 5) == false)\nassert(below_threshold(l: [1, 20, 4, 10], t: 21) == true)\nassert(below_threshold(l: [1, 20, 4, 10], t: 22) == true)\nassert(below_threshold(l: [1, 8, 4, 10], t: 11) == true)\nassert(below_threshold(l: [1, 8, 4, 10], t: 10) == false)"},{"task_id":"HumanEval_53","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙⵙⵓⵏⴼⵓ ⵙⵉⵏ ⵉⵎⴹⴰⵏⵏ x ⴷ y \/\/\/ >>> add(x: 2, y: 3)\n\/\/\/ 5\n\/\/\/ >>> add(x: 5, y: 7)\n\/\/\/ 12\nfunc add(x: Int, y: Int) -> Int {\n","canonical_solution":"func add(x: Int, y: Int) -> Int {\n    return x + y\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add(x: 0, y: 1) == 1)\nassert(add(x: 1, y: 0) == 1)\nassert(add(x: 2, y: 3) == 5)\nassert(add(x: 5, y: 7) == 12)\nassert(add(x: 7, y: 5) == 12)"},{"task_id":"HumanEval_54","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵣⵣⵔⴰⵢ ⵎⴽ ⴳⴰⵏ ⵙⵉⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵖⵓⵔⵙⵏ ⵉⵎⵙⴽⴰⵔⵏ ⵉⵎⵎⵙⴰⵙⴰⵏ. \/\/\/ >>> same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddeddabc\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"abcd\", s1: \"dddddddabc\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"dddddddabc\", s1: \"abcd\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"eabcd\", s1: \"dddddddabc\")\n\/\/\/ false\n\/\/\/ >>> same_chars(s0: \"abcd\", s1: \"dddddddabce\")\n\/\/\/ false\n\/\/\/ >>> same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddddabc\")\n\/\/\/ false\nfunc same_chars(s0: String, s1: String) -> Bool {\n","canonical_solution":"func same_chars(s0: String, s1: String) -> Bool {\n    let set0 = Set(s0)\n    let set1 = Set(s1)\n    return set0 == set1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddeddabc\") == true)\nassert(same_chars(s0: \"abcd\", s1: \"dddddddabc\") == true)\nassert(same_chars(s0: \"dddddddabc\", s1: \"abcd\") == true)\nassert(same_chars(s0: \"eabcd\", s1: \"dddddddabc\") == false)\nassert(same_chars(s0: \"abcd\", s1: \"dddddddabcf\") == false)\nassert(same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddddabc\") == false)\nassert(same_chars(s0: \"aabb\", s1: \"aaccc\") == false)"},{"task_id":"HumanEval_55","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⴷ ⵢⴰⴽⵣ ⴰⵎⴹⴰⵏ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵛⵉ ⵡⵉⵙⵙ ⵏ. \/\/\/ >>> fib(n: 10)\n\/\/\/ 55\n\/\/\/ >>> fib(n: 1)\n\/\/\/ 1\n\/\/\/ >>> fib(n: 8)\n\/\/\/ 21\nfunc fib(n: Int) -> Int {\n","canonical_solution":"func fib(n: Int) -> Int {\n    if n <= 0 {\n        return 0\n    } else if n == 1 {\n        return 1\n    }\n    \n    var a = 0\n    var b = 1\n    for _ in 2...n {\n        let temp = a + b\n        a = b\n        b = temp\n    }\n    return b\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fib(n: 10) == 55)\nassert(fib(n: 1) == 1)\nassert(fib(n: 8) == 21)\nassert(fib(n: 11) == 89)\nassert(fib(n: 12) == 144)"},{"task_id":"HumanEval_56","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⴷⴰ ⴽⵓ ⴰⵙⴽⴽⵉⵍ ⵏ ⵓⵕⵥⵥⵓⵎ ⴷⴰⵔⵙ ⴰⵙⴽⴽⵉⵍ ⵏ ⵓⵇⵇⵏ. \/\/ ⴱⵔⴰⴽⵉⵜⵙ ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉⵍ ⵏ \"<\" ⴷ \">\". \/\/\/ >>> correct_bracketing(brackets: \"<\")\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(brackets: \"<>\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"<<><>>\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"><<>\")\n\/\/\/ false\nfunc correct_bracketing(brackets: String) -> Bool {\n","canonical_solution":"func correct_bracketing(brackets: String) -> Bool {\n    var balance = 0\n    \n    for bracket in brackets {\n        if bracket == \"<\" {\n            balance += 1\n        } else if bracket == \">\" {\n            balance -= 1\n            if balance < 0 {\n                return false\n            }\n        }\n    }\n    \n    return balance == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)"},{"task_id":"HumanEval_57","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵏⴰⴽⴽⴰ true ⵉⴳⴰⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵙⵏⵙⵍ ⴷⴰ ⵙⵙⵓⴷⵓⵏ ⵙ ⵓⵖⵍⵉ ⵏⵖⴷ ⵙ ⵓⴷⵔⴰⵔ. \/\/\/ >>> monotonic(l: [1, 2, 4, 20])\n\/\/\/ true\n\/\/\/ >>> monotonic(l: [1, 20, 4, 10])\n\/\/\/ false\n\/\/\/ >>> monotonic(l: [4, 1, 0, -10])\n\/\/\/ true\nfunc monotonic(l: [Int]) -> Bool {\n","canonical_solution":"func monotonic(l: [Int]) -> Bool {\n    guard l.count > 1 else {\n        return true\n    }\n    \n    var increasing = true\n    var decreasing = true\n    \n    for i in 1..<l.count {\n        if l[i] > l[i - 1] {\n            decreasing = false\n        } else if l[i] < l[i - 1] {\n            increasing = false\n        }\n    }\n    \n    return increasing || decreasing\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"},{"task_id":"HumanEval_58","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⵉⵡⴰⵏⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵉ ⵙⵉⵏ ⵉⵎⵙⴷⴷⵉⵢⵏ. \/\/\/ >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n\/\/\/ [1, 5, 653]\n\/\/\/ >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n\/\/\/ [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n","canonical_solution":"func common(l1: [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let commonElements = set1.intersection(set2)\n    return Array(commonElements).sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"},{"task_id":"HumanEval_59","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⴷ ⵏⵔⴰⵔ ⴰⵎⴳⴳⴰⵔⵓ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ ⵏ n. ⵏⵙⵙⵏ ⵉⵙ n > 1 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵎⵣⵡⴰⵔⵓ. \/\/\/ >>> largest_prime_factor(n: 13195)\n\/\/\/ 29\n\/\/\/ >>> largest_prime_factor(n: 2048)\n\/\/\/ 2\nfunc largest_prime_factor(n: Int) -> Int {\n","canonical_solution":"func largest_prime_factor(n: Int) -> Int {\n    var number = n\n    var divisor = 2\n    \n    while number > 1 {\n        if number % divisor == 0 {\n            number \/= divisor\n        } else {\n            divisor += 1\n        }\n    }\n    \n    return divisor\n}\n\n\/\/ Example usage:\n\/\/ print(largest_prime_factor(n: 13195)) \/\/ Output: 29\n\/\/ print(largest_prime_factor(n: 2048))  \/\/ Output: 2","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"},{"task_id":"HumanEval_60","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ sum_to_n ⵜⴳⴰ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵉⵙⵎⵓⵏⵏ ⵉⵎⴹⴰⵏⵏ ⵙⴳ 1 ⴰⵔ n. \/\/\/ >>> sum_to_n(n: 30)\n\/\/\/ 465\n\/\/\/ >>> sum_to_n(n: 100)\n\/\/\/ 5050\n\/\/\/ >>> sum_to_n(n: 5)\n\/\/\/ 15\n\/\/\/ >>> sum_to_n(n: 10)\n\/\/\/ 55\n\/\/\/ >>> sum_to_n(n: 1)\n\/\/\/ 1\nfunc sum_to_n(n: Int) -> Int {\n","canonical_solution":"func sum_to_n(n: Int) -> Int {\n    return (n * (n + 1)) \/ 2\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_to_n(n: 1) == 1)\nassert(sum_to_n(n: 6) == 21)\nassert(sum_to_n(n: 11) == 66)\nassert(sum_to_n(n: 30) == 465)\nassert(sum_to_n(n: 100) == 5050)"},{"task_id":"HumanEval_61","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⴷⴰ ⴽⵓ ⴰⵙⴽⴽⵉⵍ ⵏ ⵓⵕⵥⵥⵓⵎ ⴷⴰⵔⵙ ⴰⵙⴽⴽⵉⵍ ⵏ ⵓⵇⵇⵏ. \/\/ ⴱⵔⴰⴽⵉⵜⵙ ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏ \"(\" ⴷ \")\". \/\/\/ >>> correct_bracketing(brackets: \"(\")\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(brackets: \"()\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"(()())\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \")(()\")\n\/\/\/ false\nfunc correct_bracketing(brackets: String) -> Bool {\n","canonical_solution":"func correct_bracketing(brackets: String) -> Bool {\n    var balance = 0\n    for char in brackets {\n        if char == \"(\" {\n            balance += 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n        if balance < 0 {\n            return false\n        }\n    }\n    return balance == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)"},{"task_id":"HumanEval_62","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⴷ ⵏⵔⴰⵔ ⵜⴰⵙⵏⴼⵍⵓⵍⵜ ⵏ ⵓⵎⴳⴳⵉⵡⵙ ⴰⴷ ⴳ ⵢⴰⵜ ⵜⴰⵍⵖⴰ. \/\/ xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/ xs ⴷⴰ ⵉⵙⵎⴷⵢⴰ ⵉⵎⵙⴽⴰⵔⵏ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ. \/\/\/ >>> derivative(xs: [3, 1, 2, 4, 5])\n\/\/\/ [1, 4, 12, 20]\n\/\/\/ >>> derivative(xs: [1, 2, 3])\n\/\/\/ [2, 6]\nfunc derivative(xs: [Int]) -> [Int] {\n","canonical_solution":"func derivative(xs: [Int]) -> [Int] {\n    guard xs.count > 1 else { return [] }\n    var result: [Int] = []\n    for i in 1..<xs.count {\n        result.append(xs[i] * i)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(derivative(xs: [3, 1, 2, 4, 5]) == [1, 4, 12, 20])\nassert(derivative(xs: [1, 2, 3]) == [2, 6])\nassert(derivative(xs: [3, 2, 1]) == [2, 2])\nassert(derivative(xs: [3, 2, 1, 0, 4]) == [2, 2, 0, 16])\nassert(derivative(xs: [1]) == [] as [Int])"},{"task_id":"HumanEval_63","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵉⴹⵏ ⴰⵎⵏⵣⵓ ⵡⵉⵙⵙ n ⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵏ fibfib. \/\/ fibfib{n} == fibfib{n-1} + fib{n-2} + fib{n-3} \/\/ fib fib ((2) == 1 \/\/ fib fib ((1) == 0 \/\/ fib fib ((0) == 0 \/\/ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ FibFib ⵜⴳⴰ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵣⵓⵏⴷ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ: \/\/\/ >>> fibfib(n: 1)\n\/\/\/ 0\n\/\/\/ >>> fibfib(n: 5)\n\/\/\/ 4\n\/\/\/ >>> fibfib(n: 8)\n\/\/\/ 24\nfunc fibfib(n: Int) -> Int {\n","canonical_solution":"func fibfib(n: Int) -> Int {\n    if n == 0 || n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    \n    var fibfibNums = [0, 0, 1]\n    \n    for i in 3...n {\n        let nextFibFib = fibfibNums[i - 1] + fibfibNums[i - 2] + fibfibNums[i - 3]\n        fibfibNums.append(nextFibFib)\n    }\n    \n    return fibfibNums[n]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fibfib(n: 2) == 1)\nassert(fibfib(n: 1) == 0)\nassert(fibfib(n: 5) == 4)\nassert(fibfib(n: 8) == 24)\nassert(fibfib(n: 10) == 81)\nassert(fibfib(n: 12) == 274)\nassert(fibfib(n: 14) == 927)"},{"task_id":"HumanEval_64","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⴰⵖⵔⵉ, ⵎⴰⵛⴰ ⴷⴰⵢ ⵉⴳ ⵉⵍⵍⴰ ⴳ ⵜⴳⵉⵔⴰ ⵏ ⵜⴳⵓⵔⵉ ⵉⵜⵜⵓⴼⴽⴰⵏ. \/\/ ⵉⵎⵓⵀⴰⵖ ⴳ ⵡⴰⴷⴷⴰⴷ ⴰⴷ ⴳⴰⵏ 'ⴰ', 'ⵢ', 'ⵉ', 'ⵓ', 'ⵓ'. ⴷⵖⵉ, 'ⵢ' ⵉⴳⴰ ⴰⵡⴷ ⵢⴰⵏ \/\/ ⵢⴰⵏ ⵡⴰⵡⴰⵍ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵙⴽⴰⵔ ⵉⵎⵉⴹ ⵏ ⵉⵎⵙⵍⵉ ⴳ ⵜⵣⵍⵉⵜ. \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ vowels_count ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵜⴰⵡⵓⵔⵉ ⵏ \/\/\/ >>> vowels_count(s: \"abcde\")\n\/\/\/ 2\n\/\/\/ >>> vowels_count(s: \"ACEDY\")\n\/\/\/ 3\nfunc vowels_count(s: String) -> Int {\n","canonical_solution":"func vowels_count(s: String) -> Int {\n    guard !s.isEmpty else { return 0 }\n    \n    let vowels = Set(\"aeiouAEIOU\")\n    var count = 0\n    let characters = Array(s)\n    \n    for i in 0..<characters.count {\n        let char = characters[i]\n        \n        if vowels.contains(char) {\n            count += 1\n        } else if char == \"y\" || char == \"Y\" {\n            if i == characters.count - 1 {\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(vowels_count(s: \"abcde\") == 2)\nassert(vowels_count(s: \"Alone\") == 3)\nassert(vowels_count(s: \"key\") == 2)\nassert(vowels_count(s: \"bye\") == 1)\nassert(vowels_count(s: \"keY\") == 2)\nassert(vowels_count(s: \"bYe\") == 1)\nassert(vowels_count(s: \"ACEDY\") == 3)"},{"task_id":"HumanEval_65","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵎⴽ ⵜⵔⴰⵔ > ⴰⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵔⴰⴷ ⵜⵔⴰⵔ ⵉⵎⴹⴰⵏⵏ ⵙ ⵓⴱⵔⴰⵔ. \/\/ ⴷ ⴰⵔ ⵏⵙⵙⴽⵛⵎ ⵜⴰⵢⴰⴼⵓⵜ ⵙ ⵜⴰⵍⵖⴰ. \/\/ ⴰⵖⵍⵍⵓⵢ ⵏ ⵓⵙⵏⴼⵍ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ x, ⵙⵏⴼⵍ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵙ ⵓⵣⵔⴼ ⵙ ⵓⵙⵏⴼⵍ \/\/\/ >>> circular_shift(x: 12, shift: 1)\n\/\/\/ \"21\"\n\/\/\/ >>> circular_shift(x: 12, shift: 2)\n\/\/\/ \"12\"\nfunc circular_shift(x: Int, shift: Int) -> String {\n","canonical_solution":"func circular_shift(x: Int, shift: Int) -> String {\n    let digits = Array(String(x))\n    let count = digits.count\n    \n    \/\/ If shift is greater than the number of digits, return the digits reversed\n    if shift >= count {\n        return String(digits.reversed())\n    }\n    \n    \/\/ Calculate the actual shift needed by using modulo operation\n    let actualShift = shift % count\n    \n    \/\/ Perform the circular shift to the right\n    let splitIndex = count - actualShift\n    let shiftedDigits = digits[splitIndex...] + digits[..<splitIndex]\n    \n    return String(shiftedDigits)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(circular_shift(x: 100, shift: 2) == \"001\")\nassert(circular_shift(x: 12, shift: 2) == \"12\")\nassert(circular_shift(x: 97, shift: 8) == \"79\")\nassert(circular_shift(x: 12, shift: 1) == \"21\")\nassert(circular_shift(x: 11, shift: 101) == \"11\")"},{"task_id":"HumanEval_66","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⵉⵙⴽⵉⴷⵏ ⵏ ASCII. \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵖⵉⵍⵓⴼ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵙⴽⴰⵔ ⵜⴰⴳⵓⵜ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵓⴼⵍⵍⴰ ⴷⴰⵢ' \/\/ ⵜⴰⵡⵓⵔⵉ \/\/\/ >>> digitSum(s: \"\")\n\/\/\/ 0\n\/\/\/ >>> digitSum(s: \"abAB\")\n\/\/\/ 131\n\/\/\/ >>> digitSum(s: \"abcCd\")\n\/\/\/ 67\n\/\/\/ >>> digitSum(s: \"helloE\")\n\/\/\/ 69\n\/\/\/ >>> digitSum(s: \"woArBld\")\n\/\/\/ 131\n\/\/\/ >>> digitSum(s: \"aAaaaXa\")\n\/\/\/ 153\nfunc digitSum(s: String) -> Int {\n","canonical_solution":"func digitSum(s: String) -> Int {\n    var sum = 0\n    for character in s {\n        if character.isUppercase {\n            sum += Int(character.asciiValue ?? 0)\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digitSum(s: \"\") == 0)\nassert(digitSum(s: \"abAB\") == 131)\nassert(digitSum(s: \"abcCd\") == 67)\nassert(digitSum(s: \"helloE\") == 69)\nassert(digitSum(s: \"woArBld\") == 131)\nassert(digitSum(s: \"aAaaaXa\") == 153)\nassert(digitSum(s: \" How are yOu?\") == 151)\nassert(digitSum(s: \"You arE Very Smart\") == 327)"},{"task_id":"HumanEval_67","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉ ⵓⵎⵙⵓⵖⵍ: \/\/ ⴳ ⵜⴽⵕⴹⴰ ⴰⵔ ⵜⵙⵙⴽⵛⵎ ⵓⵟⵟⵓⵏ ⵏ ⵜⵢⴰⴼⵓⵜⵉⵏ ⵏ ⵍⵎⴰⵏⴳⵓ ⴳ ⵜⴽⵕⴹⴰ. \/\/ ⵜⵉⴱⵔⴽⴰⵏⵉⵏ ⴷ ⵜⵉⴱⵔⵎⴰⵏⵉⵏ ⴷ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ ⴰⵎⴹⴰⵏ ⵏ ⵜⵢⴰⴼⵓⵜⵉⵏ \/\/ ⵜⵉⴱⵔⵣⴰ, ⵜⵉⴱⵕⴰⵏⵊⵉⵏ, ⴷ ⵜⴽⵡⴼⴰⵢⵉⵏ ⵏ ⵍⵎⴰⵏⴳⵓ. ⵥⵕ ⵜⴰⵡⵔⵉ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ ⴰⵎⴹⴰⵏ ⵏ \/\/ ⵏⵏⴰ ⵉⵜⵜⵓⵣⵟⵟⴰ ⴳ ⵢⴰⵜ ⵜⴽⵕⴹⴰ ⵏ ⵜⴽⵕⴹⴰ ⵏ ⵜⵢⴰⴼⵓⵜ ⵉⵍⵍⴰ ⴳⵉⵙ \/\/ ⴳ ⵜⵎⵙⴰⵔⵜ ⴰⴷ, ⵔⴰⴷ ⴽⴽⵉⵖ ⵢⴰⵜ ⵜⵣⵍⵉⵜ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⴱⵔⵔⵉⵜⵉⵏ ⴷ ⵜⴱⵓⵕⵜⵓⵖⴰⵍⵉⵏ \/\/\/ >>> fruit_distribution(s: \"5 apples and 6 oranges\", n: 19)\n\/\/\/ 8\n\/\/\/ >>> fruit_distribution(s: \"0 apples and 1 oranges\", n: 3)\n\/\/\/ 2\n\/\/\/ >>> fruit_distribution(s: \"2 apples and 3 oranges\", n: 100)\n\/\/\/ 95\n\/\/\/ >>> fruit_distribution(s: \"100 apples and 1 oranges\", n: 120)\n\/\/\/ 19\nfunc fruit_distribution(s: String, n: Int) -> Int {\n","canonical_solution":"func fruit_distribution(s: String, n: Int) -> Int {\n    let components = s.components(separatedBy: \" \")\n    var apples = 0\n    var oranges = 0\n    \n    for (index, component) in components.enumerated() {\n        if component == \"apples\" || component == \"apple\" {\n            if let number = Int(components[index - 1]) {\n                apples = number\n            }\n        } else if component == \"oranges\" || component == \"orange\" {\n            if let number = Int(components[index - 1]) {\n                oranges = number\n            }\n        }\n    }\n    \n    let totalApplesOranges = apples + oranges\n    let mangoes = n - totalApplesOranges\n    return mangoes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fruit_distribution(s: \"5 apples and 6 oranges\", n: 19) == 8)\nassert(fruit_distribution(s: \"5 apples and 6 oranges\", n: 21) == 10)\nassert(fruit_distribution(s: \"0 apples and 1 oranges\", n: 3) == 2)\nassert(fruit_distribution(s: \"1 apples and 0 oranges\", n: 3) == 2)\nassert(fruit_distribution(s: \"2 apples and 3 oranges\", n: 100) == 95)\nassert(fruit_distribution(s: \"2 apples and 3 oranges\", n: 5) == 0)\nassert(fruit_distribution(s: \"1 apples and 100 oranges\", n: 120) == 19)"},{"task_id":"HumanEval_68","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ 1: \/\/ ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⵡⴰⵜⵉⴳⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ ⵏⵖⴷ ⵉⴳ ⵓⵎⵙⴳⵔⴰⵡ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⴳⴰ ⵜ ⵡⴰⴽⴰⵍ, ⵙⵙⵓⴼⵖ []. \/\/ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⵏⵓⵍⴼⴰ ⵜⵓⵏⵏⵓⵏⵜ ⵉⵜⵜⵓⵙⵏⴱⴹⵏ ⴳ ⵢⴰⵏ ⵓⵙⵏⵙⵍ, [ smalest_value, ⴰⵙⵖⵍ ⵏⵏⵙ ], \/\/ ⵎⴽ ⵍⵍⴰⵏⵜ ⴽⵉⴳⴰⵏ ⵏ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⴰⵎⴽⵙⵓⵍ, ⵙⵙⵓⴼⵖ ⵜⵓⵏⵏⵓⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵥⵥⵢⴰⵏ. \/\/ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⴳ ⵜⵓⵏⵏⵓⵏⵜ ⵉⵜⵜⵓⵙⵏⴱⴹⵏ ⵜⴰⵡⵜⵎⵉⵢⵜ ⵜⴰⵥⵥⵉⴹⴰⵔⵜ. \/\/ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵢⴰⵜ ⵙⴳ ⵜⵓⵏⵏⵓⵏⵜ ⴷ ⴰⴷ ⵜⵔⴰⵔ. \/\/ \"ⴰⴽⵓⴷ ⵉⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵏ ⵓⵥⵟⵟⴰ ⵏ ⵢⴰⵜ ⵜⵙⴽⵍⴰ ⵏⵏⴰ ⵖⵓⵔⵙ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵔⵉⵏ \/\/\/ >>> pluck(arr: [4, 2, 3])\n\/\/\/ [2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 2:\n\/\/\/ >>> pluck(arr: [1, 2, 3])\n\/\/\/ [2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 3:\n\/\/\/ >>> pluck(arr: [] as [Int])\n\/\/\/ [] as [Int]\n\/\/\/ Example 4:\n\/\/\/ >>> pluck(arr: [5, 0, 3, 0, 4, 2])\n\/\/\/ [0, 1]\n\/\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/\/ so we will choose the first zero, which has the smallest index.\n\/\/\/ Constraints:\n\/\/\/ * 1 <= nodes.length <= 10000\n\/\/\/ * 0 <= node.value\nfunc pluck(arr: [Int]) -> [Int] {\n","canonical_solution":"func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue: Int? = nil\n    var smallestIndex: Int? = nil\n\n    for (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n            if smallestEvenValue == nil || value < smallestEvenValue! || (value == smallestEvenValue! && index < smallestIndex!) {\n                smallestEvenValue = value\n                smallestIndex = index\n            }\n        }\n    }\n\n    if let smallestEvenValue = smallestEvenValue, let smallestIndex = smallestIndex {\n        return [smallestEvenValue, smallestIndex]\n    } else {\n        return []\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"},{"task_id":"HumanEval_69","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⵜⵉⴳ ⴰⴷ, ⵙⵓⵍ -1. \/\/ ⵜⴰⴽⵓⴷⵜ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵉⴳⴰ ⵜ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⴷⴰ ⵉⵜⵜⴼⴼⵖ ⴳ ⵓⵎⵙⴳⴷⴰⵍ. \/\/ ⴰⵎⵢⴰ, ⴷ ⵖⵓⵔⵙ ⵢⴰⵏ ⵓⴽⵓⴷ ⴰⵅⴰⵜⴰⵔ ⵏⵖⴷ ⵉⵎⵣⴷⴰⵖ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵉⵎⵉⴹ ⴰⵎⴷⴷⴰⴷ ⵉⵎⴰⵏ ⵏⵏⵙ. \/\/ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵅⵍⵍⵚⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵔⵎⵙⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⵏⵏⴰ ⵢⵎⵇⵇⵓⵔⵏ \/\/\/ >>> search(lst: [4, 1, 2, 2, 3, 1])\n\/\/\/ 2\n\/\/\/ >>> search(lst: [1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/\/ 3\n\/\/\/ >>> search(lst: [5, 5, 4, 4, 4])\n\/\/\/ -1\nfunc search(lst: [Int]) -> Int {\n","canonical_solution":"func search(lst: [Int]) -> Int {\n    var frequencyMap = [Int: Int]()\n    \n    \/\/ Count frequencies of each number in the list\n    for number in lst {\n        frequencyMap[number, default: 0] += 1\n    }\n    \n    var result = -1\n    \n    \/\/ Iterate through the frequency map to find the greatest integer that satisfies the condition\n    for (number, frequency) in frequencyMap {\n        if frequency >= number {\n            result = max(result, number)\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(lst: [5, 5, 5, 5, 1]) == 1)\nassert(search(lst: [4, 1, 4, 1, 4, 4]) == 4)\nassert(search(lst: [3, 3]) == -1)\nassert(search(lst: [8, 8, 8, 8, 8, 8, 8, 8]) == 8)\nassert(search(lst: [2, 3, 3, 2, 2]) == 2)\nassert(search(lst: [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)\nassert(search(lst: [3, 2, 8, 2]) == 2)\nassert(search(lst: [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)\nassert(search(lst: [8, 8, 3, 6, 5, 6, 4]) == -1)\nassert(search(lst: [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)\nassert(search(lst: [1, 9, 10, 1, 3]) == 1)\nassert(search(lst: [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)\nassert(search(lst: [1]) == 1)\nassert(search(lst: [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)\nassert(search(lst: [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)\nassert(search(lst: [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)\nassert(search(lst: [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4)\nassert(search(lst: [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)\nassert(search(lst: [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)\nassert(search(lst: [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)\nassert(search(lst: [10]) == -1)\nassert(search(lst: [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)\nassert(search(lst: [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)\nassert(search(lst: [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)\nassert(search(lst: [3, 10, 10, 9, 2]) == -1)"},{"task_id":"HumanEval_70","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⴷⴼⴼⵉⵔ ⵏ ⵓⴳⴳⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵇⵇⵉⵎⵏ, ⴷⴼⴼⵉⵔ ⵏ ⵓⴳⴳⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ ⴰⵢⴰⴷ. \/\/ ⴰⵙⵎⵉⵍ ⴰⵎⵣⴳⵓⵏ, ⵉⴳ ⴷⴰ ⵜⵙⵙⵏⵜⵉⴷ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ, \/\/ ⴰⵟⵟⴰⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⴰⵟⵟⴰⵙ ⴳ ⵓⴱⵔⵉⴷ ⵓⵔ ⵉⵃⵍⵉⵏ. \/\/\/ >>> strange_sort_list(lst: [1, 2, 3, 4])\n\/\/\/ [1, 4, 2, 3]\n\/\/\/ >>> strange_sort_list(lst: [5, 5, 5, 5])\n\/\/\/ [5, 5, 5, 5]\n\/\/\/ >>> strange_sort_list(lst: [] as [Int])\n\/\/\/ [] as [Int]\nfunc strange_sort_list(lst: [Int]) -> [Int] {\n","canonical_solution":"func strange_sort_list(lst: [Int]) -> [Int] {\n    var sortedList = lst.sorted()\n    var result: [Int] = []\n    \n    while !sortedList.isEmpty {\n        if let min = sortedList.first {\n            result.append(min)\n            sortedList.removeFirst()\n        }\n        \n        if let max = sortedList.last {\n            result.append(max)\n            sortedList.removeLast()\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"},{"task_id":"HumanEval_71","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⵓⴳⴳⴰⵔ ⵏ ⵜⵙⴳⴰ ⵜⵉⵙⵙ ⴽⵕⴰⴹⵜ. \/\/ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⴷⴰ ⵙⴽⴰⵔⵏ ⵢⴰⵏ ⵓⴽⵕⴰⴹ ⵉⵖⵓⴷⴰⵏ ⵉⴳ ⵜⵍⵍⴰ ⵜⵔⵎⵜ ⵏ ⵙⵏⴰⵜ ⵜⴼⵓⵍⵉⵏ ⵅⴰⵜⴰⵔ\/\/ ⵎⴽ ⵓⵔ ⵜⴽⴽⵉⴷ ⴰⵔⴷ ⴷⴰⵖ -1 \/\/ ⵜⴰⵎⵉⴹⵉ ⵏ ⴽⵕⴰⴹ ⵉⵎⵉⴹⵉ ⵏ ⵜⵔⴳⴰⵍⵜ ⵎⴽⵍⵍⵉ ⴳⴰⵏ ⴽⵕⴰⴹ ⵏ ⵉⴳⴼⵉⵔⵏ ⵢⴰⵜ ⵜⴰⵎⵉⴹⵉ ⵏ ⴽⵕⴰⴹ ⵉⵎⵉⴹⵉ ⵏ ⵜⵔⴳⴰⵍⵜ. \/\/ ⴰⵖ ⴷ ⵢⵓⴼⴰ ⵜⵉⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⵢⴰⵏ ⵓⴽⵕⴰⴹ. ⵔⵎⵙⵏ ⵜⴰⵊⵓⵎⵎⴰ ⵏ \/\/\/ >>> triangle_area(a: 3, b: 4, c: 5)\n\/\/\/ 6.0\n\/\/\/ >>> triangle_area(a: 1, b: 2, c: 10)\n\/\/\/ -1\nfunc triangle_area(a: Int, b: Int, c: Int) -> Double {\n","canonical_solution":"func triangle_area(a: Int, b: Int, c: Int) -> Double {\n    \/\/ Check if the sides form a valid triangle\n    if a + b > c && a + c > b && b + c > a {\n        \/\/ Calculate the semi-perimeter\n        let s = Double(a + b + c) \/ 2.0\n        \/\/ Calculate the area using Heron's formula\n        let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))\n        \/\/ Round to 2 decimal places\n        return round(area * 100) \/ 100\n    } else {\n        return -1\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(a: 3, b: 4, c: 5) == 6.0)\nassert(triangle_area(a: 1, b: 2, c: 10) == -1)\nassert(triangle_area(a: 4, b: 8, c: 5) == 8.18)\nassert(triangle_area(a: 2, b: 2, c: 2) == 1.73)\nassert(triangle_area(a: 1, b: 2, c: 3) == -1)\nassert(triangle_area(a: 10, b: 5, c: 7) == 16.25)\nassert(triangle_area(a: 2, b: 6, c: 3) == -1)\nassert(triangle_area(a: 1, b: 1, c: 1) == 0.43)\nassert(triangle_area(a: 2, b: 2, c: 10) == -1)"},{"task_id":"HumanEval_72","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⵔⴰⴷ ⵉⵢⵉ ⵜⴱⴰⵢⵢ ⵉⴳ ⵉⴳⴰ ⵡⴰⵏⴰⵡ q ⴰⵎⵙⴰⵙⴰ (ⵉⴳⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉ) ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⵙ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⴳⴳⴰⵔ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵓⴳⴳⴰⵔ ⵏ ⵓⴽⵙⴰⵢ w. \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴷⵜ ⵎⴽ ⴷⴰ ⵉⵜⵜⴰⵡⵉ ⵓⴷⵎ q, ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ. \/\/\/ >>> will_it_fly(q: [1, 2], w: 5)\n\/\/\/ false\n\/\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/\/ >>> will_it_fly(q: [3, 2, 3], w: 1)\n\/\/\/ false\n\/\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/\/ >>> will_it_fly(q: [3, 2, 3], w: 9)\n\/\/\/ true\n\/\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/\/ >>> will_it_fly(q: [3], w: 5)\n\/\/\/ true\n\/\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int], w: Int) -> Bool {\n","canonical_solution":"func will_it_fly(q: [Int], w: Int) -> Bool {\n    func isPalindromic(_ array: [Int]) -> Bool {\n        return array == array.reversed()\n    }\n    \n    let sum = q.reduce(0, +)\n    return isPalindromic(q) && sum <= w\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"},{"task_id":"HumanEval_73","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⴷⴰ ⵉⵜⵜⵓⵙⵙⴰⵏ ⵙ ⵢⴰⵜ ⵜⵖⴰⵔⴰⵙⵜ ⵙ ⵓⵎⵏⵉⴷ ⴷ ⵙ ⵓⴷⴼⵍ. ⴳ ⵢⴰⵏ ⵓⵙⵏⴼⵍ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵏⴼⵍⴷ ⵢⴰⵏ ⵉⴼⵔⴷⵉⵙ ⵙ ⴽⵔⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵢⴰⴹⵏⵉⵏ.\/\/ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⵍ ⴰⴼⴰⴷ ⴰⴷ ⵉⴳ ⵓⵙⵏⵙⵍ ⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉ. ⴰⵙⵏⵙⵍ ⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉ ⵉⴳⴰ ⴰⵙⵏⵙⵍ ⵏⵏⴰ \/\/ ⴰⵖ ⴷ ⵢⵓⴼⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵉ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵥⵕⵉ ⴰⵎⴹⴰⵏ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ \/\/\/ >>> smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6])\n\/\/\/ 4\n\/\/\/ >>> smallest_change(arr: [1, 2, 3, 4, 3, 2, 2])\n\/\/\/ 1\n\/\/\/ >>> smallest_change(arr: [1, 2, 3, 2, 1])\n\/\/\/ 0\nfunc smallest_change(arr: [Int]) -> Int {\n","canonical_solution":"func smallest_change(arr: [Int]) -> Int {\n    var changes = 0\n    let n = arr.count\n\n    for i in 0..<(n \/ 2) {\n        if arr[i] != arr[n - i - 1] {\n            changes += 1\n        }\n    }\n\n    return changes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6]) == 4)\nassert(smallest_change(arr: [1, 2, 3, 4, 3, 2, 2]) == 1)\nassert(smallest_change(arr: [1, 4, 2]) == 1)\nassert(smallest_change(arr: [1, 4, 4, 2]) == 1)\nassert(smallest_change(arr: [1, 2, 3, 2, 1]) == 0)\nassert(smallest_change(arr: [3, 1, 1, 3]) == 0)\nassert(smallest_change(arr: [1]) == 0)\nassert(smallest_change(arr: [0, 1]) == 1)"},{"task_id":"HumanEval_74","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ \/\/ ⵎⴽ ⴷⴰⵔ ⵙⵏⴰⵜ ⵏ ⵜⴳⵡⵎⵎⴰ ⵏ ⵉⵎⵙⴷⴷⵉⵢⵏ ⵉⵎⵏⴹⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ, ⵙⵙⵓⴼⵖ ⵜⴰⴳⵡⵎⵎⴰ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ. \/\/ ⴰⵟⵟⵓⵏ ⵏ ⵜⴽⴰⵔⴽⵙ ⴳ ⴽⵓⵍⵍⵓ ⵜⵉⵙⵉⴹⴼⴰⵏ ⵏ ⵓⵙⵏⵙⵍ ⵎⵥⵥⵉⵢⵏ ⴳ ⵓⵙⵏⵙⵍ ⵢⴰⴹⵏ. \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵙⵏⴰⵜ ⵏ ⵜⵔⴱⴰⵜⵉⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⴷ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⴰⵔⴱⴰⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ \/\/\/ >>> total_match(lst1: [] as [String], lst2: [] as [String])\n\/\/\/ [] as [String]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"Hi\"])\n\/\/\/ [\"hI\", \"Hi\"]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\", \"admin\", \"project\"])\n\/\/\/ [\"hi\", \"admin\"]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hi\"])\n\/\/\/ [\"hI\", \"hi\", \"hi\"]\n\/\/\/ >>> total_match(lst1: [\"4\"], lst2: [\"1\", \"2\", \"3\", \"4\", \"5\"])\n\/\/\/ [\"4\"]\nfunc total_match(lst1: [String], lst2: [String]) -> [String] {\n","canonical_solution":"func total_match(lst1: [String], lst2: [String]) -> [String] {\n    let totalChars1 = lst1.reduce(0) { $0 + $1.count }\n    let totalChars2 = lst2.reduce(0) { $0 + $1.count }\n    \n    if totalChars1 < totalChars2 {\n        return lst1\n    } else if totalChars2 < totalChars1 {\n        return lst2\n    } else {\n        return lst1\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(total_match(lst1: [] as [String], lst2: [] as [String]) == [] as [String])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\"]) == [\"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\", \"admin\", \"project\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1: [\"4\"], lst2: [\"1\", \"2\", \"3\", \"4\", \"5\"]) == [\"4\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"Hi\"]) == [\"hI\", \"Hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hi\"]) == [\"hI\", \"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hii\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1: [] as [String], lst2: [\"this\"]) == [] as [String])\nassert(total_match(lst1: [\"this\"], lst2: [] as [String]) == [] as [String])"},{"task_id":"HumanEval_75","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⵏⵙⵙⵏ ⵎⴰⵙⴷ (ⴰ) ⵉⴳⴰ ⴷⵔⵓⵙ ⵏ 100. \/\/ ⴷ ⵜⵉⵣⴳⴰⵍⵜ ⵎⵇⵇⴰⵔ ⵓⵔ ⵜⵍⵍⵉ. \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵢⴰⴽⴽⴰⵏ ⵜⴰⵔⵎⵉⵜ ⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ \/\/\/ >>> is_multiply_prime(a: 30)\n\/\/\/ true\n\/\/\/ 30 = 2 * 3 * 5\nfunc is_multiply_prime(a: Int) -> Bool {\n","canonical_solution":"func is_multiply_prime(a: Int) -> Bool {\n    \/\/ Function to check if a number is prime\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    \/\/ Generate all prime numbers less than 100\n    var primes = [Int]()\n    for i in 2..<100 {\n        if isPrime(i) {\n            primes.append(i)\n        }\n    }\n    \n    \/\/ Check combinations of 3 primes\n    let primeCount = primes.count\n    for i in 0..<primeCount {\n        for j in i..<primeCount {\n            for k in j..<primeCount {\n                if primes[i] * primes[j] * primes[k] == a {\n                    return true\n                }\n            }\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_multiply_prime(a: 5) == false)\nassert(is_multiply_prime(a: 30) == true)\nassert(is_multiply_prime(a: 8) == true)\nassert(is_multiply_prime(a: 10) == false)\nassert(is_multiply_prime(a: 125) == true)\nassert(is_multiply_prime(a: 105) == true)\nassert(is_multiply_prime(a: 126) == false)\nassert(is_multiply_prime(a: 729) == false)\nassert(is_multiply_prime(a: 891) == false)\nassert(is_multiply_prime(a: 1001) == true)"},{"task_id":"HumanEval_76","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ x ⴷ ⴰⵙⵓⴳⴳⴰⵙ ⴰⵎⵢⵉⵡⵏ ⵏ n ⵎⴽ n**int=x \/\/ ⵜⴰⵣⵎⵔⵜ ⵏ n ⴷ ⵜⵉⵣⴳⵉⵍⵜ ⴳ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏⵉⵏ. \/\/ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵔⵔⴰ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ x ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⵀⴰⵢⵢⴰⵏ\/\/\/ >>> is_simple_power(x: 1, n: 4)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 2, n: 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 8, n: 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 3, n: 2)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(x: 3, n: 1)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(x: 5, n: 3)\n\/\/\/ false\nfunc is_simple_power(x: Int, n: Int) -> Bool {\n","canonical_solution":"func is_simple_power(x: Int, n: Int) -> Bool {\n    if x < 1 || n < 1 {\n        return false\n    }\n    if x == 1 {\n        return true \/\/ n**0 = 1\n    }\n    var power = 1\n    while power < x {\n        power *= n\n    }\n    return power == x\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_simple_power(x: 16, n: 2) == true)\nassert(is_simple_power(x: 143214, n: 16) == false)\nassert(is_simple_power(x: 4, n: 2) == true)\nassert(is_simple_power(x: 9, n: 3) == true)\nassert(is_simple_power(x: 16, n: 4) == true)\nassert(is_simple_power(x: 24, n: 2) == false)\nassert(is_simple_power(x: 128, n: 4) == false)\nassert(is_simple_power(x: 12, n: 6) == false)\nassert(is_simple_power(x: 1, n: 1) == true)\nassert(is_simple_power(x: 1, n: 12) == true)"},{"task_id":"HumanEval_77","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⴰⵖⴰⵔⴰⵙ: ⴰⴷ ⵜⵙⵙⵏⵎ ⵉⵙ ⵉⴳⴰ ⵡⴰⵏⵏⴰⵍ ⴰⵀⴰ ⵉⴳⴰ ⵜ ⴰⵣⵔⴼⴰⵏ. \/\/ ⵎⴽ ⵉⴳⴰ ⵡⵉⵏⴳⵉⵊⵉⵔ ⴰⴷ ⵢⴰⵏ ⵓⴽⵡⴼⴰⵢ ⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ. \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ a ⴰⵔ ⵉⵜⵜⵔ true \/\/\/ >>> iscube(a: 1)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 2)\n\/\/\/ false\n\/\/\/ >>> iscube(a: -1)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 64)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 0)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 180)\n\/\/\/ false\nfunc iscube(a: Int) -> Bool {\n","canonical_solution":"func iscube(a: Int) -> Bool {\n    if a == 0 { return true } \/\/ 0 is a cube (0^3)\n    let absA = abs(a)\n    let cubeRoot = Int(round(pow(Double(absA), 1.0\/3.0)))\n    return cubeRoot * cubeRoot * cubeRoot == absA\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(iscube(a: 1) == true)\nassert(iscube(a: 2) == false)\nassert(iscube(a: -1) == true)\nassert(iscube(a: 64) == true)\nassert(iscube(a: 180) == false)\nassert(iscube(a: 1000) == true)\nassert(iscube(a: 0) == true)\nassert(iscube(a: 1729) == false)"},{"task_id":"HumanEval_78","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⴷ ⵉⵙⵎⵎⴰⵍⵏ A,B,C,D,E,F ⴰⵀⴰ ⴳⴰⵏ ⵉⵎⵥⵍⵉⵢⵏ. \/\/ ⴰⵖⴰⵔⴰⵙ: ⵉⵖⵢ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉⴷ ⵉⵙ ⵉⴳⴰ ⵡⴰⵏⵙⴰ ⵏ ⵓⵙⴽⵛⵎ ⴰⵀⴰ ⵉⴳⴰ ⵜⴷⵓⵙ ⵏⵖⴷ ⵉⴳⴰ ⵡⴰⵏⵙⴰ ⵏ ⵓⴽⵛⵛⵓⵎ, ⴱ (= ⴷⵣⵉⵎⴰⵍ 11), ⴷ (= ⴷⵣⵉⵎⴰⵍ 13).\/\/ ⴰⵢⴰ ⴰⵖ ⵉⵇⵇⴰⵏ ⴰⴷ ⵏⵙⵙⴽⵏ ⵉⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⴰⴷ: 2, 3, 5, 7, \/\/ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴳⴰⵏ 2, 3, 5, 7, 11, 13, 17,... \/\/ ⵓⵟⵟⵓⵏⵏ ⵏ ⵓⴽⵙⵡⴰⵜ ⴳⴰⵏ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. \/\/ ⴰⵅⴰⵜⴰⵔ ⵙⴳ 1 ⵓⵔ ⵉⴳⵉ ⴰⵎⵢⴰⴼⵓ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵔⴰⵔⵏ).\/\/ ⵉⵎⴹⴰⵏⵏ ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ (ⵉⴹ ⴰⵎⵣⵡⴰⵔⵓ, ⵏⵖ ⴰⵎⵣⵡⴰⵔⵓ, ⵉⴳⴰ ⴰⵎⴹⴰⵏ ⴰⴳⴰⵎⴰⵏ \/\/ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵀⵉⵊⴰⴷⵉⵛⵎⴰⵍ ⴰⵎⵎ ⵢⴰⵜ ⵜⵣⵍⵉⵜ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⴷ ⴰⵔ ⵉⵙⵉⴹⵏ ⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵀⵉⵊⴰⴷⵉⵛⵎⴰⵍⵏ \/\/ ⵜⵜⵓⵣⵔⴰⴽ ⴰⴷ ⵜⴰⵔⵉⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵔⴰⴷ ⵢⴰⵎⵥ \/\/\/ >>> hex_key(num: \"AB\")\n\/\/\/ 1\n\/\/\/ >>> hex_key(num: \"1077E\")\n\/\/\/ 2\n\/\/\/ >>> hex_key(num: \"ABED1A33\")\n\/\/\/ 4\n\/\/\/ >>> hex_key(num: \"123456789ABCDEF0\")\n\/\/\/ 6\n\/\/\/ >>> hex_key(num: \"2020\")\n\/\/\/ 2\nfunc hex_key(num: String) -> Int {\n","canonical_solution":"func hex_key(num: String) -> Int {\n    \/\/ Define hexadecimal digits that are prime numbers\n    let primeHexDigits: Set<Character> = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n    \n    \/\/ Initialize count\n    var primeCount = 0\n    \n    \/\/ Iterate over each character in the string\n    for char in num {\n        \/\/ Check if the character is a prime hexadecimal digit\n        if primeHexDigits.contains(char) {\n            primeCount += 1\n        }\n    }\n    \n    return primeCount\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"},{"task_id":"HumanEval_79","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵓⴳⴳⴰⵔ ⵍⵍⴰⵏ ⴰⴼⴰⴷ ⴰⴷ ⵙⵙⵓⴷⵙⵏ ⵜⴰⵍⵖⴰ. \/\/ ⵔⴰⴷ ⵉⵍⵉⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵙⴽⴰⵔⵏ 'db' ⴳ ⵍⴱⴷⵓ ⴷ ⵜⴳⵉⵔⴰ ⵏ ⵜⵣⵍⵉⵜ. \/\/ ⵓⵟⵟⵓⵏ. ⴽⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ ⵜⵣⵍⵉⵜ ⵔⴰⴷ ⵉⴳⵏ '0' ⵏⵖ '1'. ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵔⴰ ⴰⴷ ⵜⵙⴽⵔ ⵢⴰⵏ ⵓⵙⴽⴽⵉⵍ, ⵙ ⴽⵓ ⵉⵙⴽⴽⵉⵍ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵏ ⵓⵙⴽⴽⵉⵍ ⴱⵉⵏⴰⵔⵉ \/\/ ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡⵏ ⴳ ⵜⴰⵍⵖⴰ ⵏ ⵜⵓⵙⴷⵉⴷⵜ ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⴼⵍⵜ ⵔ\/\/\/ >>> decimal_to_binary(decimal: 15)\n\/\/\/ \"db1111db\"\n\/\/\/ >>> decimal_to_binary(decimal: 32)\n\/\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal: Int) -> String {\n","canonical_solution":"func decimal_to_binary(decimal: Int) -> String {\n    let binaryString = String(decimal, radix: 2)\n    return \"db\" + binaryString + \"db\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(decimal_to_binary(decimal: 0) == \"db0db\")\nassert(decimal_to_binary(decimal: 32) == \"db100000db\")\nassert(decimal_to_binary(decimal: 103) == \"db1100111db\")\nassert(decimal_to_binary(decimal: 15) == \"db1111db\")"},{"task_id":"HumanEval_80","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⵜⴰⵡⵉⵍⴰ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵜⴳⴰ ⵜⴰⵡⵉⵍⴰ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵎⴽ ⵜⴳⴰ ⵜⴰⵖⵣⵉ ⵏⵏⵙ 3 ⴷ ⴽⵓ 3 ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵎⴹⴼⴰⵕⵏ ⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ \/\/ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵥⵕ ⵉⵙ ⵜⴳⴰ ⵜⵊⵎⵉⵍⵜ ⵜⴰⵎⵙⴷⴰⵍⵜ ⵏⵖ ⵓⵔ ⵜⴽⵉ. \/\/ ⵜⵜⵓⴼⴽⴰ ⵜ ⵢⴰⵜ ⵜⵓⵙⴷⵉⴷⵜ s. \/\/\/ >>> is_happy(s: \"a\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"aa\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"abcd\")\n\/\/\/ true\n\/\/\/ >>> is_happy(s: \"aabb\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"adb\")\n\/\/\/ true\n\/\/\/ >>> is_happy(s: \"xyy\")\n\/\/\/ false\nfunc is_happy(s: String) -> Bool {\n","canonical_solution":"func is_happy(s: String) -> Bool {\n    let characters = Array(s)\n    if characters.count < 3 {\n        return false\n    }\n    \n    for i in 0..<(characters.count - 2) {\n        if characters[i] == characters[i + 1] || characters[i] == characters[i + 2] || characters[i + 1] == characters[i + 2] {\n            return false\n        }\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"},{"task_id":"HumanEval_81","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ 0.0 E \/\/ > 0.0 ⴷ- \/\/ > 0.7 ⴷ \/\/ > 1.0 ⴷ+ \/\/ > 1.3 C- \/\/ > 1.7 C \/\/ > 2.0 C+ \/\/ > 2.3 ⴱ- \/\/ > 2.7 B \/\/ > 3.0 ⴱ+ \/\/ > 3.3 ⴰ- \/\/ > 3.7 ⴰ \/\/ 4.0 ⴰ + \/\/ GPA ∙ ⴰⵜⵉⴳ ⵏ ⵜⵉⵔⵔⴰ ∙\/\/ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵥⴹⴰⵕⵏ ⴰⴷ ⵉⴼⴽ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵙⵡⵉⵔⵏ ⵏ ⵜⵉⵔⵔⴰ ⵙ ⵓⵙⵎⵔⵙ ⵏ ⵓⵖⴰⵡⴰⵙ ⴰⴷ: \/\/ ⵜⵙⴽⵔ ⴽⵔⴰ ⵏ ⵉⵙⵡⴰⵍⵏ ⵏ ⴽⵔⴰ ⵏ ⵉⵏⵍⵎⴰⴷⵏ ⴷ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵔⵔⴰⵎ \/\/ ⴰⵙⵇⵙⵉ ⴷⴰⵢⵉ ⵉⴳⴰⵜ, ⵉⵙ ⵜⵙⵙⵓⵜⵍⵜ ⵜⴰⴽⵓⴷⵜ ⵏⵏⴰ ⵙⵙⵎⵔⴰⵙⵏⵜ ⵉ ⵓⵙⵜⴰⵍ. \/\/ ⵉ ⵉⵏⵍⵎⴰⴷⵏ. ⵉⵙⴽⵔ ⵓⵙⵍⵎⴰⴷ ⴰⵍⴳⵓⵔⵉⵜⵎ ⵏⵏⵙ ⵏ ⵓⵙⵜⴰⵍ. \/\/ ⴷ ⵉⵎⴰⵍⴰⵙⵙ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵜⵙⵓⵜⵍⵜ ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⴼⴽ ⵓⵙⵍⵎⴰⴷ ⵜⵉⵙⴽⵜⵉⵜⵉⵏ \/\/\/ >>> numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5])\n\/\/\/ [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nfunc numerical_letter_grade(grades: [Double]) -> [String] {\n","canonical_solution":"func numerical_letter_grade(grades: [Double]) -> [String] {\n    return grades.map { gpa in\n        switch gpa {\n        case 4.0:\n            return \"A+\"\n        case 3.7...4.0:\n            return \"A\"\n        case 3.3..<3.7:\n            return \"A-\"\n        case 3.0..<3.3:\n            return \"B+\"\n        case 2.7..<3.0:\n            return \"B\"\n        case 2.3..<2.7:\n            return \"B-\"\n        case 2.0..<2.3:\n            return \"C+\"\n        case 1.7..<2.0:\n            return \"C\"\n        case 1.3..<1.7:\n            return \"C-\"\n        case 1.0..<1.3:\n            return \"D+\"\n        case 0.7..<1.0:\n            return \"D\"\n        case 0.0..<0.7:\n            return \"D-\"\n        default:\n            return \"E\"\n        }\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5]) == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"])\nassert(numerical_letter_grade(grades: [1.2]) == [\"D+\"])\nassert(numerical_letter_grade(grades: [0.5]) == [\"D-\"])\nassert(numerical_letter_grade(grades: [0.0]) == [\"E\"])\nassert(numerical_letter_grade(grades: [1.0, 0.3, 1.5, 2.8, 3.3]) == [\"D\", \"D-\", \"C-\", \"B\", \"B+\"])\nassert(numerical_letter_grade(grades: [0.0, 0.7]) == [\"E\", \"D-\"])"},{"task_id":"HumanEval_82","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ \/\/ ⵜⵉⵖⵣⵉ ⵜⴳⴰ ⴰⵎⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵏⵖⴷ ⵜⵉⴳⵡⴷⵓⵜ \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵍⴰⵏ ⴰⵔ ⵉⵙⴽⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⵜⴳⴰ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵍⴰⵏ \/\/\/ >>> prime_length(string: \"Hello\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"abcdcba\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"kittens\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"orange\")\n\/\/\/ false\nfunc prime_length(string: String) -> Bool {\n","canonical_solution":"func prime_length(string: String) -> Bool {\n    let length = string.count\n    \n    guard length > 1 else {\n        return false\n    }\n    \n    for i in 2..<length {\n        if length % i == 0 {\n            return false\n        }\n    }\n    \n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_length(string: \"Hello\") == true)\nassert(prime_length(string: \"abcdcba\") == true)\nassert(prime_length(string: \"kittens\") == true)\nassert(prime_length(string: \"orange\") == false)\nassert(prime_length(string: \"wow\") == true)\nassert(prime_length(string: \"world\") == true)\nassert(prime_length(string: \"MadaM\") == true)\nassert(prime_length(string: \"Wow\") == true)\nassert(prime_length(string: \"\") == false)\nassert(prime_length(string: \"HI\") == true)\nassert(prime_length(string: \"go\") == true)\nassert(prime_length(string: \"gogo\") == false)\nassert(prime_length(string: \"aaaaaaaaaaaaaaa\") == false)\nassert(prime_length(string: \"Madam\") == true)\nassert(prime_length(string: \"M\") == false)\nassert(prime_length(string: \"0\") == false)"},{"task_id":"HumanEval_83","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⴷⵉⵢⵏ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴷⴰⵢⵏ ⵏⵖ ⵉⵜⵜⵉⵔⴰⵢⵏ ⵙ 1. \/\/ ⴰⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⴽⵔ ⵜⴰⵙⵙⵉⴹⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ n ⴹⵊⵉⵜ func starts_one_ends(n: Int) -> Int {\n","canonical_solution":"func starts_one_ends(n: Int) -> Int {\n    if n == 1 {\n        \/\/ For a 1-digit number, it can be either starting or ending with 1, which is just the number 1.\n        return 1\n    }\n    \n    \/\/ Count of n-digit numbers starting with 1:\n    \/\/ First digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9.\n    let startWithOne = Int(pow(10.0, Double(n - 1)))\n    \n    \/\/ Count of n-digit numbers ending with 1:\n    \/\/ Last digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9, but cannot be zero at the first place.\n    \/\/ So these are (n-1) digit numbers that can be from 10^(n-1) to (10^n - 1), of which we need the count.\n    let endWithOne = Int(pow(10.0, Double(n - 1)))\n    \n    \/\/ Intersection of both sets is the numbers starting and ending with 1\n    \/\/ which are of the form `1` followed by (n-2) digits and `1`, so:\n    let startAndEndWithOne = Int(pow(10.0, Double(n - 2)))\n    \n    return startWithOne + endWithOne - startAndEndWithOne\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(starts_one_ends(n: 1) == 1)\nassert(starts_one_ends(n: 2) == 18)\nassert(starts_one_ends(n: 3) == 180)\nassert(starts_one_ends(n: 4) == 1800)\nassert(starts_one_ends(n: 5) == 18000)"},{"task_id":"HumanEval_84","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ \/\/ ⴰⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ N, ⵙⵙⵓⴼⵖ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⵙ ⵜⴱⵉⵏⴰⵔⵉⵜ. \/\/\/ >>> solve(N: 1000)\n\/\/\/ \"1\"\n\/\/\/ >>> solve(N: 150)\n\/\/\/ \"110\"\n\/\/\/ >>> solve(N: 147)\n\/\/\/ \"1100\"\n\/\/\/ Variables:\n\/\/\/ @N integer\n\/\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/\/ Output:\n\/\/\/ a string of binary number\nfunc solve(N: Int) -> String {\n","canonical_solution":"func solve(N: Int) -> String {\n    let sumOfDigits = String(N).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    return String(sumOfDigits, radix: 2)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"},{"task_id":"HumanEval_85","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⴰⵖ ⴷ ⵢⵉⵡⵉ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵅⴷⴷⴰⵎⵏ ⵣⵡⴰⵔ. ⵔⵏⵓⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵉⵙⵓⵎⴰⵔ ⵉⵎⵣⴰⵔⴰⵢⵏ.. \/\/\/ >>> add(lst: [4, 2, 6, 7])\n\/\/\/ 2\nfunc add(lst: [Int]) -> Int {\n","canonical_solution":"func add(lst: [Int]) -> Int {\n    var sum = 0\n    for i in stride(from: 1, to: lst.count, by: 2) {\n        if lst[i] % 2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add(lst: [4, 88]) == 88)\nassert(add(lst: [4, 5, 6, 7, 2, 122]) == 122)\nassert(add(lst: [4, 0, 6, 7]) == 0)\nassert(add(lst: [4, 4, 6, 8]) == 12)"},{"task_id":"HumanEval_86","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⴰⵖⵏⵏⵉⵊ: ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵃⴹⵓ ⵜⴰⴼⵔⴰⵔⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⵡⴰⵏⵙⴰ ⵉⵍⵍⴰⵏ ⴳ ⵜⴳⵓⵔⵉ. \/\/ ⴰⴹⴼⴼⵓⵕ ⴰⵎⵓⵟⵟⵓⵏ ⵅⴼ ⵡⴰⵜⵉⴳ ⵏ ascii. \/\/ ⴷⴰ ⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⵙ ⵜⴳⵓⵔⵉ ⵜⴰⵎⴰⵢⵏⵓⵜ ⴳ ⵔⴰⴷ ⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ \/\/ ⵜⴰⵡⵍⴰⴼⵜ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵜⴳⴰ ⵜⵉⴼⵉⵏⴰⵖ ⴳ ⵍⵍⴰⵏⵜ ⴽⵓⵍⵍⵓ ⵜⴳⵓⵔⵉⵡⵉⵏ (ⵉⴱⴹⴰⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ) \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵎⴰⵍ ⴷ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵜ ⵜⵓⵏⵖⵉⵍⵜ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⵏ. \/\/\/ >>> anti_shuffle(s: \"Hi\")\n\/\/\/ \"Hi\"\n\/\/\/ >>> anti_shuffle(s: \"hello\")\n\/\/\/ \"ehllo\"\n\/\/\/ >>> anti_shuffle(s: \"Hello World!!!\")\n\/\/\/ \"Hello !!!Wdlor\"\nfunc anti_shuffle(s: String) -> String {\n","canonical_solution":"func anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy: .whitespaces)\n    let orderedWords = words.map { String($0.sorted()) }\n    var result = \"\"\n    var wordIndex = 0\n    \n    for character in s {\n        if character.isWhitespace {\n            result.append(character)\n        } else if wordIndex < orderedWords.count {\n            if let currentWord = orderedWords[wordIndex].first {\n                result.append(currentWord)\n                orderedWords[wordIndex].remove(at: orderedWords[wordIndex].startIndex)\n            }\n        }\n        \n        if let lastCharacter = result.last {\n            if lastCharacter.isWhitespace {\n                wordIndex += 1\n            }\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"},{"task_id":"HumanEval_87","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⴰⵡⴷ, ⵙⵙⵓⴷⵙ ⵜⵉⵙⵖⵏⵙⵉⵡⵉⵏ ⵏ ⵜⵙⴽⴼⵍⵜ ⵙ ⵜⵔⵙⴰⵍ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵏⵣⵓ. \/\/ ⵙⵙⵓⴷⵙ ⴰⴽⵓⵓⵔⴷⵉⴰⵜⵏ ⴳ ⵜⵉⵣⵡⵉⵔⵉ ⵙ ⵜⵉⴼⵔⵉⵙⵉⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵇⵔⴰⵏ. \/\/ ⴽⵓ ⵜⴰⴱⵍⵓⵜ ⵜⴳⴰ ⴽⵓⵓⵔⴷⵉⴷⴰⵜ - (ⵜⵉⵔⵉⵜ, ⵜⵉⵔⵙⴰⵍ), ⴰⵔ ⵜⴱⴷⴰⴷ ⵙ 0. \/\/ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴰ ⴰⵙⵔⴰⵙ ⵏ ⵜⵓⵔⴷⵉⵡⵉⵏ, [(x1, y1), (x2, y2) ...] ⵣⵓⵏⴷ ⵎⴰⵙ \/\/ ⴷⴰⵜ ⵏ lst, ⴷ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ x, ⵥⵕ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ x ⴳ ⵓⵎⵙⴳⴷⴰⵍ, \/\/ ⴽⵓ ⵜⴰⵡⵔⵉⴼⵜ ⵜⵣⵎⵔ ⴰⴷ ⵜⵓⵎⵣ ⴰⵎⴹⴰⵏ ⵏ ⵜⵔⵙⴰⵍ ⵉⵎⵣⴰⵔⴰⵢⵏ. \/\/ ⵏⵏⴰ ⵢⴰⴽⵙⵓⵍⵏ ⴷ ⵎⴰⵜⵔⵉⵙ, ⵎⴰⵛⴰ, ⵓⵔ ⵢⴰⴽⵙⵓⵍⵏ ⴷ ⵎⴰⵜⵔⵉⵙ, \/\/ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡⵏ ⵏ ⵙⵉⵏ ⵡⵓⴳⴳⵓⴳⵏ, ⵙ ⵜⴰⵍⵖⵉⵡⵉⵏ ⵏ ⵉⵎⵙⴷⴷⵉ, \/\/\/ >>> get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n\/\/\/ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\/\/\/ >>> get_row(lst: [] as [[Int]], x: 1)\n\/\/\/ [] as [(Int, Int)]\n\/\/\/ >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3)\n\/\/\/ [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n","canonical_solution":"func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var coordinates: [(Int, Int)] = []\n    \n    for (rowIndex, row) in lst.enumerated() {\n        for (colIndex, value) in row.enumerated() {\n            if value == x {\n                coordinates.append((rowIndex, colIndex))\n            }\n        }\n    }\n    \n    let sortedCoordinates = coordinates.sorted {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n        } else {\n            return $0.0 < $1.0\n        }\n    }\n    \n    return sortedCoordinates\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"},{"task_id":"HumanEval_88","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ * ⵓⵔ ⴷⴰ ⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⵉⵎⵙⴷⴷⵉⵢⵏ ⵏⵏⴰ ⴷ ⵢⵓⴼⴰ. \/\/ ⴰⵖⴰⵔⴰⵙ: \/\/ ⵏⵖ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⴷⴰⵔⵓ ⵎⴽ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵓⴷⵙ ⴰⵎⴳⴳⴰⵔⵓ) ⴰⵎⵙⴽⵙⵡⴰⵜ. \/\/ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⴰⵙⴼⵙⵉ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵓⵙⵙⵓ ⵎⴽ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⵡⴰⵔⵓ, ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵓⴷⵙ ⴰⵎⴳⴳⴰⵔⵓ) ⵓⵔ ⵉⵎⵙⴰⵙⴰⵏ, \/\/ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵔⵉⵏ, ⵔⵎⵙⵏ ⴰⵙⵎⵓⵜⵜⴳ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵎⵓⵜⵜⴳ, \/\/\/ >>> sort_array(array: [] as [Int])\n\/\/\/ [] as [Int]\n\/\/\/ >>> sort_array(array: [5])\n\/\/\/ [5]\n\/\/\/ >>> sort_array(array: [2, 4, 3, 0, 1, 5])\n\/\/\/ [0, 1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(array: [2, 4, 3, 0, 1, 5, 6])\n\/\/\/ [6, 5, 4, 3, 2, 1, 0]\nfunc sort_array(array: [Int]) -> [Int] {\n","canonical_solution":"func sort_array(array: [Int]) -> [Int] {\n    guard let first = array.first, let last = array.last else {\n        return array\n    }\n    let sum = first + last\n    if sum % 2 == 0 {\n        return array.sorted(by: >) \/\/ Descending order\n    } else {\n        return array.sorted() \/\/ Ascending order\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(array: [] as [Int]) == [] as [Int])\nassert(sort_array(array: [5]) == [5])\nassert(sort_array(array: [2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\nassert(sort_array(array: [2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\nassert(sort_array(array: [2, 1]) == [1, 2])\nassert(sort_array(array: [15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\nassert(sort_array(array: [21, 14, 23, 11]) == [23, 21, 14, 11])"},{"task_id":"HumanEval_89","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⵙⵙⵉⴼⵜ ⵙ ⵙⵉⵏ ⵙ ⵙⵏⴰⵜ ⵜⵏⴰⴼⵓⵜⵉⵏ. \/\/ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵏⵙⵙⵎⵓⵜⵜⴳ ⴰⴱⵉⴷⵢⵓ ⵙ ⵢⴰⵜ ⵜⵖⴰⵔⴰⵙⵜ ⵏⵏⴰ ⵔⴰⴷ ⵔⴰⵔⵏⵜ ⵜⴱⵔⴰⵜⵉⵏ \/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⴽⵜⵓⵎ ⵉⵜⵜⵓⵣⵎⵎⴻⵎⵏ ⵙ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⴼⵉⵏⴰⵖ. \/\/ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏ ⵓⵙⵉⴼⵙⵉ ⵏⵏⴰ ⵉⵙⴽⴰⵔⵏ ⴰⵙⴽⴽⵉⵍ ⴰⵎⵎ ⵓⵎⵏⵣⴰⵖ ⴷ \/\/\/ >>> encrypt(s: \"hi\")\n\/\/\/ \"lm\"\n\/\/\/ >>> encrypt(s: \"asdfghjkl\")\n\/\/\/ \"ewhjklnop\"\n\/\/\/ >>> encrypt(s: \"gf\")\n\/\/\/ \"kj\"\n\/\/\/ >>> encrypt(s: \"et\")\n\/\/\/ \"ix\"\nfunc encrypt(s: String) -> String {\n","canonical_solution":"func encrypt(s: String) -> String {\n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    let shift = 2 * 2 \/\/ shift down by two multiplied by two places, i.e., 4\n    var result = \"\"\n\n    for character in s {\n        if let index = alphabet.firstIndex(of: character) {\n            let newIndex = (index + shift) % alphabet.count\n            result.append(alphabet[newIndex])\n        } else {\n            result.append(character) \/\/ append non-alphabetic characters unchanged\n        }\n    }\n\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") == \"e\")"},{"task_id":"HumanEval_90","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ nil ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵓⵏⴰⵡ ⴰⴷ. \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ next_smallest (() ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴽⴽⵍⵜ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⴳ ⵉⵎⵥⵥⵢⴰⵏⵏ ⵏ ⵓⵎⵙⴳⴷⴰⵍ. \/\/ ⵏⵜⵜⴰⴼⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. \/\/\/ >>> next_smallest(lst: [1, 2, 3, 4, 5])\n\/\/\/ 2\n\/\/\/ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n\/\/\/ 2\n\/\/\/ >>> next_smallest(lst: [] as [Int])\n\/\/\/ nil\n\/\/\/ >>> next_smallest(lst: [1, 1])\n\/\/\/ nil\nfunc next_smallest(lst: [Int]) -> Int? {\n","canonical_solution":"func next_smallest(lst: [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    \n    var uniqueSorted = Array(Set(lst)).sorted()\n    \n    if uniqueSorted.count < 2 {\n        return nil\n    }\n    \n    return uniqueSorted[1]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"},{"task_id":"HumanEval_91","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⴷⴰ ⵜⵜⵓⵙⴳⵣⵏ ⵜⵉⴳⵓⵔⵉⵡⵉⵏ ⵙ '.', '?' ⵏⵖ '!'. \/\/ ⵏ ⵜⵔⴳⴰⵍ. ⵜⴰⵔⴳⴰⵍⵜ ⵜⴳⴰ ⵢⴰⵜ ⵜⴳⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵙ ⵜⴳⵓⵔⵉ \"ⵉ\". \/\/ ⴰⴷ ⴽⴽⵙⴷ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ, ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⴰⴷ ⵜⵙⵙⵉⴹⵏ ⴰⵎⴹⴰⵏ \/\/\/ >>> is_bored(S: \"Hello world\")\n\/\/\/ 0\n\/\/\/ >>> is_bored(S: \"The sky is blue. The sun is shining. I love this weather\")\n\/\/\/ 1\nfunc is_bored(S: String) -> Int {\n","canonical_solution":"func is_bored(S: String) -> Int {\n    let sentences = S.split { $0 == '.' || $0 == '?' || $0 == '!' }\n    var boredomCount = 0\n    \n    for sentence in sentences {\n        let trimmedSentence = sentence.trimmingCharacters(in: .whitespaces)\n        if trimmedSentence.hasPrefix(\"I\") {\n            boredomCount += 1\n        }\n    }\n    \n    return boredomCount\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_bored(S: \"Hello world\") == 0)\nassert(is_bored(S: \"Is the sky blue?\") == 0)\nassert(is_bored(S: \"I love It !\") == 1)\nassert(is_bored(S: \"bIt\") == 0)\nassert(is_bored(S: \"I feel good today. I will be productive. will kill It\") == 2)\nassert(is_bored(S: \"You and I are going for a walk\") == 0)"},{"task_id":"HumanEval_92","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ \/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴼⵍⵡⵉⵜ ⴳ ⴽⵔⴰ ⵏ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏⵉⵏ. \/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵢⴰⵏ ⵙⴳ ⵉⵎⴹⴰⵏⵏ ⴰⵎⵎ ⵓⴳⵣⵓⵎ ⵏ ⵙⵉⵏ ⵢⴰⴹⵏⵉⵏ, ⴷ ⵎⴰⵕⵕⴰ ⵉⵎⴹⴰⵏⵏ ⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. \/\/ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏ. \/\/\/ >>> any_int(x: 5, y: 2, z: 7)\n\/\/\/ true\n\/\/\/ >>> any_int(x: 3, y: 2, z: 2)\n\/\/\/ false\n\/\/\/ >>> any_int(x: 3, y: -2, z: 1)\n\/\/\/ true\n\/\/\/ >>> any_int(x: 3.6, y: -2.2, z: 2)\n\/\/\/ false\nfunc any_int(x: Double, y: Double, z: Double) -> Bool {\n","canonical_solution":"func any_int(x: Double, y: Double, z: Double) -> Bool {\n    guard x == floor(x), y == floor(y), z == floor(z) else {\n        return false\n    }\n    \n    let a = Int(x)\n    let b = Int(y)\n    let c = Int(z)\n    \n    return a == b + c || b == a + c || c == a + b\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(any_int(x: 2, y: 3, z: 1) == true)\nassert(any_int(x: 2.5, y: 2, z: 3) == false)\nassert(any_int(x: 1.5, y: 5, z: 3.5) == false)\nassert(any_int(x: 2, y: 6, z: 2) == false)\nassert(any_int(x: 4, y: 2, z: 2) == true)\nassert(any_int(x: 2.2, y: 2.2, z: 2.2) == false)\nassert(any_int(x: -4, y: 6, z: 2) == true)\nassert(any_int(x: 2, y: 1, z: 1) == true)\nassert(any_int(x: 3, y: 4, z: 7) == true)\nassert(any_int(x: 3.0, y: 4, z: 7) == false)"},{"task_id":"HumanEval_93","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⵙⵙⵓⵎⵔ ⴷⴰⵢ ⵉⵙⴽⴽⵉⵍⵏ. \/\/ ⴰⵖⵔⵉ ⴳ ⵓⴳⵎⵎⴰⵢ ⴰⴱⵔⵍⴰⵎⴰⵏⵉ. \/\/ ⵜⴰⴱⵔⴰⵜ ⵙ ⵜⴱⵔⴰⵜ ⵏⵏⴰ ⵉⵜⵜⵉⵍⵉⵏ ⵙⵏⴰⵜ ⵏ ⵡⴰⵏⵙⴰ ⴷⴰⵜ ⵏ ⵜⴱⵔⴰⵜ \/\/ ⴰⴱⵔⵉⴷ ⵏⵏⴰ ⵉⵙⵏⴼⵍⵏ ⵜⵉⴽⴽⵍⵜ ⵏ ⴽⵓⵍⵍⵓ ⵜⵉⵔⵔⴰ, ⵉⵙⵏⴼⵍ ⴽⵓⵍⵍⵓ ⵉⵎⵙⵍⵉ ⴳ \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⴰⵔ ⵜⵙⵙⵓⴷⵙ ⴳ ⵢⴰⵏ \/\/\/ >>> encode(message: \"test\")\n\/\/\/ \"TGST\"\n\/\/\/ >>> encode(message: \"This is a message\")\n\/\/\/ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n","canonical_solution":"func encode(message: String) -> String {\n    let vowels = \"aeiouAEIOU\"\n    let vowelReplacement = [\n        \"a\": \"c\", \"e\": \"g\", \"i\": \"k\", \"o\": \"q\", \"u\": \"w\",\n        \"A\": \"C\", \"E\": \"G\", \"I\": \"K\", \"O\": \"Q\", \"U\": \"W\"\n    ]\n    \n    var encodedMessage = \"\"\n    \n    for char in message {\n        if vowels.contains(char) {\n            if let replacement = vowelReplacement[String(char)] {\n                encodedMessage.append(replacement)\n            }\n        } else {\n            let swappedCase = char.isUppercase ? Character(char.lowercased()) : Character(char.uppercased())\n            encodedMessage.append(swappedCase)\n        }\n    }\n    \n    return encodedMessage\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"},{"task_id":"HumanEval_94","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⴰⴼⴷ ⴰⵜⵉⴳ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ ⴷ ⴰⴷ ⵜⵔⴰⵔⴷ ⵜⴰⴳⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ. \/\/ ⵏⵜⵜⴰⴼⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. \/\/\/ >>> skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/\/ 10\n\/\/\/ >>> skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/\/ 25\n\/\/\/ >>> skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/\/ 13\n\/\/\/ >>> skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/\/ 11\n\/\/\/ >>> skjkasdkd(lst: [0, 81, 12, 3, 1, 21])\n\/\/\/ 3\n\/\/\/ >>> skjkasdkd(lst: [0, 8, 1, 2, 1, 7])\n\/\/\/ 7\nfunc skjkasdkd(lst: [Int]) -> Int {\n","canonical_solution":"func skjkasdkd(lst: [Int]) -> Int {\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 { return false }\n            i += 6\n        }\n        return true\n    }\n    \n    var largestPrime: Int? = nil\n    for number in lst {\n        if isPrime(number) {\n            if largestPrime == nil || number > largestPrime! {\n                largestPrime = number\n            }\n        }\n    }\n    \n    if let largestPrime = largestPrime {\n        return String(largestPrime).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    }\n    \n    return 0 \/\/ In case there are no prime numbers\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10)\nassert(skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25)\nassert(skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13)\nassert(skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11)\nassert(skjkasdkd(lst: [0, 81, 12, 3, 1, 21]) == 3)\nassert(skjkasdkd(lst: [0, 8, 1, 2, 1, 7]) == 7)\nassert(skjkasdkd(lst: [8191]) == 19)\nassert(skjkasdkd(lst: [8191, 123456, 127, 7]) == 19)\nassert(skjkasdkd(lst: [127, 97, 8192]) == 10)"},{"task_id":"HumanEval_96","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴷ ⵉⵎⵥⵥⵉⵏ ⵙⴳ n. \/\/ ⵙⵙⴽⵔ ⵢⴰⵜ ⵜⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⵔⵉⵏⵉ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ n \/\/\/ >>> count_up_to(n: 5)\n\/\/\/ [2, 3]\n\/\/\/ >>> count_up_to(n: 11)\n\/\/\/ [2, 3, 5, 7]\n\/\/\/ >>> count_up_to(n: 0)\n\/\/\/ [] as [Int]\n\/\/\/ >>> count_up_to(n: 20)\n\/\/\/ [2, 3, 5, 7, 11, 13, 17, 19]\n\/\/\/ >>> count_up_to(n: 1)\n\/\/\/ [] as [Int]\n\/\/\/ >>> count_up_to(n: 18)\n\/\/\/ [2, 3, 5, 7, 11, 13, 17]\nfunc count_up_to(n: Int) -> [Int] {\n","canonical_solution":"func count_up_to(n: Int) -> [Int] {\n    guard n > 2 else { return [] }\n    \n    var primes: [Int] = [2]\n    \n    for number in 3..<n {\n        var isPrime = true\n        for prime in primes {\n            if prime * prime > number {\n                break\n            }\n            if number % prime == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes.append(number)\n        }\n    }\n    \n    return primes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_up_to(n: 5) == [2, 3])\nassert(count_up_to(n: 6) == [2, 3, 5])\nassert(count_up_to(n: 7) == [2, 3, 5])\nassert(count_up_to(n: 10) == [2, 3, 5, 7])\nassert(count_up_to(n: 0) == [] as [Int])\nassert(count_up_to(n: 22) == [2, 3, 5, 7, 11, 13, 17, 19])\nassert(count_up_to(n: 1) == [] as [Int])\nassert(count_up_to(n: 18) == [2, 3, 5, 7, 11, 13, 17])\nassert(count_up_to(n: 47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\nassert(count_up_to(n: 101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])"},{"task_id":"HumanEval_97","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⵏⵙⵙⵏ ⵉⵙ ⵉⴳⴰ ⵡⴰⵏⵏⴰⵍ ⴰⵀⴰ ⵉⴳⴰ ⵜ ⴰⵣⵔⴼⴰⵏ. \/\/ ⴰⵙⵎⵓⵜⵜⴳ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴰⴳⵣⵣⵓⵎⵜ ⵏⵏⵙⵏ. \/\/ ⵙⵎⵓⵜⵜⴳ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⴰⵔ ⵉⵜⵜⵔ \/\/\/ >>> multiply(a: 148, b: 412)\n\/\/\/ 16\n\/\/\/ >>> multiply(a: 19, b: 28)\n\/\/\/ 72\n\/\/\/ >>> multiply(a: 2020, b: 1851)\n\/\/\/ 0\n\/\/\/ >>> multiply(a: 14, b: -15)\n\/\/\/ 20\nfunc multiply(a: Int, b: Int) -> Int {\n","canonical_solution":"func multiply(a: Int, b: Int) -> Int {\n    let unitDigitA = abs(a % 10)\n    let unitDigitB = abs(b % 10)\n    return unitDigitA * unitDigitB\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(multiply(a: 148, b: 412) == 16)\nassert(multiply(a: 19, b: 28) == 72)\nassert(multiply(a: 2020, b: 1851) == 0)\nassert(multiply(a: 14, b: -15) == 20)\nassert(multiply(a: 76, b: 67) == 42)\nassert(multiply(a: 17, b: 27) == 49)\nassert(multiply(a: 0, b: 1) == 0)\nassert(multiply(a: 0, b: 0) == 0)"},{"task_id":"HumanEval_98","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⵙ ⵓⵙⴽⴽⵉⵍ s, ⵙⵙⵉⴹⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵏ ⵉⵎⵙⵍⵉ ⵏ ⵜⴳⵓⵔⵉ ⵜⴰⵎⵇⵔⴰⵏⵜ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵎⵓⵟⵟⵓⵏⵏ. \/\/\/ >>> count_upper(s: \"aBCdEf\")\n\/\/\/ 1\n\/\/\/ >>> count_upper(s: \"abcdefg\")\n\/\/\/ 0\n\/\/\/ >>> count_upper(s: \"dBBE\")\n\/\/\/ 0\nfunc count_upper(s: String) -> Int {\n","canonical_solution":"func count_upper(s: String) -> Int {\n    let upperVowels = Set<Character>([\"A\", \"E\", \"I\", \"O\", \"U\"])\n    var count = 0\n\n    for (index, char) in s.enumerated() {\n        if index % 2 == 0 && upperVowels.contains(char) {\n            count += 1\n        }\n    }\n\n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"},{"task_id":"HumanEval_99","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ \/\/ ⵙⴳ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⵜⵜⵔ ⴰⵙⵏ ⵙⴳ ⵓⵎⵢⴰ. \/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⴽⴽⵡ ⵉⵎⵉⵣⴰⵔ ⵏⵏⵙ. ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⴷ ⴰⵎⴹⴰⵏ ⵉⵎⵉⵣⴰⵔ ⵏⵏⵙ \/\/ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵡⴰⵜⵉⴳ (ⵜⴰⵏⴳⴰⵍⵜ) ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵏ ⵓⵟⵟⵓⵏ \/\/\/ >>> closest_integer(value: \"10\")\n\/\/\/ 10\n\/\/\/ >>> closest_integer(value: \"15.3\")\n\/\/\/ 15\n\/\/\/ Note:\n\/\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/\/ from two integers, the one you should return is the one that is the\n\/\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n","canonical_solution":"func closest_integer(value: String) -> Int {\n    if let number = Double(value) {\n        return Int(number.rounded(.awayFromZero))\n    }\n    return 0 \/\/ or handle error as needed\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"},{"task_id":"HumanEval_100","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ i ⴷⴰ ⵉⵙⵎⴷⵢⴰ ⵓⵟⵟⵓⵏ ⵏ ⵉⵔⵖⴰⵏ ⴳ ⵓⵙⵡⵉⵔ (i+1). \/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵓⵟⵟⵓⵏ ⵏ ⵉⵔⵖⴰⵏ ⴳ ⴽⵓ ⴰⵙⵡⵉⵔ ⴳ ⵢⴰⵏ ⵓⵙⵏⵙⵍ, ⴳ ⵉⵍⵍⴰ ⵓⵏⴰⵎⴽ ⴳ ⵓⵙⵏⵙⵍ - ⴰⵎⴹⴰⵏ ⴰⵎⵎⵓⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵉⴳ n ⵉⴳⴰ ⴰⵎⵎⵓⴹⴰⵏ.- ⴰⵎⴹⴰⵏ ⴰⵎⵢⵉⵡⵏ ⴰⴹⵏⵉⵏ ⵎⴽ n ⵉⴳⴰ ⴰⵎⵢⵉⵡⵏ.\/\/ ⴰⵟⵟⵓⵏ ⵏ ⵉⵔⵖⴰⵏ ⴳ ⵓⵙⵡⵉⵔ ⵢⴰⴹⵏ ⵉⴳⴰ ⵜ: \/\/ ⴰⵙⵡⵉⵔ ⴰⵎⵣⵡⴰⵔⵓ ⴷⴰⵔⵙ n ⵉⵔⵖⴰⵏ. \/\/ ⴰⵛⴽⵓ ⵏⵜⵜⴰⴼ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ n, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵏⵙⴽⵔ ⵢⴰⵜ ⵜⵔⴱⴰⵜ ⵏ n ⵉⵙⵡⵉⵔⵏ ⵏ ⵉⵔⵖⴰⵏ. \/\/\/ >>> make_a_pile(n: 3)\n\/\/\/ [3, 5, 7]\nfunc make_a_pile(n: Int) -> [Int] {\n","canonical_solution":"func make_a_pile(n: Int) -> [Int] {\n    var pile = [Int]()\n    var currentLevelStones = n\n    \n    for _ in 0..<n {\n        pile.append(currentLevelStones)\n        if n % 2 == 0 {\n            currentLevelStones += 2\n        } else {\n            currentLevelStones += 2\n        }\n    }\n    \n    return pile\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(make_a_pile(n: 3) == [3, 5, 7])\nassert(make_a_pile(n: 4) == [4, 6, 8, 10])\nassert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])\nassert(make_a_pile(n: 6) == [6, 8, 10, 12, 14, 16])\nassert(make_a_pile(n: 8) == [8, 10, 12, 14, 16, 18, 20, 22])"},{"task_id":"HumanEval_101","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⴰⴷ ⵜⴱⴹⵉⴷ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴼ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⴰⴷ ⵜⵙⴽⵔⴷ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ. \/\/ ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⴱⴹⴰⵏ ⵙ ⵜⴽⵓⵎⵉⵏ ⵏⵖ ⴷ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ \/\/\/ >>> words_string(s: \"Hi, my name is John\")\n\/\/\/ [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n\/\/\/ >>> words_string(s: \"One, two, three, four, five, six\")\n\/\/\/ [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nfunc words_string(s: String) -> [String] {\n","canonical_solution":"func words_string(s: String) -> [String] {\n    let separators = CharacterSet(charactersIn: \", \")\n    return s.components(separatedBy: separators).filter { !$0.isEmpty }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(words_string(s: \"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"])\nassert(words_string(s: \"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"Hi, my name\") == [\"Hi\", \"my\", \"name\"])\nassert(words_string(s: \"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"\") == [] as [String])\nassert(words_string(s: \"ahmed     , gamal\") == [\"ahmed\", \"gamal\"])"},{"task_id":"HumanEval_102","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⵓⵔ ⵉⵍⵍⵉ ⵡⵓⵟⵟⵓⵏ ⴰⴷ, ⵔⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ -1. \/\/ ⴰⵎⴹⴰⵏ ⴰⵎⵇⵇⵔⴰⵏ ⴰⵎⴷⴷⴰⴽⴽⵍ ⴳ ⵓⵙⵏⴼⵍ [x, y] ⴳ ⵜⵓⵎⵣⵉⵏ. ⵎⴽ \/\/ ⴷⴰ ⵜⴽⴽⴰ ⵜⵎⵔⵙⵍⵜ ⴰⴷ ⵙⵉⵏ ⵉⵎⴹⴰⵏⵏ ⵉⴽⵙⵡⴰⵜⵏ x ⴷ y ⴰⵔ ⵜⵔⴰⵔ \/\/\/ >>> choose_num(x: 12, y: 15)\n\/\/\/ 14\n\/\/\/ >>> choose_num(x: 13, y: 12)\n\/\/\/ -1\nfunc choose_num(x: Int, y: Int) -> Int {\n","canonical_solution":"func choose_num(x: Int, y: Int) -> Int {\n    \/\/ Determine the starting and ending range values\n    let start = min(x, y)\n    let end = max(x, y)\n    \n    \/\/ Iterate from the end of the range to the start\n    for num in (start...end).reversed() {\n        \/\/ Check if the current number is even\n        if num % 2 == 0 {\n            return num\n        }\n    }\n    \n    \/\/ Return -1 if no even number is found\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(choose_num(x: 12, y: 15) == 14)\nassert(choose_num(x: 13, y: 12) == -1)\nassert(choose_num(x: 33, y: 12354) == 12354)\nassert(choose_num(x: 5234, y: 5233) == -1)\nassert(choose_num(x: 6, y: 29) == 28)\nassert(choose_num(x: 27, y: 10) == -1)\nassert(choose_num(x: 7, y: 7) == -1)\nassert(choose_num(x: 546, y: 546) == 546)"},{"task_id":"HumanEval_103","nl":"tzm_Tfng","pl":"swift","prompt":"\nextension Int: Error {}\n        \n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⵎⴽ n ⵢⵓⴳⵔⵏ m, ⵙⴽⵔ -1. \/\/ ⵙⵙⵓⴷⵓⵏ ⵜⴰⵔⴰⵔⵓⵜ ⵖⵔ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵇⵇⵓⵔⵏ ⴷ ⵙⵙⴼⵍⴷⵏ ⴰⵙ ⵖⵔ ⴱⵉⵏⴰⵔⵉ. \/\/ ⴰⵎⵎⴰⵙⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙⴳ n ⴰⵔ m (ⴰⵎⵎ n ⴷ m). \/\/ ⵏⵜⵜⴰⴼⴰ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏ ⴷ ⵎ, ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵉⴹⵏ \/\/\/ >>> rounded_avg(n: 1, m: 5)\n\/\/\/ .success(\"0b11\")\n\/\/\/ >>> rounded_avg(n: 7, m: 5)\n\/\/\/ .failure(-1)\n\/\/\/ >>> rounded_avg(n: 10, m: 20)\n\/\/\/ .success(\"0b1111\")\n\/\/\/ >>> rounded_avg(n: 20, m: 33)\n\/\/\/ .success(\"0b11010\")\nfunc rounded_avg(n: Int, m: Int) -> Result<String, Int> {\n","canonical_solution":"func rounded_avg(n: Int, m: Int) -> Result<String, Int> {\n    if n > m {\n        return .failure(-1)\n    }\n    \n    let count = m - n + 1\n    let sum = (n + m) * count \/ 2\n    let average = Double(sum) \/ Double(count)\n    let roundedAverage = Int(average.rounded())\n    let binaryString = String(roundedAverage, radix: 2)\n    \n    return .success(\"0b\" + binaryString)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rounded_avg(n: 1, m: 5) == .success(\"0b11\"))\nassert(rounded_avg(n: 7, m: 13) == .success(\"0b1010\"))\nassert(rounded_avg(n: 964, m: 977) == .success(\"0b1111001010\"))\nassert(rounded_avg(n: 996, m: 997) == .success(\"0b1111100100\"))\nassert(rounded_avg(n: 560, m: 851) == .success(\"0b1011000010\"))\nassert(rounded_avg(n: 185, m: 546) == .success(\"0b101101110\"))\nassert(rounded_avg(n: 362, m: 496) == .success(\"0b110101101\"))\nassert(rounded_avg(n: 350, m: 902) == .success(\"0b1001110010\"))\nassert(rounded_avg(n: 197, m: 233) == .success(\"0b11010111\"))\nassert(rounded_avg(n: 7, m: 5) == .failure(-1))\nassert(rounded_avg(n: 5, m: 1) == .failure(-1))\nassert(rounded_avg(n: 5, m: 5) == .success(\"0b101\"))"},{"task_id":"HumanEval_104","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⴰⵖⴰⵔⴰⵙ: ⵉⵇⵇⴰⵏ ⴰⴷ ⵏⵙⵎⵓⵏ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵉⵜⵜⵓⵢⴰⴽⴽⴰⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵔⵏⵉⵡ. \/\/ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵓⵟⵟⵓⵏ ⴰⵡⴷ ⵢⴰⵏ. \/\/ ⵏⵜⵜⴰⴼ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵥⴰⵢⵏ x. ⵏⵙⵙⴽⵛⵎ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵏ ⴽⵓⵍⵍⵓ \/\/\/ >>> unique_digits(x: [15, 33, 1422, 1])\n\/\/\/ [1, 15, 33]\n\/\/\/ >>> unique_digits(x: [152, 323, 1422, 10])\n\/\/\/ [] as [Int]\nfunc unique_digits(x: [Int]) -> [Int] {\n","canonical_solution":"func unique_digits(x: [Int]) -> [Int] {\n    return x.filter { number in\n        var hasEvenDigit = false\n        var num = number\n        while num > 0 {\n            if (num % 10) % 2 == 0 {\n                hasEvenDigit = true\n                break\n            }\n            num \/= 10\n        }\n        return !hasEvenDigit\n    }.sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique_digits(x: [15, 33, 1422, 1]) == [1, 15, 33])\nassert(unique_digits(x: [152, 323, 1422, 10]) == [] as [Int])\nassert(unique_digits(x: [12345, 2033, 111, 151]) == [111, 151])\nassert(unique_digits(x: [135, 103, 31]) == [31, 135])"},{"task_id":"HumanEval_105","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ \" ⵢⴰⵏ \", \" ⵙⵉⵏ \", \" ⴽⵕⴰⴹ \", \" ⴽⴽⵓⵥ \", \" ⵙⵎⵎⵓⵙ \", \" ⵙⴹⵉⵙ \", \" ⵙⴰ \", \" ⵜⴰⵎ \", \" ⵜⵥⴰ \". \/\/ ⴰⴷ ⵏⵙⵙⵏⴼⵍ ⴰⵙⵏⴼⴰⵔ ⵏ ⵓⵙⵏⴼⴰⵔ, ⴷ ⴰⴷ ⵏⵙⵎⵔⵙ ⴽⵓ ⵓⵟⵟⵓⵏ ⵙ ⵉⵙⵎ ⵏⵏⵙ ⵙⴳ \/\/ ⴰⵖⴼ ⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴷⵙ ⵉⵎⴹⴰⵏⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵍⵍⴰⵏ ⴳⵔ 1 ⴷ 9 ⴳ ⵜⴰⵎⵎ ⵏⵙⵏ, \/\/\/ >>> by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3])\n\/\/\/ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\/\/\/ If the array is empty, return an empty array:\n\/\/\/ >>> by_length(arr: [] as [Int])\n\/\/\/ [] as [String]\n\/\/\/ If the array has any strange number ignore it:\n\/\/\/ >>> by_length(arr: [1, -1, 55])\n\/\/\/ [\"One\"]\nfunc by_length(arr: [Int]) -> [String] {\n","canonical_solution":"func by_length(arr: [Int]) -> [String] {\n    let numberNames: [Int: String] = [\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    ]\n    \n    let filteredSortedReversedNumbers = arr.filter { (1...9).contains($0) }\n                                           .sorted(by: >)\n    \n    let result = filteredSortedReversedNumbers.map { numberNames[$0] ?? \"\" }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\nassert(by_length(arr: [] as [Int]) == [] as [String])\nassert(by_length(arr: [1, -1, 55]) == [\"One\"])\nassert(by_length(arr: [1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\nassert(by_length(arr: [9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])"},{"task_id":"HumanEval_106","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⵉⴳⴰ ⵓⴼⴰⴽⵜⵓⵔⵢⴰⵍ ⵏ i ⴰⵙⴼⵓⴽⵍⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ 1 ⴰⵔ i (1 * 2 * ... * i). \/\/ ⵔⴰⴷ ⵙⵏⵜⵉⵖ ⵙⴳ 1. \/\/ ⵏⵖ ⴷ ⵓⴳⵎⵎⴰⵢ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵙⴳ 1 ⴰⵔ i ⵎⴽ ⵓⵔ ⵢⴰⴷ ⵉⴳⵉ. \/\/ ⴰⵔ ⵉⵜⵜⴰⴷⴼ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ n, ⵣⵓⵏⴷ ⴰⵜⵉⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵙⵏⵎⵍ i ⵉⴳⴰ ⵜ ⵓⴼⴰⵔⵙ ⵏ i ⵎⴽ ⵉⴳⴰ i ⴰⵎⵎ \/\/ ⵙⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ f ⵏⵏⴰ ⵢⵓⵎⵥⵏ n ⴰⵎⵎ ⵓⵎⵙⴽⴰⵔ, \/\/\/ >>> f(n: 5)\n\/\/\/ [1, 2, 6, 24, 15]\nfunc f(n: Int) -> [Int] {\n","canonical_solution":"func f(n: Int) -> [Int] {\n    func factorial(_ x: Int) -> Int {\n        guard x > 1 else { return 1 }\n        return (1...x).reduce(1, *)\n    }\n    \n    func sumTo(_ x: Int) -> Int {\n        return (1...x).reduce(0, +)\n    }\n    \n    var result = [Int]()\n    for i in 1...n {\n        if i % 2 == 0 {\n            result.append(factorial(i))\n        } else {\n            result.append(sumTo(i))\n        }\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 5) == [1, 2, 6, 24, 15])\nassert(f(n: 7) == [1, 2, 6, 24, 15, 720, 28])\nassert(f(n: 1) == [1])\nassert(f(n: 3) == [1, 2, 6])"},{"task_id":"HumanEval_107","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ 1: \/\/ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵣⴳⵓⵏⵏ ⵏⵏⴰ ⵉⴽⵛⵎⵏ ⴳ ⵓⵙⵏⴼⵍ ((1, n), ⵙⵍⴰⵡⴰⵏ ⴰⴽⴽⵡ. \/\/ ⵏⵜⵜⴰⴼ ⵢⴰⵏ ⵉⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵏⵙⵙⴽⵜⵉ ⵢⴰⵏ ⵓⵙⴽⴽⵉⵍ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵟⵟⵓⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵎⵔⵉⵏ ⴷ ⵉⵎⵣⴰⵔⴰⵢⵏ \/\/\/ >>> even_odd_palindrome(n: 3)\n\/\/\/ (1, 2)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/\/ Example 2:\n\/\/\/ >>> even_odd_palindrome(n: 12)\n\/\/\/ (4, 6)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/\/ Note:\n\/\/\/ 1. 1 <= n <= 10^3\n\/\/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n: Int) -> (Int, Int) {\n","canonical_solution":"func even_odd_palindrome(n: Int) -> (Int, Int) {\n    func isPalindrome(_ num: Int) -> Bool {\n        let str = String(num)\n        return str == String(str.reversed())\n    }\n    \n    var evenCount = 0\n    var oddCount = 0\n    \n    for i in 1...n {\n        if isPalindrome(i) {\n            if i % 2 == 0 {\n                evenCount += 1\n            } else {\n                oddCount += 1\n            }\n        }\n    }\n    \n    return (evenCount, oddCount)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_odd_palindrome(n: 123) == (8, 13))\nassert(even_odd_palindrome(n: 12) == (4, 6))\nassert(even_odd_palindrome(n: 3) == (1, 2))\nassert(even_odd_palindrome(n: 63) == (6, 8))\nassert(even_odd_palindrome(n: 25) == (5, 6))\nassert(even_odd_palindrome(n: 19) == (4, 6))\nassert(even_odd_palindrome(n: 9) == (4, 5))\nassert(even_odd_palindrome(n: 1) == (0, 1))"},{"task_id":"HumanEval_108","nl":"tzm_Tfng","pl":"swift","prompt":"\n-123 ⵖⵓⵔⵙ ⵉⵎⵉⴹⵏ -1, 2 ⴷ 3.\/\/ ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⵎⴳⵓⵔⴰⵏ ⴰⵎⴳⵓⵔⴰⵏ, ⵔⴰⴷ ⵉⴳ ⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵏⵏⵙ ⴰⵎⴳⵓⵔⴰⵏ ⴰⵎⴳⵓⵔⴰⵏ: \/\/ ⴰⵎⴹⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ > 0. \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ count_nums ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴰ \/\/\/ >>> count_nums(arr: [] as [Int])\n\/\/\/ 0\n\/\/\/ >>> count_nums(arr: [-1, 11, -11])\n\/\/\/ 1\n\/\/\/ >>> count_nums(arr: [1, 1, 2])\n\/\/\/ 3\nfunc count_nums(arr: [Int]) -> Int {\n","canonical_solution":"func count_nums(arr: [Int]) -> Int {\n    return arr.filter { number in\n        var n = number\n        var sumOfDigits = 0\n\n        while n != 0 {\n            sumOfDigits += n % 10\n            n \/= 10\n        }\n\n        return sumOfDigits > 0\n    }.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_nums(arr: [] as [Int]) == 0)\nassert(count_nums(arr: [-1, -2, 0]) == 0)\nassert(count_nums(arr: [1, 1, 2, -2, 3, 4, 5]) == 6)\nassert(count_nums(arr: [1, 6, 9, -6, 0, 1, 5]) == 5)\nassert(count_nums(arr: [1, 100, 98, -7, 1, -1]) == 4)\nassert(count_nums(arr: [12, 23, 34, -45, -56, 0]) == 5)\nassert(count_nums(arr: [0, 1]) == 1)\nassert(count_nums(arr: [1]) == 1)"},{"task_id":"HumanEval_109","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⴰⵖⴰⵔⴰⵙ: ⴰⵙⵔⵔⵓⵙ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⵜⵜⵓⵢⴰⵙⵙⴰⵏ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⵉⵡⵏ. \/\/ ⵎⴽ ⵜⴳⴰ ⵜⵔⴰⴱⴱⵓⵜ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵜⵓⵏⵏⵓⵏⵜ, ⵔⴰⴷ ⵏⵔⴰⵔ true. \/\/ ⴰⴷ ⵏⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽⵍⵍⵉ ⵏⵔⴰⵔ ⵜⵉⴼⵍⵡⵉⵜ. \/\/ ⵎⴽ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⴰⵡⵉ ⵜⵔⴰⴱⴱⵓⵜ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵜⵎⵙⴽⵔⵜ ⵏ ⵓⴼⵍⵍⴰ \/\/ ⴰⴷⵖⴰⵔ ⵏ ⵓⵣⵡⵓ ⴳ ⵓⵎⵙⴳⵔⴰⵡ, ⵉⴳⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵡⵉⵙⵙ 0.ⵔⴰⴷ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⵓ ⵓⵏⴰⵡ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵓⵙⵏⵙⵉ ⵙ \/\/ ⵢⴰⵏ ⵓⵙⵙⵉⴼ ⵏ ⵓⵣⵔⴼ ⴰⵎⵎⴰⵍ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵙⵏⵙⵉ ⵙ ⵢⴰⵏ \/\/ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⴽⵔⴷ ⵜⵉⴳⴳⵉⵜ ⵏ ⵓⵙⵏⴼⵍ ⵙ ⵓⵣⵔⴼ ⴽⵉⴳⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ. \/\/ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵅⴼ ⵓⵎⵙⴳⵔⴰⵡ ⴰⴷ: \/\/ ⵉⵖⵉⵢ ⴰⴷ ⵢⴰⵎⵥ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵙ ⵓⵙⵙⵓⴷⵙ ⵓⵔ ⴷ ⵢⴰⴳⴳⵓⴳⵏ ⵙ ⵓⵙⴽⴰⵔ ⵏ \/\/ ⵔⴰⴷ ⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ ⵡⵓⵟⵟⵓⵏ ⴳ ⵓⵙⵏⵙⵉ ⵙ ⵜⴱⵔⵉⴷⵜ ⵏ ⵓⵙⴽⵙⵍ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⵎ ⵎⴰ ⵔⴰⴷ \/\/ ⴷⴰⵔⵉⵖ ⴰⵙⵔⵔⵓⵙ 'ⴰⵔⵔ' ⵏ N ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ arr[1], arr[2], ..., arr[N].\/\/\/ >>> move_one_ball(arr: [3, 4, 5, 1, 2])\n\/\/\/ true\n\/\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/\/ be achieved for the given array.\n\/\/\/ >>> move_one_ball(arr: [3, 5, 4, 1, 2])\n\/\/\/ false\n\/\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/\/ array by performing any number of right shift operations.\nfunc move_one_ball(arr: [Int]) -> Bool {\n","canonical_solution":"func move_one_ball(arr: [Int]) -> Bool {\n    guard !arr.isEmpty else { return true }\n    \n    let n = arr.count\n    var breakPointCount = 0\n    \n    \/\/ Find the number of break points where the array is decreasing\n    for i in 0..<n {\n        if arr[i] > arr[(i + 1) % n] {\n            breakPointCount += 1\n        }\n    }\n    \n    \/\/ If there's at most one break point, the array can be right shifted\n    return breakPointCount <= 1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(move_one_ball(arr: [3, 4, 5, 1, 2]) == true)\nassert(move_one_ball(arr: [3, 5, 10, 1, 2]) == true)\nassert(move_one_ball(arr: [4, 3, 1, 2]) == false)\nassert(move_one_ball(arr: [3, 5, 4, 1, 2]) == false)\nassert(move_one_ball(arr: [] as [Int]) == true)"},{"task_id":"HumanEval_110","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⵎⴽ ⵓⵔ ⵜⵍⵍⵉ, ⵙⵓⵍ \"ⵓⵀⵓ\". \/\/ ⴰⴷ ⴳⵉⵏ ⴰⴽⴽⵡ ⵉⴼⵔⴷⵉⵙⵏ ⵏ lst1 ⵉⵎⵎⵔⵡⴰⵙⵏ, ⵔⵔⵓⵜⵓⵔ \"YES\". \/\/ ⵎⴽ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵏⴼⵍⴷ ⵉⴼⵔⴷⵉⵙⵏ ⴳⵔ lst1 ⴷ lst2 ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⴽⵔⴷ \/\/ ⵓⵔ ⵉⵍⵍⵉ ⵓⵜⵜⵓ ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴳⵔ lst1 ⴷ lst2. \/\/ ⴳⵔⵙⵏ ⵃⵎⴰ ⴰⴷ ⵏⵙⴽⵔ lst1 ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ. \/\/ ⴰⵔ ⵉⵜⵜⵉⵔⵉ ⴰⴷ ⵉⵙⴽⵔ ⵓⵙⵏⴼⵍ ⵏ ⵉⴼⵔⴷⵉⵙⵏ \/\/ ⴳ ⵜⵎⵙⴰⵔⵜ ⴰⴷ, ⵔⴰⴷ ⵜⵙⵙⴽⵔⵎ ⵢⴰⵜ ⵜⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵙⵏⴰⵜ ⵏ ⵜⵔⴱⴰⵜⵉⵏ ⵏ ⵉⵎⴹⴰⵏⵏ, \/\/\/ >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4])\n\/\/\/ \"YES\"\n\/\/\/ >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4])\n\/\/\/ \"NO\"\n\/\/\/ It is assumed that the input arrays will be non-empty.\nfunc exchange(lst1: [Int], lst2: [Int]) -> String {\n","canonical_solution":"func exchange(lst1: [Int], lst2: [Int]) -> String {\n    var hasOddInLst1 = false\n    var hasEvenInLst2 = false\n    \n    for num in lst1 {\n        if num % 2 != 0 {\n            hasOddInLst1 = true\n            break\n        }\n    }\n    \n    for num in lst2 {\n        if num % 2 == 0 {\n            hasEvenInLst2 = true\n            break\n        }\n    }\n    \n    if !hasOddInLst1 {\n        return \"YES\"\n    }\n    \n    if hasEvenInLst2 {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4]) == \"YES\")\nassert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4]) == \"NO\")\nassert(exchange(lst1: [1, 2, 3, 4], lst2: [2, 1, 4, 3]) == \"YES\")\nassert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 4]) == \"YES\")\nassert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 3]) == \"NO\")\nassert(exchange(lst1: [3, 2, 6, 1, 8, 9], lst2: [3, 5, 5, 1, 1, 1]) == \"NO\")\nassert(exchange(lst1: [100, 200], lst2: [200, 200]) == \"YES\")"},{"task_id":"HumanEval_111","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⵎⴽ ⴷⴰⵔ ⴽⵉⴳⴰⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵢⴰⵏ ⵡⴰⴷⴷⴰⴷ, ⵙⵙⵓⴼⵖ-ⵜ ⴽⵓⵍⵍⵓ. \/\/ ⵏ ⵜⴱⵔⴰⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵓⴳⴳⴰⵔ ⵏ ⵓⵙⴽⴽⵉⵍ ⴷ ⵍⵍⴰⵏ ⴳⵉⵙ ⵉⵎⴹⴰⵏⵏ ⵏ ⵜⴱⵔⴰⵜⵉⵏ. \/\/ ⴰⵖⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ ⵜⵉⵔⵔⴰ ⵜⵉⵎⵥⵢⴰⵏⵉⵏ ⵉⵜⵜⵓⵢⴼⴼⴰⵔⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ, ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵙⴳⵓⵔⵉ \/\/\/ >>> histogram(test: \"a b c\")\n\/\/\/ [\"a\" : 1, \"b\" : 1, \"c\" : 1]\n\/\/\/ >>> histogram(test: \"a b b a\")\n\/\/\/ [\"a\" : 2, \"b\" : 2]\n\/\/\/ >>> histogram(test: \"a b c a b\")\n\/\/\/ [\"a\" : 2, \"b\" : 2]\n\/\/\/ >>> histogram(test: \"b b b b a\")\n\/\/\/ [\"b\" : 4]\n\/\/\/ >>> histogram(test: \"\")\n\/\/\/ [:] as [String : Int]\nfunc histogram(test: String) -> [String : Int] {\n","canonical_solution":"func histogram(test: String) -> [String : Int] {\n    var letterCount: [String: Int] = [:]\n\n    \/\/ Split the string into an array of letters\n    let letters = test.split(separator: \" \").map { String($0) }\n\n    \/\/ Count occurrences of each letter\n    for letter in letters {\n        letterCount[letter, default: 0] += 1\n    }\n\n    \/\/ Determine the maximum number of occurrences\n    guard let maxCount = letterCount.values.max() else {\n        return [:] as [String : Int]\n    }\n\n    \/\/ Filter the letterCount dictionary to only include letters with the max count\n    let result = letterCount.filter { $0.value == maxCount }\n\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"},{"task_id":"HumanEval_112","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ \/\/ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵔⵉⵜ ⵢⴰⵏ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵓⵏⵖⵉⵍⵜ ⵉⵍⵍⴰⵏ ⴳⵉⵙ ⵜⴰⵡⵉⵍⴰ ⵏ ⵜⵢⴰⴼⵓⵜ ⴷ true\/false ⵉ ⵓⵣⵣⵔⴰⵢ. \/\/ ⴷⴰ ⵜⵜⵉⵏⵉⵏ ⵉⵊⵊ ⵏ ⵓⵖⵉⵍⵓⴼ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ ⵎⴽ ⴷⴰ ⵜⴻⵜⵜⵢⴰⵔⴰ ⵙ ⵓⵎⵏⵉⴷ ⴰⵎⵎ ⵓⵎⵏⵉⴷ. \/\/ ⴹⴰⵕⵜ ⵓⵢⴰ, ⵥⵕⵖ ⵉⵙ ⵜⴳⴰ ⵜⵢⴰⴼⵓⵜ ⵏ ⵓⵡⵉⴽⵉ ⴰⵏⵎⴳⴰⵍ. \/\/ ⵏⵜⵜⴰⴽⴽⴰ ⵙⵉⵏ ⵉⵙⴽⴽⵉⵍⵏ s ⴷ c, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵏⵙⵙⴽⵛⵎ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ s ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ ⴷ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ c \/\/ ⵜⴰⵡⵓⵔⵉ \/\/\/ >>> reverse_delete(s: \"abcde\", c: \"ae\")\n\/\/\/ (\"bcd\", false)\n\/\/\/ >>> reverse_delete(s: \"abcdef\", c: \"b\")\n\/\/\/ (\"acdef\", false)\n\/\/\/ >>> reverse_delete(s: \"abcdedcba\", c: \"ab\")\n\/\/\/ (\"cdedc\", true)\nfunc reverse_delete(s: String, c: String) -> (String, Bool) {\n","canonical_solution":"func reverse_delete(s: String, c: String) -> (String, Bool) {\n    \/\/ Remove characters from s that are in c\n    let filteredString = s.filter { !c.contains($0) }\n    \n    \/\/ Check if the resulting string is a palindrome\n    let isPalindrome = filteredString == String(filteredString.reversed())\n    \n    \/\/ Return the resulting string and the palindrome check result\n    return (filteredString, isPalindrome)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(reverse_delete(s: \"abcde\", c: \"ae\") == (\"bcd\", false))\nassert(reverse_delete(s: \"abcdef\", c: \"b\") == (\"acdef\", false))\nassert(reverse_delete(s: \"abcdedcba\", c: \"ab\") == (\"cdedc\", true))\nassert(reverse_delete(s: \"dwik\", c: \"w\") == (\"dik\", false))\nassert(reverse_delete(s: \"a\", c: \"a\") == (\"\", true))\nassert(reverse_delete(s: \"abcdedcba\", c: \"\") == (\"abcdedcba\", true))\nassert(reverse_delete(s: \"abcdedcba\", c: \"v\") == (\"abcdedcba\", true))\nassert(reverse_delete(s: \"vabba\", c: \"v\") == (\"abba\", true))\nassert(reverse_delete(s: \"mamma\", c: \"mia\") == (\"\", true))"},{"task_id":"HumanEval_113","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵜⵔⴳⴰⵍⵜ ⵜⵉⵙⵙ i ⵏ ⵓⵙⴽⵛⵎ. \/\/ ⵜⵉⴼⵉⵏⴰⵖ i ⵏ ⵓⵙⴽⵛⵎ. \" ⴳⴰⵏ ⴰⴽⴽⵡ i's ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⵙ ⵓⵟⵟⵓⵏ \/\/ ⴽⵓ ⵉⴼⵔⴷⵉⵙ i ⵏ ⵜⵏⴰⴼⵓⵜ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ \"ⵉⴹ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ \/\/ ⴰⵛⴽⵓ ⵏⵙⴽⵔ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵙⴽⴽⵉⵍⵏ, ⴳ ⴽⵓ ⴰⵙⵏⵙⵍ ⵉⵍⵍⴰ ⴳⵉⵙ ⵓⵟⵟⵓⵏⵏ, ⵏⵙⵙⴽⵔ ⴰⵙⵏⵙⵍ. \/\/\/ >>> odd_count(lst: [\"1234567\"])\n\/\/\/ [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\/\/\/ >>> odd_count(lst: [\"3\", \"11111111\"])\n\/\/\/ [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nfunc odd_count(lst: [String]) -> [String] {\n","canonical_solution":"func odd_count(lst: [String]) -> [String] {\n    return lst.map { str in\n        let oddCount = str.filter { \"13579\".contains($0) }.count\n        return \"the number of odd elements \\(oddCount)n the str\\(oddCount)ng \\(oddCount) of the \\(oddCount)nput.\"\n    }\n}\n\n\/\/ Example Usage\nprint(odd_count(lst: [\"1234567\"]))\nprint(odd_count(lst: [\"3\", \"11111111\"]))","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(odd_count(lst: [\"1234567\"]) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])\nassert(odd_count(lst: [\"3\", \"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"])\nassert(odd_count(lst: [\"271\", \"137\", \"314\"]) == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"])"},{"task_id":"HumanEval_114","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ \/\/ ⵏ ⵉⵎⴹⴰⵏⵏ. \/\/ ⴰⵖⴼ ⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵉⴼⵍ ⴰⵎⴹⴰⵏ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⴽⵔⴰ ⵏ ⵡⴰⵎⵎⴰⵙⵏ ⵏ ⵓⵙⵏⵙⵉ \/\/\/ >>> minSubArraySum(nums: [2, 3, 4, 1, 2, 4])\n\/\/\/ 1\n\/\/\/ >>> minSubArraySum(nums: [-1, -2, -3])\n\/\/\/ -6\nfunc minSubArraySum(nums: [Int]) -> Int {\n","canonical_solution":"func minSubArraySum(nums: [Int]) -> Int {\n    guard !nums.isEmpty else { return 0 }\n    \n    var currentMin = nums[0]\n    var overallMin = nums[0]\n    \n    for i in 1..<nums.count {\n        currentMin = min(nums[i], currentMin + nums[i])\n        overallMin = min(overallMin, currentMin)\n    }\n    \n    return overallMin\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minSubArraySum(nums: [2, 3, 4, 1, 2, 4]) == 1)\nassert(minSubArraySum(nums: [-1, -2, -3]) == -6)\nassert(minSubArraySum(nums: [-1, -2, -3, 2, -10]) == -14)\nassert(minSubArraySum(nums: [-9999999999999999]) == -9999999999999999)\nassert(minSubArraySum(nums: [0, 10, 20, 1000000]) == 0)\nassert(minSubArraySum(nums: [-1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [100, -1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [10, 11, 13, 8, 3, 4]) == 3)\nassert(minSubArraySum(nums: [100, -33, 32, -1, 0, -2]) == -33)\nassert(minSubArraySum(nums: [-10]) == -10)\nassert(minSubArraySum(nums: [7]) == 7)\nassert(minSubArraySum(nums: [1, -1]) == -1)"},{"task_id":"HumanEval_115","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ 1: \/\/ ⵙⵙⵓⴼⵖ ⴰⵎⴹⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵜⵔⴰⵎ ⴰⴷ ⵜⵙⵙⴷⵉⴷⴷ ⵜⵉⵙⵉ ⵏ ⵉⵙⴼⴽⴰ. \/\/ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵎⵔⵙⴷ ⵉⴽⵛⵛⵓⵎⵏ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵏⴼⵍⴷ ⵜⵉⵖⵔⵎⵉⵏ. \/\/ ⴷ ⴽⵓⵍⵍⵓ ⵉⴽⵛⵛⵓⵎⵏ ⵖⵓⵔⵙⵏ ⵜⴰⵣⵎⵔⵜ ⵢⴰⵜⵜⵓⵢⵏ. \/\/ ⴽⵓ ⵜⵓⵏⵙ ⵖⵓⵔⵙ ⵢⴰⵏ ⵍⴱⵉⴽⴰⵜ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⵏⵏⴰ ⵉⵖⵢ ⴰⴷ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⴳ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵡⴰⵎⴰⵏ ⵙⴳ ⵜⵓⵏⵙ, \/\/ ⴷ ⴽⵓ 1 ⴳ ⵢⴰⵏ ⵓⵡⵔⵉⴽ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵜ ⵜⴰⵢⵎⵓⵏⵜ ⵏ ⵡⴰⵎⴰⵏ. \/\/ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ ⵏ ⵜⵔⴳⴰ ⵜⴰⵣⴳⴰⵍⵜ. ⴽⵓ ⵜⴰⵡⵔⵉⵔⵜ ⴷⴰ ⵜⵙⵎⴷⵢ ⵢⴰⵏ ⵓⴽⵛⵛⵓⵎ, \/\/\/ >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\n\/\/\/ 6\n\/\/\/ Example 2:\n\/\/\/ >>> max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n\/\/\/ 5\n\/\/\/ Example 3:\n\/\/\/ >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)\n\/\/\/ 0\n\/\/\/ Constraints:\n\/\/\/ * all wells have the same length\n\/\/\/ * 1 <= grid.length <= 10^2\n\/\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/\/ * grid[i][j] -> 0 | 1\n\/\/\/ * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n","canonical_solution":"func max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var totalWater = 0\n    for row in grid {\n        for unit in row {\n            if unit == 1 {\n                totalWater += 1\n            }\n        }\n    }\n    return (totalWater + capacity - 1) \/ capacity\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"},{"task_id":"HumanEval_116","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⴽⴰⵔ ⵣⵓⵏⴷ ⴰⴷ: \/\/ ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵢⴰⴳⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ, ⵙⵙⵓⴷⵙ ⵅⴼ ⵡⴰⵜⵉⴳ ⴰⵎⵔⴰⵡ. \/\/ ⵉⵎⴹⴰⵏ ⵏ ⵉⵎⵥⵢⴰⵏⵏ ⴳ ⵓⵙⵎⴷⵢⴰ ⵏⵏⵙⵏ ⴰⵎⵉⵏⴰⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵇⵔⴰⵏ. \/\/ ⴳ ⴽⴰⵜⴰ ⴰⴷ, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵔⵉⵏ ⴹⴰⵕⵜ \/\/\/ >>> sort_array(arr: [1, 5, 2, 3, 4])\n\/\/\/ [1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(arr: [-2, -3, -4, -5, -6])\n\/\/\/ [-6, -5, -4, -3, -2]\n\/\/\/ >>> sort_array(arr: [1, 0, 2, 3, 4])\n\/\/\/ [0, 1, 2, 3, 4]\nfunc sort_array(arr: [Int]) -> [Int] {\n","canonical_solution":"func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted {\n        let onesCount1 = $0.nonNegativeOnesCount()\n        let onesCount2 = $1.nonNegativeOnesCount()\n        return (onesCount1, $0) < (onesCount2, $1)\n    }\n}\n\nextension Int {\n    func nonNegativeOnesCount() -> Int {\n        return self < 0 ? 0 : self.nonBitCount()\n    }\n    \n    private func nonBitCount() -> Int {\n        var count = 0\n        var num = self\n        while num > 0 {\n            count += num & 1\n            num >>= 1\n        }\n        return count\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"},{"task_id":"HumanEval_117","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⴰⵖⴰⵔⴰⵙ: ⵉⵖⵢ ⴰⴷ ⵜⵙⵙⵏⵎⵙⴷ ⵉⵙ ⴳⴰⵏⵜ ⵜⵉⵔⵔⴰ ⴷ ⵉⵙⴰⵢⵔⴰⵔⵏ ⵖⴰⵙ ⵜⵉⴼⵉⵏⴰⵖ ⵏ ⵓⵙⴽⴽⵉⵍ. \/\/ ⵎⴽ ⵜⴳⴰ ⵜⵉⴼⵉⵏⴰⵖ s ⵜⴰⵍⵍⵉⵜ, ⵔⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵉⵍⵍⵓⵍⵏ. \/\/ n ⵉⵎⵙⵍⵉ, ⵙ ⵓⵍⵖⵓ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴷ ⴳ ⵜⵣⴳⵉⵍⵜ s. \/\/ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴽⴽⵡ ⵙⴳ ⵜⵉⴼⵉⵏⴰⵖ s ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ \/\/ ⵙ ⵓⵙⴽⴽⵉⵍ s ⴷ ⵓⵟⵟⵓⵏ ⴰⴳⴰⵎⴰⵏ n, ⵔⴰⴷ ⵜⵙⵙⴽⵔⴷ \/\/\/ >>> select_words(s: \"Mary had a little lamb\", n: 4)\n\/\/\/ [\"little\"]\n\/\/\/ >>> select_words(s: \"Mary had a little lamb\", n: 3)\n\/\/\/ [\"Mary\", \"lamb\"]\n\/\/\/ >>> select_words(s: \"simple white space\", n: 2)\n\/\/\/ [] as [String]\n\/\/\/ >>> select_words(s: \"Hello world\", n: 4)\n\/\/\/ [\"world\"]\n\/\/\/ >>> select_words(s: \"Uncle sam\", n: 3)\n\/\/\/ [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n","canonical_solution":"func select_words(s: String, n: Int) -> [String] {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    let words = s.split(separator: \" \")\n    var result: [String] = []\n    \n    for word in words {\n        let consonantCount = word.filter { !vowels.contains($0) }.count\n        if consonantCount == n {\n            result.append(String(word))\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"},{"task_id":"HumanEval_118","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⴰⴷ ⵜⵙⵙⵏⵎ ⵉⵙ ⴷⴰⵔⵙ ⵜⵉⵔⵔⴰ ⵜⴰⵏⴳⵍⵉⵣⵜ ⵖⴰⵙ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ. \/\/ ⴰⴷ ⵏⴰⴼ ⴽⵔⴰ ⵏ ⵓⵡⵉⴽⵉⵍ ⵉⵔⵡⴰⵏ ⴷ ⵡⴰⴷⴷⴰⴷ ⵏⵏⵉⴳ ⵏ ⵓⵢⴰ. \/\/ ⵓⵔ ⴷⴰ ⵜⵜⵓⵙⵉⴹⵏ ⵉⵎⵙⵍⵉ ⴳ ⵍⴱⴷⵓ ⴷ ⵜⴳⵉⵔⴰ. ⵔⵎⵙⵏ ⵜⴰⵡⴰⵍⵜ ⵜⵓⵎⵥⵜ ⵎⴽ ⵓⵔ ⵜⵔⵎⵙⵏ \/\/ ⵙⵏⴰⵜ ⵜⵓⵏⵙⵉⵏ ⵙⴳ ⵜⵙⴳⴰ ⵏ ⵓⵣⵔⴼ ⵏ ⵜⴳⵓⵔⵉ (ⵜⴰⵙⴳⵓⵔⵉ ⵏ ⵓⴷⵖⴰⵔ).\/\/ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵜ ⵜⴳⵓⵔⵉ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴰⴼⴷ ⵓⵡⴰⵍⵉ ⴰⴽⴽⵡ ⵉⵎⵉⴽⴽ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳⵔ \/\/\/ >>> get_closest_vowel(word: \"yogurt\")\n\/\/\/ \"u\"\n\/\/\/ >>> get_closest_vowel(word: \"FULL\")\n\/\/\/ \"U\"\n\/\/\/ >>> get_closest_vowel(word: \"quick\")\n\/\/\/ \"\"\n\/\/\/ >>> get_closest_vowel(word: \"ab\")\n\/\/\/ \"\"\nfunc get_closest_vowel(word: String) -> String {\n","canonical_solution":"func get_closest_vowel(word: String) -> String {\n    let vowels = Set(\"aeiouAEIOU\")\n    var foundVowel: Character? = nil\n    \n    for i in stride(from: word.count - 2, through: 1, by: -1) {\n        let currentIndex = word.index(word.startIndex, offsetBy: i)\n        let previousIndex = word.index(word.startIndex, offsetBy: i - 1)\n        let nextIndex = word.index(word.startIndex, offsetBy: i + 1)\n        \n        if vowels.contains(word[currentIndex]) && \n            !vowels.contains(word[previousIndex]) && \n            !vowels.contains(word[nextIndex]) {\n            foundVowel = word[currentIndex]\n            break\n        }\n    }\n    \n    return foundVowel != nil ? String(foundVowel!) : \"\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"},{"task_id":"HumanEval_119","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⴰⴷ ⵏⵔⴰⵔ \"ⵉⵀ\" ⵎⴽ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴱⵔⵉⴷ ⵉ ⵓⵙⴽⴰⵔ ⵏ ⵢⴰⵏ ⵓⵖⵉⵍⵓⴼ ⵉⵖⵓⴷⴰⵏ, ⴷ ⴰⴷ ⵏⵔⴰⵔ \"ⵓⵄ\" ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ. \/\/ '())' ⵓⵔ ⵉⴳⵉ. \/\/ ⴳⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ. ⵙ ⵓⵎⴷⵢⴰ: ⵜⵉⴼⵉⵏⴰⵖ '(()))) ' ⵜⴳⴰ ⵜⵣⵔⴼⴰⵏⵜ, ⵎⴰⵛⴰ ⵜⵉⴼⵉⵏⴰⵖ \/\/ ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙ ⵜⵉⴼⵉⵏⴰⵖ S ⴰⴷ ⵜⴳ ⵜⵣⴷⵉⴳⵜ ⵎⴽ ⴷ ⴽⵓⵍⵍⵓ ⵜⵉⵙⴳⵏⵓⵜⵉⵏ ⴳ S \/\/ ⴽⵔⴰ ⵏ ⵓⵙⵓⴷⵙ, ⵎⴰⵙⴷ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⵔⴰⴷ ⵉⴳ ⵉⵖⵓⴷⴰⵏ. \/\/ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵥⵕⵎ ⵎⴽ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴽⴷⴷⴷ ⵙⵏⴰⵜ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴳ \/\/ ⵜⴰⴳⵔⵓⵎⵎⴰ \" (() \" ⵏⵖ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵓⴳⵏⵙⵓ \") \" ⵅ.\/\/ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵙⵡⴰⵜ ⵏ ⵙⵉⵏ ⵉⵙⵓⴳⴰⵎ, ⵙⵉⵏ ⵉⵙⵓⴳⴰⵎ ⴳⴰⵏ ⵉⵕⵥⵎⵏ \/\/\/ >>> match_parens(lst: [\"()(\", \")\"])\n\/\/\/ \"Yes\"\n\/\/\/ >>> match_parens(lst: [\")\", \")\"])\n\/\/\/ \"No\"\nfunc match_parens(lst: [String]) -> String {\n","canonical_solution":"func match_parens(lst: [String]) -> String {\n    let combined1 = lst[0] + lst[1]\n    let combined2 = lst[1] + lst[0]\n    \n    func isBalanced(_ s: String) -> Bool {\n        var balance = 0\n        for char in s {\n            if char == \"(\" {\n                balance += 1\n            } else if char == \")\" {\n                balance -= 1\n            }\n            if balance < 0 {\n                return false\n            }\n        }\n        return balance == 0\n    }\n    \n    if isBalanced(combined1) || isBalanced(combined2) {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")"},{"task_id":"HumanEval_120","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ 1: \/\/ ⵏ ⵜⵉⵖⵣⵉ k ⵙ ⵓⴳⴳⴰⵔ ⵏ k ⵉⵎⴹⴰⵏⵏ ⴳ arr. \/\/ ⴰⵖ ⴷ ⵢⵓⴼⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵢⴰⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ k, ⴰⴷ ⵉⵔⴰⵔ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ \/\/\/ >>> maximum(arr: [-3, -4, 5], k: 3)\n\/\/\/ [-4, -3, 5]\n\/\/\/ Example 2:\n\/\/\/ >>> maximum(arr: [4, -4, 4], k: 2)\n\/\/\/ [4, 4]\n\/\/\/ Example 3:\n\/\/\/ >>> maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\n\/\/\/ [2]\n\/\/\/ Note:\n\/\/\/ 1. The length of the array will be in the range of [1, 1000].\n\/\/\/ 2. The elements in the array will be in the range of [-1000, 1000].\n\/\/\/ 3. 0 <= k <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n","canonical_solution":"func maximum(arr: [Int], k: Int) -> [Int] {\n    guard k > 0 else { return [] }\n    let sortedArr = arr.sorted(by: >)\n    let maxElements = Array(sortedArr.prefix(k))\n    return maxElements.sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"},{"task_id":"HumanEval_121","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ \/\/ ⵏⵜⵜⴰⴼⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵅⴷⴷⴰⵎⵏ, ⵏⵙⵙⴽⵏ ⵜⴰⴳⵓⵜ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵜⵣⴷⵓⵖⵉⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ. \/\/\/ >>> solution(lst: [5, 8, 7, 1])\n\/\/\/ 12\n\/\/\/ >>> solution(lst: [3, 3, 3, 3, 3])\n\/\/\/ 9\n\/\/\/ >>> solution(lst: [30, 13, 24, 321])\n\/\/\/ 0\nfunc solution(lst: [Int]) -> Int {\n","canonical_solution":"func solution(lst: [Int]) -> Int {\n    var sum = 0\n    for (index, value) in lst.enumerated() {\n        if index % 2 == 0 && value % 2 != 0 {\n            sum += value\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solution(lst: [5, 8, 7, 1]) == 12)\nassert(solution(lst: [3, 3, 3, 3, 3]) == 9)\nassert(solution(lst: [30, 13, 24, 321]) == 0)\nassert(solution(lst: [5, 9]) == 5)\nassert(solution(lst: [2, 4, 8]) == 0)\nassert(solution(lst: [30, 13, 23, 32]) == 23)\nassert(solution(lst: [3, 13, 2, 9]) == 3)"},{"task_id":"HumanEval_122","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵙ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ ⵉⴼⵔⴷⵉⵙⵏ ⵏ k ⵏ arr. \/\/ ⴰⵖ ⴷ ⵢⵉⵡⵙ ⵓⵙⵔⵔⵓⵙ ⵓⵔ ⵉⴳⵉⵏ ⵡⴰⴽⴰⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ arr ⴷ ⵢⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ k, return \/\/\/ >>> add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4)\n\/\/\/ 24\n\/\/\/ Constraints:\n\/\/\/ 1. 1 <= len(arr) <= 100\n\/\/\/ 2. 1 <= k <= len(arr)\nfunc add_elements(arr: [Int], k: Int) -> Int {\n","canonical_solution":"func add_elements(arr: [Int], k: Int) -> Int {\n    var sum = 0\n    for i in 0..<k {\n        if arr[i] >= -99 && arr[i] <= 99 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add_elements(arr: [1, -2, -3, 41, 57, 76, 87, 88, 99], k: 3) == -4)\nassert(add_elements(arr: [111, 121, 3, 4000, 5, 6], k: 2) == 0)\nassert(add_elements(arr: [11, 21, 3, 90, 5, 6, 7, 8, 9], k: 4) == 125)\nassert(add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4) == 24)\nassert(add_elements(arr: [1], k: 1) == 1)"},{"task_id":"HumanEval_123","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ get_odd_collatz(5) ⴰⵔ ⵉⵜⵜⵔⴰⵔ [1, 5] # ⵜⴰⵔⵔⴰ ⵏ ⴽⵓⵍⵍⴰⵜⵣ ⵉ 5 ⵜⴳⴰ [5, 16, 8, 4, 2, 1], ⴰⵢⴰⴷ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ ⴳⴰⵏ 1, ⴷ 5. \/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ 2. ⵉⵙⵡⵓⵜⵜⵓ ⵓⵙⵎⵉⵍ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵔⵏⵉⵡ. \/\/ 1. ⴽⵓⵍⵍⴰⵣ ((1) ⵉⴳⴰ [1]. \/\/ ⴰⵖⴰⵔⴰⵙ: \/\/ ⴰⴳⴳⵓⴳ + 1. ⵜⴰⵡⵏⴳⵉⵎⵜ ⵜⴳⴰ ⵜⵜ ⵎⴰⵙ ⵓⵔ ⵜⵅⵙ ⴰⵜⵉⴳ ⵏ n, ⵔⴰⴷ ⵜⵍⴽⵎ ⵜⵉⴼⵔⴽⵜ ⴰⵀⴰ 1. \/\/ ⵓⴽⵓⴷ ⵉⵣⵔⵉⵏ. ⵎⴽ ⵉⴳⴰ ⵓⴽⵓⴷ ⵉⵣⵔⵉⵏ ⴰⵎⵣⴳⵓⵏ, ⵓⴽⵓⴷ ⴰⴹⴼⴰⵕ ⵉⴳⴰ 3 ⵏ ⵓⴽⵓⴷ ⵉⵣⵔⵉⵏ \/\/ ⴰⵖⵔⵓⵎ ⵉⵣⵔⵉⵏ ⴰⵎⵎ ⵡⴰⴷ: ⵎⴽ ⵉⴳⴰ ⵓⵖⵔⵓⵎ ⵉⵣⵔⵉⵏ ⴰⵎⵎ, ⵉⴳⴰ ⵓⵖⵔⵓⵎ ⴰⴹⴼⴰⵕ ⵢⴰⵏ ⵓⵣⴳⵏ ⵏ \/\/ ⵙ ⵡⴰⵏⴰⵡ ⴰⴷ: ⵙⵙⵏⵜⵉ ⵙ ⴽⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ n. ⴹⴰⵕⵜ ⵓⵢⴰ, ⴷⴰ ⵜⵜⵓⵢⴰⵡⵙⴽⴰⵔ ⴽⵓ ⵜⴰⵙⵓⵔⵉⴼⵜ ⵙⴳ \/\/ ⵜⴰⵖⵏⵙⴰ ⵏ ⴽⵓⵍⵍⴰⵣ ⵜⴳⴰ ⵢⴰⵜ ⵜⵖⵏⵙⴰ ⴳ ⵜⵓⵙⵏⴰⴽⵜ ⵏⵏⴰ ⵉⵥⵍⵉⵏ ⵙ ⵢⴰⵜ ⵜⵣⵍⵉⵜ ⵉⵜⵜⵓⵙⵙⴰⵏⵏ \/\/ ⵏⵜⵜⴰⴼ ⵢⴰⵏ ⵉⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵏⵙⵙⴽⵏ ⵢⴰⵜ ⵜⵎⵙⴷⴰⵍⵜ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ ⴳ ⵓⵙⵓⵔⵙ ⵏ ⴽⵓⵍⴰⵜⵣ. \/\/\/ >>> get_odd_collatz(n: 5)\n\/\/\/ [1, 5]\nfunc get_odd_collatz(n: Int) -> [Int] {\n","canonical_solution":"func get_odd_collatz(n: Int) -> [Int] {\n    var collatzSequence: [Int] = []\n    var number = n\n\n    while number != 1 {\n        if number % 2 != 0 {\n            collatzSequence.append(number)\n        }\n        if number % 2 == 0 {\n            number \/= 2\n        } else {\n            number = 3 * number + 1\n        }\n    }\n\n    collatzSequence.append(1) \/\/ append 1 as the sequence ends at 1\n\n    let sortedOdds = collatzSequence.sorted()\n    \n    return sortedOdds\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"},{"task_id":"HumanEval_124","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ 4. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵢⵉⵍⵉ ⵓⵙⵙⴰⵏ ⴳ ⵜⵍⵖⴰ: ⵎⵎ-ⴷⵉ-ⵢⵢⴰⵢⵢⴰ ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵉⴳ ⵡⴰⵢⵢⵓⵔ ⴷⴷⵔⵓⵙ ⵙⴳ 1 ⵏⵖ ⵓⴳⴳⴰⵔ ⵙⴳ 12.ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⵓⵔ ⴷⵔⵓⵙⵏ ⵙⴳ 1 ⵏⵖ ⵓⴳⴳⴰⵔ ⵏ 31 ⵏ ⵡⵓⵙⵙⴰⵏ ⵉ ⵡⴰⵢⵢⵓⵔ 1,3,5,7,8,10,12. ⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⵓⵔ ⴷⵔⵓⵙⵏ ⵙⴳ 1 ⵏⵖ ⵓⴳⴳⴰⵔ ⵏ 30 ⵏ ⵡⵓⵙⵙⴰⵏ ⵉ ⵡⴰⵢⵢⵓⵔ 4,6,9,11. ⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⵓⵔ ⴷⵔⵓⵙⵏ ⵙⴳ 1 ⵏⵖ ⵓⴳⴳⴰⵔ ⵏ 29 ⵉ ⵡⴰⵢⵢⵓⵔ 2.\/\/ 1. ⵓⵔ ⵜⵍⵍⵉ ⵜⵣⴳⵉⵍⵜ ⵏ ⵡⴰⵙⵙ ⵅⴷⴷⴰ. \/\/ ⵉⴳⴰ ⵡⴰⵙⵙ ⴰⴷ ⴰⵣⵔⴼⴰⵏ ⵎⴽⵍⵍⵉ ⵜⵜⵓⵙⵎⵔⵏ ⴽⵓⵍⵍⵓ ⵉⵍⵓⴳⵏⵏ ⴰⴷ: \/\/ ⴰⵔ ⵉⵜⵜⵔ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⴰⵙⵙ ⵢⴰⵜ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵜⵉⴷⵜ. \/\/ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵔⵉⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵙⵎⴷⵏ ⵜⴰⵡⵓⵔⵉ ⵏ ⵓⵣⵎⵣ ⴷ \/\/\/ >>> valid_date(date: \"03-11-2000\")\n\/\/\/ true\n\/\/\/ >>> valid_date(date: \"15-01-2012\")\n\/\/\/ false\n\/\/\/ >>> valid_date(date: \"04-0-2040\")\n\/\/\/ false\n\/\/\/ >>> valid_date(date: \"06-04-2020\")\n\/\/\/ true\n\/\/\/ >>> valid_date(date: \"06\/04\/2020\")\n\/\/\/ false\nfunc valid_date(date: String) -> Bool {\n","canonical_solution":"func valid_date(date: String) -> Bool {\n    \/\/ Check if the date is empty\n    if date.isEmpty {\n        return false\n    }\n    \n    \/\/ Split the date into components using the \"-\" delimiter\n    let components = date.split(separator: \"-\")\n    \n    \/\/ Ensure the date has exactly three components\n    if components.count != 3 {\n        return false\n    }\n    \n    \/\/ Ensure the date components are integers\n    guard let month = Int(components[0]), let day = Int(components[1]), let year = Int(components[2]) else {\n        return false\n    }\n    \n    \/\/ Check if the month is within the valid range\n    if month < 1 || month > 12 {\n        return false\n    }\n    \n    \/\/ Define the number of days in each month\n    let daysInMonth = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    \/\/ Check the day range for each month\n    if day < 1 || day > daysInMonth[month] {\n        return false\n    }\n    \n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(valid_date(date: \"03-11-2000\") == true)\nassert(valid_date(date: \"15-01-2012\") == false)\nassert(valid_date(date: \"04-0-2040\") == false)\nassert(valid_date(date: \"06-04-2020\") == true)\nassert(valid_date(date: \"01-01-2007\") == true)\nassert(valid_date(date: \"03-32-2011\") == false)\nassert(valid_date(date: \"\") == false)\nassert(valid_date(date: \"04-31-3000\") == false)\nassert(valid_date(date: \"06-06-2005\") == true)\nassert(valid_date(date: \"21-31-2000\") == false)\nassert(valid_date(date: \"04-12-2003\") == true)\nassert(valid_date(date: \"04122003\") == false)\nassert(valid_date(date: \"20030412\") == false)\nassert(valid_date(date: \"2003-04\") == false)\nassert(valid_date(date: \"2003-04-12\") == false)\nassert(valid_date(date: \"04-2003\") == false)"},{"task_id":"HumanEval_125","nl":"tzm_Tfng","pl":"swift","prompt":"\nextension Int: Error {}\n        \n\/\/ ⵉⵎⴷⵢⴰⵜⵏ \/\/ ⴰⵍⴰⴼⵉⴱⵉⵜ, ord{\"a\") = 0, ord{\"b\") = 1, ... ord{\"z\") = 25 \/\/ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⴱⴹⵓ ⵅⴼ ⵜⵓⵙⴷⵉⴷⵉⵏ ',' ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵜⵓⵙⴷⵉⴷⵉⵏ ⵔⴰⴷ ⵜⵔⵉⵏⵉ ⵉⵎⴹⴰⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵎⵥⵥⵉⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵥⵥⵢⴰⵏ ⴳ \/\/ ⵙ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ, ⴰⴷ ⵏⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵜⵜⵓⵥⵍⴰⵢⵏ ⵅⴼ ⵡⴰⵏⵙⴰ ⵏ ⵡⴰⵔⵔⴰ, ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⵏⵙⴰ ⵏ ⵡⴰⵔⵔⴰ ⴳ ⵓⴹⵕⵉⵚ ⵏⵏⴰ ⵜⵔⴰⵎ \/\/\/ >>> split_words(txt: \"Hello world!\")\n\/\/\/ .success([\"Hello\", \"world!\"])\n\/\/\/ >>> split_words(txt: \"Hello,world!\")\n\/\/\/ .success([\"Hello\", \"world!\"])\n\/\/\/ >>> split_words(txt: \"abcdef\")\n\/\/\/ .failure(3)\nfunc split_words(txt: String) -> Result<[String], Int> {\n","canonical_solution":"func split_words(txt: String) -> Result<[String], Int> {\n    if txt.contains(\" \") {\n        let words = txt.split(separator: \" \").map { String($0) }\n        return .success(words)\n    } else if txt.contains(\",\") {\n        let words = txt.split(separator: \",\").map { String($0) }\n        return .success(words)\n    } else {\n        let oddOrderedLowerCaseLetters = txt.filter { char in\n            if let asciiValue = char.asciiValue {\n                let order = asciiValue - Character(\"a\").asciiValue!\n                return order % 2 == 1\n            }\n            return false\n        }\n        return .failure(oddOrderedLowerCaseLetters.count)\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"},{"task_id":"HumanEval_126","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ \/\/ ⵓⵟⵟⵓⵏ, ⴰⵔ ⵉⵜⵜⴰⴽⵔⴰ ⵜⵉⴽⵍⵉⵜ ⵏ false. ⵓⵔ ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⴽⵔⴰ ⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴳⵓⵔⴰⵏ ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. \/\/ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵇⵔⴰⵏ. ⵎⴽ ⴷⴰⵔ ⵓⵎⵙⴳⵏⴰⴼ ⵓⴳⴳⴰⵔ ⵏ 1 ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵢⴰⵏ \/\/ ⴰⵖⴼ ⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏⵏ, ⴰⵔ ⵏⵙⵙⴽⵛⵎ ⵎⴽⵍⵍⵉ ⴳⴰⵏ ⵉⵎⵙⵓⴷⵙⵏ \/\/\/ >>> is_sorted(lst: [5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 3, 2, 4, 5])\n\/\/\/ false\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5, 6])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n\/\/\/ false\n\/\/\/ >>> is_sorted(lst: [1, 2, 2, 3, 3, 4])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\/\/\/ false\nfunc is_sorted(lst: [Int]) -> Bool {\n","canonical_solution":"func is_sorted(lst: [Int]) -> Bool {\n    guard !lst.isEmpty else { return true }\n\n    var previous = lst[0]\n    var duplicates = 0\n\n    for i in 1..<lst.count {\n        if lst[i] < previous {\n            return false\n        } else if lst[i] == previous {\n            duplicates += 1\n            if duplicates > 1 {\n                return false\n            }\n        } else {\n            duplicates = 0\n        }\n        previous = lst[i]\n    }\n\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"},{"task_id":"HumanEval_127","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ [input\/output] ⵉⵎⴷⵢⴰⵣⵏ: \/\/ ⵎⴽ ⵓⵔ ⴷⴰ ⵜⵜⵎⵙⴰⵙⴰⵏ ⵙⵏⴰⵜ ⵏ ⵜⴽⵔⴹⵉⵡⵉⵏ, ⵙⵙⵓⴼⵖ \"NO\". \/\/ ⵎⴽ ⵓⵔ ⵜⵍⵍⵉ, ⵙⵓⵍ \"ⵓⵀⵓ\". \/\/ ⵎⴽ ⵜⴳⴰ ⵜⵉⵖⵣⵉ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⴰⵎⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⵙⵙⵓⴼⵖ \"YES\", \/\/ ⴷ ⵜⵉⵖⵣⵉ ⵏⵏⵙ ⵜⴳⴰ 1, ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ. \/\/ ⴰⵎⴷⵢⴰ, ⴰⵙⵎⵓⵜⵜⴳ ⵏ ⵉⵎⵣⴳⵓⵏⵏ (1, 3), (2, 4) ⵉⴳⴰ (2, 3) \/\/ ⵉⵙⵎⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ. \/\/ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⵎ ⵎⴰⵙⴷ ⵜⵉⵖⵣⵉ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵙⵏⴰⵜ \/\/ ⵉ ⴽⵓ ⵢⴰⵏ ⵓⵣⵎⵣ, ⴷⴰ ⵏⵙⵡⵉⵏⴳⵉⵎ ⵎⴰⵙⴷ ⴰⵙⵏⵜⵉ ⵏⵏⵙ ⵉⴳⴰ ⵉⵎⵥⵥⵉⵏ ⵏⵖⴷ ⵉⵎⵎⵔⵡⴰⵙⵏ ⴷ ⵜⴳⵉⵔⴰ ⵏⵏⵙ.\/\/ ⴷⴰ ⵉⵙⵎⵓⵏ ⵜⵉⵣⵡⵉⵔⵉ ⴷ ⵜⴳⵉⵔⴰ. \/\/ ⴳⵔⵔⴰⵜⵏ ⵉⵜⵜⵢⴰⵙⵏ ⵜⵜⵢⴰⵙⵏ ⴰⵢⵏⵏⴰ ⵎⵉ ⵉⴳⴰ ⵓⴱⵔⴰⵔⴰⵣ (ⵜⴰⵏⵣⵡⵉ, ⵜⴳⵉⵔⴰ) \/\/ ⴳ ⴽⵓ ⵢⴰⵏ ⵏ ⵉⵏⴱⵔⴰⵣⵏ ⵉⴳⴰ ⵢⴰⵏ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ. ⵙ ⵓⵎⴷⵢⴰ, ⵉⵏⴱⵔⴰⵣ = (ⵜⴱⴷⴰ, ⵜⴳⵉⵔⴰ) = (1, 2).\/\/ ⵜⵜⵓⴼⴽⴰ ⵙⵏⴰⵜ ⵏ ⵜⵉⵣⵉ, \/\/\/ >>> intersection(interval1: (1, 2), interval2: (2, 3))\n\/\/\/ \"NO\"\n\/\/\/ >>> intersection(interval1: (-1, 1), interval2: (0, 4))\n\/\/\/ \"NO\"\n\/\/\/ >>> intersection(interval1: (-3, -1), interval2: (-5, 5))\n\/\/\/ \"YES\"\nfunc intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n","canonical_solution":"func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n    \/\/ Helper function to determine if a number is prime\n    func isPrime(_ num: Int) -> Bool {\n        if num <= 1 {\n            return false\n        }\n        if num <= 3 {\n            return true\n        }\n        if num % 2 == 0 || num % 3 == 0 {\n            return false\n        }\n        var i = 5\n        while i * i <= num {\n            if num % i == 0 || num % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    \/\/ Find the start and end of the intersection\n    let intersectStart = max(interval1.0, interval2.0)\n    let intersectEnd = min(interval1.1, interval2.1)\n    \n    \/\/ Calculate the length of the intersection\n    let intersectionLength = intersectEnd - intersectStart\n\n    \/\/ Check if intersection length is positive and prime\n    if intersectionLength > 0 && isPrime(intersectionLength) {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersection(interval1: (1, 2), interval2: (2, 3)) == \"NO\")\nassert(intersection(interval1: (-1, 1), interval2: (0, 4)) == \"NO\")\nassert(intersection(interval1: (-3, -1), interval2: (-5, 5)) == \"YES\")\nassert(intersection(interval1: (-2, 2), interval2: (-4, 0)) == \"YES\")\nassert(intersection(interval1: (-11, 2), interval2: (-1, -1)) == \"NO\")\nassert(intersection(interval1: (1, 2), interval2: (3, 5)) == \"NO\")\nassert(intersection(interval1: (1, 2), interval2: (1, 2)) == \"NO\")\nassert(intersection(interval1: (-2, -2), interval2: (-3, -2)) == \"NO\")"},{"task_id":"HumanEval_128","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⵙⵙⴽⵜⵉ: ⴰⵔ ⵏⴰⴽⴽⴰ nil ⵉ arr ⵓⵔ ⵉⵍⵍⵉⵏ. \/\/ ⵏ ⴽⵓ ⵓⵟⵟⵓⵏ ⴳ ⵓⵎⵙⴳⵔⴰⵡ, ⵉⵜⵜⵓⵙⵎⴷⵢⴰ ⵙ 1, -1 ⵏⵖⴷ 0. \/\/ ⴰⵖⵔⵓⵎ ⵏ ⵜⵉⵙⴽⴼⴰⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙ ⵜⵢⴰⴼⵓⵜ ⵏ ⵉⵙⵎⴰⵡⵏ ⴰⴽⴽⵡ \/\/ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽ ⵢⴰⵏ ⵓⵙⵏⵙⵍ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵔⵉⵜⵔⵉⵏ \/\/\/ >>> prod_signs(arr: [1, 2, 2, -4])\n\/\/\/ 9\n\/\/\/ >>> prod_signs(arr: [0, 1])\n\/\/\/ 0\n\/\/\/ >>> prod_signs(arr: [] as [Int])\n\/\/\/ nil\nfunc prod_signs(arr: [Int]) -> Int? {\n","canonical_solution":"func prod_signs(arr: [Int]) -> Int? {\n    \/\/ Return nil for empty array\n    if arr.isEmpty {\n        return nil\n    }\n\n    \/\/ Calculate the sum of magnitudes\n    let sumOfMagnitudes = arr.reduce(0) { sum, num in\n        return sum + abs(num)\n    }\n\n    \/\/ Calculate the product of all signs\n    let productOfSigns = arr.reduce(1) { product, num in\n        if num > 0 {\n            return product * 1\n        } else if num < 0 {\n            return product * -1\n        } else {\n            return 0\n        }\n    }\n\n    \/\/ Return the result of sum of magnitudes multiplied by product of signs\n    return sumOfMagnitudes * productOfSigns\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"},{"task_id":"HumanEval_129","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵉⵜⵜⵓⵙⵓⴷⵙⵏ ⵏ ⵡⴰⵜⵉⴳⵏ ⵏ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⵙ ⵉⴳⴳⵡⴰⵔ ⴰⴱⵔⵉⴷ ⵏ ⵓⵙⵎⵓⵜⵜⴳ. \/\/ ⵉⵜⵜⵓⴳⴰ ⴰⵖⵏⵏⴰⵏ ⵎⴰⵙⴷ ⵜⴰⵔⴰⵔⵓⵜ ⵜⴳⴰ ⵢⴰⵜ. \/\/ lst_A[j] = lst_B[j] \/\/ ⵣⵓⵏⴷ lst_A[i] < lst_B[i] ⴷ ⵉ ⴽⵓ j (1 <= j < i) ⵖⵓⵔⵖ \/\/ ⵏ lst_B, ⵙ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵢⴰⴹⵏ, ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ i (1 <= i <= k) \/\/ ⵙ (ⴰⴷ ⵏⵉⵏⵉ ⴰⵙⵏ lst_A ⴷ lst_B), lst_A ⵉⴳⴰ ⵡⵉⵏ ⵓⴷⵔⴰⵔ \/\/ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⴽⴰⵔ ⵏ ⵉⵙⵏⴼⴰⵔⵏ ⵏ ⵡⴰⵜⵉⴳⵏ ⵏ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⵔⴰⴷ ⵙⴽⵔⵏ A ⴷ B \/\/ ⴰⴱⵔⵉⴷ A (ⵙ ⵜⵉⵖⵣⵉ k) ⵉⴳⴰ ⵜⵜ ⵉⵎⵥⵥⵉⵢⵏ ⵙⴳ ⵓⴱⵔⵉⴷ B (ⵙ ⵜⵉⵖⵣⵉ k) ⵎⴽ \/ ⵓⵔ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵣⵔⵉⴷ ⵙⴳ ⵜⵔⴰⴱⴱⵓⵜ.\/\/ ⴰⵀⴰ ⵉⵎⵣⴰⵔⴰⵢⵏ). \/\/ ⵔⵥⵎ ⴰⵖ ⴳ ⵓⴱⵔⵉⴷ ⵏ ⵜⵉⵖⵣⵉ k ⴷⴰ ⵉⵙⵎⵓⵏ ⴽⵔⴰ ⵏ ⵜⵖⵔⴰⵙⵉⵏ (ⵓⵔ \/\/ ⵜⴰⵖⵔⴰⵙⵜ. \/\/ ⵙ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵢⴰⴹⵏ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵣⵔⴷ ⵉ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⴷⴰⵔ ⵢⴰⵏ ⵓⴽⴼⴼⴰⵢ ⴰⴽⴷ ⵡⴰⵙⵙⴰⵢ \/\/ ⵙⴳ ⴽⵔⴰ ⵏ ⵜⵖⵔⴰⵙⵜ, ⴷ ⴳ ⴽⵓ ⵜⴰⵙⵓⵔⵉⴼⵜ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵖⵔ ⴽⵔⴰ ⵏ ⵜⵖⵔⴰⵙⵜ ⵜⴰⴷⴷⴰⵔⵜ ⵜⵓⵎⵍⵉⵍⵜ, \/\/ ⴰⴷ ⵜⵙⵙⴼⵔⴰⵢⴷ ⴰⴱⵔⵉⴷ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵜⵉⵣⵉ k ⴳ ⵜⵊⵎⵉⵍⵜ. ⵥⴹⴰⵕⴷ ⴰⴷ ⵜⵙⵙⵏⵜⵉ \/\/ ⴷⴰ ⵉⵜⵜⵓⵣⵎⵎⴻⵎ inclusive ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ ⴳ ⵜⵖⵔⴰⵙⵉⵏ ⵏ ⵜⴽⵔⵔⴰⵢⵜ. \/\/ ⴽⵓ ⵜⴰⵖⵔⴰⵙⵜ ⵏ ⵜⴽⵔⵟⴰ ⵜⵍⴰ ⵢⴰⵏ ⵡⴰⵜⵉⴳ. ⴽⵓ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵙⵏⴼⵍ [1, N * N] \/\/ ⴰⵖⵉⵍ ⵏ ⵜⵊⵎⵉⵍⵜ ⴷ N ⵏ ⵜⵉⴼⵔⴽⵉⵏ ⴷ N ⵏ ⵜⵉⵔⵙⴰⵍ (N >= 2) ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ k, \/\/\/ >>> minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3)\n\/\/\/ [1, 2, 1]\n\/\/\/ >>> minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1)\n\/\/\/ [1]\nfunc minPath(grid: [[Int]], k: Int) -> [Int] {\n","canonical_solution":"func minPath(grid: [[Int]], k: Int) -> [Int] {\n    let n = grid.count\n    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    struct Path: Comparable {\n        let cells: [Int]\n        \n        static func < (lhs: Path, rhs: Path) -> Bool {\n            return lhs.cells.lexicographicallyPrecedes(rhs.cells)\n        }\n    }\n    \n    var minPath: Path? = nil\n    \n    func dfs(x: Int, y: Int, k: Int, currentPath: [Int]) {\n        var currentPath = currentPath\n        currentPath.append(grid[x][y])\n        \n        if currentPath.count == k {\n            let newPath = Path(cells: currentPath)\n            if minPath == nil || newPath < minPath! {\n                minPath = newPath\n            }\n            return\n        }\n        \n        for direction in directions {\n            let newX = x + direction.0\n            let newY = y + direction.1\n            if newX >= 0 && newX < n && newY >= 0 && newY < n {\n                dfs(x: newX, y: newY, k: k, currentPath: currentPath)\n            }\n        }\n    }\n    \n    for i in 0..<n {\n        for j in 0..<n {\n            dfs(x: i, y: j, k: k, currentPath: [])\n        }\n    }\n    \n    return minPath!.cells\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3) == [1, 2, 1])\nassert(minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1) == [1])\nassert(minPath(grid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], k: 4) == [1, 2, 1, 2])\nassert(minPath(grid: [[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], k: 7) == [1, 10, 1, 10, 1, 10, 1])\nassert(minPath(grid: [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], k: 5) == [1, 7, 1, 7, 1])\nassert(minPath(grid: [[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], k: 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\nassert(minPath(grid: [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], k: 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\nassert(minPath(grid: [[2, 7, 4], [3, 1, 5], [6, 8, 9]], k: 8) == [1, 3, 1, 3, 1, 3, 1, 3])\nassert(minPath(grid: [[6, 1, 5], [3, 8, 9], [2, 7, 4]], k: 8) == [1, 5, 1, 5, 1, 5, 1, 5])\nassert(minPath(grid: [[1, 2], [3, 4]], k: 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\nassert(minPath(grid: [[1, 3], [3, 2]], k: 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])"},{"task_id":"HumanEval_130","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ n + 1 ⵏ ⵜⵔⴱⵓⵏⴰⵛⵛⵉ. \/\/ ⵏⵜⵜⴰⴼⴰ ⵢⴰⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⵏⴳⵓ n, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵏⵔⴰⵔ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ \/\/ = 2 + 3 + 3 = 8 \/\/ tri(3) = tri(2) + tri(1) + tri(4) \/\/ tri(4) = 3 \/\/ tri(2) = 1 + (2 \/ 2) = 2 \/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ tri ((n) = tri ((n - 1) + tri ((n - 2) + tri ((n + 1), ⵉⴳ n ⵉⴳⴰ ⴰⵎⵣⴳⵓⵏ. \/\/tri{n}=1 + n \/2, ⵉⴳ n ⵉⴳⴰ ⴰⵎⵎ. \/\/ tri(1) = 3 \/\/ ⴷⴰ ⵜⵜⵓⵙⵏⵎⵍ ⵜⴹⴰ ⵏ ⵜⵔⵉⴱⵓⵏⴰⵛⵉ ⵙ ⵓⵙⵏⵓⵍⴼⵓ: ⵎⴰⵛⴰ, ⵎⴰ ⵓⵔ ⵉⵙⵙⵏ ⵓⴼⴳⴰⵏ ⵉⴳⴰ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵟⵔⵉⴱⵓⵏⴰⵛⵉ.ⴽⵓ ⵢⴰⵏ ⵉⵙⵙⵏ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ, ⵜⵜⵓⵙⵎⵔⵙⵏⵜ ⵙ ⵓⴳⴳⴰⵔ ⵙⴳ ⵉⵎⵓⵙⵏⴰⵡⵏ ⵏ ⵜⵓⵙⵏⴰⴽⵜ ⴳ \/\/\/ >>> tri(n: 3)\n\/\/\/ [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n","canonical_solution":"func tri(n: Int) -> [Int] {\n    guard n >= 0 else { return [] }\n    if n == 0 { return [1] }\n    if n == 1 { return [1, 3] }\n    if n == 2 { return [1, 3, 2] }\n    \n    var sequence = [1, 3, 2]\n    \n    for i in 3...n {\n        if i % 2 == 0 {\n            sequence.append(1 + i \/ 2)\n        } else {\n            let nextVal = sequence[i-1] + sequence[i-2] + sequence[i+1-1]\n            sequence.append(nextVal)\n        }\n    }\n    \n    return sequence\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])"},{"task_id":"HumanEval_131","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ 0 ⵎⴽ ⵜⴳⴰ ⴽⵓⵍⵍⵓ ⵜⵉⵟⵟⵓⵏⵉⵏ ⵜⵉⴽⵙⵡⴰⵜⵉⵏ. \/\/ ⴰⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵙⵓⴼⵖ ⵜⴰⵢⴰⴼⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ. \/\/\/ >>> digits(n: 1)\n\/\/\/ 1\n\/\/\/ >>> digits(n: 4)\n\/\/\/ 0\n\/\/\/ >>> digits(n: 235)\n\/\/\/ 15\nfunc digits(n: Int) -> Int {\n","canonical_solution":"func digits(n: Int) -> Int {\n    var num = n\n    var product = 1\n    var hasOdd = false\n    \n    while num > 0 {\n        let digit = num % 10\n        if digit % 2 != 0 {\n            hasOdd = true\n            product *= digit\n        }\n        num \/= 10\n    }\n    \n    return hasOdd ? product : 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digits(n: 5) == 5)\nassert(digits(n: 54) == 5)\nassert(digits(n: 120) == 1)\nassert(digits(n: 5014) == 5)\nassert(digits(n: 98765) == 315)\nassert(digits(n: 5576543) == 2625)\nassert(digits(n: 2468) == 0)"},{"task_id":"HumanEval_132","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴳ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴽⵛⵛⵓⵎ ⴳ ⵜⴹⴼⵉⵕⵜ ⵏ ⵜⵙⵏⵙⵉ. \/\/ ⵔⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ true ⵎⴽ ⴷ ⵖⴰⵙ ⵎⴽ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴹⴼⴼⵓⵕ ⵏ ⵜⴷⵔⴰⵡⵜ ⵏ ⵜⴷⵔⴰⵡⵉⵏ \/\/ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⵓⵙⴽⵉⵡⵉⵏ ⵜⵉⴽⵓⵢⵔⵉⵏ. \/\/\/ >>> is_nested(string: \"[[]]\")\n\/\/\/ true\n\/\/\/ >>> is_nested(string: \"[]]]]]]][[[[[]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[][]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[[][]]\")\n\/\/\/ true\n\/\/\/ >>> is_nested(string: \"[[]][[\")\n\/\/\/ true\nfunc is_nested(string: String) -> Bool {\n","canonical_solution":"func is_nested(string: String) -> Bool {\n    var stack: [Character] = []\n    var nested = false\n\n    for bracket in string {\n        if bracket == \"[\" {\n            stack.append(bracket)\n        } else if bracket == \"]\" {\n            if let last = stack.last, last == \"[\" {\n                stack.removeLast()\n                if !stack.isEmpty {\n                    nested = true\n                }\n            } else {\n                return false\n            }\n        }\n    }\n    return nested\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"},{"task_id":"HumanEval_133","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⵙⵙⵓⵜⵔ ⴽⵓ ⵉⴼⵔⴷⵉⵙ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵙ ⵜⴽⵍⵉⵜ ⵏ ⵓⴼⵍⵍⴰ (((ⴰⴽⴼⴼⴼⵓⵔ)) ⴳ ⵓⵎⵣⵡⴰⵔⵓ. \/\/ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵔⵉⵜⵔⵓⵏ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵓⵥ ⴳ ⵓⵙⵏⵙⵉ ⵏⵏⴰ ⴷ ⵢⵓⴼⴰ, \/\/ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵙⵓⵎ ⵏ ⵉⵎⴹⴰⵏⵏ. \/\/\/ >>> sum_squares(lst: [1.0, 2.0, 3.0])\n\/\/\/ 14\n\/\/\/ >>> sum_squares(lst: [1.0, 4.0, 9.0])\n\/\/\/ 98\n\/\/\/ >>> sum_squares(lst: [1.0, 3.0, 5.0, 7.0])\n\/\/\/ 84\n\/\/\/ >>> sum_squares(lst: [1.4, 4.2, 0.0])\n\/\/\/ 29\n\/\/\/ >>> sum_squares(lst: [-2.4, 1.0, 1.0])\n\/\/\/ 6\nfunc sum_squares(lst: [Double]) -> Int {\n","canonical_solution":"func sum_squares(lst: [Double]) -> Int {\n    return lst.map { ceil($0) } \/\/ Round each element to the upper int (Ceiling)\n              .map { Int($0 * $0) } \/\/ Square each element\n              .reduce(0, +) \/\/ Sum all squared elements\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 3.0, 5.0, 7.0]) == 84)\nassert(sum_squares(lst: [1.4, 4.2, 0.0]) == 29)\nassert(sum_squares(lst: [-2.4, 1.0, 1.0]) == 6)\nassert(sum_squares(lst: [100.0, 1.0, 15.0, 2.0]) == 10230)\nassert(sum_squares(lst: [10000.0, 10000.0]) == 200000000)\nassert(sum_squares(lst: [-1.4, 4.6, 6.3]) == 75)\nassert(sum_squares(lst: [-1.4, 17.9, 18.9, 19.9]) == 1086)\nassert(sum_squares(lst: [0.0]) == 0)\nassert(sum_squares(lst: [-1.0]) == 1)\nassert(sum_squares(lst: [-1.0, 1.0, 0.0]) == 2)"},{"task_id":"HumanEval_134","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⴰⵖⴰⵔⴰⵙ: \"ⴰⴳⵓⵔⵉ\" ⵉⴳⴰ ⵜⴰⵔⴰⴱⴱⵓⵜ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵜⵜⵓⵢⵙⴱⴹⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ. \/\/ ⵢⴰⵏ ⵓⴳⵣⵣⵓⵎ ⵏ ⵜⴳⵓⵔⵉ, ⴷ ⵡⴰⵍⴰ ⵏⵉⵜ ⵓⵔ ⵉⴳⵉ. \/\/ ⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉⵍ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉⵍ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵓⵔ ⵉⴳⵉ \/\/ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵎⵓⵖ ⴰⵎⴳⴳⴰⵔⵓ \/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pie\")\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pi e\")\n\/\/\/ true\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pi e \")\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"\")\n\/\/\/ false\nfunc check_if_last_char_is_a_letter(txt: String) -> Bool {\n","canonical_solution":"func check_if_last_char_is_a_letter(txt: String) -> Bool {\n    guard let lastChar = txt.trimmingCharacters(in: .whitespaces).last else {\n        return false\n    }\n    \n    if lastChar.isLetter {\n        let words = txt.split(separator: \" \")\n        if let lastWord = words.last {\n            return lastWord.count == 1\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_if_last_char_is_a_letter(txt: \"apple\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"eeeee\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"A\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie 1\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"eeeee e \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pie\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e \") == false)"},{"task_id":"HumanEval_135","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⴰⵜⵉⴳⵏ ⵉⵎⵢⴰⵍⵍⴰⵏ. \/\/ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵣⵓⵏⴷ ⴰⴷ, ⵔⴰⴷ ⵏⵔⴰⵔ -1.\/\/ ⵓⵔ ⵢⴰⴷ ⵢⵓⴳⵔ ⵏⵖ ⵓⵔ ⵢⴰⴽⵙⵓⵍ ⴷ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴷ ⵢⵣⵔⵉⵏ. ⵎⴽ \/\/ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⴰⵙⵖⵍ ⴰⵎⵇⵔⴰⵏ ⵏ ⵢⴰⵏ ⵉⴼⵔⴷⵉⵙ ⵏⵏⴰ \/\/\/ >>> can_arrange(arr: [1, 2, 4, 3, 5])\n\/\/\/ 3\n\/\/\/ >>> can_arrange(arr: [1, 2, 3])\n\/\/\/ -1\nfunc can_arrange(arr: [Int]) -> Int {\n","canonical_solution":"func can_arrange(arr: [Int]) -> Int {\n    for i in (1..<arr.count).reversed() {\n        if arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"},{"task_id":"HumanEval_136","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴳⴳⵓⵜⵏ ⵏⵖⴷ ⵉⵔⵡⵉⵏ, ⵙⵙⵓⴼⵖ-ⴰⵙⵏ ⵣⵓⵏⴷ nil. \/\/ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵢⴰⵏ ⵓⵙⵏⵙⵍ. \/\/ ⴰⵎⵇⵇⵔⴰⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵔⵡⵉⵏ, ⴷ 'ⴱ' ⵉⴳⴰ ⴰⵎⵥⵥⵢⴰⵏ \/\/ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⴰⵔⵔⴰⵢⵜ ⵏ ⵜⴱⵔⴳⴰⵍⵜ (a, b), ⴳ ⵉⵍⵍⴰ 'a' \/\/\/ >>> largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7])\n\/\/\/ (nil, 1)\n\/\/\/ >>> largest_smallest_integers(lst: [] as [Int])\n\/\/\/ (nil, nil)\n\/\/\/ >>> largest_smallest_integers(lst: [0])\n\/\/\/ (nil, nil)\nfunc largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {\n","canonical_solution":"func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {\n    var largestNegative: Int? = nil\n    var smallestPositive: Int? = nil\n\n    for number in lst {\n        if number < 0 {\n            if largestNegative == nil || number > largestNegative! {\n                largestNegative = number\n            }\n        } else if number > 0 {\n            if smallestPositive == nil || number < smallestPositive! {\n                smallestPositive = number\n            }\n        }\n    }\n\n    return (largestNegative, smallestPositive)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7]) == (nil, 1))\nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7, 0]) == (nil, 1))\nassert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6, -2]) == (-2, 1))\nassert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7]) == (-7, 2))\nassert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2))\nassert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))\nassert(largest_smallest_integers(lst: [0]) == (nil, nil))\nassert(largest_smallest_integers(lst: [-1, -3, -5, -6]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-1, -3, -5, -6, 0]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, 1]) == (-3, 1))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100, 1]) == (-3, 1))"},{"task_id":"HumanEval_137","nl":"tzm_Tfng","pl":"swift","prompt":"\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n\/\/ ⴰⵖⴰⵔⴰⵙ: ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⵢⴰⵏ ⵓⵡⵔⵉⴽ, ⵉⵖⵢ ⴰⴷ ⵉⴳ ⵓⴹⵕⵉⵚ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵎ . ⵏⵖ , \/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ nil ⵎⴽ ⵜⴳⴰ ⵜⵉⵜⵉⴳⵉⵏ ⵜⵉⵙⴳⵏⴰⵏⵉⵏ. \/\/ ⵉⵎⴹⴰⵏⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴰⵔ ⵉⵙⴽⴰⵔ ⴰⵎⵙⵏⴼⵍⵓⵍ ⴰⵅⴰⵜⴰⵔ ⴳ ⵡⴰⵏⴰⵡ ⵏ ⵓⵎⵙⵏⴼⵍⵓⵍ ⵏⵏⴻⵙ. \/\/ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵉⵙⴼⵍⴷⵏ, ⵏⵖ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ \/\/\/ >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))\n\/\/\/ .doubleValue(2.5)\n\/\/\/ >>> compare_one(a: .intValue(1), b: .stringValue(\"2,3\"))\n\/\/\/ .stringValue(\"2,3\")\n\/\/\/ >>> compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n\/\/\/ .stringValue(\"6\")\n\/\/\/ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n\/\/\/ nil\nfunc compare_one(a: Value, b: Value) -> Value? {\n","canonical_solution":"func compare_one(a: Value, b: Value) -> Value? {\n    func convertToDouble(value: Value) -> Double? {\n        switch value {\n        case .intValue(let int):\n            return Double(int)\n        case .doubleValue(let double):\n            return double\n        case .stringValue(let string):\n            let formatter = NumberFormatter()\n            formatter.locale = Locale(identifier: \"en_US_POSIX\")\n            if string.contains(\",\") {\n                formatter.decimalSeparator = \",\"\n            } else {\n                formatter.decimalSeparator = \".\"\n            }\n            return formatter.number(from: string)?.doubleValue\n        }\n    }\n    \n    let aDouble = convertToDouble(value: a)\n    let bDouble = convertToDouble(value: b)\n    \n    if let aDouble = aDouble, let bDouble = bDouble {\n        if aDouble > bDouble {\n            return a\n        } else if bDouble > aDouble {\n            return b\n        }\n    }\n    \n    return nil\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)"},{"task_id":"HumanEval_138","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ \/\/ ⵙⵙⴼⵔⴰⵢ ⵎⴽ ⵜⵣⵎⵔⵎ ⴰⴷ ⵜⵔⵉⵜ ⴰⵎⴹⴰⵏ n ⴰⵎⵎ ⵓⴳⵣⵓⵎ ⵏ 4 ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵎⵓⴹⴰⵏⵏ ⵉⴽⵙⵡⴰⵜⵏ \/\/\/ >>> is_equal_to_sum_even(n: 4)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(n: 6)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(n: 8)\n\/\/\/ true\nfunc is_equal_to_sum_even(n: Int) -> Bool {\n","canonical_solution":"func is_equal_to_sum_even(n: Int) -> Bool {\n    if n <= 8 {\n        return false\n    }\n    return n % 2 == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_equal_to_sum_even(n: 4) == false)\nassert(is_equal_to_sum_even(n: 6) == false)\nassert(is_equal_to_sum_even(n: 8) == true)\nassert(is_equal_to_sum_even(n: 10) == true)\nassert(is_equal_to_sum_even(n: 11) == false)\nassert(is_equal_to_sum_even(n: 12) == true)\nassert(is_equal_to_sum_even(n: 13) == false)\nassert(is_equal_to_sum_even(n: 16) == true)"},{"task_id":"HumanEval_139","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⴳ ⵉⵍⵍⴰ n > 0 \/\/ brazilian_factorial{n}=n! * (n-1)! * (n-2)! * ... * 1! \/\/ ⴷⴰ ⵉⵜⵜⵓⵙⵏⵎⵍ ⵓⴼⴰⴽⵜⵓⵔⵢⴰⵍ ⴰⴱⵕⴰⵣⵉⵍⵉ ⵙ: \/\/\/ >>> special_factorial(n: 4)\n\/\/\/ 288\n\/\/\/ The function will receive an integer as input and should return the special\n\/\/\/ factorial of this integer.\nfunc special_factorial(n: Int) -> Int {\n","canonical_solution":"func factorial(_ n: Int) -> Int {\n    return n <= 1 ? 1 : n * factorial(n - 1)\n}\n\nfunc special_factorial(n: Int) -> Int {\n    var result = 1\n    for i in 1...n {\n        result *= factorial(i)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"},{"task_id":"HumanEval_140","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴷⴼⴼⵉⵔ ⴰⴷ ⵙⵏⴼⵍ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵣⴷⴰⵖⵏ ⵙ - \/\/ ⴷ ⵎⴽ ⴷⴰⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵏⵙⵎⴰⵙⵙⵓ ⵓⴳⴳⴰⵔ ⵏ 2 ⵏ ⵡⴰⵏⵙⴰ ⵉⵎⴹⴼⴰⵕⵏ, \/\/ ⵙ ⵓⴹⵕⵉⵚ ⵏ ⵜⵣⵍⵉⵜ, ⵙⵙⵓⵜⴼ ⴰⴽⴽⵡ ⵉⴷⵖⴰⵔⵏ ⴳⵉⵙ ⵙ ⵉⵙⵡⵉⵔⴰ, \/\/\/ >>> fix_spaces(text: \" Example\")\n\/\/\/ \"Example\"\n\/\/\/ >>> fix_spaces(text: \" Example 1\")\n\/\/\/ \"Example_1\"\n\/\/\/ >>> fix_spaces(text: \" Example 2\")\n\/\/\/ \"_Example_2\"\n\/\/\/ >>> fix_spaces(text: \" Example 3\")\n\/\/\/ \"_Example-3\"\nfunc fix_spaces(text: String) -> String {\n","canonical_solution":"func fix_spaces(text: String) -> String {\n    var result = \"\"\n    var spaceCount = 0\n    \n    for character in text {\n        if character == \" \" {\n            spaceCount += 1\n        } else {\n            if spaceCount == 1 {\n                result.append(\"_\")\n            } else if spaceCount > 1 {\n                result.append(\"-\")\n            }\n            result.append(character)\n            spaceCount = 0\n        }\n    }\n    \n    if spaceCount == 1 {\n        result.append(\"_\")\n    } else if spaceCount > 1 {\n        result.append(\"-\")\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fix_spaces(text: \"Example\") == \"Example\")\nassert(fix_spaces(text: \"Mudasir Hanif \") == \"Mudasir_Hanif_\")\nassert(fix_spaces(text: \"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\")\nassert(fix_spaces(text: \"Exa   mple\") == \"Exa-mple\")\nassert(fix_spaces(text: \"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\")"},{"task_id":"HumanEval_141","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: - ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵓⵙⴽⴽⵉⵍ ⵏ ⴷⴼⴼⵉⵔ ⵏ ⵜⵓⵙⴷⵉⴷⵜ ⵢⴰⵏ ⵙⴳ ⵡⵉⵏⵏⴰ ⴷⴷⵖ: ['txt', 'exe', 'dll'] \/\/ ⴰⵍⴰⴼⵉⴱⵉⵜ ⴰⵍⴰⵜⵉⵏⵉ ('a'-'z' ⴷ 'A'-'Z'). - ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵢⵉⵍⵉ ⵡⴰⵏⵙⴰ ⴷⴰⵜ ⵏ ⵜⵓⵙⴷⵉⴷⵜ, ⴰⵔ ⵜⴱⴷⴰⴷ ⵙ ⵓⴱⵔⴰⵜ ⵙⴳ \/\/ - ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⵉⵍⵍⴰ ⴳⵉⵙ ⵢⴰⵏ ⵓⴷⵖⴰⵔ '.' - ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵉⵍⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⴽⵕⴰⴹ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ('0'-'9') ⴳ ⵉⵙⵎ ⵏ ⵓⴷⵍⵉⵙ.\/\/ ⵜⵜⵓⵙⵎⵓⵏ: \/\/ ⴷⴰ ⵉⵜⵜⵓⵙⵎⴳⴰⵍ ⵢⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⴰⴷ ⵉⴳ ⵡⵉⵏ ⵜⵓⵏⵏⵓⵏⵜ ⵎⴽ ⴷ ⵖⴰⵙ ⵎⴽ ⴷⴰ ⵜⵜⵎⵓⵏⵏ ⴽⵓⵍⵍⵓ ⵜⵎⵣⴰⵣⵉⵏ ⴰⴷ \/\/ 'Yes' ⵉⵖ ⵉⴳⴰ ⵢⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⴰⵣⵔⴼⴰⵏ, ⴰⵔ ⵉⵙⵡⵓⵜⵜⵓ 'No' ⵎⴽ ⵓⵔ ⵉⴳⵉ. \/\/ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏ ⵉⵙⵎ ⵏ ⵓⵡⵉⴽⵉ, ⴰⵔ ⵉⵜⵜⵔⴰⵔ \/\/\/ >>> file_name_check(file_name: \"example.txt\")\n\/\/\/ \"Yes\"\n\/\/\/ >>> file_name_check(file_name: \"1example.dll\")\n\/\/\/ \"No\"\nfunc file_name_check(file_name: String) -> String {\n","canonical_solution":"func file_name_check(file_name: String) -> String {\n    \/\/ Split by the dot.\n    let components = file_name.split(separator: \".\", omittingEmptySubsequences: false)\n    \n    \/\/ Check if there's exactly one dot.\n    guard components.count == 2 else {\n        return \"No\"\n    }\n    \n    \/\/ Extract the prefix and suffix.\n    let prefix = String(components[0])\n    let suffix = String(components[1])\n    \n    \/\/ Check if the prefix is non-empty and starts with a letter.\n    guard !prefix.isEmpty, let firstChar = prefix.first, firstChar.isLetter else {\n        return \"No\"\n    }\n    \n    \/\/ Check if the suffix is one of the allowed types.\n    let validSuffixes = [\"txt\", \"exe\", \"dll\"]\n    guard validSuffixes.contains(suffix) else {\n        return \"No\"\n    }\n    \n    \/\/ Count digits in the file name.\n    let digitCount = file_name.filter { $0.isNumber }.count\n    \n    \/\/ Ensure that there are not more than 3 digits.\n    guard digitCount <= 3 else {\n        return \"No\"\n    }\n    \n    \/\/ If all checks pass, it's a valid file name.\n    return \"Yes\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(file_name_check(file_name: \"example.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"1example.dll\") == \"No\")\nassert(file_name_check(file_name: \"s1sdf3.asd\") == \"No\")\nassert(file_name_check(file_name: \"K.dll\") == \"Yes\")\nassert(file_name_check(file_name: \"MY16FILE3.exe\") == \"Yes\")\nassert(file_name_check(file_name: \"His12FILE94.exe\") == \"No\")\nassert(file_name_check(file_name: \"_Y.txt\") == \"No\")\nassert(file_name_check(file_name: \"?aREYA.exe\") == \"No\")\nassert(file_name_check(file_name: \"\/this_is_valid.dll\") == \"No\")\nassert(file_name_check(file_name: \"this_is_valid.wow\") == \"No\")\nassert(file_name_check(file_name: \"this_is_valid.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"this_is_valid.txtexe\") == \"No\")\nassert(file_name_check(file_name: \"#this2_i4s_5valid.ten\") == \"No\")\nassert(file_name_check(file_name: \"@this1_is6_valid.exe\") == \"No\")\nassert(file_name_check(file_name: \"this_is_12valid.6exe4.txt\") == \"No\")\nassert(file_name_check(file_name: \"all.exe.txt\") == \"No\")\nassert(file_name_check(file_name: \"I563_No.exe\") == \"Yes\")\nassert(file_name_check(file_name: \"Is3youfault.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"no_one#knows.dll\") == \"Yes\")\nassert(file_name_check(file_name: \"1I563_Yes3.exe\") == \"No\")\nassert(file_name_check(file_name: \"I563_Yes3.txtt\") == \"No\")\nassert(file_name_check(file_name: \"final..txt\") == \"No\")\nassert(file_name_check(file_name: \"final132\") == \"No\")\nassert(file_name_check(file_name: \"_f4indsartal132.\") == \"No\")\nassert(file_name_check(file_name: \".txt\") == \"No\")\nassert(file_name_check(file_name: \"s.\") == \"No\")"},{"task_id":"HumanEval_143","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ 1: \/\/ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⴳ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴳ ⵜⵣⵍⵉⵜ ⵜⴰⵎⴰⵢⵏⵓⵜ ⴰⵎⵎ ⵜⴰⵣⵍⵉⵜ ⵜⴰⵣⵡⴰⵔⵓⵜ. \/\/ ⵜⵉⵖⵣⵉ ⵏⵏⵙ ⴳⴰⵏⵜ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ, \/\/ ⴷ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵔⵉⵜⵔⵓⵏ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ ⴳ ⵍⵍⴰⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵜⴳⵓⵔⵉ ⵜⴰⵢⵎⵎⴰⵜ, \/\/ ⴳ ⵜⴳⵓⵔⵉ ⵉⵍⵍⴰ ⴽⵔⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵜⵜⵓⵣⵍⴰⵢⵏ ⵙ ⵢⴰⵏ ⵓⵙⴰⵢⵔⴰⵔ, \/\/ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ ⵉⵙⵎⴷⵢⴰⵏⵏ ⵜⴰⴳⵓⵔⵉ, \/\/\/ >>> words_in_sentence(sentence: \"This is a test\")\n\/\/\/ \"is\"\n\/\/\/ Example 2:\n\/\/\/ >>> words_in_sentence(sentence: \"lets go for swimming\")\n\/\/\/ \"go for\"\n\/\/\/ Constraints:\n\/\/\/ * 1 <= len(sentence) <= 100\n\/\/\/ * sentence contains only letters\nfunc words_in_sentence(sentence: String) -> String {\n","canonical_solution":"func words_in_sentence(sentence: String) -> String {\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 { return false }\n            i += 6\n        }\n        return true\n    }\n    \n    let words = sentence.split(separator: \" \")\n    let primeLengthWords = words.filter { isPrime($0.count) }\n    return primeLengthWords.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"},{"task_id":"HumanEval_144","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵏⵣⵎⵔ ⴰⴷ ⵏⵙⵡⵉⵏⴳⵉⵎ ⵎⴰⵙ ⴷ x, ⴷ n ⴳⴰⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵣⵔⴼⴰⵏ, ⴷ ⵓⵔ ⵖⵓⵔⵙⵏ ⵓⵎⵢⴰ ⴰⵎⵎ ⵓⵎⵙⵙⴰⵖ. \/\/ <numerator>\/<denominator> ⴳⴰⵏ ⵉⵎⵉⴹⴰⵏ ⴷ ⵉⵎⵙⵙⴰⵖⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵓⴼⴰⵢⵏ. \/\/ ⵎⴽⵍⵍⵉ ⵓⵔ ⵉⴳⵉ. x ⴷ n, ⴳⴰⵏ ⴰⵙⵎⴷⵢⴰ ⵏ ⵜⵉⴼⵔⴽⵜ, ⴷ ⵖⵓⵔⵙⵏ ⵜⴰⵍⵖⴰ ⴷ ⵢⵓⵛⴽⴰⵏ, \/\/ x * n. ⴷⴰ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ true ⵎⴽ ⴷⴰ ⵜⵙⵙⵎⵔⴰⵙ x * n ⵉ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴷ false \/\/ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵔⵎ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵔⴰⴷ ⵉⵙⴱⴷⴷⴰⴷ ⴰⵙⵏⵓⵎⵎⵍ \/\/\/ >>> simplify(x: \"1\/5\", n: \"5\/1\")\n\/\/\/ true\n\/\/\/ >>> simplify(x: \"1\/6\", n: \"2\/1\")\n\/\/\/ false\n\/\/\/ >>> simplify(x: \"7\/10\", n: \"10\/2\")\n\/\/\/ false\nfunc simplify(x: String, n: String) -> Bool {\n","canonical_solution":"func simplify(x: String, n: String) -> Bool {\n    func parseFraction(fraction: String) -> (numerator: Int, denominator: Int) {\n        let parts = fraction.split(separator: \"\/\").map { Int($0)! }\n        return (numerator: parts[0], denominator: parts[1])\n    }\n    \n    let (xNumerator, xDenominator) = parseFraction(fraction: x)\n    let (nNumerator, nDenominator) = parseFraction(fraction: n)\n    \n    \/\/ Multiply the two fractions: (xNumerator * nNumerator) \/ (xDenominator * nDenominator)\n    let resultNumerator = xNumerator * nNumerator\n    let resultDenominator = xDenominator * nDenominator\n    \n    \/\/ Check if the resulting fraction is a whole number by verifying if the numerator is divisible by the denominator\n    return resultNumerator % resultDenominator == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(simplify(x: \"1\/5\", n: \"5\/1\") == true)\nassert(simplify(x: \"1\/6\", n: \"2\/1\") == false)\nassert(simplify(x: \"5\/1\", n: \"3\/1\") == true)\nassert(simplify(x: \"7\/10\", n: \"10\/2\") == false)\nassert(simplify(x: \"2\/10\", n: \"50\/10\") == true)\nassert(simplify(x: \"7\/2\", n: \"4\/2\") == true)\nassert(simplify(x: \"11\/6\", n: \"6\/1\") == true)\nassert(simplify(x: \"2\/3\", n: \"5\/2\") == false)\nassert(simplify(x: \"5\/2\", n: \"3\/5\") == false)\nassert(simplify(x: \"2\/4\", n: \"8\/4\") == true)\nassert(simplify(x: \"2\/4\", n: \"4\/2\") == true)\nassert(simplify(x: \"1\/5\", n: \"5\/1\") == true)\nassert(simplify(x: \"1\/5\", n: \"1\/5\") == false)"},{"task_id":"HumanEval_145","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⵙⵙⵓⴷⵙ-ⵜⵏⵜ ⵅⴼ ⵓⵙⵏⴼⴰⵔ ⵏⵏⵙⵏⵜ ⴳ ⵓⵙⵏⵙⵍ ⴰⵎⵣⵡⴰⵔⵓ. \/\/ ⴰⵖⵏⵏⵉⵊ: ⵎⴽ ⵍⵍⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵙ ⵓⵖⵣⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ, \/\/ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ. \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵙⵎⵓⵏⵏ ⴰⵙⵔⵔⵓⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ \/\/\/ >>> order_by_points(nums: [1, 11, -1, -11, -12])\n\/\/\/ [-1, -11, 1, -12, 11]\n\/\/\/ >>> order_by_points(nums: [] as [Int])\n\/\/\/ [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n","canonical_solution":"func order_by_points(nums: [Int]) -> [Int] {\n    return nums.enumerated().sorted {\n        let sum1 = digitSum($0.element)\n        let sum2 = digitSum($1.element)\n        if sum1 == sum2 {\n            return $0.offset < $1.offset\n        } else {\n            return sum1 < sum2\n        }\n    }.map { $0.element }\n}\n\nfunc digitSum(_ number: Int) -> Int {\n    return String(abs(number)).compactMap { Int(String($0)) }.reduce(0, +)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"},{"task_id":"HumanEval_146","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⴷ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⵓⴳⴳⴰⵔⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵓⵔ ⵉⵎⵢⴰⵏⴰⵡⵏ (1, 3, 5, 7, 9). \/\/ ⴰⵎⴹⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵙⵏⵙⵍ ⵏⵏⴰ ⵎⵇⵇⵓⵔⵏⵉⵏ ⴷ 10 ⴷ ⵙⵏⴰⵜ \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵎ ⵉⵏⴽⵛⵓⵎⵏ ⴷ ⵉⵙⵏⴼⴰⵍⵏ \/\/\/ >>> specialFilter(nums: [15, -73, 14, -15])\n\/\/\/ 1\n\/\/\/ >>> specialFilter(nums: [33, -2, -3, 45, 21, 109])\n\/\/\/ 2\nfunc specialFilter(nums: [Int]) -> Int {\n","canonical_solution":"func specialFilter(nums: [Int]) -> Int {\n    return nums.filter { num in\n        let absNum = abs(num)\n        \n        guard absNum > 10 else {\n            return false\n        }\n        \n        let firstDigit = String(String(absNum).first!)\n        let lastDigit = String(absNum % 10)\n        \n        let oddDigits: Set = [\"1\", \"3\", \"5\", \"7\", \"9\"]\n        \n        return oddDigits.contains(firstDigit) && oddDigits.contains(lastDigit)\n    }.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(specialFilter(nums: [5, -2, 1, -5]) == 0)\nassert(specialFilter(nums: [15, -73, 14, -15]) == 1)\nassert(specialFilter(nums: [33, -2, -3, 45, 21, 109]) == 2)\nassert(specialFilter(nums: [43, -12, 93, 125, 121, 109]) == 4)\nassert(specialFilter(nums: [71, -2, -33, 75, 21, 19]) == 3)\nassert(specialFilter(nums: [1]) == 0)\nassert(specialFilter(nums: [] as [Int]) == 0)"},{"task_id":"HumanEval_147","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⴷ a[i] + a[j] + a[k] ⵉⴳⴰ ⴰⴽⴽⵡ ⴽⵕⴰⴹ. \/\/ ⴰⵔ ⵏⵙⵙⴽⵛⵎ ⵓⵟⵟⵓⵏ ⵏ ⵜⵔⴱⵢⵉⵍⵉⵏ (a[i], a[j], a[k]) ⵏ a ⴳ i < j < k, \/\/ ⵉ ⴽⵓ i (1 ≤ i ≤ n), ⴰⵜⵉⴳ ⵏ a[i] = i * i - i + 1. \/\/ ⵏⵜⵜⴰⴼⴰ ⵢⴰⵏ ⵉⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n. ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵏⵙⴽⵔ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⵏ ⵜⵉⵖⵣⵉ n. \/\/\/ >>> get_max_triples(n: 5)\n\/\/\/ 1\n\/\/\/ Explanation: \n\/\/\/ a = [1, 3, 7, 13, 21]\n\/\/\/ The only valid triple is (1, 7, 13).\nfunc get_max_triples(n: Int) -> Int {\n","canonical_solution":"func get_max_triples(n: Int) -> Int {\n    \/\/ Create the array a based on the problem description\n    var a = [Int](repeating: 0, count: n)\n    for i in 1...n {\n        a[i - 1] = i * i - i + 1\n    }\n    \n    var count = 0\n    \/\/ Check for all possible triples\n    for i in 0..<n {\n        for j in (i + 1)..<n {\n            for k in (j + 1)..<n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1\n                }\n            }\n        }\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_max_triples(n: 5) == 1)\nassert(get_max_triples(n: 6) == 4)\nassert(get_max_triples(n: 10) == 36)\nassert(get_max_triples(n: 100) == 53361)"},{"task_id":"HumanEval_149","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⴰⴷ ⵜⵙⵙⵏⵎ ⵉⵙ ⴽⵓⵍⵍⵓ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵔⴰⴷ ⵖⵓⵔⵙⵏ ⵜⵉⵖⵣⵉ ⵜⴰⵣⴳⵣⴰⵡⵜ. \/\/ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵙ ⵓⵙⵙⵓⴷⵙ. \/\/ ⵎⴽ ⴷⴰⵔ ⵙⵏⴰⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵜⵉⵖⵣⵉ ⵜⴰⵣⴳⵣⴰⵡⵜ, ⵙⵙⵓⴷⵙ ⵜⴰⵡⵔⵉⵔⵜ ⵙ ⵜⴰⵍⵖⴰ ⵜⴰⴽⵔⵓⵎⴰⵏⵜ. \/\/ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⵉ ⴰⵙⵏⵙⵍ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵓⵙⵍⴳⵏ ⴰⴷ. \/\/ ⴰⴷ ⵢⵉⵍⵉ ⵓⵙⵙⵓⴷⵙ ⵏ ⵓⵙⵏⵙⵍ ⵙ ⵓⴽⵓⴷ ⵏ ⴽⵓ ⵜⴳⵓⵔⵉ, ⴷ ⵔⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ \/\/ ⴷ ⵖⵉⵢⵏ ⴰⴷ ⴷⵉⴳⵙ ⵉⵍⵉⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⴰⵍⵍⴰⵏ. \/\/ ⴰⵙⵏⵙⵍ ⵉⴳⴰ ⴰⵀⴰ ⴰⵙⵏⵙⵍ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏⵏ, \/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⴳⵏ ⵙ ⵢⴰⵏ ⵓⴽⵓⴷ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⴳⵏ, \/\/ ⴷⴰ ⵉⵙⴱⴰⴷⵍ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⵖⵓⵔⵙⵏ ⵜⵉⵖⵣⵉ ⵜⴰⵣⴳⵣⴰⵡⵜ, \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵉⵙⵉⴹⵏⵏ ⴰⵎⵎ ⵓⴱⴰⵔⴰⵣ, \/\/\/ >>> sorted_list_sum(lst: [\"aa\", \"a\", \"aaa\"])\n\/\/\/ [\"aa\"]\n\/\/\/ >>> sorted_list_sum(lst: [\"ab\", \"a\", \"aaa\", \"cd\"])\n\/\/\/ [\"ab\", \"cd\"]\nfunc sorted_list_sum(lst: [String]) -> [String] {\n","canonical_solution":"func sorted_list_sum(lst: [String]) -> [String] {\n    return lst.filter { $0.count % 2 == 0 }\n              .sorted { \n                  if $0.count == $1.count {\n                      return $0 < $1\n                  }\n                  return $0.count < $1.count\n              }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sorted_list_sum(lst: [\"aa\", \"a\", \"aaa\"]) == [\"aa\"])\nassert(sorted_list_sum(lst: [\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"])\nassert(sorted_list_sum(lst: [\"d\", \"b\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst: [\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"])\nassert(sorted_list_sum(lst: [\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"])\nassert(sorted_list_sum(lst: [\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst: [\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"])"},{"task_id":"HumanEval_150","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⵣ ⴰⵜⵉⴳ ⵏ y ⵎⴽ ⵓⵔ ⵢⴰⴽⵣ. \/\/ ⴰⵖⴰⵡⴰⵙ ⴰⵎⵢⵉⵡⵏ ⵏⵏⴰ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⴰ ⴰⵜⵉⴳ ⵏ x ⵎⴽ ⵜⴳⴰ n \/\/\/ >>> x_or_y(n: 7, x: 34, y: 12)\n\/\/\/ 34\n\/\/\/ >>> x_or_y(n: 15, x: 8, y: 5)\n\/\/\/ 5\nfunc x_or_y(n: Int, x: Int, y: Int) -> Int {\n","canonical_solution":"func x_or_y(n: Int, x: Int, y: Int) -> Int {\n    func isPrime(_ number: Int) -> Bool {\n        if number <= 1 { return false }\n        if number <= 3 { return true }\n        if number % 2 == 0 || number % 3 == 0 { return false }\n        \n        var i = 5\n        while i * i <= number {\n            if number % i == 0 || number % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    return isPrime(n) ? x : y\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(x_or_y(n: 7, x: 34, y: 12) == 34)\nassert(x_or_y(n: 15, x: 8, y: 5) == 5)\nassert(x_or_y(n: 3, x: 33, y: 5212) == 33)\nassert(x_or_y(n: 1259, x: 3, y: 52) == 3)\nassert(x_or_y(n: 7919, x: -1, y: 12) == -1)\nassert(x_or_y(n: 3609, x: 1245, y: 583) == 583)\nassert(x_or_y(n: 91, x: 56, y: 129) == 129)\nassert(x_or_y(n: 6, x: 34, y: 1234) == 1234)\nassert(x_or_y(n: 1, x: 2, y: 0) == 0)\nassert(x_or_y(n: 2, x: 2, y: 0) == 2)"},{"task_id":"HumanEval_151","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴳ ⵓⵎⵙⴳⴷⴰⵍ ⵏⵏⴰ ⵓⵔ ⵉⵎⵙⴰⵙⴰⵏ. ⵔⴰⴷ ⵏⵙⵙⵏ ⵉⵎⴹⴰⵏⵏ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⴷⴷⴰⴷⵏ.\/\/ ⴰⵖⴼ ⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵡⵓⵟⵟⵓⵏⵏ, ⵙⵏⵓⵍⴼⵓ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵏ ⵡⵓⵟⵟⵓⵏⵏ \/\/\/ >>> double_the_difference(lst: [1, 3, 2, 0])\n\/\/\/ 10\n\/\/\/ >>> double_the_difference(lst: [-1, -2, 0])\n\/\/\/ 0\n\/\/\/ >>> double_the_difference(lst: [9, -2])\n\/\/\/ 81\n\/\/\/ >>> double_the_difference(lst: [0])\n\/\/\/ 0\n\/\/\/ If the input array is empty, return 0.\nfunc double_the_difference(lst: [Double]) -> Int {\n","canonical_solution":"func double_the_difference(lst: [Double]) -> Int {\n    return lst.filter { $0 >= 0 && $0 == floor($0) && Int($0) % 2 != 0 }\n              .map { Int($0) * Int($0) }\n              .reduce(0, +)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(double_the_difference(lst: [] as [Double]) == 0)\nassert(double_the_difference(lst: [5.0, 4.0]) == 25)\nassert(double_the_difference(lst: [0.1, 0.2, 0.3]) == 0)\nassert(double_the_difference(lst: [-10.0, -20.0, -30.0]) == 0)\nassert(double_the_difference(lst: [-1.0, -2.0, 8.0]) == 0)\nassert(double_the_difference(lst: [0.2, 3.0, 5.0]) == 34)\nassert(double_the_difference(lst: [-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)"},{"task_id":"HumanEval_152","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⴰⵜⵉⴳ ⵉⴳⴰ 0, ⴷ ⵎⴽ ⵓⵔ ⵉⴳⵉ, ⴰⵜⵉⴳ ⵉⴳⴰ ⴰⵎⵣⴰⵔⴰⵢ ⴰⵖⴰⵔⴰⵏ ⴳⵔ ⵓⵙⵏⵖⵎⵙ ⴷ ⵜⵏⴰⴼⵓⵜ. \/\/ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵜⵉⵖⵣⵉ ⵏⵏⴰ ⵉⵙⵙⵏⴰⵏ ⵎⴰⵎⴽ ⵙ ⵉⵣⵣⵉⴳⵉⵣ ⴽⵓ ⴰⵙⵏⵖⵎⵙ. ⵎⴽ ⵙⵏⵖⵏ ⵙ ⵜⴷⵓⵙⵉ, \/\/ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵏⴰⵜ ⵏ ⵜⵔⵎⵉⵏ ⵏ ⵜⵏⵇⵇⵉⵟⵉⵏ ⴷ ⵉⵙⵏⵓⵎⵎⴰⵍⵏ ⵏ ⵜⵉⵖⵣⵉ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⴳ ⴽⵓ ⵢⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⵙⵏⵎⵍ ⴷⴰ ⵉⵙⵙⴼⵍⴷ ⵢⴰⵜ ⵜⵎⵙⴰⵙⵜⵍⵜ. \/\/ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⵎ ⵎⴽ ⵜⵙⵙⵏ ⵢⴰⵏ ⵓⴼⴳⴰⵏ ⵙ ⵜⴷⵓⵙⵉ ⵜⵉⵢⴰⴼⵓⵜⵉⵏ ⵏ ⴽⵔⴰ ⵏ ⵉⵎⵏⴽⴰⴷⵏ. \/\/ ⵙ ⵡⴰⴷⴷⴰⴷ ⵉⵖⵓⴷⴰⵏ ⴰⴷ ⵏⵙⵙⴽⵜⵉ ⴷ ⴰⴷ ⵏⵙⵎⵣⴰⵣⴰⵍ. ⵀⴰⵜ ⵓⵔ ⴷ ⵉⵅⵚⵚⴰ ⴰⴷ ⵏⵙⵙⵏ ⵉⵙⴽⴽⵉⵏⵏ ⴷ ⵜⵡⵏⴳⵉⵎⵉⵏ ⵏⵏⴰ ⴷⴰⵔⴽ ⴳ ⵜⵉⵣⵉ ⴰⴷ.ⵄⴰⵍⵉ ⵏⵏⴽ ⴰⴽⴽⵡ ⵔⴰⴷ ⵜⵙⵙⵏⴷ ⴰⵙⵏⵖⵎⵙ ⴰⴷ ⵍⵍⵉⵖ ⵜⵍⴽⵎ ⵜⵢⴰⴼⵓⵜ ⵏ ⴽⵔⴰ ⵏ ⵓⵙⵏⵖⵎⵙ ⵉⵜⵜⵓⵣⵎⵎⴰⵔ ⵣⵉⴽⴽ\/\/\/ >>> compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2])\n\/\/\/ [0, 0, 0, 0, 3, 3]\n\/\/\/ >>> compare(game: [0, 5, 0, 0, 0, 4], guess: [4, 1, 1, 0, 0, -2])\n\/\/\/ [4, 4, 1, 0, 0, 6]\nfunc compare(game: [Int], guess: [Int]) -> [Int] {\n","canonical_solution":"func compare(game: [Int], guess: [Int]) -> [Int] {\n    var result: [Int] = []\n    \n    for i in 0..<game.count {\n        let difference = abs(game[i] - guess[i])\n        result.append(difference)\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3])\nassert(compare(game: [0, 0, 0, 0, 0, 0], guess: [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0])\nassert(compare(game: [1, 2, 3], guess: [-1, -2, -3]) == [2, 4, 6])\nassert(compare(game: [1, 2, 3, 5], guess: [-1, 2, 3, 4]) == [2, 0, 0, 1])"},{"task_id":"HumanEval_153","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ (ⵜⴰⵏⵣⴰ ⵏⵏⵙ ⵜⴳⴰ -1). \/\/ ⴰⵔ ⵉⵜⵜⵔ \"Slices.SErviNGSliCes\" ⴰⵛⴽⵓ \"SErviNGSliCes\" ⵉⴳⴰ ⴰⵙⵖⵣⵣⵉⴼ ⵉⴷⵓⵙⵏ \/\/ ⵉⵙⵎⵓⵜⵜⴳⵏ: ['SERVINGSliCes', 'Cheese', 'StuFfed'] ⵀⴰⵜ ⵔⴰⴷ ⵜⵙⵙⵏⴷ \/\/ ⵙ ⵓⵎⴷⵢⴰ, ⵎⴽ ⵜⵓⵎⵥⴷ \"Slices\" ⴰⵎⵎ ⵜⵔⵎⵜ ⴷ ⵓⵎⵙⴳⴷⴰⵍ ⵏ \/\/ ⵙⵜⴰⵢ ⵢⴰⵏ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⴳ ⵓⵎⵏⵣⵓ. \/\/ ⵎⴽ ⵍⵍⴰⵏⵜ ⵙⵏⴰⵜ ⵏⵖ ⵓⴳⴳⴰⵔ ⵏ ⵜⵣⵣⵉⴳⵣⵉⵏ ⵙ ⵢⴰⵜ ⵜⵣⵎⵔⵜ, ⵔⴰⴷ ⵜⵙⵙⵏⵎ \/\/ format: ClassName.StrongestExtensionName.  ⴰⵖⴰⵡⴰⵙ ⵏ ⵓⵙⵎⵓⵜⵜⴳ\/\/ ⵔⴰⴷ ⵜⵙⵙⵏⴼⵍⴷ ⴰⵙⵖⵣⵣⵉⴼ ⴰⴷⴷⵓⵙ ⴷ ⵔⴰⴷ ⵜⵔⵉⵜⵔⵉⵏ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ ⴳ ⴹⴰⴽⵜ ⴰⴷ\/\/ ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵣⵉⴼ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵣⵎⵔⵜ ⵙ ⵓⴳⵣⵣⵓⵎ CAP - SM. \/\/ ⵜⵉⵔⵔⴰ ⴳ ⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵣⵉⴼ, ⴷ ⴰⴷ ⵜⴳ SM ⴰⵎⴹⴰⵏ ⵏ ⵜⵉⵔⵔⴰ ⵜⵉⵎⵥⵢⴰⵏⵉⵏ \/\/ ⵜⴰⴷⵓⵙⵉ ⵏ ⵓⵙⵙⵖⵣⵏ ⵜⴳⴰ ⵜⵜ: ⴰⴷ ⵜⴳ CAP ⵓⵟⵟⵓⵏ ⵏ ⵓⵡⵔⵉⴽ ⴰⵎⵇⵔⴰⵏ \/\/ ⵔⴰⴷ ⵜⵜⵓⵙⵎⵔⴰⵙⵏ ⵉⵙⵖⵣⵏⵏ ⵃⵎⴰ ⴰⴷ ⵜⵜⵓⵙⵙⴽⵛⵎⵏ ⵉⵙⵍⵎⴰⴷⵉⵏ ⵢⴰⴹⵏⵉⵏ ⵙ ⵓⵙⵍⵎⴷ.\/\/ ⵔⴰⴷ ⴽⴽⵉⵖ ⵉⵙⵎ ⵏ ⵜⵔⵎⵜ (ⵜⴰⵏⴳⴰⵍⵜ) ⴷ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵏ ⵉⵙⵖⵣⵏ. \/\/\/ >>> Strongest_Extension(class_name: \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n\/\/\/ \"my_class.AA\"\nfunc Strongest_Extension(class_name: String, extensions: [String]) -> String {\n","canonical_solution":"func Strongest_Extension(class_name: String, extensions: [String]) -> String {\n    var strongestExtension: String? = nil\n    var maxStrength = Int.min\n    \n    for ext in extensions {\n        let cap = ext.filter { $0.isUppercase }.count\n        let sm = ext.filter { $0.isLowercase }.count\n        let strength = cap - sm\n        \n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = ext\n        }\n    }\n    \n    if let strongestExt = strongestExtension {\n        return \"\\(class_name).\\(strongestExt)\"\n    }\n    \n    return class_name\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"},{"task_id":"HumanEval_154","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵏⴰⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵔⴰⴷ ⵜⵔⵉⵜⵓⵔⵏ ⵜⵉⴷⵜ ⵎⴽ ⵜⴳⴰ ⵜⴳⵓⵔⵉ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⵏⵖ ⴽⵔⴰ ⵏ ⵜⵙⵓⵜⵍⵜ ⵏⵏⵙ ⵢⴰⵜ ⵜⵉⵔⵔⴰ ⵏ ⵜⴳⵓⵔⵉ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ \/\/\/ >>> cycpattern_check(a: \"abcd\", b: \"abd\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"hello\", b: \"ell\")\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(a: \"whassup\", b: \"psus\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"abab\", b: \"baa\")\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(a: \"efef\", b: \"eeff\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"himenss\", b: \"simen\")\n\/\/\/ true\nfunc cycpattern_check(a: String, b: String) -> Bool {\n","canonical_solution":"func cycpattern_check(a: String, b: String) -> Bool {\n    guard !b.isEmpty else { return true }\n    let bCombined = b + b\n    for i in 0..<b.count {\n        let rotation = String(bCombined.dropFirst(i).prefix(b.count))\n        if a.contains(rotation) {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(cycpattern_check(a: \"xyzw\", b: \"xyw\") == false)\nassert(cycpattern_check(a: \"yello\", b: \"ell\") == true)\nassert(cycpattern_check(a: \"whattup\", b: \"ptut\") == false)\nassert(cycpattern_check(a: \"efef\", b: \"fee\") == true)\nassert(cycpattern_check(a: \"abab\", b: \"aabb\") == false)\nassert(cycpattern_check(a: \"winemtt\", b: \"tinem\") == true)"},{"task_id":"HumanEval_155","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⴰⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ. ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⴰⴱⵔⵔⵉⵜ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ ⴷ ⵡⵉⵏ ⵡⴰⵔ ⵉⵎⵎⵔⵡⴰⵙⵏ. \/\/\/ >>> even_odd_count(num: -12)\n\/\/\/ (1, 1)\n\/\/\/ >>> even_odd_count(num: 123)\n\/\/\/ (1, 2)\nfunc even_odd_count(num: Int) -> (Int, Int) {\n","canonical_solution":"func even_odd_count(num: Int) -> (Int, Int) {\n    var countEvens = 0\n    var countOdds = 0\n    var number = abs(num) \/\/ Handle negative numbers by taking absolute value\n\n    while number > 0 {\n        let digit = number % 10\n        if digit % 2 == 0 {\n            countEvens += 1\n        } else {\n            countOdds += 1\n        }\n        number \/= 10\n    }\n    return (countEvens, countOdds)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_odd_count(num: 7) == (0, 1))\nassert(even_odd_count(num: -78) == (1, 1))\nassert(even_odd_count(num: 3452) == (2, 2))\nassert(even_odd_count(num: 346211) == (3, 3))\nassert(even_odd_count(num: -345821) == (3, 3))\nassert(even_odd_count(num: -2) == (1, 0))\nassert(even_odd_count(num: -45347) == (2, 3))\nassert(even_odd_count(num: 0) == (1, 0))"},{"task_id":"HumanEval_156","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ: \/\/ ⵜⵉⵎⵥⴰ: 1 <= num <= 1000 \/\/ ⴷ ⵙⵙⵓⴼⵖ-ⵜ ⵙ ⵜⵉⵔⵔⴰ ⵜⵉⵎⵥⵢⴰⵏⵉⵏ. \/\/ ⴰⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ, ⵙⵙⵓⵜⵔ ⴰⵎⴹⴰⵏ ⵏⵏⵙ ⴰⵕⵓⵎⴰⵏ ⴰⵎⵎ ⵜⴰⵖⵕⴹⵜ, \/\/\/ >>> int_to_mini_roman(number: 19)\n\/\/\/ \"xix\"\n\/\/\/ >>> int_to_mini_roman(number: 152)\n\/\/\/ \"clii\"\n\/\/\/ >>> int_to_mini_roman(number: 426)\n\/\/\/ \"cdxxvi\"\nfunc int_to_mini_roman(number: Int) -> String {\n","canonical_solution":"func int_to_mini_roman(number: Int) -> String {\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    let numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    \n    var num = number\n    var result = \"\"\n    \n    for (index, value) in values.enumerated() {\n        while num >= value {\n            result += numerals[index]\n            num -= value\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"},{"task_id":"HumanEval_157","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ 90 ⵜⵉⵙⴽⴼⵍⵜ. \/\/ ⵉⴳⴰ ⵓⴽⵏⴰⵔⵉ ⵏ ⵜⵉⵖⵓⵍⵜ ⵜⴰⵣⴳⵍⵜ ⵢⴰⵏ ⵓⴽⵏⴰⵔⵉ ⴳ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴽⵏⴰⵔⵉ ⵏ ⵜⵉⵖⵓⵍⵜ ⵜⴰⵣⴳⵍⵜ ⵏⵖ \/\/ ⴷⴰ ⵙⴽⴰⵔⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵢⴰⵏ ⵓⴽⵏⵉⵡ ⴰⵎⵣⴳⵓⵏ, ⵓⵔ ⵉⴳⵉ ⵡⵉ-ⵏⵏⴰ ⵢⴰⴹⵏⵉⵏ. \/\/ ⴰⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⵢⴰⵏ ⵓⴽⵕⴰⴹ. ⵔⵡⵍ ⵜⵉⴷⵜ ⵎⴽ ⵀⴰⵏ ⴽⵕⴰⴹⵜ \/\/\/ >>> right_angle_triangle(a: 3, b: 4, c: 5)\n\/\/\/ true\n\/\/\/ >>> right_angle_triangle(a: 1, b: 2, c: 3)\n\/\/\/ false\nfunc right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n","canonical_solution":"func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n    let sides = [a, b, c].sorted()\n    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(right_angle_triangle(a: 3, b: 4, c: 5) == true)\nassert(right_angle_triangle(a: 1, b: 2, c: 3) == false)\nassert(right_angle_triangle(a: 10, b: 6, c: 8) == true)\nassert(right_angle_triangle(a: 2, b: 2, c: 2) == false)\nassert(right_angle_triangle(a: 7, b: 24, c: 25) == true)\nassert(right_angle_triangle(a: 10, b: 5, c: 7) == false)\nassert(right_angle_triangle(a: 5, b: 12, c: 13) == true)\nassert(right_angle_triangle(a: 15, b: 8, c: 17) == true)\nassert(right_angle_triangle(a: 48, b: 55, c: 73) == true)\nassert(right_angle_triangle(a: 1, b: 1, c: 1) == false)\nassert(right_angle_triangle(a: 2, b: 2, c: 10) == false)"},{"task_id":"HumanEval_158","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵙⴽⴽⵉⵍⵏ, ⵔⴰⴷ ⵢⴰⴽⴽⵉ ⵡⴰⵏⵏⴰ ⵢⵓⵛⴽⴰⵏ ⴳ ⵓⵎⵣⵡⴰⵔⵓ ⴳ ⵓⵏⵎⴰⵍⴰ ⵏ ⵓⵙⴽⴽⵉⵍ. \/\/ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⵉⵡⵏ. ⵎⴽ ⴷⴰⵔ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⵉⵡⵏ \/\/ ⴷⴰ ⵢⴰⵎⵓ ⵓⵙⵏⵙⵉ ⴳ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵔⴰⴷ ⵢⴰⴽⴽⴰ ⵜⴳⵓⵔⵉ ⵙ ⵓⵟⵟⵓⵏ ⴰⵎⵇⵔⴰⵏ \/\/ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵙⴽⴽⵉⵍⵏ. \/\/\/ >>> find_max(words: [\"name\", \"of\", \"string\"])\n\/\/\/ \"string\"\n\/\/\/ >>> find_max(words: [\"name\", \"enam\", \"game\"])\n\/\/\/ \"enam\"\n\/\/\/ >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n\/\/\/ \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n","canonical_solution":"func find_max(words: [String]) -> String {\n    func uniqueCharacterCount(in word: String) -> Int {\n        return Set(word).count\n    }\n    \n    return words.max { a, b in\n        let uniqueCountA = uniqueCharacterCount(in: a)\n        let uniqueCountB = uniqueCharacterCount(in: b)\n        \n        if uniqueCountA == uniqueCountB {\n            return a > b\n        }\n        \n        return uniqueCountA < uniqueCountB\n    } ?? \"\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"},{"task_id":"HumanEval_159","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵎⴷⵢⴰ: \/\/ ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⵉⵇⵇⵉⵎⵏ ⵏ ⵜⵔⵖⵉ, ⵔⴰⴷ ⵜⵛⵉⵎ ⴽⵓⵍⵍⵓ ⵜⵔⵖⵉ, ⵎⴰⵛⴰ ⵔⴰⴷ ⵜⵇⵇⵉⵎ ⵜⵔⵖⵉ.\/\/ ⴰⵟⵟⴰⵙ ⵏ ⵜⵔⵖⵉ ⵏⵏⴰ ⴷ ⵉⵇⵇⵉⵎⵏ ⴷⴼⴼⵉⵔ ⵏ ⵜⴷⴳⴳⵡⴰⵜ ⵏⵏⴽ ] \/\/ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ [ ⵓⵟⵟⵓⵏ ⴰⵖⵓⵍⴰⵏ ⵏ ⵜⵔⵖⵉ ⵍⵍⵉ ⵜⵙⵙⵓⵜⵎ ⴷⴼⴼⵉⵔ ⵏ ⵜⴷⴰⵍⴰ ⵏⵏⴽ, ⵎⴰⵛⴰ ⵖⵉⵍⴰⴷ, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⵙⵓⵜⵎ ⵓⴳⴳⴰⵔ ⵏ ⵉⴽⴰⵔⴰⵡⵏ ⴰⴼⴰⴷ ⴰⴷ ⵜⵙⵙⵎⵓⵔⵎ ⵜⴰⵢⵢⵉⴹⵜ ⵏ ⵡⴰⵙⵙ.\/\/ ⵀⴰⵜ ⵉⵙ ⵜⵛⵛⵉⵖ ⵜⴰⵔⵔⵢⴰⵙⵜ, ⴷ ⵜⵛⵛⵉⵖ ⴰⵟⵟⴰⵙ ⵏ ⵉⵔⵖⴰⵏ, \/\/\/ >>> eat(number: 5, need: 6, remaining: 10)\n\/\/\/ [11, 4]\n\/\/\/ >>> eat(number: 4, need: 8, remaining: 9)\n\/\/\/ [12, 1]\n\/\/\/ >>> eat(number: 1, need: 10, remaining: 10)\n\/\/\/ [11, 0]\n\/\/\/ >>> eat(number: 2, need: 11, remaining: 5)\n\/\/\/ [7, 0]\n\/\/\/ Variables:\n\/\/\/ @number : integer\n\/\/\/ the number of carrots that you have eaten.\n\/\/\/ @need : integer\n\/\/\/ the number of carrots that you need to eat.\n\/\/\/ @remaining : integer\n\/\/\/ the number of remaining carrots thet exist in stock\n\/\/\/ Constrain:\n\/\/\/ * 0 <= number <= 1000\n\/\/\/ * 0 <= need <= 1000\n\/\/\/ * 0 <= remaining <= 1000\n\/\/\/ Have fun :)\nfunc eat(number: Int, need: Int, remaining: Int) -> [Int] {\n","canonical_solution":"func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let totalNeeded = number + need\n    let totalEaten = min(totalNeeded, number + remaining)\n    let carrotsLeft = max(0, remaining - (totalEaten - number))\n    return [totalEaten, carrotsLeft]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"},{"task_id":"HumanEval_160","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⴰⵙⵔⵔⵓⵙ ⵏ ⵓⵎⵙⴽⴰⵔ ⵖⵓⵔⵙ ⵢⴰⵏ ⵓⵎⵙⴽⴰⵔ, ⴷ ⵓⵙⵔⵔⵓⵙ ⵏ ⵓⵎⵙⴽⴰⵔ ⵖⵓⵔⵙ ⵙⵉⵏ ⵉⵎⵙⴽⴰⵔⵏ. \/\/ ⵓⴱⵢⵔⴰⵏⴷ ⵉⴳⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵔⵉⵏ. \/\/ ⵜⵉⵖⵣⵉ ⵏ ⵓⵙⵏⵙⵉ ⵏ ⵓⵎⵙⵡⵓⵔⵉ ⵜⴳⴰ ⵜⵜ ⵜⵉⵖⵣⵉ ⵏ ⵓⵙⵏⵙⵉ ⵏ ⵓⵙⵎⵙⴽⵍ ⵙ ⵢⴰⵏ. \/\/ ⴰⵖⴰⵔⴰⵙ: \/\/ => ⵜⴰⵢⴰⴼⵓⵜ = 9 \/\/ ⵜⴰⵢⴰⴼⵓⵜ = 2 + 3 * 4 - 5 \/\/ ⴰⵙⵔⵔⵓⵙ = [2, 3, 4, 5] \/\/ ⵓⵎⵙⴽⴰⵔ['+', '*', '-'] \/\/ ⴰⵎⴷⵢⴰ: \/\/ ⴰⵙⵎⵓⵜⵜⴳ (**) \/\/ ⴰⴱⵟⵟⵓ ⵏ ⵓⵙⵡⵉⵔ ( \/\/) \/\/ ⴰⵙⴼⵓⴽⵍⵓ (*) \/\/ ⴰⵙⵏⵓⵎⵔ ( - ) \/\/ ⴰⵙⵎⵓⵏ (+) \/\/ ⵜⵉⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ ⵜⵉⵙⵍⴽⵉⵎⵉⵏ: \/\/ ⴰⵙⵏⵎⴰⵍⴰ ⴷ ⵓⵙⵏⴼⵍ ⵏ ⵓⵙⵜⴰⵍ ⵏ ⵓⵙⵏⵎⴰⵍⴰ ⴰⴷ. \/\/ ⴰⵙⵔⴷⴰⵙ ⵡⵉⵙⵙ ⵙⵉⵏ ⵉⴳⴰ ⴰⵙⵔⴷⴰⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙⵎⵔⵙⵏ ⵉⵙⵔⴷⴰⵙⵏ ⴰⴷ ⵙⵉⵏ ⴰⴼⴰⴷ ⴰⴷ ⵙⵙⴽⵔⵏ ⵜⴰⵍⵖⴰ ⵏ ⵍⵊⵉⴱⵔ \/\/ ⵏⵜⵜⴰⴼ ⵉⵙⵡⵓⵔⵉⵏ ⵏ ⵙⵉⵏ ⵉⵎⵙⴽⴰⵔⵏ ⵏ ⵉⵎⵙⴷⴷⵉ ⴷ ⵓⵎⵙⴽⴰⵔ. ⴰⵎⵙⴷⴷⵉ ⴰⵎⵣⵡⴰⵔⵓ ⴷⴰⵔ ⵜⵉⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ ⵜⵉⴷⵙⵍⴰⵏⵉⵏ, ⴷ func do_algebra(operator: [String], operand: [Int]) -> Int {\n","canonical_solution":"func do_algebra(operator: [String], operand: [Int]) -> Int {\n    var result = operand[0]\n    let precedence: [String: Int] = [\"+\": 1, \"-\": 1, \"*\": 2, \"\/\/\": 2, \"**\": 3]\n    \n    var opStack: [String] = []\n    var numStack: [Int] = [result]\n    \n    func applyOperator(_ op: String, _ b: Int, _ a: Int) -> Int {\n        switch op {\n        case \"+\":\n            return a + b\n        case \"-\":\n            return a - b\n        case \"*\":\n            return a * b\n        case \"\/\/\":\n            return a \/ b\n        case \"**\":\n            return Int(pow(Double(a), Double(b)))\n        default:\n            fatalError(\"Unsupported operator: \\(op)\")\n        }\n    }\n    \n    for i in 0..<operator.count {\n        let currentOp = `operator`[i]\n        let currentNum = operand[i + 1]\n        \n        while let lastOp = opStack.last, precedence[lastOp]! >= precedence[currentOp] {\n            opStack.removeLast()\n            let b = numStack.removeLast()\n            let a = numStack.removeLast()\n            numStack.append(applyOperator(lastOp, b, a))\n        }\n        \n        opStack.append(currentOp)\n        numStack.append(currentNum)\n    }\n    \n    while let lastOp = opStack.popLast() {\n        let b = numStack.removeLast()\n        let a = numStack.removeLast()\n        numStack.append(applyOperator(lastOp, b, a))\n    }\n    \n    return numStack.first!\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(do_algebra(operator: [\"**\", \"*\", \"+\"], operand: [2, 3, 4, 5]) == 37)\nassert(do_algebra(operator: [\"+\", \"*\", \"-\"], operand: [2, 3, 4, 5]) == 9)\nassert(do_algebra(operator: [\"\/\/\", \"*\"], operand: [7, 3, 4]) == 8)"},{"task_id":"HumanEval_161","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵉⵎⴷⵢⴰⵜⵏ \/\/ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ. \/\/ ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴳ ⵜⵊⵎⵉⵍⵜ ⴽⵔⴰ ⵏ ⵉⵙⴽⴽⵉⵍⵏ, ⵙⵙⵓⵜⵔ ⵜⵊⵎⵉⵍⵜ. \/\/ ⵎⴽ ⵓⵔ ⵜⵍⵍⴰ, ⵃⴹⵓ ⵜⵜ ⴰⵎⴽ ⵉⵍⵍⴰ. \/\/ ⵎⴽ ⵜⴳⴰ s[i] ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⵙⵙⵓⵜⵍ ⵜⴰⵡⴰⵍⵜ ⵏⵏⵙ ⵙⴳ ⴷⴷⴰⵡ ⴰⵔ ⴰⴼⵍⵍⴰ ⵏⵖⴷ ⵙ ⵓⵎⵣⴰⵔⴰⵢ, \/\/ ⵜⵜⵓⴼⴽⴰ ⵜ ⵢⴰⵜ ⵜⵓⵙⴷⵉⴷⵜ s. \/\/\/ >>> solve(s: \"1234\")\n\/\/\/ \"4321\"\n\/\/\/ >>> solve(s: \"ab\")\n\/\/\/ \"AB\"\n\/\/\/ >>> solve(s: \"#a@C\")\n\/\/\/ \"#A@c\"\nfunc solve(s: String) -> String {\n","canonical_solution":"func solve(s: String) -> String {\n    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {\n        return String(s.reversed())\n    }\n    \n    var result = \"\"\n    for char in s {\n        if char.isLetter {\n            if char.isLowercase {\n                result.append(char.uppercased())\n            } else {\n                result.append(char.lowercased())\n            }\n        } else {\n            result.append(char)\n        }\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"},{"task_id":"HumanEval_162","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵎⴽ 'text' ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵉⵣⴳⵍⵏ, ⴰⵔ ⵉⵜⵜⵔⴰⵔ nil. \/\/ ⵙ ⵓⴽⵛⵛⵓⵎ ⵏ ⵓⴹⵕⵉⵚ, ⵙⵙⵓⴼⵖ ⵜⴰⵡⵓⵔⵉ ⵏ md5 hash. \/\/\/ >>> string_to_md5(text: \"Hello world\")\n\/\/\/ \"3e25960a79dbc69b674cd4ec67a72c62\"\nfunc string_to_md5(text: String) -> String? {\n","canonical_solution":"import Foundation\nimport CommonCrypto\n\nfunc string_to_md5(text: String) -> String? {\n    guard !text.isEmpty else { return nil }\n    \n    let length = Int(CC_MD5_DIGEST_LENGTH)\n    let messageData = text.data(using: .utf8)!\n    var digestData = Data(count: length)\n    \n    _ = digestData.withUnsafeMutableBytes { digestBytes in\n        messageData.withUnsafeBytes { messageBytes in\n            CC_MD5(messageBytes.baseAddress, CC_LONG(messageData.count), digestBytes.bindMemory(to: UInt8.self).baseAddress)\n        }\n    }\n    \n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_to_md5(text: \"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\")\nassert(string_to_md5(text: \"\") == nil)\nassert(string_to_md5(text: \"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\")\nassert(string_to_md5(text: \"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\")"},{"task_id":"HumanEval_163","nl":"tzm_Tfng","pl":"swift","prompt":"\n\/\/ ⵙ ⵓⵎⴷⵢⴰ: \/\/ ⴷ b, ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵇⵔⴰⵏ. \/\/ ⵙ ⵓⵙⴽⴽⵉⵔ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ a ⴷ b, ⵙⵙⵓⴼⵖ ⵜⵉⵟⵟⵓⵏⵉⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ ⴳⵔ a \/\/\/ >>> generate_integers(a: 2, b: 8)\n\/\/\/ [2, 4, 6, 8]\n\/\/\/ >>> generate_integers(a: 8, b: 2)\n\/\/\/ [2, 4, 6, 8]\n\/\/\/ >>> generate_integers(a: 10, b: 14)\n\/\/\/ [] as [Int]\nfunc generate_integers(a: Int, b: Int) -> [Int] {\n","canonical_solution":"func generate_integers(a: Int, b: Int) -> [Int] {\n    let lower = min(a, b)\n    let upper = max(a, b)\n    var result = [Int]()\n    \n    for number in lower...upper {\n        if number % 2 == 0 {\n            result.append(number)\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(generate_integers(a: 2, b: 10) == [2, 4, 6, 8])\nassert(generate_integers(a: 10, b: 2) == [2, 4, 6, 8])\nassert(generate_integers(a: 132, b: 2) == [2, 4, 6, 8])\nassert(generate_integers(a: 17, b: 89) == [] as [Int])"}]