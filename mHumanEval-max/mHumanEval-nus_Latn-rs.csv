task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,nus_Latn,rs,"/// ca ŋun ɛ pek mi̱ ca ŋun./// Kiɛ guic mi̱ rɛy ba̱ktɔr nämbäri̱, ɛni̱ nämbäri̱ rɛw tin thia̱k kä rɔ̱ ɛ läny kɛn /// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)
/// false
/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
/// true
fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {
","fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {
    for i in 0..numbers.len() {
        for j in (i + 1)..numbers.len() {
            if (numbers[i] - numbers[j]).abs() < threshold {
                return true;
            }
        }
    }
    false
}","}

fn main() {
    let candidate = has_close_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);
}
"
HumanEval_1,nus_Latn,rs,"/// /Thiɛlɛ mi̱ ca mat rɛy inpuɔɔth string.///Kua̱a̱th ti̱ gööl la kɛn rɔ̱ laa pa̱a̱rkɛ (kä bi̱kɛ rɔ̱ la̱th gua̱a̱th kɛl) kä /ci̱kɛ rɔ̱ laa mat kɛɛl.///ca̱a̱p tin ca mat kä ca̱a̱p ti̱ti̱ da̱a̱k kä bi̱ kɛn kɛ loc ɛ la ti̱ ca mat kä bi̱ kɛ cu loc ɛ la ti̱ ca mat./// Input kä pa̱ŋciin ɛmɛ ɛ la̱t mi̱ tekɛ bun ti̱ ŋuan ti̱ ca mat kɛ parenthesethni̱./// >>> separate_paren_groups(String::from(""( ) (( )) (( )( ))""))
/// vec![String::from(""()""), String::from(""(())""), String::from(""(()())"")]
fn separate_paren_groups(paren_string: String) -> Vec<String> {
","fn separate_paren_groups(paren_string: String) -> Vec<String> {
    let mut groups = Vec::new();
    let mut current_group = String::new();
    let mut open_count = 0;

    for char in paren_string.chars() {
        if char == '(' {
            open_count += 1;
            current_group.push(char);
        } else if char == ')' {
            open_count -= 1;
            current_group.push(char);
        }

        if open_count == 0 && !current_group.is_empty() {
            groups.push(current_group.clone());
            current_group.clear();
        }
    }

    groups
}","}

fn main() {
    let candidate = separate_paren_groups;
    assert_eq!(candidate(String::from(""(()()) ((())) () ((())()())"")), vec![String::from(""(()())""), String::from(""((()))""), String::from(""()""), String::from(""((())()())"")]);
    assert_eq!(candidate(String::from(""() (()) ((())) (((())))"")), vec![String::from(""()""), String::from(""(())""), String::from(""((()))""), String::from(""(((())))"")]);
    assert_eq!(candidate(String::from(""(()(())((())))"")), vec![String::from(""(()(())((())))"")]);
    assert_eq!(candidate(String::from(""( ) (( )) (( )( ))"")), vec![String::from(""()""), String::from(""(())""), String::from(""(()())"")]);
}
"
HumanEval_2,nus_Latn,rs,"/// Läthni̱ decimal part duŋ nämbärä. /// (cu tha̱a̱ŋdɛ min ci̱ duɔth ɛ mi̱ tɔt ni̱ ciaaŋ mi̱ kuiy ni̱ jɛn kä 1)./// kɛnɛ intejeri̱ tin te gua̱thdiɛn (in la intejeri̱ tin di̱t kä kuiyni̱kɛn kä nämbäri̱ tin ca ŋun) kɛnɛ deci̱malni̱ /// Mi̱ ca ŋun ɛ la mi̱ tekɛ po̱jitibol pi̱löthömin, jɛn ba da̱a̱k kä /// >>> truncate_number(3.5)
/// 0.5
fn truncate_number(number: f64) -> f64 {
","fn truncate_number(number: f64) -> f64 {
    number - number.floor()
}

fn main() {
    println!(""{}"", truncate_number(3.5)); // 0.5
}","}

fn main() {
    let candidate = truncate_number;
    assert_eq!(candidate(3.5), 0.5);
    assert_eq!(candidate(1.25), 0.25);
    assert_eq!(candidate(123.0), 0.0);
}
"
HumanEval_3,nus_Latn,rs,"///rɛy ɛmɔ bi̱ la̱t ɛmɔ dhil loc ni̱ thuɔ̱k. mi̱ /ci̱e̱ jɛn bɛ loc ni̱ kac./// zero balance. La̱tdu ɛ ɣöö bi̱ ji̱ek mi̱ ci̱ pek yio̱o̱ni̱ rɛy account (kuɔ̱l) bɛ pɛn piny dhɛrö, kɛnɛ ///Ca ji̱ moc kɛ duɔ̱ɔ̱r mi̱ bi̱ ji̱ yi̱o̱w thi̱n kɛnɛ ɣöö bi̱ ji̱ yi̱o̱w woc kɛ kɔɔn bank mi̱ bi̱ tuɔk kɛ /// >>> below_zero(vec![1, 2, 3])
/// false
/// >>> below_zero(vec![1, 2, -4, 5])
/// true
fn below_zero(operations: Vec<isize>) -> bool {
","fn below_zero(operations: Vec<isize>) -> bool {
    let mut balance = 0;
    for operation in operations {
        balance += operation;
        if balance < 0 {
            return true;
        }
    }
    false
}

fn main() {
    println!(""{}"", below_zero(vec![1, 2, 3])); // false
    println!(""{}"", below_zero(vec![1, 2, -4, 5])); // true
    println!(""{}"", below_zero(vec![1, -1, -1, 2])); // true
}","}

fn main() {
    let candidate = below_zero;
    assert_eq!(candidate(Vec::<isize>::new()), false);
    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);
    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);
    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);
}
"
HumanEval_4,nus_Latn,rs,"/// MAD = average  x - x_mean /// ɛlɛmɛni̱ kɛnɛ däär (mi̱e̱e̱n rɛy kä nɛmɛ): /// Mean Absolute Deviation ɛ jɛn in te dääk kamdiɛn /// räthdɛ kä däär dataɛtni̱ ti̱ti̱./// Kɛ kui̱ kä pektɛri̱ in ca ŋun kä nämbäri̱ tin ca la̱th, ba mi̱dian abthölut debi̱ecin lɛ läät./// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])
/// 1.0
fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {
","fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {
    let n = numbers.len() as f64;
    if n == 0.0 {
        return 0.0;
    }

    let mean: f64 = numbers.iter().sum::<f64>() / n;
    let mad: f64 = numbers.iter().map(|&x| (x - mean).abs()).sum::<f64>() / n;
    
    mad
}

fn main() {
    let numbers = vec![1.0, 2.0, 3.0, 4.0];
    println!(""{}"", mean_absolute_deviation(numbers)); // Output: 1.0
}","}

fn main() {
    let candidate = mean_absolute_deviation;
    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);
}
"
HumanEval_5,nus_Latn,rs,"/// Ji̱äk nämbär 'dëlëmëtɛr' kamni̱ rɛw tin guɔ̱rkɛ rɔ̱ kä inpuut bɛktɔr ∀numberni̱' /// >>> intersperse(vec![], 4)
/// Vec::<isize>::new()
/// >>> intersperse(vec![1, 2, 3], 4)
/// vec![1, 4, 2, 4, 3]
fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {
","fn intersperse(numbers: Vec<isize>, delimiter: isize) -> Vec<isize> {
    if numbers.is_empty() {
        return Vec::new();
    }
    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);
    for (i, &num) in numbers.iter().enumerate() {
        result.push(num);
        if i != numbers.len() - 1 {
            result.push(delimiter);
        }
    }
    result
}

fn main() {
    println!(""{:?}"", intersperse(vec![], 4)); // Output: Vec::<isize>::new()
    println!(""{:?}"", intersperse(vec![1, 2, 3], 4)); // Output: vec![1, 4, 2, 4, 3]
}","}

fn main() {
    let candidate = intersperse;
    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);
    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);
}
"
HumanEval_6,nus_Latn,rs,"/// C.d. (() (()) tekɛ pek mi̱ bäär kä rɛw kä bi̱kɛ rɔ̱ mat gua̱th in bi̱kɛ te thi̱n kä ((())) tekɛ diɔ̱k. /// Kɛ kui̱ bunä kɛl, bɛ kulɛ la̱t ɛ la mi̱ te piny ɛlɔ̱ŋ kä bi̱kɛ rɔ̱ mat rɛy parɛthɛthi̱thni̱./// Input kä pa̱ŋciin ɛmɛ ɛ la̱t mi̱ cuŋ ɛ la ti̱ ŋuan ti̱ ca la̱t kɛ kui̱ bunä mi̱ ca da̱a̱k ɛ kam kamni̱kiɛn./// >>> parse_nested_parens(String::from(""(()()) ((())) () ((())()())""))
/// vec![2, 3, 1, 3]
fn parse_nested_parens(paren_string: String) -> Vec<isize> {
","fn parse_nested_parens(paren_string: String) -> Vec<isize> {
    paren_string.split_whitespace().map(|group| {
        let mut max_depth = 0;
        let mut current_depth = 0;
        for char in group.chars() {
            match char {
                '(' => {
                    current_depth += 1;
                    if current_depth > max_depth {
                        max_depth = current_depth;
                    }
                },
                ')' => {
                    current_depth -= 1;
                },
                _ => {}
            }
        }
        max_depth
    }).collect()
}

fn main() {
    let result = parse_nested_parens(String::from(""(()()) ((())) () ((())()())""));
    println!(""{:?}"", result); // Output: [2, 3, 1, 3]
}","}

fn main() {
    let candidate = parse_nested_parens;
    assert_eq!(candidate(String::from(""(()()) ((())) () ((())()())"")), vec![2, 3, 1, 3]);
    assert_eq!(candidate(String::from(""() (()) ((())) (((())))"")), vec![1, 2, 3, 4]);
    assert_eq!(candidate(String::from(""(()(())((())))"")), vec![4]);
}
"
HumanEval_7,nus_Latn,rs,"/// Filter input vector of strings only for ones that contain given substring   ɛ la mi̱ la̱thkɛ rɛy kä min ca ŋun ɛ la thäp-thäp/// >>> filter_by_substring(vec![], String::from(""a""))
/// Vec::<String>::new()
/// >>> filter_by_substring(vec![String::from(""abc""), String::from(""bacd""), String::from(""cde""), String::from(""array"")], String::from(""a""))
/// vec![String::from(""abc""), String::from(""bacd""), String::from(""array"")]
fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {
","fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {
    strings.into_iter().filter(|s| s.contains(&substring)).collect()
}","}

fn main() {
    let candidate = filter_by_substring;
    assert_eq!(candidate(Vec::<String>::new(), String::from(""john"")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""xxx""), String::from(""asd""), String::from(""xxy""), String::from(""john doe""), String::from(""xxxAAA""), String::from(""xxx"")], String::from(""xxx"")), vec![String::from(""xxx""), String::from(""xxxAAA""), String::from(""xxx"")]);
    assert_eq!(candidate(vec![String::from(""xxx""), String::from(""asd""), String::from(""aaaxxy""), String::from(""john doe""), String::from(""xxxAAA""), String::from(""xxx"")], String::from(""xx"")), vec![String::from(""xxx""), String::from(""aaaxxy""), String::from(""xxxAAA""), String::from(""xxx"")]);
    assert_eq!(candidate(vec![String::from(""grunt""), String::from(""trumpet""), String::from(""prune""), String::from(""gruesome"")], String::from(""run"")), vec![String::from(""grunt""), String::from(""prune"")]);
}
"
HumanEval_8,nus_Latn,rs,"/// Empty sum bɛ yi̱k pa̱a̱r kɛ 0 kɛnɛ ɣöö bɛ yi̱k pa̱a̱r kɛ dɛ bɛ pa̱a̱r kɛ 1./// Kɛ kui̱ kä intɛgeri̱ diaal tin ca ŋun, locni̱ tuple mi̱ tekɛ mat kɛnɛ la̱tdiɛn kɛn intɛgeri̱ diaal rɛy intɛgeri̱./// >>> sum_product(vec![])
/// (0, 1)
/// >>> sum_product(vec![1, 2, 3, 4])
/// (10, 24)
fn sum_product(numbers: Vec<isize>) -> (isize, isize) {
","fn sum_product(numbers: Vec<isize>) -> (isize, isize) {
    let sum = numbers.iter().sum();
    let product = numbers.iter().fold(1, |acc, &x| acc * x);
    (sum, product)
}

fn main() {
    println!(""{:?}"", sum_product(vec![])); // (0, 1)
    println!(""{:?}"", sum_product(vec![1, 2, 3, 4])); // (10, 24)
}","}

fn main() {
    let candidate = sum_product;
    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));
    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));
    assert_eq!(candidate(vec![100, 0]), (100, 0));
    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));
    assert_eq!(candidate(vec![10]), (10, 10));
}
"
HumanEval_9,nus_Latn,rs,"/// rɛy gua̱th in ci̱ rɔ lot thi̱n. /// Kä intɛrjiɛri̱ ti̱ ca ŋun, ka̱mkɛ intɛrjiɛr mi̱ di̱i̱t kä ca jiek ɛ la intɛrjiɛr mi̱ di̱i̱t mi̱ ca jiek ɛ wä ni̱ kä mi̱ ca ŋun./// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])
/// vec![1, 2, 3, 3, 3, 4, 4]
fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {
","fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {
    let mut result = Vec::new();
    let mut current_max = isize::MIN;
    for &num in &numbers {
        if num > current_max {
            current_max = num;
        }
        result.push(current_max);
    }
    result
}","}

fn main() {
    let candidate = rolling_max;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);
    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);
}
"
HumanEval_10,nus_Latn,rs,"/// - Ji̱äkni̱ kä guut kä min ca la̱t ɛ la mi̱ ci̱ rɔ ri̱i̱t kä min ca la̱t ɛ la mi̱ ci̱ rɔ ri̱i̱t kä min nhiam kä palindromik./// - Ji̱n bi postfix in bär ni̱ jɛn kä thärk in ca ŋun kä bi̱ palindrɔm. /// Alɣo̱ri̱thi̱m cärɛ ɛ mi̱ thi̱a̱k: /// Ji̱n bi palindrɔm in tɔt jek mi̱ tokɛ kɛ mi̱ ca ŋun ɛ la i̱thti̱ri̱d./// >>> make_palindrome(String::from(""""))
/// String::from("""")
/// >>> make_palindrome(String::from(""cat""))
/// String::from(""catac"")
/// >>> make_palindrome(String::from(""cata""))
/// String::from(""catac"")
fn make_palindrome(string: String) -> String {
","fn make_palindrome(string: String) -> String {
    fn is_palindrome(s: &str) -> bool {
        s.chars().eq(s.chars().rev())
    }

    if string.is_empty() || is_palindrome(&string) {
        return string;
    }

    for i in (0..string.len()).rev() {
        if is_palindrome(&string[i..]) {
            let prefix = &string[..i];
            let reversed_prefix: String = prefix.chars().rev().collect();
            return string + &reversed_prefix;
        }
    }

    string
}

fn main() {
    println!(""{:?}"", make_palindrome(String::from(""""))); // String::from("""")
    println!(""{:?}"", make_palindrome(String::from(""cat""))); // String::from(""catac"")
    println!(""{:?}"", make_palindrome(String::from(""cata""))); // String::from(""catac"")
}","}

fn main() {
    let candidate = make_palindrome;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""x"")), String::from(""x""));
    assert_eq!(candidate(String::from(""xyz"")), String::from(""xyzyx""));
    assert_eq!(candidate(String::from(""xyx"")), String::from(""xyx""));
    assert_eq!(candidate(String::from(""jerry"")), String::from(""jerryrrej""));
}
"
HumanEval_11,nus_Latn,rs,"/// Lätni̱ bainäri̱ XOR kä tin ca la̱th kä bi̱ ben raar ɛ la ti̱ ca gɔ̱r ɛ la ti̱ ŋuan./// Input ɛ rɛw ti̱ la̱tkɛ ɛ a kɛnɛ b tin tekɛ 1 kɛnɛ 0 kärɔ̱. /// >>> string_xor(String::from(""010""), String::from(""110""))
/// String::from(""100"")
fn string_xor(a: String, b: String) -> String {
","fn string_xor(a: String, b: String) -> String {
    a.chars()
     .zip(b.chars())
     .map(|(char_a, char_b)| if char_a == char_b { '0' } else { '1' })
     .collect()
}","}

fn main() {
    let candidate = string_xor;
    assert_eq!(candidate(String::from(""111000""), String::from(""101010"")), String::from(""010010""));
    assert_eq!(candidate(String::from(""1""), String::from(""1"")), String::from(""0""));
    assert_eq!(candidate(String::from(""0101""), String::from(""0000"")), String::from(""0101""));
}
"
HumanEval_12,nus_Latn,rs,"///thɛrndni̱ ti̱ päär bäär. /Ci̱kɛ bi̱ loc mi̱ ci̱ inpuut bɛktɔr te baaŋ./// Rɛy kä bɛktɔr duŋ thärkdɛ, locni̱ mi̱ bäär. Lätni̱ min nhiamdiɛn mi̱ ci̱kɛ ŋuan./// >>> longest(vec![])
/// None
/// >>> longest(vec![String::from(""a""), String::from(""b""), String::from(""c"")])
/// Some(String::from(""a""))
/// >>> longest(vec![String::from(""a""), String::from(""bb""), String::from(""ccc"")])
/// Some(String::from(""ccc""))
fn longest(strings: Vec<String>) -> Option<String> {
","fn longest(strings: Vec<String>) -> Option<String> {
    strings.into_iter().max_by_key(|s| s.len())
}","}

fn main() {
    let candidate = longest;
    assert_eq!(candidate(Vec::<String>::new()), None);
    assert_eq!(candidate(vec![String::from(""x""), String::from(""y""), String::from(""z"")]), Some(String::from(""x"")));
    assert_eq!(candidate(vec![String::from(""x""), String::from(""yyy""), String::from(""zzzz""), String::from(""www""), String::from(""kkkk""), String::from(""abc"")]), Some(String::from(""zzzz"")));
}
"
HumanEval_13,nus_Latn,rs,"/// Lätdɛ ɛ la min di̱tni̱ jɛn kä dääkdiɛn kä intejeri̱ rɛw a kɛnɛ b /// >>> greatest_common_divisor(3, 5)
/// 1
/// >>> greatest_common_divisor(25, 15)
/// 5
fn greatest_common_divisor(a: isize, b: isize) -> isize {
","fn greatest_common_divisor(mut a: isize, mut b: isize) -> isize {
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a
}","}

fn main() {
    let candidate = greatest_common_divisor;
    assert_eq!(candidate(3, 7), 1);
    assert_eq!(candidate(10, 15), 5);
    assert_eq!(candidate(49, 14), 7);
    assert_eq!(candidate(144, 60), 12);
}
"
HumanEval_14,nus_Latn,rs,"/// Lɔ̱a̱rkɛ pektɔr in te nhiamdɛ kä kɛn diaal ɛ tokɛ kä min ciɛk ɛ wä kä min bäär kä inpuɔɔ thi̱rɛnd /// >>> all_prefixes(String::from(""abc""))
/// vec![String::from(""a""), String::from(""ab""), String::from(""abc"")]
fn all_prefixes(string: String) -> Vec<String> {
","fn all_prefixes(string: String) -> Vec<String> {
    let mut prefixes = Vec::new();
    for i in 1..=string.len() {
        prefixes.push(string[..i].to_string());
    }
    prefixes
}

// Example usage
fn main() {
    let prefixes = all_prefixes(String::from(""abc""));
    println!(""{:?}"", prefixes);
}","}

fn main() {
    let candidate = all_prefixes;
    assert_eq!(candidate(String::from("""")), Vec::<String>::new());
    assert_eq!(candidate(String::from(""asdfgh"")), vec![String::from(""a""), String::from(""as""), String::from(""asd""), String::from(""asdf""), String::from(""asdfg""), String::from(""asdfgh"")]);
    assert_eq!(candidate(String::from(""WWW"")), vec![String::from(""W""), String::from(""WW""), String::from(""WWW"")]);
}
"
HumanEval_15,nus_Latn,rs,"/// Lɔ̱a̱kɛ ni̱ string mi̱ tekɛ nämbäri̱ ti̱ ca gɛɛr ɛ wä kä 0 ɛ wä kä n amääni̱ kɛndial. /// >>> string_sequence(0)
/// String::from(""0"")
/// >>> string_sequence(5)
/// String::from(""0 1 2 3 4 5"")
fn string_sequence(n: isize) -> String {
","fn string_sequence(n: isize) -> String {
    (0..=n).map(|num| num.to_string()).collect::<Vec<String>>().join("" "")
}","}

fn main() {
    let candidate = string_sequence;
    assert_eq!(candidate(0), String::from(""0""));
    assert_eq!(candidate(3), String::from(""0 1 2 3""));
    assert_eq!(candidate(10), String::from(""0 1 2 3 4 5 6 7 8 9 10""));
}
"
HumanEval_16,nus_Latn,rs,"/// Mi̱ ca thärkdɛ ŋun, görɛ jɛ i̱ ɛ pek in di̱tni̱jɛn kä bi̱kɛ te thi̱n (ɛ /ci̱kɛ bi̱ te gua̱a̱th kɛl)/// >>> count_distinct_characters(String::from(""xyzXYZ""))
/// 3
/// >>> count_distinct_characters(String::from(""Jerry""))
/// 4
fn count_distinct_characters(string: String) -> isize {
","use std::collections::HashSet;

fn count_distinct_characters(string: String) -> isize {
    let lowercase_string = string.to_lowercase();
    let distinct_chars: HashSet<char> = lowercase_string.chars().collect();
    distinct_chars.len() as isize
}","}

fn main() {
    let candidate = count_distinct_characters;
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""abcde"")), 5);
    assert_eq!(candidate(String::from(""abcdecadeCADE"")), 5);
    assert_eq!(candidate(String::from(""aaaaAAAAaaaa"")), 1);
    assert_eq!(candidate(String::from(""Jerry jERRY JeRRRY"")), 5);
}
"
HumanEval_17,nus_Latn,rs,"///'.Nɛ̈ɛ̈n' - quater note, bɛ wɔ̱ kɛ gua̱a̱th mi̱ tɔt ///'o dakɛ' - tha̱a̱ŋ no̱o̱ŋni̱, la duɔthkɛ ni̱ kä rɛw /// 'o' - mi̱ te thi̱n kɛɛliw, bɛ ŋot kɛ mi̱ cɛ ŋuaan ti̱ ci̱ duäc /// Nɛmɛ ɛ jɛn ruac ëë wal:///ci̱kɛ jɔak. /// La̱tdu ɛ ɣöö bi̱ kɛ kuɛn kä bi̱ kɛ wɔ̱ liny kɛ pek in ci̱kɛ be̱n kɛ kɛl./// Input kä pa̱ŋciin ɛmɛ ɛ thi̱ŋ mi̱ cuŋ kɛ kui̱ no̱o̱ŋni̱ kɛ ca̱a̱p ASCII ti̱ rɛlrɔ̱./// >>> parse_music(String::from(""o o| .| o| o| .| .| .| .| o o""))
/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
fn parse_music(music_string: String) -> Vec<isize> {
","fn parse_music(music_string: String) -> Vec<isize> {
    let mut result = Vec::new();
    let notes: Vec<&str> = music_string.split_whitespace().collect();

    for note in notes {
        match note {
            ""o"" => result.push(4),
            ""o|"" => result.push(2),
            "".|"" => result.push(1),
            _ => (),
        }
    }

    result
}

fn main() {
    let music_string = String::from(""o o| .| o| o| .| .| .| .| o o"");
    let beats = parse_music(music_string);
    println!(""{:?}"", beats); // Outputs: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
}","}

fn main() {
    let candidate = parse_music;
    assert_eq!(candidate(String::from("""")), Vec::<isize>::new());
    assert_eq!(candidate(String::from(""o o o o"")), vec![4, 4, 4, 4]);
    assert_eq!(candidate(String::from("".| .| .| .|"")), vec![1, 1, 1, 1]);
    assert_eq!(candidate(String::from(""o| o| .| .| o o o o"")), vec![2, 2, 1, 1, 4, 4, 4, 4]);
    assert_eq!(candidate(String::from(""o| .| o| .| o o| o o|"")), vec![2, 1, 2, 1, 4, 2, 4, 2]);
}
"
HumanEval_18,nus_Latn,rs,"/// Ji̱n biɛ jek i̱ ɛ pek in di̱i̱t i̱di̱ ɛn thub-thɛrŋ min ca ŋun kä thärk in nhiam. Kuɛn tin ci̱ rɔ̱ mat gua̱th kɛl. /// >>> how_many_times(String::from(""""), String::from(""a""))
/// 0
/// >>> how_many_times(String::from(""aaa""), String::from(""a""))
/// 3
/// >>> how_many_times(String::from(""aaaa""), String::from(""aa""))
/// 3
fn how_many_times(string: String, substring: String) -> isize {
","fn how_many_times(string: String, substring: String) -> isize {
    if substring.is_empty() || string.is_empty() {
        return 0;
    }

    let mut count = 0;
    let mut position = 0;

    while let Some(pos) = string[position..].find(&substring) {
        count += 1;
        position += pos + 1; // Move to the start of the next potential substring
    }

    count
}

fn main() {
    println!(""{}"", how_many_times(String::from(""""), String::from(""a""))); // 0
    println!(""{}"", how_many_times(String::from(""aaa""), String::from(""a""))); // 3
    println!(""{}"", how_many_times(String::from(""aaaa""), String::from(""aa""))); // 3
}","}

fn main() {
    let candidate = how_many_times;
    assert_eq!(candidate(String::from(""""), String::from(""x"")), 0);
    assert_eq!(candidate(String::from(""xyxyxyx""), String::from(""x"")), 4);
    assert_eq!(candidate(String::from(""cacacacac""), String::from(""cac"")), 4);
    assert_eq!(candidate(String::from(""john doe""), String::from(""john"")), 1);
}
"
HumanEval_19,nus_Latn,rs,"/// Lätdɛ jɔk kä nämbäri̱ ti̱ ca riali̱kä kä tin tɔt ɛ wä kä tin di̱t ///Kä tin de kuany ɛ kɛn 'dhɛrö', 'kɛl', ' rɛw', 'diɔ̱k', 'ŋuaan', 'li̱e̱c', 'dath', ' bärɔw', 'bärɔw' kɛnɛ 'ŋuɔ̱ɔ̱k'. /// Input ɛ mi̱ la thi̱rpëth-mi̱ ca ŋun ɛ nämbäri̱ tin ba cu dääk kä 'dhɛrö' ɛ wä kä 'duec'. /// >>> sort_numbers(String::from(""three one five""))
/// String::from(""one three five"")
fn sort_numbers(numbers: String) -> String {
","fn sort_numbers(numbers: String) -> String {
    let word_to_number = |word: &str| -> u32 {
        match word {
            ""zero"" => 0,
            ""one"" => 1,
            ""two"" => 2,
            ""three"" => 3,
            ""four"" => 4,
            ""five"" => 5,
            ""six"" => 6,
            ""seven"" => 7,
            ""eight"" => 8,
            ""nine"" => 9,
            _ => panic!(""Invalid input""),
        }
    };

    let words: Vec<&str> = numbers.split_whitespace().collect();
    let mut number_words: Vec<(&str, u32)> = words.iter().map(|&w| (w, word_to_number(w))).collect();

    number_words.sort_by_key(|&(_, number)| number);

    number_words.iter().map(|&(word, _)| word).collect::<Vec<&str>>().join("" "")
}","}

fn main() {
    let candidate = sort_numbers;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""three"")), String::from(""three""));
    assert_eq!(candidate(String::from(""three five nine"")), String::from(""three five nine""));
    assert_eq!(candidate(String::from(""five zero four seven nine eight"")), String::from(""zero four five seven eight nine""));
    assert_eq!(candidate(String::from(""six five four three two one zero"")), String::from(""zero one two three four five six""));
}
"
HumanEval_20,nus_Latn,rs,"/// kɔ̱kiɛn kä loc kɛ kɛ rɛy riali̱ (kä nämbär in kuiy, kä nämbär in di̱t)./// Kä pekdɛ min ca ŋun kä nämbäri̱ (kɛ pek mi̱ kuiy ni̱ jɛn kä rɛw) kuɛ̈nkɛ kɛnɛ locni̱ rɛw tin thia̱k kɛ kɛl /// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {
","fn find_closest_elements(mut numbers: Vec<f64>) -> (f64, f64) {
    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());
    let mut min_diff = f64::INFINITY;
    let mut result = (0.0, 0.0);

    for i in 0..(numbers.len() - 1) {
        let diff = numbers[i + 1] - numbers[i];
        if diff < min_diff {
            min_diff = diff;
            result = (numbers[i], numbers[i + 1]);
        }
    }
    
    result
}

fn main() {
    // Example usage
    let vec1 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2];
    let res1 = find_closest_elements(vec1);
    println!(""{:?}"", res1); // (2.0, 2.2)

    let vec2 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0];
    let res2 = find_closest_elements(vec2);
    println!(""{:?}"", res2); // (2.0, 2.0)
}","}

fn main() {
    let candidate = find_closest_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));
}
"
HumanEval_21,nus_Latn,rs,"/// cetkɛ ɣöö min kuiy ni̱ jɛn kä nämbäri̱ bɛ cu ben ɛ 0 kɛnɛ ɣöö min di̱t ni̱ jɛn bɛ cu ben ɛ 1 /// Mi̱ ca pektɛk in ca ŋun kä nämbäri̱ (kɛ ɛlɛmɛni̱ rɛw), la̱thkɛ li̱ni̱e̱e̱r tra̱ni̱thpörmɛn kä bɛktɔr ɛmɔ, /// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])
/// vec![0.0, 0.25, 0.5, 0.75, 1.0]
fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {
","fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {
    if numbers.len() < 2 {
        return numbers;
    }

    let min_value = numbers.iter().cloned().fold(f64::INFINITY, f64::min);
    let max_value = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);

    numbers.into_iter().map(|x| (x - min_value) / (max_value - min_value)).collect()
}

fn main() {
    let numbers = vec![1.0, 2.0, 3.0, 4.0, 5.0];
    let rescaled = rescale_to_unit(numbers);
    println!(""{:?}"", rescaled);
}","}

fn main() {
    let candidate = rescale_to_unit;
    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);
    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);
    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
}
"
HumanEval_23,nus_Latn,rs,"/// Läthni̱ pek in ca ŋun kä thärkɛn/// >>> strlen(String::from(""""))
/// 0
/// >>> strlen(String::from(""abc""))
/// 3
fn strlen(string: String) -> isize {
","fn strlen(string: String) -> isize {
    string.chars().count() as isize
}

fn main() {
    println!(""{}"", strlen(String::from(""""))); // Output: 0
    println!(""{}"", strlen(String::from(""abc""))); // Output: 3
}","}

fn main() {
    let candidate = strlen;
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""x"")), 1);
    assert_eq!(candidate(String::from(""asdasnakj"")), 9);
}
"
HumanEval_24,nus_Latn,rs,"/// Kɛ kui̱ nämbäri̱ ti̱ ca ŋun, n, jiekɛ nämbär in di̱tni̱ jɛn min dääk n ɛ päär, mi̱ kuiy ni̱ jɛn kä n /// >>> largest_divisor(15)
/// 5
fn largest_divisor(n: isize) -> isize {
","fn largest_divisor(n: isize) -> isize {
    for i in (1..n).rev() {
        if n % i == 0 {
            return i;
        }
    }
    1 // If no other divisor is found, return 1
}

fn main() {
    println!(""{}"", largest_divisor(15)); // Output: 5
}","}

fn main() {
    let candidate = largest_divisor;
    assert_eq!(candidate(3), 1);
    assert_eq!(candidate(7), 1);
    assert_eq!(candidate(10), 5);
    assert_eq!(candidate(100), 50);
    assert_eq!(candidate(49), 7);
}
"
HumanEval_25,nus_Latn,rs,"/// Input nämbär ba pa̱a̱r kɛ min ca pith kä paktɔri̱ diaal /// Kɛn gua̱th tin ba kɛ la̱t kɛ jɛ ba kɛ la̱t ɛ la pek in lot rɔ kɛ pek in bi̱ ben raar rɛy pi̱rɛktɔri̱./// Lätdɛ kɛ prämik pa̱rti̱bi̱li̱ kä intɛrjɛr min ca ŋun kä min kuiy ni̱ jɛn kä min di̱t ni̱ jɛn./// >>> factorize(8)
/// vec![2, 2, 2]
/// >>> factorize(25)
/// vec![5, 5]
/// >>> factorize(70)
/// vec![2, 5, 7]
fn factorize(n: isize) -> Vec<isize> {
","fn factorize(mut n: isize) -> Vec<isize> {
    let mut factors = Vec::new();
    let mut divisor = 2;
    while n >= divisor * divisor {
        while n % divisor == 0 {
            factors.push(divisor);
            n /= divisor;
        }
        divisor += 1;
    }
    if n > 1 {
        factors.push(n);
    }
    factors
}

fn main() {
    // Test cases
    println!(""{:?}"", factorize(8));  // Should print: [2, 2, 2]
    println!(""{:?}"", factorize(25)); // Should print: [5, 5]
    println!(""{:?}"", factorize(70)); // Should print: [2, 5, 7]
}","}

fn main() {
    let candidate = factorize;
    assert_eq!(candidate(2), vec![2]);
    assert_eq!(candidate(4), vec![2, 2]);
    assert_eq!(candidate(8), vec![2, 2, 2]);
    assert_eq!(candidate(57), vec![3, 19]);
    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);
    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);
    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);
    assert_eq!(candidate(18), vec![2, 3, 3]);
}
"
HumanEval_26,nus_Latn,rs,"/// Kiɛ ba yi̱k ɛlɛmɛni̱ ba̱ny piny mi̱ päär cie min te rɛy inpuɔɔä.///Thi̱nbɛktɔr duŋ intejeri̱, wuɔ̱c ɛlɛmɛni̱ diaal tin ci̱ tuɔɔk ni̱kɛ gua̱a̱ kɛl./// >>> remove_duplicates(vec![1, 2, 3, 2, 4])
/// vec![1, 3, 4]
fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {
","use std::collections::HashMap;

fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {
    let mut occurrences = HashMap::new();
    
    // Count occurrences of each number
    for &number in &numbers {
        *occurrences.entry(number).or_insert(0) += 1;
    }

    // Filter out numbers that occur more than once
    numbers.into_iter()
        .filter(|&number| occurrences[&number] == 1)
        .collect()
}","}

fn main() {
    let candidate = remove_duplicates;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);
}
"
HumanEval_27,nus_Latn,rs,"/// Kɛ ɣöö ba thärkdɛ min ca ŋun, locni̱kɛ kɛ piny kä bi̱kɛ cu te nhial kä bi̱kɛ cu te piny./// >>> flip_case(String::from(""Hello""))
/// String::from(""hELLO"")
fn flip_case(string: String) -> String {
","fn flip_case(string: String) -> String {
    string.chars().map(|c| {
        if c.is_lowercase() {
            c.to_ascii_uppercase()
        } else {
            c.to_ascii_lowercase()
        }
    }).collect()
}","}

fn main() {
    let candidate = flip_case;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""Hello!"")), String::from(""hELLO!""));
    assert_eq!(candidate(String::from(""These violent delights have violent ends"")), String::from(""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""));
}
"
HumanEval_28,nus_Latn,rs,"/// Concatenate vector of strings into a single string  /// >>> concatenate(vec![])
/// String::from("""")
/// >>> concatenate(vec![String::from(""a""), String::from(""b""), String::from(""c"")])
/// String::from(""abc"")
fn concatenate(strings: Vec<String>) -> String {
","fn concatenate(strings: Vec<String>) -> String {
    strings.concat()
}","}

fn main() {
    let candidate = concatenate;
    assert_eq!(candidate(Vec::<String>::new()), String::from(""""));
    assert_eq!(candidate(vec![String::from(""x""), String::from(""y""), String::from(""z"")]), String::from(""xyz""));
    assert_eq!(candidate(vec![String::from(""x""), String::from(""y""), String::from(""z""), String::from(""w""), String::from(""k"")]), String::from(""xyzwk""));
}
"
HumanEval_29,nus_Latn,rs,"/// Filter ɛ input bɛktɔr duŋ thärkithni̱ kärɔa kɛ kui̱ thärkithni̱ tin tokɛ rɔ̱ kɛ prepi̱dhik mi̱ ca ŋun./// >>> filter_by_prefix(vec![], String::from(""a""))
/// Vec::<String>::new()
/// >>> filter_by_prefix(vec![String::from(""abc""), String::from(""bcd""), String::from(""cde""), String::from(""array"")], String::from(""a""))
/// vec![String::from(""abc""), String::from(""array"")]
fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {
","fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {
    strings.into_iter()
        .filter(|s| s.starts_with(&prefix))
        .collect()
}","}

fn main() {
    let candidate = filter_by_prefix;
    assert_eq!(candidate(Vec::<String>::new(), String::from(""john"")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""xxx""), String::from(""asd""), String::from(""xxy""), String::from(""john doe""), String::from(""xxxAAA""), String::from(""xxx"")], String::from(""xxx"")), vec![String::from(""xxx""), String::from(""xxxAAA""), String::from(""xxx"")]);
}
"
HumanEval_30,nus_Latn,rs,"/// Läthni̱ nämbäri̱ puci̱tibni̱ kärɔ̱ rɛy bɛktɔrä. /// >>> get_positive(vec![-1, 2, -4, 5, 6])
/// vec![2, 5, 6]
/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// vec![5, 3, 2, 3, 9, 123, 1]
fn get_positive(l: Vec<isize>) -> Vec<isize> {
","fn get_positive(l: Vec<isize>) -> Vec<isize> {
    l.into_iter().filter(|&x| x > 0).collect()
}","}

fn main() {
    let candidate = get_positive;
    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);
    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);
    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
}
"
HumanEval_31,nus_Latn,rs,"/// Lɔ̱a̱rkɛ thuɔ̱k mi̱ ca ŋun ɛ nämbär ɛ la praam, kɛnɛ kac mi̱ dɔ̱ŋ./// >>> is_prime(6)
/// false
/// >>> is_prime(101)
/// true
/// >>> is_prime(11)
/// true
/// >>> is_prime(13441)
/// true
/// >>> is_prime(61)
/// true
/// >>> is_prime(4)
/// false
/// >>> is_prime(1)
/// false
fn is_prime(n: isize) -> bool {
","fn is_prime(n: isize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}","}

fn main() {
    let candidate = is_prime;
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(101), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(13441), true);
    assert_eq!(candidate(61), true);
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(1), false);
    assert_eq!(candidate(5), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(17), true);
    assert_eq!(candidate(85), false);
    assert_eq!(candidate(77), false);
    assert_eq!(candidate(255379), false);
}
"
HumanEval_33,nus_Latn,rs,"/// kä tin ca mat kä indi̱i̱ci̱ni̱ tin päärkɛ kä l, duŋni̱ ɣöö cua kɛ da̱a̱k.///l' ɛ mi̱ päär kɛ l kä indi̱i̱ciini̱ tin /ca de da̱a̱k ɛ diɔ̱ɔ̱k, kä bi̱ tin te kä indi̱i̱ciini̱ tin de da̱a̱k ɛ diɔ̱k pa̱a̱r./// La̱t ɛmɛ naŋɛ bɛktɔr l kä bɛ bɛktɔr l' loc ɛ la mi̱ ce̱tkɛ mi̱ cie /// >>> sort_third(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])
/// vec![2, 6, 3, 4, 8, 9, 5]
fn sort_third(l: Vec<isize>) -> Vec<isize> {
","fn sort_third(l: Vec<isize>) -> Vec<isize> {
    let mut divisible_by_three: Vec<(usize, isize)> = l.iter()
        .enumerate()
        .filter(|&(i, _)| i % 3 == 0)
        .map(|(i, &value)| (i, value))
        .collect();

    // Sort the values that are at indices divisible by 3
    divisible_by_three.sort_by_key(|&(_, value)| value);

    let mut result = l.clone();
    for (sorted_index, (original_index, _)) in divisible_by_three.iter().enumerate() {
        result[*original_index] = divisible_by_three[sorted_index].1;
    }

    result
}","}

fn main() {
    let candidate = sort_third;
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);
    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);
    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);
}
"
HumanEval_34,nus_Latn,rs,"/// Lɔ̱a̱rkɛ ɛlɛmɛni̱ tin ca da̱a̱k rɛy bɛktɔr /// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![0, 2, 3, 5, 9, 123]
fn unique(l: Vec<isize>) -> Vec<isize> {
","fn unique(mut l: Vec<isize>) -> Vec<isize> {
    l.sort_unstable();
    l.dedup();
    l
}

fn main() {
    let result = unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]);
    println!(""{:?}"", result);
}","}

fn main() {
    let candidate = unique;
    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);
}
"
HumanEval_35,nus_Latn,rs,"/// Lätdɛ ɛlɛmɛni̱ tin di̱tni̱kɛn rɛy bɛktɔr. /// >>> max_element(vec![1, 2, 3])
/// 3
/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
fn max_element(l: Vec<isize>) -> isize {
","fn max_element(l: Vec<isize>) -> isize {
    l.into_iter().max().unwrap()
}","}

fn main() {
    let candidate = max_element;
    assert_eq!(candidate(vec![1, 2, 3]), 3);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);
}
"
HumanEval_36,nus_Latn,rs,"/// Läthni̱ nämbär kä min la jɔɔc ɛ la 7 rɛy intejeri̱ tin kuiyni̱kɛn kä n tin de da̱a̱k ɛ 11 kiɛ 13. /// >>> fizz_buzz(50)
/// 0
/// >>> fizz_buzz(78)
/// 2
/// >>> fizz_buzz(79)
/// 3
fn fizz_buzz(n: isize) -> isize {
","fn fizz_buzz(n: isize) -> isize {
    (0..n)
        .filter(|&x| x % 11 == 0 || x % 13 == 0)
        .flat_map(|x| x.to_string().chars())
        .filter(|&c| c == '7')
        .count() as isize
}","}

fn main() {
    let candidate = fizz_buzz;
    assert_eq!(candidate(50), 0);
    assert_eq!(candidate(78), 2);
    assert_eq!(candidate(79), 3);
    assert_eq!(candidate(100), 3);
    assert_eq!(candidate(200), 6);
    assert_eq!(candidate(4000), 192);
    assert_eq!(candidate(10000), 639);
    assert_eq!(candidate(100000), 8026);
}
"
HumanEval_37,nus_Latn,rs,"/// kä ba̱li̱öni̱ ɛ päär ɛ indi̱ci̱ni̱ kä l, duŋni̱ ɣöö cua kɛ da̱a̱k.///l' ɛ mi̱ päär kɛ l kä indi̱i̱ciini̱ ti̱ /ci̱ tɔ̱a̱ a kɛl, niɛ gua̱a̱ mɔ bi̱ tin te thi̱n kä indi̱i̱ciini̱ ti̱ päär tekɛ päär /// La̱t ɛmɛ naŋɛ bɛktɔr l kä bɛ bɛktɔr l' loc ɛ la mi̱ ce̱tkɛ mi̱ cie /// >>> sort_even(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_even(vec![5, 6, 3, 4])
/// vec![3, 6, 5, 4]
fn sort_even(l: Vec<isize>) -> Vec<isize> {
","fn sort_even(l: Vec<isize>) -> Vec<isize> {
    // Collect even indexed elements and sort them
    let mut even_elements: Vec<isize> = l.iter().enumerate()
        .filter(|&(i, _)| i % 2 == 0)
        .map(|(_, &val)| val)
        .collect();
    even_elements.sort();

    // Reconstruct the vector `l'`
    let mut result = l.clone();
    let mut even_index = 0;

    for i in 0..l.len() {
        if i % 2 == 0 {
            result[i] = even_elements[even_index];
            even_index += 1;
        }
    }
    
    result
}","}

fn main() {
    let candidate = sort_even;
    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}
"
HumanEval_39,nus_Latn,rs,"/// prime_fib la̱tdɛ ɛ nämbär n-th min la nämbär Fi̱böna̱ci kä jɛn bä ɛ pra̱m./// >>> prime_fib(1)
/// 2
/// >>> prime_fib(2)
/// 3
/// >>> prime_fib(3)
/// 5
/// >>> prime_fib(4)
/// 13
/// >>> prime_fib(5)
/// 89
fn prime_fib(n: isize) -> isize {
","fn prime_fib(n: isize) -> isize {
    fn is_prime(num: isize) -> bool {
        if num <= 1 {
            return false;
        }
        if num <= 3 {
            return true;
        }
        if num % 2 == 0 || num % 3 == 0 {
            return false;
        }
        let mut i = 5;
        while i * i <= num {
            if num % i == 0 || num % (i + 2) == 0 {
                return false;
            }
            i += 6;
        }
        true
    }

    fn fibonacci() -> impl Iterator<Item = isize> {
        let mut a: isize = 0;
        let mut b: isize = 1;
        std::iter::from_fn(move || {
            let next = a + b;
            a = b;
            b = next;
            Some(a)
        })
    }

    let mut count = 0;
    for fib_num in fibonacci() {
        if is_prime(fib_num) {
            count += 1;
            if count == n {
                return fib_num;
            }
        }
    }
    -1
}","}

fn main() {
    let candidate = prime_fib;
    assert_eq!(candidate(1), 2);
    assert_eq!(candidate(2), 3);
    assert_eq!(candidate(3), 5);
    assert_eq!(candidate(4), 13);
    assert_eq!(candidate(5), 89);
    assert_eq!(candidate(6), 233);
    assert_eq!(candidate(7), 1597);
    assert_eq!(candidate(8), 28657);
    assert_eq!(candidate(9), 514229);
    assert_eq!(candidate(10), 433494437);
}
"
HumanEval_40,nus_Latn,rs,"///mi̱ matkɛ ɛ la dhɛrö, kä mi̱ dɔ̱ŋ /ci̱kɛ thuɔ̱k./// jɛn la loc ɛ thuɔ̱k mi̱ tekɛ ɛlɛmɛni̱ da̱ŋ diɔ̱k ti̱ gööl rɛy bɛktɔr min bi̱ ///triple_sum_to_zero la naŋɛ intɛrjiɛr bɛktɔr ɛ la inpuut./// >>> triples_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(vec![1])
/// false
fn triples_sum_to_zero(l: Vec<isize>) -> bool {
","fn triples_sum_to_zero(l: Vec<isize>) -> bool {
    let n = l.len();
    if n < 3 {
        return false;
    }

    let mut sorted_l = l.clone();
    sorted_l.sort();

    for i in 0..n-2 {
        let a = sorted_l[i];
        let mut left = i + 1;
        let mut right = n - 1;

        while left < right {
            let sum = a + sorted_l[left] + sorted_l[right];
            if sum == 0 {
                return true;
            } else if sum < 0 {
                left += 1;
            } else {
                right -= 1;
            }
        }
    }

    false
}","}

fn main() {
    let candidate = triples_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, 5, -1]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), true);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![1, 2, 5, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![1, 3, 5, -100]), false);
    assert_eq!(candidate(vec![100, 3, 5, -100]), false);
}
"
HumanEval_41,nus_Latn,rs,"/// La̱t ɛmɛ bɛ pek in ci̱ ben raar kä römdiɛn raar nyoth.///kä duɔ̱ɔ̱p in jäl kɛ kɛ /ci̱kɛ rɔ̱ bi̱ wɔ̱ kɛ jɛ.///Kä dɛ,kä thurbiɛli̱ tin la̱tkɛ ɛ ji̱-bi̱i̱li̱ ti̱ ŋuan ti̱ bum kɛnɛ buɔ̱mdiɛn; kɛ kui̱c ɛmɔ, kɛn la̱tkɛ kɛ ɣöö bi̱kɛ ŋot kɛ mi̱ jälkɛ./// mi̱ ci̱ thurbil mi̱ jäl caam kä cuec bɛ röm kɛ thurbil mi̱ jäl cuec kä cuec.//Kɛn thurbiɛli̱ diaal jälkɛ kɛ pɛ̈th mi̱ päär.///Kɛn ja̱a̱l tin kɔ̱ŋ tin laa jäl kui̱c caam laa jäl kɛ kui̱c cuëëc ɛ wɔ̱ ni̱ kä caam.///n bi̱kɛ ja̱l kɛ kui̱c caam ɛ wä kui̱c cuëëc; kɛ gua̱a̱ kɛl, bi̱kɛ tekɛ gua̱a̱ mi̱ göl kä bi̱kɛ ja̱l kɛ bi̱kɛ ja̱l kɛ bi̱kɛ wä kui̱c cuëëc.///Cɛ car ɛn duɔ̱p in cuŋ ɛ la duɔ̱ɔ̱p mi̱ /thiɛl pek mi̱ bäär.fn car_race_collision(n: isize) -> isize {
","fn car_race_collision(n: isize) -> isize {
    // Since every car moving left to right will collide exactly once
    // with every car moving right to left, the number of collisions is n * n
    n * n
}

fn main() {
    let n = 5;
    println!(""Number of collisions: {}"", car_race_collision(n));
}","}

fn main() {
    let candidate = car_race_collision;
    assert_eq!(candidate(2), 4);
    assert_eq!(candidate(3), 9);
    assert_eq!(candidate(4), 16);
    assert_eq!(candidate(8), 64);
    assert_eq!(candidate(10), 100);
}
"
HumanEval_42,nus_Latn,rs,"/// Lätdɛ kɛ bendɛ kɛ ɛlɛmɛni̱ tin caa rëp kɛ 1. /// >>> incr_list(vec![1, 2, 3])
/// vec![2, 3, 4]
/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]
fn incr_list(l: Vec<isize>) -> Vec<isize> {
","fn incr_list(l: Vec<isize>) -> Vec<isize> {
    l.iter().map(|&x| x + 1).collect()
}","}

fn main() {
    let candidate = incr_list;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);
    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);
}
"
HumanEval_43,nus_Latn,rs,"///mi̱ matkɛ ɛ la dhɛrö, kä mi̱ dɔ̱ŋ /ci̱kɛ thuɔ̱k./// jɛn la loc ɛ thuɔ̱k mi̱ tekɛ rɛw ti̱ gööl rɛy bɛktɔr min bi̱ /// pairs_sum_to_zero la naŋɛ intɛrjiɛr bɛktɔr ɛ la inpuut./// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(vec![1])
/// false
fn pairs_sum_to_zero(l: Vec<isize>) -> bool {
","fn pairs_sum_to_zero(l: Vec<isize>) -> bool {
    use std::collections::HashSet;
    let mut seen = HashSet::new();
    
    for &num in &l {
        if seen.contains(&-num) {
            return true;
        }
        seen.insert(num);
    }
    false
}

fn main() {
    println!(""{}"", pairs_sum_to_zero(vec![1, 3, 5, 0])); // false
    println!(""{}"", pairs_sum_to_zero(vec![1, 3, -2, 1])); // false
    println!(""{}"", pairs_sum_to_zero(vec![1, 2, 3, 7])); // false
    println!(""{}"", pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])); // true
    println!(""{}"", pairs_sum_to_zero(vec![1])); // false
}","}

fn main() {
    let candidate = pairs_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);
}
"
HumanEval_44,nus_Latn,rs,"/// nämbäri̱ ba̱thni̱ tin kuiyni̱ kɛn kä 10./// luɔ̱c thärkɛn ɛ ca nyoth kɛ kɔr kä mi ca loc./// Gɛɛr nämerikal baath kä inpuɔɔ nämbär x kɛ baath./// >>> change_base(8, 3)
/// String::from(""22"")
/// >>> change_base(8, 2)
/// String::from(""1000"")
/// >>> change_base(7, 2)
/// String::from(""111"")
fn change_base(x: isize, base: isize) -> String {
","fn change_base(x: isize, base: isize) -> String {
    if base < 2 || base > 9 {
        panic!(""Base must be between 2 and 9"");
    }
    
    if x == 0 {
        return String::from(""0"");
    }
    
    let mut result = String::new();
    let mut number = x;
    
    while number > 0 {
        let remainder = number % base;
        result.push_str(&remainder.to_string());
        number /= base;
    }
    
    result.chars().rev().collect()
}","}

fn main() {
    let candidate = change_base;
    assert_eq!(candidate(8, 3), String::from(""22""));
    assert_eq!(candidate(9, 3), String::from(""100""));
    assert_eq!(candidate(234, 2), String::from(""11101010""));
    assert_eq!(candidate(16, 2), String::from(""10000""));
    assert_eq!(candidate(8, 2), String::from(""1000""));
    assert_eq!(candidate(7, 2), String::from(""111""));
    assert_eq!(candidate(2, 3), String::from(""2""));
    assert_eq!(candidate(3, 4), String::from(""3""));
    assert_eq!(candidate(4, 5), String::from(""4""));
    assert_eq!(candidate(5, 6), String::from(""5""));
    assert_eq!(candidate(6, 7), String::from(""6""));
    assert_eq!(candidate(7, 8), String::from(""7""));
}
"
HumanEval_45,nus_Latn,rs,"/// Mi̱ ca ŋun ɛ la bäär gua̱a̱th in bi̱ ben kɛ jɔk kɛnɛ gua̱a̱th in bi̱ locni̱kɛ rɔ̱ thi̱n kɛ kui̱ kä tin ci̱ rɔ̱ loc./// >>> triangle_area(5, 3)
/// 7.5
fn triangle_area(a: isize, h: isize) -> f64 {
","fn triangle_area(a: isize, h: isize) -> f64 {
    (a as f64 * h as f64) / 2.0
}

fn main() {
    let area = triangle_area(5, 3);
    println!(""{}"", area);
}","}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(5, 3), 7.5);
    assert_eq!(candidate(2, 2), 2.0);
    assert_eq!(candidate(10, 8), 40.0);
}
"
HumanEval_46,nus_Latn,rs,"/// Ji̱n gɔ̱ri̱ pa̱ŋciin mi̱ bi̱ lät ɛ gɔaa kɛ ɣöö ba pek ɛ la n-th kä ɛlɛmɛni̱ kä fib4 nämbäri̱ tin guɔ̱ɔ̱rkɛrɔ̱. /Cu lät kɛ mi̱ la rɔ nyɔk kɛ locni̱./// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)./// fib4(3) -> 0 /// fib4(2) -> 2 /// fib4(1) -> 0 /// fib4(0) -> 0 /// Kä Fib4 nämbär thekuɛnthi̱ ɛ thekuɛnthi̱ mi̱ cäät kɛ Fibbonacci thekuɛnthi̱ min ca lat i̱ ɛ jɛn i̱nɔ: /// >>> fib4(5)
/// 4
/// >>> fib4(6)
/// 8
/// >>> fib4(7)
/// 14
fn fib4(n: isize) -> isize {
","fn fib4(n: isize) -> isize {
    if n < 0 {
        return 0; // Define behavior for negative input
    }

    let mut sequence = vec![0, 0, 2, 0];

    if n < 4 {
        return sequence[n as usize];
    }

    for i in 4..=n {
        let next_value = sequence[(i - 1) as usize] 
                       + sequence[(i - 2) as usize] 
                       + sequence[(i - 3) as usize] 
                       + sequence[(i - 4) as usize];
        sequence.push(next_value);
    }

    sequence[n as usize]
}

fn main() {
    println!(""{}"", fib4(5)); // 4
    println!(""{}"", fib4(6)); // 8
    println!(""{}"", fib4(7)); // 14
}","}

fn main() {
    let candidate = fib4;
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 28);
    assert_eq!(candidate(10), 104);
    assert_eq!(candidate(12), 386);
}
"
HumanEval_47,nus_Latn,rs,"/// Lätdɛ kɛ mediaan kä elɛmɛni̱ rɛy bɛktɔr l. /// >>> median(vec![3, 1, 2, 4, 5])
/// 3.0
/// >>> median(vec![-10, 4, 6, 1000, 10, 20])
/// 15.0
fn median(l: Vec<isize>) -> f64 {
","fn median(l: Vec<isize>) -> f64 {
    let mut l = l.clone();
    l.sort();
    let len = l.len();

    if len % 2 == 0 {
        let mid1 = len / 2;
        let mid2 = mid1 - 1;
        ((l[mid1] as f64) + (l[mid2] as f64)) / 2.0
    } else {
        l[len / 2] as f64
    }
}","}

fn main() {
    let candidate = median;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);
    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);
    assert_eq!(candidate(vec![5]), 5.0);
    assert_eq!(candidate(vec![6, 5]), 5.5);
    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);
}
"
HumanEval_48,nus_Latn,rs,"/// Ɣɔ̱ɔ̱ni̱ mi̱ ca ŋun ɛ la pa̱li̱ndrɔm /// >>> is_palindrome(String::from(""""))
/// true
/// >>> is_palindrome(String::from(""aba""))
/// true
/// >>> is_palindrome(String::from(""aaaaa""))
/// true
/// >>> is_palindrome(String::from(""zbcd""))
/// false
fn is_palindrome(text: String) -> bool {
","fn is_palindrome(text: String) -> bool {
    let chars: Vec<char> = text.chars().collect();
    let len = chars.len();
    for i in 0..len / 2 {
        if chars[i] != chars[len - 1 - i] {
            return false;
        }
    }
    true
}","}

fn main() {
    let candidate = is_palindrome;
    assert_eq!(candidate(String::from("""")), true);
    assert_eq!(candidate(String::from(""aba"")), true);
    assert_eq!(candidate(String::from(""aaaaa"")), true);
    assert_eq!(candidate(String::from(""zbcd"")), false);
    assert_eq!(candidate(String::from(""xywyx"")), true);
    assert_eq!(candidate(String::from(""xywyz"")), false);
    assert_eq!(candidate(String::from(""xywzx"")), false);
}
"
HumanEval_49,nus_Latn,rs,"/// Läth 2^n modulo p (ŋi̱i̱c kɛ nämerikni̱)./// >>> modp(3, 5)
/// 3
/// >>> modp(1101, 101)
/// 2
/// >>> modp(0, 101)
/// 1
/// >>> modp(3, 11)
/// 8
/// >>> modp(100, 101)
/// 1
fn modp(n: isize, p: isize) -> isize {
","fn modp(n: isize, p: isize) -> isize {
    if p == 1 {
        return 0;
    }
    let mut result = 1;
    let mut base = 2 % p;
    let mut exponent = n;
    
    while exponent > 0 {
        if exponent % 2 == 1 {
            result = (result * base) % p;
        }
        base = (base * base) % p;
        exponent /= 2;
    }
    
    result
}","}

fn main() {
    let candidate = modp;
    assert_eq!(candidate(3, 5), 3);
    assert_eq!(candidate(1101, 101), 2);
    assert_eq!(candidate(0, 101), 1);
    assert_eq!(candidate(3, 11), 8);
    assert_eq!(candidate(100, 101), 1);
    assert_eq!(candidate(30, 5), 4);
    assert_eq!(candidate(31, 5), 3);
}
"
HumanEval_51,nus_Latn,rs,"/// remove_vowels ɛ mi̱ la̱t mi̱ naŋkɛ ni̱ kɛn i̱thtirŋ kɛnɛ ɣöö bɛ loc ni̱ kɛn i̱thtirŋ mi̱ thiɛl jɔw./// >>> remove_vowels(String::from(""""))
/// String::from("""")
/// >>> remove_vowels(String::from(""abcdef""))
/// String::from(""bcdf"")
/// >>> remove_vowels(String::from(""aaaaa""))
/// String::from("""")
/// >>> remove_vowels(String::from(""aaBAA""))
/// String::from(""B"")
/// >>> remove_vowels(String::from(""zbcd""))
/// String::from(""zbcd"")
fn remove_vowels(text: String) -> String {
","fn remove_vowels(text: String) -> String {
    text.chars()
        .filter(|&c| !""aeiouAEIOU"".contains(c))
        .collect()
}","}

fn main() {
    let candidate = remove_vowels;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""abcdef
ghijklm"")), String::from(""bcdf
ghjklm""));
    assert_eq!(candidate(String::from(""fedcba"")), String::from(""fdcb""));
    assert_eq!(candidate(String::from(""eeeee"")), String::from(""""));
    assert_eq!(candidate(String::from(""acBAA"")), String::from(""cB""));
    assert_eq!(candidate(String::from(""EcBOO"")), String::from(""cB""));
    assert_eq!(candidate(String::from(""ybcd"")), String::from(""ybcd""));
}
"
HumanEval_52,nus_Latn,rs,"/// Lɔ̱a̱rkɛ thuɔ̱k mi̱ ci̱ nämbäri̱ diaal rɛy bɛktɔr l te piny kä thärkäl t. /// >>> below_threshold(vec![1, 2, 4, 10], 100)
/// true
/// >>> below_threshold(vec![1, 20, 4, 10], 5)
/// false
fn below_threshold(l: Vec<isize>, t: isize) -> bool {
","fn below_threshold(l: Vec<isize>, t: isize) -> bool {
    l.iter().all(|&x| x < t)
}

fn main() {
    println!(""{}"", below_threshold(vec![1, 2, 4, 10], 100)); // true
    println!(""{}"", below_threshold(vec![1, 20, 4, 10], 5));  // false
}","}

fn main() {
    let candidate = below_threshold;
    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);
    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);
}
"
HumanEval_53,nus_Latn,rs,"/// Mat nämbäri̱ rɛw x kɛnɛ y /// >>> add(2, 3)
/// 5
/// >>> add(5, 7)
/// 12
fn add(x: isize, y: isize) -> isize {
","fn add(x: isize, y: isize) -> isize {
    x + y
}","}

fn main() {
    let candidate = add;
    assert_eq!(candidate(0, 1), 1);
    assert_eq!(candidate(1, 0), 1);
    assert_eq!(candidate(2, 3), 5);
    assert_eq!(candidate(5, 7), 12);
    assert_eq!(candidate(7, 5), 12);
}
"
HumanEval_54,nus_Latn,rs,"/// Thɛm mi̱ ci̱ rie̱t da̱ŋ rɛw tekɛ kɛ luɔt mi̱ cäät. /// >>> same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddeddabc""))
/// true
/// >>> same_chars(String::from(""abcd""), String::from(""dddddddabc""))
/// true
/// >>> same_chars(String::from(""dddddddabc""), String::from(""abcd""))
/// true
/// >>> same_chars(String::from(""eabcd""), String::from(""dddddddabc""))
/// false
/// >>> same_chars(String::from(""abcd""), String::from(""dddddddabce""))
/// false
/// >>> same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddddabc""))
/// false
fn same_chars(s0: String, s1: String) -> bool {
","use std::collections::HashSet;

fn same_chars(s0: String, s1: String) -> bool {
    let set0: HashSet<char> = s0.chars().collect();
    let set1: HashSet<char> = s1.chars().collect();
    set0 == set1
}

fn main() {
    println!(""{}"", same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddeddabc""))); // true
    println!(""{}"", same_chars(String::from(""abcd""), String::from(""dddddddabc""))); // true
    println!(""{}"", same_chars(String::from(""dddddddabc""), String::from(""abcd""))); // true
    println!(""{}"", same_chars(String::from(""eabcd""), String::from(""dddddddabc""))); // false
    println!(""{}"", same_chars(String::from(""abcd""), String::from(""dddddddabce""))); // false
    println!(""{}"", same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddddabc""))); // false
}","}

fn main() {
    let candidate = same_chars;
    assert_eq!(candidate(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddeddabc"")), true);
    assert_eq!(candidate(String::from(""abcd""), String::from(""dddddddabc"")), true);
    assert_eq!(candidate(String::from(""dddddddabc""), String::from(""abcd"")), true);
    assert_eq!(candidate(String::from(""eabcd""), String::from(""dddddddabc"")), false);
    assert_eq!(candidate(String::from(""abcd""), String::from(""dddddddabcf"")), false);
    assert_eq!(candidate(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddddabc"")), false);
    assert_eq!(candidate(String::from(""aabb""), String::from(""aaccc"")), false);
}
"
HumanEval_55,nus_Latn,rs,"/// Lätdɛ ɛ nämbär Fibönakci̱ n-th. /// >>> fib(10)
/// 55
/// >>> fib(1)
/// 1
/// >>> fib(8)
/// 21
fn fib(n: isize) -> isize {
","fn fib(n: isize) -> isize {
    match n {
        0 => 0,
        1 => 1,
        _ => fib(n - 1) + fib(n - 2),
    }
}

fn main() {
    println!(""{}"", fib(10)); // 55
    println!(""{}"", fib(1));  // 1
    println!(""{}"", fib(8));  // 21
}","}

fn main() {
    let candidate = fib;
    assert_eq!(candidate(10), 55);
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(8), 21);
    assert_eq!(candidate(11), 89);
    assert_eq!(candidate(12), 144);
}
"
HumanEval_56,nus_Latn,rs,"/// luɔ̱cdɛ i̱ thuɔ̱k mi̱ ci̱kɛ rɔ̱ tok kɛ lëpdɛ kɛrɔ̱ kä bi̱kɛ cu thi̱ëëk kɛ lëpdɛ kɛrɔ̱./// brackets ɛ mi̱ la thärkdɛ kä ""<"" kɛnɛ "">"". /// >>> correct_bracketing(String::from(""<""))
/// false
/// >>> correct_bracketing(String::from(""<>""))
/// true
/// >>> correct_bracketing(String::from(""<<><>>""))
/// true
/// >>> correct_bracketing(String::from(""><<>""))
/// false
fn correct_bracketing(brackets: String) -> bool {
","fn correct_bracketing(brackets: String) -> bool {
    let mut balance = 0;
    
    for bracket in brackets.chars() {
        if bracket == '<' {
            balance += 1;
        } else if bracket == '>' {
            balance -= 1;
            if balance < 0 {
                return false;
            }
        }
    }
    
    balance == 0
}","}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from(""<>"")), true);
    assert_eq!(candidate(String::from(""<<><>>"")), true);
    assert_eq!(candidate(String::from(""<><><<><>><>"")), true);
    assert_eq!(candidate(String::from(""<><><<<><><>><>><<><><<>>>"")), true);
    assert_eq!(candidate(String::from(""<<<><>>>>"")), false);
    assert_eq!(candidate(String::from(""><<>"")), false);
    assert_eq!(candidate(String::from(""<"")), false);
    assert_eq!(candidate(String::from(""<<<<"")), false);
    assert_eq!(candidate(String::from("">"")), false);
    assert_eq!(candidate(String::from(""<<>"")), false);
    assert_eq!(candidate(String::from(""<><><<><>><>><<>"")), false);
    assert_eq!(candidate(String::from(""<><><<><>><>>><>"")), false);
}
"
HumanEval_57,nus_Latn,rs,"/// Lɔ̱a̱rkɛ thuɔ̱k ɛni̱ ɛlɛmɛni̱ bɛktɔri̱ kɛn bi̱kɛ rɔ̱ rep kiɛ bi̱kɛ rɔ̱ rep kɛ duɔ̱ɔ̱p mi̱ thi̱a̱k./// >>> monotonic(vec![1, 2, 4, 20])
/// true
/// >>> monotonic(vec![1, 20, 4, 10])
/// false
/// >>> monotonic(vec![4, 1, 0, -10])
/// true
fn monotonic(l: Vec<isize>) -> bool {
","fn monotonic(l: Vec<isize>) -> bool {
    if l.len() <= 1 {
        return true;
    }
    
    let mut increasing = true;
    let mut decreasing = true;
    
    for i in 0..l.len() - 1 {
        if l[i] < l[i + 1] {
            decreasing = false;
        }
        if l[i] > l[i + 1] {
            increasing = false;
        }
    }
    
    increasing || decreasing
}

fn main() {
    println!(""{}"", monotonic(vec![1, 2, 4, 20])); // true
    println!(""{}"", monotonic(vec![1, 20, 4, 10])); // false
    println!(""{}"", monotonic(vec![4, 1, 0, -10])); // true
}","}

fn main() {
    let candidate = monotonic;
    assert_eq!(candidate(vec![1, 2, 4, 10]), true);
    assert_eq!(candidate(vec![1, 2, 4, 20]), true);
    assert_eq!(candidate(vec![1, 20, 4, 10]), false);
    assert_eq!(candidate(vec![4, 1, 0, -10]), true);
    assert_eq!(candidate(vec![4, 1, 1, 0]), true);
    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);
    assert_eq!(candidate(vec![9, 9, 9, 9]), true);
}
"
HumanEval_58,nus_Latn,rs,"/// Läthni̱ kä ti̱ ca riali̱kä ti̱ gööl ti̱ cäät kä ɣɛktɔri̱ da̱ŋ rɛw./// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])
/// vec![1, 5, 653]
/// >>> common(vec![5, 3, 2, 8], vec![3, 2])
/// vec![2, 3]
fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {
","use std::collections::HashSet;

fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {
    // Convert both vectors to hash sets to remove duplicates and allow set operations
    let set1: HashSet<_> = l1.into_iter().collect();
    let set2: HashSet<_> = l2.into_iter().collect();

    // Find the intersection of both sets
    let intersection: HashSet<_> = set1.intersection(&set2).cloned().collect();

    // Convert the intersection set to a sorted vector
    let mut result: Vec<_> = intersection.into_iter().collect();
    result.sort();

    result
}

fn main() {
    // Test cases
    println!(""{:?}"", common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])); // Should print: [1, 5, 653]
    println!(""{:?}"", common(vec![5, 3, 2, 8], vec![3, 2])); // Should print: [2, 3]
}","}

fn main() {
    let candidate = common;
    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);
    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);
    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());
}
"
HumanEval_59,nus_Latn,rs,"/// Läthni̱ prämik paktɔr in di̱tni̱ jɛn kä n. Ɣɔɔri̱ n > 1 kä /ci̱ɛɛ prämik. /// >>> largest_prime_factor(13195)
/// 29
/// >>> largest_prime_factor(2048)
/// 2
fn largest_prime_factor(n: isize) -> isize {
","fn largest_prime_factor(mut n: isize) -> isize {
    let mut largest_factor = 1;

    // Check for number of twos that divide n
    while n % 2 == 0 {
        largest_factor = 2;
        n /= 2;
    }

    // n must be odd at this point, so we can skip even numbers
    let mut factor = 3;
    while factor * factor <= n {
        while n % factor == 0 {
            largest_factor = factor;
            n /= factor;
        }
        factor += 2;
    }

    // If n becomes a prime number greater than 2
    if n > 2 {
        largest_factor = n;
    }

    largest_factor
}

fn main() {
    println!(""{}"", largest_prime_factor(13195));
    println!(""{}"", largest_prime_factor(2048));
}","}

fn main() {
    let candidate = largest_prime_factor;
    assert_eq!(candidate(15), 5);
    assert_eq!(candidate(27), 3);
    assert_eq!(candidate(63), 7);
    assert_eq!(candidate(330), 11);
    assert_eq!(candidate(13195), 29);
}
"
HumanEval_60,nus_Latn,rs,"/// sum_to_n ɛ pa̱ŋcin mi̱ la mat nämbäri̱ kä 1 ɛ wä kä n. /// >>> sum_to_n(30)
/// 465
/// >>> sum_to_n(100)
/// 5050
/// >>> sum_to_n(5)
/// 15
/// >>> sum_to_n(10)
/// 55
/// >>> sum_to_n(1)
/// 1
fn sum_to_n(n: isize) -> isize {
","fn sum_to_n(n: isize) -> isize {
    n * (n + 1) / 2
}","}

fn main() {
    let candidate = sum_to_n;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(6), 21);
    assert_eq!(candidate(11), 66);
    assert_eq!(candidate(30), 465);
    assert_eq!(candidate(100), 5050);
}
"
HumanEval_61,nus_Latn,rs,"/// luɔ̱cdɛ i̱ thuɔ̱k mi̱ ci̱kɛ rɔ̱ tok kɛ lëpdɛ kɛrɔ̱ kä bi̱kɛ cu thi̱ëëk kɛ lëpdɛ kɛrɔ̱./// brackets ɛ mi̱ la ri̱e̱t mi̱ tä kɛɛ ""("" kɛnɛ "")"". /// >>> correct_bracketing(String::from(""(""))
/// false
/// >>> correct_bracketing(String::from(""()""))
/// true
/// >>> correct_bracketing(String::from(""(()())""))
/// true
/// >>> correct_bracketing(String::from("")(()""))
/// false
fn correct_bracketing(brackets: String) -> bool {
","fn correct_bracketing(brackets: String) -> bool {
    let mut balance = 0;
    
    for c in brackets.chars() {
        if c == '(' {
            balance += 1;
        } else if c == ')' {
            balance -= 1;
        }

        if balance < 0 {
            return false;
        }
    }
    
    balance == 0
}","}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from(""()"")), true);
    assert_eq!(candidate(String::from(""(()())"")), true);
    assert_eq!(candidate(String::from(""()()(()())()"")), true);
    assert_eq!(candidate(String::from(""()()((()()())())(()()(()))"")), true);
    assert_eq!(candidate(String::from(""((()())))"")), false);
    assert_eq!(candidate(String::from("")(()"")), false);
    assert_eq!(candidate(String::from(""("")), false);
    assert_eq!(candidate(String::from(""(((("")), false);
    assert_eq!(candidate(String::from("")"")), false);
    assert_eq!(candidate(String::from(""(()"")), false);
    assert_eq!(candidate(String::from(""()()(()())())(()"")), false);
    assert_eq!(candidate(String::from(""()()(()())()))()"")), false);
}
"
HumanEval_62,nus_Latn,rs,"/// Lätdɛ jɔk ɛ la mi̱ ji̱o̱li̱k kä pöli̱nömial mi̱ te rɛy kä mi̱ cäät./// xs[0] + xs[1] * x + xs[2] * x^2 + .... ///xs cuŋkɛ ɛ la nyin pöli̱nömial./// >>> derivative(vec![3, 1, 2, 4, 5])
/// vec![1, 4, 12, 20]
/// >>> derivative(vec![1, 2, 3])
/// vec![2, 6]
fn derivative(xs: Vec<isize>) -> Vec<isize> {
","fn derivative(xs: Vec<isize>) -> Vec<isize> {
    let mut result = Vec::new();
    for (i, &coeff) in xs.iter().enumerate().skip(1) {
        result.push(coeff * i as isize);
    }
    result
}

fn main() {
    let poly1 = vec![3, 1, 2, 4, 5];
    let poly2 = vec![1, 2, 3];
    println!(""{:?}"", derivative(poly1)); // Output: [1, 4, 12, 20]
    println!(""{:?}"", derivative(poly2)); // Output: [2, 6]
}","}

fn main() {
    let candidate = derivative;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);
    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);
    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);
    assert_eq!(candidate(vec![1]), Vec::<isize>::new());
}
"
HumanEval_63,nus_Latn,rs,"/// Ji̱n bi̱ la̱t mi̱ bi̱ lät kä ba pek in te kä n-th ɛlɛmɛni̱ kä fib-fib nämbär thekuɛnthi̱./// fibibibn) == fibibn-1) + fibibn-2) + fibibn-3)./// fib fib ((2) == 1 /// fib fib ((1) == 0 /// fib fib ((0) == 0 /// Kä FibFib nämbär thekuɛnthi̱ ɛ thekuɛnthi̱ mi̱ cäät kɛ Fibbonacci thekuɛnthi̱ min ca lat i̱ ɛ jɛn i̱nɔ: /// >>> fibfib(1)
/// 0
/// >>> fibfib(5)
/// 4
/// >>> fibfib(8)
/// 24
fn fibfib(n: isize) -> isize {
","fn fibfib(n: isize) -> isize {
    if n < 0 {
        // Optionally handle negative indices as an error or specific value
        return -1; // Example error indicator
    }
    match n {
        0 => 0,
        1 => 0,
        2 => 1,
        _ => {
            let mut a = 0;
            let mut b = 0;
            let mut c = 1;
            let mut result = 0;
            for _ in 3..=n {
                result = a + b + c;
                a = b;
                b = c;
                c = result;
            }
            result
        }
    }
}","}

fn main() {
    let candidate = fibfib;
    assert_eq!(candidate(2), 1);
    assert_eq!(candidate(1), 0);
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 24);
    assert_eq!(candidate(10), 81);
    assert_eq!(candidate(12), 274);
    assert_eq!(candidate(14), 927);
}
"
HumanEval_64,nus_Latn,rs,"/// Cäät: /// vowel, duŋdɛ ɣöö jɛn kärɔa mi̱ jɛn ɛ guut ri̱e̱e̱t in ca ŋun./// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. ɛn wanɛ mɛ, 'y' ɛ jɛn a /// ɛ rie̱t mi̱ ca mat kä bɛ pek in tekɛ wöwɛlni̱ rɛy thärkdɛ loc.///Cu wargak mi̱ cɔali̱ vowels_count mi̱ naŋɛ ni̱ mi̱ nyooth ni̱ /// >>> vowels_count(String::from(""abcde""))
/// 2
/// >>> vowels_count(String::from(""ACEDY""))
/// 3
fn vowels_count(s: String) -> isize {
","fn vowels_count(s: String) -> isize {
    let vowels = ['a', 'e', 'i', 'o', 'u'];
    let s = s.to_lowercase();
    let mut count = 0;

    for (i, c) in s.chars().enumerate() {
        if vowels.contains(&c) || (c == 'y' && i == s.len() - 1) {
            count += 1;
        }
    }
    
    count
}

fn main() {
    println!(""{}"", vowels_count(String::from(""abcde""))); // Output: 2
    println!(""{}"", vowels_count(String::from(""ACEDY""))); // Output: 3
}","}

fn main() {
    let candidate = vowels_count;
    assert_eq!(candidate(String::from(""abcde"")), 2);
    assert_eq!(candidate(String::from(""Alone"")), 3);
    assert_eq!(candidate(String::from(""key"")), 2);
    assert_eq!(candidate(String::from(""bye"")), 1);
    assert_eq!(candidate(String::from(""keY"")), 2);
    assert_eq!(candidate(String::from(""bYe"")), 1);
    assert_eq!(candidate(String::from(""ACEDY"")), 3);
}
"
HumanEval_65,nus_Latn,rs,"/// Mi̱ ci̱ shift > nämbär di̱ji̱tni̱, bi̱ di̱ji̱tni̱ loc jɔk.///kä luɔ̱cdɛ bɛ ben ɛ la mi̱ la̱t kɛ ɛ la mi̱ ci̱ rɔ de̱e̱ la̱t./// Ci̱ri̱kular i̱thpi̱e̱r di̱jitni̱ kä intɛrjɛr x, i̱thpi̱e̱r di̱jitni̱ ɛ wä kui̱c ɛ wä kui̱c ɛ wä kui̱c./// >>> circular_shift(12, 1)
/// String::from(""21"")
/// >>> circular_shift(12, 2)
/// String::from(""12"")
fn circular_shift(x: isize, shift: isize) -> String {
","fn circular_shift(x: isize, shift: isize) -> String {
    let mut digits: Vec<char> = x.abs().to_string().chars().collect();
    let len = digits.len() as isize;
    
    if shift > len {
        digits.reverse();
    } else {
        digits.rotate_right(shift as usize % len as usize);
    }
    
    digits.into_iter().collect()
}","}

fn main() {
    let candidate = circular_shift;
    assert_eq!(candidate(100, 2), String::from(""001""));
    assert_eq!(candidate(12, 2), String::from(""12""));
    assert_eq!(candidate(97, 8), String::from(""79""));
    assert_eq!(candidate(12, 1), String::from(""21""));
    assert_eq!(candidate(11, 101), String::from(""11""));
}
"
HumanEval_66,nus_Latn,rs,"/// Cäätni̱: ///Kɔɔdni̱ ASCII. ///Cu gɔr i̱thti̱rmin min bi̱ la̱t ɛ la mi̱ ca la̱th rɛy i̱thti̱riŋä kä bi̱ loc ni̱ min ca mat kä tin di̱t kärɔ̱' /// Ta̱a̱ la̱t /// >>> digitSum(String::from(""""))
/// 0
/// >>> digitSum(String::from(""abAB""))
/// 131
/// >>> digitSum(String::from(""abcCd""))
/// 67
/// >>> digitSum(String::from(""helloE""))
/// 69
/// >>> digitSum(String::from(""woArBld""))
/// 131
/// >>> digitSum(String::from(""aAaaaXa""))
/// 153
fn digitSum(s: String) -> isize {
","fn digitSum(s: String) -> isize {
    s.chars()
     .filter(|c| c.is_uppercase())
     .map(|c| c as isize)
     .sum()
}","}

fn main() {
    let candidate = digitSum;
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""abAB"")), 131);
    assert_eq!(candidate(String::from(""abcCd"")), 67);
    assert_eq!(candidate(String::from(""helloE"")), 69);
    assert_eq!(candidate(String::from(""woArBld"")), 131);
    assert_eq!(candidate(String::from(""aAaaaXa"")), 153);
    assert_eq!(candidate(String::from("" How are yOu?"")), 151);
    assert_eq!(candidate(String::from(""You arE Very Smart"")), 327);
}
"
HumanEval_67,nus_Latn,rs,"/// kɛ kui̱ kä min ca lat: /// rɛy tharbët (tharbët) luɔ̱c pek dɛy mango rɛy tharbët./// ci̱ kɛ̈l kɛ̈ɛ̈li̱ kɛnɛ tuɔm kɛnɛ intejeri̱ tin cuŋkɛ ɛ la nämbär in matkɛ kä dɛy /// ɛ pɛl, ɛ thurbiɛɛli, kɛnɛ dɛy mangua̱th. Mi ca thärkɛn ŋun ɛ nyoth nämbär in matkɛ ɛ ///ca kɛ da̱a̱k rɛy thärkä mi̱ tekɛ dɛw ti̱ gööl rɛy thärkä ɛmɔ //Rɛy la̱t ɛmɛ, ba ji̱ ka̱m tha̱a̱ŋ thurɛkä min bi̱ nämbär duŋ tuɔp kɛnɛ aplan nyoth./// >>> fruit_distribution(String::from(""5 apples and 6 oranges""), 19)
/// 8
/// >>> fruit_distribution(String::from(""0 apples and 1 oranges""), 3)
/// 2
/// >>> fruit_distribution(String::from(""2 apples and 3 oranges""), 100)
/// 95
/// >>> fruit_distribution(String::from(""100 apples and 1 oranges""), 120)
/// 19
fn fruit_distribution(s: String, n: isize) -> isize {
","fn fruit_distribution(s: String, n: isize) -> isize {
    let mut parts = s.split_whitespace();
    let apples: isize = parts.next().unwrap().parse().unwrap();
    parts.next(); // skip ""apples""
    parts.next(); // skip ""and""
    let oranges: isize = parts.next().unwrap().parse().unwrap();
    
    n - (apples + oranges)
}

fn main() {
    assert_eq!(fruit_distribution(String::from(""5 apples and 6 oranges""), 19), 8);
    assert_eq!(fruit_distribution(String::from(""0 apples and 1 oranges""), 3), 2);
    assert_eq!(fruit_distribution(String::from(""2 apples and 3 oranges""), 100), 95);
    assert_eq!(fruit_distribution(String::from(""100 apples and 1 oranges""), 120), 19);
    println!(""All test cases passed!"");
}","}

fn main() {
    let candidate = fruit_distribution;
    assert_eq!(candidate(String::from(""5 apples and 6 oranges""), 19), 8);
    assert_eq!(candidate(String::from(""5 apples and 6 oranges""), 21), 10);
    assert_eq!(candidate(String::from(""0 apples and 1 oranges""), 3), 2);
    assert_eq!(candidate(String::from(""1 apples and 0 oranges""), 3), 2);
    assert_eq!(candidate(String::from(""2 apples and 3 oranges""), 100), 95);
    assert_eq!(candidate(String::from(""2 apples and 3 oranges""), 5), 0);
    assert_eq!(candidate(String::from(""1 apples and 100 oranges""), 120), 19);
}
"
HumanEval_68,nus_Latn,rs,"/// Cäät kä 1: /// Mi̱ thiɛlɛ mi̱ ca mat ɛ päär kiɛ bɛktɔr mi̱ ca ŋun ɛ la mi̱ thiɛl luɔt, locni̱ []./// Kä no̱o̱p in ca jiek ba yi̱k loc rɛy bɛktɔr, [tha̱mälth_ba̱li̱ö, ɛ indi̱dhɛthdɛ], /// Mi̱ ca näth ti̱ ŋuan jiek ti̱ tekɛ pe̱k mi̱ tɔt mi̱ päär mi̱ ca jiek, loc ni̱ näth in tekɛ indi̱th in tɔt. ///Kä min ca jiek kä no̱o̱ŋɛ bi̱ cu te ni̱ jɛn no̱o̱ŋä min kuiy ni̱ jɛn kä pa̱r.///Ci̱ la̱tdu ɛ ɣöö bi̱ ji̱n kɛl kä nyin duëli̱ kä bi̱ kɛ loc jɔk./// ""Mi̱ ca ŋun ɛ bɛktɔr mi̱ cuŋ kɛ kui̱ karä jiathä mi̱ tekɛ näön-negɛtib intejeri̱ (nɔŋdho̱n) /// >>> pluck(vec![4, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(vec![1, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(vec![])
/// Vec::<isize>::new()
/// Example 4:
/// >>> pluck(vec![5, 0, 3, 0, 4, 2])
/// vec![0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
fn pluck(arr: Vec<isize>) -> Vec<isize> {
","fn pluck(arr: Vec<isize>) -> Vec<isize> {
    let mut smallest_even: Option<(isize, usize)> = None;

    for (index, &value) in arr.iter().enumerate() {
        if value % 2 == 0 {
            match smallest_even {
                None => smallest_even = Some((value, index)),
                Some((smallest_value, _)) if value < smallest_value => smallest_even = Some((value, index)),
                _ => {}
            }
        }
    }

    match smallest_even {
        Some((value, index)) => vec![value, index as isize],
        None => Vec::new(),
    }
}","}

fn main() {
    let candidate = pluck;
    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);
    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);
    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);
    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);
    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());
}
"
HumanEval_69,nus_Latn,rs,"/// Cäätni̱: /// Mi̱ thiɛlɛ mi̱ ce̱tkɛ ba̱li̱öm ɛmɔ, bɛ loc ɛ la -1./// Kä prekuɛnthi̱ duŋ inteji̱ɛr ɛ nämbär kä min la jɔɔc rɛy bɛktɔr.///dhɔl, kɛnɛ ɣöö jɛn tëkɛ prekuɛnthi̱ min di̱tni̱ jɛn kiɛ päär kɛ min te kä intɛrjɛr kärɔa./// Ca ji̱ moc kɛ ne̱n-bi̱lli̱öm bɛktɔr duŋ puɔthitib intɛrjɛr. Lɔ̱kni̱ intejer in di̱tni̱ jɛn kä min di̱tni̱ jɛn kä /// >>> search(vec![4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(vec![5, 5, 4, 4, 4])
/// -1
fn search(lst: Vec<isize>) -> isize {
","fn search(lst: Vec<isize>) -> isize {
    use std::collections::HashMap;
    
    let mut frequency_map = HashMap::new();
    
    // Count the frequency of each integer in the vector
    for &num in &lst {
        *frequency_map.entry(num).or_insert(0) += 1;
    }
    
    let mut result = -1;
    
    // Iterate over the map to find the greatest integer with a frequency
    // greater than or equal to its value
    for (&num, &freq) in &frequency_map {
        if freq >= num && num > result {
            result = num;
        }
    }
    
    result
}

// Test cases
fn main() {
    assert_eq!(search(vec![4, 1, 2, 2, 3, 1]), 2);
    assert_eq!(search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4]), 3);
    assert_eq!(search(vec![5, 5, 4, 4, 4]), -1);
}","}

fn main() {
    let candidate = search;
    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);
    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);
    assert_eq!(candidate(vec![3, 3]), -1);
    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);
    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);
    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);
    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);
    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);
    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);
    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);
    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);
    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);
    assert_eq!(candidate(vec![1]), 1);
    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);
    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);
    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);
    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);
    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);
    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);
    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);
    assert_eq!(candidate(vec![10]), -1);
    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);
    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);
    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);
    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);
}
"
HumanEval_70,nus_Latn,rs,"/// Cäätni̱: ///kɛ kɔrɛ bi̱ di̱tni̱ jɛn kä intejeri̱ tin ci̱ duɔth, kɛ kɔrɛ bi̱ min tɔt kulɛ te thi̱n.///Kä min la̱tkɛ ɛ la̱a̱t tin kɔ̱ŋ, ɛ mi̱ ci̱ ji̱n ɛ tok kɛ pek in kuiyni̱jɛn, ///Ka̱mkɛ intɛrjiɛri̱ bɛktɔr, bɛktɔr mi̱ loc rɔ rɛy thi̱ärɛ./// >>> strange_sort_list(vec![1, 2, 3, 4])
/// vec![1, 4, 2, 3]
/// >>> strange_sort_list(vec![5, 5, 5, 5])
/// vec![5, 5, 5, 5]
/// >>> strange_sort_list(vec![])
/// Vec::<isize>::new()
fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {
","fn strange_sort_list(mut lst: Vec<isize>) -> Vec<isize> {
    let mut result = Vec::with_capacity(lst.len());
    lst.sort();

    while !lst.is_empty() {
        // Take the smallest element
        if let Some(min) = lst.first().cloned() {
            result.push(min);
            lst.remove(0);
        }
        // Take the largest element
        if let Some(max) = lst.last().cloned() {
            result.push(max);
            lst.pop();
        }
    }

    result
}

fn main() {
    println!(""{:?}"", strange_sort_list(vec![1, 2, 3, 4])); // Output: vec![1, 4, 2, 3]
    println!(""{:?}"", strange_sort_list(vec![5, 5, 5, 5])); // Output: vec![5, 5, 5, 5]
    println!(""{:?}"", strange_sort_list(vec![])); // Output: Vec::<isize>::new()
}","}

fn main() {
    let candidate = strange_sort_list;
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);
    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);
    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);
    assert_eq!(candidate(vec![111111]), vec![111111]);
}
"
HumanEval_71,nus_Latn,rs,"/// Cäät: ///ci̱kɛ diɔ̱ɔ̱k ti̱ kɔ̱ŋ./// Tha̱a̱ŋ diɔ̱k ti̱ti̱ la kɛn ɛ tri̱angle mi̱ lotni̱ ɣöö bi̱ pekdiɛn kulɛ di̱t kä rɛw tin te kui̱c ɛ mɔ./// Mi̱ /ci̱ jɛn bi̱ loc jɔk -1 /// kä di̱ri̱jɛ̈l ɛ mi̱ ca riali̱kä ɛ wä kä 2 decimal pɔnt mi̱ ci̱ thärkäl ɛ la di̱ri̱jɛ̈l mi̱ tekɛ dup ti̱ ŋuan./// Mi̱ ca pek ɛ wä kä kui̱c in diɔ̱k kä ki̱ri̱i̱thi̱li̱ö mi̱ ca ŋun./// >>> triangle_area(3, 4, 5)
/// 6.0
/// >>> triangle_area(1, 2, 10)
/// -1.0
fn triangle_area(a: isize, b: isize, c: isize) -> f64 {
","fn triangle_area(a: isize, b: isize, c: isize) -> f64 {
    if a + b > c && a + c > b && b + c > a {
        let s = (a + b + c) as f64 / 2.0;
        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();
        (area * 100.0).round() / 100.0
    } else {
        -1.0
    }
}

fn main() {
    println!(""{}"", triangle_area(3, 4, 5)); // 6.0
    println!(""{}"", triangle_area(1, 2, 10)); // -1.0
}","}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(3, 4, 5), 6.0);
    assert_eq!(candidate(1, 2, 10), -1.0);
    assert_eq!(candidate(4, 8, 5), 8.18);
    assert_eq!(candidate(2, 2, 2), 1.73);
    assert_eq!(candidate(1, 2, 3), -1.0);
    assert_eq!(candidate(10, 5, 7), 16.25);
    assert_eq!(candidate(2, 6, 3), -1.0);
    assert_eq!(candidate(1, 1, 1), 0.43);
    assert_eq!(candidate(2, 2, 10), -1.0);
}
"
HumanEval_72,nus_Latn,rs,"/// Cäät: /// Ci̱ duɔ̱ɔ̱r q bi̱ ji̱äk mi̱ cɛ päär (ɛ jɛn palindromic bɛktɔr) kɛnɛ ɣöö bi̱ mat ŋɔaani̱kɛ cu kuɛ̈ɛ̈ kiɛ päär kɛ pek in di̱tni̱ jɛn kä de rɔ lot w.///Cu gɔr i̱thpëth mi̱ locrɔ mi̱ ɛ thuɔ̱k mi̱ ci̱ duɔ̱ɔ̱r q bi̱ jiɛɛn, kɛnɛ ɣöö bɛ kac mi̱ dɔ̱ŋ./// >>> will_it_fly(vec![1, 2], 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(vec![3, 2, 3], 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(vec![3, 2, 3], 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(vec![3], 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
fn will_it_fly(q: Vec<isize>, w: isize) -> bool {
","fn will_it_fly(q: Vec<isize>, w: isize) -> bool {
    let sum: isize = q.iter().sum();
    let is_palindromic = q.iter().eq(q.iter().rev());

    is_palindromic && sum <= w
}

fn main() {
    // Test cases
    println!(""{}"", will_it_fly(vec![1, 2], 5)); // false
    println!(""{}"", will_it_fly(vec![3, 2, 3], 1)); // false
    println!(""{}"", will_it_fly(vec![3, 2, 3], 9)); // true
    println!(""{}"", will_it_fly(vec![3], 5)); // true
}","}

fn main() {
    let candidate = will_it_fly;
    assert_eq!(candidate(vec![3, 2, 3], 9), true);
    assert_eq!(candidate(vec![1, 2], 5), false);
    assert_eq!(candidate(vec![3], 5), true);
    assert_eq!(candidate(vec![3, 2, 3], 1), false);
    assert_eq!(candidate(vec![1, 2, 3], 6), false);
    assert_eq!(candidate(vec![5], 5), true);
}
"
HumanEval_73,nus_Latn,rs,"/// Ciee cäät ɛmɛ: /// jɛn kuɛnkɛ ɛ päär jɔkdɛ kɛnɛ nhiamdɛ. rɛy gërä kɛl, deri̱ ɛlɛmɛni̱ gɛr kä ɛlɛmɛni̱ kɔ̱kiɛn./// ba yi̱k gɛr kɛ ɣöö ba bɛktɔr jakä pa̱li̱ndrɔmik. Pa̱li̱ndrɔmik bɛktɔr ɛ bɛktɔr mi̱ bi̱ /// Mi̱ ca ŋun ɛ bɛktɔr arr duŋ intejeri̱, jiekɛ nämbär in kuiyni̱jɛn kä elɛmɛni̱ tin bi̱ /// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(vec![1, 2, 3, 2, 1])
/// 0
fn smallest_change(arr: Vec<isize>) -> isize {
","fn smallest_change(arr: Vec<isize>) -> isize {
    let mut changes = 0;
    let n = arr.len();
    
    for i in 0..n/2 {
        if arr[i] != arr[n - i - 1] {
            changes += 1;
        }
    }
    
    changes
}

// Example usage:
// fn main() {
//     let result = smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6]);
//     println!(""{}"", result); // Outputs: 4
// }","}

fn main() {
    let candidate = smallest_change;
    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);
    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);
    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(vec![0, 1]), 1);
}
"
HumanEval_74,nus_Latn,rs,"/// Cäätni̱ /// mi̱ ci̱ bɛktɔri̱ rɛw tekɛ kɛ pek mi̱ päär kä kar, locni̱ bɛktɔr in nhiam./// nämbär kä kar rɛy thärkäli̱ diaal kä bɛktɔr min kuiyni̱ jɛn kä bɛktɔr in dɔ̱ŋ.///Cu gɔr ɛ la̱t mi̱ nhɔkɛ bɛktɔri̱ rɛw kä thärkdɛ kɛnɛ ɣöö bɛ bɛktɔr mi̱ tekɛ /// >>> total_match(vec![], vec![])
/// Vec::<String>::new()
/// >>> total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""Hi"")])
/// vec![String::from(""hI""), String::from(""Hi"")]
/// >>> total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hi""), String::from(""hi""), String::from(""admin""), String::from(""project"")])
/// vec![String::from(""hi""), String::from(""admin"")]
/// >>> total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")])
/// vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")]
/// >>> total_match(vec![String::from(""4"")], vec![String::from(""1""), String::from(""2""), String::from(""3""), String::from(""4""), String::from(""5"")])
/// vec![String::from(""4"")]
fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {
","fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {
    let char_count = |lst: &Vec<String>| lst.iter().map(|s| s.len()).sum::<usize>();

    if char_count(&lst1) <= char_count(&lst2) {
        lst1
    } else {
        lst2
    }
}

// Example usage
fn main() {
    let result1 = total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""Hi"")]);
    println!(""{:?}"", result1);

    let result2 = total_match(vec![String::from(""4"")], vec![String::from(""1""), String::from(""2""), String::from(""3""), String::from(""4""), String::from(""5"")]);
    println!(""{:?}"", result2);
}","}

fn main() {
    let candidate = total_match;
    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hi""), String::from(""hi"")]), vec![String::from(""hi""), String::from(""hi"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hi""), String::from(""hi""), String::from(""admin""), String::from(""project"")]), vec![String::from(""hi""), String::from(""admin"")]);
    assert_eq!(candidate(vec![String::from(""4"")], vec![String::from(""1""), String::from(""2""), String::from(""3""), String::from(""4""), String::from(""5"")]), vec![String::from(""4"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""Hi"")]), vec![String::from(""hI""), String::from(""Hi"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")]), vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""hi""), String::from(""hii"")]), vec![String::from(""hi""), String::from(""admin"")]);
    assert_eq!(candidate(Vec::<String>::new(), vec![String::from(""this"")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""this"")], Vec::<String>::new()), Vec::<String>::new());
}
"
HumanEval_75,nus_Latn,rs,"/// Cäät: /// Mi̱ ŋa̱cnɛ i̱ (a) ɛ kuiy ni̱ jɛn kä 100. ///ci̱kɛ thuɔ̱ɔ̱k kä /ci̱kɛ thuɔ̱ɔ̱k./// Ca̱p mi̱ la̱tkɛ kɛ ɣöö bɛ loc ɛ la thuɔ̱k mi̱ ca ŋun ɛ nämbär mi̱ ca loc ɛ la mälti̱pli̱kecin duŋ 3 praam nämbäri̱ /// >>> is_multiply_prime(30)
/// true
/// 30 = 2 * 3 * 5
fn is_multiply_prime(a: isize) -> bool {
","fn is_multiply_prime(a: isize) -> bool {
    fn is_prime(n: isize) -> bool {
        if n <= 1 {
            return false;
        }
        if n <= 3 {
            return true;
        }
        if n % 2 == 0 || n % 3 == 0 {
            return false;
        }
        let mut i = 5;
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 {
                return false;
            }
            i += 6;
        }
        true
    }

    if a < 2 {
        return false;
    }

    let mut primes = Vec::new();
    for i in 2..a {
        if is_prime(i) {
            primes.push(i);
        }
    }

    let p_len = primes.len();
    for i in 0..p_len {
        for j in i..p_len {
            for k in j..p_len {
                if primes[i] * primes[j] * primes[k] == a {
                    return true;
                }
            }
        }
    }
    false
}","}

fn main() {
    let candidate = is_multiply_prime;
    assert_eq!(candidate(5), false);
    assert_eq!(candidate(30), true);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), false);
    assert_eq!(candidate(125), true);
    assert_eq!(candidate(105), true);
    assert_eq!(candidate(126), false);
    assert_eq!(candidate(729), false);
    assert_eq!(candidate(891), false);
    assert_eq!(candidate(1001), true);
}
"
HumanEval_76,nus_Latn,rs,"/// Ciee cäät ɛmɛ: ///x ɛ mi̱ ca la̱t ɛ thi̱a̱k kä n mi̱ n**int=x /// buɔ̱m duŋ n kɛnɛ kac rɛy gua̱thni̱ kɔ̱kiɛn./// La̱tdu ɛ ɣöö bi̱ la̱t mi̱ ci̱ thuɔ̱k loc mi̱ ci̱ nämbär ɛ x ɛ thi̱mpil /// >>> is_simple_power(1, 4)
/// true
/// >>> is_simple_power(2, 2)
/// true
/// >>> is_simple_power(8, 2)
/// true
/// >>> is_simple_power(3, 2)
/// false
/// >>> is_simple_power(3, 1)
/// false
/// >>> is_simple_power(5, 3)
/// false
fn is_simple_power(x: isize, n: isize) -> bool {
","fn is_simple_power(x: isize, n: isize) -> bool {
    if x <= 0 || n <= 0 {
        return false;
    } else if x == 1 {
        return true;
    } else if n == 1 {
        return x == 1;
    }

    let mut power_n = n;
    while power_n < x {
        power_n *= n;
    }
    power_n == x
}

fn main() {
    println!(""{}"", is_simple_power(1, 4)); // true
    println!(""{}"", is_simple_power(2, 2)); // true
    println!(""{}"", is_simple_power(8, 2)); // true
    println!(""{}"", is_simple_power(3, 2)); // false
    println!(""{}"", is_simple_power(3, 1)); // false
    println!(""{}"", is_simple_power(5, 3)); // false
}","}

fn main() {
    let candidate = is_simple_power;
    assert_eq!(candidate(16, 2), true);
    assert_eq!(candidate(143214, 16), false);
    assert_eq!(candidate(4, 2), true);
    assert_eq!(candidate(9, 3), true);
    assert_eq!(candidate(16, 4), true);
    assert_eq!(candidate(24, 2), false);
    assert_eq!(candidate(128, 4), false);
    assert_eq!(candidate(12, 6), false);
    assert_eq!(candidate(1, 1), true);
    assert_eq!(candidate(1, 12), true);
}
"
HumanEval_77,nus_Latn,rs,"/// Cäätni̱: ///Nötë: deri̱ jɛ car i̱ ɛn inpuut bɛ te thi̱n ni̱ ciaaŋ./// mi̱ jɛn ini̱gɛr ɛ kuub duŋ intejer nämbärä./// Ca̱p mi̱ la̱tkɛ kɛ ɣöö ba intɛrjɛr a naŋ kä bɛ loc ni̱ thuɔ̱k /// >>> iscube(1)
/// true
/// >>> iscube(2)
/// false
/// >>> iscube(-1)
/// true
/// >>> iscube(64)
/// true
/// >>> iscube(0)
/// true
/// >>> iscube(180)
/// false
fn iscube(a: isize) -> bool {
","fn iscube(a: isize) -> bool {
    if a < 0 {
        // For negative numbers, take the cube root of the absolute value.
        let cube_root = (-a as f64).cbrt();
        let rounded_cube = cube_root.round() as isize;
        rounded_cube * rounded_cube * rounded_cube == a
    } else {
        let cube_root = (a as f64).cbrt();
        let rounded_cube = cube_root.round() as isize;
        rounded_cube * rounded_cube * rounded_cube == a
    }
}

fn main() {
    println!(""{}"", iscube(1));   // true
    println!(""{}"", iscube(2));   // false
    println!(""{}"", iscube(-1));  // true
    println!(""{}"", iscube(64));  // true
    println!(""{}"", iscube(0));   // true
    println!(""{}"", iscube(180)); // false
}","}

fn main() {
    let candidate = iscube;
    assert_eq!(candidate(1), true);
    assert_eq!(candidate(2), false);
    assert_eq!(candidate(-1), true);
    assert_eq!(candidate(64), true);
    assert_eq!(candidate(180), false);
    assert_eq!(candidate(1000), true);
    assert_eq!(candidate(0), true);
    assert_eq!(candidate(1729), false);
}
"
HumanEval_78,nus_Latn,rs,"/// Cäätni̱: ///kä bi̱ thi̱i̱mbuɔli̱ A,B,C,D,E,F ni̱ ciaaŋ la gɔ̱rkɛ kɛ wargak mi̱ di̱i̱t./// Note: deri̱ jɛ car i̱ ɛn inpuut bɛ a mi̱ lot rɔ ni̱ ciaaŋ kiɛ bɛ te baaŋ, /// B (= decimal 11), D (= decimal 13). ///Ci̱kɛ bi̱ lɛ wɔ̱ kɛ ɣöö ba pek di̱jitni̱ ti̱ti̱ ŋa̱c: 2, 3, 5, 7, ///Ci̱ nämbäri̱ Präm kɛn 2, 3, 5, 7, 11, 13, 17,... /// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. /// min di̱tni̱ jɛn kä 1 min /ci̱kɛ la pi̱löda̱k duŋ näci̱ral nämbäri̱ rɛw tin kuiyni̱kɛn).///ci̱ dijitni̱ tin la praam (praam nämbär, kiɛ praam, ɛ näci̱ral nämbär /// ɛ nämbär Ɣɛdhadethimɔl ɛ la mi̱ la̱tkɛ ɛ la thi̱rɛnd kä kuɛnɛ nämbär Ɣɛdhadethimɔl /// Ca ji̱ la̱t ɣöö bi̱ la̱t mi̱ bi̱ ji̱ luäk kulɛ gɔ̱r./// >>> hex_key(String::from(""AB""))
/// 1
/// >>> hex_key(String::from(""1077E""))
/// 2
/// >>> hex_key(String::from(""ABED1A33""))
/// 4
/// >>> hex_key(String::from(""123456789ABCDEF0""))
/// 6
/// >>> hex_key(String::from(""2020""))
/// 2
fn hex_key(num: String) -> isize {
","fn hex_key(num: String) -> isize {
    let prime_hex_chars = vec!['2', '3', '5', '7', 'B', 'D'];
    num.chars()
        .filter(|c| prime_hex_chars.contains(c))
        .count() as isize
}","}

fn main() {
    let candidate = hex_key;
    assert_eq!(candidate(String::from(""AB"")), 1);
    assert_eq!(candidate(String::from(""1077E"")), 2);
    assert_eq!(candidate(String::from(""ABED1A33"")), 4);
    assert_eq!(candidate(String::from(""2020"")), 2);
    assert_eq!(candidate(String::from(""123456789ABCDEF0"")), 6);
    assert_eq!(candidate(String::from(""112233445566778899AABBCCDDEEFF00"")), 12);
}
"
HumanEval_79,nus_Latn,rs,"/// Cäätni̱: ///Kɛn wargakni̱ tin ca mat thi̱n kɛ ɣöö bi̱ kɛ wɔ̱ läät kɛ ta̱a̱ in ca gɔ̱r thi̱n./// Bɛ tekɛ kaar ti̱ ŋuan ti̱ ba cu ŋa̱c 'db' kä tukdɛ kɛnɛ guutdɛ kä thɛrnd./// nämbär. Kɛn karkɛtɛri̱ diaal rɛy thi̱rɛndä bi̱ kɛnɛ '0' kiɛ '1'./// binary format. La̱t in la̱tkɛ ba yi̱k loc ɛ la mi̱ la bi̱ la̱t ɛ la binary /// Ca ji̱ bi̱ ka̱m nämbär rɛy thurɛ decimal kä la̱tdu ɛ ɣöö bi̱ jɛ loc kä /// >>> decimal_to_binary(15)
/// String::from(""db1111db"")
/// >>> decimal_to_binary(32)
/// String::from(""db100000db"")
fn decimal_to_binary(decimal: isize) -> String {
","fn decimal_to_binary(decimal: isize) -> String {
    let binary_string = format!(""{:b}"", decimal);
    format!(""db{}db"", binary_string)
}

fn main() {
    // Example usage
    let binary_15 = decimal_to_binary(15);
    let binary_32 = decimal_to_binary(32);
    println!(""{}"", binary_15); // Outputs: db1111db
    println!(""{}"", binary_32); // Outputs: db100000db
}","}

fn main() {
    let candidate = decimal_to_binary;
    assert_eq!(candidate(0), String::from(""db0db""));
    assert_eq!(candidate(32), String::from(""db100000db""));
    assert_eq!(candidate(103), String::from(""db1100111db""));
    assert_eq!(candidate(15), String::from(""db1111db""));
}
"
HumanEval_80,nus_Latn,rs,"/// Ciee cäät ɛmɛ: /// Ci̱kɛrɔŋ ɛ mi̱ la̱t kɛ jɛ mi̱ ci̱ pekdɛ ɛ mi̱ kuiy ni̱ jɛn kä 3 kɛnɛ ɣöö kɛn i̱thti̱ri̱öni̱ diaal tin guɔ̱rkɛ rɔ̱ laa dääk kɛn rɔ̱ ///La̱tdu ɛ ɣöö bi̱ ji̱n ɛ ŋa̱c i̱ ci̱ la̱t in la̱tkɛ ɛ la̱t mi̱ /ci̱ gɔaa./// Ca ji̱ moc yi̱k mi̱ /ci̱ rɔ bi̱ lot. /// >>> is_happy(String::from(""a""))
/// false
/// >>> is_happy(String::from(""aa""))
/// false
/// >>> is_happy(String::from(""abcd""))
/// true
/// >>> is_happy(String::from(""aabb""))
/// false
/// >>> is_happy(String::from(""adb""))
/// true
/// >>> is_happy(String::from(""xyy""))
/// false
fn is_happy(s: String) -> bool {
","fn is_happy(s: String) -> bool {
    if s.len() < 3 {
        return false;
    }

    let chars: Vec<char> = s.chars().collect();
    for i in 0..(chars.len() - 2) {
        if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] || chars[i + 1] == chars[i + 2] {
            return false;
        }
    }

    true
}

fn main() {
    println!(""{}"", is_happy(String::from(""a""))); // false
    println!(""{}"", is_happy(String::from(""aa""))); // false
    println!(""{}"", is_happy(String::from(""abcd""))); // true
    println!(""{}"", is_happy(String::from(""aabb""))); // false
    println!(""{}"", is_happy(String::from(""adb""))); // true
    println!(""{}"", is_happy(String::from(""xyy""))); // false
}","}

fn main() {
    let candidate = is_happy;
    assert_eq!(candidate(String::from(""a"")), false);
    assert_eq!(candidate(String::from(""aa"")), false);
    assert_eq!(candidate(String::from(""abcd"")), true);
    assert_eq!(candidate(String::from(""aabb"")), false);
    assert_eq!(candidate(String::from(""adb"")), true);
    assert_eq!(candidate(String::from(""xyy"")), false);
    assert_eq!(candidate(String::from(""iopaxpoi"")), true);
    assert_eq!(candidate(String::from(""iopaxioi"")), false);
}
"
HumanEval_81,nus_Latn,rs,"/// Cäät: /// 0.0 E /// > 0.0 D- /// > 0.7 D /// > 1.0 D+ /// > 1.3 C- /// > 1.7 C /// > 2.0 C+ /// > 2.3 B- /// > 2.7 B /// > 3.0 B+ /// > 3.3 A- /// > 3.7 A /// 4.0 A+ /// GPA. ɛ̈t in ca gɔ̱r /// ɛ pa̱ŋcin mi̱ dee be̱n raar kɛ ba̱th kä ba̱th in caa lɛp kɛ duɔ̱ɔ̱p in caa la̱t kɛ jɛ: /// Cɛ ji̱ moc kɛ GPA kɛ kui̱i̱ tha̱a̱ŋ gɔ̱a̱a̱ri̱ kä bi̱ ji̱n ɛ gɔ̱r.///Ci̱ riɛk ɛ kɛl kärɔa, jɛn cɛ kɔd in lätdɛ kɛ ɣöö bɛ di̱l gɔ̱r ji̱ bath.///kä ji̱ gɔ̱rä. Ŋi̱i̱cdɛ cɛ la̱t ɛ la algöri̱thi̱mdɛ kɛ ɣöö bɛ di̱t./// Ci̱e̱ jɛn juɔk in jɔak kä themi̱thɛr kä ŋi̱i̱c bɛ ji̱ ŋieec ka̱m tiit /// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])
/// vec![String::from(""A+""), String::from(""B""), String::from(""C-""), String::from(""C""), String::from(""A-"")]
fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {
","fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {
    grades.into_iter().map(|gpa| {
        match gpa {
            4.0 => String::from(""A+""),
            v if v > 3.7 => String::from(""A""),
            v if v > 3.3 => String::from(""A-""),
            v if v > 3.0 => String::from(""B+""),
            v if v > 2.7 => String::from(""B""),
            v if v > 2.3 => String::from(""B-""),
            v if v > 2.0 => String::from(""C+""),
            v if v > 1.7 => String::from(""C""),
            v if v > 1.3 => String::from(""C-""),
            v if v > 1.0 => String::from(""D+""),
            v if v > 0.7 => String::from(""D""),
            v if v > 0.0 => String::from(""D-""),
            _ => String::from(""E""),
        }
    }).collect()
}","}

fn main() {
    let candidate = numerical_letter_grade;
    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from(""A+""), String::from(""B""), String::from(""C-""), String::from(""C""), String::from(""A-"")]);
    assert_eq!(candidate(vec![1.2]), vec![String::from(""D+"")]);
    assert_eq!(candidate(vec![0.5]), vec![String::from(""D-"")]);
    assert_eq!(candidate(vec![0.0]), vec![String::from(""E"")]);
    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from(""D""), String::from(""D-""), String::from(""C-""), String::from(""B""), String::from(""B+"")]);
    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from(""E""), String::from(""D-"")]);
}
"
HumanEval_82,nus_Latn,rs,"/// Cäätni̱ ///kä bär ɛ mi̱ la praam nämbär kiɛ ɛ kac mi̱ dɔ̱ŋ /// Ca̱p mi̱ la̱tkɛ kɛ ɣöö bi̱ la̱t ɛ naŋkɛ i̱thtirŋ kɛnɛ ɣöö bɛ loc i̱ ɛ thuɔ̱k mi̱ ci̱ i̱thtirŋ ɛ /// >>> prime_length(String::from(""Hello""))
/// true
/// >>> prime_length(String::from(""abcdcba""))
/// true
/// >>> prime_length(String::from(""kittens""))
/// true
/// >>> prime_length(String::from(""orange""))
/// false
fn prime_length(string: String) -> bool {
","fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn prime_length(string: String) -> bool {
    let length = string.len();
    is_prime(length)
}

// Example usage
fn main() {
    println!(""{}"", prime_length(String::from(""Hello""))); // true
    println!(""{}"", prime_length(String::from(""abcdcba""))); // true
    println!(""{}"", prime_length(String::from(""kittens""))); // true
    println!(""{}"", prime_length(String::from(""orange""))); // false
}","}

fn main() {
    let candidate = prime_length;
    assert_eq!(candidate(String::from(""Hello"")), true);
    assert_eq!(candidate(String::from(""abcdcba"")), true);
    assert_eq!(candidate(String::from(""kittens"")), true);
    assert_eq!(candidate(String::from(""orange"")), false);
    assert_eq!(candidate(String::from(""wow"")), true);
    assert_eq!(candidate(String::from(""world"")), true);
    assert_eq!(candidate(String::from(""MadaM"")), true);
    assert_eq!(candidate(String::from(""Wow"")), true);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""HI"")), true);
    assert_eq!(candidate(String::from(""go"")), true);
    assert_eq!(candidate(String::from(""gogo"")), false);
    assert_eq!(candidate(String::from(""aaaaaaaaaaaaaaa"")), false);
    assert_eq!(candidate(String::from(""Madam"")), true);
    assert_eq!(candidate(String::from(""M"")), false);
    assert_eq!(candidate(String::from(""0"")), false);
}
"
HumanEval_83,nus_Latn,rs,"/// ɛ mi̱ la thuɔ̱k kä intejeri̱ tin tokɛ kiɛ ɛ guutdiɛn kɛ 1./// Mi̱ ca ŋun ɛ la mi̱ tekɛ puɔthtip intejiɛr n, locni̱ nämbäri̱ tin te kä n-dhi̱jit fn starts_one_ends(n: isize) -> isize {
","fn starts_one_ends(n: isize) -> isize {
    if n <= 0 {
        return 0;
    }
    if n == 1 {
        return 1; // only '1' satisfies the condition for a single-digit
    }

    // Consider numbers starting with '1' (1XXXX...)
    let start_with_one = 9isize.pow((n-1) as u32);

    // Consider numbers ending with '1' (...XXXX1)
    let end_with_one = 9isize.pow((n-1) as u32);
    
    // Consider numbers both starting and ending with '1' and check overlaps (1XXX1)
    let both_start_end_one = 9isize.pow((n-2) as u32);

    // Total numbers starting or ending with '1'
    start_with_one + end_with_one - both_start_end_one
}

fn main() {
    // Example usage:
    let n = 3;
    println!(""Count of n-digit numbers starting or ending with 1: {}"", starts_one_ends(n));
}","}

fn main() {
    let candidate = starts_one_ends;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(2), 18);
    assert_eq!(candidate(3), 180);
    assert_eq!(candidate(4), 1800);
    assert_eq!(candidate(5), 18000);
}
"
HumanEval_84,nus_Latn,rs,"/// Cäätdɛ /// Mi̱ ca ŋun ɛ la mi̱ tekɛ puɔthtip intejiɛr N, locni̱ mat di̱jitni̱kɛ rɛy bainairi̱. /// >>> solve(1000)
/// String::from(""1"")
/// >>> solve(150)
/// String::from(""110"")
/// >>> solve(147)
/// String::from(""1100"")
/// Variables:
/// @N integer
/// Constraints: 0 ≤ N ≤ 10000.
/// Output:
/// a string of binary number
fn solve(N: isize) -> String {
","fn solve(N: isize) -> String {
    let sum_of_digits: isize = N
        .to_string()
        .chars()
        .map(|c| c.to_digit(10).unwrap() as isize)
        .sum();
    
    format!(""{:b}"", sum_of_digits)
}","}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(1000), String::from(""1""));
    assert_eq!(candidate(150), String::from(""110""));
    assert_eq!(candidate(147), String::from(""1100""));
    assert_eq!(candidate(333), String::from(""1001""));
    assert_eq!(candidate(963), String::from(""10010""));
}
"
HumanEval_85,nus_Latn,rs,"/// Cäätni̱: /// Mi̱ ca ŋun ɛ la mi̱ /ci̱ la duŋ intɛrjiɛr ba̱kdiɛn. Läthni̱ ɛlɛmɛni̱ pa̱r tin te kä indi̱dhi̱i̱tni̱ ti̱ /ci̱ tɔt./// >>> add(vec![4, 2, 6, 7])
/// 2
fn add(lst: Vec<isize>) -> isize {
","fn add(lst: Vec<isize>) -> isize {
    lst.iter()
        .enumerate()
        .filter(|(i, _)| i % 2 == 1) // select odd indices
        .map(|(_, &x)| x) // get the values at odd indices
        .filter(|&x| x % 2 == 0) // filter even values
        .sum() // sum the values
}","}

fn main() {
    let candidate = add;
    assert_eq!(candidate(vec![4, 88]), 88);
    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);
    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);
    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);
}
"
HumanEval_86,nus_Latn,rs,"/// Ciee cäät ɛmɛ: /// Note: Bi̱diöö ɛ ciɛk-ciɛk mi̱ la̱tkɛ ɛ ji̱n, bi̱diöö ɛ ciɛk-ciɛk mi̱ la̱tkɛ ɛ ji̱n, bi̱diöö ɛ ciɛk-ciɛk mi̱ la̱tkɛ ɛ ji̱n./// rɔɔdɛ re̱p kä rɔɔdɛ re̱p kä rɔɔdɛ ɛ la mi̱ ci̱ rɔ re̱p./// caa kɛ loc ɛ riet mi̱ pay tuɔɔk mi̱ ci̱ kɛn ciɛŋ diaal ti̱ caa riali̱kä rɛy /// Ci̱öt in ca riali̱kä kä ci̱öt, ɛ ci̱öt mi̱ ci̱ötkɛ diaal (tin dääk kɛ kam)///Cu gɔr ɛ la̱t mi̱ naŋkɛ i̱thtriŋ kä locni̱ i̱thtriŋ mi̱ ca riali̱kä./// >>> anti_shuffle(String::from(""Hi""))
/// String::from(""Hi"")
/// >>> anti_shuffle(String::from(""hello""))
/// String::from(""ehllo"")
/// >>> anti_shuffle(String::from(""Hello World!!!""))
/// String::from(""Hello !!!Wdlor"")
fn anti_shuffle(s: String) -> String {
","fn anti_shuffle(s: String) -> String {
    let mut result = String::new();
    let mut word = String::new();

    for c in s.chars() {
        if c.is_whitespace() {
            if !word.is_empty() {
                let mut chars: Vec<char> = word.chars().collect();
                chars.sort_unstable();
                result.push_str(&chars.into_iter().collect::<String>());
                word.clear();
            }
            result.push(c);
        } else {
            word.push(c);
        }
    }

    if !word.is_empty() {
        let mut chars: Vec<char> = word.chars().collect();
        chars.sort_unstable();
        result.push_str(&chars.into_iter().collect::<String>());
    }

    result
}

fn main() {
    // Example usages:
    println!(""{}"", anti_shuffle(String::from(""Hi"")));              // ""Hi""
    println!(""{}"", anti_shuffle(String::from(""hello"")));           // ""ehllo""
    println!(""{}"", anti_shuffle(String::from(""Hello World!!!"")));  // ""Hello !!!Wdlor""
}","}

fn main() {
    let candidate = anti_shuffle;
    assert_eq!(candidate(String::from(""Hi"")), String::from(""Hi""));
    assert_eq!(candidate(String::from(""hello"")), String::from(""ehllo""));
    assert_eq!(candidate(String::from(""number"")), String::from(""bemnru""));
    assert_eq!(candidate(String::from(""abcd"")), String::from(""abcd""));
    assert_eq!(candidate(String::from(""Hello World!!!"")), String::from(""Hello !!!Wdlor""));
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""Hi. My name is Mister Robot. How are you?"")), String::from("".Hi My aemn is Meirst .Rboot How aer ?ouy""));
}
"
HumanEval_87,nus_Latn,rs,"/// Cäätni̱: ///Kä bä, ca̱a̱rkɛ römdiɛn kɛ römdiɛn kɛ kɔlömni̱ kɛ ɣöö bi̱kɛ wä piny./// Cuɔ̱ɔ̱ni̱ tin caa la̱th piny kɛ nhiam kɛ duɔ̱ɔ̱p mi̱ wä nhial.///kɛl tuple ɛ jɛn kɔrdi̱nɛt - (rɛy, kɔlömni̱), ɛ tokɛ kä 0./// kɛnɛ locdɛ kɛ bendɛ kä tupulɛ, [(x1, y1), (x2, y2) ...] ce̱tkɛ mi̱ cie jɛn /// Mi̱ ca ŋun i̱th, kɛnɛ intejeri̱ x, jiekni̱ intejeri̱ x rɛy bɛktɔr, ///rɛy kɛl dɔ̱ŋ bɛ tekɛ nämbär mi̱ göl kä kɔlömni̱./// min cäät kɛ matrik, duŋni̱ ɣöö, /cɛ ce̱tkɛ matrikni̱, /// Ca ji̱ moc data ni̱ ti̱ 2 dimɛncinal, cie ɛ bɛktɔri̱ ti̱ ca rɔ̱ mat, /// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)
/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(vec![], 1)
/// Vec::<(isize, isize)>::new()
/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)
/// vec![(2, 2)]
fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {
","fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {
    let mut result = Vec::new();

    for (row_index, row) in lst.iter().enumerate() {
        let mut found_indices: Vec<isize> = row.iter()
            .enumerate()
            .filter(|&(_, &value)| value == x)
            .map(|(col_index, _)| col_index as isize)
            .collect();

        found_indices.sort_by(|a, b| b.cmp(a)); // Sort column indices in descending order

        for col_index in found_indices {
            result.push((row_index as isize, col_index));
        }
    }

    result
}","}

fn main() {
    let candidate = get_row;
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);
    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);
}
"
HumanEval_88,nus_Latn,rs,"/// Cäätni̱: /// */cuɛ gɛr kä ba̱a̱dɛ min ca ŋun./// Cuɔŋ: ///kiɛ däkdɛ kɛ jɛ kɛ ɣöö bɛ wä piny mi̱ ci̱ mat ((kɛl jäkni̱ kä min nhiam, kɛ jäkni̱ kä min jɔak) ɛ mi̱ päär./// bi̱ ji̱n bɛktɔr mi̱ ca ŋun käp kɛ duɔ̱ɔ̱p mi̱ wä nhial mi̱ ci̱ mat ((kä index ba̱li̱ö min nhiam, kä index ba̱li̱ö min jɔak) ɛ mi̱ /ci̱ päär, /// Mi̱ ca ŋun ɛ bɛktɔr mi̱ /ci̱ɛɛ negɛtib intejeri̱, locni̱kɛ ɛ la kɔrs duŋ bɛktɔr in ca ŋun kɛ kɔr kä mi̱ ca kɛ da̱a̱k, /// >>> sort_array(vec![])
/// Vec::<isize>::new()
/// >>> sort_array(vec![5])
/// vec![5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])
/// vec![0, 1, 2, 3, 4, 5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])
/// vec![6, 5, 4, 3, 2, 1, 0]
fn sort_array(array: Vec<isize>) -> Vec<isize> {
","fn sort_array(array: Vec<isize>) -> Vec<isize> {
    if array.is_empty() {
        return Vec::<isize>::new();
    }

    let first = array.first().unwrap_or(&0);
    let last = array.last().unwrap_or(&0);
    let sum = first + last;

    let mut sorted_array = array.clone();
    if sum % 2 == 0 {
        sorted_array.sort_by(|a, b| b.cmp(a)); // Descending order
    } else {
        sorted_array.sort(); // Ascending order
    }

    sorted_array
}

fn main() {
    // Test cases
    println!(""{:?}"", sort_array(vec![])); // Vec::<isize>::new()
    println!(""{:?}"", sort_array(vec![5])); // vec![5]
    println!(""{:?}"", sort_array(vec![2, 4, 3, 0, 1, 5])); // vec![0, 1, 2, 3, 4, 5]
    println!(""{:?}"", sort_array(vec![2, 4, 3, 0, 1, 5, 6])); // vec![6, 5, 4, 3, 2, 1, 0]
}","}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5]), vec![5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);
    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);
    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);
    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);
}
"
HumanEval_89,nus_Latn,rs,"/// Ciee cäät ɛmɛ: ///ci̱kɛ bi̱ lɛ wɔ̱ piny ɛ rɛw gua̱thni̱ da̱ŋ rɛw./// Ɛn alpabet ba yi̱k loc kɛ duɔ̱ɔ̱p mi̱ bi̱ lɛ̈t ɛ la /// la loc ɛ la mi̱ ca gɔ̱r ɛ la ki̱i̱thtɛr mi̱ ca rɔ̱ gɛr kä alpɛth. /// Ji̱kɛ pa̱ŋciin ɛ ci̱kɛ rɔ̱ɔ̱diɛn kuëŋ kä bi̱ kɛn ku lɛ naŋ ɛ la argɔmɛni̱ kɛnɛ /// >>> encrypt(String::from(""hi""))
/// String::from(""lm"")
/// >>> encrypt(String::from(""asdfghjkl""))
/// String::from(""ewhjklnop"")
/// >>> encrypt(String::from(""gf""))
/// String::from(""kj"")
/// >>> encrypt(String::from(""et""))
/// String::from(""ix"")
fn encrypt(s: String) -> String {
","fn encrypt(s: String) -> String {
    s.chars()
        .map(|c| {
            if c.is_ascii_lowercase() {
                let offset = (c as u8 - b'a' + 4) % 26;
                (b'a' + offset) as char
            } else {
                c
            }
        })
        .collect()
}","}

fn main() {
    let candidate = encrypt;
    assert_eq!(candidate(String::from(""hi"")), String::from(""lm""));
    assert_eq!(candidate(String::from(""asdfghjkl"")), String::from(""ewhjklnop""));
    assert_eq!(candidate(String::from(""gf"")), String::from(""kj""));
    assert_eq!(candidate(String::from(""et"")), String::from(""ix""));
    assert_eq!(candidate(String::from(""faewfawefaewg"")), String::from(""jeiajeaijeiak""));
    assert_eq!(candidate(String::from(""hellomyfriend"")), String::from(""lippsqcjvmirh""));
    assert_eq!(candidate(String::from(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")), String::from(""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""));
    assert_eq!(candidate(String::from(""a"")), String::from(""e""));
}
"
HumanEval_90,nus_Latn,rs,"/// / /ci̱kɛ bi̱ loc mi̱ /thiɛlɛ mi̱ ce̱tkɛ mi̱ ci̱ tuɔɔk.///Cu wargak mi̱ dɔ̱ŋ mi̱ dɔ̱ŋ_mi̱ tɔt (next_smallest) mi̱ locni̱ ɛlɛmɛni̱ rɛw tin tɔt kä bɛktɔr.///Ca ji̱ moc kɛ intɛrjiɛr bɛktɔr./// >>> next_smallest(vec![1, 2, 3, 4, 5])
/// Some(2)
/// >>> next_smallest(vec![5, 1, 4, 3, 2])
/// Some(2)
/// >>> next_smallest(vec![])
/// None
/// >>> next_smallest(vec![1, 1])
/// None
fn next_smallest(lst: Vec<isize>) -> Option<isize> {
","fn next_smallest(lst: Vec<isize>) -> Option<isize> {
    if lst.len() < 2 {
        return None;
    }
    let mut unique_elements: Vec<isize> = lst.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect();
    if unique_elements.len() < 2 {
        return None;
    }
    unique_elements.sort();
    Some(unique_elements[1])
}

fn main() {
    println!(""{:?}"", next_smallest(vec![1, 2, 3, 4, 5])); // Some(2)
    println!(""{:?}"", next_smallest(vec![5, 1, 4, 3, 2])); // Some(2)
    println!(""{:?}"", next_smallest(vec![])); // None
    println!(""{:?}"", next_smallest(vec![1, 1])); // None
}","}

fn main() {
    let candidate = next_smallest;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));
    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));
}
"
HumanEval_91,nus_Latn,rs,"/// Ciee cäät ɛmɛ: /// Thäntipni̱ ba kɛ yiath piny ɛ '.', '?' kiɛ '!'. ///ci̱kɛ bi̱ lɛ̈p kɛ duɔ̱ɔ̱r. /Ci̱kɛ bi̱ lɛ̈p kɛ duɔ̱ɔ̱r mi̱ bi̱ tok kɛ rie̱t i̱ ""Ɣän"".///Ca ji̱ bi̱ ka̱m rie̱t ti̱ ŋuan, kä bi̱ la̱tdu ɛ ɣöö bi̱ pekdiɛn kuɛn./// >>> is_bored(String::from(""Hello world""))
/// 0
/// >>> is_bored(String::from(""The sky is blue. The sun is shining. I love this weather""))
/// 1
fn is_bored(S: String) -> isize {
","fn is_bored(S: String) -> isize {
    S.split(|c| c == '.' || c == '?' || c == '!')
        .filter(|sentence| sentence.trim_start().starts_with(""I""))
        .count() as isize
}","}

fn main() {
    let candidate = is_bored;
    assert_eq!(candidate(String::from(""Hello world"")), 0);
    assert_eq!(candidate(String::from(""Is the sky blue?"")), 0);
    assert_eq!(candidate(String::from(""I love It !"")), 1);
    assert_eq!(candidate(String::from(""bIt"")), 0);
    assert_eq!(candidate(String::from(""I feel good today. I will be productive. will kill It"")), 2);
    assert_eq!(candidate(String::from(""You and I are going for a walk"")), 0);
}
"
HumanEval_92,nus_Latn,rs,"/// Cäätni̱ /// Jiekɛ i̱ jiekɛ i̱ /ci̱kɛ thuɔ̱ɔ̱k rɛy kä ti̱ kɔ̱kiɛn./// Ji̱äk ɛ thuɔ̱k mi̱ kɛl kä nämbäri̱ ɛ mi̱ päär kɛ mat nämbäri̱ da̱ŋ rɛw kɔ̱kiɛn, kɛnɛ nämbäri̱ diaal ɛ intejeri̱./// Ji̱n bi̱ la̱t mi̱ naŋ ni̱ nämbäri̱ da̱ŋ diɔ̱k./// >>> any_int(5, 2, 7)
/// true
/// >>> any_int(3, 2, 2)
/// false
/// >>> any_int(3, -2, 1)
/// true
/// >>> any_int(3.6, -2.2, 2)
/// false
fn any_int(x: f64, y: f64, z: f64) -> bool {
","fn any_int(x: f64, y: f64, z: f64) -> bool {
    // Check if all the numbers are integers
    if x.fract() == 0.0 && y.fract() == 0.0 && z.fract() == 0.0 {
        // Convert f64 to i64 because they are integers
        let xi = x as i64;
        let yi = y as i64;
        let zi = z as i64;

        // Check if any one of the numbers is equal to the sum of the other two
        xi == yi + zi || yi == xi + zi || zi == xi + yi
    } else {
        false
    }
}

fn main() {
    // Examples
    println!(""{}"", any_int(5.0, 2.0, 7.0)); // true
    println!(""{}"", any_int(3.0, 2.0, 2.0)); // false
    println!(""{}"", any_int(3.0, -2.0, 1.0)); // true
    println!(""{}"", any_int(3.6, -2.2, 2.0)); // false
}","}

fn main() {
    let candidate = any_int;
    assert_eq!(candidate(2.0, 3.0, 1.0), true);
    assert_eq!(candidate(2.5, 2.0, 3.0), false);
    assert_eq!(candidate(1.5, 5.0, 3.5), false);
    assert_eq!(candidate(2.0, 6.0, 2.0), false);
    assert_eq!(candidate(4.0, 2.0, 2.0), true);
    assert_eq!(candidate(2.2, 2.2, 2.2), false);
    assert_eq!(candidate(-4.0, 6.0, 2.0), true);
    assert_eq!(candidate(2.0, 1.0, 1.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), false);
}
"
HumanEval_93,nus_Latn,rs,"/// Cäätni̱: /// Cuɔ̱ŋni̱ warɛgakni̱ kärɔ̱./// ɛ jɔw rɛy ali̱phabëth Liŋli̱th.///kä thok in te wargak thi̱n min ci̱ jɔɔc gua̱th da̱ŋ rɛw nhiamdɛ ɛn nɔmɔ /// duɔ̱ɔ̱p in laa gɛrkɛ ni̱ bok ti̱ tä kɛ luɔt, laa jɛ laa gɛrkɛ ni̱ rieet ti̱ tä kɛ jɔw rɛy ///Cu gɔr ni̱ pa̱ŋcin mi̱ naŋ ruac, kä bɛ jɛ kuëŋ rɛy kä mi̱ ce̱tkɛ mi̱ cie /// >>> encode(String::from(""test""))
/// String::from(""TGST"")
/// >>> encode(String::from(""This is a message""))
/// String::from(""tHKS KS C MGSSCGG"")
fn encode(message: String) -> String {
","fn encode(message: String) -> String {
    message.chars().map(|c| {
        match c {
            'a' => 'C',
            'e' => 'G',
            'i' => 'K',
            'o' => 'Q',
            'u' => 'W',
            'A' => 'c',
            'E' => 'g',
            'I' => 'k',
            'O' => 'q',
            'U' => 'w',
            'a'..='z' => c.to_ascii_uppercase(),
            'A'..='Z' => c.to_ascii_lowercase(),
            _ => c,
        }
    }).collect()
}","}

fn main() {
    let candidate = encode;
    assert_eq!(candidate(String::from(""TEST"")), String::from(""tgst""));
    assert_eq!(candidate(String::from(""Mudasir"")), String::from(""mWDCSKR""));
    assert_eq!(candidate(String::from(""YES"")), String::from(""ygs""));
    assert_eq!(candidate(String::from(""This is a message"")), String::from(""tHKS KS C MGSSCGG""));
    assert_eq!(candidate(String::from(""I DoNt KnOw WhAt tO WrItE"")), String::from(""k dQnT kNqW wHcT Tq wRkTg""));
}
"
HumanEval_94,nus_Latn,rs,"/// Cäätni̱: /// Ji̱n go̱o̱ri ɣöö bi̱ min di̱tni̱ jɛn kä bɛ nööŋ ɛ la mi̱ di̱i̱t kä bi̱ loc ni̱ pek di̱jitni̱kɛ.///Ca ji̱ moc kɛ intɛrjiɛr bɛktɔr./// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])
/// 7
fn skjkasdkd(lst: Vec<isize>) -> isize {
","fn is_prime(n: isize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn digit_sum(n: isize) -> isize {
    n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum()
}

fn skjkasdkd(lst: Vec<isize>) -> isize {
    match lst.into_iter().filter(is_prime).max() {
        Some(max_prime) => digit_sum(max_prime),
        None => 0,
    }
}","}

fn main() {
    let candidate = skjkasdkd;
    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);
    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);
    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);
    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);
    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);
    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);
    assert_eq!(candidate(vec![8191]), 19);
    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);
    assert_eq!(candidate(vec![127, 97, 8192]), 10);
}
"
HumanEval_95,nus_Latn,rs,"use std::collections::HashMap;

/// Cäätni̱: /// La̱t ba loc ni̱ mi̱ ji̱äk mi̱ ca ŋun ɛ Ɣathmap ɛ mi̱ te baaŋ. /// mi̱ ci̱kɛ te thi̱n kiɛ bi̱ kɛn diaal ɛ thi̱rndɛrni̱ ti̱ te thi̱rndɛrni̱ ti̱ di̱t, mi̱ /ci̱kɛ bi̱ loc ɛ la kac./// Mi̱ ca ŋun ɛ la HashMap, bɛ loc ni̱ thuɔ̱k mi̱ ci̱ ki̱i̱ni̱ diaal ɛ ti̱ te kä ci̱ rɔ̱ mat kɛ piny./// >>> check_dict_case(HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""b""), String::from(""banana""))]))
/// true
/// >>> check_dict_case(HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""A""), String::from(""banana"")), (String::from(""B""), String::from(""banana""))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from(""a""), String::from(""apple"")), (8, String::from(""banana"")), (String::from(""a""), String::from(""apple""))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from(""Name""), String::from(""John"")), (String::from(""Age""), String::from(""36"")), (String::from(""City""), String::from(""Houston""))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from(""STATE""), String::from(""NC"")), (String::from(""ZIP""), String::from(""12345""))]))
/// true
fn check_dict_case(dict: HashMap<String, String>) -> bool {
","use std::collections::HashMap;

fn check_dict_case(dict: HashMap<String, String>) -> bool {
    if dict.is_empty() {
        return false;
    }

    let mut lowercase = true;
    let mut uppercase = true;

    for key in dict.keys() {
        if !key.chars().all(|c| c.is_lowercase()) {
            lowercase = false;
        }
        if !key.chars().all(|c| c.is_uppercase()) {
            uppercase = false;
        }
    }

    lowercase || uppercase
}

fn main() {
    let dict1 = HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""b""), String::from(""banana""))]);
    assert_eq!(check_dict_case(dict1), true);

    let dict2 = HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""A""), String::from(""banana"")), (String::from(""B""), String::from(""banana""))]);
    assert_eq!(check_dict_case(dict2), false);

    let dict3 = HashMap::from([(String::from(""STATE""), String::from(""NC"")), (String::from(""ZIP""), String::from(""12345""))]);
    assert_eq!(check_dict_case(dict3), true);

    let dict4 = HashMap::from([(String::from(""Name""), String::from(""John"")), (String::from(""Age""), String::from(""36"")), (String::from(""City""), String::from(""Houston""))]);
    assert_eq!(check_dict_case(dict4), false);
}","}

fn main() {
    let candidate = check_dict_case;
    assert_eq!(candidate(HashMap::from([(String::from(""p""), String::from(""pineapple"")), (String::from(""b""), String::from(""banana""))])), true);
    assert_eq!(candidate(HashMap::from([(String::from(""p""), String::from(""pineapple"")), (String::from(""A""), String::from(""banana"")), (String::from(""B""), String::from(""banana""))])), false);
    assert_eq!(candidate(HashMap::from([(String::from(""p""), String::from(""pineapple"")), (String::from(""5""), String::from(""banana"")), (String::from(""a""), String::from(""apple""))])), false);
    assert_eq!(candidate(HashMap::from([(String::from(""Name""), String::from(""John"")), (String::from(""Age""), String::from(""36"")), (String::from(""City""), String::from(""Houston""))])), false);
    assert_eq!(candidate(HashMap::from([(String::from(""STATE""), String::from(""NC"")), (String::from(""ZIP""), String::from(""12345""))])), true);
    assert_eq!(candidate(HashMap::from([(String::from(""fruit""), String::from(""Orange"")), (String::from(""taste""), String::from(""Sweet""))])), true);
    assert_eq!(candidate(HashMap::from([])), false);
}
"
HumanEval_96,nus_Latn,rs,"/// cäätdɛ: /// intejeri̱ tin la praam nämbäri̱ kɛnɛ tin kuiyni̱kɛn kä n. /// La̱t mi̱ la̱tkɛ kɛ ɣöö ba nämbär mi̱ /ci̱ mɔ a negɛtib mi̱ ca mat kä bi̱ ben raar ɛ la bɛktɔr duŋ n in nhiam /// >>> count_up_to(5)
/// vec![2, 3]
/// >>> count_up_to(11)
/// vec![2, 3, 5, 7]
/// >>> count_up_to(0)
/// Vec::<isize>::new()
/// >>> count_up_to(20)
/// vec![2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(1)
/// Vec::<isize>::new()
/// >>> count_up_to(18)
/// vec![2, 3, 5, 7, 11, 13, 17]
fn count_up_to(n: isize) -> Vec<isize> {
","fn count_up_to(n: isize) -> Vec<isize> {
    let mut primes = Vec::new();

    for num in 2..n {
        let mut is_prime = true;

        for divisor in 2..=((num as f64).sqrt() as isize) {
            if num % divisor == 0 {
                is_prime = false;
                break;
            }
        }

        if is_prime {
            primes.push(num);
        }
    }

    primes
}

fn main() {
    println!(""{:?}"", count_up_to(5)); // vec![2, 3]
    println!(""{:?}"", count_up_to(11)); // vec![2, 3, 5, 7]
    println!(""{:?}"", count_up_to(0)); // Vec::<isize>::new()
    println!(""{:?}"", count_up_to(20)); // vec![2, 3, 5, 7, 11, 13, 17, 19]
    println!(""{:?}"", count_up_to(1)); // Vec::<isize>::new()
    println!(""{:?}"", count_up_to(18)); // vec![2, 3, 5, 7, 11, 13, 17]
}","}

fn main() {
    let candidate = count_up_to;
    assert_eq!(candidate(5), vec![2, 3]);
    assert_eq!(candidate(6), vec![2, 3, 5]);
    assert_eq!(candidate(7), vec![2, 3, 5]);
    assert_eq!(candidate(10), vec![2, 3, 5, 7]);
    assert_eq!(candidate(0), Vec::<isize>::new());
    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);
    assert_eq!(candidate(1), Vec::<isize>::new());
    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}
"
HumanEval_97,nus_Latn,rs,"/// Cäätni̱: /// Ca̱r in ca la̱th thi̱n ɛ la mi̱ la thuɔ̱k ni̱ ciaaŋ./// kä min la̱tkɛ ɛ nämbäri̱ yunitni̱kiɛn./// Lätdɛ kɛ pek mi̱ naŋɛ intejeri̱ rɛw kä loc ɛ /// >>> multiply(148, 412)
/// 16
/// >>> multiply(19, 28)
/// 72
/// >>> multiply(2020, 1851)
/// 0
/// >>> multiply(14, -15)
/// 20
fn multiply(a: isize, b: isize) -> isize {
","fn multiply(a: isize, b: isize) -> isize {
    let unit_digit_a = (a % 10).abs();
    let unit_digit_b = (b % 10).abs();
    unit_digit_a * unit_digit_b
}","}

fn main() {
    let candidate = multiply;
    assert_eq!(candidate(148, 412), 16);
    assert_eq!(candidate(19, 28), 72);
    assert_eq!(candidate(2020, 1851), 0);
    assert_eq!(candidate(14, -15), 20);
    assert_eq!(candidate(76, 67), 42);
    assert_eq!(candidate(17, 27), 49);
    assert_eq!(candidate(0, 1), 0);
    assert_eq!(candidate(0, 0), 0);
}
"
HumanEval_98,nus_Latn,rs,"/// Ciee cäät ɛmɛ: /// Mi̱ ca thärkdɛ ŋun, kuɛn nämbär duŋ bɛ̈ɛ̈r-bɛ̈ɛ̈r tin di̱t rɛy i̱thpëthi̱th./// >>> count_upper(String::from(""aBCdEf""))
/// 1
/// >>> count_upper(String::from(""abcdefg""))
/// 0
/// >>> count_upper(String::from(""dBBE""))
/// 0
fn count_upper(s: String) -> isize {
","fn count_upper(s: String) -> isize {
    s.chars().enumerate().filter(|(i, c)| {
        *i % 2 == 0 && matches!(c, 'A' | 'E' | 'I' | 'O' | 'U')
    }).count() as isize
}","}

fn main() {
    let candidate = count_upper;
    assert_eq!(candidate(String::from(""aBCdEf"")), 1);
    assert_eq!(candidate(String::from(""abcdefg"")), 0);
    assert_eq!(candidate(String::from(""dBBE"")), 0);
    assert_eq!(candidate(String::from(""B"")), 0);
    assert_eq!(candidate(String::from(""U"")), 1);
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""EEEE"")), 2);
}
"
HumanEval_99,nus_Latn,rs,"/// Cäätni̱ ///kɛ rɛw tin te rɛy intɛrjiɛr,kä cu thärkäli̱ jɛ ɛ wä kä dhɛrö./// kɛnɛ locni̱ intejiɛr in thia̱k kɛ jɛ. Mi̱ ci̱ nämbär ɛ päär gua̱th in te thi̱n /// Ji̱kɛ pa̱ŋciin mi̱ naŋkɛ ba̱li̱ö (thtiring) mi̱ cuŋkɛ ɛ la nämbär /// >>> closest_integer(String::from(""10""))
/// 10
/// >>> closest_integer(String::from(""15.3""))
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer(""14.5"") should
/// return 15 and closest_integer(""-14.5"") should return -15.
fn closest_integer(value: String) -> isize {
","fn closest_integer(value: String) -> isize {
    let num: f64 = value.parse().expect(""Invalid number format"");
    if num.fract().abs() == 0.5 {
        if num.is_sign_positive() {
            num.ceil() as isize
        } else {
            num.floor() as isize
        }
    } else {
        num.round() as isize
    }
}

// Example usage
fn main() {
    println!(""{}"", closest_integer(String::from(""10"")));   // Output: 10
    println!(""{}"", closest_integer(String::from(""15.3""))); // Output: 15
    println!(""{}"", closest_integer(String::from(""14.5""))); // Output: 15
    println!(""{}"", closest_integer(String::from(""-14.5""))); // Output: -15
}","}

fn main() {
    let candidate = closest_integer;
    assert_eq!(candidate(String::from(""10"")), 10);
    assert_eq!(candidate(String::from(""14.5"")), 15);
    assert_eq!(candidate(String::from(""-15.5"")), -16);
    assert_eq!(candidate(String::from(""15.3"")), 15);
    assert_eq!(candidate(String::from(""0"")), 0);
}
"
HumanEval_100,nus_Latn,rs,"/// Cäätni̱: /// i ɛ nämbär pämni̱ rɛy kä ti̱e̱c (i+1)./// Läthni̱ nämbär pämni̱ rɛy kä bɛl kɛ̈l kɛ̈ɛ̈li̱ rɛy bɛktɔr, gua̱th in bi̱ ɛlɛmɛni̱ ɛ wɔ̱ kä indi̱dhɛth /// - ɛ nämbär mi̱ dɔ̱ŋ mi̱ päär mi̱ n ɛ päär. /// - ɛ nämbär mi̱ dɔ̱ŋ mi̱ /ci̱ päär mi̱ n ɛ mi̱ /ci̱ päär. /// Ci̱ pek pämni̱ rɛy la̱t in dɔ̱ŋ de ben: ///Thi̱n nhiamdiɛn tekɛ pääm ti̱ n.//Mi̱ ca ŋun ɛ la mi̱ tekɛ nämbär mi̱ thuɔ̱k mi̱ n, bi̱ ji̱n ɛ la̱t kɛ pääm ti̱ tekɛ n gua̱a̱thni̱ ti̱ gööl./// >>> make_a_pile(3)
/// vec![3, 5, 7]
fn make_a_pile(n: isize) -> Vec<isize> {
","fn make_a_pile(n: isize) -> Vec<isize> {
    let mut pile = Vec::new();
    let mut current = n;
    
    for _ in 0..n {
        pile.push(current);
        current = if n % 2 == 1 {
            current + 2
        } else {
            current + 2
        };
    }
    
    pile
}

fn main() {
    let level = make_a_pile(3);
    println!(""{:?}"", level);
}","}

fn main() {
    let candidate = make_a_pile;
    assert_eq!(candidate(3), vec![3, 5, 7]);
    assert_eq!(candidate(4), vec![4, 6, 8, 10]);
    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);
    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);
    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);
}
"
HumanEval_101,nus_Latn,rs,"/// Ciee cäät ɛmɛ: /// kɛ däkdɛ kä rieet kɛnɛ locdɛ kɛ duɔ̱ɔ̱r mi̱ ca la̱t ɛ rieet.//Bi̱ ji̱n ɛ ji̱n bi̱ ruac mi̱ bi̱ rɔ da̱a̱k kɛ kɔma kiɛ i̱thpëth./// >>> words_string(String::from(""Hi, my name is John""))
/// vec![String::from(""Hi""), String::from(""my""), String::from(""name""), String::from(""is""), String::from(""John"")]
/// >>> words_string(String::from(""One, two, three, four, five, six""))
/// vec![String::from(""One""), String::from(""two""), String::from(""three""), String::from(""four""), String::from(""five""), String::from(""six"")]
fn words_string(s: String) -> Vec<String> {
","fn words_string(s: String) -> Vec<String> {
    s.split(|c: char| c.is_whitespace() || c == ',')
        .filter(|word| !word.is_empty())
        .map(String::from)
        .collect()
}","}

fn main() {
    let candidate = words_string;
    assert_eq!(candidate(String::from(""Hi, my name is John"")), vec![String::from(""Hi""), String::from(""my""), String::from(""name""), String::from(""is""), String::from(""John"")]);
    assert_eq!(candidate(String::from(""One, two, three, four, five, six"")), vec![String::from(""One""), String::from(""two""), String::from(""three""), String::from(""four""), String::from(""five""), String::from(""six"")]);
    assert_eq!(candidate(String::from(""Hi, my name"")), vec![String::from(""Hi""), String::from(""my""), String::from(""name"")]);
    assert_eq!(candidate(String::from(""One,, two, three, four, five, six,"")), vec![String::from(""One""), String::from(""two""), String::from(""three""), String::from(""four""), String::from(""five""), String::from(""six"")]);
    assert_eq!(candidate(String::from("""")), Vec::<String>::new());
    assert_eq!(candidate(String::from(""ahmed     , gamal"")), vec![String::from(""ahmed""), String::from(""gamal"")]);
}
"
HumanEval_102,nus_Latn,rs,"/// Ciee cäät ɛmɛ: ///thiɛlɛ nämbär mi̱ cie nɔ, kä ba pa̱ŋcin loc ɛ -1/// ɛ jɛn in di̱tni̱jɛn kä ɛ mi̱ matkɛ ɛ la intejiɛr mi̱ te rɛy gua̱th in te [x,y] thi̱n. Mi̱ /// La̱t ɛmɛ naŋɛ nämbäri̱ rɛw ti̱ puci̱tip (positive) x kɛnɛ y kä lockɛ ni̱ /// >>> choose_num(12, 15)
/// 14
/// >>> choose_num(13, 12)
/// -1
fn choose_num(x: isize, y: isize) -> isize {
","fn choose_num(x: isize, y: isize) -> isize {
    let (start, end) = if x < y { (x, y) } else { (y, x) };
    for n in (start..=end).rev() {
        if n % 2 == 0 {
            return n;
        }
    }
    -1
}

fn main() {
    println!(""{}"", choose_num(12, 15)); // 14
    println!(""{}"", choose_num(13, 12)); // -1
}","}

fn main() {
    let candidate = choose_num;
    assert_eq!(candidate(12, 15), 14);
    assert_eq!(candidate(13, 12), -1);
    assert_eq!(candidate(33, 12354), 12354);
    assert_eq!(candidate(5234, 5233), -1);
    assert_eq!(candidate(6, 29), 28);
    assert_eq!(candidate(27, 10), -1);
    assert_eq!(candidate(7, 7), -1);
    assert_eq!(candidate(546, 546), 546);
}
"
HumanEval_104,nus_Latn,rs,"/// Ciee cäät ɛmɛ: ///Nöt: Ba̱l in ca loc ɛ bɛc ba kɛ da̱a̱k kɛ ɣöö bi̱ rɔ rep.///ci̱kɛ ti̱ ŋuan ti̱ /thiɛl nämbär mi̱ matkɛ./// Mi̱ ca jɛ ŋun ɛ bɛktɔr mi̱ tekɛ puci̱tib intejeri̱ x. bi̱ jäkni̱ baktɔr mi̱ ca riali̱kä kä kɛn diaal /// >>> unique_digits(vec![15, 33, 1422, 1])
/// vec![1, 15, 33]
/// >>> unique_digits(vec![152, 323, 1422, 10])
/// Vec::<isize>::new()
fn unique_digits(x: Vec<isize>) -> Vec<isize> {
","fn unique_digits(x: Vec<isize>) -> Vec<isize> {
    let mut result: Vec<isize> = x.into_iter()
        .filter(|&num| {
            num.to_string().chars().all(|c| {
                match c {
                    '0' | '2' | '4' | '6' | '8' => false,
                    _ => true,
                }
            })
        })
        .collect();
    result.sort();
    result
}","}

fn main() {
    let candidate = unique_digits;
    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);
    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());
    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);
    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);
}
"
HumanEval_105,nus_Latn,rs,"/// Ciee cäät ɛmɛ: /// ""Kɛl"", ""Kä rɛw"", ""Kä Diɔ̱ɔ̱k"", ""Kä Ŋuaan"", ""Kä Bädäk"", ""Kä Bäkɛl"", ""Kä bärɔw"", ""Kä Bädäk"", ""Kä Däk"".///cuɔ̱ɔ̱rɛ bɛc kä bɛc in bi̱ ben raar kä bɛc, kä bɛ di̱jitni̱ diaal gɛr kɛ ci̱ötdɛ min lot rɔ kä /// Mi̱ ca ŋun ɛ bɛktɔr duŋ intejeri̱, ba intejeri̱ thɔɔri̱ tin te kam 1 kɛnɛ 9 ɛ matkɛ, /// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])
/// vec![String::from(""Eight""), String::from(""Five""), String::from(""Four""), String::from(""Three""), String::from(""Two""), String::from(""Two""), String::from(""One""), String::from(""One"")]
/// If the vector is empty, return an empty vector:
/// >>> by_length(vec![])
/// Vec::<String>::new()
/// If the vector has any strange number ignore it:
/// >>> by_length(vec![1, -1, 55])
/// vec![String::from(""One"")]
fn by_length(arr: Vec<isize>) -> Vec<String> {
","fn by_length(arr: Vec<isize>) -> Vec<String> {
    let digit_names = [
        ""One"", ""Two"", ""Three"", ""Four"", ""Five"", 
        ""Six"", ""Seven"", ""Eight"", ""Nine"",
    ];

    let mut filtered: Vec<isize> = arr.into_iter()
        .filter(|&x| x >= 1 && x <= 9)
        .collect();

    filtered.sort();
    filtered.reverse();

    filtered.into_iter()
        .map(|x| String::from(digit_names[(x - 1) as usize]))
        .collect()
}","}

fn main() {
    let candidate = by_length;
    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(""Eight""), String::from(""Five""), String::from(""Four""), String::from(""Three""), String::from(""Two""), String::from(""Two""), String::from(""One""), String::from(""One"")]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(""One"")]);
    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(""Three""), String::from(""Two""), String::from(""One"")]);
    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(""Nine""), String::from(""Eight""), String::from(""Four"")]);
}
"
HumanEval_106,nus_Latn,rs,"/// Cäät: /// kä paktɔriɔl duŋ i ɛ mi̱ la di̱tni̱ jɛn kä nämbäri̱ tin te kä 1 ɛ wä kä i (1 * 2 * ... * i)./// i bɛ tok kä 1. /// kiɛ mat nämbäri̱ kä 1 ɛ wä kä i mi̱ dɔ̱ŋ. /// kä locdɛ ɛ bɛktɔr mi̱ di̱i̱t n, ce̱tkɛ mi̱ ba pek ɛlɛmɛni̱ kä indi̱th i ɛ ba̱ktɔri̱al duŋ i mi̱ i ɛ pa̱r./// Lätdɛ kɛ pa̱ŋciin f min naŋ n cie parami̱tɛr, /// >>> f(5)
/// vec![1, 2, 6, 24, 15]
fn f(n: isize) -> Vec<isize> {
","fn f(n: isize) -> Vec<isize> {
    fn factorial(x: isize) -> isize {
        (1..=x).product()
    }

    fn sum_up_to(x: isize) -> isize {
        (1..=x).sum()
    }

    (1..=n)
        .map(|i| if i % 2 == 0 { factorial(i) } else { sum_up_to(i) })
        .collect()
}","}

fn main() {
    let candidate = f;
    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);
    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);
    assert_eq!(candidate(1), vec![1]);
    assert_eq!(candidate(3), vec![1, 2, 6]);
}
"
HumanEval_107,nus_Latn,rs,"/// Cäät kä 1: /// intɛgɛr palindrɔmi̱ tin te rɛy gua̱th in te ((1, n), ɛ matkɛ. /// Mi̱ ca ŋun ɛ la mi̱ tekɛ puɔthtip intejiɛr n, locni̱ tuple mi̱ tekɛ nämbär duŋ pari̱ kɛnɛ pa̱rdi̱ /// >>> even_odd_palindrome(3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
fn even_odd_palindrome(n: isize) -> (isize, isize) {
","fn is_palindrome(x: isize) -> bool {
    let s = x.to_string();
    s == s.chars().rev().collect::<String>()
}

fn even_odd_palindrome(n: isize) -> (isize, isize) {
    let mut even_count = 0;
    let mut odd_count = 0;
    
    for i in 1..=n {
        if is_palindrome(i) {
            if i % 2 == 0 {
                even_count += 1;
            } else {
                odd_count += 1;
            }
        }
    }
    
    (even_count, odd_count)
}","}

fn main() {
    let candidate = even_odd_palindrome;
    assert_eq!(candidate(123), (8, 13));
    assert_eq!(candidate(12), (4, 6));
    assert_eq!(candidate(3), (1, 2));
    assert_eq!(candidate(63), (6, 8));
    assert_eq!(candidate(25), (5, 6));
    assert_eq!(candidate(19), (4, 6));
    assert_eq!(candidate(9), (4, 5));
    assert_eq!(candidate(1), (0, 1));
}
"
HumanEval_108,nus_Latn,rs,"/// c.d. -123 cɛ di̱jitni̱ -1, 2 kɛnɛ 3 thany./// Mi̱ ci̱ nämbär ɛ mi̱negɛtib, kä ɛn di̱jit in nhiam in ca la̱th thi̱n bɛ cu te ni̱ jɛn kɛ negɛtib: /// nämbär ɛlɛmɛni̱ tin te di̱jitni̱kiɛn kɛɛl > 0. ///Cu wargak mi̱ cɔali̱ count_nums mi̱ naŋkɛ intɛrjɛr kä locni̱ /// >>> count_nums(vec![])
/// 0
/// >>> count_nums(vec![-1, 11, -11])
/// 1
/// >>> count_nums(vec![1, 1, 2])
/// 3
fn count_nums(arr: Vec<isize>) -> isize {
","fn count_nums(arr: Vec<isize>) -> isize {
    arr.into_iter()
        .filter(|&num| {
            let mut n = num;
            let mut sum = 0;
            let mut is_first_digit = true;

            while n != 0 {
                let digit = if is_first_digit {
                    is_first_digit = false;
                    n % 10
                } else {
                    (n % 10).abs()
                };
                sum += digit;
                n /= 10;
            }
            sum > 0
        })
        .count() as isize
}","}

fn main() {
    let candidate = count_nums;
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![-1, -2, 0]), 0);
    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);
    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);
    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);
    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);
    assert_eq!(candidate(vec![0, 1]), 1);
    assert_eq!(candidate(vec![1]), 1);
}
"
HumanEval_109,nus_Latn,rs,"/// Ciee cäät ɛmɛ: ///Nöt: Kä bɛc in ca ŋun ba kɛ ŋun i̱ bɛ tekɛ ɛlɛmɛni̱ ti̱ gööl.//Mi̱ ca ŋun ɛ bɛktɔr ɛ mi̱ te baaŋ bɛ loc ni̱ thuɔ̱k.///ci̱kɛ bi̱ loc ɛ la thuɔ̱ɔ̱k kiɛ bi̱ kɛ loc ɛ la kac./// Mi̱ jɛn lotdɛ rɔ kɛ ɣöö ba pektɔr in ca riali̱kä jiek kɛ la̱tdiɛn in te nhial ɛ la̱t /// kä tuk gua̱th rɛy bɛktɔr i.e. 0th indi̱dhɛth. /// gua̱thdɛ rɛy duɔ̱p in cuŋ. Kä ɛlɛmɛni̱ tin jɔak kä bɛktɔr ba kɛ naŋ kä /// Kɛl mi̱ la̱tkɛ kɛ ɣöö ba cuɔ̱ŋ ɛ la̱t mi̱ lotni̱ ɣöö ba ŋɔaani̱ diaal tin te rɛy bɛktɔrä gɛɛr ɛ kɛl.///Ca ji̱ nhök ɣöö bi̱ la̱t ɛ wä kui̱c ɛ nyɔk kɛ lätni̱dɛ kɛ pek in go̱o̱ri̱./// kä min ba la̱t kä bɛ thöp ɛ bɛc kä bɛc in ca ŋun: /// jɛn lotdɛ rɔ kɛ ɣöö ba bɛ̈c bɛ̈ɛ̈c mi̱ la̱tkɛ kɛ duɔ̱ɔ̱p mi̱ /ci̱ wä piny kɛ la̱tdiɛn /// nämbäri̱ rɛy bɛktɔrä ba kɛ riali̱kä kɛ duɔ̱ɔ̱r mi̱ ci̱ rɔ lot. la̱tdu ɛ ɣöö bi̱ ji̱n ɛ ŋa̱c mi̱ ɛ ///Kɔn ta̱nɛ kɛ ba̱ktɔr 'arr' duŋ N intejeri̱ arr[1], arr[2], ..., arr[N]./// >>> move_one_ball(vec![3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given vector.
/// >>> move_one_ball(vec![3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// vector by performing any number of right shift operations.
fn move_one_ball(arr: Vec<isize>) -> bool {
","fn move_one_ball(arr: Vec<isize>) -> bool {
    if arr.is_empty() {
        return true; // An empty array is already considered sorted.
    }
    
    let mut break_point = 0;
    let mut break_found = false;
    let len = arr.len();

    for i in 0..len {
        if arr[i] > arr[(i + 1) % len] {
            if break_found {
                return false;  // Found more than one break point, not possible.
            }
            break_point = i + 1;
            break_found = true;
        }
    }
    
    // After finding a single break point, simulate the right shift by 'break_point'
    for i in 0..len {
        if arr[(break_point + i) % len] > arr[(break_point + i + 1) % len] {
            return false; // Not sorted in non-decreasing order with this shift.
        }
    }
    
    true
}

// Example usages:

// This will return true, as we can shift twice to sort it.
assert_eq!(move_one_ball(vec![3, 4, 5, 1, 2]), true);

// This will return false, as we can't sort this by any number of shifts.
assert_eq!(move_one_ball(vec![3, 5, 4, 1, 2]), false);","}

fn main() {
    let candidate = move_one_ball;
    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);
    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);
    assert_eq!(candidate(vec![4, 3, 1, 2]), false);
    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
}
"
HumanEval_110,nus_Latn,rs,"/// Ciee cäät ɛmɛ: ///Mi /ciɛ jɛn, locni̱ ""ƔËY"". ///kä ɛlɛmɛni̱ diaal kä lst1 kɛ ɣöö bi̱kɛ a päär, luɔ̱c ""YƐƐ""./// Mi̱ jɛn lotdɛ rɔ kɛ ɣöö ba ɛlɛmɛni̱ gɛɛr kam lst1 kɛnɛ lst2 kɛ ɣöö ba la̱t ɛ la mi̱ bi̱ rɔ lot kɛ jɛ///Thiɛlɛ mi̱ ca thɛm kä nämbär in ba la̱th thi̱n kam lst1 kɛnɛ lst2./// kamdiɛn kɛ la̱tdiɛn lst1 ɛ bɛc mi̱ la duŋ nämbäri̱ pa̱r kärɔa./// kä ŋäcɛ mi̱ jɛn lotdɛ rɔ kɛ ɣöö bɛ la̱t ɛ la mi̱ loc rɔ kä ɛlɛmɛni̱ //Rɛy ri̱e̱e̱tni̱ ti̱ti̱, bi̱ ji̱n lät kɛ pa̱ŋcin mi̱ naŋɛ bɛktɔri̱ nämbäri̱ rɛw, /// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])
/// String::from(""YES"")
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])
/// String::from(""NO"")
/// It is assumed that the input vectors will be non-empty.
fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {
","fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {
    let mut even_in_lst2 = false;
    for &num in &lst2 {
        if num % 2 == 0 {
            even_in_lst2 = true;
            break;
        }
    }

    if even_in_lst2 {
        for &num in &lst1 {
            if num % 2 != 0 {
                return String::from(""YES"");
            }
        }
        return String::from(""YES"");
    }

    String::from(""NO"")
}

fn main() {
    // Example cases
    println!(""{}"", exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])); // ""YES""
    println!(""{}"", exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])); // ""NO""
}","}

fn main() {
    let candidate = exchange;
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(""YES""));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(""NO""));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(""YES""));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(""YES""));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(""NO""));
    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(""NO""));
    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from(""YES""));
}
"
HumanEval_111,nus_Latn,rs,"use std::collections::HashMap;

/// Cäät: //Mi̱ ci̱ warɛgakni̱ ti̱ ŋuan te kɛ mi̱ cäät, locni̱kɛ diaal./// kä wargak mi̱ caa nyɔk kɛ loc kä tä kɛ pek mi̱ päär. /// Mi̱ ca ŋun ɛ la i̱thtiring mi̱ cuŋkɛ ɛ la i̱thti̱ri̱ tin tɔatni̱ tin caa da̱a̱k ɛ kam, bi̱ HashMap loc /// >>> histogram(String::from(""a b c""))
/// HashMap::from([(String::from(""a""), 1), (String::from(""b""), 1), (String::from(""c""), 1)])
/// >>> histogram(String::from(""a b b a""))
/// HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])
/// >>> histogram(String::from(""a b c a b""))
/// HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])
/// >>> histogram(String::from(""b b b b a""))
/// HashMap::from([(String::from(""b""), 4)])
/// >>> histogram(String::from(""""))
/// HashMap::from([])
fn histogram(test: String) -> HashMap<String, isize> {
","use std::collections::HashMap;

fn histogram(test: String) -> HashMap<String, isize> {
    let mut counts: HashMap<String, isize> = HashMap::new();
    let mut max_count = 0;

    for letter in test.split_whitespace() {
        let count = counts.entry(letter.to_string()).or_insert(0);
        *count += 1;
        if *count > max_count {
            max_count = *count;
        }
    }

    counts.retain(|_, &mut val| val == max_count);
    counts
}

fn main() {
    let result = histogram(String::from(""a b c""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""a""), 1), (String::from(""b""), 1), (String::from(""c""), 1)])

    let result = histogram(String::from(""a b b a""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])

    let result = histogram(String::from(""a b c a b""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])

    let result = histogram(String::from(""b b b b a""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""b""), 4)])

    let result = histogram(String::from(""""));
    println!(""{:?}"", result); // HashMap::from([])
}","}

fn main() {
    let candidate = histogram;
    assert_eq!(candidate(String::from(""a b b a"")), HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)]));
    assert_eq!(candidate(String::from(""a b c a b"")), HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)]));
    assert_eq!(candidate(String::from(""a b c d g"")), HashMap::from([(String::from(""a""), 1), (String::from(""b""), 1), (String::from(""c""), 1), (String::from(""d""), 1), (String::from(""g""), 1)]));
    assert_eq!(candidate(String::from(""r t g"")), HashMap::from([(String::from(""r""), 1), (String::from(""t""), 1), (String::from(""g""), 1)]));
    assert_eq!(candidate(String::from(""b b b b a"")), HashMap::from([(String::from(""b""), 4)]));
    assert_eq!(candidate(String::from(""r t g"")), HashMap::from([(String::from(""r""), 1), (String::from(""t""), 1), (String::from(""g""), 1)]));
    assert_eq!(candidate(String::from("""")), HashMap::from([]));
    assert_eq!(candidate(String::from(""a"")), HashMap::from([(String::from(""a""), 1)]));
}
"
HumanEval_112,nus_Latn,rs,"/// Cäätdɛ /// Ji̱n bi̱ yi̱k loc ni̱ tuple mi̱ te kä min bi̱ ben raar kä bi̱ thuɔ̱k/ji̱ääk kɛ ɣöö ba kuɛn.///Ci̱kɛ bi̱ɛl mi̱ cɔali̱ palindrɔm mi̱ ci̱kɛ kuɛn ɛ päär kɛ jɔkdɛ kɛnɛ nhiamdɛ.///kɛ kɔrɛ ba guic mi̱ ci̱ min bi̱ ben raar ɛ pa̱li̱ndrɔm./// Ca kɔn moc kɛ bi̱i̱ni̱ rɛw ti̱ cɔali̱ s kɛnɛ c, bi̱i̱ kɛn ciɛŋ diaal tin tä rɛy s tin päär kɛ ciɛŋ tin tä rɛy c woc./// Ta̱a̱ la̱t /// >>> reverse_delete(String::from(""abcde""), String::from(""ae""))
/// (String::from(""bcd""), false)
/// >>> reverse_delete(String::from(""abcdef""), String::from(""b""))
/// (String::from(""acdef""), false)
/// >>> reverse_delete(String::from(""abcdedcba""), String::from(""ab""))
/// (String::from(""cdedc""), true)
fn reverse_delete(s: String, c: String) -> (String, bool) {
","fn reverse_delete(s: String, c: String) -> (String, bool) {
    // Create a set of characters to delete for quick lookup
    let delete_chars: std::collections::HashSet<char> = c.chars().collect();
    
    // Filter the string, keeping only characters not in the delete set
    let filtered: String = s.chars().filter(|ch| !delete_chars.contains(ch)).collect();
    
    // Check if the filtered string is a palindrome
    let is_palindrome = filtered == filtered.chars().rev().collect::<String>();
    
    // Return the filtered string and whether it's a palindrome
    (filtered, is_palindrome)
}","}

fn main() {
    let candidate = reverse_delete;
    assert_eq!(candidate(String::from(""abcde""), String::from(""ae"")), (String::from(""bcd""), false));
    assert_eq!(candidate(String::from(""abcdef""), String::from(""b"")), (String::from(""acdef""), false));
    assert_eq!(candidate(String::from(""abcdedcba""), String::from(""ab"")), (String::from(""cdedc""), true));
    assert_eq!(candidate(String::from(""dwik""), String::from(""w"")), (String::from(""dik""), false));
    assert_eq!(candidate(String::from(""a""), String::from(""a"")), (String::from(""""), true));
    assert_eq!(candidate(String::from(""abcdedcba""), String::from("""")), (String::from(""abcdedcba""), true));
    assert_eq!(candidate(String::from(""abcdedcba""), String::from(""v"")), (String::from(""abcdedcba""), true));
    assert_eq!(candidate(String::from(""vabba""), String::from(""v"")), (String::from(""abba""), true));
    assert_eq!(candidate(String::from(""mamma""), String::from(""mia"")), (String::from(""""), true));
}
"
HumanEval_113,nus_Latn,rs,"/// duŋ di̱jitni̱ tin /ci̱ tɔt rɛy i̱thtring kä inpuut. /// i kä inpuut thärkɛnt. "" gua̱th in bi̱ i̱thki̱ri̱öni̱ diaal ba kɛ gɛr ɛ nämbär /// Ɛlɛmɛni̱ i̱thpöd bɛ yi̱k ɛ la nämbär ɛlɛmɛni̱ tin /ci̱ tɔ̱ a kɛl rɛy /// Mi̱ ca ŋun ɛ bɛktɔr mi̱ la thi̱rndɛr, gua̱th in bi̱ thi̱rndɛr kɛl ɛ naŋ ni̱ di̱jitni̱ kärɔ̱, bi̱ bɛktɔr loc./// >>> odd_count(vec![String::from(""1234567"")])
/// vec![String::from(""the number of odd elements 4n the str4ng 4 of the 4nput."")]
/// >>> odd_count(vec![String::from(""3""), String::from(""11111111"")])
/// vec![String::from(""the number of odd elements 1n the str1ng 1 of the 1nput.""), String::from(""the number of odd elements 8n the str8ng 8 of the 8nput."")]
fn odd_count(lst: Vec<String>) -> Vec<String> {
","fn odd_count(lst: Vec<String>) -> Vec<String> {
    lst.iter()
        .map(|s| {
            let odd_count = s.chars().filter(|&c| {
                match c {
                    '1' | '3' | '5' | '7' | '9' => true,
                    _ => false,
                }
            }).count();
            format!(""the number of odd elements {0}n the str{0}ng {0} of the {0}nput."", odd_count)
        })
        .collect()
}

// Example usage:
// fn main() {
//     let result = odd_count(vec![String::from(""1234567"")]);
//     println!(""{:?}"", result);
// 
//     let result = odd_count(vec![String::from(""3""), String::from(""11111111"")]);
//     println!(""{:?}"", result);
// }","}

fn main() {
    let candidate = odd_count;
    assert_eq!(candidate(vec![String::from(""1234567"")]), vec![String::from(""the number of odd elements 4n the str4ng 4 of the 4nput."")]);
    assert_eq!(candidate(vec![String::from(""3""), String::from(""11111111"")]), vec![String::from(""the number of odd elements 1n the str1ng 1 of the 1nput.""), String::from(""the number of odd elements 8n the str8ng 8 of the 8nput."")]);
    assert_eq!(candidate(vec![String::from(""271""), String::from(""137""), String::from(""314"")]), vec![String::from(""the number of odd elements 2n the str2ng 2 of the 2nput.""), String::from(""the number of odd elements 3n the str3ng 3 of the 3nput.""), String::from(""the number of odd elements 2n the str2ng 2 of the 2nput."")]);
}
"
HumanEval_114,nus_Latn,rs,"/// Cäätdɛ /// duŋ nämbäri̱. /// Mi̱ ca ŋun ɛ bɛktɔr mi̱ tekɛ intejeri̱ nämbäri̱, jiekɛ min kuiy ni̱ jɛn kä matkɛ ɛni̱ tha̱b-bɛktɔr mi̱ /ci̱ la duŋ duŋ i̱thkuɛr/// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(vec![-1, -2, -3])
/// -6
fn minSubArraySum(nums: Vec<isize>) -> isize {
","fn minSubArraySum(nums: Vec<isize>) -> isize {
    let mut min_sum = nums[0];
    let mut current_sum = nums[0];

    for &num in nums.iter().skip(1) {
        current_sum = current_sum.min(current_sum + num);
        min_sum = min_sum.min(current_sum);
    }

    min_sum
}","}

fn main() {
    let candidate = minSubArraySum;
    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);
    assert_eq!(candidate(vec![-1, -2, -3]), -6);
    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);
    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);
    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);
    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);
    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);
    assert_eq!(candidate(vec![-10]), -10);
    assert_eq!(candidate(vec![7]), 7);
    assert_eq!(candidate(vec![1, -1]), -1);
}
"
HumanEval_115,nus_Latn,rs,"/// Cäät kä 1: ///Cu pek in go̱o̱ri̱ ɣöö bi̱ ji̱n ɛ la̱th piny kä bi̱kɛl la̱th.///La̱tdu ɛ ɣöö bi̱ ji̱th tin te rɛy yiëër diaal jakä thil pi̱w.///kä kɛn dha̱a̱ri̱ diaal tekɛ pek mi̱ päär. /// Ci̱kɛl mi̱ te pi̱w ti̱ gɔw ɛ mi̱ päär mi̱ dëë la̱t kɛ ɣöö baa pi̱w kulɛ ka̱m raar, ///kä 1 ɛ te rɛy la̱t ɛ kɛl ɛ nyothɛ yunit kɛl mi̱ la pi̱w.///Ca ji̱ moc kɛ röm mi̱ ca ri̱e̱t ɛ la gëëk mi̱ cuŋ ɛ la mi̱ te kɛ mi̱ ci̱ rɔ̱ɔ̱diɛn mat thi̱n./// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)
/// 6
/// Example 2:
/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)
/// 5
/// Example 3:
/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {
","fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {
    let mut total_water_units = 0;

    for row in grid.iter() {
        for &unit in row.iter() {
            total_water_units += unit;
        }
    }

    // Calculate how many times we need to lower the bucket to extract all water units
    (total_water_units + capacity - 1) / capacity
}

fn main() {
    println!(""{}"", max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)); // 6
    println!(""{}"", max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)); // 5
    println!(""{}"", max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)); // 0
}","}

fn main() {
    let candidate = max_fill;
    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);
    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);
    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);
}
"
HumanEval_116,nus_Latn,rs,"/// Jɛn ba yi̱k la̱t ce̱tkɛ mi̱ cie nɛmɛ: /// Kɛ kui̱ nämbäri̱ ti̱ cäät kä kɛl, ba kɛ da̱a̱k kɛ ta̱a̱ decimalä./// nämbär duŋ kɛl rɛy bainäri̱diɛn kɛ ɣöö bɛ rɔ re̱p./// Rɛy kä Kata, bi̱di̱ bi̱di̱ mi̱ /ci̱ mɔ a negɛtib intejeri̱ ba riali̱kä kɛ duɔ̱ɔ̱p mi̱ cie /// >>> sort_array(vec![1, 5, 2, 3, 4])
/// vec![1, 2, 3, 4, 5]
/// >>> sort_array(vec![-2, -3, -4, -5, -6])
/// vec![-6, -5, -4, -3, -2]
/// >>> sort_array(vec![1, 0, 2, 3, 4])
/// vec![0, 1, 2, 3, 4]
fn sort_array(arr: Vec<isize>) -> Vec<isize> {
","fn sort_array(arr: Vec<isize>) -> Vec<isize> {
    let mut arr = arr;
    arr.sort_by(|&a, &b| {
        let ones_a = a.count_ones();
        let ones_b = b.count_ones();
        if ones_a == ones_b {
            a.cmp(&b)
        } else {
            ones_a.cmp(&ones_b)
        }
    });
    arr
}

fn main() {
    println!(""{:?}"", sort_array(vec![1, 5, 2, 3, 4])); // Output: [1, 2, 3, 4, 5]
    println!(""{:?}"", sort_array(vec![-2, -3, -4, -5, -6])); // Output: [-6, -5, -4, -3, -2]
    println!(""{:?}"", sort_array(vec![1, 0, 2, 3, 4])); // Output: [0, 1, 2, 3, 4]
}","}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);
    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);
    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
}
"
HumanEval_117,nus_Latn,rs,"/// Cäätni̱: /// Note: deri̱ jɛ car i̱ ɛn inpuut string bɛ tekɛ lɛtteri̱ kɛnɛ i̱thpëthni̱ kärɔ̱./// Mi̱ ci̱ ki̱rɛnd s te̱e̱ /thiɛl luɔt, kä bi̱ pa̱ŋciin ɛ nyɔk kɛ locni̱ ɛ la duŋ bɛktɔr mi̱ thiɛl luɔt.///n kɛ̈l kɛ̈ɛ̈li̱, kɛ ɣöö bi̱ kɛn rieet ti̱ti̱ jɔɔc rɛy thärkdɛ./// ɛ pa̱ŋcin mi̱ locni̱ ba̱kciɛr duŋ ri̱e̱e̱tni̱ diaal kä thärkdɛ (string) min tekɛ ɛ päär /// Mi̱ ca ŋun ɛ la thärkdɛ (string) kɛnɛ näci̱ral nämbär (natural number), ba ji̱ la̱t kɛ ɣöö bi̱ la̱t ɛ mɔ la̱t./// >>> select_words(String::from(""Mary had a little lamb""), 4)
/// vec![String::from(""little"")]
/// >>> select_words(String::from(""Mary had a little lamb""), 3)
/// vec![String::from(""Mary""), String::from(""lamb"")]
/// >>> select_words(String::from(""simple white space""), 2)
/// Vec::<String>::new()
/// >>> select_words(String::from(""Hello world""), 4)
/// vec![String::from(""world"")]
/// >>> select_words(String::from(""Uncle sam""), 3)
/// vec![String::from(""Uncle"")]
fn select_words(s: String, n: isize) -> Vec<String> {
","fn select_words(s: String, n: isize) -> Vec<String> {
    let consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"";
    let mut result = Vec::new();

    for word in s.split_whitespace() {
        let consonant_count = word.chars().filter(|c| consonants.contains(*c)).count();
        if consonant_count == n as usize {
            result.push(word.to_string());
        }
    }

    result
}","}

fn main() {
    let candidate = select_words;
    assert_eq!(candidate(String::from(""Mary had a little lamb""), 4), vec![String::from(""little"")]);
    assert_eq!(candidate(String::from(""Mary had a little lamb""), 3), vec![String::from(""Mary""), String::from(""lamb"")]);
    assert_eq!(candidate(String::from(""simple white space""), 2), Vec::<String>::new());
    assert_eq!(candidate(String::from(""Hello world""), 4), vec![String::from(""world"")]);
    assert_eq!(candidate(String::from(""Uncle sam""), 3), vec![String::from(""Uncle"")]);
    assert_eq!(candidate(String::from(""""), 4), Vec::<String>::new());
    assert_eq!(candidate(String::from(""a b c d e f""), 1), vec![String::from(""b""), String::from(""c""), String::from(""d""), String::from(""f"")]);
}
"
HumanEval_118,nus_Latn,rs,"/// Cäät: /// Ji̱n deri̱ jɛ car i̱ ɛn thärk in ca ŋun te kɛɛ i̱thkri̱p I̱ŋli̱th kärɔa.///cuɛ tekɛ jɔw mi̱ ci̱ rɔ lot kɛ min ca lat nhial.///Ci̱ rɔal tin te tukdɛ kɛnɛ guutdɛ la̱t. Mi̱ /ci̱ la̱tdu la̱t ɛ lɔ̱ŋ, bi̱ yi̱k loc ɛ la mi̱ thiɛl luɔt./// rɛw tin la jɔc ɛ wä kui̱c cuëëc thuɔk (kä mi̱ ci̱kɛ te thi̱n bi̱ kɛ cu ji̱ek).///Ca ji̱ moc riet mi̱ bi̱ la̱tdu ɛ ɣöö bi̱ ji̱n ɛ jiek kɛ rie̱t mi̱ ci̱ rɔ lot kɛ jɛ./// >>> get_closest_vowel(String::from(""yogurt""))
/// String::from(""u"")
/// >>> get_closest_vowel(String::from(""FULL""))
/// String::from(""U"")
/// >>> get_closest_vowel(String::from(""quick""))
/// String::from("""")
/// >>> get_closest_vowel(String::from(""ab""))
/// String::from("""")
fn get_closest_vowel(word: String) -> String {
","fn get_closest_vowel(word: String) -> String {
    let vowels = ""aeiouAEIOU"";
    let chars: Vec<char> = word.chars().collect();
    if chars.len() < 3 {
        return String::from("""");
    }

    for i in (1..chars.len() - 1).rev() {
        if vowels.contains(chars[i]) && !vowels.contains(chars[i-1]) && !vowels.contains(chars[i+1]) {
            return chars[i].to_string();
        }
    }
    String::from("""")
}","}

fn main() {
    let candidate = get_closest_vowel;
    assert_eq!(candidate(String::from(""yogurt"")), String::from(""u""));
    assert_eq!(candidate(String::from(""full"")), String::from(""u""));
    assert_eq!(candidate(String::from(""easy"")), String::from(""""));
    assert_eq!(candidate(String::from(""eAsy"")), String::from(""""));
    assert_eq!(candidate(String::from(""ali"")), String::from(""""));
    assert_eq!(candidate(String::from(""bad"")), String::from(""a""));
    assert_eq!(candidate(String::from(""most"")), String::from(""o""));
    assert_eq!(candidate(String::from(""ab"")), String::from(""""));
    assert_eq!(candidate(String::from(""ba"")), String::from(""""));
    assert_eq!(candidate(String::from(""quick"")), String::from(""""));
    assert_eq!(candidate(String::from(""anime"")), String::from(""i""));
    assert_eq!(candidate(String::from(""Asia"")), String::from(""""));
    assert_eq!(candidate(String::from(""Above"")), String::from(""o""));
}
"
HumanEval_119,nus_Latn,rs,"/// Cäätni̱: /// Ji̱äkni̱ 'Ɣɔ̱ɔ̱n' mi̱ ca duɔ̱ɔ̱r mi̱ gɔaa mi̱ ca la̱t, kä ji̱äkni̱ '/Cɛ' mi̱ dɔ̱ŋ./// "" (()) "" /ciɛ jɛn.///kɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛlkɛl/// Ci̱kɛriŋ S ba car i̱ de gɔaa mi̱ kɛnɛ kɛn kärɔ̱ mi̱ ci̱kɛ parenteethethni̱ diaal rɛy S ///Thiɛlɛ mi̱ bi̱ ben raar kä bi̱ kɛn rɔ̱ lot kɛ duɔ̱ɔ̱p mi̱ gɔaa./// La̱tdu ɛ ɣöö bi̱ ji̱n ɛ ŋa̱c i̱ de rɔ lot kɛ ɣöö bi̱ kɛn rɛw ti̱ti̱ mat kɛɛl rɛy gua̱th in ci̱kɛ wɔ̱ thi̱n./// kɛ kamni̱ "" (() "" kiɛ kamni̱ tin thia̱k kärɔ̱./// Ca ji̱ moc kɛ bi̱i̱ ti̱ ŋuan ti̱ caa rɔ̱ɔ̱diɛn la̱th thi̱n, kɛn bi̱i̱ da̱ŋ rɛw tin ca rɔ̱ɔ̱diɛn la̱th thi̱n kɛ ɣöö bi̱kɛ rɔ̱ɔ̱diɛn lɛp./// >>> match_parens(vec![String::from(""()(""), String::from("")"")])
/// String::from(""Yes"")
/// >>> match_parens(vec![String::from("")""), String::from("")"")])
/// String::from(""No"")
fn match_parens(lst: Vec<String>) -> String {
","fn match_parens(lst: Vec<String>) -> String {
    fn is_balanced(s: &str) -> bool {
        let mut balance = 0;
        for ch in s.chars() {
            if ch == '(' {
                balance += 1;
            } else {
                balance -= 1;
            }
            if balance < 0 {
                return false;
            }
        }
        balance == 0
    }

    if lst.len() != 2 {
        return ""No"".to_string();
    }

    let s1 = &lst[0];
    let s2 = &lst[1];

    let combined1 = format!(""{}{}"", s1, s2);
    let combined2 = format!(""{}{}"", s2, s1);

    if is_balanced(&combined1) || is_balanced(&combined2) {
        ""Yes"".to_string()
    } else {
        ""No"".to_string()
    }
}","}

fn main() {
    let candidate = match_parens;
    assert_eq!(candidate(vec![String::from(""()(""), String::from("")"")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from("")""), String::from("")"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from(""(()(())""), String::from(""())())"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from("")())""), String::from(""(()()("")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from(""(())))""), String::from(""(()())(("")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from(""()""), String::from(""())"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from(""(()(""), String::from(""()))()"")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from(""((((""), String::from(""((())"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from("")(()""), String::from(""(()("")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from("")(""), String::from("")("")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from(""(""), String::from("")"")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from("")""), String::from(""("")]), String::from(""Yes""));
}
"
HumanEval_120,nus_Latn,rs,"/// Cäät kä 1: /// mi̱ bäär k kä ɛ mi̱ di̱i̱t kä k nämbäri̱ rɛy arr. /// Mi̱ ca ŋun ɛ bɛktɔr arr duŋ intejeri̱ kɛnɛ puɔ̱thitib intejeri̱ k, locni̱ bɛktɔr mi̱ ca riali̱kä /// >>> maximum(vec![-3, -4, 5], 3)
/// vec![-4, -3, 5]
/// Example 2:
/// >>> maximum(vec![4, -4, 4], 2)
/// vec![4, 4]
/// Example 3:
/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)
/// vec![2]
/// Note:
/// 1. The length of the vector will be in the range of [1, 1000].
/// 2. The elements in the vector will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {
","fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {
    let mut arr = arr;
    arr.sort_unstable_by(|a, b| b.cmp(a));
    let k = k as usize;
    let mut result: Vec<isize> = arr.into_iter().take(k).collect();
    result.sort_unstable();
    result
}

fn main() {
    assert_eq!(maximum(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(maximum(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
}","}

fn main() {
    let candidate = maximum;
    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);
    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);
    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);
    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);
    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);
    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);
    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);
    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());
}
"
HumanEval_121,nus_Latn,rs,"/// Cäätni̱ /// Mi̱ ca ŋun ɛ la intɛgeri̱ ti̱ /ci̱kɛ pual, locni̱ dääk kä i̱thpetherni̱ diaal tin te pa̱a̱r ti̱ te gua̱thkiɛn kärɔ̱./// >>> solution(vec![5, 8, 7, 1])
/// 12
/// >>> solution(vec![3, 3, 3, 3, 3])
/// 9
/// >>> solution(vec![30, 13, 24, 321])
/// 0
fn solution(lst: Vec<isize>) -> isize {
","fn solution(lst: Vec<isize>) -> isize {
    lst.iter()
        .enumerate()
        .filter(|(i, &x)| i % 2 == 0 && x % 2 != 0)
        .map(|(_, &x)| x)
        .sum()
}","}

fn main() {
    let candidate = solution;
    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);
    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);
    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);
    assert_eq!(candidate(vec![5, 9]), 5);
    assert_eq!(candidate(vec![2, 4, 8]), 0);
    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);
    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);
}
"
HumanEval_122,nus_Latn,rs,"/// Cäät: /// ɛ mat ŋɔaani̱ tin tekɛ di̱jitni̱ rɛw ɛlɔ̱ŋ kä ɛlɛmɛni̱ tin nhiam kä k nyin arr. /// Mi̱ ca ŋun ɛ la mi̱ /ci̱ la duŋ duŋ intɛrjiɛr ba̱th kä arr kɛnɛ intɛrjiɛr k, locni̱ /// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
fn add_elements(arr: Vec<isize>, k: isize) -> isize {
","fn add_elements(arr: Vec<isize>, k: isize) -> isize {
    arr.iter()
        .take(k as usize)
        .filter(|&&x| x > -100 && x < 100)
        .sum()
}

fn main() {
    let result = add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4);
    println!(""{}"", result);  // Output: 24
}","}

fn main() {
    let candidate = add_elements;
    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);
    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);
    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);
    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);
    assert_eq!(candidate(vec![1], 1), 1);
}
"
HumanEval_123,nus_Latn,rs,"/// get_odd_collatz(5) läätdɛ ɛ [1, 5] # Kä kɔlatdh thekuɛnthi̱ kɛ kui̱ 5 ɛ [5, 16, 8, 4, 2, 1], kɛ kui̱c ɛmɔ nämbäri̱ tin /ci̱ tɔ̱ a kɛl ɛ 1, kɛnɛ 5. /// Ciee cäät ɛmɛ: /// 2. cɛ loc ɛ la bɛktɔr mi̱ ca riali̱kä kɛ ɣöö bɛ rɔ re̱p./// 1. Collatz ((1) ɛ [1]. /// Cuɔŋ: ///term matkɛ 1. Kä ca̱r ɛ ɣöö ɛni̱ mi̱ ɛ ŋu kä ba̱li̱ö duŋ n, kä thi̱kuɛnthi̱ bɛ räth ni̱ ciaaŋ kä 1.//Mi̱ ci̱ ci̱ɛk in nhiam ɛ mi̱ /ci̱ mɔ a kɛl, kä ci̱ɛk in dɔ̱ŋ bɛ tekɛ diɔ̱k ti̱ ŋuan kä ci̱ɛk in nhiam./// ri̱e̱t ëë nhiam ɛ mi̱ cie: mi̱ ci̱ ri̱e̱t ëë nhiam ɛ pa̱r, ri̱e̱t in dɔ̱ŋ bɛ a nuth kä /// cetkɛ min ba lat: tokɛ kɛ pek mi̱ lotrɔ kä intɛrjiɛr n. Kä ɛn kɔrɛ ba mi̱ ci̱kɛ te kɛɛl kulɛ jiek kä /// Kä Köllatdh kɔnjeciɛr ɛ kɔnjeciɛr rɛy mɛthä min ruac kɛ kui̱ kä min ca lat kä thi̱kuɛnthi̱ /// Mi̱ ca ŋun ɛ la mi̱ tekɛ puɔthtip intejiɛr n, locni̱ thortdä bɛktɔr mi̱ tekɛ nämbäri̱ ti̱ ji̱di̱tni̱ rɛy kɔla̱tdh thekuɛnthi̱./// >>> get_odd_collatz(5)
/// vec![1, 5]
fn get_odd_collatz(n: isize) -> Vec<isize> {
","fn get_odd_collatz(n: isize) -> Vec<isize> {
    let mut sequence = Vec::new();
    let mut current = n;

    while current != 1 {
        if current % 2 != 0 {
            sequence.push(current);
        }

        if current % 2 == 0 {
            current /= 2;
        } else {
            current = 3 * current + 1;
        }
    }
    
    // Add the final odd number 1 if n is 1
    sequence.push(1);

    sequence.sort();
    sequence
}

fn main() {
    let result = get_odd_collatz(5);
    println!(""{:?}"", result); // Outputs: [1, 5]
}","}

fn main() {
    let candidate = get_odd_collatz;
    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(5), vec![1, 5]);
    assert_eq!(candidate(12), vec![1, 3, 5]);
    assert_eq!(candidate(1), vec![1]);
}
"
HumanEval_124,nus_Latn,rs,"/// 4. cäŋ bi̱ dhil te rɛy kä mi̱ ca riali̱kä: mm-dd-yyyy /// 3. Kä päth /ci̱kɛ bi̱ te piny 1 kiɛ bi̱ di̱t ni̱ kä 12./// 2. Kä nämbär ni̱ni̱ /ci̱kɛ kuiy ni̱ kä 1 kiɛ di̱t ni̱ kä 31 ni̱ni̱ kɛ kui̱ päthni̱ 1,3,5,7,8,10,12. Kä nämbär ni̱ni̱ /ci̱kɛ kuiy ni̱ kä 1 kiɛ di̱t ni̱ kä 30 ni̱ni̱ kɛ kui̱ päthni̱ 4,6,9,11. Kä, nämbär ni̱ni̱ /ci̱kɛ kuiy ni̱ kä 1 kiɛ di̱t ni̱ kä 29 kɛ kui̱ päthni̱ 2./// 1. Kä cäŋ ɛ/ciɛɛ mi̱ te jɔ̱ɔ̱r./// Dati̱ ɛ mi̱ la thuɔ̱k mi̱ ca ŋuɔ̱t ti̱ti̱ diaal la̱th thi̱n: /// la loc ɛ thuɔ̱k mi̱ ci̱ cäŋ ɛ thuɔ̱k mi̱ dɔ̱ŋ ɛ kac. /// Ji̱n bi̱ la̱t mi̱ bi̱ la̱t mi̱ ci̱ thuɔ̱k kä ca ŋun kä cäŋ ɛ ci̱ duɔth kä /// >>> valid_date(String::from(""03-11-2000""))
/// true
/// >>> valid_date(String::from(""15-01-2012""))
/// false
/// >>> valid_date(String::from(""04-0-2040""))
/// false
/// >>> valid_date(String::from(""06-04-2020""))
/// true
/// >>> valid_date(String::from(""06/04/2020""))
/// false
fn valid_date(date: String) -> bool {
","fn valid_date(date: String) -> bool {
    if date.is_empty() {
        return false;
    }

    let parts: Vec<&str> = date.split('-').collect();
    if parts.len() != 3 {
        return false;
    }

    let maybe_month = parts[0].parse::<u32>();
    let maybe_day = parts[1].parse::<u32>();
    let maybe_year = parts[2].parse::<u32>();

    if maybe_month.is_err() || maybe_day.is_err() || maybe_year.is_err() {
        return false;
    }

    let month = maybe_month.unwrap();
    let day = maybe_day.unwrap();

    if month < 1 || month > 12 {
        return false;
    }

    match month {
        1 | 3 | 5 | 7 | 8 | 10 | 12 => {
            if day < 1 || day > 31 {
                return false;
            }
        }
        4 | 6 | 9 | 11 => {
            if day < 1 || day > 30 {
                return false;
            }
        }
        2 => {
            if day < 1 || day > 29 {
                return false;
            }
        }
        _ => return false, // This case should never be reached
    }

    true
}","}

fn main() {
    let candidate = valid_date;
    assert_eq!(candidate(String::from(""03-11-2000"")), true);
    assert_eq!(candidate(String::from(""15-01-2012"")), false);
    assert_eq!(candidate(String::from(""04-0-2040"")), false);
    assert_eq!(candidate(String::from(""06-04-2020"")), true);
    assert_eq!(candidate(String::from(""01-01-2007"")), true);
    assert_eq!(candidate(String::from(""03-32-2011"")), false);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""04-31-3000"")), false);
    assert_eq!(candidate(String::from(""06-06-2005"")), true);
    assert_eq!(candidate(String::from(""21-31-2000"")), false);
    assert_eq!(candidate(String::from(""04-12-2003"")), true);
    assert_eq!(candidate(String::from(""04122003"")), false);
    assert_eq!(candidate(String::from(""20030412"")), false);
    assert_eq!(candidate(String::from(""2003-04"")), false);
    assert_eq!(candidate(String::from(""2003-04-12"")), false);
    assert_eq!(candidate(String::from(""04-2003"")), false);
}
"
HumanEval_126,nus_Latn,rs,"/// Cäätni̱ /// nämbär, locni̱ mi̱ la kac. /Cu thiɛlɛ nämbäri̱ ti̱ ca mat kä ɛni̱ intejeri̱ kärɔ̱./// rɛy kä min wä nhial kä bi̱ ben nhial mi̱ ci̱ bɛktɔr tekɛ ti̱ ŋuan ti̱ päär ti̱ päär /// Mi̱ ca ŋun ɛ bɛktɔr nämbäri̱, bi̱ locni̱ mi̱ ca kɛ da̱a̱k kiɛ /ka̱n kɛ da̱a̱k./// >>> is_sorted(vec![5])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])
/// false
fn is_sorted(lst: Vec<isize>) -> bool {
","fn is_sorted(lst: Vec<isize>) -> bool {
    if lst.is_empty() || lst.len() == 1 {
        return true;
    }
    
    let mut previous = lst[0];
    let mut repeat_count = 0;

    for &current in &lst[1..] {
        if current < previous {
            return false;
        }
        if current == previous {
            repeat_count += 1;
            if repeat_count >= 2 {
                return false;
            }
        } else {
            repeat_count = 0;
        }
        previous = current;
    }

    true
}","}

fn main() {
    let candidate = is_sorted;
    assert_eq!(candidate(vec![5]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
    assert_eq!(candidate(vec![1]), true);
    assert_eq!(candidate(vec![3, 2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4]), true);
}
"
HumanEval_127,nus_Latn,rs,"/// [input/output] samples: //Mi̱ ci̱ gua̱th da̱ŋ rɛw ti̱ti̱ /ci̱kɛ rɔ̱ mat, locni̱ ""ƔE/CƐ""./// mi̱ /ci̱e jɛn, luɔ̱c ""/CƐ"". /// Mi̱ ci̱ pek in ci̱ rɔ röm ɛ mi̱ la praam nämbär, locni̱ ""YƐƐ"", /// min bäärɛ ɛ 1, min /ci̱ɛɛ nämbär mi̱ di̱i̱t./// Cäätdɛ, ɛn kam kamni̱ gua̱a̱th in te kam (1, 3), (2, 4) ɛ (2, 3) /// Interval ɛ mi̱ la praam nämbär./// La̱tdu ɛ ɣöö bi̱ ji̱n ɛ ŋa̱c i̱ ɛ pek in ci̱ kamdiɛn rɔ̱ röm kɛ kɛn rɛw ti̱ti̱ /// Kɛ gua̱th mi̱ ca ŋun, jɛn ba naŋ i̱ jɛn tukdɛ ɛ kuiy kiɛ päärkɛ kɛ guutdɛ./// matdɛ tuk kɛnɛ guut. ///Kä kam in ca ŋun tëkɛ mi̱ ca gäk min lotni̱ ɣöö kam (ka̱m raar, guut) /// gua̱th in bi̱ kamni̱ diaal ɛ la pek mi̱ matkɛ ɛ la intejeri̱. Cäät, kam = (ka̱m raar, guut) = (1, 2).///Ca ji̱ moc gua̱th da̱ŋ rɛw, /// >>> intersection((1, 2), (2, 3))
/// String::from(""NO"")
/// >>> intersection((-1, 1), (0, 4))
/// String::from(""NO"")
/// >>> intersection((-3, -1), (-5, 5))
/// String::from(""YES"")
fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {
","fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {
    let (start1, end1) = interval1;
    let (start2, end2) = interval2;
    let start_intersection = std::cmp::max(start1, start2);
    let end_intersection = std::cmp::min(end1, end2);

    if start_intersection <= end_intersection {
        let length = (end_intersection - start_intersection + 1) as usize;
        if is_prime(length) {
            return String::from(""YES"");
        }
    }
    String::from(""NO"")
}

// Example usage
fn main() {
    println!(""{}"", intersection((1, 2), (2, 3))); // ""NO""
    println!(""{}"", intersection((-1, 1), (0, 4))); // ""NO""
    println!(""{}"", intersection((-3, -1), (-5, 5))); // ""YES""
}","}

fn main() {
    let candidate = intersection;
    assert_eq!(candidate((1, 2), (2, 3)), String::from(""NO""));
    assert_eq!(candidate((-1, 1), (0, 4)), String::from(""NO""));
    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(""YES""));
    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(""YES""));
    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(""NO""));
    assert_eq!(candidate((1, 2), (3, 5)), String::from(""NO""));
    assert_eq!(candidate((1, 2), (1, 2)), String::from(""NO""));
    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(""NO""));
}
"
HumanEval_128,nus_Latn,rs,"/// Cäät: /// Note: return None for empty arr. /// kä nämbär kɛliw rɛy bɛktɔr, cuŋkɛ ɛ la 1, -1 kiɛ 0. /// mat di̱tni̱diɛn kä intejeri̱ mi̱ ca rëp ɛ la mi̱ ca la̱t ɛ la mi̱ ca la̱t ɛ kɛn diaal /// Ca ji̱ moc kɛ ba̱thtɛkciɛr arr duŋ intejeri̱ kä bi̱ ji̱ yi̱k locni̱kɛ /// >>> prod_signs(vec![1, 2, 2, -4])
/// Some(9)
/// >>> prod_signs(vec![0, 1])
/// Some(0)
/// >>> prod_signs(vec![])
/// None
fn prod_signs(arr: Vec<isize>) -> Option<isize> {
","fn prod_signs(arr: Vec<isize>) -> Option<isize> {
    if arr.is_empty() {
        return None;
    }

    let mut sum_of_magnitudes = 0;
    let mut product_of_signs = 1;

    for &num in &arr {
        sum_of_magnitudes += num.abs();
        if num == 0 {
            product_of_signs = 0;
            break;
        } else if num > 0 {
            product_of_signs *= 1;
        } else {
            product_of_signs *= -1;
        }
    }

    Some(sum_of_magnitudes * product_of_signs)
}","}

fn main() {
    let candidate = prod_signs;
    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));
    assert_eq!(candidate(vec![0, 1]), Some(0));
    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));
    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));
    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));
    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));
}
"
HumanEval_129,nus_Latn,rs,"/// Cäätni̱: /// Läthni̱ duɔ̱ɔ̱r mi̱ ca riali̱kä kä ba̱li̱öni̱ kä thëlli̱ min bi̱ min tɔt kä dup wä thi̱n. ///Ca jɛ ŋun ɛn ɣöö luɔcdɛ ɛ kɛl kärɔa./// lst_A[j] = lst_B[j] /// cetkɛ lst_A[i] < lst_B[i] kɛnɛ j (1 <= j < i) mi̱ tekɛ /// kä lst_B, kɛ rie̱t ti̱ kɔ̱kiɛn, tëkɛ intejer indɛth i (1 <= i <= k) ///thɛɛ (nɛy kɛ ciöt i̱ lst_A kɛnɛ lst_B), lst_A ɛ mi̱ kuiy kä kɛ̈l kɛ̈ɛ̈li̱ ///kɛ kɔr kä mëë ca la̱t ɛ la mi̱ ca riali̱kä kɛ kui̱ kä ba̱ktɔri̱ kä ba̱li̱öni̱ kä thëlli̱ tin wä A kɛnɛ B /// Mi̱ ca duɔ̱ɔ̱p A (mi̱ bäär k) guic ɛ mi̱ kuiy ni̱ jɛn kä duɔ̱ɔ̱p B (mi̱ bäär k) mi̱ ///Ci̱ rɔ bi̱ lot ɛn ɣöö bi̱ ji̱n rɔ cu woc.///ca rɔ̱ lot kɛ dääkdiɛn)./// Kuɛ ŋa̱c ɛn ɣöö mi̱ ci̱ duɔ̱ɔ̱p mi̱ bäär k lotdɛ ni̱ ɣöö ba thɛl k wä gui̱l (/ci̱ɛ /// cell. //Kɛ rieet ti̱ kɔ̱ŋ, deri̱ wä kä thëlli̱ tin nyuakɛ ɛni̱ duɔ̱ɔ̱r kɛ ji̱ ɛntäämɛ.///kɛ thɛl mi̱ te go̱lä, kä kɛ duɔ̱ɔ̱p kɛl deri̱ wä kä thɛl mi̱ thieek, /// Ji̱n bi̱ dhil duɔ̱ɔ̱p mi̱ tɔt mi̱ bäär mi̱ /ci̱ bi̱ te thi̱n rɛy gi̱ri̱d. Ji̱n deri̱ jɛ tok./// cuɛɛ rɔ̱ mat gua̱th kɛl kärɔa kä thëlli̱ tin te kä gi̱ri̱d.///kä thɛl ɛni̱ kɛl kä gi̱ri̱d bɛ tekɛ ba̱li̱ö. ɛni̱ intejeri̱ rɛy römɛnt [1, N * N] /// Mi̱ ca ŋun ɛ la gi̱ri̱d mi̱ tekɛ N ri̱i̱wni̱ kɛnɛ N kɔlömni̱ (N >= 2) kɛnɛ ɣöö ɛ puci̱tip intejeri̱ k, /// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)
/// vec![1, 2, 1]
/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)
/// vec![1]
fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {
","fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {
    let n = grid.len();
    let mut best_path = vec![];
    let mut best_values = vec![isize::MAX; k as usize];
    
    fn dfs(
        grid: &Vec<Vec<isize>>, 
        row: usize, 
        col: usize, 
        path: &mut Vec<(usize, usize)>, 
        values: &mut Vec<isize>, 
        k: isize, 
        best_values: &mut Vec<isize>
    ) {
        if path.len() == k as usize {
            if values < best_values {
                best_values.clone_from(values);
            }
            return;
        }
        
        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];
        for &(dr, dc) in directions.iter() {
            let new_row = row as isize + dr;
            let new_col = col as isize + dc;
            if new_row >= 0 && new_row < grid.len() as isize && new_col >= 0 && new_col < grid.len() as isize {
                path.push((new_row as usize, new_col as usize));
                values.push(grid[new_row as usize][new_col as usize]);
                dfs(grid, new_row as usize, new_col as usize, path, values, k, best_values);
                values.pop();
                path.pop();
            }
        }
    }

    for r in 0..n {
        for c in 0..n {
            let mut path = vec![(r, c)];
            let mut values = vec![grid[r][c]];
            dfs(&grid, r, c, &mut path, &mut values, k, &mut best_values);
        }
    }

    best_values
}","}

fn main() {
    let candidate = minPath;
    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);
    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);
    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);
    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);
    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);
    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);
    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}
"
HumanEval_130,nus_Latn,rs,"/// Cäätni̱: ///kɛl n + 1 nämbäri̱ tin nhiam kä Tri̱bönatci̱ thi̱kuɛnthi̱./// Ca ji̱ moc nämbär mi̱ /ci̱ mɔ a negative intejer, bi̱ ji̱ dhil locni̱ ɛ la vektɔr duŋ /// = 2 + 3 + 3 = 8 /// trɛ (n) = trɛ (n) + trɛ (n) + trɛ (n) ///tri(4) = 3 ///tri(2) = 1 + (2 / 2) = 2 /// Ciee cäät ɛmɛ: ///tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), mi̱ n ɛ mi̱ /ci̱ mɔ a kɛl. ///tri (n) = 1 + n / 2, mi̱ n ɛ päär. ///tri(1) = 3 /// Tribönaki̱ thi̱kuɛnthi̱ ca lat ɛ la mi̱ ci̱ rɔ nyɔk kɛ luɔ̱c: //Kä min /ca ŋäc ɛ naath ɛ jɛn Tribönaki̱ thi̱kuɛnthi̱.///Ci̱ nɛy diaal ɛ ŋa̱c i̱ ɛ thi̱kuɛnthi̱ Pi̱i̱bɔnaki̱, jɛn cua ŋi̱e̱e̱c ɛlɔ̱ŋ ɛ mɛthemati̱ciani̱ rɛy /// >>> tri(3)
/// vec![1, 3, 2, 8]
fn tri(n: isize) -> Vec<isize> {
","fn tri(n: isize) -> Vec<isize> {
    fn tribonacci(n: isize, memo: &mut Vec<isize>) -> isize {
        if n < memo.len() as isize {
            return memo[n as usize];
        }

        let result = if n == 1 {
            3
        } else if n % 2 == 0 {
            1 + n / 2
        } else {
            tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n + 1, memo)
        };

        if n as usize >= memo.len() {
            memo.resize(n as usize + 1, 0);
        }
        memo[n as usize] = result;
        result
    }

    let mut sequence = Vec::new();
    let mut memo = Vec::new();

    for i in 0..=n {
        sequence.push(tribonacci(i, &mut memo));
    }

    sequence
}","}

fn main() {
    let candidate = tri;
    assert_eq!(candidate(3), vec![1, 3, 2, 8]);
    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);
    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);
    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);
    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);
    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);
    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
    assert_eq!(candidate(0), vec![1]);
    assert_eq!(candidate(1), vec![1, 3]);
}
"
HumanEval_131,nus_Latn,rs,"/// Ciee cäät ɛmɛ: /// Lätdɛ 0 mi̱ ci̱ digitni̱ diaal ɛ pari̱. /// Mi̱ ca ŋun ɛ la mi̱ tekɛ puɔthtip intejiɛr n, locni̱ pröda̱k duŋ di̱jitni̱ tin /ci̱ tɔt./// >>> digits(1)
/// 1
/// >>> digits(4)
/// 0
/// >>> digits(235)
/// 15
fn digits(n: isize) -> isize {
","fn digits(n: isize) -> isize {
    let mut product = 1;
    let mut has_odd = false;
    let mut num = n;

    while num > 0 {
        let digit = num % 10;
        if digit % 2 != 0 {
            product *= digit;
            has_odd = true;
        }
        num /= 10;
    }

    if has_odd {
        product
    } else {
        0
    }
}

fn main() {
    println!(""{}"", digits(1));  // 1
    println!(""{}"", digits(4));  // 0
    println!(""{}"", digits(235)); // 15
}","}

fn main() {
    let candidate = digits;
    assert_eq!(candidate(5), 5);
    assert_eq!(candidate(54), 5);
    assert_eq!(candidate(120), 1);
    assert_eq!(candidate(5014), 5);
    assert_eq!(candidate(98765), 315);
    assert_eq!(candidate(5576543), 2625);
    assert_eq!(candidate(2468), 0);
}
"
HumanEval_132,nus_Latn,rs,"/// gua̱th in bi̱ ram kɛl kä bi̱kɛl rɛy thɛkcuɛnthi̱ ɛ mi̱ ca la̱th kä bi̱kɛl./// La̱t ba yi̱k loc i̱ thuɔ̱k mi̱ kɛnɛ ɛni̱ mi̱ ɛni̱ mi̱ tekɛ mi̱ lot rɔ kɛ min ca la̱t ɛ la mi̱ te piny kä parketni̱ /// Ji̱n bi̱ la̱t mi̱ naŋkɛ ni̱ string mi̱ te ni̱ karkɛt paraketni̱ thi̱n ɛ la inpuut./// >>> is_nested(String::from(""[[]]""))
/// true
/// >>> is_nested(String::from(""[]]]]]]][[[[[]""))
/// false
/// >>> is_nested(String::from(""[][]""))
/// false
/// >>> is_nested(String::from(""[]""))
/// false
/// >>> is_nested(String::from(""[[][]]""))
/// true
/// >>> is_nested(String::from(""[[]][[""))
/// true
fn is_nested(string: String) -> bool {
","fn is_nested(string: String) -> bool {
    let mut stack = Vec::new();
    let mut nested = false;

    for bracket in string.chars() {
        if bracket == '[' {
            stack.push(bracket);
        } else if bracket == ']' {
            if let Some(_) = stack.pop() {
                if !stack.is_empty() {
                    nested = true;
                }
            } else {
                return false;
            }
        }
    }

    nested
}

fn main() {
    println!(""{}"", is_nested(String::from(""[[]]""))); // true
    println!(""{}"", is_nested(String::from(""[]]]]]]][[[[[]""))); // false
    println!(""{}"", is_nested(String::from(""[][]""))); // false
    println!(""{}"", is_nested(String::from(""[]""))); // false
    println!(""{}"", is_nested(String::from(""[[][]]""))); // true
    println!(""{}"", is_nested(String::from(""[[]][[""))); // true
}","}

fn main() {
    let candidate = is_nested;
    assert_eq!(candidate(String::from(""[[]]"")), true);
    assert_eq!(candidate(String::from(""[]]]]]]][[[[[]"")), false);
    assert_eq!(candidate(String::from(""[][]"")), false);
    assert_eq!(candidate(String::from(""[]"")), false);
    assert_eq!(candidate(String::from(""[[[[]]]]"")), true);
    assert_eq!(candidate(String::from(""[]]]]]]]]]]"")), false);
    assert_eq!(candidate(String::from(""[][][[]]"")), true);
    assert_eq!(candidate(String::from(""[[]"")), false);
    assert_eq!(candidate(String::from(""[]]"")), false);
    assert_eq!(candidate(String::from(""[[]][["")), true);
    assert_eq!(candidate(String::from(""[[][]]"")), true);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""[[[[[[[["")), false);
    assert_eq!(candidate(String::from(""]]]]]]]]"")), false);
}
"
HumanEval_133,nus_Latn,rs,"/// Cäätni̱: /// rɔɔdɛli̱ ɛlɛmɛni̱ rɛy bɛktɔr kɛ ɣöö bɛ cop ni̱ kä intɛciɔn in te nhial (thil) kɛ nhiam./// Ji̱n go̱ri̱ ɣöö bi̱ ji̱n locni̱ pek nämbäri̱ tin ca kuëŋ kä i̱thkuɛr rɛy bɛktɔr in ca ŋun, ///Ca ji̱ moc kɛ ba̱kciɛr nämbäri̱./// >>> lst(vec![1.0, 2.0, 3.0])
/// 14
/// >>> lst(vec![1.0, 4.0, 9.0])
/// 98
/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> lst(vec![1.4, 4.2, 0.0])
/// 29
/// >>> lst(vec![-2.4, 1.0, 1.0])
/// 6
fn sum_squares(lst: Vec<f64>) -> isize {
","fn sum_squares(lst: Vec<f64>) -> isize {
    lst.iter()
        .map(|&x| x.ceil() as isize)  // Round each element to the nearest upper integer
        .map(|x| x * x)               // Square each element
        .sum()                        // Sum all the squared elements
}

fn main() {
    println!(""{}"", sum_squares(vec![1.0, 2.0, 3.0])); // 14
    println!(""{}"", sum_squares(vec![1.0, 4.0, 9.0])); // 98
    println!(""{}"", sum_squares(vec![1.0, 3.0, 5.0, 7.0])); // 84
    println!(""{}"", sum_squares(vec![1.4, 4.2, 0.0])); // 29
    println!(""{}"", sum_squares(vec![-2.4, 1.0, 1.0])); // 6
}","}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);
    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);
    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);
    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);
    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);
    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);
    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);
    assert_eq!(candidate(vec![0.0]), 0);
    assert_eq!(candidate(vec![-1.0]), 1);
    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);
}
"
HumanEval_134,nus_Latn,rs,"/// Cäätni̱: /// Note: ""word"" ɛ buɔ̱n kä tin ca da̱a̱k ɛ kam.///ci̱kɛ tha̱a̱ŋ rieetni̱, kä kɛ duɔ̱ɔ̱p mi̱ dɔ̱ŋ /ci̱kɛ thuɔ̱k./// kä thärkdɛ min ca ŋun ɛ alpabetik kä /ciɛ /// Ji̱kɛ pa̱ŋcin mi̱ loc ni̱ thuɔ̱k mi̱ ca karɛkta̱r in jɔakdiɛn /// >>> check_if_last_char_is_a_letter(String::from(""apple pie""))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""apple pi e""))
/// true
/// >>> check_if_last_char_is_a_letter(String::from(""apple pi e ""))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""""))
/// false
fn check_if_last_char_is_a_letter(txt: String) -> bool {
","fn check_if_last_char_is_a_letter(txt: String) -> bool {
    if let Some(c) = txt.trim().chars().rev().next() {
        if c.is_alphabetic() {
            if let Some(prev_char) = txt.chars().rev().skip_while(|&ch| ch.is_whitespace()).nth(1) {
                return !prev_char.is_alphabetic();
            }
        }
    }
    false
}

fn main() {
    println!(""{}"", check_if_last_char_is_a_letter(String::from(""apple pie"")));  // false
    println!(""{}"", check_if_last_char_is_a_letter(String::from(""apple pi e""))); // true
    println!(""{}"", check_if_last_char_is_a_letter(String::from(""apple pi e ""))); // false
    println!(""{}"", check_if_last_char_is_a_letter(String::from("""")));           // false
}","}

fn main() {
    let candidate = check_if_last_char_is_a_letter;
    assert_eq!(candidate(String::from(""apple"")), false);
    assert_eq!(candidate(String::from(""apple pi e"")), true);
    assert_eq!(candidate(String::from(""eeeee"")), false);
    assert_eq!(candidate(String::from(""A"")), true);
    assert_eq!(candidate(String::from(""Pumpkin pie "")), false);
    assert_eq!(candidate(String::from(""Pumpkin pie 1"")), false);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""eeeee e "")), false);
    assert_eq!(candidate(String::from(""apple pie"")), false);
    assert_eq!(candidate(String::from(""apple pi e "")), false);
}
"
HumanEval_135,nus_Latn,rs,"/// Cäätni̱: /// cɛ rɔ̱ mat kä ti̱ ŋuan.///thiɛlɛ mi̱ cie ɛlɛmɛni̱ tɔ̱tɔ̱ thi̱n kä bɛ loc ɛ la -1. Kä bɛ tektöri̱ tin ca ŋun thiɛl kɛ /// /ci̱kɛ di̱tni̱ jɛn kiɛ päärkɛ kɛ ɛlɛmɛni̱ tin te thi̱n ni̱ wän./// Ji̱kɛ pa̱ŋciin mi̱ bi̱ locni̱ indi̱th in di̱tni̱ jɛn kä elɛmɛni̱ tin bi̱ /// >>> can_arrange(vec![1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(vec![1, 2, 3])
/// -1
fn can_arrange(arr: Vec<isize>) -> isize {
","fn can_arrange(arr: Vec<isize>) -> isize {
    for i in (1..arr.len()).rev() {
        if arr[i] < arr[i - 1] {
            return i as isize;
        }
    }
    -1
}

// Example usage:
// fn main() {
//     println!(""{}"", can_arrange(vec![1, 2, 4, 3, 5])); // Outputs: 3
//     println!(""{}"", can_arrange(vec![1, 2, 3])); // Outputs: -1
// }","}

fn main() {
    let candidate = can_arrange;
    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);
    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);
    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);
    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);
    assert_eq!(candidate(Vec::<isize>::new()), -1);
}
"
HumanEval_136,nus_Latn,rs,"/// Cäätni̱: /// Mi̱ thiɛlɛ negɛtib kiɛ puɔ̱thi̱tip intejeri̱, bi̱kɛ loc ɛ la Noth./// duŋ puɔ̱thi̱tip intirji̱ri̱ rɛy bɛktɔr./// min di̱tni̱ jɛn kä min ca mat kä min ca mat kä min ca mat kä min ca mat kä min ca mat kä min ca mat kä min ca mat kä min ca mat kä min ca mat kä min ca mat kä min ca mat./// Ji̱e̱k pa̱ŋciin mi̱ locni̱ tuple (a, b), gua̱th in bi̱ 'a' ɛ /// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])
/// (None, Some(1))
/// >>> largest_smallest_integers(vec![])
/// (None, None)
/// >>> largest_smallest_integers(vec![0])
/// (None, None)
fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {
","fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {
    let mut largest_negative: Option<isize> = None;
    let mut smallest_positive: Option<isize> = None;

    for &num in &lst {
        if num < 0 {
            largest_negative = match largest_negative {
                Some(largest) => Some(largest.max(num)),
                None => Some(num),
            };
        } else if num > 0 {
            smallest_positive = match smallest_positive {
                Some(smallest) => Some(smallest.min(num)),
                None => Some(num),
            };
        }
    }

    (largest_negative, smallest_positive)
}

fn main() {
    println!(""{:?}"", largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])); // (None, Some(1))
    println!(""{:?}"", largest_smallest_integers(vec![])); // (None, None)
    println!(""{:?}"", largest_smallest_integers(vec![0])); // (None, None)
    println!(""{:?}"", largest_smallest_integers(vec![-5, -1, -3, 0, 2, 3])); // (Some(-1), Some(2))
}","}

fn main() {
    let candidate = largest_smallest_integers;
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));
    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));
    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));
    assert_eq!(candidate(Vec::<isize>::new()), (None, None));
    assert_eq!(candidate(vec![0]), (None, None));
    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));
    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));
    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));
    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));
}
"
HumanEval_138,nus_Latn,rs,"/// Cäätdɛ /// Guic mi̱ ca ŋun kä nämbär n de gɔ̱r ɛ la mat nämbäri̱ ti̱ ŋuan ti̱ pa̱a̱r /// >>> is_equal_to_sum_even(4)
/// false
/// >>> is_equal_to_sum_even(6)
/// false
/// >>> is_equal_to_sum_even(8)
/// true
fn is_equal_to_sum_even(n: isize) -> bool {
","fn is_equal_to_sum_even(n: isize) -> bool {
    // A number n can be expressed as the sum of 4 positive even numbers if and only if
    // it is greater than or equal to 8 and even
    n >= 8 && n % 2 == 0
}

// Test cases
fn main() {
    println!(""{}"", is_equal_to_sum_even(4));  // false
    println!(""{}"", is_equal_to_sum_even(6));  // false
    println!(""{}"", is_equal_to_sum_even(8));  // true
}","}

fn main() {
    let candidate = is_equal_to_sum_even;
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), true);
    assert_eq!(candidate(11), false);
    assert_eq!(candidate(12), true);
    assert_eq!(candidate(13), false);
    assert_eq!(candidate(16), true);
}
"
HumanEval_139,nus_Latn,rs,"/// Ciee cäät ɛmɛ: /// gua̱th in n > 0 /// brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! /// Brazil ɛ mi̱ la̱tkɛ ɛ la̱t ɛ la̱t ɛ: /// >>> special_factorial(4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
fn special_factorial(n: isize) -> isize {
","fn factorial(n: isize) -> isize {
    (1..=n).product()
}

fn special_factorial(n: isize) -> isize {
    (1..=n).map(factorial).product()
}

fn main() {
    let result = special_factorial(4);
    println!(""{}"", result);
}","}

fn main() {
    let candidate = special_factorial;
    assert_eq!(candidate(4), 288);
    assert_eq!(candidate(5), 34560);
    assert_eq!(candidate(7), 125411328000);
    assert_eq!(candidate(1), 1);
}
"
HumanEval_140,nus_Latn,rs,"/// kä bɛ kamni̱ diaal tin guɔ̱rkɛ rɔ̱ gɛr kɛ - /// kä mi̱ ci̱ thärkdɛ tekɛ gua̱th ti̱ ŋuan ti̱ guɔ̱rkɛ rɔ̱, /// Mi ca thärk mi̱ ca gɔ̱r ka̱m ji̱, bi̱ kamni̱ diaal ɛ loc kɛ ti̱ te piny, /// >>> fix_spaces(String::from("" Example""))
/// String::from(""Example"")
/// >>> fix_spaces(String::from("" Example 1""))
/// String::from(""Example_1"")
/// >>> fix_spaces(String::from("" Example 2""))
/// String::from(""_Example_2"")
/// >>> fix_spaces(String::from("" Example 3""))
/// String::from(""_Example-3"")
fn fix_spaces(text: String) -> String {
","fn fix_spaces(text: String) -> String {
    let mut result = String::new();
    let mut space_count = 0;

    for c in text.chars() {
        if c == ' ' {
            space_count += 1;
        } else {
            if space_count > 2 {
                result.push('-');
            } else if space_count > 0 {
                result.push_str(&""_"".repeat(space_count));
            }
            result.push(c);
            space_count = 0;
        }
    }

    if space_count > 2 {
        result.push('-');
    } else if space_count > 0 {
        result.push_str(&""_"".repeat(space_count));
    }
    
    result
}","}

fn main() {
    let candidate = fix_spaces;
    assert_eq!(candidate(String::from(""Example"")), String::from(""Example""));
    assert_eq!(candidate(String::from(""Mudasir Hanif "")), String::from(""Mudasir_Hanif_""));
    assert_eq!(candidate(String::from(""Yellow Yellow  Dirty  Fellow"")), String::from(""Yellow_Yellow__Dirty__Fellow""));
    assert_eq!(candidate(String::from(""Exa   mple"")), String::from(""Exa-mple""));
    assert_eq!(candidate(String::from(""   Exa 1 2 2 mple"")), String::from(""-Exa_1_2_2_mple""));
}
"
HumanEval_141,nus_Latn,rs,"/// Cäätni̱: /// - Kä thöp-thɛrn in ba guɔ̱ɔ̱r ɛ dot ba kɛl kä ti̱ti̱: ['txt', 'exe', 'dll'] /// kä Latin alpabet ('a'-'z' kɛnɛ 'A'-'Z'). /// - Kä thub-thɛrŋ ɛ ŋot /ci̱ dot bi̱ te baaŋ, kä jɛn bɛ tok kɛ wargak mi̱ bëë kä /// - Kä ciöt in ca gɔ̱r kä paylɛ tëkɛ dɔt kɛl '.' /// - /Thiɛlɛ di̱ji̱tni̱ ti̱ ŋuan kä diɔ̱k ('0'-'9') rɛy ci̱ötdä kɛ̈l kɛ̈ɛ̈li̱. ///ca kɛ mat: /// Ci̱öt mi̱ la̱tkɛ kɛ kui̱i̱ kä mi̱ ci̱e̱e̱ mi̱ ci̱kɛ la̱t kɛndiaal tin la̱tkɛ ɛ nɛy ti̱ti̱ /// 'Ɣɔ̱ɔ̱n' mi̱ ci̱ ciöt in ca gɔ̱r ɛ thuɔ̱k, kä locni̱ '/Cɛ' mi̱ dɔ̱ŋ./// Ji̱i̱ni̱ pa̱ŋciin mi̱ naŋkɛ thärn mi̱ cuŋ kɛ ciötdɛ kä ba loc ɛ la /// >>> file_name_check(String::from(""example.txt""))
/// String::from(""Yes"")
/// >>> file_name_check(String::from(""1example.dll""))
/// String::from(""No"")
fn file_name_check(file_name: String) -> String {
","fn file_name_check(file_name: String) -> String {
    let parts: Vec<&str> = file_name.split('.').collect();

    if parts.len() != 2 {
        return String::from(""No"");
    }

    let before_dot = parts[0];
    let after_dot = parts[1];

    if before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic() {
        return String::from(""No"");
    }

    let digit_count = before_dot.chars().filter(|c| c.is_digit(10)).count();
    if digit_count > 3 {
        return String::from(""No"");
    }

    match after_dot {
        ""txt"" | ""exe"" | ""dll"" => String::from(""Yes""),
        _ => String::from(""No""),
    }
}","}

fn main() {
    let candidate = file_name_check;
    assert_eq!(candidate(String::from(""example.txt"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""1example.dll"")), String::from(""No""));
    assert_eq!(candidate(String::from(""s1sdf3.asd"")), String::from(""No""));
    assert_eq!(candidate(String::from(""K.dll"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""MY16FILE3.exe"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""His12FILE94.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""_Y.txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""?aREYA.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""/this_is_valid.dll"")), String::from(""No""));
    assert_eq!(candidate(String::from(""this_is_valid.wow"")), String::from(""No""));
    assert_eq!(candidate(String::from(""this_is_valid.txt"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""this_is_valid.txtexe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""#this2_i4s_5valid.ten"")), String::from(""No""));
    assert_eq!(candidate(String::from(""@this1_is6_valid.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""this_is_12valid.6exe4.txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""all.exe.txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""I563_No.exe"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""Is3youfault.txt"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""no_one#knows.dll"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""1I563_Yes3.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""I563_Yes3.txtt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""final..txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""final132"")), String::from(""No""));
    assert_eq!(candidate(String::from(""_f4indsartal132."")), String::from(""No""));
    assert_eq!(candidate(String::from("".txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""s."")), String::from(""No""));
}
"
HumanEval_142,nus_Latn,rs,"/// Cäätni̱: /// gɛr kɛn tin ca la̱th rɛy bɛktɔr min ci̱ indi̱dhɛthkiɛn /ci̱kɛ ti̱ ŋuan kä 3 kiɛ 4. Kä pa̱ŋciin bɛ kulɛ loc ni̱ min ca mat kä tin ca la̱th./// ɛ mi̱ la gua̱c kä 3 kä bɛ cubi̱ la̱t intejeri̱ mi̱ ci̱ i̱ndɛkdɛ ɛ mi̱ la gua̱c kä 4 kä /ci̱ɛɛ mi̱ la gua̱c kä 3./// La̱t ɛmɛ bɛ naŋ ɛ la intɛgeri̱ bɛktɔr. kɛ kui̱ kä tin ca gɔ̱r rɛy bɛktɔrä, la̱t bɛ räth kä i̱thki̱ɛr intɛgeri̱ ɛni̱ mi̱ ɛ indi̱dhɛthdɛ ɛ a /// ""  kɛ/// >>> lst
/// vec![1, 2, 3]
/// >>> lst
/// vec![]
/// >>> lst
/// vec![-1, -5, 2, -1, -5]
fn sum_squares(lst: Vec<isize>) -> isize {
","fn sum_squares(lst: Vec<isize>) -> isize {
    lst.into_iter()
        .enumerate()
        .map(|(i, value)| {
            if i % 3 == 0 {
                value * value
            } else if i % 4 == 0 {
                value * value * value
            } else {
                value
            }
        })
        .sum()
}

fn main() {
    let lst = vec![1, 2, 3];
    println!(""{}"", sum_squares(lst)); // Outputs: 14

    let lst = vec![];
    println!(""{}"", sum_squares(lst)); // Outputs: 0

    let lst = vec![-1, -5, 2, -1, -5];
    println!(""{}"", sum_squares(lst)); // Outputs: 112
}","}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1, 2, 3]), 6);
    assert_eq!(candidate(vec![1, 4, 9]), 14);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);
    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);
    assert_eq!(candidate(vec![0]), 0);
    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);
    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);
    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);
    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);
    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);
}
"
HumanEval_143,nus_Latn,rs,"/// Cäät kä 1: ///kä min ca lat rɛy rie̱tdä min pay la̱t bi̱ kɛnɛ ti̱ cäät kɛ tin ca la̱t ni̱ wal./// min bäärɛ ɛ mi̱ la praam nämbäri̱, ///kä bi̱diöö ɛ mɔ bi̱ ji̱ lɛ loc ni̱ rie̱t tin te rɛy rie̱tdä min nhiam, /// ci̱ thënt tekɛ rie̱t ti̱ ca da̱a̱k ɛ kam, ///Ca ji̱ moc kɛ bi̱ɛl mi̱ cuŋ kɛ kui̱ thënciɛn, /// >>> words_in_sentence(String::from(""This is a test""))
/// String::from(""is"")
/// Example 2:
/// >>> words_in_sentence(String::from(""lets go for swimming""))
/// String::from(""go for"")
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
fn words_in_sentence(sentence: String) -> String {
","fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn words_in_sentence(sentence: String) -> String {
    let words: Vec<&str> = sentence.split_whitespace().collect();
    let prime_length_words: Vec<&str> = words
        .iter()
        .filter(|&&word| is_prime(word.len()))
        .cloned()
        .collect();
    prime_length_words.join("" "")
}

fn main() {
    assert_eq!(
        words_in_sentence(String::from(""This is a test"")),
        String::from(""is"")
    );
    assert_eq!(
        words_in_sentence(String::from(""lets go for swimming"")),
        String::from(""go for"")
    );
}","}

fn main() {
    let candidate = words_in_sentence;
    assert_eq!(candidate(String::from(""This is a test"")), String::from(""is""));
    assert_eq!(candidate(String::from(""lets go for swimming"")), String::from(""go for""));
    assert_eq!(candidate(String::from(""there is no place available here"")), String::from(""there is no place""));
    assert_eq!(candidate(String::from(""Hi I am Hussein"")), String::from(""Hi am Hussein""));
    assert_eq!(candidate(String::from(""go for it"")), String::from(""go for it""));
    assert_eq!(candidate(String::from(""here"")), String::from(""""));
    assert_eq!(candidate(String::from(""here is"")), String::from(""is""));
}
"
HumanEval_144,nus_Latn,rs,"/// Ji̱n deri̱ jɛ ŋac i̱ x, kɛnɛ n kɛn kɛ pi̱rɛkciɔni̱ ti̱ la̱tkɛ, kä /ci̱kɛ dhɛrö bi̱ pa̱a̱r cie min la dɔminömɛtɛr./// <numerɛtɔr>/<nudenemina̱tɔr> gua̱th in bi̱ kɛn numɛtɛr kɛnɛ denemina̱tɔr kɛn bi̱ kɛnɛ nämbäri̱ ti̱ puɔthtip./// mi̱ dɔ̱ŋ. kɛn rɛw x kɛnɛ n, kɛn kɛ ti̱ cuŋkɛ ɛ la ti̱ ca ŋun ɛ la nyin pi̱rɛkciɔn, kɛnɛ ɣöö tekɛ kɛ ta̱a̱ in ba guɔ̱r, /// x * n. La̱t ɛ nyɔk kɛ loc ɛ la thuɔ̱k mi̱ x * n ɛ mi̱ ca pekdɛ ŋa̱c kä ɛ mi̱ la thuɔ̱k kä ɛ mi̱ /ci̱ thuɔ̱k./// La̱tdu ɛ ɣöö bi̱ la̱t ɛ lät kɛ ɣöö bɛ min bi̱ jɔɔc ɛ la̱t ɛ thi̱a̱k./// >>> simplify(String::from(""1/5""), String::from(""5/1""))
/// true
/// >>> simplify(String::from(""1/6""), String::from(""2/1""))
/// false
/// >>> simplify(String::from(""7/10""), String::from(""10/2""))
/// false
fn simplify(x: String, n: String) -> bool {
","fn gcd(a: u32, b: u32) -> u32 {
    if b == 0 {
        a
    } else {
        gcd(b, a % b)
    }
}

fn simplify(x: String, n: String) -> bool {
    let x_parts: Vec<&str> = x.split('/').collect();
    let n_parts: Vec<&str> = n.split('/').collect();
    
    let x_num: u32 = x_parts[0].parse().unwrap();
    let x_den: u32 = x_parts[1].parse().unwrap();
    let n_num: u32 = n_parts[0].parse().unwrap();
    let n_den: u32 = n_parts[1].parse().unwrap();
    
    let result_num = x_num * n_num;
    let result_den = x_den * n_den;
    
    let gcd_value = gcd(result_num, result_den);
    
    result_den / gcd_value == 1
}","}

fn main() {
    let candidate = simplify;
    assert_eq!(candidate(String::from(""1/5""), String::from(""5/1"")), true);
    assert_eq!(candidate(String::from(""1/6""), String::from(""2/1"")), false);
    assert_eq!(candidate(String::from(""5/1""), String::from(""3/1"")), true);
    assert_eq!(candidate(String::from(""7/10""), String::from(""10/2"")), false);
    assert_eq!(candidate(String::from(""2/10""), String::from(""50/10"")), true);
    assert_eq!(candidate(String::from(""7/2""), String::from(""4/2"")), true);
    assert_eq!(candidate(String::from(""11/6""), String::from(""6/1"")), true);
    assert_eq!(candidate(String::from(""2/3""), String::from(""5/2"")), false);
    assert_eq!(candidate(String::from(""5/2""), String::from(""3/5"")), false);
    assert_eq!(candidate(String::from(""2/4""), String::from(""8/4"")), true);
    assert_eq!(candidate(String::from(""2/4""), String::from(""4/2"")), true);
    assert_eq!(candidate(String::from(""1/5""), String::from(""5/1"")), true);
    assert_eq!(candidate(String::from(""1/5""), String::from(""1/5"")), false);
}
"
HumanEval_145,nus_Latn,rs,"/// Ciee cäät ɛmɛ: /// ca̱a̱r kɛ jɛ kɛ kui̱ indi̱i̱thdiɛn rɛy original bɛktɔr.///Nötë: mi̱ tëë kɛ ti̱ ŋuan ti̱ te kɛɛl kɛ min ca mat kä di̱jitni̱kiɛn, ///rɛydɛ rɔ re̱p kɛ ɣöö bɛ kulɛ wä nhial kɛ pek di̱jitni̱kiɛn.///Cu gɔ̱r kɛ pa̱ŋcin min bi̱ thɔɔrɛ ɛn intɛrjɛr bɛktɔr mi̱ ca ŋun /// >>> order_by_points(vec![1, 11, -1, -11, -12])
/// vec![-1, -11, 1, -12, 11]
/// >>> order_by_points(vec![])
/// Vec::<isize>::new()
fn order_by_points(nums: Vec<isize>) -> Vec<isize> {
","fn order_by_points(nums: Vec<isize>) -> Vec<isize> {
    let mut nums_with_indices: Vec<(isize, usize)> = nums.iter().cloned().enumerate().collect();

    nums_with_indices.sort_by_key(|&(num, index)| {
        let sum_of_digits = num.abs().to_string().chars().map(|c| c.to_digit(10).unwrap_or(0) as isize).sum::<isize>();
        (sum_of_digits, index)
    });

    nums_with_indices.iter().map(|&(num, _)| num).collect()
}

fn main() {
    // Example usage
    let sorted = order_by_points(vec![1, 11, -1, -11, -12]);
    println!(""{:?}"", sorted); // Output: [-1, -11, 1, -12, 11]
}","}

fn main() {
    let candidate = order_by_points;
    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);
    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);
}
"
HumanEval_146,nus_Latn,rs,"/// Ciee cäät ɛmɛ: /// ci̱kɛ kɔn kɛnɛ di̱jit in jɔak kä nämbär ɛ mi̱ /ci̱ mɔ a kɛl (1, 3, 5, 7, 9)./// nämbär ɛlɛmɛni̱ rɛy bɛktɔr min di̱tni̱ jɛn kä 10 kɛnɛ rɛw /// Ca̱p mi̱ la̱tkɛ kɛ ɣöö ba nämbäri̱ naŋ ɛ la ti̱ ca mat kä ba locni̱kɛ./// >>> specialFilter(vec![15, -73, 14, -15])
/// 1
/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])
/// 2
fn specialFilter(nums: Vec<isize>) -> isize {
","fn specialFilter(nums: Vec<isize>) -> isize {
    nums.into_iter().filter(|&num| {
        let abs_num = num.abs();
        abs_num > 10 && {
            let digits: Vec<u8> = abs_num.to_string().bytes().map(|b| b - b'0').collect();
            let first_digit = digits.first().unwrap();
            let last_digit = digits.last().unwrap();
            first_digit % 2 == 1 && last_digit % 2 == 1
        }
    }).count() as isize
}

// Example usage:
// fn main() {
//     let result1 = specialFilter(vec![15, -73, 14, -15]);
//     println!(""{}"", result1); // Output: 1

//     let result2 = specialFilter(vec![33, -2, -3, 45, 21, 109]);
//     println!(""{}"", result2); // Output: 2
// }","}

fn main() {
    let candidate = specialFilter;
    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);
    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);
    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);
    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);
    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
}
"
HumanEval_147,nus_Latn,rs,"/// Cäätdɛ: /// kä a[i] + a[j] + a[k] ɛ mi̱ la ti̱ ŋuan kä 3. /// Läthni̱ nämbär kä diɔ̱k (a[i], a[j], a[k]) kä a gua̱th in i < j < k, /// Kɛ kui̱ kä i̱thkuɛr i̱thkuɛrä (1 ≤ i ≤ n), kä ba̱li̱ö duŋ a[i] = i * i - i + 1. /// Ca ji̱ moc nämbär mi̱ puɔthtip intejer n. Ji̱n bi̱ yi̱k ni̱ intɛr bɛktɔr mi̱ tekɛ bär n./// >>> get_max_triples(5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
fn get_max_triples(n: isize) -> isize {
","fn get_max_triples(n: isize) -> isize {
    let mut a = Vec::new();
    for i in 1..=n {
        a.push(i * i - i + 1);
    }
    
    let mut count = 0;
    for i in 0..n {
        for j in i+1..n {
            for k in j+1..n {
                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {
                    count += 1;
                }
            }
        }
    }
    count
}

fn main() {
    println!(""{}"", get_max_triples(5)); // Output: 1
}","}

fn main() {
    let candidate = get_max_triples;
    assert_eq!(candidate(5), 1);
    assert_eq!(candidate(6), 4);
    assert_eq!(candidate(10), 36);
    assert_eq!(candidate(100), 53361);
}
"
HumanEval_149,nus_Latn,rs,"/// Ciee cäät ɛmɛ: ///Ci̱ rɔ lot ɛn ɣöö bi̱ rieet diaal tekɛ pek mi̱ päär./// La̱t in la̱tkɛ bɛ yi̱k loc ni̱ pekdɛ min ca riali̱kä kɛ duɔ̱ɔ̱p mi̱ ca riali̱kä.//Mi̱ ci̱ rie̱e̱t da̱ŋ rɛw tekɛ kɛ pek mi̱ päär, ba ba̱li̱ bɛktɔr lɛpdɛ kɛ alpabethi̱d./// bi̱ yi̱k loc ni̱ pekdɛ min ca riali̱kä kɛ ŋuɔ̱t ɛmɔ.///Ci̱kɛ bi̱ lɛ wɔ̱ nhial kɛ pek in ci̱kɛ rɔ̱ɔ̱diɛn la̱t, kä bi̱ kɛn rɔ̱ɔ̱diɛn la̱t ɛ kɛn.///kä dɔ̱ŋ bɛ tekɛ duplikɛtni̱.///Kä bɛc ni̱ ciaaŋ ɛ bɛc mi̱ la thi̱ri̱ndi̱ni̱ kä /ci̱ɛ bɛc mi̱ la nämbäri̱, /// kä locdɛ ɛ bɛc kä bɛc in ci̱ ben raar kɛ duɔ̱ɔ̱p mi̱ ca riali̱kä, ///ci̱kɛ bi̱ lɛ be̱n woc kä ci̱kɛ bi̱ te̱e̱ kɛ ti̱ /ci̱ mɔ a ti̱ /ci̱ mɔ a ti̱ /ci̱ mɔ a ti̱ /ci̱ mɔ a ti̱ /ci̱ mɔ a ti̱ /ci̱ mɔ a ti̱ /ci̱ mɔ a ti̱ /ci̱ mɔ a ti̱ /ci̱ mɔ a ti̱///Cu gɔr ɛ la̱t mi̱ nhɔkɛ kä bi̱ rɔ lot kɛ duɔ̱ɔ̱r mi̱ la parɛmatɛr, /// >>> list_sort(vec![String::from(""aa""), String::from(""a""), String::from(""aaa"")])
/// vec![String::from(""aa"")]
/// >>> list_sort(vec![String::from(""ab""), String::from(""a""), String::from(""aaa""), String::from(""cd"")])
/// vec![String::from(""ab""), String::from(""cd"")]
fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {
","fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {
    let mut even_length_strings: Vec<String> = lst
        .into_iter()
        .filter(|s| s.len() % 2 == 0)
        .collect();
    
    even_length_strings.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));
    
    even_length_strings
}

fn main() {
    let result = sorted_list_sum(vec![
        String::from(""aa""),
        String::from(""a""),
        String::from(""aaa""),
    ]);
    println!(""{:?}"", result); // Should print: [""aa""]

    let result = sorted_list_sum(vec![
        String::from(""ab""),
        String::from(""a""),
        String::from(""aaa""),
        String::from(""cd""),
    ]);
    println!(""{:?}"", result); // Should print: [""ab"", ""cd""]
}","}

fn main() {
    let candidate = sorted_list_sum;
    assert_eq!(candidate(vec![String::from(""aa""), String::from(""a""), String::from(""aaa"")]), vec![String::from(""aa"")]);
    assert_eq!(candidate(vec![String::from(""school""), String::from(""AI""), String::from(""asdf""), String::from(""b"")]), vec![String::from(""AI""), String::from(""asdf""), String::from(""school"")]);
    assert_eq!(candidate(vec![String::from(""d""), String::from(""b""), String::from(""c""), String::from(""a"")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""d""), String::from(""dcba""), String::from(""abcd""), String::from(""a"")]), vec![String::from(""abcd""), String::from(""dcba"")]);
    assert_eq!(candidate(vec![String::from(""AI""), String::from(""ai""), String::from(""au"")]), vec![String::from(""AI""), String::from(""ai""), String::from(""au"")]);
    assert_eq!(candidate(vec![String::from(""a""), String::from(""b""), String::from(""b""), String::from(""c""), String::from(""c""), String::from(""a"")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""aaaa""), String::from(""bbbb""), String::from(""dd""), String::from(""cc"")]), vec![String::from(""cc""), String::from(""dd""), String::from(""aaaa""), String::from(""bbbb"")]);
}
"
HumanEval_150,nus_Latn,rs,"/// Cäätni̱: /// ɛ mi̱ la praam nämbär kä bi̱ yi̱o̱w luɔ̱c kä ba̱li̱ö duŋ y mi̱ dɔ̱ŋ./// Ɛ prɔgram mi̱ thi̱a̱k mi̱ bi̱ luɔ̱c i̱thpethi̱ duŋ x mi̱ n ɛ /// >>> x_or_y(7, 34, 12)
/// 34
/// >>> x_or_y(15, 8, 5)
/// 5
fn x_or_y(n: isize, x: isize, y: isize) -> isize {
","fn x_or_y(n: isize, x: isize, y: isize) -> isize {
    fn is_prime(num: isize) -> bool {
        if num <= 1 {
            return false;
        }
        for i in 2..=((num as f64).sqrt() as isize) {
            if num % i == 0 {
                return false;
            }
        }
        true
    }
    
    if is_prime(n) {
        x
    } else {
        y
    }
}

fn main() {
    println!(""{}"", x_or_y(7, 34, 12)); // Output: 34
    println!(""{}"", x_or_y(15, 8, 5)); // Output: 5
}","}

fn main() {
    let candidate = x_or_y;
    assert_eq!(candidate(7, 34, 12), 34);
    assert_eq!(candidate(15, 8, 5), 5);
    assert_eq!(candidate(3, 33, 5212), 33);
    assert_eq!(candidate(1259, 3, 52), 3);
    assert_eq!(candidate(7919, -1, 12), -1);
    assert_eq!(candidate(3609, 1245, 583), 583);
    assert_eq!(candidate(91, 56, 129), 129);
    assert_eq!(candidate(6, 34, 1234), 1234);
    assert_eq!(candidate(1, 2, 0), 0);
    assert_eq!(candidate(2, 2, 0), 2);
}
"
HumanEval_151,nus_Latn,rs,"///ci̱kɛ bi̱ te rɛy ba̱kciɛr min la duŋ duŋ duŋ i̱thpärid. /Cuɛ bi̱ lɛ naŋni̱ nämbäri̱ tin negative kiɛ tin /ci̱ kɛn intejeri̱./// Mi̱ ca ŋun ɛ ba̱kciɛr nämbäri̱, locni̱ nämbäri̱ i̱thkuɛrɛn i̱thkuɛrɛn /// >>> double_the_difference(vec![1, 3, 2, 0])
/// 10
/// >>> double_the_difference(vec![-1, -2, 0])
/// 0
/// >>> double_the_difference(vec![9, -2])
/// 81
/// >>> double_the_difference(vec![0])
/// 0
/// If the input vector is empty, return 0.
fn double_the_difference(lst: Vec<f64>) -> isize {
","fn double_the_difference(lst: Vec<f64>) -> isize {
    lst.iter()
        .filter(|&&x| x.fract() == 0.0 && x > 0.0 && x as isize % 2 != 0)
        .map(|&x| (x as isize).pow(2))
        .sum()
}

fn main() {
    println!(""{}"", double_the_difference(vec![1.0, 3.0, 2.0, 0.0])); // 10
    println!(""{}"", double_the_difference(vec![-1.0, -2.0, 0.0])); // 0
    println!(""{}"", double_the_difference(vec![9.0, -2.0])); // 81
    println!(""{}"", double_the_difference(vec![0.0])); // 0
    println!(""{}"", double_the_difference(vec![])); // 0
}","}

fn main() {
    let candidate = double_the_difference;
    assert_eq!(candidate(Vec::<f64>::new()), 0);
    assert_eq!(candidate(vec![5.0, 4.0]), 25);
    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);
    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);
    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);
    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);
    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);
}
"
HumanEval_152,nus_Latn,rs,"/// cäät: /// kä ba̱li̱öm ɛ 0, kä mi̱ /ci̱ jɛn ba̱li̱öm ɛ jɛn abthölut dääk kam ba̱li̱öm kɛnɛ i̱thkɛr./// Luɔ̱cdɛ kɛ bendɛ mi̱ päär mi̱ nyooth pek in ci̱ rɔ rɛl kɛ jɛ. Mi̱ ca̱rkɛ jɛ i̱ ɛ thuɔ̱k, /// Ca ji̱ moc kɛ rɛw ti̱ te kɛ pekdiɛn päär kä bi̱ kɛn kɛ kulɛ pa̱a̱r, gua̱th in bi̱ index in te thi̱n nyoth ɛ päär.///La̱tdu ɛ ɣöö bi̱ ji̱n ɛ ŋa̱c i̱ ɛni̱ ram mi̱ ci̱ thuɔ̱k kä ci̱kɛ ŋak kä min ci̱ ben raar kä mat.///ciɛ mi̱ de kɔnɛ la̱t kɛ ɣöö bi̱ kɔnɛ pa̱a̱r.///Ci̱ gua̱a̱th ɛmɔ ni̱ wän, kä ca̱riɛn kɛnɛ cärkiɛn tin te rɛy gua̱th ɛmɔ kɛn kɛ ti̱ ca ŋa̱c./// Cä jɛ car ɛn ɣöö kɔn diaal canɛ ca̱r ɛmɔ tim mi̱ ci̱ min caar kɛ pek mi̱ bäär ben raar./// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])
/// vec![0, 0, 0, 0, 3, 3]
/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])
/// vec![4, 4, 1, 0, 0, 6]
fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {
","fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {
    game.iter()
        .zip(guess.iter())
        .map(|(g, gss)| (g - gss).abs())
        .collect()
}

fn main() {
    let result1 = compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]);
    let result2 = compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2]);
    println!(""{:?}"", result1); // Output: [0, 0, 0, 0, 3, 3]
    println!(""{:?}"", result2); // Output: [4, 4, 1, 0, 0, 6]
}","}

fn main() {
    let candidate = compare;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);
    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);
    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);
    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);
}
"
HumanEval_153,nus_Latn,rs,"/// Cäät: /// (kä buɔ̱mdɛ ɛ -1)./// return 'Slices.SErviNGSliCes' kɛ ɣöö 'SErviNGSliCes' ɛ jɛn in bumni̱jɛn kä repdɛ /// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] kɛ kɔrɛ bi̱ ji̱n bi̱ lɛ go̱r i̱ /// Cäätdɛ, mi ca ji̱ ka̱m ""Thi̱i̱cni̱"" cie ki̱lɛth kɛnɛ bɛktɔr duŋ ///cuɛ ram min nhiam rɛy bɛktɔr mɛk.//Mi̱ tëë kɛ rɛw kiɛ ti̱ ŋuan ti̱ ci̱ rɔ̱ räth kä päär, bi̱ ji̱n rɔ bi̱ lɛ luäŋ kɛ ɣöö bi̱ kɛ kuëŋ thi̱n./// format: ClassName.StrongestExtensionName. /// Ji̱n bi̱ yi̱k ji̱ek kɛ ɣöö bi̱ ji̱ek mi̱ bum jek kä bi̱ yi̱k loc ɛ la mi̱ te rɛy kä nɛmɛ./// rɛy ciötä min ca gɔ̱r, ɛn buɔ̱mdɛ ca ŋun ɛ puɔrkciɔn CAP - SM. /// wargakni̱ rɛy ciöt in ca gɔ̱r ɛ kuär, kɛnɛ ɣöö bi̱ SM ɛ nämbär kä wargakni̱ tin tɔatni̱ /// buɔ̱m kä mi̱ ca rëp ɛ mi̱ cie min te piny: Mi̱ ca CAP la̱th kä nämbäri̱ tin ca gɔ̱r kɛ ci̱öt mi̱ di̱i̱t /// Kä mi̱ ca mat piny ba la̱t kɛ ɣöö ba la̱tdiɛn kulɛ mat kä ki̱lɛthni̱ tin kɔ̱ŋ./// Ca ji̱ bi̱ ka̱m ciöt ki̱lɛthä (thɛrnd) kɛnɛ bɛktɔr mi̱ la̱thkɛ raar./// >>> Strongest_Extension(String::from(""my_class""), vec![String::from(""AA""), String::from(""Be""), String::from(""CC"")])
/// String::from(""my_class.AA"")
fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {
","fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {
    let mut strongest_extension = String::new();
    let mut max_strength = i32::MIN;

    for extension in extensions {
        let cap_count = extension.chars().filter(|c| c.is_uppercase()).count() as i32;
        let sm_count = extension.chars().filter(|c| c.is_lowercase()).count() as i32;
        let strength = cap_count - sm_count;

        if strength > max_strength {
            max_strength = strength;
            strongest_extension = extension;
        }
    }

    format!(""{}.{}"", class_name, strongest_extension)
}","}

fn main() {
    let candidate = Strongest_Extension;
    assert_eq!(candidate(String::from(""Watashi""), vec![String::from(""tEN""), String::from(""niNE""), String::from(""eIGHt8OKe"")]), String::from(""Watashi.eIGHt8OKe""));
    assert_eq!(candidate(String::from(""Boku123""), vec![String::from(""nani""), String::from(""NazeDa""), String::from(""YEs.WeCaNe""), String::from(""32145tggg"")]), String::from(""Boku123.YEs.WeCaNe""));
    assert_eq!(candidate(String::from(""__YESIMHERE""), vec![String::from(""t""), String::from(""eMptY""), String::from(""nothing""), String::from(""zeR00""), String::from(""NuLl__""), String::from(""123NoooneB321"")]), String::from(""__YESIMHERE.NuLl__""));
    assert_eq!(candidate(String::from(""K""), vec![String::from(""Ta""), String::from(""TAR""), String::from(""t234An""), String::from(""cosSo"")]), String::from(""K.TAR""));
    assert_eq!(candidate(String::from(""__HAHA""), vec![String::from(""Tab""), String::from(""123""), String::from(""781345""), String::from(""-_-"")]), String::from(""__HAHA.123""));
    assert_eq!(candidate(String::from(""YameRore""), vec![String::from(""HhAas""), String::from(""okIWILL123""), String::from(""WorkOut""), String::from(""Fails""), String::from(""-_-"")]), String::from(""YameRore.okIWILL123""));
    assert_eq!(candidate(String::from(""finNNalLLly""), vec![String::from(""Die""), String::from(""NowW""), String::from(""Wow""), String::from(""WoW"")]), String::from(""finNNalLLly.WoW""));
    assert_eq!(candidate(String::from(""_""), vec![String::from(""Bb""), String::from(""91245"")]), String::from(""_.Bb""));
    assert_eq!(candidate(String::from(""Sp""), vec![String::from(""671235""), String::from(""Bb"")]), String::from(""Sp.671235""));
}
"
HumanEval_154,nus_Latn,rs,"/// Ca ji̱ moc rie̱e̱t da̱ŋ rɛw. Ji̱n bi̱ yi̱k loc ni̱ thuɔ̱k mi̱ ci̱ riet in rɛwdɛ kiɛ mi̱ ci̱ rɔ lɛ loc ɛ la mi̱ te rɛy rie̱e̱t in nhiam./// >>> cycpattern_check(String::from(""abcd""), String::from(""abd""))
/// false
/// >>> cycpattern_check(String::from(""hello""), String::from(""ell""))
/// true
/// >>> cycpattern_check(String::from(""whassup""), String::from(""psus""))
/// false
/// >>> cycpattern_check(String::from(""abab""), String::from(""baa""))
/// true
/// >>> cycpattern_check(String::from(""efef""), String::from(""eeff""))
/// false
/// >>> cycpattern_check(String::from(""himenss""), String::from(""simen""))
/// true
fn cycpattern_check(a: String, b: String) -> bool {
","fn cycpattern_check(a: String, b: String) -> bool {
    let len_b = b.len();
    if len_b == 0 {
        return true;
    }
    let doubled_b = b.clone() + &b;
    for i in 0..len_b {
        if let Some(sub) = doubled_b.get(i..i + len_b) {
            if a.contains(sub) {
                return true;
            }
        }
    }
    false
}","}

fn main() {
    let candidate = cycpattern_check;
    assert_eq!(candidate(String::from(""xyzw""), String::from(""xyw"")), false);
    assert_eq!(candidate(String::from(""yello""), String::from(""ell"")), true);
    assert_eq!(candidate(String::from(""whattup""), String::from(""ptut"")), false);
    assert_eq!(candidate(String::from(""efef""), String::from(""fee"")), true);
    assert_eq!(candidate(String::from(""abab""), String::from(""aabb"")), false);
    assert_eq!(candidate(String::from(""winemtt""), String::from(""tinem"")), true);
}
"
HumanEval_155,nus_Latn,rs,"/// Cäät: /// Mi̱ ca ŋun ɛ intejeri̱, locni̱ tuple mi̱ tekɛ nämbär mi̱ päär kɛnɛ di̱jitni̱ ti̱ /ci̱ päär kɛrɔ̱./// >>> even_odd_count(-12)
/// (1, 1)
/// >>> even_odd_count(123)
/// (1, 2)
fn even_odd_count(num: isize) -> (isize, isize) {
","fn even_odd_count(num: isize) -> (isize, isize) {
    let mut even_count = 0;
    let mut odd_count = 0;
    let num_str = num.abs().to_string();
    
    for ch in num_str.chars() {
        if let Some(digit) = ch.to_digit(10) {
            if digit % 2 == 0 {
                even_count += 1;
            } else {
                odd_count += 1;
            }
        }
    }
    
    (even_count, odd_count)
}","}

fn main() {
    let candidate = even_odd_count;
    assert_eq!(candidate(7), (0, 1));
    assert_eq!(candidate(-78), (1, 1));
    assert_eq!(candidate(3452), (2, 2));
    assert_eq!(candidate(346211), (3, 3));
    assert_eq!(candidate(-345821), (3, 3));
    assert_eq!(candidate(-2), (1, 0));
    assert_eq!(candidate(-45347), (2, 3));
    assert_eq!(candidate(0), (1, 0));
}
"
HumanEval_156,nus_Latn,rs,"/// Cäätni̱: /// Kɛn tin ca thany: 1 <= num <= 1000 ///kä luɔ̱c ɛ rɛy kä min ca gɔ̱r piny./// Mi̱ ca ŋun ɛ la mi̱ tekɛ puɔ̱thitib intejeri̱, ba Roman nämbäri̱dɛ mi̱ päärkɛ jiek cie mi̱ ɛ thi̱ri̱nd, /// >>> int_to_mini_roman(19)
/// String::from(""xix"")
/// >>> int_to_mini_roman(152)
/// String::from(""clii"")
/// >>> int_to_mini_roman(426)
/// String::from(""cdxxvi"")
fn int_to_mini_roman(number: isize) -> String {
","fn int_to_mini_roman(mut number: isize) -> String {
    let roman_numerals = [
        (1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
        (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
        (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""),
        (1, ""i""),
    ];
    
    let mut result = String::new();
    
    for &(value, symbol) in roman_numerals.iter() {
        while number >= value {
            number -= value;
            result.push_str(symbol);
        }
    }
    
    result
}","}

fn main() {
    let candidate = int_to_mini_roman;
    assert_eq!(candidate(19), String::from(""xix""));
    assert_eq!(candidate(152), String::from(""clii""));
    assert_eq!(candidate(251), String::from(""ccli""));
    assert_eq!(candidate(426), String::from(""cdxxvi""));
    assert_eq!(candidate(500), String::from(""d""));
    assert_eq!(candidate(1), String::from(""i""));
    assert_eq!(candidate(4), String::from(""iv""));
    assert_eq!(candidate(43), String::from(""xliii""));
    assert_eq!(candidate(90), String::from(""xc""));
    assert_eq!(candidate(94), String::from(""xciv""));
    assert_eq!(candidate(532), String::from(""dxxxii""));
    assert_eq!(candidate(900), String::from(""cm""));
    assert_eq!(candidate(994), String::from(""cmxciv""));
    assert_eq!(candidate(1000), String::from(""m""));
}
"
HumanEval_157,nus_Latn,rs,"/// Cäät: /// 90 di̱gri̱i̱. /// Rɛgët-angi̱li̱ tra̱i̱ŋgi̱l ɛ tra̱i̱ŋgi̱l mi̱ te gua̱a̱th kɛl ɛ la rektangɔl kiɛ ɛ rektangɔl/// ci̱ thëëdni̱kɛ ɛ la̱t kɛ ɛ la̱t mi̱ cuŋ ɛ la ti̱c (right-angled triangle), ɛ kac mi̱ dɔ̱ŋ.//Mi̱ ca pek ɛ wä kä kui̱c in diɔ̱k kä kui̱c in diɔ̱kdiɛn kä tri̱angle, bɛ loc ni̱ thuɔ̱k mi̱ ci̱ kɛn diɔ̱k ɛ wä kä kui̱c in diɔ̱kdiɛn./// >>> right_angle_triangle(3, 4, 5)
/// true
/// >>> right_angle_triangle(1, 2, 3)
/// false
fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {
","fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {
    let mut sides = [a, b, c];
    sides.sort_unstable();

    let [x, y, z] = sides;
    x * x + y * y == z * z
}","}

fn main() {
    let candidate = right_angle_triangle;
    assert_eq!(candidate(3, 4, 5), true);
    assert_eq!(candidate(1, 2, 3), false);
    assert_eq!(candidate(10, 6, 8), true);
    assert_eq!(candidate(2, 2, 2), false);
    assert_eq!(candidate(7, 24, 25), true);
    assert_eq!(candidate(10, 5, 7), false);
    assert_eq!(candidate(5, 12, 13), true);
    assert_eq!(candidate(15, 8, 17), true);
    assert_eq!(candidate(48, 55, 73), true);
    assert_eq!(candidate(1, 1, 1), false);
    assert_eq!(candidate(2, 2, 10), false);
}
"
HumanEval_158,nus_Latn,rs,"/// ci̱kɛ rɔ̱ɔ̱diɛn la̱th kä ci̱kɛ rɔ̱ɔ̱diɛn la̱th kä ci̱kɛ rɔ̱ɔ̱diɛn la̱th kä ci̱kɛ rɔ̱ɔ̱diɛn la̱th kä ci̱kɛ rɔ̱ɔ̱diɛn la̱th kä ci̱kɛ rɔ̱ɔ̱diɛn la̱th./// duŋ kä tin la nyin kɛl. Mi̱ ca thɛrpɛri̱ ti̱ ŋuan la̱t kɛ pek mi̱ di̱i̱t kä tin la nyin kɛl./// Kä bɛktɔr tëkɛ rie̱e̱t ti̱ gööl. Lätni̱ rie̱e̱t kɛ pek in di̱tni̱ jɛn kä nämbär ///Cu gɔr ɛ la̱t mi̱ nhɔkɛ ni̱ ti̱ ŋuan ti̱ la̱tkɛ ɛ thi̱rŋ./// >>> find_max(vec![String::from(""name""), String::from(""of""), String::from(""string"")])
/// String::from(""string"")
/// >>> find_max(vec![String::from(""name""), String::from(""enam""), String::from(""game"")])
/// String::from(""enam"")
/// >>> find_max(vec![String::from(""aaaaaaa""), String::from(""bb""), String::from(""cc"")])
/// String::from(""aaaaaaa"")
fn find_max(words: Vec<String>) -> String {
","fn find_max(words: Vec<String>) -> String {
    fn unique_char_count(s: &str) -> usize {
        let mut chars: std::collections::HashSet<char> = std::collections::HashSet::new();
        for c in s.chars() {
            chars.insert(c);
        }
        chars.len()
    }

    words
        .into_iter()
        .max_by(|a, b| {
            let count_a = unique_char_count(a);
            let count_b = unique_char_count(b);
            count_a.cmp(&count_b).then_with(|| a.cmp(b))
        })
        .unwrap()
}","}

fn main() {
    let candidate = find_max;
    assert_eq!(candidate(vec![String::from(""name""), String::from(""of""), String::from(""string"")]), String::from(""string""));
    assert_eq!(candidate(vec![String::from(""name""), String::from(""enam""), String::from(""game"")]), String::from(""enam""));
    assert_eq!(candidate(vec![String::from(""aaaaaaa""), String::from(""bb""), String::from(""cc"")]), String::from(""aaaaaaa""));
    assert_eq!(candidate(vec![String::from(""abc""), String::from(""cba"")]), String::from(""abc""));
    assert_eq!(candidate(vec![String::from(""play""), String::from(""this""), String::from(""game""), String::from(""of""), String::from(""footbott"")]), String::from(""footbott""));
    assert_eq!(candidate(vec![String::from(""we""), String::from(""are""), String::from(""gonna""), String::from(""rock"")]), String::from(""gonna""));
    assert_eq!(candidate(vec![String::from(""we""), String::from(""are""), String::from(""a""), String::from(""mad""), String::from(""nation"")]), String::from(""nation""));
    assert_eq!(candidate(vec![String::from(""this""), String::from(""is""), String::from(""a""), String::from(""prrk"")]), String::from(""this""));
    assert_eq!(candidate(vec![String::from(""b"")]), String::from(""b""));
    assert_eq!(candidate(vec![String::from(""play""), String::from(""play""), String::from(""play"")]), String::from(""play""));
}
"
HumanEval_159,nus_Latn,rs,"/// Cäät: ///Mi̱ /thiɛlɛ karɔ̱a̱m ti̱ ro̱ŋ ti̱ ci̱ duɔth, bi̱ ji̱n karɔ̱a̱m diaal tin ci̱ duɔth cam, duŋni̱ ɣöö bi̱ ji̱n ŋot kɛ mi̱ näk ji̱ buɔth./// nämbär in ci̱ duɔth kä karöti̱ kɛ kɔr mi̱ethdu] /// bi̱di̱ bi̱ ji̱n bi̱ ji̱n dhil locni̱ pek mi̱ [ pek in ca cam kɛ kɔr mi̱ethdu, ///Kä täämɛ go̱o̱ri̱ ɣöö bi̱ cam ni̱ karɔ̱tni̱ ti̱ ŋuan kɛ ɣöö bi̱ camku ɛn cäŋ ɛmɔ kulɛ thuɔ̱k.///Ciɛ ji̱n muul mi̱ tä kɛ buɔth, kä ci̱i̱ car kɛ mi̱ ci̱i̱ cam, /// >>> eat(5, 6, 10)
/// vec![11, 4]
/// >>> eat(4, 8, 9)
/// vec![12, 1]
/// >>> eat(1, 10, 10)
/// vec![11, 0]
/// >>> eat(2, 11, 5)
/// vec![7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {
","fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {
    let to_eat = if need <= remaining { need } else { remaining };
    vec![number + to_eat, remaining - to_eat]
}","}

fn main() {
    let candidate = eat;
    assert_eq!(candidate(5, 6, 10), vec![11, 4]);
    assert_eq!(candidate(4, 8, 9), vec![12, 1]);
    assert_eq!(candidate(1, 10, 10), vec![11, 0]);
    assert_eq!(candidate(2, 11, 5), vec![7, 0]);
    assert_eq!(candidate(4, 5, 7), vec![9, 2]);
    assert_eq!(candidate(4, 5, 1), vec![5, 0]);
}
"
HumanEval_160,nus_Latn,rs,"/// Operɛtɔr bɛ tekɛ operɛtɔr kɛl, kä operand bɛ tekɛ operandni̱ rɛw./// Operand ɛ bɛktɔr duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ duŋ/// Kä bäär operɛtɔr bɛ pa̱a̱r kɛ bäär operand bɛktɔr mi̱ thiɛl kɛl./// Cuɔŋ: /// => luɔcdɛ = 9 /// min bi̱ ben raar = 2 + 3 * 4 - 5 ///bɛktɔr = [2, 3, 4, 5] /// operator['+', '*', '-'] /// Cäät: /// Exponentiation (**)  /// Dääk piny ( //) /// Mälti̱pli̱keciɔn (*) /// Thɔ̱kciɔn ( - ) /// Matkɛ (+) /// Kä aljɛbra min la̱tkɛ ni̱ wän: /// expression kä bɛ luɔ̱c ɛkuëlaciɔn duŋ kä expression ɛmɔ.///kä bɛktɔr in rɛwdɛ ɛ bɛktɔr mi̱ la intejeri̱. La̱tdɛ kɛ bɛktɔri̱ da̱ŋ rɛw tin ca ŋun kɛ ta̱th aljɛbri̱ka /// Mi̱ ca ŋun ɛ la rɛw ti̱ la̱tkɛ ɛ bɛktɔr, kɛnɛ operand. Bɛktɔr in nhiam tekɛ aljɛbra mi̱ thi̱a̱k, kɛnɛ fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {
","fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {
    let mut result = operand[0];
    
    for i in 0..operator.len() {
        match operator[i].as_str() {
            ""+"" => result += operand[i+1],
            ""-"" => result -= operand[i+1],
            ""*"" => result *= operand[i+1],
            ""//"" => result /= operand[i+1],
            ""**"" => result = result.pow(operand[i+1] as u32),
            _ => panic!(""Unexpected operator""),
        }
    }
    
    result
}

fn main() {
    let operators = vec![""+"",""*"",""-""].iter().map(|s| s.to_string()).collect();
    let operands = vec![2, 3, 4, 5];
    let result = do_algebra(operators, operands);
    println!(""Result: {}"", result);
}","}

fn main() {
    let candidate = do_algebra;
    assert_eq!(candidate(vec![String::from(""**""), String::from(""*""), String::from(""+"")], vec![2, 3, 4, 5]), 37);
    assert_eq!(candidate(vec![String::from(""+""), String::from(""*""), String::from(""-"")], vec![2, 3, 4, 5]), 9);
    assert_eq!(candidate(vec![String::from(""//""), String::from(""*"")], vec![7, 3, 4]), 8);
}
"
HumanEval_161,nus_Latn,rs,"/// Cäätni̱ /// La̱t in ba la̱t bɛ cu loc ni̱ min ci̱ ben raar kä ci̱ mɔ a thi̱n.//Mi̱ thiɛlɛ ci̱öt ti̱ te rɛy thärkäl, loc thärkäl jɔk./// mi̱ /ci̱ mɔ ɛ jɛn, bi̱ la̱t ɛ mɔ ŋot thi̱n./// mi̱ ci̱ i̱thpether ɛ lɛt, bi̱kɛ gua̱thdɛ loc ɛ wä nhial ɛ wä piny kiɛ mi̱ ci̱kɛ loc jɔk, /// Ca ji̱ moc yi̱k mi̱ /ci̱ rɔ bi̱ lot. /// >>> solve(String::from(""1234""))
/// String::from(""4321"")
/// >>> solve(String::from(""ab""))
/// String::from(""AB"")
/// >>> solve(String::from(""#a@C""))
/// String::from(""#A@c"")
fn solve(s: String) -> String {
","fn solve(s: String) -> String {
    if s.chars().all(|c| !c.is_alphabetic()) {
        s.chars().rev().collect()
    } else {
        s.chars()
            .map(|c| {
                if c.is_lowercase() {
                    c.to_ascii_uppercase()
                } else if c.is_uppercase() {
                    c.to_ascii_lowercase()
                } else {
                    c
                }
            })
            .collect()
    }
}","}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(String::from(""AsDf"")), String::from(""aSdF""));
    assert_eq!(candidate(String::from(""1234"")), String::from(""4321""));
    assert_eq!(candidate(String::from(""ab"")), String::from(""AB""));
    assert_eq!(candidate(String::from(""#a@C"")), String::from(""#A@c""));
    assert_eq!(candidate(String::from(""#AsdfW^45"")), String::from(""#aSDFw^45""));
    assert_eq!(candidate(String::from(""#6@2"")), String::from(""2@6#""));
    assert_eq!(candidate(String::from(""#$a^D"")), String::from(""#$A^d""));
    assert_eq!(candidate(String::from(""#ccc"")), String::from(""#CCC""));
}
"
HumanEval_162,nus_Latn,rs,"/// Mi̱ 'ta̱a̱' ɛ mi̱ thiɛl luɔt, loc ni̱ Noth./// Mi̱ ca thärkdɛ ŋun 'text', bi̱ yi̱kdɛ loc ɛ la md5 mi̱ päär kɛ thärkdɛ./// >>> string_to_md5(String::from(""Hello world""))
/// Some(String::from(""3e25960a79dbc69b674cd4ec67a72c62""))
fn string_to_md5(text: String) -> Option<String> {
","use md5;

fn string_to_md5(text: String) -> Option<String> {
    if text.is_empty() {
        return None;
    }
    let digest = md5::compute(text);
    Some(format!(""{:x}"", digest))
}","}

fn main() {
    let candidate = string_to_md5;
    assert_eq!(candidate(String::from(""Hello world"")), Some(String::from(""3e25960a79dbc69b674cd4ec67a72c62"")));
    assert_eq!(candidate(String::from("""")), None);
    assert_eq!(candidate(String::from(""A B C"")), Some(String::from(""0ef78513b0cb8cef12743f5aeb35f888"")));
    assert_eq!(candidate(String::from(""password"")), Some(String::from(""5f4dcc3b5aa765d61d8327deb882cf99"")));
}
"
HumanEval_163,nus_Latn,rs,"/// Ciee cäät ɛmɛ: /// kɛnɛ b, kɛ ɣöö bi̱kɛ rɔ̱ re̱p./// Mi̱ ca ŋun ɛ la rɛw ti̱ puci̱tip intejeri̱ a kɛnɛ b, locni̱ ɛni̱ dhi̱ji̱tni̱ kam a /// >>> generate_integers(2, 8)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(8, 2)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(10, 14)
/// Vec::<isize>::new()
fn generate_integers(a: isize, b: isize) -> Vec<isize> {
","fn generate_integers(a: isize, b: isize) -> Vec<isize> {
    let (start, end) = if a < b { (a, b) } else { (b, a) };
    (start..=end).filter(|&x| x % 2 == 0).collect()
}

fn main() {
    let result1 = generate_integers(2, 8);
    println!(""{:?}"", result1); // Output: vec![2, 4, 6, 8]

    let result2 = generate_integers(8, 2);
    println!(""{:?}"", result2); // Output: vec![2, 4, 6, 8]

    let result3 = generate_integers(10, 14);
    println!(""{:?}"", result3); // Output: vec![10, 12, 14]
}","}

fn main() {
    let candidate = generate_integers;
    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);
    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(17, 89), Vec::<isize>::new());
}
"
