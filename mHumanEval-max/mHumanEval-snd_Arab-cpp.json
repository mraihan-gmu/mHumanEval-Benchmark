[
    {
        "task_id": "HumanEval/0",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// چيڪ ڪريو ته نمبرن جي ڏنل ويڪٽر ۾ ، ٻه نمبر هڪ ٻئي کان ويجهي آهن ڏنل حد کان. >>> has_close_elements (((std:: vector<float> ((({(float) 1.0f, (float) 2.0f, (float) 3.0f})), (0.5f)) (false) >>> has_close_elements (((std:: vector<float> (((float) 1.0f, (float) 2.8f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.0f})), (0.3f)) (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n",
        "canonical_solutions": "bool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order\n    for (size_t i = 1; i < numbers.size(); i++) {\n        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = has_close_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/1",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هن فنڪشن جو انپٽ هڪ اسٽرنگ آهي جنهن ۾ گھڻن گروهن جي گھڙيل قوسين جو هڪ سلسلو آهي. توهان جو مقصد انهن گروپن کي الڳ الڳ اسٽرنگن ۾ ڌار ڪرڻ ۽ انهن جي ويڪٽر کي واپس ڪرڻ آهي. الڳ گروپ متوازن آهن (هر کليل قوسين کي صحيح طور تي بند ڪيو ويو آهي) ۽ هڪ ٻئي جي اندر گھڙيل نه آهن انپٽ اسٽرنگ ۾ ڪنهن به جڳهه کي نظرانداز ڪيو. >>> separate_paren_groups (((\"( ) (() (()))))))) (std:: vector<std:: string> ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') continue;  // Ignore spaces\n\n        current_group += ch;\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n            if (balance == 0) {  // Found a balanced group\n                groups.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return groups;\n}",
        "test": "}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"(()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/2",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثبت فلوٽنگ پوائنٽ نمبر ڏنو ويو آهي ، اهو انٽيگر حصو (وڏي کان وڏو عدد ڏنل نمبر کان نن smallerو) ۽ اعشاري حصن ۾ ٽوڙي سگهجي ٿو (باقي حصو هميشه 1 کان نن smallerو آهي). نمبر جو اعشاري حصو واپس ڪريو. >>> truncate_number((3.5f)) (0.5f)\nfloat truncate_number(float number) {\n",
        "canonical_solutions": "float truncate_number(float number) {\n    return number - std::floor(number);\n}",
        "test": "}\nint main() {\n    auto candidate = truncate_number;\n    assert(candidate((3.5f)) == (0.5f));\n    assert(candidate((1.25f)) == (0.25f));\n    assert(candidate((123.0f)) == (0.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/3",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي هڪ بينڪ اڪائونٽ تي جمع ۽ واپسي جي عملن جو هڪ ويڪٽر ڏنو ويو آهي جيڪو صفر توازن سان شروع ٿئي ٿو. توهان جو ڪم اهو معلوم ڪرڻ آهي ته ڪنهن به وقت اڪائونٽ جي توازن صفر کان هيٺ اچي وڃي ٿي ، ۽ انهي نقطي تي فنڪشن کي صحيح موٽڻ گهرجي. ٻي صورت ۾ اهو غلط موٽڻ گهرجي. >>> below_zero(((std::vector<long>({long) 1، (long) 2، (long) 3}))) (false) >>> below_zero((std::vector<long>({long) 1، (long) 2، (long) 4، (long) 5}))) (true)\nbool below_zero(std::vector<long> operations) {\n",
        "canonical_solutions": "bool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = below_zero;\n    assert(candidate((std::vector<long>())) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/4",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انپٽ نمبرن جي ڏنل ويڪٽر لاءِ ، هن ڊيٽا سيٽ جي وچولي جي چوڌاري Mean Absolute Deviation جو حساب ڪريو. Mean Absolute Deviation هر عنصر ۽ مرڪزي نقطي جي وچ ۾ اوسط مطلق فرق آهي (هن صورت ۾ مطلب): MAD = █ x - x_mean █ >>> mean_absolute_deviation (((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n",
        "canonical_solutions": "float mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, \n                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) \n                / numbers.size();\n    return mad;\n}",
        "test": "}\nint main() {\n    auto candidate = mean_absolute_deviation;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));\n}\n"
    },
    {
        "task_id": "HumanEval/5",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// داخل ڪريو هڪ نمبر 'ڊيمٽر' انپٽ ويڪٽر جي هر ٻن لڳاتار عنصرن جي وچ ۾ `numbers' >>> intersperse((std::vector<long>() ، (4)) (std::vector<long>()) >>> intersperse((std::vector<long>({long) 1، (long) 2، (long) 3}) ، (4)) (std::vector<long>({long) 1، (long) 4، (long) 2، (long) 4، (long) 3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n",
        "canonical_solutions": "std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<long> result;\n    for (size_t i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = intersperse;\n    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));\n    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/6",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هن فنڪشن ۾ انپٽ هڪ اسٽرنگ آهي جيڪا گھڻن گروهن جي نمائندگي ڪري ٿي گھڙيل قوسين لاءِ جيڪي جڳهن کان ڌار آهن. هر هڪ گروپ لاءِ ، قوسين جي گھڙڻ جي سڀ کان گهڻي سطح کي ٻاھر ڪ outputو. مثال طور (())) وڌ ۾ وڌ ٻه سطحون آهن جڏهن ته ((())) ٽي آهن. >>> parse_nested_parens (((\"((()) ((())) () ((()))))))) (std:: vector<long>({(long) 2, (long) 3, (long) 1, (long) 3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> depths;\n    long current_depth = 0, max_depth = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') {\n            if (max_depth > 0) {\n                depths.push_back(max_depth);\n                max_depth = 0;\n            }\n            current_depth = 0;\n        } else if (ch == '(') {\n            current_depth++;\n            max_depth = std::max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n\n    if (max_depth > 0) {\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
    },
    {
        "task_id": "HumanEval/7",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// صرف انهن لاءِ اسٽرنگن جو انپٽ ويڪٽر فلٽر ڪريو جيڪي ڏنل ذيلي اسٽرنگ تي مشتمل آهن >>> filter_by_substring(((std::vector<std::string>()), (\"a\")) (std::vector<std::string>()) >>> filter_by_substring((((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bacd\", (std::string) \"cde\", (std::string) \"array\"})), (\"a\") (std::vector<std::string>(({(std::string) abc\", (std::string) \"bacd\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.find(substring) != std::string::npos) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_substring;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"aaaxxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"aaaxxy\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"grunt\", (std::string)\"trumpet\", (std::string)\"prune\", (std::string)\"gruesome\"})), (\"run\")) == (std::vector<std::string>({(std::string)\"grunt\", (std::string)\"prune\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/8",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ ڏنل عدد جي ويڪٽر لاءِ ، هڪ ٽپل موٽايو جنهن ۾ هڪ ويڪٽر ۾ سڀني عددن جو مجموعو ۽ هڪ پيداوار شامل هجي. خالي رقم 0 جي برابر هجڻ گهرجي ۽ خالي پيداوار 1 جي برابر هجڻ گهرجي. >>> sum_product (((std::vector<long> ((()) (std::make_tuple ((0, 1)) >>> sum_product (((std::vector<long> (((long) 1, (long) 2, (long) 3, (long) 4)))) (std::make_tuple ((10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);\n    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());\n    return std::make_tuple(sum, product);\n}",
        "test": "}\nint main() {\n    auto candidate = sum_product;\n    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));\n    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));\n    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));\n}\n"
    },
    {
        "task_id": "HumanEval/9",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انٽيگرز جي ڏنل ويڪٽر مان ، تسلسل ۾ ڏنل لمحي تائين مليل وڌ کان وڌ عنصر جو هڪ ويڪٽر پيدا ڪريو. >>> rolling_max(((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 2, (long) 3, (long) 4, (long) 2}))) (std::vector<long>({long) 1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = LONG_MIN;\n\n    for (long num : numbers) {\n        max_so_far = std::max(max_so_far, num);\n        result.push_back(max_so_far);\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = rolling_max;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));\n}\n"
    },
    {
        "task_id": "HumanEval/10",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سڀ کان ننڍو پاليندروم ڳوليو جيڪو فراهم ڪيل تار سان شروع ٿئي ٿو. الگورتھم جو خيال سادو آهي: - فراهم ڪيل تار جو سڀ کان ڊگهو پوسٽ فڪس ڳوليو جيڪو هڪ پاليندروم آهي. - اسٽرنگ جي آخر ۾ اسٽرنگ جي اڳڪٿي جو ريورس شامل ڪريو جيڪو پاليندرومڪ سيفڪس کان اڳ اچي ٿو. >>> make_palindrome (((\"\")) (\"\") >>> make_palindrome (((\"cat\")) (\"catac\") >>> make_palindrome (((\"cata\")) (\"catac\")\nstd::string make_palindrome(std::string string) {\n",
        "canonical_solutions": "std::string make_palindrome(std::string string) {\n    auto is_palindrome = [](const std::string &s) {\n        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());\n    };\n\n    for (size_t i = 0; i < string.size(); ++i) {\n        if (is_palindrome(string.substr(i))) {\n            std::string prefix = string.substr(0, i);\n            std::reverse(prefix.begin(), prefix.end());\n            return string + prefix;\n        }\n    }\n\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"jerry\")) == (\"jerryrrej\"));\n}\n"
    },
    {
        "task_id": "HumanEval/11",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انپٽ ٻه اسٽرنگس آهن a ۽ b صرف 1s ۽ 0s تي مشتمل آهن. انهن انپٽس تي بائنري XOR انجام ڏيو ۽ نتيجو پڻ هڪ اسٽرنگ جي طور تي موٽايو. >>> string_xor((\"010\"), (\"110\")) (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n",
        "canonical_solutions": "std::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
    },
    {
        "task_id": "HumanEval/12",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// string جي ويڪٽر کان ٻاهر، سڀ کان ڊگهو موٽايو. ساڳي ڊيگهه جي ڪيترن ئي تارن جي صورت ۾ پهريون هڪ موٽايو. ان صورت ۾ ڪوبه نه موٽايو جيڪڏهن ان پٽ ويڪٽر خالي آهي. >>> longest((std::vector<std::string>())) std::nullopt >>> longest((std::vector<std::string>{(std::string) \"a\"، (std::string) \"b\"، (std::string) \"c\"}))) \"a\" >>> longest(((std::vector<std::string>({(std::string) \"a\"، (std::string) \"bb\"، (stdstring) \"ccc\"}))) \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) return std::nullopt;\n\n    return *std::max_element(strings.begin(), strings.end(), \n                             [](const std::string& a, const std::string& b) {\n                                 return a.size() < b.size();\n                             });\n}",
        "test": "}\nint main() {\n    auto candidate = longest;\n    assert(candidate((std::vector<std::string>())) == std::nullopt);\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == \"x\");\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"yyy\", (std::string)\"zzzz\", (std::string)\"www\", (std::string)\"kkkk\", (std::string)\"abc\"}))) == \"zzzz\");\n}\n"
    },
    {
        "task_id": "HumanEval/13",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ٻه integers جي وڏي ۾ وڏي عام divisor موٽي a ۽ b >>> وڏي ۾ وڏي_عام_divisor (((3) ، (5)) (1) >>> وڏي ۾ وڏي_عام_divisor (((25), (15)) (5)\nlong greatest_common_divisor(long a, long b) {\n",
        "canonical_solutions": "long greatest_common_divisor(long a, long b) {\n    return std::gcd(a, b);\n}",
        "test": "}\nint main() {\n    auto candidate = greatest_common_divisor;\n    assert(candidate((3), (7)) == (1));\n    assert(candidate((10), (15)) == (5));\n    assert(candidate((49), (14)) == (7));\n    assert(candidate((144), (60)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/14",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سڀني اڳڪٿين جي واپسي ويڪٽر نن shortestي کان ڊگهي تائين انپٽ اسٽرنگ >>> all_prefixes (((\"abc\")) (std:: vector<std::string>({(std::string) \"a\" ، (std::string) \"ab\" ، (std::string) \"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n",
        "canonical_solutions": "std::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (size_t i = 1; i <= string.size(); ++i) {\n        prefixes.push_back(string.substr(0, i));\n    }\n    return prefixes;\n}",
        "test": "}\nint main() {\n    auto candidate = all_prefixes;\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"asdfgh\")) == (std::vector<std::string>({(std::string)\"a\", (std::string)\"as\", (std::string)\"asd\", (std::string)\"asdf\", (std::string)\"asdfg\", (std::string)\"asdfgh\"})));\n    assert(candidate((\"WWW\")) == (std::vector<std::string>({(std::string)\"W\", (std::string)\"WW\", (std::string)\"WWW\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/15",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ اسٽرنگ واپس ڪريو جنهن ۾ 0 کان شروع ٿيندڙ ۽ n تائين شامل ڪيل نمبر شامل آهن. >>> string_sequence((0)) (\"0\") >>> string_sequence((5)) (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n",
        "canonical_solutions": "std::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i > 0) oss << \" \";\n        oss << i;\n    }\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_sequence;\n    assert(candidate((0)) == (\"0\"));\n    assert(candidate((3)) == (\"0 1 2 3\"));\n    assert(candidate((10)) == (\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"
    },
    {
        "task_id": "HumanEval/16",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ اسٽرنگ ڏني وئي، ڳولي وٺو ته ڪيترا مختلف اکر (سواءِ ڪيس جي) ان ۾ شامل آهن >>> count_distinct_characters (((\"xyzXYZ\")) (3) >>> count_distinct_characters (((\"Jerry\")) (4)\nlong count_distinct_characters(std::string string) {\n",
        "canonical_solutions": "long count_distinct_characters(std::string string) {\n    std::unordered_set<char> distinct_chars;\n    for (char ch : string) {\n        distinct_chars.insert(std::tolower(ch));\n    }\n    return distinct_chars.size();\n}",
        "test": "}\nint main() {\n    auto candidate = count_distinct_characters;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abcde\")) == (5));\n    assert(candidate((\"abcdecadeCADE\")) == (5));\n    assert(candidate((\"aaaaAAAAaaaa\")) == (1));\n    assert(candidate((\"Jerry jERRY JeRRRY\")) == (5));\n}\n"
    },
    {
        "task_id": "HumanEval/17",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هن فنڪشن ۾ داخل ٿيل هڪ اسڪرپٽ آهي جيڪو موسيقي نوٽس کي ASCII فارميٽ ۾ ظاهر ڪري ٿو. توهان جي انٽيگر جي تار جي تار جي وڪٽ کي پارس ڪرڻ آهي جيڪا ڪيتريون ئي بيٽس سان ملندي آهي. هتي هڪ ليجنڊ آهي: 'o' نوٽ، آخري چار بيٽس 'o' ڪيس '- آخري اڌ نوٽ، آخري ٻه بيٽس '- آخري نوٽ، آخري هڪ >>> parse_music. \"(o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o\nstd::vector<long> parse_music(std::string music_string) {\n",
        "canonical_solutions": "std::vector<long> parse_music(std::string music_string) {\n    std::vector<long> beats;\n    std::istringstream iss(music_string);\n    std::string note;\n    \n    while (iss >> note) {\n        if (note == \"o\") beats.push_back(4);\n        else if (note == \"o|\") beats.push_back(2);\n        else if (note == \".|\") beats.push_back(1);\n    }\n\n    return beats;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_music;\n    assert(candidate((\"\")) == (std::vector<long>()));\n    assert(candidate((\"o o o o\")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\".| .| .| .|\")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));\n    assert(candidate((\"o| o| .| .| o o o o\")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\"o| .| o| .| o o| o o|\")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/18",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڳولي وٺو ته اصل اسٽرنگ ۾ ڏنل ذيلي اسٽرنگ ڪيترا ڀيرا ملي سگهي ٿي. اوورلوپنگ ڪيس ڳڻپ ڪريو. >>> how_many_times((\"\"), (\"a\")) (0) >>> how_many_times(\"aaa\"), (\"a\")) (3) >>> how_many_times(\"aaaa\"), (\"aa\") (3)\nlong how_many_times(std::string string, std::string substring) {\n",
        "canonical_solutions": "long how_many_times(std::string string, std::string substring) {\n    if (substring.empty()) return 0;\n    \n    long count = 0;\n    size_t pos = 0;\n    \n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++;  // Move one position forward to count overlapping occurrences\n    }\n    \n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = how_many_times;\n    assert(candidate((\"\"), (\"x\")) == (0));\n    assert(candidate((\"xyxyxyx\"), (\"x\")) == (4));\n    assert(candidate((\"cacacacac\"), (\"cac\")) == (4));\n    assert(candidate((\"john doe\"), (\"john\")) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/19",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انپٽ 'صفر' کان 'نو' تائين عددن جي هڪ جڳهه سان محدود تار آهي. صحيح چونڊون آهن 'صفر'، 'هڪ'، 'ٻه'، 'ٽي'، 'چار'، 'پنج'، 'ڇهه'، 'سَت'، 'اٺ' ۽ 'نو'. نن smallestي کان وڏي تائين ترتيب ڏنل انگن سان تار واپس ڪريو >>> sort_numbers((\"ٽي هڪ پنج\")) (\"هڪ ٽي پنج\")\nstd::string sort_numbers(std::string numbers) {\n",
        "canonical_solutions": "std::string sort_numbers(std::string numbers) {\n    std::unordered_map<std::string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    std::unordered_map<int, std::string> rev_map = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    std::istringstream iss(numbers);\n    std::vector<int> num_list;\n    std::string word;\n\n    while (iss >> word) {\n        num_list.push_back(num_map[word]);\n    }\n\n    std::sort(num_list.begin(), num_list.end());\n\n    std::ostringstream oss;\n    for (size_t i = 0; i < num_list.size(); ++i) {\n        if (i > 0) oss << \" \";\n        oss << rev_map[num_list[i]];\n    }\n\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = sort_numbers;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"three\")) == (\"three\"));\n    assert(candidate((\"three five nine\")) == (\"three five nine\"));\n    assert(candidate((\"five zero four seven nine eight\")) == (\"zero four five seven eight nine\"));\n    assert(candidate((\"six five four three two one zero\")) == (\"zero one two three four five six\"));\n}\n"
    },
    {
        "task_id": "HumanEval/20",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// نمبرن جي فراهم ڪيل ويڪٽر مان (گهٽ ۾ گهٽ ٻه) چونڊ ۽ ٻه واپس آڻيو جيڪي هڪ ٻئي جي ويجهو آهن ۽ انهن کي ترتيب سان واپس آڻيو (نن smallerو نمبر ، وڏو نمبر). >>> find_closest_elements (((std:: vector<float>(({(float) 1.0f ، (float) 2.0f ، (float) 3.0f ، (float) 4.0f ، (float) 5.0f ، (float) 2.2f}))) (std:: make_tuple (((2.0f ، 2.2f)) >>> find_closest_elements (((std:: vector<float>(({(float) 1.0f ، (float) 2.0f ، (float) 3.0f ، (float) 4.0f ، (float) 5.0f ، (float) 2.0f)) (std:: vector<float>) 2.0f ، (float) 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0, num2 = 0;\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = numbers[i] - numbers[i - 1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i - 1];\n            num2 = numbers[i];\n        }\n    }\n\n    return std::make_tuple(num1, num2);\n}",
        "test": "}\nint main() {\n    auto candidate = find_closest_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));\n}\n"
    },
    {
        "task_id": "HumanEval/21",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انگن جي ڏنل ويڪٽر (گهٽ ۾ گهٽ ٻن عنصرن جي) ، ان ويڪٽر کي هڪ لائينئر ٽرانسفارم لاڳو ڪريو ، جيئن ته نن smallestڙو نمبر 0 ٿي ويندو ۽ وڏو نمبر 1 ٿي ويندو >>> rescale_to_unit ((((std:: vector<float>(({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f}))) (std:: vector<float>(((((float) 0.0f, (float) 0.25f, (float) 0.5f, (float) 0.75f, (float) 1.0f))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        std::fill(numbers.begin(), numbers.end(), 0.0f);\n        return numbers;\n    }\n\n    for (float &num : numbers) {\n        num = (num - min_val) / (max_val - min_val);\n    }\n\n    return numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n}\n"
    },
    {
        "task_id": "HumanEval/22",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فلٽر ڏنو ويو آهي ته ڪنهن به cppthon قدرن جو صرف انٽيگرز لاءِ فلٽر >>> فلٽر_ انٽيگرز (((اسٽ: ويڪٽر <اسٽ: ڪو به> (((اسٽ: اسٽرنگ) \"a\" ، (اسٽ: اسٽرنگ) 3.14f ، (اسٽ: اسٽرنگ) 5}))) (اسٽ: ويڪٽر <ڊگهي> (((ڊگهي) 5})) >>> فلٽر_ انٽيگرز (((اسٽ: ويڪٽر <اسٽ: ڪو به> ((({1 ، 2 ، 3 ، \"abc\" ، اسٽ: <ڊگهي ، نقشو >) ، (((اسٽ: ويڪٽر <ڊگهي> (((())))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n",
        "canonical_solutions": "std::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (const auto& val : values) {\n        if (val.type() == typeid(long)) {\n            result.push_back(std::any_cast<long>(val));\n        } else if (val.type() == typeid(int)) {\n            result.push_back(std::any_cast<int>(val));\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_integers;\n    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));\n    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, \"adasd\"}))) == (std::vector<long>({(long)4, (long)9})));\n    assert(candidate((std::vector<std::any>({3, \"c\", 3, 3, \"a\", \"b\"}))) == (std::vector<long>({(long)3, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/23",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڏنل اسٽرنگ جي ڊيگهه واپس ڪريو >>> string_length (((\"\")) (0) >>> string_length (((\"abc\")) (3)\nlong string_length(std::string string) {\n",
        "canonical_solutions": "long string_length(std::string string) {\n    return string.length();\n}",
        "test": "}\nint main() {\n    auto candidate = string_length;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"x\")) == (1));\n    assert(candidate((\"asdasnakj\")) == (9));\n}\n"
    },
    {
        "task_id": "HumanEval/24",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ ڏنل نمبر n لاءِ، سڀ کان وڏو نمبر ڳوليو جيڪو n کي برابر طور تي ورهائي ٿو، n کان ننڍو >>> largest_divisor (((15)) (5)\nlong largest_divisor(long n) {\n",
        "canonical_solutions": "long largest_divisor(long n) {\n    for (long i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_divisor;\n    assert(candidate((3)) == (1));\n    assert(candidate((7)) == (1));\n    assert(candidate((10)) == (5));\n    assert(candidate((100)) == (50));\n    assert(candidate((49)) == (7));\n}\n"
    },
    {
        "task_id": "HumanEval/25",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// واپسي جي ترتيب ۾ ڏنل انٽيگر جي پرائم فيڪٽرز جي واپسي ويڪٽر نن smallestي کان وڏي تائين. هر هڪ عنصر کي ڀاڙڻ جي تعداد ۾ ڀاڙڻ گهرجي ته اهو ڀاڙڻ ۾ ڪيترا ڀيرا ظاهر ٿئي ٿو. انپٽ نمبر سڀني عنصرن جي پيداوار جي برابر هجڻ گهرجي >>> فئڪٽوريز (((8)) (std:: vector<long> ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> factorize(long n) {\n",
        "canonical_solutions": "std::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    for (long i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}",
        "test": "}\nint main() {\n    auto candidate = factorize;\n    assert(candidate((2)) == (std::vector<long>({(long)2})));\n    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));\n    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));\n    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));\n    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/26",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// عددن جي هڪ ويڪٽر مان ، سڀني عنصرن کي ختم ڪريو جيڪي هڪ کان وڌيڪ ڀيرا اچن ٿا. عناصر جي ترتيب کي ساڳيو ئي رکجي جيئن انپٽ ۾. >>> remove_duplicates((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 4}))) (std::vector<long>({(long) 1, (long) 3, (long) 4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::unordered_map<long, int> freq;\n    for (long num : numbers) {\n        freq[num]++;\n    }\n\n    std::vector<long> result;\n    for (long num : numbers) {\n        if (freq[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_duplicates;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));\n}\n"
    },
    {
        "task_id": "HumanEval/27",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ ڏنل اسٽرنگ لاءِ ، ننcaseن اکرن کي وڏي اکرن ۽ وڏي اکرن کي ننcaseن اکرن ۾ تبديل ڪريو. >>> flip_case (((\"Hello\")) (\"HELLO\")\nstd::string flip_case(std::string string) {\n",
        "canonical_solutions": "std::string flip_case(std::string string) {\n    for (char &ch : string) {\n        if (std::islower(ch)) {\n            ch = std::toupper(ch);\n        } else if (std::isupper(ch)) {\n            ch = std::tolower(ch);\n        }\n    }\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = flip_case;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hello!\")) == (\"hELLO!\"));\n    assert(candidate((\"These violent delights have violent ends\")) == (\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"
    },
    {
        "task_id": "HumanEval/28",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سٽرنگن جو هڪ سٽرنگ ۾ گڏيل ويڪٽر >>> گڏيل ((((std:: vector<std::string>())) (\"\") >>> گڏيل ((((std:: vector<std::string>({(std::string) \"a\" ، (std::string) \"b\" ، (std::string) \"c\"}))) (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = concatenate;\n    assert(candidate((std::vector<std::string>())) == (\"\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == (\"xyz\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\", (std::string)\"w\", (std::string)\"k\"}))) == (\"xyzwk\"));\n}\n"
    },
    {
        "task_id": "HumanEval/29",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// صرف انهن لاءِ هڪ انپٽ ويڪٽر فلٽر ڪريو جيڪي ڏنل اڳڪٿي سان شروع ٿين ٿيون. >>> filter_by_prefix((std::vector<std::string>()), (\"a\")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bcd\", (std::string) \"cde\", (stdstring) \"array\"})), (\"a\") (std::vector<std::string>(({(std::string) \"abc\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/30",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// صرف مثبت نمبر موٽايو وڪٽور ۾. >>> get_positive((std::vector<long>({long) -1, (long) -2, (long) -4, (long) -5, (long) -6}))) (std::vector<long>({long) -2, (long) -5, (long) -6})) >>> get_positive((std::vector<long>({long) -5, (long) -3, (long) -3, (long) -3, (long) -9, (long) -0, (long) -123, (long) -1, (long) -10}))) (std::vector<long>{(long) -5, (long) -3, (long) -2, (long) -3, (long) -9, (long) -123, (long) -1)))\nstd::vector<long> get_positive(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = get_positive;\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/31",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// صحيح موٽايو جيڪڏهن هڪ ڏنو ويو نمبر پرائم آهي، ۽ ٻي صورت ۾ غلط. >>> is_prime((6)) (false) >>> is_prime((101)) (true) >>> is_prime((11) (true) >>> is_prime((13441)) (true) >>> is_prime(61)) (true) >>> is_prime(4)) (false) >>> is_prime(1)) (false)\nbool is_prime(long n) {\n",
        "canonical_solutions": "bool is_prime(long n) {\n    if (n < 2) return false;\n    if (n < 4) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_prime;\n    assert(candidate((6)) == (false));\n    assert(candidate((101)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((13441)) == (true));\n    assert(candidate((61)) == (true));\n    assert(candidate((4)) == (false));\n    assert(candidate((1)) == (false));\n    assert(candidate((5)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((17)) == (true));\n    assert(candidate((85)) == (false));\n    assert(candidate((77)) == (false));\n    assert(candidate((255379)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/33",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هي فنڪشن هڪ ويڪٽر l وٺندو آهي ۽ هڪ ويڪٽر l' واپس ڪندو آهي جيئن ته l' انڊيڪس ۾ l سان برابر آهي جيڪي ٽن ۾ ورهايل نه آهن ، جڏهن ته انڊيڪس تي ان جا قدر جيڪي ٽن ۾ ورهايل آهن ، برابر آهن l جي لاڳاپيل انڊيڪس جي قدرن سان ، پر ترتيب ڏنل. >>> sort_third(((std::vector<long>{(long) 1، (long) 2، (long) 3}))) (std::vector<long>{(long) 1، (long) 2، (long) 3})) >>> sort_third((std::vector<long>{(long>{(long) 5، (long) 6، (long) 3، (long) 4، (long) 8، (long) 9، (long) 2}))) (std::vector<long>{(long>{(long>2, (long) 6، (long) 3، (long) 4، (long) 8، (long) 9، (long) 5})\nstd::vector<long> sort_third(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> third_indices;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    std::sort(third_indices.begin(), third_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        l[i] = third_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_third;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/34",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ھڪڙي ويڪٽر ۾ ترتيب ڏنل منفرد عناصر واپس ڪريو >>> منفرد ({{std::vector<long>({(long) 5، (long) 3، (long) 5، (long) 2، (long) 3، (long) 3، (long) 9، (long) 0، (long) 123}))) (std::vector<long>{(long) 0، (long) 2، (long) 3، (long) 5، (long) 9، (long) 123}))\nstd::vector<long> unique(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = unique;\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));\n}\n"
    },
    {
        "task_id": "HumanEval/35",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ويڪٽر ۾ وڌ کان وڌ عنصر واپس ڪريو. >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long)-5, (long) 2, (long)-3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (123)\nlong max_element(std::vector<long> l) {\n",
        "canonical_solutions": "long max_element(std::vector<long> l) {\n    return *std::max_element(l.begin(), l.end());\n}",
        "test": "}\nint main() {\n    auto candidate = max_element;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));\n}\n"
    },
    {
        "task_id": "HumanEval/36",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// عددي 7 جو تعداد واپس ڪريو جيڪي 11 يا 13 کان ورهائيندڙ n کان گهٽ انٽيگرز ۾ ظاهر ٿين ٿا. >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)\nlong fizz_buzz(long n) {\n",
        "canonical_solutions": "long fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            long temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++;\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = fizz_buzz;\n    assert(candidate((50)) == (0));\n    assert(candidate((78)) == (2));\n    assert(candidate((79)) == (3));\n    assert(candidate((100)) == (3));\n    assert(candidate((200)) == (6));\n    assert(candidate((4000)) == (192));\n    assert(candidate((10000)) == (639));\n    assert(candidate((100000)) == (8026));\n}\n"
    },
    {
        "task_id": "HumanEval/37",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هي فنڪشن هڪ ويڪٽر l وٺندو آهي ۽ هڪ ويڪٽر l' واپس ڪندو آهي جيئن ته l' انڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊينڊين\nstd::vector<long> sort_even(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_even;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));\n}\n"
    },
    {
        "task_id": "HumanEval/39",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib n-th نمبر واپس ڪري ٿو جيڪو هڪ فبوناچي نمبر آهي ۽ اهو پڻ پرائم آهي. >>> prime_fib((1)) (2) >>> prime_fib((2)) (3) >>> prime_fib((3)) (5) >>> prime_fib((4)) (13) >>> prime_fib((5)) (89)\nlong prime_fib(long n) {\n",
        "canonical_solutions": "bool is_prime(long num) {\n    if (num < 2) return false;\n    if (num < 4) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (long i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nlong prime_fib(long n) {\n    std::vector<long> prime_fibs;\n    long a = 1, b = 1;\n    while (prime_fibs.size() < n) {\n        long next = a + b;\n        a = b;\n        b = next;\n        if (is_prime(next)) {\n            prime_fibs.push_back(next);\n        }\n    }\n    return prime_fibs[n - 1];\n}",
        "test": "}\nint main() {\n    auto candidate = prime_fib;\n    assert(candidate((1)) == (2));\n    assert(candidate((2)) == (3));\n    assert(candidate((3)) == (5));\n    assert(candidate((4)) == (13));\n    assert(candidate((5)) == (89));\n    assert(candidate((6)) == (233));\n    assert(candidate((7)) == (1597));\n    assert(candidate((8)) == (28657));\n    assert(candidate((9)) == (514229));\n    assert(candidate((10)) == (433494437));\n}\n"
    },
    {
        "task_id": "HumanEval/40",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ٽرپل_سم_ٽو_زيرو انٽيگرز جي ويڪٽر کي ان پٽ جي طور تي وٺي ٿو. اهو صحيح موٽندو آهي جيڪڏهن ويڪٽر ۾ ٽي الڳ عنصر آهن جيڪي صفر تائين گڏ ٿين ٿا ، ۽ ٻي صورت ۾ غلط. >>> ٽرپل_سم_ٽو_زيرو (((std::vector<long>((long) 1، (long) 3، (long) 5، (long) 0)) (false) >>> ٽرپل_سم_ٽو_زيرو (((vector<long>(long) 1، (long) 3، (long) 2، (long) 1)) >>> (true) ٽرپل_سم_ٽو_زيرو (((std::vector<long>(long) 1، (long) 2، (long) 3، (long) 7)) (false) >>> ٽرپل_سم_ٽو_زيرو ((((((((((long)) (long) 2، (long) 4، (long) 5، (long) 3، (long) 9، (long) 7)) (true) >>> ٽرپل_سم_ٽو_جيٽيو (long) >>> (long_long) >>> ٽرپل_سم_ٽ_ٽو_ٽو_زيرو (long) >>> (long_long) >>> (long_long_long)) (long_long)) (long) >>> ٽرپل_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_ٽ_زرو) >>> (long))\nbool triples_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n - 2; i++) {\n        size_t left = i + 1, right = n - 1;\n        while (left < right) {\n            long sum = l[i] + l[left] + l[right];\n            if (sum == 0) return true;\n            else if (sum < 0) left++;\n            else right--;\n        }\n    }\n    \n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = triples_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));\n    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/41",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// تصور ڪريو ته هڪ روڊ جيڪو هڪ مڪمل سڌي لامحدود ڊگهي لڪير آهي. n ڪارون کاٻي کان سا rightي طرف ڊوڙنديون آهن؛ هڪ ئي وقت ۾ ، n ڪارون جو هڪ مختلف سيٽ سا rightي کان کاٻي طرف ڊوڙنديون آهن. ڪارون جا ٻه سيٽ هڪ ٻئي کان تمام پري ٿيڻ شروع ٿي وڃن ٿا. سڀ ڪارون هڪ ئي رفتار سان هلن ٿيون. ٻن ڪارون کي ٽڪرائڻ لاءِ چيو ويندو آهي جڏهن هڪ ڪار جيڪا کاٻي کان سا rightي طرف وڃي رهي آهي هڪ ڪار کي ٽڪرائيندي آهي جيڪا سا rightي کان کاٻي طرف وڃي رهي آهي. تنهن هوندي ، ڪارون لامحدود مضبوط ۽ مضبوط آهن ؛ نتيجي طور ، اهي پنهنجي رستي تي هلڻ جاري رکندا آهن ifڻ ته اهي ٽڪرائجي نه رهيا هئا. اهو فنڪشن اهڙن ٽڪرن جو تعداد ٻاھر ڪ .\nlong car_race_collision(long n) {\n",
        "canonical_solutions": "long car_race_collision(long n) {\n    return n * n;\n}",
        "test": "}\nint main() {\n    auto candidate = car_race_collision;\n    assert(candidate((2)) == (4));\n    assert(candidate((3)) == (9));\n    assert(candidate((4)) == (16));\n    assert(candidate((8)) == (64));\n    assert(candidate((10)) == (100));\n}\n"
    },
    {
        "task_id": "HumanEval/42",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 1. جي طرف وڌايو عنصرن سان واپسي vector >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 2, (long) 3, (long) 4})) >>> incr_list((std::vector<long>{long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> incr_list(std::vector<long> l) {\n    for (long &num : l) {\n        num++;\n    }\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = incr_list;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));\n    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));\n}\n"
    },
    {
        "task_id": "HumanEval/43",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero انٽيگرز جو ويڪٽر ان پٽ جي طور تي وٺي ٿو. اهو صحيح موٽندو آهي جيڪڏهن ويڪٽر ۾ ٻه الڳ عنصر آهن جيڪي صفر تائين گڏ ٿين ٿا ، ۽ ٻي صورت ۾ غلط. >>> pairs_sum_to_zero(std::vector<long>({long) 1، (long) 3، (long) 5، (long) 0}))) (false) >>> pairs_sum_to_zero(std::vector<long>({long) 1، (long) 3، (long) 2، (long) 1} >>> (false) pairs_sum_to_zero(std::vector<long>({long) 1، (long) 2، (long) 3، (long) 7}))) (se) pairs >>>_sum_to_zero(std::vector<long>{long>2، (long) 4، (long) 5، (long) 3، (long) 5، (long) 7))) (true) >>> pairs_sum_to_zero (long) >>> (long_long) 1، (long) >>> (false) pairs >>> (long_sum_long))\nbool pairs_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> seen;\n    for (long num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = pairs_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/44",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انپٽ نمبر x جي عددي بنياد کي بنياد ۾ تبديل ڪريو. واپسي واري اسٽرنگ نمائندگي تبديل ڪرڻ کان پوءِ. بنيادي نمبر 10 کان گهٽ آهن. >>> change_base((8), (3)) (\"22\") >>> change_base(8), (2)) (\"1000\") >>> change_base(7), (2)) (\"111\")\nstd::string change_base(long x, long base) {\n",
        "canonical_solutions": "std::string change_base(long x, long base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = change_base;\n    assert(candidate((8), (3)) == (\"22\"));\n    assert(candidate((9), (3)) == (\"100\"));\n    assert(candidate((234), (2)) == (\"11101010\"));\n    assert(candidate((16), (2)) == (\"10000\"));\n    assert(candidate((8), (2)) == (\"1000\"));\n    assert(candidate((7), (2)) == (\"111\"));\n    assert(candidate((2), (3)) == (\"2\"));\n    assert(candidate((3), (4)) == (\"3\"));\n    assert(candidate((4), (5)) == (\"4\"));\n    assert(candidate((5), (6)) == (\"5\"));\n    assert(candidate((6), (7)) == (\"6\"));\n    assert(candidate((7), (8)) == (\"7\"));\n}\n"
    },
    {
        "task_id": "HumanEval/45",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ مثلث لاءِ هڪ پاسي جي ڊيگهه ۽ اعليٰ واپسي واري ايراضي ڏني وئي. >>> triangle_area((5), (3)) (7.5f)\nfloat triangle_area(long a, long h) {\n",
        "canonical_solutions": "float triangle_area(long a, long h) {\n    return 0.5f * a * h;\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((5), (3)) == (7.5f));\n    assert(candidate((2), (2)) == (2.0f));\n    assert(candidate((10), (8)) == (40.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/46",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Fib4 نمبر سيڪيونس هڪ سيڪيونس آهي جيڪا فبونچي سيڪيونس سان ملندڙ آهي جنهن جي وضاحت هن ريت آهي: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). مهرباني ڪري هڪ فنڪشن لکو ته fib4 نمبر سيڪيونس جي n-th عنصر کي موثر طريقي سان ڳڻپ ڪري. recursion استعمال نه ڪريو. >>> fib4((5)) (4) >>> fib4((6)) (8) >>> fib4((7)) (14)\nlong fib4(long n) {\n",
        "canonical_solutions": "long fib4(long n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 2;\n\n    for (long i = 4; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fib4;\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (28));\n    assert(candidate((10)) == (104));\n    assert(candidate((12)) == (386));\n}\n"
    },
    {
        "task_id": "HumanEval/47",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ويڪٽر ۾ عنصرن جو وچولي واپسي l. >>> median((std::vector<long>({(long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (float(3) >>> median((std::vector<long>({(long) -10، (long) 4, (long) 6, (long) 1000، (long) 10, (long) 20}))) (15.0f)\nfloat median(std::vector<long> l) {\n",
        "canonical_solutions": "float median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    if (n % 2 == 1) {\n        return static_cast<float>(l[n / 2]);\n    } else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = median;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));\n    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));\n    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));\n    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));\n    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));\n}\n"
    },
    {
        "task_id": "HumanEval/48",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// چيڪ ڪري ٿو ته ڏنل اسٽرنگ هڪ پيلنڊروم آهي >>> is_palindrome (((\"\")) (true) >>> is_palindrome (((\"aba\")) (true) >>> is_palindrome (((\"aaaaa\")) (true) >>> is_palindrome (((\"zbcd\")) (false)\nbool is_palindrome(std::string text) {\n",
        "canonical_solutions": "bool is_palindrome(std::string text) {\n    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());\n}",
        "test": "}\nint main() {\n    auto candidate = is_palindrome;\n    assert(candidate((\"\")) == (true));\n    assert(candidate((\"aba\")) == (true));\n    assert(candidate((\"aaaaa\")) == (true));\n    assert(candidate((\"zbcd\")) == (false));\n    assert(candidate((\"xywyx\")) == (true));\n    assert(candidate((\"xywyz\")) == (false));\n    assert(candidate((\"xywzx\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/49",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// موٽايو 2 ^ n ماڊل p (عدديات کان واقف ٿيو). >>> ماڊلp ((((3) ، (5)) (3) >>> ماڊلp (((1101) ، (101)) (2) >>> ماڊلp (((0) ، (101)) (1) >>> ماڊلp (((3) ، (11)) (8) >>> ماڊلp (((100) ، (101)) (1)\nlong modp(long n, long p) {\n",
        "canonical_solutions": "long modp(long n, long p) {\n    return std::pow(2, n) % p;\n}",
        "test": "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/51",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels هڪ فنڪشن آهي جيڪو تار وٺي ٿو ۽ بغير آوازن جي تار موٽائي ٿو. >>> remove_vowels(\"\")) (\"\") >>> remove_vowels((\"abcdef\")) (\"bcdf\") >>> remove_vowels((\"aaaaa\")) (\"\") >>> remove_vowels(\"aaBAA\")) (\"B\") >>> remove_vowels((\"zbcd\")) (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n",
        "canonical_solutions": "std::string remove_vowels(std::string text) {\n    std::string result;\n    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    for (char ch : text) {\n        if (vowels.find(ch) == vowels.end()) {\n            result += ch;\n        }\n    }\n    \n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_vowels;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"abcdef\\nghijklm\")) == (\"bcdf\\nghjklm\"));\n    assert(candidate((\"fedcba\")) == (\"fdcb\"));\n    assert(candidate((\"eeeee\")) == (\"\"));\n    assert(candidate((\"acBAA\")) == (\"cB\"));\n    assert(candidate((\"EcBOO\")) == (\"cB\"));\n    assert(candidate((\"ybcd\")) == (\"ybcd\"));\n}\n"
    },
    {
        "task_id": "HumanEval/52",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// موٽايو سچو جيڪڏهن ويڪٽر ۾ سڀ نمبر آهن حد کان هيٺ t. >>> below_threshold(((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 10})), (100)) (true) >>> below_threshold((std::vector<long>({(long) 1, (long) 20, (long) 4, (long) 10})), (5)) (false)\nbool below_threshold(std::vector<long> l, long t) {\n",
        "canonical_solutions": "bool below_threshold(std::vector<long> l, long t) {\n    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });\n}",
        "test": "}\nint main() {\n    auto candidate = below_threshold;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/53",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ٻن نمبرن کي شامل ڪريو x ۽ y >>> شامل ڪريو ((((2) ، (3)) (5) >>> شامل ڪريو ((((5) ، (7)) (12)\nlong add(long x, long y) {\n",
        "canonical_solutions": "long add(long x, long y) {\n    return x + y;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((0), (1)) == (1));\n    assert(candidate((1), (0)) == (1));\n    assert(candidate((2), (3)) == (5));\n    assert(candidate((5), (7)) == (12));\n    assert(candidate((7), (5)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/54",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// چيڪ ڪريو ته ٻن لفظن ۾ ساڳيا اکر آهن. >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) (true) >>> same_chars((\"abcd\"), (\"dddddddabc\")) (true) >>> same_chars(\"dddddddabc\"), (\"abcd\") (true) >>> same_chars((\"eabcd\"), (\"dddddddabc\")) (false) >>> same_chars >>>\"((abcd\"), (\"dddddddabce\") (false) >>> same_chars((\"eabcd\"), (\"ddddzzzzzdzzdddabc\") (false)\nbool same_chars(std::string s0, std::string s1) {\n",
        "canonical_solutions": "bool same_chars(std::string s0, std::string s1) {\n    std::unordered_set<char> set0(s0.begin(), s0.end());\n    std::unordered_set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}",
        "test": "}\nint main() {\n    auto candidate = same_chars;\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(candidate((\"abcd\"), (\"dddddddabc\")) == (true));\n    assert(candidate((\"dddddddabc\"), (\"abcd\")) == (true));\n    assert(candidate((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(candidate((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(candidate((\"aabb\"), (\"aaccc\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/55",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// n-th فبوناچي نمبر واپس ڪريو. >>> fib((10)) (55) >>> fib((1)) (1) >>> fib((8)) (21)\nlong fib(long n) {\n",
        "canonical_solutions": "long fib(long n) {\n    if (n <= 1) return n;\n    \n    long a = 0, b = 1, c;\n    for (long i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    \n    return b;\n}",
        "test": "}\nint main() {\n    auto candidate = fib;\n    assert(candidate((10)) == (55));\n    assert(candidate((1)) == (1));\n    assert(candidate((8)) == (21));\n    assert(candidate((11)) == (89));\n    assert(candidate((12)) == (144));\n}\n"
    },
    {
        "task_id": "HumanEval/56",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets \"<\" ۽ \">\" جو هڪ سلسلو آهي. جيڪڏهن هر افتتاحي براڪنگ ۾ هڪ برابر بند ڪرڻ وارو براڪنگ هجي ته صحيح موٽايو. >>> correct_bracketing((\"<\")) (false) >>> correct_bracketing(\"<>\")) (true) >>> correct_bracketing(\"<><>\")) (true) >>> correct_bracketing(\">(<>\") (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') balance++;\n        else if (ch == '>') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"<>\")) == (true));\n    assert(candidate((\"<<><>>\")) == (true));\n    assert(candidate((\"<><><<><>><>\")) == (true));\n    assert(candidate((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(candidate((\"<<<><>>>>\")) == (false));\n    assert(candidate((\"><<>\")) == (false));\n    assert(candidate((\"<\")) == (false));\n    assert(candidate((\"<<<<\")) == (false));\n    assert(candidate((\">\")) == (false));\n    assert(candidate((\"<<>\")) == (false));\n    assert(candidate((\"<><><<><>><>><<>\")) == (false));\n    assert(candidate((\"<><><<><>><>>><>\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/57",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// موٽڻ صحيح آهي ويڪٽر عناصر monotonically وڌندا يا گهٽتائي آهن. >>> monotonic ((((std::vector<long> (((long) 1، (long) 2، (long) 4، (long) 20)) (سچو) >>> monotonic ((((std::vector<long> (long) 1، (long) 20، (long) 4، (long) 10)) (غلط) >>> monotonic ((((std::vector<long> (long) 4، (long) 1، (long) 0، (long) 10)) (سچو)\nbool monotonic(std::vector<long> l) {\n",
        "canonical_solutions": "bool monotonic(std::vector<long> l) {\n    bool increasing = true, decreasing = true;\n    \n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) decreasing = false;\n        if (l[i] < l[i - 1]) increasing = false;\n    }\n    \n    return increasing || decreasing;\n}",
        "test": "}\nint main() {\n    auto candidate = monotonic;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));\n    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/58",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ٻن ويڪٽرز لاءِ ترتيب ڏنل منفرد عام عنصر واپس ڪريو. >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5}) ، (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653}) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}) ، (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long) 2, (long) 3))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n",
        "canonical_solutions": "std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::unordered_set<long> set1(l1.begin(), l1.end());\n    std::unordered_set<long> result_set;\n    \n    for (long num : l2) {\n        if (set1.count(num)) {\n            result_set.insert(num);\n        }\n    }\n    \n    std::vector<long> result(result_set.begin(), result_set.end());\n    std::sort(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = common;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/59",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// n جو سڀ کان وڏو پرائم فيڪٽر موٽايو. فرض ڪريو n > 1 ۽ پرائم نه آهي. >>> largest_prime_factor (((13195)) (29) >>> largest_prime_factor (((2048)) (2)\nlong largest_prime_factor(long n) {\n",
        "canonical_solutions": "long largest_prime_factor(long n) {\n    long largest = -1;\n    \n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n    \n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n    \n    if (n > 1) largest = n;\n    \n    return largest;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n}\n"
    },
    {
        "task_id": "HumanEval/60",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n هڪ فنڪشن آهي جيڪو 1 کان n تائين نمبرن جو مجموعو آهي. >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)\nlong sum_to_n(long n) {\n",
        "canonical_solutions": "long sum_to_n(long n) {\n    return n * (n + 1) / 2;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_to_n;\n    assert(candidate((1)) == (1));\n    assert(candidate((6)) == (21));\n    assert(candidate((11)) == (66));\n    assert(candidate((30)) == (465));\n    assert(candidate((100)) == (5050));\n}\n"
    },
    {
        "task_id": "HumanEval/61",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets \"(\" ۽ \"\") جي هڪ تار آهي. جيڪڏهن هر افتتاحي براڪنگ ۾ هڪ برابر بند ڪرڻ وارو براڪنگ هجي ته صحيح موٽايو. >>> correct_bracketing((\"(\")) (false) >>> correct_bracketing(\"() \")) (true) >>> correct_bracketing(\"(()))))) (true) >>> correct_bracketing((\") ((()))) (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') balance++;\n        else if (ch == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/62",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// xs هڪ پولينوميل جي ضابطن جي نمائندگي ڪن ٿا. xs[0] + xs[1] * x + xs[2] * x^2 + .... هن پولينوميل جو مشتق ساڳي شڪل ۾ موٽايو. >>> مشتق: (((std::vector<long>({long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> مشتق: (((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n",
        "canonical_solutions": "std::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> result;\n    for (size_t i = 1; i < xs.size(); i++) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = derivative;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));\n    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/63",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فبيب نمبر سيڪيونس فببونچي سيڪيونس سان ملندڙ هڪ سيڪيونس آهي جنهن جي وضاحت هن ريت آهي: فبيب ((0) == 0 فبيب ((1) == 0 فبيب ((2) == 1 فبيب ((n) == فبيب ((n-1) + فبيب ((n-2) + فبيب ((n-3). مهرباني ڪري هڪ فنڪشن لکو ته فبيب نمبر سيڪيونس جي ن-هين عنصر کي موثر طريقي سان ڳڻپ ڪري. >>> فبيب (((1)) (0) >>> فبيب (((5)) (4) >>> فبيب (((8)) (24)\nlong fibfib(long n) {\n",
        "canonical_solutions": "long fibfib(long n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 1;\n\n    for (long i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fibfib;\n    assert(candidate((2)) == (1));\n    assert(candidate((1)) == (0));\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (24));\n    assert(candidate((10)) == (81));\n    assert(candidate((12)) == (274));\n    assert(candidate((14)) == (927));\n}\n"
    },
    {
        "task_id": "HumanEval/64",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو vowels_count جيڪو هڪ لفظ جي نمائندگي ڪندڙ تار کي ان پٽ طور وٺي ٿو ۽ تار ۾ موجود آوازن جو تعداد واپس ڪري ٿو. هن صورت ۾ آواز 'a' ، 'e' ، 'i' ، 'o' ، 'u' آهن. هتي ، 'y' پڻ هڪ آواز آهي ، پر صرف جڏهن اهو ڏنل لفظ جي آخر ۾ آهي. مثال: >>> vowels_count (((\"abcde\")) (2) >>> vowels_count (((\"ACEDY\")) (3)\nlong vowels_count(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong vowels_count(std::string s) {\n  long count = 0;\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  for (char c : s) {\n    if (vowels.count(c)) {\n      count++;\n    }\n  }\n  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n    count++;\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = vowels_count;\n    assert(candidate((\"abcde\")) == (2));\n    assert(candidate((\"Alone\")) == (3));\n    assert(candidate((\"key\")) == (2));\n    assert(candidate((\"bye\")) == (1));\n    assert(candidate((\"keY\")) == (2));\n    assert(candidate((\"bYe\")) == (1));\n    assert(candidate((\"ACEDY\")) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/65",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سرڪل انٽيگر x جي انگن اکرن کي منتقل ڪريو ، انگن اکرن کي سا rightي طرف منتقل ڪريو ۽ نتيجو هڪ تار جي طور تي موٽايو. جيڪڏهن شفٽ > انگن اکرن جو تعداد ، انگن اکرن کي واپس موٽايو. >>> circular_shift (((12), (1)) (\"21\") >>> circular_shift (((12), (2)) (\"12\")\nstd::string circular_shift(long x, long shift) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string circular_shift(long x, long shift) {\n  std::string s = std::to_string(x);\n  long n = s.length();\n  if (n == 0) {\n    return \"\";\n  }\n  shift %= n;\n  if (shift < 0) {\n    shift += n;\n  }\n  if (shift == 0) {\n    return s;\n  }\n  if (shift > n) {\n    std::reverse(s.begin(), s.end());\n    return s;\n  }\n  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);\n  return shifted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = circular_shift;\n    assert(candidate((100), (2)) == (\"001\"));\n    assert(candidate((12), (2)) == (\"12\"));\n    assert(candidate((97), (8)) == (\"79\"));\n    assert(candidate((12), (1)) == (\"21\"));\n    assert(candidate((11), (101)) == (\"11\"));\n}\n"
    },
    {
        "task_id": "HumanEval/66",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ٽاسڪ هڪ فنڪشن لکو جيڪو انپٽ جي طور تي هڪ اسٽرنگ وٺي ٿو ۽ صرف مٿين اکرن جو مجموعو موٽائي ٿو. مثال: >>> digitSum (((\"\")) (0) >>> digitSum (((\"abAB\")) (131) >>> digitSum (((\"abcCd\")) (67) >>> digitSum (((\"helloE\")) (69) >>> digitSum (((\"woArBld\")) (131) >>> digitSum (((\"aAXaaaa\")) (153)\nlong digitSum(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += static_cast<long>(c);\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = digitSum;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abAB\")) == (131));\n    assert(candidate((\"abcCd\")) == (67));\n    assert(candidate((\"helloE\")) == (69));\n    assert(candidate((\"woArBld\")) == (131));\n    assert(candidate((\"aAaaaXa\")) == (153));\n    assert(candidate((\" How are yOu?\")) == (151));\n    assert(candidate((\"You arE Very Smart\")) == (327));\n}\n"
    },
    {
        "task_id": "HumanEval/67",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هن ڪم ۾، توهان کي هڪ اسٽرنگ ڏني ويندي جيڪا انب ۽ نارنگي جي تعداد جي نمائندگي ڪري ٿي جيڪا ميون جي هڪ ٽوڪري ۾ ورهائي وئي آهي هن ٽوڪري ۾ انب، نارنگي ۽ منگو ميون شامل آهن. اها اسٽرنگ ڏني وئي جيڪا نارنگي ۽ انب جي مجموعي تعداد جي نمائندگي ڪري ٿي ۽ هڪ انٽيگر جيڪا ٽوڪري ۾ ميون جي مجموعي تعداد جي نمائندگي ڪري ٿي ٽوڪري ۾ منگو ميون جو تعداد واپس ڪريو. مثال طور: >>> fruit_distribution ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nlong fruit_distribution(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong fruit_distribution(std::string s, long n) {\n  long apples = 0;\n  long oranges = 0;\n  size_t apples_pos = s.find(\"apples\");\n  if (apples_pos != std::string::npos) {\n    size_t start = 0;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    apples = std::stoll(s.substr(start, apples_pos - start));\n  }\n  size_t oranges_pos = s.find(\"oranges\");\n  if (oranges_pos != std::string::npos) {\n    size_t and_pos = s.find(\"and\");\n    size_t start = and_pos + 3;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    oranges = std::stoll(s.substr(start, oranges_pos - start));\n  }\n  return n - apples - oranges;\n}",
        "test": "}\nint main() {\n    auto candidate = fruit_distribution;\n    assert(candidate((\"5 apples and 6 oranges\"), (19)) == (8));\n    assert(candidate((\"5 apples and 6 oranges\"), (21)) == (10));\n    assert(candidate((\"0 apples and 1 oranges\"), (3)) == (2));\n    assert(candidate((\"1 apples and 0 oranges\"), (3)) == (2));\n    assert(candidate((\"2 apples and 3 oranges\"), (100)) == (95));\n    assert(candidate((\"2 apples and 3 oranges\"), (5)) == (0));\n    assert(candidate((\"1 apples and 100 oranges\"), (120)) == (19));\n}\n"
    },
    {
        "task_id": "HumanEval/68",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"هڪ ويڪٽر ڏنو ويو آهي جيڪو هڪ وڻ جي شاخ جي نمائندگي ڪري ٿو جنهن ۾ غير منفي انٽيگر نوڊس آهن توهان جو ڪم نوڊس مان هڪ کي ڇڪڻ ۽ ان کي واپس ڪرڻ آهي. ڇڪيل نوڊ نن smallestي کان نن evenي قدر سان نوڊ هجڻ گهرجي. جيڪڏهن هڪ ئي نن smallestي کان نن evenي قدر سان نوڊ واپس اچي ته نن smallestي کان نن indexي انڊيڪس سان نوڊ واپس اچي. ڇڪيل نوڊ کي ويڪٽر ۾ واپس ڪيو وڃي ، [smallest_value ، ان جو انڊيڪس ]، جيڪڏهن ڪوبه به قدر نه آهن يا ڏنل ويڪٽر خالي آهي ، واپس []. مثال 1: >>> ڇڪڻ: // longdvector<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nstd::vector<long> pluck(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> pluck(std::vector<long> arr) {\n  if (arr.empty()) {\n    return {};\n  }\n  long min_even = -1;\n  long min_index = -1;\n  for (long i = 0; i < arr.size(); ++i) {\n    if (arr[i] % 2 == 0) {\n      if (min_even == -1 || arr[i] < min_even) {\n        min_even = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  if (min_even == -1) {\n    return {};\n  }\n  return {min_even, min_index};\n}",
        "test": "}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/69",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي مثبت انٽيگرز جو هڪ غير خالي ويڪٽر ڏنو ويو آهي. اهو سڀ کان وڏو انٽيگر واپس آڻيو جيڪو صفر کان وڏو آهي، ۽ انٽيگر جي قدر کان وڌيڪ يا برابر آهي. انٽيگر جي فريڪئنسي انٽيگر جي قدر کان وڌيڪ يا برابر آهي. جيڪڏهن اهڙي ڪا قدر موجود نه آهي، واپس -1. مثال: >>> ڳولا:<long> (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) (long) (long)) ، (long) (long) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) ()) ()) ()) ()) ()))))))) ()) ()))))))))))) ()))))))) ())))))))))))))))))))))\nlong search(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong search(std::vector<long> lst) {\n  std::map<long, long> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  long result = -1;\n  for (auto const& [value, count] : counts) {\n    if (value > 0 && count >= value) {\n      result = std::max(result, value);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/70",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انٽيگرز جو هڪ ويڪٽر ڏنو ويو آهي ، واپسي وارو ويڪٽر غير معمولي ترتيب ۾. غير معمولي ترتيب ڏيڻ ، اهو آهي جڏهن توهان گهٽ ۾ گهٽ قيمت سان شروع ڪريو ، پوءِ باقي انٽيگرز جو وڌ کان وڌ ، پوءِ گهٽ ۾ گهٽ ۽ پوءِ. مثال: >>> strange_sort_list{}، (long) 1، (long) 2، (long) 3، (long) 4}))) (std:: vector<long>، (long) 1، (long) 4، (long) 2، (long) 3})) >>> strange_sort_list{}، (long) 5، (long) 5}))) (std:: vector<long>، (long) 5، (long) 5} (long) 5}) >>> strange_sort_list<long>، (long) 5، (long) 5، (long) 5} >>> strange_sort_list<long>، (long) 5، (long) 5، (long) 5}\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  if (lst.empty()) {\n    return {};\n  }\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  long left = 0;\n  long right = lst.size() - 1;\n  bool take_min = true;\n  while (left <= right) {\n    if (take_min) {\n      result.push_back(lst[left++]);\n    } else {\n      result.push_back(lst[right--]);\n    }\n    take_min = !take_min;\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = strange_sort_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));\n}\n"
    },
    {
        "task_id": "HumanEval/71",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ مثلث جي ٽن پاسن جي ڊيگهه ڏني وئي. جيڪڏهن ٽن پاسن هڪ صحيح مثلث ٺاهيو ته مثلث جي ايراضي کي 2 ڊيسمل پوائنٽس ڏانهن واپس آڻيو. ٻي صورت ۾ -1 واپس آڻيو ٽي پاسا هڪ صحيح مثلث ٺاهيندا آهن جڏهن ڪنهن به ٻن پاسن جو مجموعو ٽئين پاسي کان وڏو آهي. مثال: >>> triangle_area((3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())\nfloat triangle_area(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nfloat triangle_area(long a, long b, long c) {\n  if (a + b <= c || a + c <= b || b + c <= a) {\n    return -1.0f;\n  }\n  double s = static_cast<double>(a + b + c) / 2.0;\n  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));\n  std::stringstream ss;\n  ss << std::fixed << std::setprecision(2) << area;\n  return std::stof(ss.str());\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((3), (4), (5)) == (6.0f));\n    assert(candidate((1), (2), (10)) == (float(-1)));\n    assert(candidate((4), (8), (5)) == (8.18f));\n    assert(candidate((2), (2), (2)) == (1.73f));\n    assert(candidate((1), (2), (3)) == (float(-1)));\n    assert(candidate((10), (5), (7)) == (16.25f));\n    assert(candidate((2), (6), (3)) == (float(-1)));\n    assert(candidate((1), (1), (1)) == (0.43f));\n    assert(candidate((2), (2), (10)) == (float(-1)));\n}\n"
    },
    {
        "task_id": "HumanEval/72",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو جيڪو صحيح موٽندو آهي جيڪڏهن اعتراض q اڏامي ويندو ، ۽ ٻي صورت ۾ غلط. اعتراض q اڏامي ويندو جيڪڏهن اهو متوازن هجي (اهو هڪ پيلنڊرومڪ ويڪٽر آهي) ۽ ان جي عنصرن جو مجموعو وڌ کان وڌ ممڪن وزن کان گهٽ يا برابر آهي. مثال: >>> will_it_fly((std::vector<long>({long) 1، (long) 2}) ، (5)) (false) # 1+2 وڌ کان وڌ ممڪن وزن کان گهٽ آهي ، پر اهو غير متوازن آهي. >>> will_it_fly(((std::vector<long>((long) 3، (long) 2، (long) 3}) ، (1)) (false) # اهو متوازن آهي ، پر 3+2+3 وڌ کان وڌ ممڪن وزن کان وڌيڪ آهي. >>> will_it_fly((std::vector<long>{(long>3، (long) 2، (long) 3}) ، (9) (true) # 3+2 آهي ، ۽ وڌ کان وڌ ممڪن وزن کان گهٽ آهي ، پر اهو متوازن آهي.\nbool will_it_fly(std::vector<long> q, long w) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool will_it_fly(std::vector<long> q, long w) {\n  std::vector<long> reversed_q = q;\n  std::reverse(reversed_q.begin(), reversed_q.end());\n  if (q != reversed_q) {\n    return false;\n  }\n  long sum = 0;\n  for (long val : q) {\n    sum += val;\n  }\n  return sum <= w;\n}",
        "test": "}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/73",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ vector ارر انٽيگرز کي ڏنو ويو آهي ، عنصرن جو گهٽ ۾ گهٽ تعداد ڳوليو جيڪي ويڪٽر کي پالينڊرومڪ بڻائڻ جي ضرورت آهي. هڪ پالينڊرومڪ ويڪٽر هڪ ويڪٽر آهي جيڪو ساڳيو پوئتي ۽ اڳتي پڙهي ٿو. هڪ تبديلي ۾ ، توهان هڪ عنصر کي ڪنهن ٻئي عنصر ۾ تبديل ڪري سگهو ٿا. مثال طور: >>> smallest_change(std::vector<long>({long) 1، (long) 2، (long) 3، (long) 5، (long) 4، (long) 7، (long) 9، (long) 6}))) (4) >>> smallest_change(std::vector<long>{(long) 1، (long) 2، (long) 3، (long) 2، (long) 1))) >>> smallest_change(std::vector<long>{(long) 1، (long) 2، (long) 3، (long) 2، (long) 1)))\nlong smallest_change(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong smallest_change(std::vector<long> arr) {\n  long n = arr.size();\n  long changes = 0;\n  for (long i = 0; i < n / 2; ++i) {\n    if (arr[i] != arr[n - 1 - i]) {\n      changes++;\n    }\n  }\n  return changes;\n}",
        "test": "}\nint main() {\n    auto candidate = smallest_change;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/74",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو جيڪو ٻن تارن جي ويڪٽر کي قبول ڪري ٿو ۽ ويڪٽر کي واپس ڪري ٿو جنهن ۾ ويڪٽر جي سڀني تارن ۾ مجموعي تعداد جي ٻين کان گهٽ آهي. جيڪڏهن ٻن ويڪٽرز ۾ هڪ ئي تعداد جا اکر آهن ، پهرين ويڪٽر واپس ڪريو. مثال >>> total_match ({}): vector ({): vector ({): vector ({): vector ({): vector ({): vector ({): vector ({): vector ({): vector ({): vector ({): vector ({): vector ({): vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({: vector ({) }: vector ({ vector ({ vector ({ vector ({ vector ({ vector ({ vector)))))))))) \" ({: vector (vector ({ vector ({ vector ({ vector ({ vector ({ vector ({ vector ({ vector) } vector ({ vector ({ vector) } vector ({ vector) } vector ({ vector ({ vector) } vector (vector (vector) \" vector (vector (vector (vector) \" vector (vector (vector (vector) \" vector (vector (vector) \" vector (vector (vector) \"vector (vector (vector) \"vector (vector (vector) \"vector (vector (vector) \"vector (vector (vector) \"vector (vector (vector) \"vector (vector (vector) \"vector (vector) \"vector (vector (vector) \"vector (vector (vector) \"vector (vector) \"ve\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  long count1 = 0;\n  for (const std::string& s : lst1) {\n    count1 += s.length();\n  }\n  long count2 = 0;\n  for (const std::string& s : lst2) {\n    count2 += s.length();\n  }\n  if (count1 <= count2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = total_match;\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"}))) == (std::vector<std::string>({(std::string)\"4\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hii\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)\"this\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\"})), (std::vector<std::string>())) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/75",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو جيڪو صحيح موٽائي ٿو جيڪڏهن ڏنل نمبر 3 پرائم نمبرن جو ضرب آهي ۽ ٻي صورت ۾ غلط آهي. ڄاڻڻ ته (a) 100 کان گهٽ آهي. مثال: >>> is_multiply_prime((30)) (سچ) 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_multiply_prime(long a) {\n  if (a <= 0) {\n    return false;\n  }\n  std::vector<int> primes;\n  std::vector<bool> is_prime(100, true);\n  is_prime[0] = is_prime[1] = false;\n  for (int p = 2; p * p < 100; p++) {\n    if (is_prime[p]) {\n      for (int i = p * p; i < 100; i += p)\n        is_prime[i] = false;\n    }\n  }\n  for (int p = 2; p < 100; p++) {\n    if (is_prime[p]) {\n      primes.push_back(p);\n    }\n  }\n  int count = 0;\n  for (int p1 : primes) {\n    if (a % p1 == 0) {\n      count++;\n      int rem = a / p1;\n      for (int p2 : primes) {\n        if (rem % p2 == 0) {\n          count++;\n          int rem2 = rem / p2;\n          for (int p3 : primes) {\n            if (rem2 == p3) {\n              count++;\n              if (count == 3) {\n                return true;\n              }\n              count--;\n            }\n          }\n          count--;\n        }\n      }\n      count--;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = is_multiply_prime;\n    assert(candidate((5)) == (false));\n    assert(candidate((30)) == (true));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (false));\n    assert(candidate((125)) == (true));\n    assert(candidate((105)) == (true));\n    assert(candidate((126)) == (false));\n    assert(candidate((729)) == (false));\n    assert(candidate((891)) == (false));\n    assert(candidate((1001)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/76",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان جو ڪم هڪ فنڪشن لکڻ آهي جيڪو صحيح موٽندو آهي جيڪڏهن هڪ نمبر x هڪ سادي طاقت آهي n ۽ غلط ٻين ڪيسن ۾. x هڪ سادي طاقت آهي n جيڪڏهن n ** int = x مثال طور: >>> is_simple_power (((1) ، (4)) (سچو) >>> is_simple_power (((2) ، (2)) (سچو) >>> is_simple_power (((8) ، (2)) (سچو) >>> is_simple_power (((3) ، (2)) (غلط) >>> is_simple_power (((3) ، (1)) (غلط) >>> is_simple_power (((5) ، (3)) (غلط)\nbool is_simple_power(long x, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_simple_power(long x, long n) {\n  if (x == n) return true;\n  if (n == 1) return x == 1;\n  if (n == 0) return x == 0;\n  if (x == 0) return false;\n  if (x == 1) return true;\n  long power = n;\n  while (power < x) {\n    if (x % n != 0) return false;\n    if (power > x / n) return false;\n    power *= n;\n  }\n  return power == x;\n}",
        "test": "}\nint main() {\n    auto candidate = is_simple_power;\n    assert(candidate((16), (2)) == (true));\n    assert(candidate((143214), (16)) == (false));\n    assert(candidate((4), (2)) == (true));\n    assert(candidate((9), (3)) == (true));\n    assert(candidate((16), (4)) == (true));\n    assert(candidate((24), (2)) == (false));\n    assert(candidate((128), (4)) == (false));\n    assert(candidate((12), (6)) == (false));\n    assert(candidate((1), (1)) == (true));\n    assert(candidate((1), (12)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/77",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو جيڪو هڪ انٽيگر a وٺي ٿو ۽ صحيح موٽائي ٿو جيڪڏهن اهو انٽيگر ڪنهن انٽيگر نمبر جو ڪعب آهي. نوٽ: توهان فرض ڪري سگهو ٿا ته ان پٽ هميشه صحيح آهي. مثال: >>> iscube((1)) (سچو) >>> iscube((2)) (غلط) >>> iscube(-1)) (سچو) >>> iscube(64)) (سچو) >>> iscube(0)) (سچو) >>> iscube((180)) (غلط)\nbool iscube(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool iscube(long a) {\n  if (a == 0) return true;\n  long abs_a = std::abs(a);\n  long root = round(std::cbrt(abs_a));\n  return root * root * root == abs_a;\n}",
        "test": "}\nint main() {\n    auto candidate = iscube;\n    assert(candidate((1)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((-1)) == (true));\n    assert(candidate((64)) == (true));\n    assert(candidate((180)) == (false));\n    assert(candidate((1000)) == (true));\n    assert(candidate((0)) == (true));\n    assert(candidate((1729)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/78",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي هڪ فنڪشن لکڻ جو ڪم ڏنو ويو آهي جيڪو هڪ هيڪساڊيڪيمل نمبر کي هڪ اسٽرنگ طور تي وصول ڪري ٿو ۽ هيڪساڊيڪيمل انگن جو تعداد ڳڻيندو آهي جيڪي پرائم آهن (پرائم نمبر ، يا پرائم ، هڪ قدرتي نمبر آهي جيڪو 1 کان وڏو آهي جيڪو ٻن نن smallerن نن naturalن نمبرن جو هڪ پيداوار نه آهي). هيڪساڊيڪيمل انگن اکرن جا نمبر آهن 0 ، 1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9 ، اي ، بي ، سي ، ڊي ، اي ، ايف. پرائم نمبر آهن 2 ، 3 ، 5 ، 7 ، 11 ، 13 ، 17 ، . . . . تنهن ڪري توهان کي هيٺين انگن جو تعداد طئي ڪرڻو آهي: 2 ، 3 ، 5 ، 7 ، 7 ، بي (= ڊيڪمل 11) ، ڊي (= ڊيڪمل 13). نوٽ: توهان فرض ڪري سگهو ٿا ته ان پٽ هميشه صحيح يا خالي آهي ، ۽ نشان A ، B ، C ، D ، E ، F هميشه وڏا اکر آهن. مثال: >>> hex_((AB\"ڪي\") >>> hex_((1\") >>> hex_(10\") >>> hex_(77\") >>> hex_((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nlong hex_key(std::string num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong hex_key(std::string num) {\n  long count = 0;\n  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};\n  for (char c : num) {\n    if (prime_hex.count(c)) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/79",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي ڏهائي شڪل ۾ هڪ نمبر ڏنو ويندو ۽ توهان جو ڪم ان کي بائنري فارميٽ ۾ تبديل ڪرڻ هوندو. فنڪشن کي هڪ اسٽرنگ موٽڻ گهرجي، جنهن ۾ هر ڪردار هڪ بائنري نمبر جي نمائندگي ڪندو. اسٽرنگ ۾ هر ڪردار '0' يا '1' هوندو. اسٽرنگ جي شروعات ۽ آخر ۾ اضافي اکرن جو هڪ اضافي جوڙو 'db' هوندو. اضافي اکر فارميٽ سان مدد لاءِ موجود آهن. مثال: >>> decimal_to_binary((15)) (\"db1111db\") >>> decimal_to_binary(32) (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string decimal_to_binary(long decimal) {\n  if (decimal == 0) {\n    return \"db0db\";\n  }\n  std::string binaryString = \"\";\n  long temp = std::abs(decimal);\n  while (temp > 0) {\n    binaryString = (temp % 2 == 0 ? \"0\" : \"1\") + binaryString;\n    temp /= 2;\n  }\n  return \"db\" + binaryString + \"db\";\n}",
        "test": "}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
    },
    {
        "task_id": "HumanEval/80",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي هڪ اسٽرنگ s ڏني وئي آهي. توهان جو ڪم اهو جانچڻ آهي ته ڇا اسٽرنگ خوش آهي يا نه. هڪ اسٽرنگ خوش آهي جيڪڏهن ان جي ڊيگهه گهٽ ۾ گهٽ 3 آهي ۽ هر 3 لڳاتار اکر الڳ آهن مثال طور: >>> is_happy((\"a\")) (false) >>> is_happy((\"aa\")) (false) >>> is_happy((\"abcd\")) (true) >>> is_happy((\"aabb\")) (false) >>> is_happy(\"adb\")) (true) >>> is_happy((\"xyy\") (false)\nbool is_happy(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (size_t i = 0; i <= s.length() - 3; ++i) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_happy;\n    assert(candidate((\"a\")) == (false));\n    assert(candidate((\"aa\")) == (false));\n    assert(candidate((\"abcd\")) == (true));\n    assert(candidate((\"aabb\")) == (false));\n    assert(candidate((\"adb\")) == (true));\n    assert(candidate((\"xyy\")) == (false));\n    assert(candidate((\"iopaxpoi\")) == (true));\n    assert(candidate((\"iopaxioi\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/81",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اهو سيمسٽر جو آخري هفتو آهي ۽ استاد کي شاگردن کي گريڊ ڏيڻا آهن. استاد گريڊنگ لاءِ پنهنجو الگورتھم ٺاهي رهيو آهي. صرف مسئلو اهو آهي ته هن گريڊنگ لاءِ استعمال ڪيل ڪوڊ وڃائي ڇڏيو آهي. هن توهان کي ڪجهه شاگردن لاءِ GPAs جو ويڪٽر ڏنو آهي ۽ توهان کي هڪ فنڪشن لکڻ گهرجي جيڪو هيٺ ڏنل ٽيبل استعمال ڪندي خط جي گريڊ جو ويڪٽر ڏئي سگهي ٿو: GPA. خط گريڊ 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E مثال: >>>_grade equation: (((std::vector<float>(({(float) 4.0f, (float) 3, (float) 1.7f, (float) 2, (float) 3.5f)) (std:vector<std::std::string>((((((string::std::string::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float gpa : grades) {\n    if (gpa == 4.0f) {\n      letter_grades.push_back(\"A+\");\n    } else if (gpa > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (gpa > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (gpa > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (gpa > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (gpa > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (gpa > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (gpa > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (gpa > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (gpa > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (gpa > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (gpa > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "test": "}\nint main() {\n    auto candidate = numerical_letter_grade;\n    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"})));\n    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)\"D+\"})));\n    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)\"D-\"})));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)\"E\"})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)\"D\", (std::string)\"D-\", (std::string)\"C-\", (std::string)\"B\", (std::string)\"B+\"})));\n    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)\"E\", (std::string)\"D-\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/82",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو جيڪو هڪ اسٽرنگ وٺندو آهي ۽ صحيح موٽندو آهي جيڪڏهن اسٽرنگ جي ڊيگهه هڪ پرائم نمبر آهي يا ٻي صورت ۾ غلط آهي مثال >>> prime_length (((\"هيلو\")) (سچ) >>> prime_length (((\"abcdcba\")) (سچ) >>> prime_length (((\"ڪتن\")) (سچ) >>> prime_length (((\"نارنگي\")) (غلط)\nbool prime_length(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(int n) {\n  if (n <= 1) return false;\n  for (int i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nbool prime_length(std::string string) {\n  return is_prime(string.length());\n}",
        "test": "}\nint main() {\n    auto candidate = prime_length;\n    assert(candidate((\"Hello\")) == (true));\n    assert(candidate((\"abcdcba\")) == (true));\n    assert(candidate((\"kittens\")) == (true));\n    assert(candidate((\"orange\")) == (false));\n    assert(candidate((\"wow\")) == (true));\n    assert(candidate((\"world\")) == (true));\n    assert(candidate((\"MadaM\")) == (true));\n    assert(candidate((\"Wow\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"HI\")) == (true));\n    assert(candidate((\"go\")) == (true));\n    assert(candidate((\"gogo\")) == (false));\n    assert(candidate((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(candidate((\"Madam\")) == (true));\n    assert(candidate((\"M\")) == (false));\n    assert(candidate((\"0\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/83",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثبت عدد n ڏنو ويو، 1 سان شروع ٿيندڙ يا ختم ٿيندڙ n-عددي مثبت عدد جي تعداد کي موٽايو.\nlong starts_one_ends(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong starts_one_ends(long n) {\n  if (n <= 0) {\n    return 0;\n  }\n  if (n == 1) {\n    return 1;\n  }\n  long starts_with_one = std::pow(10, n - 1);\n  long ends_with_one = std::pow(10, n - 1);\n  long starts_and_ends_with_one = std::pow(10, n - 2);\n  return starts_with_one + ends_with_one - starts_and_ends_with_one;\n}",
        "test": "}\nint main() {\n    auto candidate = starts_one_ends;\n    assert(candidate((1)) == (1));\n    assert(candidate((2)) == (18));\n    assert(candidate((3)) == (180));\n    assert(candidate((4)) == (1800));\n    assert(candidate((5)) == (18000));\n}\n"
    },
    {
        "task_id": "HumanEval/84",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ مثبت انٽيگر N ڏنو ويو آهي، ان جي انگن جو مجموعو بائنري ۾ موٽايو. مثال >>> حل ڪريو (((1000)) (\"1\") >>> حل ڪريو (((150)) (\"110\") >>> حل ڪريو (((147)) (\"1100\") متغيرات: @ اين انٽيگر پابنديون: 0 ≤ اين ≤ 10000. ٻاھر: بائنري نمبر جي ھڪڙي تار\nstd::string solve(long N) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string solve(long N) {\n  if (N < 0 || N > 10000) {\n    return \"\"; // Or handle invalid input as needed\n  }\n  long sum = 0;\n  std::string s = std::to_string(N);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  if (sum == 0) {\n    return \"0\";\n  }\n  std::string binary_sum = \"\";\n  while (sum > 0) {\n    binary_sum = (sum % 2 == 0 ? \"0\" : \"1\") + binary_sum;\n    sum /= 2;\n  }\n  return binary_sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((1000)) == (\"1\"));\n    assert(candidate((150)) == (\"110\"));\n    assert(candidate((147)) == (\"1100\"));\n    assert(candidate((333)) == (\"1001\"));\n    assert(candidate((963)) == (\"10010\"));\n}\n"
    },
    {
        "task_id": "HumanEval/85",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// lst جي هڪ غير خالي ويڪٽر ڏنو ويو آهي. شامل ڪريو جيڪي به عنصر آهن جيڪي انڊيڪس تي آهن. مثال: >>> add((std:: vector<long>({(long) 4, (long) 2, (long) 6, (long) 7}))) (2)\nlong add(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));\n    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));\n    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/86",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو جيڪو هڪ اسٽرنگ وٺي ٿو ۽ ان جو هڪ ترتيب وارو نسخو موٽائي ٿو. اسٽرنگ جو ترتيب وارو نسخو ، هڪ اسٽرنگ آهي جتي سڀني لفظن (خالي جي ذريعي جدا ٿيل) کي نئين لفظ سان تبديل ڪيو ويندو آهي جتي سڀني اکرن کي ascii قدر جي بنياد تي وڌندڙ ترتيب ۾ ترتيب ڏنل آهي. نوٽ: توهان کي جملي ۾ لفظن ۽ خالي جڳهن جي ترتيب رکڻ گهرجي. مثال طور: >>> anti_shuffle (((\"Hi\")) (\"Hi\") >>> anti_shuffle (((\"hello\")) (\"ehllo\") >>> anti_shuffle ((((Hello World!!!\")) (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string anti_shuffle(std::string s) {\n  std::string result = \"\";\n  std::string current_word = \"\";\n  for (char c : s) {\n    if (c == ' ') {\n      std::sort(current_word.begin(), current_word.end());\n      result += current_word;\n      result += c;\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  std::sort(current_word.begin(), current_word.end());\n  result += current_word;\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = anti_shuffle;\n    assert(candidate((\"Hi\")) == (\"Hi\"));\n    assert(candidate((\"hello\")) == (\"ehllo\"));\n    assert(candidate((\"number\")) == (\"bemnru\"));\n    assert(candidate((\"abcd\")) == (\"abcd\"));\n    assert(candidate((\"Hello World!!!\")) == (\"Hello !!!Wdlor\"));\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hi. My name is Mister Robot. How are you?\")) == (\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"
    },
    {
        "task_id": "HumanEval/87",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي هڪ 2 dimensional ڊيٽا ڏنو ويو آهي ، هڪ نست ٿيل ويڪٽر جي طور تي ، جيڪو ميٽرڪس سان ملندڙ آهي ، تنهن هوندي به ، ميٽرڪس جي برعڪس ، هر قطار ۾ مختلف تعداد ۾ ڪالمن شامل ٿي سگهن ٿا. ڏنو ويو آهي lst ، ۽ انٽيگر x ، ويڪٽر ۾ انٽيگرز x ڳوليو ، ۽ ٽپلس جو واپسي ويڪٽر ، [(x1 ، y1 ، (x2 ، y2) ...] جيئن ته هر ٽپل هڪ همراهه آهي - (row ، columns) ، 0 سان شروع ٿيندڙ. شروعاتي ترتيب سان قطار ۾ ترتيب ڏيو. پڻ ، قطار جي ترتيب سان ترتيب ڏيو. مثال: >>> get_row(std::vector<std::vector<>>>> (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) ، long (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> coordinates;\n  for (long i = 0; i < lst.size(); ++i) {\n    std::vector<std::pair<long, long>> row_coords;\n    for (long j = 0; j < lst[i].size(); ++j) {\n      if (lst[i][j] == x) {\n        row_coords.push_back({j, i});\n      }\n    }\n    std::sort(row_coords.rbegin(), row_coords.rend());\n    for (const auto& coord_pair : row_coords) {\n      coordinates.emplace_back(coord_pair.second, coord_pair.first);\n    }\n  }\n  return coordinates;\n}",
        "test": "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));\n    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));\n}\n"
    },
    {
        "task_id": "HumanEval/88",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// غير منفي انٽيگرز جي هڪ ويڪٽر ڏنو ويو آهي ، ترتيب ڏيڻ کان پوءِ ڏنل ويڪٽر جو ڪوڪپ واپس آڻيو ، توهان ڏنل ويڪٽر کي ترتيب ڏيو جيڪڏهن رقم ((پهرين انڊيڪس ويليو ، آخري انڊيڪس ويليو) اڻ وڻندڙ آهي ، يا ان کي ترتيب ڏيو جيڪڏهن رقم ((پهرين انڊيڪس ويليو ، آخري انڊيڪس ويليو) برابر آهي. نوٽ: * ڏنل ويڪٽر کي تبديل نه ڪريو. مثال: >>> sort_array(std::vector<long>(())) (std::vector<long>)) >>> sort_array((std::vector<long>(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> sort_array(std::vector<long> array) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if (sorted_array.empty()) {\n    return sorted_array;\n  }\n  long first = 0;\n  long last = sorted_array.size() - 1;\n  if ((first + last) % 2 != 0) {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  } else {\n    std::sort(sorted_array.rbegin(), sorted_array.rend());\n  }\n  return sorted_array;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));\n    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));\n    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));\n    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));\n}\n"
    },
    {
        "task_id": "HumanEval/89",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن ٺاهيو انڪرپٽ جيڪو هڪ اسٽرنگ کي دليل طور وٺي ٿو ۽ الفابيٽ کي گھمڻ سان انڪرپٽ ٿيل اسٽرنگ واپس ڪري ٿو. الفابيٽ کي اهڙي طرح گھمڻ گهرجي ته اکرن کي ٻن جي طرف ٻه جڳهن تي ضرب ڪيو وڃي. مثال طور: >>> انڪرپٽ (((\"هي\")) (\"lm\") >>> انڪرپٽ (((\"asdfghjkl\")) (\"ewhjklnop\") >>> انڪرپٽ (((\"gf\")) (\"kj\") >>> انڪرپٽ (((\"et\")) (\"ix\")\nstd::string encrypt(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encrypt(std::string s) {\n  std::string encrypted_s = \"\";\n  int shift = 2 * 2;\n  for (char c : s) {\n    if (isalpha(c)) {\n      char base = islower(c) ? 'a' : 'A';\n      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);\n    } else {\n      encrypted_s += c;\n    }\n  }\n  return encrypted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = encrypt;\n    assert(candidate((\"hi\")) == (\"lm\"));\n    assert(candidate((\"asdfghjkl\")) == (\"ewhjklnop\"));\n    assert(candidate((\"gf\")) == (\"kj\"));\n    assert(candidate((\"et\")) == (\"ix\"));\n    assert(candidate((\"faewfawefaewg\")) == (\"jeiajeaijeiak\"));\n    assert(candidate((\"hellomyfriend\")) == (\"lippsqcjvmirh\"));\n    assert(candidate((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")) == (\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert(candidate((\"a\")) == (\"e\"));\n}\n"
    },
    {
        "task_id": "HumanEval/90",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي انٽيگرز جو هڪ ويڪٽر ڏنو ويو آهي. هڪ فنڪشن next_smallest() لکو جيڪو ويڪٽر جو 2nd smallest عنصر واپس ڪري ٿو. جيڪڏهن اهڙو عنصر نه هجي ته ڪوبه نه موٽايو. >>> next_smallest(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) 2 >>> next_smallest((std::vector<long>({long) 5, (long) 1, (long) 4, (long) 3, (long) 2))) >>> 2 next_smallest(std::vector<long>())) std::nullopt >>> next_smallest(std::vector<long>{(long) 1, (long) 1))) std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n  if (lst[0] == lst[1]) {\n    return std::nullopt;\n  }\n  return lst[1];\n}",
        "test": "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);\n}\n"
    },
    {
        "task_id": "HumanEval/91",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي لفظن جو هڪ سلسلو ڏنو ويندو، ۽ توهان جو ڪم بورڊ جو تعداد ڳڻڻ هوندو. بورڊ هڪ جملو آهي جيڪو لفظ \"I\" سان شروع ٿئي ٿو. جملن کي '.', '?' يا '! ' سان ورهايو ويندو آهي. مثال طور: >>> is_bored((\"هيلو ورلڊ\")) (0) >>> is_bored((\"آسمان نيرو آهي. سج چمڪي رهيو آهي. مون کي هن موسم سان پيار آهي\")) (1)\nlong is_bored(std::string S) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong is_bored(std::string S) {\n  long boredom_count = 0;\n  std::string current_sentence = \"\";\n  for (char c : S) {\n    current_sentence += c;\n    if (c == '.' || c == '?' || c == '!') {\n      std::stringstream ss(current_sentence);\n      std::string first_word;\n      ss >> first_word;\n      if (first_word == \"I\") {\n        boredom_count++;\n      }\n      current_sentence = \"\";\n    }\n  }\n  return boredom_count;\n}",
        "test": "}\nint main() {\n    auto candidate = is_bored;\n    assert(candidate((\"Hello world\")) == (0));\n    assert(candidate((\"Is the sky blue?\")) == (0));\n    assert(candidate((\"I love It !\")) == (1));\n    assert(candidate((\"bIt\")) == (0));\n    assert(candidate((\"I feel good today. I will be productive. will kill It\")) == (2));\n    assert(candidate((\"You and I are going for a walk\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/92",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن ٺاهيو جيڪو 3 نمبرن کي وٺي ٿو. جيڪڏهن هڪ نمبر ٻين ٻن جي مجموعي جي برابر آهي ته صحيح موٽندو آهي، ۽ سڀ نمبر انٽيجر آهن. ٻين ڪيسن ۾ غلط موٽندو آهي. مثال >>> any_int((float(5) ، (float(2) ، (float(7))) (true) >>> any_int(((float3) ، (float(2) ، (float(2))) (false) >>> any_int((float(3) ، (float(-2) ، (float(1) (true) >>> any_int(((3.6f) ، (-2.2f) ، (float(2))) (false)\nbool any_int(float x, float y, float z) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool any_int(float x, float y, float z) {\n  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {\n    return false;\n  }\n  long ix = static_cast<long>(x);\n  long iy = static_cast<long>(y);\n  long iz = static_cast<long>(z);\n  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);\n}",
        "test": "}\nint main() {\n    auto candidate = any_int;\n    assert(candidate((float(2)), (float(3)), (float(1))) == (true));\n    assert(candidate((2.5f), (float(2)), (float(3))) == (false));\n    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));\n    assert(candidate((float(2)), (float(6)), (float(2))) == (false));\n    assert(candidate((float(4)), (float(2)), (float(2))) == (true));\n    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));\n    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));\n    assert(candidate((float(2)), (float(1)), (float(1))) == (true));\n    assert(candidate((float(3)), (float(4)), (float(7))) == (true));\n    assert(candidate((3.0f), (float(4)), (float(7))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/93",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو جيڪو هڪ پيغام وٺندو آهي، ۽ ان کي اهڙي طرح ڪوڊ ڪندو آهي ته اهو سڀني اکرن جي صورت کي تبديل ڪري، انگريزي الفابيٽ ۾ ان اکر کان 2 جڳهن جي اڳيان ظاهر ٿيندڙ خط سان پيغام ۾ سڀني حرفن کي تبديل ڪري ٿو. صرف اکرن کي فرض ڪريو. مثال: >>> encode((\"test\")) (\"TGST\") >>> encode((\"This is a message\")) (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encode(std::string message) {\n  std::string encoded_message = \"\";\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  std::map<char, char> vowel_map = {\n      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};\n  for (char c : message) {\n    if (isalpha(c)) {\n      char swapped_case = islower(c) ? toupper(c) : tolower(c);\n      if (vowels.count(c)) {\n        encoded_message += vowel_map[c];\n      } else {\n        encoded_message += swapped_case;\n      }\n    } else {\n      encoded_message += c;\n    }\n  }\n  return encoded_message;\n}",
        "test": "}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
    },
    {
        "task_id": "HumanEval/94",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي انٽيگرز جو هڪ ويڪٽر ڏنو ويو آهي. توهان کي سڀ کان وڏي پرائم ويليو ڳولڻ جي ضرورت آهي ۽ ان جي عددن جو مجموعو واپس آڻيو. مثال: >>> skjkasdkd((std:: vector<long>(((long) 0، (long) 3، (long) 2، (long) 1، (long) 3، (long) 5، (long) 7، (long) 4، (long) 5، (long) 2، (long) 18، (long) 32، (long) 32، (long) 3، (long) 2، (long) 32، (long) 32، (long) 3، (long) 10، (long) 10، (long) 12، (long) 12، (long) 12، (long) 12، (long) 12، (long) 13، (long) 12، (long) 13، (long) 12، (long) 13، (long) 12، (long) 13، (long) 12، (long) 13، (long) 12، (long) 12، (long) 13، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (\nlong skjkasdkd(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nlong sum_digits(long n) {\n  long sum = 0;\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  return sum;\n}\n\nlong skjkasdkd(std::vector<long> lst) {\n  long largest_prime = -1;\n  for (long num : lst) {\n    if (num > largest_prime && is_prime(num)) {\n      largest_prime = num;\n    }\n  }\n  if (largest_prime == -1) {\n    return 0;\n  }\n  return sum_digits(largest_prime);\n}",
        "test": "}\nint main() {\n    auto candidate = skjkasdkd;\n    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));\n    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));\n    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));\n    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)8191}))) == (19));\n    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));\n    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));\n}\n"
    },
    {
        "task_id": "HumanEval/95",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ نقشو ڏنو، جيڪڏهن سڀئي ڪنجيون ننڍي اکرن ۾ آهن يا سڀئي ڪنجيون وڏين اکرن ۾ آهن ته صحيح موٽايو، ٻي صورت ۾ غلط موٽايو. فنڪشن کي غلط موٽڻ گهرجي ته ڏنل نقشو خالي آهي. مثال: >>> check_dict_case(((std::map<std::string,std::string>(({{\"a\"، \"apple\"}، {\"b\"، \"banana\"}}))) (true) >>> check_dict_case((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nbool check_dict_case(std::map<std::string,std::string> dict) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n  bool first_key_lower = false;\n  bool first_key_upper = false;\n  auto it = dict.begin();\n  if (!it->first.empty() && islower(it->first[0])) {\n    first_key_lower = true;\n  } else if (!it->first.empty() && isupper(it->first[0])) {\n    first_key_upper = true;\n  } else {\n    return false;\n  }\n  for (const auto& pair : dict) {\n    if (pair.first.empty()) {\n      return false;\n    }\n    bool current_lower = true;\n    bool current_upper = true;\n    for (char c : pair.first) {\n      if (!islower(c)) {\n        current_lower = false;\n      }\n      if (!isupper(c)) {\n        current_upper = false;\n      }\n    }\n    if (first_key_lower && !current_lower) {\n      return false;\n    }\n    if (first_key_upper && !current_upper) {\n      return false;\n    }\n    if (!first_key_lower && !first_key_upper) {\n        if (current_lower) first_key_lower = true;\n        else if (current_upper) first_key_upper = true;\n        else return false;\n    }\n  }\n  return first_key_lower || first_key_upper;\n}",
        "test": "}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>())) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/96",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لاڳو ڪريو جيڪو هڪ غير منفي انٽيگر وٺندو آهي ۽ پهرين اين اين جي هڪ ويڪٽر کي واپس ڪري ٿو جيڪي پرائم نمبر آهن ۽ ن کان گهٽ آهن. مثال طور: >>> count_up_to(((5)) (std:: vector<long>{(long) 2، (long) 3}) >>> count_up_to(11)) (std:: vector<long>{(long) 2، (long) 3، (long) 5، (long) 7)) >>> count_up_to(0)) (std:: vector<long>)) >>> count_up_to(20)) (std:: vector<long>{(long) 2، (long) 3، (long) 5، (long) 7، (long) 11، (long) 13، (long) 17، (long) 1، (long) 5، (long) 17\nstd::vector<long> count_up_to(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long num) {\n  if (num <= 1) return false;\n  for (long i = 2; i * i <= num; ++i) {\n    if (num % i == 0) return false;\n  }\n  return true;\n}\n\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n <= 2) {\n    return primes;\n  }\n  for (long i = 2; i < n; ++i) {\n    if (is_prime(i)) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "test": "}\nint main() {\n    auto candidate = count_up_to;\n    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));\n    assert(candidate((0)) == (std::vector<long>()));\n    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));\n    assert(candidate((1)) == (std::vector<long>()));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));\n    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));\n}\n"
    },
    {
        "task_id": "HumanEval/97",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فنڪشن مڪمل ڪريو جيڪو ٻه انٽيگر وٺي ٿو ۽ انهن جي يونٽ ڊجيٽ جي پيداوار کي موٽائي ٿو. فرض ڪريو ته ان پٽ هميشه صحيح آهي. مثال: >>> ضرب (((148) ، (412)) (16) >>> ضرب (((19) ، (28)) (72) >>> ضرب (((2020) ، (1851)) (0) >>> ضرب (((14)) ، (-15)) (20)\nlong multiply(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong multiply(long a, long b) {\n  long unit_a = std::abs(a) % 10;\n  long unit_b = std::abs(b) % 10;\n  return unit_a * unit_b;\n}",
        "test": "}\nint main() {\n    auto candidate = multiply;\n    assert(candidate((148), (412)) == (16));\n    assert(candidate((19), (28)) == (72));\n    assert(candidate((2020), (1851)) == (0));\n    assert(candidate((14), (-15)) == (20));\n    assert(candidate((76), (67)) == (42));\n    assert(candidate((17), (27)) == (49));\n    assert(candidate((0), (1)) == (0));\n    assert(candidate((0), (0)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/98",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ اسٽرنگ s ڏنو ويو آهي ، برابر انڊيڪس ۾ وڏن اکرن جي تعداد کي ڳڻيو. مثال طور: >>> count_upper (((\"aBCdEf\")) (1) >>> count_upper (((\"abcdefg\")) (0) >>> count_upper (((\"dBBE\")) (0)\nlong count_upper(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong count_upper(std::string s) {\n  long count = 0;\n  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};\n  for (long i = 0; i < s.length(); ++i) {\n    if (i % 2 == 0 && upper_vowels.count(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_upper;\n    assert(candidate((\"aBCdEf\")) == (1));\n    assert(candidate((\"abcdefg\")) == (0));\n    assert(candidate((\"dBBE\")) == (0));\n    assert(candidate((\"B\")) == (0));\n    assert(candidate((\"U\")) == (1));\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"EEEE\")) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/99",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن ٺاهيو جيڪو هڪ نمبر جي نمائندگي ڪندڙ قدر (سٽرنگ) وٺي ٿو ۽ ان جي ويجهي انٽيگر کي واپس ڪري ٿو. جيڪڏهن نمبر ٻن انٽيگرز کان برابر آهي ، ان کي صفر کان پري ڪريو. مثال >>> closest_integer (((\"10\")) (10) >>> closest_integer (((\"15.3\")) (15) نوٽ: صفر کان پري ڪرڻ جو مطلب اهو آهي ته جيڪڏهن ڏنل نمبر ٻن انٽيگرز کان برابر آهي ، توهان کي واپس ڪرڻ گهرجي ته اهو آهي جيڪو صفر کان پري آهي. مثال طور closest_integer (((\"14.5\") کي 15 واپس ڪرڻ گهرجي ۽ closest_integer ((-14.5\") کي -15. واپس ڪرڻ گهرجي.\nlong closest_integer(std::string value) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  if (num >= 0) {\n    if (num - std::floor(num) <= 0.5) {\n      return static_cast<long>(std::floor(num));\n    } else {\n      return static_cast<long>(std::ceil(num));\n    }\n  } else {\n    if (std::ceil(num) - num <= 0.5) {\n      return static_cast<long>(std::ceil(num));\n    } else {\n      return static_cast<long>(std::floor(num));\n    }\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/100",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثبت انٽيگر n ڏنو ويو ، توهان کي پٿر جي ن سطحن جو هڪ پٿر ٺاهڻو آهي. پهرين سطح تي ن پٿر آهن. ايندڙ سطح ۾ پٿر جو تعداد آهي: - ايندڙ بي جوڙ نمبر جيڪڏهن ن جوڙ آهي. - ايندڙ برابر نمبر جيڪڏهن ن جوڙو آهي. هڪ ويڪٽر ۾ هر سطح ۾ پٿر جو تعداد واپس ڪريو ، جتي عنصر انڊيڪس i سطح ۾ پٿر جي تعداد جي نمائندگي ڪري ٿو (i + 1). مثال: >>> make_a_pile(3)) (std:: vector<long>{long) 3، (long) 5، (long) 7}))\nstd::vector<long> make_a_pile(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long current_stones = n;\n  for (int i = 0; i < n; ++i) {\n    pile.push_back(current_stones);\n    if (current_stones % 2 != 0) {\n      current_stones += 2;\n    } else {\n      current_stones += 2;\n    }\n  }\n  return pile;\n}",
        "test": "}\nint main() {\n    auto candidate = make_a_pile;\n    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));\n    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));\n    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));\n    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));\n    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));\n}\n"
    },
    {
        "task_id": "HumanEval/101",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي ڪاما يا اسپيس سان جدا ٿيل لفظن جو هڪ سلسلو ڏنو ويندو. توهان جو ڪم اهو آهي ته اسٽرنگ کي لفظن ۾ ورهايو ۽ لفظن جو هڪ ويڪٽر واپس ڪريو. مثال طور: >>> words_string (((\"هيلو، منهنجو نالو جان آهي\")) (std::vector<std::string>({(std::string) \"هيلو\"، (std::string) \"منهنجو\"، (std::string) \"نالو\"، (std::string) \"آهي\"، (std::string) \"جان\"})) >>> words_string (((\"هڪ، ٻه، ٽي، چار، پنج، ڇهه\")) (std::vector<std::string>{(stdstring) \"هڪ\"، (std::string) \"ٻه\"، (std::string) \"ٽي\"، (std::string) \"چوٿون\"، (std::string) \"پنج، (std::string) \"سٺ\")\nstd::vector<std::string> words_string(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ',' || c == ' ') {\n      if (!current_word.empty()) {\n        words.push_back(current_word);\n        current_word = \"\";\n      }\n    } else {\n      current_word += c;\n    }\n  }\n  if (!current_word.empty()) {\n    words.push_back(current_word);\n  }\n  return words;\n}",
        "test": "}\nint main() {\n    auto candidate = words_string;\n    assert(candidate((\"Hi, my name is John\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"})));\n    assert(candidate((\"One, two, three, four, five, six\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"Hi, my name\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\"})));\n    assert(candidate((\"One,, two, three, four, five, six,\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"ahmed     , gamal\")) == (std::vector<std::string>({(std::string)\"ahmed\", (std::string)\"gamal\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/102",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هي فنڪشن ٻه مثبت نمبر x ۽ y وٺندو آهي ۽ سڀ کان وڏو برابر عدد عدد واپس ڪندو آهي جيڪو [x، y] جي حد ۾ شامل آهي. جيڪڏهن اهڙو نمبر نه هجي ته فنڪشن -1 واپس ڪرڻ گهرجي. مثال طور: >>> چونڊيو_ نمبر (((12), (15)) (14) >>> چونڊيو_ نمبر (((13), (12)) (-1)\nlong choose_num(long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong choose_num(long x, long y) {\n  if (x > y) {\n    return -1;\n  }\n  long end = y;\n  if (end % 2 != 0) {\n    end--;\n  }\n  if (end < x) {\n    return -1;\n  }\n  return end;\n}",
        "test": "}\nint main() {\n    auto candidate = choose_num;\n    assert(candidate((12), (15)) == (14));\n    assert(candidate((13), (12)) == (-1));\n    assert(candidate((33), (12354)) == (12354));\n    assert(candidate((5234), (5233)) == (-1));\n    assert(candidate((6), (29)) == (28));\n    assert(candidate((27), (10)) == (-1));\n    assert(candidate((7), (7)) == (-1));\n    assert(candidate((546), (546)) == (546));\n}\n"
    },
    {
        "task_id": "HumanEval/103",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// توهان کي ٻه مثبت انٽيگرز n ۽ m ڏنا ويا آهن، ۽ توهان جو ڪم n کان وٺي m تائين انٽيگرز جي سراسري حساب ڪرڻ آهي (n ۽ m سميت) جواب کي ويجهي انٽيگر تائين گول ڪريو ۽ ان کي بائنري ۾ تبديل ڪريو. جيڪڏهن n کان وڏو آهي، واپسي -1. مثال: >>> rounded_avg((1), (5)) \"0b11\" >>> rounded_avg(7), (5)) -1 >>> rounded_avg(10), (20)) \"0b1111\" >>> rounded_avg(20), (33) \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;\n    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_string_long rounded_avg(long n, long m) {\n  if (n > m) {\n    return Union_std_string_long(-1);\n  }\n  double sum = 0;\n  for (long i = n; i <= m; ++i) {\n    sum += i;\n  }\n  double avg = sum / (m - n + 1);\n  long rounded_avg_long = std::round(avg);\n  if (rounded_avg_long == 0) {\n    return Union_std_string_long(\"0b0\");\n  }\n  std::string binary_string = \"\";\n  long temp = std::abs(rounded_avg_long);\n  while (temp > 0) {\n    binary_string = (temp % 2 == 0 ? \"0\" : \"1\") + binary_string;\n    temp /= 2;\n  }\n  return Union_std_string_long(\"0b\" + binary_string);\n}",
        "test": "}\nint main() {\n    auto candidate = rounded_avg;\n    assert(candidate((1), (5)) == \"0b11\");\n    assert(candidate((7), (13)) == \"0b1010\");\n    assert(candidate((964), (977)) == \"0b1111001010\");\n    assert(candidate((996), (997)) == \"0b1111100100\");\n    assert(candidate((560), (851)) == \"0b1011000010\");\n    assert(candidate((185), (546)) == \"0b101101110\");\n    assert(candidate((362), (496)) == \"0b110101101\");\n    assert(candidate((350), (902)) == \"0b1001110010\");\n    assert(candidate((197), (233)) == \"0b11010111\");\n    assert(candidate((7), (5)) == -1);\n    assert(candidate((5), (1)) == -1);\n    assert(candidate((5), (5)) == \"0b101\");\n}\n"
    },
    {
        "task_id": "HumanEval/104",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثبت انٽيگرز x جي هڪ ويڪٽر ڏنو ويو آهي. سڀني عنصرن جو هڪ ترتيب وارو ويڪٽر موٽايو جنهن ۾ ڪوبه به عدد نه هجي. نوٽ: موٽايل ويڪٽر کي وڌندڙ ترتيب ۾ ترتيب ڏيڻ گهرجي. مثال طور: >>> منفرد_ڊگٽس (((std:: vector<long> (((long) 15 ، (long) 33 ، (long) 142 ، (long) 1}))) (std:: vector<long> (((long) 1 ، (long) 15 ، (long) 33)) >>> منفرد_ڊگٽس (((std:: vector<long> (((long) 152 ، (long) 323 ، (long) 142 ، (long) 10)) (std:: vector<long> (((long))\nstd::vector<long> unique_digits(std::vector<long> x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool has_even_digit(long n) {\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    if ((c - '0') % 2 == 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (long val : x) {\n    if (!has_even_digit(val)) {\n      result.push_back(val);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = unique_digits;\n    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));\n    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));\n    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));\n}\n"
    },
    {
        "task_id": "HumanEval/105",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// عدد جي هڪ ويڪٽر ڏنو، انٽيگرز کي ترتيب ڏيو جيڪي 1 ۽ 9 جي وچ ۾ شامل آهن، نتيجي ۾ ويڪٽر کي ڦيرايو، ۽ پوء هر انگ کي ان جي نالي سان \"هڪ\"، \"ٻه\"، \"ٽي\"، \"چار\"، \"پنج\"، \"ڇهه\"، \"سٿ\"، \"اٺ\"، \"نو\" سان تبديل ڪريو. مثال طور: >>> by_length(std::string<(long>{long) 2، (long) 1، (long) 1، (long) 4، (long) 5، (long) 8، (long) 2، (long) 3}))) (std::vector<(string>{(string>) \"اٺ\"، (std::string) \"پنج\"، (std::string) \"چار\"، (std::string) \"ٽي\"، (std::string) \"ٻه\"، (std::string>) \"ٽي\"، (std::string>) \"چار\"، (std::string>) \"چار\"، (std::string>) \"ٻه\"، (std::string>) \"ٻه\") جيڪڏهن ڪو به خالي نمبر آهي، وري (وڪٽرٽر کي نظرانداز ڪريو) (ڊگهٽ:string_long_string_long_string) (ڊگهٽ) (ڊگهٽ) (ڊگهٽ) (ڊگهٽ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ)) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ) (ڊ\nstd::vector<std::string> by_length(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> valid_numbers;\n  std::vector<std::string> result;\n  std::map<long, std::string> number_names = {\n      {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n      {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n  for (long num : arr) {\n    if (num >= 1 && num <= 9) {\n      valid_numbers.push_back(num);\n    }\n  }\n  std::sort(valid_numbers.begin(), valid_numbers.end());\n  std::reverse(valid_numbers.begin(), valid_numbers.end());\n  for (long num : valid_numbers) {\n    result.push_back(number_names[num]);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = by_length;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)\"Three\", (std::string)\"Two\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)\"Nine\", (std::string)\"Eight\", (std::string)\"Four\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/106",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فنڪشن کي لاڳو ڪريو جيڪو n کي پيرا ميٽر طور وٺي ٿو ، ۽ سائيز n جو ويڪٽر موٽائي ٿو ، جيئن ته انڊيڪس i تي عنصر جي قيمت i جي فئڪٽريئر آهي جيڪڏهن i به هجي يا 1 کان i تائين نمبرن جو مجموعو ٻي صورت ۾. i 1 کان شروع ٿئي ٿو. i جو فئڪٽريئر 1 کان i تائين نمبرن جو ضرب آهي (1 * 2 * . . . * i). مثال: >>> f (((5)) (std:: vector<long> (((long) 1 ، (long) 2 ، (long) 6 ، (long) 24 ، (long) 15))\nstd::vector<long> f(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> f(long n) {\n  std::vector<long> result;\n  for (long i = 1; i <= n; ++i) {\n    if (i % 2 == 0) {\n      long factorial = 1;\n      for (long j = 1; j <= i; ++j) {\n        factorial *= j;\n      }\n      result.push_back(factorial);\n    } else {\n      long sum = 0;\n      for (long j = 1; j <= i; ++j) {\n        sum += j;\n      }\n      result.push_back(sum);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = f;\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/107",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثبت انٽيگر n ڏنو ويو آهي ، هڪ ٽپل موٽايو جنهن ۾ شامل آهي انٽيگر palindromes جو تعداد جيڪو حد ۾ اچي ٿو ((1، n) ، شامل آهي. مثال 1: >>> even_odd_palindrome ((3)) (std::make_tuple ((1، 2)) وضاحت: انٽيگر palindrome آهن 1، 2، 3. انهن مان هڪڙو آهي ، ۽ انهن مان ٻه آهن. مثال 2: >>> even_odd_palindrome ((12)) (std::make_tuple ((4، 6)) وضاحت: انٽيگر palindrome آهن 1، 2، 3، 4، 5، 6، 7، 8، 9، 11. انهن مان چار آهن ، ۽ انهن مان 6 آهن. نوٽ: 1. < 1 = n = 10 ^ 3 2. واپس ڪيل ٽپل ۾ ترتيب سان انٽيگر ۽ انٽيگر palindromes جو تعداد آهي.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_palindrome(long num) {\n  std::string s = std::to_string(num);\n  std::string reversed_s = s;\n  std::reverse(reversed_s.begin(), reversed_s.end());\n  return s == reversed_s;\n}\n\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0;\n  long odd_count = 0;\n  for (long i = 1; i <= n; ++i) {\n    if (is_palindrome(i)) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n  return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_palindrome;\n    assert(candidate((123)) == (std::make_tuple(8, 13)));\n    assert(candidate((12)) == (std::make_tuple(4, 6)));\n    assert(candidate((3)) == (std::make_tuple(1, 2)));\n    assert(candidate((63)) == (std::make_tuple(6, 8)));\n    assert(candidate((25)) == (std::make_tuple(5, 6)));\n    assert(candidate((19)) == (std::make_tuple(4, 6)));\n    assert(candidate((9)) == (std::make_tuple(4, 5)));\n    assert(candidate((1)) == (std::make_tuple(0, 1)));\n}\n"
    },
    {
        "task_id": "HumanEval/108",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو count_nums جيڪو انٽيگرز جو هڪ ويڪٽر وٺندو آهي ۽ عنصرن جو تعداد موٽائيندو آهي جنهن جي انگن جو مجموعو آهي > 0. جيڪڏهن هڪ نمبر منفي آهي ، ته پوءِ ان جو پهريون دستخط ٿيل انگ منفي هوندو: مثال طور -123 انگن تي دستخط ٿيل آهي -1 ، 2 ، ۽ 3. >>> count_nums ((((std:: vector<long>())) (0) >>> count_nums (((std:: vector<long>{(long) - 1 ، (long) 11 ، (long) - 11)) (1) >>> count_nums (((std:: vector<long>{(long) 1 ، (long) 1 ، (long) 2} (3))))\nlong count_nums(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_digits_signed(long n) {\n  std::string s = std::to_string(n);\n  long sum = 0;\n  for (long i = 0; i < s.length(); ++i) {\n    if (i == 0 && s[i] == '-') {\n      if (s.length() > 1) {\n        sum -= (s[i + 1] - '0');\n        i++;\n      }\n    } else {\n      sum += (s[i] - '0');\n    }\n  }\n  return sum;\n}\n\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    if (sum_digits_signed(num) > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_nums;\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));\n    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));\n    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/109",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اسان وٽ هڪ ويڪٽر 'آر آر' آهي N انٽيگرز arr[1], arr[2]، ..., arr[N]. ويڪٽر ۾ نمبر بي ترتيب سان ترتيب ڏنا ويندا. توهان جو ڪم اهو طئي ڪرڻ آهي ته ڇا هڪ ويڪٽر کي غير گهٽجڻ واري ترتيب ۾ ترتيب ڏيڻ ممڪن آهي. ڏنل ويڪٽر تي هيٺيان آپريشن ڪندي: توهان کي ڏنل ويڪٽر تي هيٺيان آپريشن ڪرڻ جي اجازت آهي. هڪ صحيح شفٽ آپريشن جو مطلب آهي ته ويڪٽر جي سڀني عنصرن کي هڪ پوزيشن کان صحيح طرف منتقل ڪرڻ. ويڪٽر جو آخري عنصر ويڪٽر ۾ شروعاتي پوزيشن تي منتقل ڪيو ويندو يعني 0th انڊيڪس. جيڪڏهن اهو ممڪن آهي ته ترتيب ڏنل ويڪٽر حاصل ڪرڻ لاءِ مٿي ڏنل آپريشن کي انجام ڏيو ته پوءِ صحيح واپس موٽايو غلط. جيڪڏهن ڏنل ويڪٽر خالي آهي ته پوءِ صحيح موٽايو. نوٽ: ڏنل ويڪٽر کي منفرد عنصرن جي ضمانت آهي. مثال طور: >>>plan_one_ball_((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nbool move_one_ball(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool move_one_ball(std::vector<long> arr) {\n  if (arr.empty()) {\n    return true;\n  }\n  int n = arr.size();\n  std::vector<long> sorted_arr = arr;\n  std::sort(sorted_arr.begin(), sorted_arr.end());\n  for (int shift = 0; shift < n; ++shift) {\n    std::vector<long> shifted_arr(n);\n    for (int i = 0; i < n; ++i) {\n      shifted_arr[i] = arr[(i - shift + n) % n];\n    }\n    if (shifted_arr == sorted_arr) {\n      return true;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/110",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هن مسئلي ۾ ، توهان هڪ فنڪشن لاڳو ڪندا جيڪو ٻن نمبرن جي ويڪٽر وٺندو آهي ، ۽ اهو طئي ڪندو آهي ته ڇا انهن جي وچ ۾ عنصرن جي تبادلي ڪرڻ ممڪن آهي ته جيئن lst1 صرف برابر نمبرن جو ويڪٽر بڻجڻ لاءِ. lst1 ۽ lst2 جي وچ ۾ مٽايل عنصرن جي تعداد تي ڪا حد ناهي. جيڪڏهن lst1 ۽ lst2 جي وچ ۾ عنصرن کي مٽائڻ ممڪن آهي ته جيئن lst1 جا سڀئي عنصر برابر ٿين ، \"ها\" موٽايو. ٻي صورت ۾ ، \"نه\" موٽايو. مثال طور: >>> exchange((std::vector<>(long) 1, (long) 2, (long) 3, (long) 4}) ، (std::vector<>(long) 1, (long) 2, (long) 3, (long) 4}) ، (std::vector<>(long) 4})) (\"ها\") >>> exchange::{dvector<>{(long>{1, (long) 2, (long) 3, (long) 4} ، (std::vector<>(long>NO<>) 5، (long) (long 4)) اهو فرض ڪيو ويندو ته ان پٽ خالي نه آهي.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  long odd_count_lst1 = 0;\n  for (long num : lst1) {\n    if (num % 2 != 0) {\n      odd_count_lst1++;\n    }\n  }\n  long even_count_lst2 = 0;\n  for (long num : lst2) {\n    if (num % 2 == 0) {\n      even_count_lst2++;\n    }\n  }\n  if (even_count_lst2 >= odd_count_lst1) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = exchange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (\"YES\"));\n}\n"
    },
    {
        "task_id": "HumanEval/111",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ اسٽرنگ ڏني وئي آهي جيڪا هڪ اسپيس کان جدا ٿيل نن lettersن اکرن جي نمائندگي ڪري ٿي ، سڀ کان وڌيڪ ورجائي سان خط جو نقشو واپس آڻيندي ۽ انهي سان لاڳاپيل ڳڻپ شامل آهي. جيڪڏهن ڪيترن ئي اکرن جو هڪ ئي واقعو آهي ، انهن سڀني کي واپس آڻيو. مثال: >>> هسٽوگرام (((\"a b c\")) (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}})) >>> هسٽوگرام ((((\"a b a\")) (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})) >>> هسٽوگرام (((\"a b c a b\")) (std::map<std::string,long>{{\"a\", 2}, {\"b\", 2}})) >>> هسٽوگرام (http://www.histogram.org/maps/maps/stdltr.html) (http://www.histogram.org/map/std:std::string,long>) (http://www.histogram.std::string,long>) >>> (http://www.histogram.std::std::string,long>) >>>\nstd::map<std::string,long> histogram(std::string test) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string, long> counts;\n  std::string current_word;\n  std::stringstream ss(test);\n  while (ss >> current_word) {\n    counts[current_word]++;\n  }\n  if (counts.empty()) {\n    return {};\n  }\n  long max_count = 0;\n  for (const auto& pair : counts) {\n    if (pair.second > max_count) {\n      max_count = pair.second;\n    }\n  }\n  std::map<std::string, long> result;\n  for (const auto& pair : counts) {\n    if (pair.second == max_count) {\n      result[pair.first] = pair.second;\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = histogram;\n    assert(candidate((\"a b b a\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c a b\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c d g\")) == (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}, {\"d\", 1}, {\"g\", 1}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"b b b b a\")) == (std::map<std::string,long>({{\"b\", 4}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"\")) == (std::map<std::string,long>()));\n    assert(candidate((\"a\")) == (std::map<std::string,long>({{\"a\", 1}})));\n}\n"
    },
    {
        "task_id": "HumanEval/112",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ٽاسڪ اسان کي ٻه اسٽرنگس s ۽ c ڏني وئي آهي ، توهان کي s ۾ سڀني اکرن کي ختم ڪرڻو پوندو جيڪي c ۾ ڪنهن به اکر جي برابر آهن پوءِ چيڪ ڪريو ته نتيجو اسٽرنگ پيلنڊروم آهي. هڪ اسٽرنگ کي پيلنڊروم سڏيو ويندو آهي جيڪڏهن اهو ساڳيو پوئتي ۽ اڳتي پڙهي ٿو. توهان کي چيڪ لاءِ نتيجو اسٽرنگ ۽ صحيح / غلط تي مشتمل هڪ ٽپل واپس ڪرڻ گهرجي. مثال >>> reverse_delete((\"abcde\"), (\"ae\")) (std::make_tuple(\"bcd\", false)) >>> reverse_delete((\"abcdef\"), (\"b\") (std::make_tuple(\"acdef\",)) >>> reverse_delete((abcded\", false)) >>> reverse_delete(abcded\", false (\"abcba\") (std::make_tuple\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  std::unordered_set<char> chars_to_delete(c.begin(), c.end());\n  for (char ch : s) {\n    if (chars_to_delete.find(ch) == chars_to_delete.end()) {\n      result += ch;\n    }\n  }\n  std::string reversed_result = result;\n  std::reverse(reversed_result.begin(), reversed_result.end());\n  return std::make_tuple(result, result == reversed_result);\n}",
        "test": "}\nint main() {\n    auto candidate = reverse_delete;\n    assert(candidate((\"abcde\"), (\"ae\")) == (std::make_tuple(\"bcd\", false)));\n    assert(candidate((\"abcdef\"), (\"b\")) == (std::make_tuple(\"acdef\", false)));\n    assert(candidate((\"abcdedcba\"), (\"ab\")) == (std::make_tuple(\"cdedc\", true)));\n    assert(candidate((\"dwik\"), (\"w\")) == (std::make_tuple(\"dik\", false)));\n    assert(candidate((\"a\"), (\"a\")) == (std::make_tuple(\"\", true)));\n    assert(candidate((\"abcdedcba\"), (\"\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"abcdedcba\"), (\"v\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"vabba\"), (\"v\")) == (std::make_tuple(\"abba\", true)));\n    assert(candidate((\"mamma\"), (\"mia\")) == (std::make_tuple(\"\", true)));\n}\n"
    },
    {
        "task_id": "HumanEval/113",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// string جي هڪ vector ڏنو ويو آهي، جتي هر string صرف انگن اکرن تي مشتمل آهي، هڪ vector موٽايو. هر عنصر آئوٽ جي \"آئي جي string ۾ اڻ ڌار عنصرن جو تعداد هجڻ گهرجي. \" جتي سڀني i جي بدران ان پٽ جي ith string ۾ اڻ ڌار انگن جي تعداد سان متبادل هجڻ گهرجي. >>> odd_count((std::vector<std::string>(({std::string) \"1234567\"}))) (std::vector<std::string>({stdstring)::\" 4n جي str4ng 4 جي اڻ ڌار عنصرن جو تعداد 4n جي str4ng 4 جي 4n. \"})) >>> odd_count((stdvector<stdstring>::{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (const std::string& s : lst) {\n    int count = 0;\n    for (char c : s) {\n      if ((c - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string count_str = std::to_string(count);\n    std::string modified_s = s;\n    for (char& c : modified_s) {\n      if (isdigit(c) && (c - '0') % 2 != 0) {\n        c = count_str[0];\n      }\n    }\n    result.push_back(\"the number of odd elements \" + count_str + \"n the str\" + modified_s + \"ng \" + modified_s + \" of the \" + modified_s + \"nput.\");\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = odd_count;\n    assert(candidate((std::vector<std::string>({(std::string)\"1234567\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"271\", (std::string)\"137\", (std::string)\"314\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\", (std::string)\"the number of odd elements 3n the str3ng 3 of the 3nput.\", (std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/114",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// عدد n جي هڪ ويڪٽر ڏنو ويو آهي ، نمبرن جي ڪنهن به خالي نه سب ويڪٽر جو گهٽ ۾ گهٽ مجموعو ڳوليو. مثال >>> minSubArraySum(((std:: vector<long>({long) 2, (long) 3, (long) 4, (long) 1, (long) 2, (long) 4}))) (1) >>> minSubArraySum(std:: vector<long>{(long) -1, (long) -2, (long) -3)))) (-6)\nlong minSubArraySum(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong minSubArraySum(std::vector<long> nums) {\n  if (nums.empty()) {\n    throw std::invalid_argument(\"Input vector cannot be empty.\");\n  }\n  long min_so_far = nums[0];\n  long current_min = nums[0];\n  for (size_t i = 1; i < nums.size(); ++i) {\n    current_min = std::min(nums[i], current_min + nums[i]);\n    min_so_far = std::min(min_so_far, current_min);\n  }\n  return min_so_far;\n}",
        "test": "}\nint main() {\n    auto candidate = minSubArraySum;\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));\n    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));\n    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));\n    assert(candidate((std::vector<long>({(long)-10}))) == (-10));\n    assert(candidate((std::vector<long>({(long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/115",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي ويلز جو هڪ مستطيل گرڊ ڏنو ويو آهي. هر قطار هڪ واحد ويل جي نمائندگي ڪري ٿي، ۽ هر قطار ۾ 1 پاڻي جي هڪ واحد يونٽ جي نمائندگي ڪري ٿو. هر ويل ۾ هڪ لاڳاپيل بڪ آهي جيڪو ان مان پاڻي ڪ extractڻ لاءِ استعمال ڪري سگهجي ٿو، ۽ سڀني بڪين جي گنجائش ساڳي آهي. توهان جو ڪم بڪين کي استعمال ڪرڻ آهي ته ويلز کي خالي ڪرڻ لاءِ. ٻاھر ڪ theڻ جو تعداد توهان کي بڪين کي گهٽائڻ جي ضرورت آهي. مثال 1: >>> max_fill((long:std:{long:long:{long:}، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long bucket_lowering_count = 0;\n  for (const auto& row : grid) {\n    long water_in_well = 0;\n    for (long unit : row) {\n      water_in_well += unit;\n    }\n    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;\n  }\n  return bucket_lowering_count;\n}",
        "test": "}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/116",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هن ڪتا ۾ ، توهان کي هڪ غير منفي انٽيگرز جي ويڪٽر کي ترتيب ڏيڻ گهرجي انهن جي بائنري نمائندگي ۾ هڪ جي تعداد جي مطابق وڌندڙ ترتيب ۾. هڪ جي ساڳئي تعداد لاءِ ، ڊيزمل قدر جي بنياد تي ترتيب ڏيو. اهو هن طرح لاڳو ٿيڻ گهرجي: >>> sort_array((std:: vector<long>{(long) 1، (long) 5، (long) 2، (long) 3، (long) 4، (long) 5)) >>> sort_array(std:: vector<long>{(long) 2، (long) 3، (long) 4، (long) 5)) >>> sort_array(std:: vector<long>{(long>{(long} 2، (long) 3، (long) 4، (long) 5، (long) 6)) (std:: vector<long>{(long>{-6, (long) 5، (long) 4، (long) 3، (long) 2، (long) 2، (long) 2، (long) 3، (long) 2، (long) >>> sort_array_std:: vector<long> (long) 1، (long) 0، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long)) (long (long) (long)) (long) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long))\nstd::vector<long> sort_array(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nint count_set_bits(long n) {\n  int count = 0;\n  if (n < 0) {\n    n = std::abs(n);\n  }\n  while (n > 0) {\n    n &= (n - 1);\n    count++;\n  }\n  return count;\n}\n\nbool compare(long a, long b) {\n  int bits_a = count_set_bits(a);\n  int bits_b = count_set_bits(b);\n  if (bits_a != bits_b) {\n    return bits_a < bits_b;\n  }\n  return a < b;\n}\n\nstd::vector<long> sort_array(std::vector<long> arr) {\n  std::sort(arr.begin(), arr.end(), compare);\n  return arr;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));\n    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n}\n"
    },
    {
        "task_id": "HumanEval/117",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ اسٽرنگ s ۽ هڪ فطري نمبر n ڏنو ويو آهي، توهان کي هڪ فنڪشن لاڳو ڪرڻ جو ڪم ڏنو ويو آهي جيڪو اسٽرنگ s مان سڀني لفظن جو ويڪٽر واپس ڪري ٿو جنهن ۾ بلڪل ن نون آواز شامل آهن، انهي ڪري اهي لفظ اسٽرنگ s ۾ ظاهر ٿين ٿا. جيڪڏهن اسٽرنگ s خالي آهي ته فنڪشن کي خالي ويڪٽر واپس ڪرڻ گهرجي. نوٽ: توهان شايد اهو سمجهو ته ان پٽ اسٽرنگ ۾ صرف اکر ۽ جڳهه شامل آهن. مثال: >>> select_words (((\"مريم کي هڪ نن lambڙو ٻڪري هئي\") ، (4)) (std:: vector<std:: string>) ، (3)) (std:: vector<std:: string>) ، (std:: string>) ، (std:: string>) ، (std:: string>) ، (std:: string>) ، (std:: string>) ، (std:: string>) ، (std:: string>) ، (std:: string>) ، (std:: string>) ، (std:: string>) ، (std:: string>) ، (std: world>) ، (std: world>) ، (std: world>) (std: world>) ، (std: world>) (std: world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world> world\nstd::vector<std::string> select_words(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_consonant(char c) {\n  c = tolower(c);\n  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ' ') {\n      long consonant_count = 0;\n      for (char word_char : current_word) {\n        if (is_consonant(word_char)) {\n          consonant_count++;\n        }\n      }\n      if (consonant_count == n) {\n        result.push_back(current_word);\n      }\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  long consonant_count = 0;\n  for (char word_char : current_word) {\n    if (is_consonant(word_char)) {\n      consonant_count++;\n    }\n  }\n  if (consonant_count == n) {\n    result.push_back(current_word);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/118",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي هڪ لفظ ڏنو ويو آهي. توهان جو ڪم اهو آهي ته ويجهي ويجهو آواز ڳوليو جيڪو لفظ جي سا sideي پاسي کان ٻن هم آوازن جي وچ ۾ بيٺو هجي (ڪيس حساس). شروعات ۽ آخر ۾ ويڙهاڪ ڳڻپ نه ڪندا آهن. جيڪڏهن توهان کي مٿي ڏنل شرط تي ڪوبه آواز نه مليو ته خالي تار واپس ڪريو. توهان فرض ڪري سگهو ٿا ته ڏنل تار ۾ صرف انگريزي اکر شامل آهن. مثال: >>> get_closest_vowel((\"yogurt\")) (\"u\") >>> get_closest_vowel(\"FULL\")) (\"U\") >>> get_closest_vowel(\"quick\") (\"\") >>> get_closest_vowel\"(ab\") (\"\")\nstd::string get_closest_vowel(std::string word) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_vowel(char c) {\n  c = tolower(c);\n  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\nbool is_consonant(char c) {\n  return isalpha(c) && !is_vowel(c);\n}\n\nstd::string get_closest_vowel(std::string word) {\n  if (word.length() < 3) {\n    return \"\";\n  }\n  for (int i = word.length() - 2; i >= 1; --i) {\n    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "test": "}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
    },
    {
        "task_id": "HumanEval/119",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي ٻه اسٽرنگس جا ويڪٽر ڏنا ويا آهن، ٻئي اسٽرنگس صرف کليل قوسين '(' يا بند قوسين ') ' تي مشتمل آهن. توهان جو ڪم اهو جانچڻ آهي ته ڇا ٻن اسٽرنگس کي ڪنهن ترتيب سان ڳن toڻ ممڪن آهي، ته نتيجو وارو اسٽرنگ سٺو هوندو. هڪ اسٽرنگ S کي سٺو سمجهيو ويندو آهي ۽ صرف جيڪڏهن S ۾ سڀ قوسين متوازن آهن. مثال طور: اسٽرنگ '(())) ' سٺو آهي ، جڏهن ته اسٽرنگ '()) ' نه آهي. جيڪڏهن هڪ سٺو اسٽرنگ ٺاهڻ جو طريقو آهي ، 'ها' واپس ڪريو ، ۽ ٻي صورت ۾ 'نه' واپس ڪريو. مثال: >>> match_parens((std:: vector<std:: string>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::string match_parens(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_good(const std::string& s) {\n  int balance = 0;\n  for (char c : s) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n    }\n    if (balance < 0) {\n      return false;\n    }\n  }\n  return balance == 0;\n}\n\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  if (is_good(s1 + s2) || is_good(s2 + s1)) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
    },
    {
        "task_id": "HumanEval/120",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ ويڪٽر آر آر ۽ هڪ مثبت انٽيگر ڪ ڏنو ويو آهي ، آر آر ۾ وڌ کان وڌ ڪي نمبرن سان گڏ ڊيگهه جي ترتيب واري ويڪٽر کي واپس ڪريو. مثال 1: >>> وڌ ۾ وڌ((اسٽ: ويڪٽر<ڊگهي>{(ڊگهي) -3, (ڊگهي) -4, (ڊگهي) -5,)), (3)) (اسٽ: ويڪٽر<ڊگهي>{(ڊگهي) -4, (ڊگهي) -3, (ڊگهي) -5}) ، (3)) (اسٽ: ويڪٽر<ڊگهي>{(ڊگهي) -4, (ڊگهي) -4}) ، (2)) (اسٽ: ويڪٽر<ڊگهي>{(ڊگهي) -4, (ڊگهي) -4}) مثال 3: >>> وڌ ۾ وڌ (((اسٽ: ويڪٽر<ڊگهي>{(ڊگهي) -3, (ڊگهي) -2, (ڊگهي) -1, (ڊگهي) -2, (ڊگهي) -1, (ڊگهي) -2, (ڊگهي) -1) ، (1) (اسٽ: ويڪٽر<ڊ: ويڪٽر<ڊ: ڊگهي>) 1. ويڪٽر جي ڊيگهه 1000 جي ڊيگهه ۾ هوندي. ويڪٽر جي ڊيگهه جي ڊيگهه 1000 جي حد ۾ هوندي. نوٽ: ويڪٽر جي ڊيگهه ۾ 1، 2، 1000 جي ڊيگهه هوندي.\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.rbegin(), arr.rend());\n  std::vector<long> result;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    result.push_back(arr[i]);\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));\n    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));\n    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));\n    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/121",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// عدد جي هڪ غير خالي ويڪٽر ڏنو ويو آهي ، سڀني غير جانبدار عنصرن جو مجموعو واپس ڪريو جيڪي برابر پوزيشن ۾ آهن. مثال >>> حل (((std:: vector<long>({(long) 5، (long) 8، (long) 7، (long) 1}))) (12) >>> حل ((((std:: vector<long>({(long) 3، (long) 3، (long) 3، (long) 3}))) (9) >>> حل ((((std:: vector<long>({(long) 30، (long) 13، (long) 24، (long) 321}))) (0)\nlong solution(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solution;\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));\n    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));\n    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));\n    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/122",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// آر آر جي انٽيگرز جي هڪ غير خالي ويڪٽر ۽ هڪ انٽيگر ڪي ڏنو ويو آهي ، آر آر جي پهرين ڪي عناصر کان وڌ ۾ وڌ ٻن انگن سان عنصرن جو مجموعو واپس ڪريو. مثال: >>> add_elements((std:: vector<long>(({long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) پابنديون: 1. 1 <= len(arr) <= 100 2. 1 <= k <= lenarr)\nlong add_elements(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add_elements;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));\n    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));\n    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));\n    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));\n    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/123",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثبت عدد n ڏنو ويو آهي ، هڪ ترتيب ڏنل ويڪٽر واپس ڪريو جنهن ۾ ڪولٽز تسلسل ۾ غير معمولي نمبر آهن. ڪولٽز جو اندازو رياضي ۾ هڪ اندازو آهي جيڪو هڪ تسلسل جي حوالي سان آهي جنهن جي وضاحت هن ريت آهي: ڪنهن به مثبت عدد n سان شروع ڪريو. پوءِ هر اصطلاح اڳئين اصطلاح کان حاصل ڪئي ويندي آهي: جيڪڏهن پوئين اصطلاح برابر آهي ، ايندڙ اصطلاح پوئين اصطلاح جو اڌ آهي. جيڪڏهن پوئين اصطلاح ڌار آهي ، ايندڙ اصطلاح 3 ڀيرا پوئين اصطلاح کان وڌيڪ آهي. اهو اندازو آهي ته n جي ڪهڙي به قدر جي پرواهه ناهي ، تسلسل هميشه 1 تائين پهچندي. نوٽ: 1. ڪولٽز (((1) آهي [1]. 2. موٽيل ويڪٽر ترتيب ڏنل ترتيب ۾. مثال طور: get_odd_collatz5) واپسي [1, 5] 5 لاءِ ڪولٽز تسلسل آهي [5, 8, 16, 4, 2, 1] ، تنهن ڪري صرف ڌار نمبر 1 ۽ 5. >>> get_odd_collatz ((((5) (وڪٽر:d<((1، (ڊگهو) {(1، (ڊگهو))\nstd::vector<long> get_odd_collatz(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> odd_numbers;\n  std::unordered_set<long> seen;\n  long current = n;\n  while (seen.find(current) == seen.end()) {\n    seen.insert(current);\n    if (current % 2 != 0) {\n      odd_numbers.push_back(current);\n    }\n    if (current == 1) {\n      break;\n    }\n    if (current % 2 == 0) {\n      current /= 2;\n    } else {\n      current = 3 * current + 1;\n    }\n  }\n  std::sort(odd_numbers.begin(), odd_numbers.end());\n  return odd_numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = get_odd_collatz;\n    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));\n    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/124",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي هڪ فنڪشن لکڻ آهي جيڪا هڪ ڏنل تاريخ جي تار کي صحيح ڪري ۽ جيڪڏهن تاريخ صحيح هجي ته صحيح موٽائي ٻي صورت ۾ غلط. تاريخ صحيح آهي جيڪڏهن هيٺين سڀني قاعدن کي پورو ڪيو وڃي: 1. تاريخ جي تار خالي نه آهي. 2. ڏينهن جو تعداد مهينن لاءِ 1 کان گهٽ يا 31 ڏينهن کان وڌيڪ نه آهي. ۽ ڏينهن جو تعداد مهينن لاءِ 1 کان گهٽ يا 30 ڏينهن کان وڌيڪ نه آهي. 4,6,9,11. ۽ ، ڏينهن جو تعداد مهينن لاءِ 1 کان گهٽ يا 29 کان وڌيڪ نه آهي. 2. مهينن کان گهٽ يا 12 کان وڌيڪ نه هجڻ گهرجي. 4. تاريخ فارميٽ ۾ هجڻ گهرجي: mm-dd-yyyy >>> صحيح_(تاريخ(103-11-2000\")) (سچ) >>> صحيح_تاريخ(15-01-2012\")) (غلط) >>> صحيح_تاريخ(04-040-20\") (غلط) >>> صحيح_تاريخ(06-2020\") (سچ) >>> صحيح_تاريخ(06-04\") >>> صحيح_تاريخ(06-04/2020) (غلط)\nbool valid_date(std::string date) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool valid_date(std::string date) {\n  if (date.empty()) {\n    return false;\n  }\n  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n    return false;\n  }\n  int month, day, year;\n  try {\n    month = std::stoi(date.substr(0, 2));\n    day = std::stoi(date.substr(3, 2));\n    year = std::stoi(date.substr(6, 4));\n  } catch (const std::invalid_argument& e) {\n    return false;\n  } catch (const std::out_of_range& e) {\n    return false;\n  }\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1) {\n    return false;\n  }\n  if (month == 2) {\n    if (day > 29) {\n      return false;\n    }\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30) {\n      return false;\n    }\n  } else {\n    if (day > 31) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = valid_date;\n    assert(candidate((\"03-11-2000\")) == (true));\n    assert(candidate((\"15-01-2012\")) == (false));\n    assert(candidate((\"04-0-2040\")) == (false));\n    assert(candidate((\"06-04-2020\")) == (true));\n    assert(candidate((\"01-01-2007\")) == (true));\n    assert(candidate((\"03-32-2011\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"04-31-3000\")) == (false));\n    assert(candidate((\"06-06-2005\")) == (true));\n    assert(candidate((\"21-31-2000\")) == (false));\n    assert(candidate((\"04-12-2003\")) == (true));\n    assert(candidate((\"04122003\")) == (false));\n    assert(candidate((\"20030412\")) == (false));\n    assert(candidate((\"2003-04\")) == (false));\n    assert(candidate((\"2003-04-12\")) == (false));\n    assert(candidate((\"04-2003\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/125",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// لفظن جي هڪ سلسلي ڏني، لفظن جي هڪ vector واپس وائيٽ اسپيس تي ورهايو، جيڪڏهن ڪو به وائيٽ اسپيس موجود نه آهي ته توهان کي ڪاما تي ورهايو وڃي '، جيڪڏهن ڪو ڪاما موجود نه آهي ته توهان کي الفابيٽ ۾ غير معمولي ترتيب سان نن lowerن اکرن جو تعداد واپس ڪرڻ گهرجي، ord ((('a') = 0 ، ord ((('b') = 1 ، . . . ord ((('z') = 25 مثال >>> split_words (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nUnion_std_vector_std_string__long split_words(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;\n    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  if (txt.find(' ') != std::string::npos) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n    std::string word;\n    while (ss >> word) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if (txt.find(',') != std::string::npos) {\n    std::vector<std::string> words;\n    std::string current_word;\n    for (char c : txt) {\n      if (c == ',') {\n        words.push_back(current_word);\n        current_word = \"\";\n      } else {\n        current_word += c;\n      }\n    }\n    words.push_back(current_word);\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long odd_order_count = 0;\n    for (char c : txt) {\n      if (islower(c)) {\n        if ((c - 'a') % 2 != 0) {\n          odd_order_count++;\n        }\n      }\n    }\n    return Union_std_vector_std_string__long(odd_order_count);\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/126",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// جيڪڏهن هڪ عدد جي ويڪٽر ڏني وئي آهي ته واپس ڪريو ته اهي وڌندڙ ترتيب ۾ ترتيب ڏنل آهن يا نه. جيڪڏهن ويڪٽر ۾ هڪ ئي نمبر جي هڪ کان وڌيڪ نقلون آهن ته غلط واپس ڪريو. فرض ڪريو ته ڪوبه منفي نمبر نه آهن ۽ صرف انٽيگرز. مثال >>> is_sorted (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (\nbool is_sorted(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_sorted(std::vector<long> lst) {\n  if (lst.size() <= 1) {\n    return true;\n  }\n  std::map<long, int> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  for (auto const& [key, val] : counts) {\n    if (val > 2) {\n      return false;\n    }\n  }\n  for (size_t i = 0; i < lst.size() - 1; ++i) {\n    if (lst[i] > lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_sorted;\n    assert(candidate((std::vector<long>({(long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/127",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي ٻه وقتي ڏنا ويا آهن، جتي هر وقتي عدد جوڙو آهي. مثال طور، وقتي = (شروع، ختم) = (1, 2). ڏنل وقتي بند ٿيل آهن جنهن جو مطلب آهي ته وقتي (شروع، ختم) ۾ شروعات ۽ ختم ٻئي شامل آهن. هر ڏنل وقتي لاءِ ، اهو فرض ڪيو ويو آهي ته ان جي شروعات ان جي آخر کان گهٽ يا برابر آهي. توهان جو ڪم اهو طئي ڪرڻ آهي ته ڇا انهن ٻن وقتي جي وچ واري ڊيگهه هڪ پرائم نمبر آهي. مثال طور ، وقتي جي وچ واري ڊيگهه (1, 3) ، (2، 4) (2، 3) آهي ، جنهن جي ڊيگهه 1 آهي ، جيڪا پرائم نمبر نه آهي. جيڪڏهن وچ واري ڊيگهه پرائم نمبر آهي ، \"ها\" موٽايو ، ٻي صورت ۾ ، \"نه\" موٽايو. جيڪڏهن ٻه وقتي وچ ۾ نه اچن ، \"نه\" موٽايو. [انپٽ / آئوٽ] نموني: >>> سيڪشن: (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get(interval1);\n  long end1 = std::get(interval1);\n  long start2 = std::get(interval2);\n  long end2 = std::get(interval2);\n  long intersection_start = std::max(start1, start2);\n  long intersection_end = std::min(end1, end2);\n  long intersection_length = intersection_end - intersection_start + 1;\n  if (intersection_length <= 0) {\n    return \"NO\";\n  }\n  if (is_prime(intersection_length)) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
    },
    {
        "task_id": "HumanEval/128",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي انٽيگرز جو هڪ ويڪٽر ڏنو ويو آهي ۽ توهان کي انٽيگرز جي ماپ جو مجموعو موٽائڻ جي ضرورت آهي هر نمبر جي نشانين جي پيداوار سان گڏ ، 1 ، -1 يا 0 جي نمائندگي ڪئي وئي آهي نوٽ: واپسي خالي آر لاءِ ڪوبه ناهي. مثال: >>> prod_signs(((std::vector<long>{(long) 1 ، (long) 2 ، (long) 2 ، (long) -4)))) 9 >>> prod_signs(std::vector<long>({(long) 0 ، (long) 1)) 0 >>> prod_signs (((std::vector<long>(())) std::nopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  long sum_magnitudes = 0;\n  long product_of_signs = 1;\n  for (long num : arr) {\n    sum_magnitudes += std::abs(num);\n    if (num > 0) {\n      product_of_signs *= 1;\n    } else if (num < 0) {\n      product_of_signs *= -1;\n    } else {\n      product_of_signs *= 0;\n    }\n  }\n  return sum_magnitudes * product_of_signs;\n}",
        "test": "}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/129",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// N قطار ۽ N ڪالمن (N > = 2) ۽ هڪ مثبت انٽيگر k سان هڪ گرڊ ڏنو ويو آهي ، گرڊ جي هر خاني ۾ هڪ قدر آهي. [1، N * N] جي حد ۾ هر انٽيگر شامل آهي گرڊ جي خاني تي هڪ ڀيرو ظاهر ٿئي ٿو. توهان کي گرڊ ۾ ڊيگهه k جو گهٽ ۾ گهٽ رستو ڳولڻو پوندو. توهان ڪنهن به سيل کان شروع ڪري سگهو ٿا ، ۽ هر قدم ۾ توهان پاڙيسري خاني مان ڪنهن ڏانهن وڃي سگهو ٿا ، ٻين لفظن ۾ ، توهان انهن خانن ڏانهن وڃي سگهو ٿا جيڪي توهان جي موجوده سيل سان گڏ هڪ ڪنڊ حصيداري ڪن ٿا. مهرباني ڪري نوٽ ڪريو ته ڊيگهه k جو رستو مطلب آهي ڪي ڪي سيلز جو دورو ڪرڻ (ضروري طور تي ڌار نه). توهان گرڊ کان ٻاهر نه ٿي سگهو. هڪ رستو A (ڊيگهه k) هڪ رستي B (ڊيگهه k) کان گهٽ سمجهيو ويندو آهي جيڪڏهن A ۽ B تي قدرن جي ترتيب وار ويڪٽر ٺاهڻ کان پوءِ (اسان انهن کي l_stA ۽ l_stB سڏيون ٿا) ، l_stA lexically آهي l_j_stB کان گهٽ آهي ، ٻين لفظن ۾ ، توهان ڪنهن به سيل کان شروع ڪري سگهو ٿا ، ٻين لفظن ۾ ، توهان ڪنهن به پاڙيل خاني ڏانهن وڃي سگهو ٿا ، ٻين لفظن ۾ ، توهان ڪنهن به پاڙ واري خاني ڏانهن وڃي سگهو ٿا. مهرباني ڪري نوٽ ڪريو ته k جي ڊيگهه k جي ڊيگهه k جو مطلب آهي (ضروري طور تي ڌار نه آهي) توهان کي گريڊ کان ٻاهر نٿي ڪري سگهو ٿا گرڊ کان. توهان گرڊ کان ٻاهر نٿي کان نٿي کان نٿي نه ٿا. توهان جي ڊيگهه کان ٻاهر نٿي کان ٻاهر نٿي کان ٻاهر نٿي ڪري سگهو ٿا.\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  int n = grid.size();\n  std::vector<long> min_path;\n\n  std::function<void(int, int, std::vector<long>)> dfs = \n    [&](int row, int col, std::vector<long> current_path) {\n    if (current_path.size() == k) {\n      if (min_path.empty() || current_path < min_path) {\n        min_path = current_path;\n      }\n      return;\n    }\n\n    current_path.push_back(grid[row][col]);\n\n    int dr= {-1, 1, 0, 0};\n    int dc= {0, 0, -1, 1};\n\n    for (int i = 0; i < 4; ++i) {\n      int next_row = row + dr[i];\n      int next_col = col + dc[i];\n      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {\n        dfs(next_row, next_col, current_path);\n      }\n    }\n  };\n\n  for (int start_row = 0; start_row < n; ++start_row) {\n    for (int start_col = 0; start_col < n; ++start_col) {\n      dfs(start_row, start_col, {});\n    }\n  }\n\n  return min_path;\n}",
        "test": "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/130",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هرڪو فبوناشي تسلسل کي knowsاڻي ٿو ، اهو گذريل ٻن صدين ۾ رياضي دانن پاران گہرے مطالعو ڪيو ويو آهي. تنهن هوندي ، جيڪي ماڻهو نٿا knowاڻن ٽربوناشي تسلسل آهي. ٽربوناشي تسلسل جي تعريف ڪئي وئي آهي: ٽري ((1) = 3 ٽري (((n) = 1 + ن / 2 ، جيڪڏهن ن جوڙي آهي. ٽري (((n) = ٽري (((n - 1) + ٽري (((n - 2) + ٽري (((n + 1) ، جيڪڏهن ن ڌار آهي. مثال طور: ٽري ((2) = 1 + (2 / 2) = 2 ٽري (((4) = 3 ٽري ((3) = ((2) + ٽري ((1) + ((4) = 2 + 3 + 3 = 8 توهان کي هڪ غير منفي انٽيگر نمبر ڏنو ويو آهي ، توهان کي ٽربوناشي تسلسل جي پهرين ن + 1 جو ويڪٽر واپس ڪرڻو آهي. مثال: >>> ((((3) (ڊگهو ويڪٽر: (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> tri(long n) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> tri(long n) {\n  std::vector<long> result;\n  if (n >= 0) {\n    result.push_back(1);\n  }\n  if (n >= 1) {\n    result.push_back(3);\n  }\n  for (long i = 2; i <= n; ++i) {\n    if (i % 2 == 0) {\n      result.push_back(1 + i / 2);\n    } else {\n      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)\n      {\n          result.push_back(result[i-1] + result[i-2] + result[i]);\n      }\n      else if (i - 1 >= 0 && i - 2 >= 0)\n      {\n          result.push_back(result[i-1] + result[i-2]);\n      }\n      else if (i - 1 >= 0)\n      {\n          result.push_back(result[i-1]);\n      }\n      else\n      {\n          result.push_back(0);\n      }\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = tri;\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));\n    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));\n    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));\n    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));\n    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));\n    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));\n    assert(candidate((0)) == (std::vector<long>({(long)1})));\n    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/131",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مثبت عدد n ڏنو ويو آهي ، غير جانبدار انگن جي پيداوار کي موٽايو. 0 واپس ڪريو جيڪڏهن سڀ انگن جو برابر آهي. مثال طور: >>> انگن جو تعداد (((1)) (1) >>> انگن جو تعداد (((4)) (0) >>> انگن جو تعداد (((235)) (15)\nlong digits(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digits(long n) {\n  long product = 1;\n  std::string s = std::to_string(n);\n  bool has_odd = false;\n  for (char c : s) {\n    long digit = c - '0';\n    if (digit % 2 != 0) {\n      product *= digit;\n      has_odd = true;\n    }\n  }\n  if (!has_odd) {\n    return 0;\n  }\n  return product;\n}",
        "test": "}\nint main() {\n    auto candidate = digits;\n    assert(candidate((5)) == (5));\n    assert(candidate((54)) == (5));\n    assert(candidate((120)) == (1));\n    assert(candidate((5014)) == (5));\n    assert(candidate((98765)) == (315));\n    assert(candidate((5576543)) == (2625));\n    assert(candidate((2468)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/132",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن ٺاهيو جيڪو ان پٽ جي طور تي هڪ اسٽرنگ وٺي ٿو جنهن ۾ صرف مربع قوسين شامل آهن. فنڪشن کي صحيح موٽڻ گهرجي ۽ صرف جيڪڏهن قوسين جو هڪ صحيح ذيلي تسلسل هجي جتي گهٽ ۾ گهٽ هڪ قوسين ۾ موجود هجي. >>> is_nested((\"[[]]\")) (true) >>> is_nested((\"[]]]]]]]][[[[[[[]\")) (false) >>> is_nested((\"[][]\")) (false) >>> is_nested((\"[]\")) (false) >>> is_nested(\"]]]]]]\") (true) >>> is_nested(\"[[]]\") (true)\nbool is_nested(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_nested(std::string string) {\n  int balance = 0;\n  bool nested = false;\n  for (char c : string) {\n    if (c == '[') {\n      balance++;\n    } else if (c == ']') {\n      if (balance > 1) {\n        nested = true;\n      }\n      balance--;\n      if (balance < 0) {\n        return false;\n      }\n    }\n  }\n  return balance == 0 && nested;\n}",
        "test": "}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/133",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي انگن جو هڪ ويڪٽر ڏنو ويو آهي. توهان کي ڏنل ويڪٽر ۾ نمبرن جي چوڪ جو مجموعو واپس ڪرڻ جي ضرورت آهي، پهرين ويڪٽر ۾ هر عنصر کي مٿين انٽ تائين گول ڪريو. مثال: >>> lst: vector<float>{(float) 1.0f, (float) 2.0f, (float) 3.0f)) (14) >>> lst: vector<float>{(float) 1.0f, (float) 4.0f, (float) 9.0f))) >>> (98) lst: vector<float>{(float) 1.0f, (float) 3.0f, (float) 5.0f, (float) 5.0f, (float) 7.0f} (84) >>> lst: vector<float>{{(float>{1.0f, (float) 2.0f, (float) 3.0f, (float) 9.0f))) (6) >>> (float: vector<float>{1.0f, (float) 2.0f, (float) 6)) >>> (float) 1.04f, (float)\nlong sum_squares(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    long rounded_up = std::ceil(num);\n    sum += rounded_up * rounded_up;\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));\n    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));\n    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));\n    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/134",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن ٺاهيو جيڪو صحيح موٽائي ٿو جيڪڏهن ڏنل اسٽرنگ جو آخري ڪردار الفابيٽ وارو ڪردار آهي ۽ لفظ جو حصو نه آهي ، ۽ ٻي صورت ۾ غلط. نوٽ: \"لفظ\" اکرن جو هڪ گروپ آهي جيڪو خلا سان جدا ٿيل آهي. مثال: >>> check_if_last_char_is_a_letter (((\"ايپل پائي\")) (false) >>> check_if_last_char_is_a_letter (((\"ايپل پائي\")) (سچو) >>> check_if_last_char_is_a_letter (((\"ايپل پائي\"))) (غلط) >>> check_if_last_char_is_a_letter (((\"غلط\"))\nbool check_if_last_char_is_a_letter(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) {\n    return false;\n  }\n  if (!isalpha(txt.back())) {\n    return false;\n  }\n  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {\n    return false;\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = check_if_last_char_is_a_letter;\n    assert(candidate((\"apple\")) == (false));\n    assert(candidate((\"apple pi e\")) == (true));\n    assert(candidate((\"eeeee\")) == (false));\n    assert(candidate((\"A\")) == (true));\n    assert(candidate((\"Pumpkin pie \")) == (false));\n    assert(candidate((\"Pumpkin pie 1\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"eeeee e \")) == (false));\n    assert(candidate((\"apple pie\")) == (false));\n    assert(candidate((\"apple pi e \")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/135",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن ٺاهيو جيڪو هڪ عنصر جو سڀ کان وڏو انڊيڪس موٽائي ٿو جيڪو ان کان اڳ واري عنصر کان وڏو يا برابر نه آهي. جيڪڏهن اهڙو عنصر موجود نه آهي ته پوءِ واپسي -1. ڏنل ويڪٽر ۾ ٻيڻو قدر نه هوندو. مثال: >>> can_arrange((std::vector<long>({long) 1, (long) 2, (long) 4, (long) 3, (long) 5}))) (3) >>> can_arrange((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (-1)\nlong can_arrange(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong can_arrange(std::vector<long> arr) {\n  for (long i = 1; i < arr.size(); ++i) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "test": "}\nint main() {\n    auto candidate = can_arrange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));\n    assert(candidate((std::vector<long>())) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/136",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن ٺاهيو جيڪو هڪ ٽپل (a، b) موٽائي ٿو، جتي 'a' منفي انٽيگرز جو سڀ کان وڏو آهي، ۽ 'b' هڪ ويڪٽر ۾ مثبت انٽيگرز جو نن smallestڙو آهي. جيڪڏهن ڪو منفي يا مثبت انٽيگرز نه آهن ، انهن کي واپس ڪريو None. مثال: >>> largest_smallest_integers(((std::vector<long>{long>) 2، (long) 4، (long) 1، (long) 3، (long) 5، (long) 7)) std::make_tuplestd::optional<long>{long>) ، std::optional<long>) >>> largest_smallest_integers{long>) ، std::optional<long> (long>) ، std::optional<long> (long>) ، std::optional<long> (long>) ، std::optional<long> (long>) ، std::optional<long> (long>) ، std::optional<long> (long>) ، std::optional<long> (<long>)\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<tuple>\n#include<vector>\n\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative.has_value() || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive.has_value() || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative, smallest_positive);\n}",
        "test": "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));\n    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));\n}\n"
    },
    {
        "task_id": "HumanEval/137",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// هڪ فنڪشن ٺاهيو جيڪو انٽيگرز، فلوٽس، يا اسٽرنگز کي حقيقي انگن جي نمائندگي ڪري ٿو، ۽ ان جي ڏنل متغير قسم ۾ وڏي متغير واپس ڪري ٿو. جيڪڏهن قدر برابر آهن ته ڪو به نه موٽايو. نوٽ: جيڪڏهن هڪ حقيقي نمبر هڪ اسٽرنگ جي طور تي نمائندگي ڪئي وئي آهي، ته فلوٽنگ پوائنٽ ٿي سگهي ٿو . يا ، >>> compare_one(1، 2.5f) 2.5f >>> compare_one(1، \"2,3\") \"2,3\" >>> compare_one(\"5,1\"، \"6\") \"6\" >>> compare_one(\"1\"، 1) std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<string>\n\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;\n    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;\n    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n\ndouble parse_real(const std::string& s) {\n    std::string temp = s;\n    std::replace(temp.begin(), temp.end(), ',', '.');\n    try {\n        return std::stod(temp);\n    } catch (const std::invalid_argument& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    } catch (const std::out_of_range& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    }\n}\n\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a.f2.empty() && b.f2.empty()) {\n        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {\n            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {\n            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {\n            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {\n            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);\n        }\n    } else {\n        double val_a, val_b;\n        if (!a.f2.empty()) val_a = parse_real(a.f2);\n        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);\n        else val_a = static_cast<double>(a.f1);\n\n        if (!b.f2.empty()) val_b = parse_real(b.f2);\n        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);\n        else val_b = static_cast<double>(b.f1);\n\n        if (!std::isnan(val_a) && !std::isnan(val_b)) {\n            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);\n            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);\n        }\n    }\n    return Union_long_float_std_string_std_nullopt(std::nullopt{});\n}",
        "test": "}\nint main() {\n    auto candidate = compare_one;\n    assert(candidate(1, 2) == 2);\n    assert(candidate(1, 2.5f) == 2.5f);\n    assert(candidate(2, 3) == 3);\n    assert(candidate(5, 6) == 6);\n    assert(candidate(1, \"2,3\") == \"2,3\");\n    assert(candidate(\"5,1\", \"6\") == \"6\");\n    assert(candidate(\"1\", \"2\") == \"2\");\n    assert(candidate(\"1\", 1) == std::nullopt);\n}\n"
    },
    {
        "task_id": "HumanEval/138",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اندازو لڳايو ته ڇا ڏنل نمبر n کي صحيح طور تي 4 مثبت انگن جو مجموعو طور لکي سگهجي ٿو مثال >>> is_equal_to_sum_even ((4)) (false) >>> is_equal_to_sum_even ((6)) (false) >>> is_equal_to_sum_even ((8)) (true)\nbool is_equal_to_sum_even(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_equal_to_sum_even(long n) {\n    if (n <= 6 || n % 2 != 0) {\n        return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_equal_to_sum_even;\n    assert(candidate((4)) == (false));\n    assert(candidate((6)) == (false));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (true));\n    assert(candidate((11)) == (false));\n    assert(candidate((12)) == (true));\n    assert(candidate((13)) == (false));\n    assert(candidate((16)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/139",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// برازيلي فيڪٽريئل جي تعريف هن ريت آهي: برازيلي_ فيڪٽريئل ((n) = ن! * (ن -1)! * (ن -2)! * . . . * 1! جتي ن > 0 مثال طور: >>> خاص_ فيڪٽريئل (((4)) (288) فنڪشن انٽيگر ان پٽ طور وصول ڪندو ۽ هن انٽيگر جو خاص فيڪٽريئل موٽڻ گهرجي.\nlong special_factorial(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong factorial(long k) {\n    long res = 1;\n    for (long i = 2; i <= k; ++i) {\n        res *= i;\n    }\n    return res;\n}\n\nlong special_factorial(long n) {\n    if (n <= 0) {\n        return 1;\n    }\n    long result = 1;\n    for (long i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = special_factorial;\n    assert(candidate((4)) == (288));\n    assert(candidate((5)) == (34560));\n    assert(candidate((7)) == (125411328000));\n    assert(candidate((1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/140",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ اسٽرنگ متن ڏنو، ان ۾ سڀني جڳهن کي underscores سان تبديل ڪريو، ۽ جيڪڏهن هڪ اسٽرنگ ۾ 2 کان وڌيڪ لڳاتار جڳهن آهن، پوء سڀني لڳاتار جڳهن کي تبديل ڪريو - >>> fix_spaces (((\" مثال \")) (\"مثال\") >>> fix_spaces (((\" مثال 1\")) (\"مثال_1\") >>> fix_spaces (((\" مثال 2\")) (\"_مثال_2\") >>> fix_spaces (((\" مثال 3\")) (\"_مثال-3\")\nstd::string fix_spaces(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string fix_spaces(std::string text) {\n    std::string result = \"\";\n    int space_count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 1) {\n                result += '-';\n            }\n            result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1 && !result.empty() && result.back() != '_') {\n        result += '_';\n    } else if (space_count > 1 && !result.empty() && result.back() != '-') {\n        result += '-';\n    } else if (space_count > 0 && result.empty()) {\n        if (space_count > 2) result += '-';\n        else if (space_count == 1) result += '_';\n    } else if (space_count == 1 && result.empty()) {\n        result += '_';\n    }\n\n    std::string trimmed_result = \"\";\n    bool non_space_found = false;\n    for (char c : result) {\n        if (c != ' ') {\n            non_space_found = true;\n            trimmed_result += c;\n        } else if (non_space_found) {\n            trimmed_result += c;\n        }\n    }\n\n    while (!trimmed_result.empty() && trimmed_result.front() == '_') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '_') {\n        trimmed_result.pop_back();\n    }\n     while (!trimmed_result.empty() && trimmed_result.front() == '-') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '-') {\n        trimmed_result.pop_back();\n    }\n\n    std::string final_result = \"\";\n    space_count = 0;\n    for (char c : trimmed_result) {\n        if (c == '_') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                final_result += '_';\n            } else if (space_count > 1) {\n                final_result += '-';\n            }\n            final_result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1) {\n        final_result += '_';\n    } else if (space_count > 1) {\n        final_result += '-';\n    }\n\n    return final_result;\n}",
        "test": "}\nint main() {\n    auto candidate = fix_spaces;\n    assert(candidate((\"Example\")) == (\"Example\"));\n    assert(candidate((\"Mudasir Hanif \")) == (\"Mudasir_Hanif_\"));\n    assert(candidate((\"Yellow Yellow  Dirty  Fellow\")) == (\"Yellow_Yellow__Dirty__Fellow\"));\n    assert(candidate((\"Exa   mple\")) == (\"Exa-mple\"));\n    assert(candidate((\"   Exa 1 2 2 mple\")) == (\"-Exa_1_2_2_mple\"));\n}\n"
    },
    {
        "task_id": "HumanEval/141",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن ٺاهيو جيڪو هڪ فائل جو نالو ظاهر ڪرڻ واري اسٽرنگ کي وٺي ٿو، ۽ جيڪڏهن فائل جو نالو صحيح آهي ته 'ها' موٽائي ٿو، ۽ ٻي صورت ۾ 'نه' موٽائي ٿو. هڪ فائل جو نالو صحيح سمجهيو ويندو آهي جيڪڏهن ۽ صرف جيڪڏهن هيٺ ڏنل سڀني شرطن تي پورا لهن: - فائل جي نالي ۾ ٽن کان وڌيڪ انگ نه هجڻ گهرجي ('0'-'9') - فائل جو نالو بلڪل هڪ ڊٽ '.' تي مشتمل آهي - ڊٽ کان اڳ سبسٽنگ خالي نه هجڻ گهرجي، ۽ اهو لاطيني الفپٽ جي هڪ خط سان شروع ٿئي ٿو ('a'-'z' ۽ 'A'-Z'). - ڊٽ کان پوء سبسٽنگ انهن مان هڪ هجڻ گهرجي: ['txt'، 'exe'، 'll'] مثال: >>> file_name_check\"(مثال.txt\") (\"ها\") >>> file_name_check\"(مثال.dll\" (\"نه\")\nstd::string file_name_check(std::string file_name) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    size_t dot_pos = std::string::npos;\n\n    for (size_t i = 0; i < file_name.length(); ++i) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        } else if (file_name[i] == '.') {\n            dot_count++;\n            dot_pos = i;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {\n        return \"No\";\n    }\n\n    std::string name_part = file_name.substr(0, dot_pos);\n    std::string ext_part = file_name.substr(dot_pos + 1);\n\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    if (ext_part == \"txt\" || ext_part == \"exe\" || ext_part == \"dll\") {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) == (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n    assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"_f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
    },
    {
        "task_id": "HumanEval/142",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \" هي فنڪشن انٽيگرز جو هڪ ويڪٽر وٺندو. ويڪٽر ۾ سڀني داخلائن لاءِ ، فنڪشن انٽيگر داخلا کي چوڪيندو جيڪڏهن ان جو انڊيڪس 3 جو هڪ ضرب آهي ۽ انٽيگر داخلا کي ڪوب ڪندو جيڪڏهن انڊيڪس 4 جو ضرب آهي ۽ نه 3 جو ضرب. فنڪشن ويڪٽر ۾ داخلائن کي تبديل نه ڪندو جن جا انڊيڪس 3 يا 4 جو ضرب نه آهن. فنڪشن پوءِ سڀني داخلائن جو مجموعو موٽائيندو. مثال: >>> lst (long({(long) 1، (long) 2، (long) 3})) >>> lst (long) 1، (long) 5، (long) 2، (long) 1، (long) 5}))\nlong sum_squares(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));\n    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));\n    assert(candidate((std::vector<long>({(long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));\n    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));\n    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));\n}\n"
    },
    {
        "task_id": "HumanEval/143",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي هڪ جملو جي نمائندگي ڪندڙ هڪ تار ڏني وئي آهي، هن جملي ۾ ڪجهه لفظن کي اسپيس سان ڌار ڪيو ويو آهي، ۽ توهان کي هڪ تار واپس ڪرڻي آهي جنهن ۾ اصل جملي جا لفظ شامل آهن، جن جي ڊيگهه پرائم نمبر آهن، نئين تار ۾ لفظن جي ترتيب اصل هڪ وانگر ساڳي هجڻ گهرجي. مثال 1: >>> words_in_sentence (((\"This is a test\")) (\"is\") مثال 2: >>> words_in_sentence (((\"lets go for swimming\")) (\"go for\") پابنديون: * 1 <= len ((sentence) <= 100 * جملي ۾ صرف اکر شامل آهن\nstd::string words_in_sentence(std::string sentence) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
    },
    {
        "task_id": "HumanEval/144",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان جو ڪم هڪ فنڪشن لاڳو ڪرڻ آهي جيڪو اظهار کي آسان بڻائي ٿو x * n فنڪشن صحيح موٽندو جيڪڏهن x * n هڪ مڪمل نمبر ۽ غلط جي قيمت ڏئي ٿو ٻئي x ۽ n ، هڪ ڀا representationي جي اسٽرنگ نمائندگي آهن ، ۽ هيٺ ڏنل فارميٽ آهي ، <نومريٽر> / < ڊينومينٽر> جتي ٻنهي نمبر ۽ ڊينومينٽر مثبت س wholeي نمبر آهن توهان اهو فرض ڪري سگهو ٿا ته x ، ۽ n صحيح ڀا areا آهن ، ۽ ڊينومينٽر طور صفر نه آهي. >>> آسان ڪريو (((\"1/5\") ، (\"5/1\")) (سچ) >>> آسان ڪريو (((\"1/6\") ، (\"2/1\")) (غلط) >>> آسان ڪريو (((\"7/10\") ، (\"10/2\")) (غلط)\nbool simplify(std::string x, std::string n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong gcd(long a, long b) {\n    while (b) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\nbool simplify(std::string x, std::string n) {\n    long x_num, x_den, n_num, n_den;\n    size_t slash_pos = x.find('/');\n    x_num = std::stol(x.substr(0, slash_pos));\n    x_den = std::stol(x.substr(slash_pos + 1));\n\n    slash_pos = n.find('/');\n    n_num = std::stol(n.substr(0, slash_pos));\n    n_den = std::stol(n.substr(slash_pos + 1));\n\n    long num = x_num * n_num;\n    long den = x_den * n_den;\n\n    long common_divisor = gcd(num, den);\n    den /= common_divisor;\n\n    return den == 1;\n}",
        "test": "}\nint main() {\n    auto candidate = simplify;\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/6\"), (\"2/1\")) == (false));\n    assert(candidate((\"5/1\"), (\"3/1\")) == (true));\n    assert(candidate((\"7/10\"), (\"10/2\")) == (false));\n    assert(candidate((\"2/10\"), (\"50/10\")) == (true));\n    assert(candidate((\"7/2\"), (\"4/2\")) == (true));\n    assert(candidate((\"11/6\"), (\"6/1\")) == (true));\n    assert(candidate((\"2/3\"), (\"5/2\")) == (false));\n    assert(candidate((\"5/2\"), (\"3/5\")) == (false));\n    assert(candidate((\"2/4\"), (\"8/4\")) == (true));\n    assert(candidate((\"2/4\"), (\"4/2\")) == (true));\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/5\"), (\"1/5\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/145",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو جيڪو انٽيگرز جي ڏنل ويڪٽر کي انهن جي انگن جي مجموعي جي مطابق وڌندڙ ترتيب ۾ ترتيب ڏئي ٿو. نوٽ: جيڪڏهن انهن جي انگن جي ساڳئي رقم سان ڪيترائي شيون آهن ، انهن کي اصل ويڪٽر ۾ انڊيڪس جي بنياد تي ترتيب ڏيو. مثال طور: >>> order_by_points((std::vector<long>({long) 1, (long) 11, (long)-1, (long) - 11, (long) - 12}))) (std::vector<long>({long) - 1, (long) - 11, (long) 1, (long) - 12, (long) 11})) >>> order_by_points((std::vector<long>())) (std::vector<long>(long))\nstd::vector<long> order_by_points(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_digits(long n) {\n    long sum = 0;\n    std::string s = std::to_string(std::abs(n));\n    for (char c : s) {\n        sum += c - '0';\n    }\n    return sum;\n}\n\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, size_t>> indexed_nums;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {\n        long sum_a = sum_digits(a.first);\n        long sum_b = sum_digits(b.first);\n        if (sum_a != sum_b) {\n            return sum_a < sum_b;\n        }\n        return a.second < b.second;\n    });\n\n    std::vector<long> result;\n    for (const auto& pair : indexed_nums) {\n        result.push_back(pair.first);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = order_by_points;\n    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));\n    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/146",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو جيڪو انگن جي ويڪٽر کي ان پٽ جي طور تي وٺي ٿو ۽ ويڪٽر ۾ عنصرن جو تعداد موٽائي ٿو جيڪي 10 کان وڌيڪ آهن ۽ هڪ نمبر جا ٻئي پهرين ۽ آخري انگ انگ آهن (1, 3, 5, 7, 9). مثال طور: >>> specialFilter((std::vector<long>({(long) 15, (long) -73, (long) -14, (long) -15}))) (1) >>> specialFilter((std::vector<long>({(long) 33، (long) -2, (long) -3, (long) -45, (long) 21، (long) 109} (2))))\nlong specialFilter(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_odd_digit(char c) {\n    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');\n}\n\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (std::abs(num) > 10) {\n            std::string s = std::to_string(std::abs(num));\n            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = specialFilter;\n    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));\n    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));\n    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));\n    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));\n    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>())) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/147",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي هڪ مثبت انٽيگر n ڏنو ويو آهي توهان کي ڊيگهه n جو هڪ انٽيگر ويڪٽر ٺاهڻو آهي. هر i (1 ≤ i ≤ n) لاءِ ، a[i] = i * i - i + 1. a جي ٽرپل جي تعداد کي واپس ڪريو (a[i] ، a[j] ، a[k]) جتي i < j < k ، ۽ a[i] + a[j] + a[k] 3 جو هڪ ضرب آهي. مثال: >>> get_max_triples((5)) (1) وضاحت: a = [1، 3، 7، 13، 21] واحد صحيح ٽرپل آهي (1, 7، 13).\nlong get_max_triples(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong get_max_triples(long n) {\n    if (n < 3) {\n        return 0;\n    }\n    std::vector<long> a(n);\n    for (long i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            for (long k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = get_max_triples;\n    assert(candidate((5)) == (1));\n    assert(candidate((6)) == (4));\n    assert(candidate((10)) == (36));\n    assert(candidate((100)) == (53361));\n}\n"
    },
    {
        "task_id": "HumanEval/148",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اسان جي شمسي نظام ۾ اٺ سيارو آهن: سج جي ويجهو ميڪوري آهي، ايندڙ هڪ وينس آهي، پوءِ زمين، مريخ، جپٽي، زحل، يورينس، نيپچون. هڪ فنڪشن لکو جيڪو ٻن سيارن جا نالا وٺي ٿو جيئن ته تارن جي سيارو1 ۽ سيارو2. فنڪشن کي هڪ ٽپل واپس ڪرڻ گهرجي جنهن ۾ سڀني سيارن جو مدار آهي جن جي مدار سيارو 1 جي مدار ۽ سيارو 2 جي مدار جي وچ ۾ واقع آهن، سج جي ويجهو ترتيب ڏنل آهي. فنڪشن کي هڪ خالي ٽپل واپس ڪرڻ گهرجي جيڪڏهن سيارو 1 يا سيارو 2 صحيح سيارو نالا نه آهن. مثالن >>> bf((\"جپٽي\") ، (\"نيپٽن\")) (std::vector<std::string>{((std::string)) \"زحل\"، (std::string) \"اورانوس\"} (http://www.world.com/world/planet/planet/planet/planet_1_1_{http://www.world.com/planet_1_1_std_planet_2_string} (http://www.world.com/world.com/planet_string_string_string_string_{http://www.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.community.\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};\n    }\n\n    int index1 = std::distance(planets.begin(), it1);\n    int index2 = std::distance(planets.begin(), it2);\n\n    if (index1 == index2) {\n        return {};\n    }\n\n    int start = std::min(index1, index2) + 1;\n    int end = std::max(index1, index2);\n\n    std::vector<std::string> result;\n    for (int i = start; i < end; ++i) {\n        result.push_back(planets[i]);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/149",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو جيڪو اسٽرنگ جي ويڪٽر کي پيرا ميٽر طور قبول ڪري ، ان مان اسٽرنگ کي خارج ڪري ٿو جنهن جي اڻ کٽ ڊيگهه آهي ، ۽ نتيجي ۾ ويڪٽر کي ترتيب ڏنل ترتيب سان موٽائي ٿو ، ويڪٽر هميشه اسٽرنگ جو ويڪٽر هوندو آهي ۽ ڪڏهن به انگن جو ويڪٽر نه هوندو آهي ، ۽ اهو شايد نقل ٿيل هجي. ويڪٽر جو حڪم هر لفظ جي ڊيگهه سان وڌڻ گهرجي ، ۽ توهان کي ويڪٽر کي انهي قاعدي سان ترتيب ڏيڻ گهرجي. جيڪڏهن ٻن لفظن جي ڊيگهه ساڳي آهي ، ويڪٽر کي الفابيٽ جي ترتيب سان ترتيب ڏيو. فنڪشن کي ترتيب ڏنل ترتيب ۾ اسٽرنگ جو ويڪٽر موٽڻ گهرجي. توهان فرض ڪري سگهو ٿا ته سڀني لفظن جي ڊيگهه ساڳي هوندي. مثال طور: >>> list_sort{\"}: \\\\ ({\"}: \\\\ ({\"}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (}: \\\\ (} \\\\ (}: \\\\ ()) \\\\ (\\\\) \\\\ (\\\\) \\\\ (\\\\) \\\\ (\\\\) \\\\ (\\\\) \\\\ (\\\\) \\\\ (\\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\ (\\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\) \\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\) \\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\) \\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\) \\\\) \\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\) \\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\) \\\\) \\\\ (\\\\) \\\\) \\\\ (\\\\) \\\\) \\\\) \\\\ (\\\\)\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> even_length_strings;\n    for (const std::string& s : lst) {\n        if (s.length() % 2 == 0) {\n            even_length_strings.push_back(s);\n        }\n    }\n\n    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n\n    return even_length_strings;\n}",
        "test": "}\nint main() {\n    auto candidate = sorted_list_sum;\n    assert(candidate((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"}))) == (std::vector<std::string>({(std::string)\"aa\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"school\", (std::string)\"AI\", (std::string)\"asdf\", (std::string)\"b\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"asdf\", (std::string)\"school\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"b\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"dcba\", (std::string)\"abcd\", (std::string)\"a\"}))) == (std::vector<std::string>({(std::string)\"abcd\", (std::string)\"dcba\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"b\", (std::string)\"c\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaa\", (std::string)\"bbbb\", (std::string)\"dd\", (std::string)\"cc\"}))) == (std::vector<std::string>({(std::string)\"cc\", (std::string)\"dd\", (std::string)\"aaaa\", (std::string)\"bbbb\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/150",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ سادي پروگرام جنهن کي x جي قيمت موٽائڻي آهي جيڪڏهن n هڪ پرائم نمبر هجي ۽ ٻي صورت ۾ y جي قيمت موٽائڻي آهي. مثال: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)\nlong x_or_y(long n, long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(long n) {\n    if (n <= 1) return false;\n    for (long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nlong x_or_y(long n, long x, long y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = x_or_y;\n    assert(candidate((7), (34), (12)) == (34));\n    assert(candidate((15), (8), (5)) == (5));\n    assert(candidate((3), (33), (5212)) == (33));\n    assert(candidate((1259), (3), (52)) == (3));\n    assert(candidate((7919), (-1), (12)) == (-1));\n    assert(candidate((3609), (1245), (583)) == (583));\n    assert(candidate((91), (56), (129)) == (129));\n    assert(candidate((6), (34), (1234)) == (1234));\n    assert(candidate((1), (2), (0)) == (0));\n    assert(candidate((2), (2), (0)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/151",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// انگن جي هڪ ويڪٽر ڏنو ويو آهي، ويڪٽر ۾ انگن جي چوڪين جو مجموعو واپس آڻيو جيڪي ڌار آهن. نمبرن کي نظرانداز ڪريو جيڪي منفي آهن يا انٽيگر نه آهن. >>> double_the_difference ((((std::vector<float>({(long) 1, (long) 3, (long) 2, (long) 0}))) (10) >>> double_the_difference ((((std::vector<float>{(long) -1, (long) -2, (long) 0}))) (0) >>> double_the_difference ((((std::vector<float>{(long) -9, (long) -2)))) (81) >>> double_the_difference ((((std::vector<float>{(long) -0)) (0) جيڪڏهن انپٽ ويڪٽر خالي آهي، 0 واپس آڻيو.\nlong double_the_difference(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong double_the_difference(std::vector<float> lst) {\n    long sum_of_squares = 0;\n    for (float num : lst) {\n        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {\n            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);\n        }\n    }\n    return sum_of_squares;\n}",
        "test": "}\nint main() {\n    auto candidate = double_the_difference;\n    assert(candidate((std::vector<float>())) == (0));\n    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));\n    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));\n    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));\n}\n"
    },
    {
        "task_id": "HumanEval/152",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مان سمجهان ٿو ته اسان سڀني کي اهو احساس ياد آهي جڏهن ڪنهن ڊگهي انتظار واري واقعي جو نتيجو آخرڪار knownاڻيو وڃي ٿو. توهان جي احساسن ۽ خيالن کي توهان انهي وقت ضرور نوٽ ڪرڻ ۽ موازنہ ڪرڻ جي قابل آهن. توهان جو ڪم اهو طئي ڪرڻ آهي ته ڇا هڪ شخص ڪيترن ئي ميچن جي نتيجن کي صحيح اندازو لڳايو آهي. توهان کي ٻه نمبر ۽ اندازن جا ٻه ويڪٽر ڏنا ويا آهن ، جتي هر انڊيڪس هڪ ميچ ڏيکاري ٿو. هڪ ئي ڊيگهه جو ويڪٽر واپس ڪريو ته هر اندازو ڪيترو پري هو. جيڪڏهن انهن صحيح اندازو لڳايو آهي ، قدر 0 آهي ، ۽ جيڪڏهن نه ، قدر اندازو ۽ اسکور جي وچ ۾ مطلق فرق آهي. مثال: compare >>> (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    std::vector<long> diff;\n    for (size_t i = 0; i < game.size(); ++i) {\n        diff.push_back(std::abs(game[i] - guess[i]));\n    }\n    return diff;\n}",
        "test": "}\nint main() {\n    auto candidate = compare;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));\n    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/153",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي هڪ ڪلاس جو نالو (هڪ اسٽرنگ) ۽ واڌارن جو هڪ ويڪٽر ڏنو ويندو. واڌارن کي ڪلاس ۾ اضافي ڪلاس لوڊ ڪرڻ لاءِ استعمال ڪيو ويندو. واڌ جي طاقت هن ريت آهي: CAP کي واڌاري جي نالي ۾ وڏن اکرن جو تعداد هجي، ۽ SM کي واڌاري جي نالي ۾ ننcaseن اکرن جو تعداد هجي، طاقت کي ڀا CAP - SM سان ڏنو ويندو آهي. توهان کي مضبوط واڌاري کي ڳولڻ گهرجي ۽ هن فارميٽ ۾ هڪ اسٽرنگ واپس ڪرڻ گهرجي: ClassName.StrongestExtensionName. جيڪڏهن ٻه يا وڌيڪ واڌاري هڪ ئي طاقت سان آهن، توهان کي اهو چونڊڻ گهرجي جيڪو ويڪٽر ۾ پهريون اچي ٿو. مثال طور ، جيڪڏهن توهان کي \"سلائس\" ڪلاس ۽ واڌارن جو هڪ ويڪٽر ڏنو ويو آهي: ['SEviviSliNGCes'، 'Cheese', 'StuFed'] پوءِ توهان کي 'Slices.SEviSliNGCes' واپس ڪرڻ گهرجي. 'SviSliNGCes'، 'myst::::myst::myst::SviSliNGCes::myst::st::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::myst::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::st::\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint calculate_strength(const std::string& extension) {\n    int cap_count = 0;\n    int sm_count = 0;\n    for (char c : extension) {\n        if (isupper(c)) {\n            cap_count++;\n        } else if (islower(c)) {\n            sm_count++;\n        }\n    }\n    return cap_count - sm_count;\n}\n\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    if (extensions.empty()) {\n        return class_name;\n    }\n\n    std::string strongest_extension = extensions[0];\n    int max_strength = calculate_strength(extensions[0]);\n\n    for (size_t i = 1; i < extensions.size(); ++i) {\n        int current_strength = calculate_strength(extensions[i]);\n        if (current_strength > max_strength) {\n            max_strength = current_strength;\n            strongest_extension = extensions[i];\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}",
        "test": "}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"}))) == (\"Sp.671235\"));\n}\n"
    },
    {
        "task_id": "HumanEval/154",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي 2 لفظ ڏنا ويا آهن. توهان کي موٽڻ جي ضرورت آهي سچ جيڪڏهن ٻيو لفظ يا ان جي ڪنهن به rotations پهرين لفظ ۾ هڪ substring آهي >>> cycpattern_check((\"abcd\"), (\"abd\")) (false) >>> cycpattern_check((\"hello\"), (\"ell\")) (true) >>> cycpattern_check((\"whassup\"), (\"psus\")) (false) >>> cycpattern_check((\"abab\"), (\"baa\")) (true) >>> cycpattern_(check\"efef\"), (\"eeff\") cy (false) >>> cycpattern_check((\"himens\"), (\"simen\") (true)\nbool cycpattern_check(std::string a, std::string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool cycpattern_check(std::string a, std::string b) {\n    if (b.empty()) {\n        return true;\n    }\n    if (a.length() < b.length()) {\n        return false;\n    }\n    for (int i = 0; i < b.length(); ++i) {\n        std::rotate(b.begin(), b.begin() + 1, b.end());\n        if (a.find(b) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = cycpattern_check;\n    assert(candidate((\"xyzw\"), (\"xyw\")) == (false));\n    assert(candidate((\"yello\"), (\"ell\")) == (true));\n    assert(candidate((\"whattup\"), (\"ptut\")) == (false));\n    assert(candidate((\"efef\"), (\"fee\")) == (true));\n    assert(candidate((\"abab\"), (\"aabb\")) == (false));\n    assert(candidate((\"winemtt\"), (\"tinem\")) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/155",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ عدد ڏنو ويو آهي. هڪ ٽپل موٽايو جنهن ۾ ترتيب سان برابر ۽ بي جوڙ انگن جو تعداد آهي. مثال: >>> even_odd_count((-12)) (std::make_tuple(1, 1)) >>> even_odd_count((123)) (std::make_tuple(1, 2)\nstd::tuple<long, long> even_odd_count(long num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<tuple>\n\nstd::tuple<long, long> even_odd_count(long num) {\n    long even_count = 0;\n    long odd_count = 0;\n    std::string s = std::to_string(std::abs(num));\n    for (char c : s) {\n        int digit = c - '0';\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_count;\n    assert(candidate((7)) == (std::make_tuple(0, 1)));\n    assert(candidate((-78)) == (std::make_tuple(1, 1)));\n    assert(candidate((3452)) == (std::make_tuple(2, 2)));\n    assert(candidate((346211)) == (std::make_tuple(3, 3)));\n    assert(candidate((-345821)) == (std::make_tuple(3, 3)));\n    assert(candidate((-2)) == (std::make_tuple(1, 0)));\n    assert(candidate((-45347)) == (std::make_tuple(2, 3)));\n    assert(candidate((0)) == (std::make_tuple(1, 0)));\n}\n"
    },
    {
        "task_id": "HumanEval/156",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ مثبت انٽيگر ڏنو، ان جي رومن عددي برابر کي هڪ اسٽرنگ طور حاصل ڪريو، ۽ ان کي ننڍي اکرن ۾ موٽايو. پابنديون: 1 <= num <= 1000 مثال: >>> int_to_mini_roman((19)) (\"xix\") >>> int_to_mini_roman((152)) (\"clii\") >>> int_to_mini_roman((426)) (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            roman += pair.second;\n            number -= pair.first;\n        }\n    }\n    return roman;\n}",
        "test": "}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
    },
    {
        "task_id": "HumanEval/157",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ مثلث جي ٽن پاسن جي ڊيگهه ڏني وئي. جيڪڏهن ٽن پاسن هڪ صحيح زاويه واري مثلث ٺاهيو ته صحيح موٽايو، ٻي صورت ۾ غلط. هڪ صحيح زاويه وارو مثلث هڪ مثلث آهي جنهن ۾ هڪ زاويه صحيح زاويه يا 90 درجا آهي. مثال: >>> right_angle_triangle((3), (4), (5)) (true) >>> right_angle_triangle(1), (2), (3)) (false)\nbool right_angle_triangle(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool right_angle_triangle(long a, long b, long c) {\n    std::vector<long> sides = {a, b, c};\n    std::sort(sides.begin(), sides.end());\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);\n}",
        "test": "}\nint main() {\n    auto candidate = right_angle_triangle;\n    assert(candidate((3), (4), (5)) == (true));\n    assert(candidate((1), (2), (3)) == (false));\n    assert(candidate((10), (6), (8)) == (true));\n    assert(candidate((2), (2), (2)) == (false));\n    assert(candidate((7), (24), (25)) == (true));\n    assert(candidate((10), (5), (7)) == (false));\n    assert(candidate((5), (12), (13)) == (true));\n    assert(candidate((15), (8), (17)) == (true));\n    assert(candidate((48), (55), (73)) == (true));\n    assert(candidate((1), (1), (1)) == (false));\n    assert(candidate((2), (2), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/158",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هڪ فنڪشن لکو جيڪو اسٽرنگ جي ويڪٽر کي قبول ڪري. ويڪٽر ۾ مختلف لفظ آهن. لفظ کي وڌ کان وڌ منفرد اکرن سان واپس ڪريو. جيڪڏهن گهڻن اسٽرنگن ۾ وڌ کان وڌ منفرد اکرن جو تعداد آهي ، اهو واپس ڪريو جيڪو لڪسيگرافڪ ترتيب ۾ پهريون اچي ٿو. >>> find_max((std::vector<std::string>({(std::string) \"name\", (std::string) \"of\", (std::string) \"string\"}))) (\"string\") >>> find_max{(std::vector<std::string>({(std::string) \"name\", (std::string) \"enam\", (std::string) \"game\"} (\"enam\")))) >>> find_max{(std::vector<std>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::string find_max(std::vector<std::string> words) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint count_unique_chars(const std::string& s) {\n    std::set<char> unique_chars;\n    for (char c : s) {\n        unique_chars.insert(c);\n    }\n    return unique_chars.size();\n}\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) {\n        return \"\";\n    }\n\n    std::string max_unique_word = words[0];\n    int max_unique_count = count_unique_chars(words[0]);\n\n    for (size_t i = 1; i < words.size(); ++i) {\n        int current_unique_count = count_unique_chars(words[i]);\n        if (current_unique_count > max_unique_count) {\n            max_unique_count = current_unique_count;\n            max_unique_word = words[i];\n        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {\n            max_unique_word = words[i];\n        }\n    }\n    return max_unique_word;\n}",
        "test": "}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"}))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
    },
    {
        "task_id": "HumanEval/159",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان هڪ بکيو خرگوش آهيو، ۽ توهان اڳ ۾ ئي گاجر جي هڪ خاص تعداد کائي ويا آهن، پر هاڻي توهان جي ڏينهن جي ڀاڄين کي مڪمل ڪرڻ لاء وڌيڪ گاجر کائڻ جي ضرورت آهي. توهان کي هڪ vector موٽڻ گهرجي [جي کائڻ کان پوء کائي گاجر جي ڪل تعداد، گاجر جي تعداد ۾ توهان جي ڀاڄين کان پوء ڇڏي ] جيڪڏهن نه ڪافي باقي گاجر آهن، توهان سڀ باقي گاجر کائي ويندا، پر اڃا تائين بکيو ٿي ويندي. مثال: >>> کائڻ ((((5) ، (6), (10)) (std:: vector<long>{(() 11، (long) 4)) >>> کائڻ (((4) ، (8), (9)) (std:: vector<long>{() 12، ( (1})) کائڻ (((1) ، (10), (10)) (std:: vector<long>{() 11، (long)) >>> (((0)) ، (11)) ، (((5)) (std:: vector<<long>{) 7، (long)) @ @ توهان جي ضرورت آهي ته کائڻ جي باقي گاجر جي تعداد ۾: 1000 * 0 = انٽيجري جي تعداد ۾ موجود آهي: 1000 * ٽريٽر = = = 1000 * ٽريٽر = = 1000 * ٽريٽر = 1000 * = 1000 *\nstd::vector<long> eat(long number, long need, long remaining) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = 0;\n    long left = remaining;\n    long to_eat = need;\n\n    if (left >= to_eat) {\n        eaten = to_eat;\n        left -= to_eat;\n    } else {\n        eaten = left;\n        left = 0;\n    }\n\n    return {(long)number + eaten, left};\n}",
        "test": "}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
    },
    {
        "task_id": "HumanEval/160",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ٻه ويڪٽر آپريٽر ۽ آپريٽر ڏنو ويو آهي. پهريون ويڪٽر بنيادي جبر جا آپريشن آهن، ۽ ٻيو ويڪٽر انٽيگرز جو ويڪٽر آهي. ڏنل ٻن ويڪٽرز کي الجبر جي اظهار جي تعمير لاءِ استعمال ڪريو ۽ هن اظهار جي تشخيص واپس ڪريو. بنيادي جبر جا آپريشن: جمع (+) - گھٹائي (-) - ضرب (*) فرش ڊويزن ( //) - ايڪسپوننٽيشن (**) مثال: آپريٽر['+'، '*'، '-'] ويڪٽر = [2, 3, 4, 5] نتيجو = 2 + 3 * 4 - 5 => نتيجو = 9 نوٽ: آپريٽر ويڪٽر جي ڊيگهه آپريٽر ويڪٽر جي ڊيگهه جي برابر آهي. آپريٽر ويڪٽر گهٽ ۾ گهٽ هڪ آهي، ۽ آپريٽر ويڪٽر ۾ گهٽ ۾ گهٽ ٻه آپريٽر آهن.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    std::vector<long> current_operand = operand;\n    std::vector<std::string> current_operator = op;\n\n    auto apply_op = [&](long a, long b, const std::string& o) {\n        if (o == \"+\") return a + b;\n        if (o == \"-\") return a - b;\n        if (o == \"*\") return a * b;\n        if (o == \"//\") return a / b;\n        if (o == \"**\") return static_cast<long>(pow(a, b));\n        return 0L; // Should not happen\n    };\n\n    std::vector<std::string> precedence1 = {\"**\"};\n    std::vector<std::string> precedence2 = {\"*\", \"//\"};\n    std::vector<std::string> precedence3 = {\"+\", \"-\"};\n\n    auto evaluate = [&](const std::vector<std::string>& prec) {\n        size_t i = 0;\n        while (i < current_operator.size()) {\n            bool found = false;\n            for (const auto& o : prec) {\n                if (current_operator[i] == o) {\n                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);\n                    current_operand.erase(current_operand.begin() + i + 1);\n                    current_operator.erase(current_operator.begin() + i);\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                i++;\n            }\n        }\n    };\n\n    evaluate(precedence1);\n    evaluate(precedence2);\n    evaluate(precedence3);\n\n    return current_operand[0];\n}",
        "test": "}\nint main() {\n    auto candidate = do_algebra;\n    assert(candidate((std::vector<std::string>({(std::string)\"**\", (std::string)\"*\", (std::string)\"+\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));\n    assert(candidate((std::vector<std::string>({(std::string)\"+\", (std::string)\"*\", (std::string)\"-\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));\n    assert(candidate((std::vector<std::string>({(std::string)\"//\", (std::string)\"*\"})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));\n}\n"
    },
    {
        "task_id": "HumanEval/161",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توهان کي هڪ اسٽرنگ s ڏني وئي آهي. جيڪڏهن s[i] هڪ اکر آهي ، ان جي ڪيس کي هيٺئين کان مٿي يا مٿي کان مٿي ڪريو ، ٻي صورت ۾ ان کي برقرار رکو. جيڪڏهن اسٽرنگ ۾ ڪوبه اکر نه آهي ، اسٽرنگ کي ريورس ڪريو. فنڪشن کي نتيجي واري اسٽرنگ واپس ڪرڻ گهرجي. مثال >>> حل ڪريو ((((\"1234\")) (\"4321\") >>> حل ڪريو (((\"ab\")) (\"AB\") >>> حل ڪريو (((\"#a@C\")) (\"#A@c\")\nstd::string solve(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (has_letter) {\n        for (char& c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    } else {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((\"AsDf\")) == (\"aSdF\"));\n    assert(candidate((\"1234\")) == (\"4321\"));\n    assert(candidate((\"ab\")) == (\"AB\"));\n    assert(candidate((\"#a@C\")) == (\"#A@c\"));\n    assert(candidate((\"#AsdfW^45\")) == (\"#aSDFw^45\"));\n    assert(candidate((\"#6@2\")) == (\"2@6#\"));\n    assert(candidate((\"#$a^D\")) == (\"#$A^d\"));\n    assert(candidate((\"#ccc\")) == (\"#CCC\"));\n}\n"
    },
    {
        "task_id": "HumanEval/162",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// جيڪڏهن 'text' خالي آهي ته None موٽايو. >>> string_to_md5((\"هيلو ورلڊ\")) \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include <optional>\n\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\n\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    std::stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n    return ss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_to_md5;\n    assert(candidate((\"Hello world\")) == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert(candidate((\"\")) == std::nullopt);\n    assert(candidate((\"A B C\")) == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert(candidate((\"password\")) == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n"
    },
    {
        "task_id": "HumanEval/163",
        "nl": "snd_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ٻه مثبت انٽيگرز a ۽ b ڏنو ويو ، a ۽ b جي وچ ۾ به انگن اکرن کي موٽايو ، وڌندڙ ترتيب ۾. مثال طور: >>> generate_integers (((2) ، (8)) (std::vector<long> (((long) 2 ، (long) 4 ، (long) 6 ، (long) 8)) >>> generate_integers (((8) ، (2)) (std::vector<long> (((long) 2 ، (long) 4 ، (long) 6 ، (long) 8)) >>> generate_integers (((10) ، (14)) (std::vector<long> ((())\nstd::vector<long> generate_integers(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long start = std::min(a, b);\n    long end = std::max(a, b);\n    for (long i = start; i <= end; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = generate_integers;\n    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((17), (89)) == (std::vector<long>()));\n}\n"
    }
]