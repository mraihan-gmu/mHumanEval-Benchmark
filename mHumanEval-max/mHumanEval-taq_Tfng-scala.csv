task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⴱⴰⵔⴰⵣ ⵏ ⵓⵙⵙⵉⵔⴰ    //ⵔⵣⵣⵓ ⴳ ⵡⴰⵏⴰⵡ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵀⴰⵜ ⵉⵍⵍⴰ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⵉⵏ ⵢⵓⵙⵉⵏ ⵉⵏⴳⵔⵙⵏ ⵓⴳⴳⴰⵔ ⵏ     // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)), (0.5f))
    // (false)
    // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))
    // (true)
    def hasCloseElements(numbers : List[Float], threshold : Float) : Boolean = {
","def hasCloseElements(numbers: List[Float], threshold: Float): Boolean = {
      val sortedNumbers = numbers.sorted
      for (i <- 1 until sortedNumbers.length) {
        if (abs(sortedNumbers(i) - sortedNumbers(i - 1)) < threshold) {
          return true
        }
      }
      false
    }
}","    }
    def main(args: Array[String]) = {
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.3f)) == (true));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.05f)) == (false));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.95f)) == (true));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.8f)) == (false));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.1f)) == (true));
    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (1.0f)) == (true));
    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (0.5f)) == (false));
    }

}
"
HumanEval_1,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵥⵎ ⴽⵔⴰ ⵏ ⵡⴰⵏⵙⴰ ⴳ ⵜⵣⵍⵉⵜ ⵏ ⵓⵙⴽⵛⵎ.    //ⵜⴰⵔⵓⴱⴱⴰ ⵉⴱⴹⴰⵏ ⵜⵜⵓⵙⵎⵙⴰⵙⴰⵏ (ⵢⴰⵜⵜⵓⵢ ⵏ ⴽⵓ ⵜⴰⴱⵔⴰⵜⴰ ⵉⵕⵥⵎⵏ ⵉⵜⵜⵓⵙⵎⵓⵏ ⵙ ⵜⵖⴰⵔⴰⵙⵜ ⵉⵅⵚⵚⴰⵏ) ⴷ ⵓⵔ ⵜⵜⵓⵙⵎⵓⵏ ⴳ ⵢⴰⵏ     //ⵔⴱⴹⵉ ⵏ ⵜⵔⴰⴱⴱⵓⵜ ⴰⴷ ⵖⵔ ⵜⵉⴼⵔⵉⵙⵉⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷ ⵜⵓⵣⵔⵉ ⵏ ⵜⵍⴳⴰⵎⵜ ⵏ ⵡⵉⵏⵏⴰ ⵉⵍⵍⴰⵏ.     //ⴷⴰ ⵉⵜⵜⵓⵙⴽⵛⵎ ⵓⵡⵡⵓⵔ ⴰⴷ ⴳ ⵢⴰⵜ ⵜⵉⴼⵔⴽⵜ ⴳ ⵍⵍⴰⵏⵜ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵏ ⵜⴱⵕⴰⵏⴽⵉⵙⵉⵏ ⵉⵜⵜⵓⵙⵎⵓⵏⵏ. ⴰⵡⵜⵜⴰⵙ ⵏⵏⴽ ⵉⴳⴰ ⴰⴷ     // >>> separateParenGroups((""( ) (( )) (( )( ))""))
    // (List[String](""()"", ""(())"", ""(()())""))
    def separateParenGroups(paren_string : String) : List[String] = {
","def separateParenGroups(paren_string: String): List[String] = {
    val result = ListBuffer[String]()
    val sanitizedInput = paren_string.replaceAll(""\\s"", """")
    var balance = 0
    var currentGroup = new StringBuilder()

    for (char <- sanitizedInput) {
        currentGroup.append(char)
        if (char == '(') balance += 1
        else if (char == ')') balance -= 1

        if (balance == 0 && currentGroup.nonEmpty) {
            result += currentGroup.toString()
            currentGroup = new StringBuilder()
        }
    }

    result.toList
}","    }
    def main(args: Array[String]) = {
    assert(separateParenGroups((""(()()) ((())) () ((())()())"")).equals((List[String](""(()())"", ""((()))"", ""()"", ""((())()())""))));
    assert(separateParenGroups((""() (()) ((())) (((())))"")).equals((List[String](""()"", ""(())"", ""((()))"", ""(((())))""))));
    assert(separateParenGroups((""(()(())((())))"")).equals((List[String](""(()(())((())))""))));
    assert(separateParenGroups((""( ) (( )) (( )( ))"")).equals((List[String](""()"", ""(())"", ""(()())""))));
    }

}
"
HumanEval_2,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵉⵜⵓⵔ ⵏ ⵓⴳⵣⵣⵓⵎ ⴰⵎⵔⴰⵡ ⵏ ⵡⵓⵟⵟⵓⵏ.    //(ⴰⵛⵔⵓⵜ ⵏ ⵓⵛⵔⴰⵉ ⴰⵀⴰ ⵉⴳⴰ ⴰⵎⵥⵥⵢⴰⵏ ⵙⴳ 1).    //ⴷ ⵓⴳⵣⵣⵓⵎ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ (ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⵉⵎⵥⵥⵉⵢⵏ ⵙⴳ ⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ) ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⵔⴰⵡⵏ     //ⵉⵖ ⵏⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ, ⵏⵣⵎⵔ ⴰⴷ ⵏⵙⴱⴹ     // >>> truncateNumber((3.5f))
    // (0.5f)
    def truncateNumber(number : Float) : Float = {
","val integerPart = number.floor
        val decimalPart = number - integerPart
        decimalPart.toFloat
    }
}","    }
    def main(args: Array[String]) = {
    assert(truncateNumber((3.5f)) == (0.5f));
    assert(truncateNumber((1.25f)) == (0.25f));
    assert(truncateNumber((123.0f)) == (0.0f));
    }

}
"
HumanEval_3,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴳ ⵜⵏⵇⵇⵉⴹⵜ ⴰⴷ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔ ⵜⵎⵔⵙⵜ ⵜⵉⴷⵜ. ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔ ⵜⵉⴷⵜ.    //ⴰⵛⴰⵍ ⵓⴰⵏ ⵏⴻⴱⵓⵍⴰⵜⴻ ⵜⴰⵏ ⵓⵉⵏ ⴰⴾⴰⵍ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⴻⵜ ⴰⵂⴰⵏⴰⵜ ⴰⵙⵉⴾⵏⴻ ⵏ ⴰⵙⵉⴾⵏⴻ ⵏ ⴰⴾⴰⵍ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ    //ⴰⵜⵓⴰⴾⴼⴰ-ⴷ ⴰⵍⴾⴰⴷ ⵏ ⴰⵍⵆⵉⴷⵎⴰⵜⵢⵏ ⵏ ⴰⵗⴰⵣⴰⵏ ⴷ ⵢⴼⵢⵙ ⴷⴰⵗ ⴰⵛⴰⵆⵉⵍ ⵏ ⴱⴰⵏⴾ ⵙ ⵉⵙⵙⵉⵏⵜⴰ ⵙ    // >>> belowZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (false)
    // >>> belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong)))
    // (true)
    def belowZero(operations : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def belowZero(operations: List[Long]): Boolean = {
    var balance: Long = 0
    for (operation <- operations) {
      balance += operation
      if (balance < 0) {
        return true
      }
    }
    false
  }

  def main(args: Array[String]): Unit = {
    println(belowZero(List(1L, 2L, 3L)))         // false
    println(belowZero(List(1L, 2L, -4L, 5L)))    // true
  }
}","    }
    def main(args: Array[String]) = {
    assert(belowZero((List[Long]())) == (false));
    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -3l.toLong, 1l.toLong, 2l.toLong, -3l.toLong))) == (false));
    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong))) == (true));
    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (false));
    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -5l.toLong))) == (true));
    assert(belowZero((List[Long](1l.toLong, -2l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (true));
    }

}
"
HumanEval_4,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //MAD=ⴰⵎⵎⴰⵜⵜⴰⵢ. x - x_ⵎⵉⵏ.    //ⴰⵛⵔⵓⵜ ⴷ ⵜⵉⵜⴱⴰⵈⴻⵜ ⵜⴰⵏ ⴰⵎⵎⴰⵙ (ⴰⵎⴰⵣⴰⵔⴰⵏ ⴷⴰⵗ ⴰⵍⵓⴰⵈ ⵓⴻⵏ):    //ⴰⵎⵣⴰⵔⴰⵢ ⵏ ⵓⵖⵣⵓⵔⴰⵏ ⴰⵎⵏⵉⴳ ⵉⴳⴰ ⴰⵎⵣⴰⵔⴰⵢ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ ⴳⵔ ⴽⵓ     //ⴰⵂⴰⵏⴷⴰⴶ ⵏ ⴰⵎⵎⴰⵙ ⵏ ⴷⴰⵜⴰ ⵙⵢⵜ ⵓⵢⵏ    //ⵉ ⵜⵍⴳⴰⵎⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵙⴽⵛⵛⵓⵎⵏ, ⵙⵏⵓⵎⵎⵍ ⴰⵎⵏⵣⴰⵢ ⴰⵎⵙⵜⴰⵔ     // >>> meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat)))
    // (1.0f)
    def meanAbsoluteDeviation(numbers : List[Float]) : Float = {
","val mean = numbers.sum / numbers.size
    val deviations = numbers.map(num => math.abs(num - mean))
    val mad = deviations.sum / deviations.size
    mad
  }
}","    }
    def main(args: Array[String]) = {
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat))) == (0.5f));
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))) == (1.0f));
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))) == (1.2f));
    }

}
"
HumanEval_5,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //""ⴰⴷ ⵢⵓⵛⴽⴰⴷ ⵓⵟⵟⵓⵏ "" ⴷⵓⵍⵉⵎⵉⵜⵔ "" ⴳⵔ ⴽⵓ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴷⴰⵢⵏ ⵏ ⵜⵍⴳⴰⵎⵜ ⵏ ⵓⴽⵛⵛⵓⵎ ""ⴹⵓⵍⵉⵎⵉⵜⵔ""    // >>> intersperse((List[Long]()), (4l))
    // (List[Long]())
    // >>> intersperse((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (4l))
    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))
    def intersperse(numbers : List[Long], delimeter : Long) : List[Long] = {
","if (numbers.isEmpty) {
        List()
      } else {
        numbers.init.flatMap(n => List(n, delimeter)) :+ numbers.last
      }
    }
}","    }
    def main(args: Array[String]) = {
    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));
    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));
    assert(intersperse((List[Long](2l.toLong, 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));
    }

}
"
HumanEval_6,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ (() (()) ⵖⵓⵔⵙ ⵙⵉⵏ ⵉⵙⵡⵉⵔⵏ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⴳ ⵜⵉⵣⵉ ⵏⵏⴰ ⴳ ⵖⵓⵔ ((())) ⴽⵕⴰⴹ.     //ⵉ ⴽⵓ ⵜⴰⵔⴰⴱⴱⵓⵜ, ⵙⵏⵓⵍⴼⵓ ⴰⵙⵡⵉⵔ ⵏ ⵓⴱⵔⴰⵏⵜⵉⵙ ⵉⴳⴳⵓⵜⵏ.    //ⴷⴰ ⵉⵜⵜⵓⵙⴽⴰⵔ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵡⵓⵔⵉ ⴰⴷ ⵙ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵉ ⵜⴱⵕⴰⵏⴽⵉⵙⵜⵉⵏ ⵉⵜⵜⵓⵙⴱⴹⴰⵏ ⵙ ⵉⵎⵣⴰⵔⴰⵢⵏ.    // >>> parseNestedParens((""(()()) ((())) () ((())()())""))
    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))
    def parseNestedParens(paren_string : String) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def parseNestedParens(paren_string: String): List[Long] = {
    paren_string.split("" "").toList.map { group =>
      var maxDepth = 0
      var currentDepth = 0
      group.foreach {
        case '(' => 
          currentDepth += 1
          maxDepth = max(maxDepth, currentDepth)
        case ')' => 
          currentDepth -= 1
      }
      maxDepth.toLong
    }
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    val result = parseNestedParens(""(()()) ((())) () ((())()())"")
    println(s""Result: ${result.mkString("", "")}"")
  }
}","    }
    def main(args: Array[String]) = {
    assert(parseNestedParens((""(()()) ((())) () ((())()())"")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    assert(parseNestedParens((""() (()) ((())) (((())))"")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(parseNestedParens((""(()(())((())))"")).equals((List[Long](4l.toLong))));
    }

}
"
HumanEval_7,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴷⴰ ⵉⵜⵜⵓⵙⴼⵉⵍⵍ ⵓⵎⵙⴳⵓⵏ ⵏ ⵉⵙⵉⴹⵏⵏ ⵏ ⵓⵙⴽⵛⵎ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵙⵉⴹⵏ ⴰⵎⴷⴷⴰⴷ     // >>> filterBySubstring((List[String]()), (""a""))
    // (List[String]())
    // >>> filterBySubstring((List[String](""abc"", ""bacd"", ""cde"", ""array"")), (""a""))
    // (List[String](""abc"", ""bacd"", ""array""))
    def filterBySubstring(strings : List[String], substring : String) : List[String] = {
","strings.filter(_.contains(substring))
    }
}","    }
    def main(args: Array[String]) = {
    assert(filterBySubstring((List[String]()), (""john"")).equals((List[String]())));
    assert(filterBySubstring((List[String](""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xxx"")).equals((List[String](""xxx"", ""xxxAAA"", ""xxx""))));
    assert(filterBySubstring((List[String](""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xx"")).equals((List[String](""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""))));
    assert(filterBySubstring((List[String](""grunt"", ""trumpet"", ""prune"", ""gruesome"")), (""run"")).equals((List[String](""grunt"", ""prune""))));
    }

}
"
HumanEval_8,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵓⵎⴹⴰⵏ ⵏ ⵓⴽⵙⵓⵎ ⴰⵣⴳⵏ ⴷ ⵓⵎⴹⴰⵏ ⵏ ⵓⴽⵙⵓⵎ ⴰⵣⴳⵏ ⴷ 1.    //ⵉ ⵓⵙⵎⵉⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⵜⴰⴱⵍⵜ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵖⵣⵓⵔⴰⵏ ⴷ ⵓⵙⵎⵉⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵙⵎⵉⵍ.    // >>> sumProduct((List[Long]()))
    // ((0l, 1l))
    // >>> sumProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // ((10l, 24l))
    def sumProduct(numbers : List[Long]) : Tuple2[Long, Long] = {
","def sumProduct(numbers: List[Long]): (Long, Long) = {
        val sum = numbers.sum
        val product = numbers.foldLeft(1L)(_ * _)
        (sum, product)
    }

    def main(args: Array[String]): Unit = {
        // Test examples
        println(sumProduct(List[Long]())) // (0L, 1L)
        println(sumProduct(List[Long](1L, 2L, 3L, 4L))) // (10L, 24L)
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumProduct((List[Long]())).equals(((0l, 1l))));
    assert(sumProduct((List[Long](1l.toLong, 1l.toLong, 1l.toLong))).equals(((3l, 1l))));
    assert(sumProduct((List[Long](100l.toLong, 0l.toLong))).equals(((100l, 0l))));
    assert(sumProduct((List[Long](3l.toLong, 5l.toLong, 7l.toLong))).equals(((15l, 105l))));
    assert(sumProduct((List[Long](10l.toLong))).equals(((10l, 10l))));
    }

}
"
HumanEval_9,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴳ ⵓⴹⴼⴼⵉⵕ.    //ⵙⴳ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵇⵇⵓⵔⵏ ⵉⵜⵜⵢⴰⴼⴰⵏ ⴰⵔ ⵜⵉⵣⵉ ⵉⵜⵜⵢⴰⴼⴰⵏ     // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))
    def rollingMax(numbers : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def rollingMax(numbers: List[Long]): List[Long] = {
        var maxSoFar = Long.MinValue
        numbers.map { num =>
            maxSoFar = max(maxSoFar, num)
            maxSoFar
        }
    }
}","    }
    def main(args: Array[String]) = {
    assert(rollingMax((List[Long]())).equals((List[Long]())));
    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));
    }

}
"
HumanEval_10,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //- ⴰⴷ ⵢⴰⵣⴰⵔ ⵙ ⵜⴳⵉⵔⴰ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵜⵣⵡⴰⵔⵜ ⵏⵏⴰ ⵉⵜⵜⴰⴷⴼⵏ ⴷⴰⵜ ⵏ ⵓⴷⴼⵍ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ.    //- ⴰⵔⴰⵎ ⴰⴷ ⵏⴰⴼ ⵜⵉⵣⵉ ⵜⴰⵖⵣⵉⴼⵜ ⵏ ⵜⴱⵔⵉⴷⵜ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏⵏⴰ ⵉⴳⴰⵏ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ.    //ⵜⴰⵡⵏⴳⵉⵎⵜ ⵏ ⴰⵍⴳⵓⵔⵉⵜⵎ ⵜⴳⴰ ⵜⴰⴼⵔⴰⵔⵜ:     //ⴹⴼⵔ ⴰⵎⵣⵔⵓⵢ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵙ ⵜⵉⴼⵉⵏⴰⵖ.    // >>> makePalindrome((""""))
    // ("""")
    // >>> makePalindrome((""cat""))
    // (""catac"")
    // >>> makePalindrome((""cata""))
    // (""catac"")
    def makePalindrome(string : String) : String = {
","def makePalindrome(string: String): String = {
    // Helper function to check if a string is a palindrome
    def isPalindrome(s: String): Boolean = s == s.reverse

    // Find the longest palindromic suffix
    var endIndex = string.length
    while (endIndex > 0 && !isPalindrome(string.substring(endIndex - 1))) {
      endIndex -= 1
    }

    // Extract the non-palindromic prefix
    val prefix = string.substring(0, endIndex - 1)

    // Append the reverse of the prefix to form the shortest palindrome
    string + prefix.reverse
  }
}","    }
    def main(args: Array[String]) = {
    assert(makePalindrome(("""")).equals(("""")));
    assert(makePalindrome((""x"")).equals((""x"")));
    assert(makePalindrome((""xyz"")).equals((""xyzyx"")));
    assert(makePalindrome((""xyx"")).equals((""xyx"")));
    assert(makePalindrome((""jerry"")).equals((""jerryrrej"")));
    }

}
"
HumanEval_11,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴷⴰ ⵏⵙⴽⴰⵔ XOR ⴱⵉⵏⴰⵔⵉ ⵅⴼ ⵉⵙⴽⵛⵛⵓⵎⵏ ⴰⴷ ⴷ ⴷⴰ ⵏⵙⴽⵛⵎ ⵜⴰⵢⴰⴼⵓⵜ ⴰⵡⴷ ⵙ ⵜⴰⵍⵖⴰ.    //ⴳⴰⵏ ⵉⵏⴽⵛⵛⵓⵎⵏ ⵙⵏⴰⵜ ⵜⵣⵍⵖⴰ a ⴷ b ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ 1 ⴷ 0 ⵅⵙ.    // >>> stringXor((""010""), (""110""))
    // (""100"")
    def stringXor(a : String, b : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def stringXor(a: String, b: String): String = {
    (a zip b).map { case (charA, charB) => 
      if (charA == charB) '0' else '1'
    }.mkString
  }
}","    }
    def main(args: Array[String]) = {
    assert(stringXor((""111000""), (""101010"")).equals((""010010"")));
    assert(stringXor((""1""), (""1"")).equals((""0"")));
    assert(stringXor((""0101""), (""0000"")).equals((""0101"")));
    }

}
"
HumanEval_12,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ None ⴳ ⵡⴰⴷⴷⴰⴷ ⵏ ⵡⴰⵔⵔⴰ ⵏ ⵓⴽⵛⵛⵓⵎ ⵉⴳⴰⵏ ⵡⴰⴽⵓⵛ.    //ⵙⴳ ⵜⵍⴳⴰⵎⵜ ⵏ ⵜⵉⴼⵔⵉⵙⵉⵏ, ⵙⵙⴽⵛⵎ ⵜⵉⵣⵉ ⵜⴰⵖⵣⵉⴼⵜ. ⵙⵙⴽⵛⵎ ⵜⵉⵣⵉ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ ⴳ ⵡⴰⴷⴷⴰⴷ ⵏ ⴽⵉⴳⴰⵏ ⵏ     // >>> longest((List[String]()))
    // None
    // >>> longest((List[String](""a"", ""b"", ""c"")))
    // Some(""a"")
    // >>> longest((List[String](""a"", ""bb"", ""ccc"")))
    // Some(""ccc"")
    def longest(strings : List[String]) : Option[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Out of list of strings, return the longest one. Return the first one in case of multiple
    // strings of the same length. Return None in case the input list is empty.
    def longest(strings: List[String]): Option[String] = {
        if (strings.isEmpty) None
        else Some(strings.maxBy(_.length))
    }
}","    }
    def main(args: Array[String]) = {
    assert(longest((List[String]())).equals(None));
    assert(longest((List[String](""x"", ""y"", ""z""))).equals(Some(""x"")));
    assert(longest((List[String](""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""))).equals(Some(""zzzz"")));
    }

}
"
HumanEval_13,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵉⵜⵓⵔⵏ ⴰⵎⵟⵟⵓ ⴰⵎⵛⵛⵓⵔⴰⵔ ⴰⵎⵇⵔⴰⵏ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⴷ b     // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    def greatestCommonDivisor(a : Long, b : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Return a greatest common divisor of two integers a and b
    // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    def greatestCommonDivisor(a: Long, b: Long): Long = {
        if (b == 0) a else greatestCommonDivisor(b, a % b)
    }
}","    }
    def main(args: Array[String]) = {
    assert(greatestCommonDivisor((3l), (7l)) == (1l));
    assert(greatestCommonDivisor((10l), (15l)) == (5l));
    assert(greatestCommonDivisor((49l), (14l)) == (7l));
    assert(greatestCommonDivisor((144l), (60l)) == (12l));
    }

}
"
HumanEval_14,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵎⵙⵎⵉⵍ ⵏ ⴽⵓⵍⵍⵓ ⵉⵙⵏⴼⴰⵔⵏ ⵙⴳ ⵓⵥⵥⵉⵢⵏ ⴰⵔ ⵓⵣⵣⵉⵏⵏ ⵏ ⵜⵣⵍⵉⵜ ⵏ ⵓⵙⴽⵛⵎ     // >>> allPrefixes((""abc""))
    // (List[String](""a"", ""ab"", ""abc""))
    def allPrefixes(string : String) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return list of all prefixes from shortest to longest of the input string
  // >>> allPrefixes((""abc""))
  // (List[String](""a"", ""ab"", ""abc""))
  def allPrefixes(string: String): List[String] = {
    (1 to string.length).map(i => string.substring(0, i)).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(allPrefixes(("""")).equals((List[String]())));
    assert(allPrefixes((""asdfgh"")).equals((List[String](""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""))));
    assert(allPrefixes((""WWW"")).equals((List[String](""W"", ""WW"", ""WWW""))));
    }

}
"
HumanEval_15,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵙⵏⴼⵍⵓⵍ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵜⵜⵓⵙⵏⴱⴹⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ ⴳ ⵓⵎⵣⵡⴰⵔⵓ ⵙⴳ 0 ⴰⵔ n.    // >>> stringSequence((0l))
    // (""0"")
    // >>> stringSequence((5l))
    // (""0 1 2 3 4 5"")
    def stringSequence(n : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def stringSequence(n: Long): String = {
    (0L to n).mkString("" "")
  }
}","    }
    def main(args: Array[String]) = {
    assert(stringSequence((0l)).equals((""0"")));
    assert(stringSequence((3l)).equals((""0 1 2 3"")));
    assert(stringSequence((10l)).equals((""0 1 2 3 4 5 6 7 8 9 10"")));
    }

}
"
HumanEval_16,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴹⴰⵗ ⵜⴰⵔⵔⴰⵉⵜ, ⵙⴰⴾⵏⵢⴷ ⵉⵎⵎⵉⴾ ⵓⴰ ⵙ ⵉⵋⵋⴰ     // >>> countDistinctCharacters((""xyzXYZ""))
    // (3l)
    // >>> countDistinctCharacters((""Jerry""))
    // (4l)
    def countDistinctCharacters(string : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a string, find out how many distinct characters (regardless of case) does it consist of
  // >>> countDistinctCharacters((""xyzXYZ""))
  // (3l)
  // >>> countDistinctCharacters((""Jerry""))
  // (4l)
  def countDistinctCharacters(string: String): Long = {
    string.toLowerCase.toSet.size.toLong
  }
}","    }
    def main(args: Array[String]) = {
    assert(countDistinctCharacters(("""")) == (0l));
    assert(countDistinctCharacters((""abcde"")) == (5l));
    assert(countDistinctCharacters((""abcdecadeCADE"")) == (5l));
    assert(countDistinctCharacters((""aaaaAAAAaaaa"")) == (1l));
    assert(countDistinctCharacters((""Jerry jERRY JeRRRY"")) == (5l));
    }

}
"
HumanEval_17,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //""ⵂⴰⵛⴻ"" - ⴰⴾⴰⵜⴰⴱ ⵏ ⴰⴾⴾⵓⵣ, ⵉⴾⴾⴰ ⵜⴰⴾⴾⴰⵛⵜ    //""oⴰⵙⵂⴰⴾⵉ"" - ⴰⵛⵂⵔⵓⵜ ⵏ ⵏⵓⵜⵢ, ⵉⴾⴾⴰⵏ ⵙⴰⵏⴰⵜⴰⵜ ⵉⴾⵉⴰⵏ    //""o"" - ⴰⴾⴰⵜⴰⴱ ⴰⴾⴾⴰⵔⴰⵏ, ⵉⴾⴾⴰⵓⴰⵏ ⴰⴾⴾⵓⵣ     //ⴾⴰⵍⴰ ⵉⵍⴰⵏ ⴰⵍⴰⵗⵉ:    //ⵓⴰⵔ ⵢⵈⵢⵍ ⵓⴰ ⵢⵔⴰⵓⴰⵏ.    //ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴼⵙⵉ ⵜⴰⵡⴰⵍⵜ ⴰⴷ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴽⵙⵙⵉ ⵏⵏⴰ ⴷⴰ ⵉⵜⵜⴳⴳ ⴽⵓ ⵢⴰⵏ.    //ⴷⴰ ⵉⵜⵜⵓⵙⴽⵛⵎ ⵓⵏⴰⵎⴽ ⴰⴷ ⵙ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⵉⵙⵎⴷⵢⴰⵏ ⵉ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵏ ⵓⵥⴰⵡⴰⵏ ⵙ ⵜⵍⵖⴰ ⵉⵥⵍⵉⵏ ⵏ ASCII.    // >>> parseMusic((""o o| .| o| o| .| .| .| .| o o""))
    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))
    def parseMusic(music_string : String) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def parseMusic(music_string: String): List[Long] = {
    val noteMap = Map(""o"" -> 4L, ""o|"" -> 2L, "".|"" -> 1L)
    val notes = music_string.split("" "")
    notes.toList.map(note => noteMap(note))
  }
}","    }
    def main(args: Array[String]) = {
    assert(parseMusic(("""")).equals((List[Long]())));
    assert(parseMusic((""o o o o"")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(parseMusic(("".| .| .| .|"")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));
    assert(parseMusic((""o| o| .| .| o o o o"")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(parseMusic((""o| .| o| .| o o| o o|"")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));
    }

}
"
HumanEval_18,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵎⵙⵏ ⵎⵏⵏⴰⵡⵜ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵉⵖⵢ ⴰⴷ ⵢⵉⵍⵉ ⵓⵙⴽⴽⵉⵍ ⴰⵎⵏⴹⴰⵡ ⴳ ⵜⴽⵔⵔⴰⵢⵜ ⵜⴰⵢⵍⴰⵏⵜ. ⵔⵎⵙⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵙⴳⴷⴰⵍⵏ.    // >>> howManyTimes((""""), (""a""))
    // (0l)
    // >>> howManyTimes((""aaa""), (""a""))
    // (3l)
    // >>> howManyTimes((""aaaa""), (""aa""))
    // (3l)
    def howManyTimes(string : String, substring : String) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def howManyTimes(string: String, substring: String): Long = {
        if (substring.isEmpty || string.isEmpty) return 0L
        var count: Long = 0L
        for (i <- 0 to (string.length - substring.length)) {
            if (string.substring(i, i + substring.length) == substring) {
                count += 1
            }
        }
        count
    }

    // Test cases
    def main(args: Array[String]): Unit = {
        println(howManyTimes("""", ""a""))    // Output: 0
        println(howManyTimes(""aaa"", ""a"")) // Output: 3
        println(howManyTimes(""aaaa"", ""aa"")) // Output: 3
    }
}","    }
    def main(args: Array[String]) = {
    assert(howManyTimes((""""), (""x"")) == (0l));
    assert(howManyTimes((""xyxyxyx""), (""x"")) == (4l));
    assert(howManyTimes((""cacacacac""), (""cac"")) == (4l));
    assert(howManyTimes((""john doe""), (""john"")) == (1l));
    }

}
"
HumanEval_19,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴷⴰ ⵉⵜⵜⴰⵊⵊⵓ ⵜⵉⴼⵔⴽⵜ ⵙ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙⴳ ⵡⵉⵏ ⵉⵎⵥⵥⵉⵏ ⴰⵔ ⵡⵉⵏ ⵉⵎⵇⵇⵔⴰⵏ     //ⵉⵙⵜⴰⵢⵏ ⵉⵣⵔⴼⴰⵏ ⴳⴰⵏ ""ⵥⵕⵓ"", ""ⵢⴰⵏ"", "" ⵙⵉⵏ"", "" ⴽⵕⴰⴹ"", "" ⴽⴽⵓⵥ"", "" ⵙⵎⵎⵓⵙ"", ""ⵚⴹⵉⵚ"", "" ⵙⴰ"", "" ⵜⴰⵎ"" ⴷ "" ⵜⵥⴰ"".    //""ⵉⴽⴽⵉ ⵏ ⵓⴹⴼⵕ ⵉⴳⴰ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ ""ⴰⵎⵢⴰ"" ⴰⵔ ""ⵜⵥⴰ"".    // >>> sortNumbers((""three one five""))
    // (""one three five"")
    def sortNumbers(numbers : String) : String = {
","def sortNumbers(numbers: String): String = {
    val numberWords = Map(
      ""zero"" -> 0,
      ""one"" -> 1,
      ""two"" -> 2,
      ""three"" -> 3,
      ""four"" -> 4,
      ""five"" -> 5,
      ""six"" -> 6,
      ""seven"" -> 7,
      ""eight"" -> 8,
      ""nine"" -> 9
    )
    
    numbers.split("" "")
      .sortBy(word => numberWords(word))
      .mkString("" "")
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortNumbers(("""")).equals(("""")));
    assert(sortNumbers((""three"")).equals((""three"")));
    assert(sortNumbers((""three five nine"")).equals((""three five nine"")));
    assert(sortNumbers((""five zero four seven nine eight"")).equals((""zero four five seven eight nine"")));
    assert(sortNumbers((""six five four three two one zero"")).equals((""zero one two three four five six"")));
    }

}
"
HumanEval_20,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴹⴰⵔⴰⵜ ⵓⵢⵏ, ⴰⴷⴷⵉⴾⵓⴷ ⵏ ⵉⴾⵉ ⵏ ⴰⵍⴾⴰⴷ ⵓⴰ ⵙ ⵉⵋⵋⴰ ⴰⵓⵢⵏ (ⵉⴾⵉ ⵏ ⵉⴷⴷⵉⴾⵓⴷ ⵓⴰ ⵎⴰⴷⵔⵓⵉⵏ, ⵉⴾⵉ ⵏ ⵉⴷⴷⵉⴾⵓⴷ ⵓⴰ ⵎⴰⵈⵈⵓⵔⴰⵏ)    //ⵙⴳ ⵜⵍⴳⴰⵎⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⴳⵏ (ⵙ ⵜⵉⵖⵣⵉ ⵏ ⵙⵉⵏ ⵓⴳⴳⴰⵔ) ⵙⵜⴰⵢ ⴷ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⴰ ⵢⵓⴳⵔⵏ ⴽⵓ ⵢⴰⵏ     // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))
    // ((2.0f, 2.2f))
    // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))
    // ((2.0f, 2.0f))
    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def findClosestElements(numbers: List[Float]): (Float, Float) = {
    require(numbers.length >= 2, ""List must contain at least two elements"")
    val sortedNumbers = numbers.sorted

    var minDiff = Float.MaxValue
    var closestPair = (0.0f, 0.0f)

    for(i <- 0 until sortedNumbers.length - 1) {
      val currentDiff = abs(sortedNumbers(i) - sortedNumbers(i + 1))
      if(currentDiff < minDiff) {
        minDiff = currentDiff
        closestPair = (sortedNumbers(i), sortedNumbers(i + 1))
      }
    }
    
    closestPair
  }
}","    }
    def main(args: Array[String]) = {
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f, 4.0f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f, 2.2f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));
    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));
    }

}
"
HumanEval_21,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵢⴰ ⴰⵖⵢⴰⵏ ⵔⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵥⵥⵢⴰⵏ 0 ⴷ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵇⵔⴰⵏ ⵔⴰⴷ ⵉⴳ 1    //ⴹⴰⵔⴰⵜ ⴰⵙⵉⵍⵎⴰⴷ ⵏ ⴾⵓⴷⴷⵉⴾⵓⴷ ⵏ ⵉⵉⵉⴰⴷ (ⴷⴰⵗ ⵙⴰⵏⴰⵜⴰⵜ ⵂⴰⵔⴰⵜⴰⵏ), ⵉⵋⵋⵉ ⵏ ⵜⵔⵂⴰⵏⵙⴼⵓⵔⵎⵜ ⵜⴰⴾⴰⵔⴰⵜ ⵉ ⴾⵓⴷⴷⵉⴾⵓⴷ ⵓⵢⵏ,    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))
    // (List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))
    def rescaleToUnit(numbers : List[Float]) : List[Float] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given list of numbers (of at least two elements), apply a linear transform to that list,
  // such that the smallest number will become 0 and the largest will become 1
  def rescaleToUnit(numbers: List[Float]): List[Float] = {
    val minVal = numbers.min
    val maxVal = numbers.max
    numbers.map(num => (num - minVal) / (maxVal - minVal))
  }
}

// Usage example
object Main extends App {
  val numbers = List[Float](1.0f, 2.0f, 3.0f, 4.0f, 5.0f)
  val rescaledNumbers = Problem.rescaleToUnit(numbers)
  println(rescaledNumbers) // Output: List(0.0, 0.25, 0.5, 0.75, 1.0)
}","    }
    def main(args: Array[String]) = {
    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));
    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));
    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));
    assert(rescaleToUnit((List[Float](2.0f.toFloat, 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));
    assert(rescaleToUnit((List[Float](12.0f.toFloat, 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));
    }

}
"
HumanEval_22,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴷⴰ ⵉⵜⵜⵓⵙⴼⵉⵍⵍ ⵓⵎⵙⵎⵉⵍ ⵏ ⴽⵔⴰ ⵏ ⵡⴰⵜⵉⴳⵏ ⵏ ⵓⵙⴽⴰⵍⴰⵜⵓⵏ ⵖⴰⵙ ⵉ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ     // >>> filterIntegers((List[Any](""a"", 3.14f, 5l)))
    // (List[Long](5l.toLong))
    // >>> filterIntegers((List[Any](1l, 2l, 3l, ""abc"", Map[Long,Long](), List[Long]())))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    def filterIntegers(values : List[Any]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def filterIntegers(values: List[Any]): List[Long] = {
    values.collect {
      case l: Long => l
    }
  }

  def main(args: Array[String]): Unit = {
    println(filterIntegers(List[Any](""a"", 3.14f, 5l))) // List(5)
    println(filterIntegers(List[Any](1l, 2l, 3l, ""abc"", Map[Long, Long](), List[Long]()))) // List(1, 2, 3)
  }
}","    }
    def main(args: Array[String]) = {
    assert(filterIntegers((List[Any]())).equals((List[Long]())));
    assert(filterIntegers((List[Any](4l, Map[Long,Long](), List[Long](), 23.2f, 9l, ""adasd""))).equals((List[Long](4l.toLong, 9l.toLong))));
    assert(filterIntegers((List[Any](3l, ""c"", 3l, 3l, ""a"", ""b""))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong))));
    }

}
"
HumanEval_23,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵓⵜⵓⵔ ⵍⵓⵏⴳ ⵏ ⵜⵔⵉⵏⴳ     // >>> stringLength((""""))
    // (0l)
    // >>> stringLength((""abc""))
    // (3l)
    def strlen(string : String) : Long = {
","def strlen(string: String): Long = {
        string.length.toLong
    }
}","    }
    def main(args: Array[String]) = {
    assert(strlen(("""")) == (0l));
    assert(strlen((""x"")) == (1l));
    assert(strlen((""asdasnakj"")) == (9l));
    }

}
"
HumanEval_24,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵉ ⵓⵎⴹⴰⵏ n, ⴷⴼⵔ ⴰⵎⴹⴰⵏ ⴰⵅⴰⵜⴰⵔ ⵏⵏⴰ ⵉⵜⵜⴱⴹⵓⵏ n ⵙ ⵜⴰⵖⴹⴼⵜ, ⴷ ⵉⵎⵥⵥⵉⵏ ⵙⴳ n     // >>> largestDivisor((15l))
    // (5l)
    def largestDivisor(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // For a given number n, find the largest number that divides n evenly, smaller than n
    // >>> largestDivisor(15l)
    // (5l)
    def largestDivisor(n: Long): Long = {
        for (i <- (n / 2) to 1 by -1) {
            if (n % i == 0) return i
        }
        1L  // if no divisor found, return 1 (since 1 divides any number)
    }
}","    }
    def main(args: Array[String]) = {
    assert(largestDivisor((3l)) == (1l));
    assert(largestDivisor((7l)) == (1l));
    assert(largestDivisor((10l)) == (5l));
    assert(largestDivisor((100l)) == (50l));
    assert(largestDivisor((49l)) == (7l));
    }

}
"
HumanEval_25,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⵙⴽⵛⵎ ⴰⵎⵎ ⵓⵢⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴰⴽⴽⵡ     //ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⵜⵜⵓⵙⴽⴰⵔ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⴽⵓ ⵢⴰⵏ ⴳ ⵉⵎⴳⴳⵉⵜⵏ ⵏⵏⴰ ⵉⵜⵜⵓⵢⴰⴼⴰⵏ ⴳ ⵓⵙⴼⵙⵔ.    //ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵎⵙⵎⵉⵍ ⵏ ⵉⵎⴳⴳⵉⵜⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⵙⴳ ⵉⵎⵥⵥⵢⴰⵏ ⴰⵔ ⵉⵎⵇⵇⵔⴰⵏ.    // >>> factorize((8l))
    // (List[Long](2l.toLong, 2l.toLong, 2l.toLong))
    // >>> factorize((25l))
    // (List[Long](5l.toLong, 5l.toLong))
    // >>> factorize((70l))
    // (List[Long](2l.toLong, 5l.toLong, 7l.toLong))
    def factorize(n : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def factorize(n: Long): List[Long] = {
    var num = n
    val factors = ListBuffer[Long]()
    
    var i = 2L
    while (i <= sqrt(num).toLong) {
      while (num % i == 0) {
        factors += i
        num /= i
      }
      i += 1
    }
    
    if (num > 1) {
      factors += num
    }
    
    factors.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(factorize((2l)).equals((List[Long](2l.toLong))));
    assert(factorize((4l)).equals((List[Long](2l.toLong, 2l.toLong))));
    assert(factorize((8l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong))));
    assert(factorize((57l)).equals((List[Long](3l.toLong, 19l.toLong))));
    assert(factorize((3249l)).equals((List[Long](3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((185193l)).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((20577l)).equals((List[Long](3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((18l)).equals((List[Long](2l.toLong, 3l.toLong, 3l.toLong))));
    }

}
"
HumanEval_26,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵃⴹⵓ ⵜⴰⵍⵖⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵙ ⵓⴱⵔⵉⴷ ⵏ ⵓⵙⴽⵛⵎ.    //ⵙⴳ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⴽⵓⵍⵍⵓ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵉⵜⵜⵉⵍⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ.    // >>> removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 3l.toLong, 4l.toLong))
    def removeDuplicates(numbers : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def removeDuplicates(numbers: List[Long]): List[Long] = {
    val elementCount = numbers.groupBy(identity).mapValues(_.size)
    numbers.filter(num => elementCount(num) == 1)
  }

  def main(args: Array[String]): Unit = {
    val numbers = List[Long](1L, 2L, 3L, 2L, 4L)
    println(removeDuplicates(numbers)) // Output: List(1, 3, 4)
  }
}","    }
    def main(args: Array[String]) = {
    assert(removeDuplicates((List[Long]())).equals((List[Long]())));
    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 5l.toLong))));
    }

}
"
HumanEval_27,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    // ⵉ ⵜⵉⴼⵉⵏⴰⵖ, ⵙⵙⵓⵜⵍ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴷ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵇⵔⴰⵏⵏ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ.    // >>> flipCase((""Hello""))
    // (""hELLO"")
    def flipCase(string : String) : String = {
","def flipCase(string: String): String = {
    string.map {
      case c if c.isLower => c.toUpper
      case c if c.isUpper => c.toLower
      case c => c
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(flipCase(("""")).equals(("""")));
    assert(flipCase((""Hello!"")).equals((""hELLO!"")));
    assert(flipCase((""These violent delights have violent ends"")).equals((""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")));
    }

}
"
HumanEval_28,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵙⵎⵓⵏ ⵏ ⵜⵍⴳⴰⵎⵜ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴳ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ     // >>> concatenate((List[String]()))
    // ("""")
    // >>> concatenate((List[String](""a"", ""b"", ""c"")))
    // (""abc"")
    def concatenate(strings : List[String]) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    // Concatenate list of strings into a single string
    // >>> concatenate((List[String]()))
    // ("""")
    // >>> concatenate((List[String](""a"", ""b"", ""c"")))
    // (""abc"")
    def concatenate(strings: List[String]): String = {
        strings.mkString("""")
    }
}","    }
    def main(args: Array[String]) = {
    assert(concatenate((List[String]())).equals(("""")));
    assert(concatenate((List[String](""x"", ""y"", ""z""))).equals((""xyz"")));
    assert(concatenate((List[String](""x"", ""y"", ""z"", ""w"", ""k""))).equals((""xyzwk"")));
    }

}
"
HumanEval_29,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴷⴰ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵓⵎⵙⴰⵙⴰ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵓⵙⵙⴽⵛⵎ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⵉⵙⵙⵏⵜⵉⵢⵏ ⵙ ⵢⴰⵏ ⵓⵣⵡⵍ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ.    // >>> filterByPrefix((List[String]()), (""a""))
    // (List[String]())
    // >>> filterByPrefix((List[String](""abc"", ""bcd"", ""cde"", ""array"")), (""a""))
    // (List[String](""abc"", ""array""))
    def filterByPrefix(strings : List[String], prefix : String) : List[String] = {
","strings.filter(_.startsWith(prefix))
    }
}","    }
    def main(args: Array[String]) = {
    assert(filterByPrefix((List[String]()), (""john"")).equals((List[String]())));
    assert(filterByPrefix((List[String](""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xxx"")).equals((List[String](""xxx"", ""xxxAAA"", ""xxx""))));
    }

}
"
HumanEval_30,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵉⵜⵓⵔ ⵏⵢ ⵖⴰⵙ ⵉⵎⴹⴰⵏ ⵉⵎⵏⵏⵉⴳⵏ ⴳ ⵜⵍⴳⴰⵎⵜ.    // >>> getPositive((List[Long](-1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong)))
    // (List[Long](2l.toLong, 5l.toLong, 6l.toLong))
    // >>> getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))
    // (List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))
    def getPositive(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def getPositive(l: List[Long]): List[Long] = {
        l.filter(_ > 0)
    }
}","    }
    def main(args: Array[String]) = {
    assert(getPositive((List[Long](-1l.toLong, -2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](4l.toLong, 5l.toLong, 6l.toLong))));
    assert(getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))));
    assert(getPositive((List[Long](-1l.toLong, -2l.toLong))).equals((List[Long]())));
    assert(getPositive((List[Long]())).equals((List[Long]())));
    }

}
"
HumanEval_31,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵔ ⵉⵜⵜⴰⵍⵙ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵜⵉⵔⵡⵉ ⵎⴽ ⵓⵔ ⵉⴳⵉ.    // >>> isPrime((6l))
    // (false)
    // >>> isPrime((101l))
    // (true)
    // >>> isPrime((11l))
    // (true)
    // >>> isPrime((13441l))
    // (true)
    // >>> isPrime((61l))
    // (true)
    // >>> isPrime((4l))
    // (false)
    // >>> isPrime((1l))
    // (false)
    def isPrime(n : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if a given number is prime, and false otherwise.
  def isPrime(n: Long): Boolean = {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    var i = 5
    while (i * i <= n) {
      if (n % i == 0 || n % (i + 2) == 0) return false
      i += 6
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isPrime((6l)) == (false));
    assert(isPrime((101l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((13441l)) == (true));
    assert(isPrime((61l)) == (true));
    assert(isPrime((4l)) == (false));
    assert(isPrime((1l)) == (false));
    assert(isPrime((5l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((17l)) == (true));
    assert(isPrime((85l)) == (false));
    assert(isPrime((77l)) == (false));
    assert(isPrime((255379l)) == (false));
    }

}
"
HumanEval_33,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵉⵍⴰⵏ ⴰⵜⵉⴳ ⵏ ⵉⵙⴼⴽⴰ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ""ⵍ"", ⵎⴰⵛⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ.    //l' ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷ l ⴳ ⵉⵙⵏⵎⴰⵍⵏ ⵏⵏⴰ ⵓⵔ ⵉⵜⵜⵓⵣⵟⵟⴰⵢⵏ ⵙ ⴽⵕⴰⴹ, ⵎⴰⵛⴰ ⵜⵉⵏⵉⴳⵉⵏ ⵏⵏⵙ ⴳ ⵉⵙⵏⵎⴰⵍⵏ ⵏⵏⴰ ⵉⵜⵜⵓⵣⵟⵟⴰⵢⵏ ⵙ ⴽⵕⴰⴹ ⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ     //ⴷⴰ ⵜⵙⵙⵎⵔⴰⵙ ⵜⴼⵍⵙⵜ ⴰⴷ ⵜⴰⵍⴳⴰⵎⵜ l ⴰⵔ ⵜⵔⴰⵔ ⵜⴰⵍⴳⴰⵎⵜ l' ⵣⵓⵏⴷ ⵎⴰⵙ     // >>> sortThird((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    // >>> sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))
    // (List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))
    def sortThird(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  
  def sortThird(l: List[Long]): List[Long] = {
    // Get the elements at indices divisible by 3
    val elementsAtThirdIndices = l.zipWithIndex.collect {
      case (value, index) if index % 3 == 0 => value
    }
    
    // Sort the collected elements
    val sortedElements = elementsAtThirdIndices.sorted
    
    // Replace elements at indices divisible by 3 with the sorted ones
    l.zipWithIndex.map {
      case (_, index) if index % 3 == 0 => sortedElements(index / 3)
      case (value, _) => value
    }
  }

  // Example usage:
  def main(args: Array[String]): Unit = {
    println(sortThird(List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    println(sortThird(List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong, 1l.toLong))));
    }

}
"
HumanEval_34,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵥⵍⴰⵢⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⴳ ⵜⵍⴳⴰⵎⵜ     // >>> unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))
    // (List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))
    def unique(l : List[Long]) : List[Long] = {
","def unique(l: List[Long]): List[Long] = {
    l.toSet.toList.sorted
  }
}","    }
    def main(args: Array[String]) = {
    assert(unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))));
    }

}
"
HumanEval_35,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵎⵙⴽⴰⵔ ⴰⵎⵇⵔⴰⵏ ⴳ ⵜⵍⴳⴰⵎⵜ.    // >>> maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (3l)
    // >>> maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))
    // (123l)
    def maxElement(l : List[Long]) : Long = {
","def maxElement(l: List[Long]): Long = {
    l.max
  }
}","    }
    def main(args: Array[String]) = {
    assert(maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (3l));
    assert(maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 124l.toLong, 1l.toLong, -10l.toLong))) == (124l));
    }

}
"
HumanEval_36,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵉⵜⵓⵔ ⵏ ⵓⵎⴹⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵓⵟⵟⵓⵏ 7 ⴳ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵥⵥⵉⵏ ⵏⵏⴰ ⵓⵔ ⵢⴰⴽⵙⵓⵍⵏ ⵙ 11 ⵏⵖⴷ 13.     // >>> fizzBuzz((50l))
    // (0l)
    // >>> fizzBuzz((78l))
    // (2l)
    // >>> fizzBuzz((79l))
    // (3l)
    def fizzBuzz(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fizzBuzz(n: Long): Long = {
    var count = 0L
    for (i <- 1L until n) {
      if (i % 11 == 0 || i % 13 == 0) {
        count += i.toString.count(_ == '7')
      }
    }
    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(fizzBuzz((50l)) == (0l));
    assert(fizzBuzz((78l)) == (2l));
    assert(fizzBuzz((79l)) == (3l));
    assert(fizzBuzz((100l)) == (3l));
    assert(fizzBuzz((200l)) == (6l));
    assert(fizzBuzz((4000l)) == (192l));
    assert(fizzBuzz((10000l)) == (639l));
    assert(fizzBuzz((100000l)) == (8026l));
    }

}
"
HumanEval_37,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵡⴰⵜⵉⴳⵏ ⵏ ⵉⵙⵖⵏⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏ ""ⵍ"", ⵎⴰⵛⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ.    //I ⴰⵎⵙⴰⵙⴰ ⴷ I ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵎⴰⵛⴰ ⵜⵉⵜⵉⴳⵉⵏ ⵏⵏⵙ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳⴰⵏⵜ ⵉⵎⵣⴰⵔⴰⵢⵏ     //ⴷⴰ ⵜⵙⵙⵎⵔⴰⵙ ⵜⴼⵍⵙⵜ ⴰⴷ ⵜⴰⵍⴳⴰⵎⵜ l ⴰⵔ ⵜⵔⴰⵔ ⵜⴰⵍⴳⴰⵎⵜ l' ⵣⵓⵏⴷ ⵎⴰⵙ     // >>> sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    // >>> sortEven((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](3l.toLong, 6l.toLong, 5l.toLong, 4l.toLong))
    def sortEven(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // This function takes a list l and returns a list l' such that
  // l' is identical to l in the odd indicies, while its values at the even indicies are equal
  // to the values of the even indicies of l, but sorted.
  def sortEven(l: List[Long]): List[Long] = {
    val evenIndices = l.indices.filter(_ % 2 == 0)
    val sortedEvens = evenIndices.map(l(_)).sorted

    l.indices.map { index =>
      if (index % 2 == 0) sortedEvens(evenIndices.indexOf(index))
      else l(index)
    }.toList
  }

  // Examples
  def main(args: Array[String]): Unit = {
    println(sortEven(List[Long](1L, 2L, 3L)))
    println(sortEven(List[Long](5L, 6L, 3L, 4L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong))));
    assert(sortEven((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](-10l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 5l.toLong, 0l.toLong, 9l.toLong, 1l.toLong, 123l.toLong))));
    assert(sortEven((List[Long](5l.toLong, 8l.toLong, -12l.toLong, 4l.toLong, 23l.toLong, 2l.toLong, 3l.toLong, 11l.toLong, 12l.toLong, -10l.toLong))).equals((List[Long](-12l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 2l.toLong, 12l.toLong, 11l.toLong, 23l.toLong, -10l.toLong))));
    }

}
"
HumanEval_39,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //prime_fib ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵟⵟⵓⵏ ⵏ ⵜⵉⵙ-ⵏⵏⴰ ⵉⴳⴰⵏ ⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⴷ ⵉⴳⴰ ⴰⵡⴷ ⴰⵎⵣⵡⴰⵔⵓ.     // >>> primeFib((1l))
    // (2l)
    // >>> primeFib((2l))
    // (3l)
    // >>> primeFib((3l))
    // (5l)
    // >>> primeFib((4l))
    // (13l)
    // >>> primeFib((5l))
    // (89l)
    def primeFib(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def primeFib(n: Long): Long = {
    // Function to check if a number is prime
    def isPrime(num: Long): Boolean = {
      if (num <= 1) return false
      if (num == 2) return true
      if (num % 2 == 0) return false
      for (i <- Range(3, math.sqrt(num).toInt + 1, 2)) {
        if (num % i == 0) return false
      }
      true
    }

    // Function to generate Fibonacci numbers
    def fibonacciStream(): Stream[Long] = {
      def fibs(a: Long, b: Long): Stream[Long] = a #:: fibs(b, a + b)
      fibs(0, 1)
    }

    // Find the n-th Fibonacci number that is also prime
    val primeFibs = fibonacciStream().filter(isPrime)
    primeFibs.take(n.toInt).last
  }

  // Test the function
  def main(args: Array[String]): Unit = {
    println(primeFib(1L)) // 2
    println(primeFib(2L)) // 3
    println(primeFib(3L)) // 5
    println(primeFib(4L)) // 13
    println(primeFib(5L)) // 89
  }
}","    }
    def main(args: Array[String]) = {
    assert(primeFib((1l)) == (2l));
    assert(primeFib((2l)) == (3l));
    assert(primeFib((3l)) == (5l));
    assert(primeFib((4l)) == (13l));
    assert(primeFib((5l)) == (89l));
    assert(primeFib((6l)) == (233l));
    assert(primeFib((7l)) == (1597l));
    assert(primeFib((8l)) == (28657l));
    assert(primeFib((9l)) == (514229l));
    assert(primeFib((10l)) == (433494437l));
    }

}
"
HumanEval_40,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵜⵉⴳ ⵏ ⵓⵎⵢⴰ, ⴷ ⵜⵉⵔⵡⵉ ⴳ ⵡⴰⵏⵙⴰ ⵢⴰⴹⵏ.    //ⴷⴰ ⵉⵜⵜⴰⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ     //ⴷⴰ ⵉⵜⵜⴰⵙⵢ triple_sum_to_zero ⵙ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ.    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))
    // (false)
    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))
    // (true)
    // >>> triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))
    // (false)
    // >>> triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong)))
    // (true)
    // >>> triplesSumToZero((List[Long](1l.toLong)))
    // (false)
    def triplesSumToZero(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // triples_sum_to_zero takes a list of integers as an input.
    // it returns true if there are three distinct elements in the list that
    // sum to zero, and false otherwise.
    def triplesSumToZero(l: List[Long]): Boolean = {
        val n = l.length
        if (n < 3) return false

        // Sort the list to use the two-pointer technique
        val sortedList = l.sorted

        // Iterate over the list
        for (i <- 0 until n - 2) {
            var left = i + 1
            var right = n - 1

            // Use two pointers to find the remaining two numbers
            while (left < right) {
                val currentSum = sortedList(i) + sortedList(left) + sortedList(right)
                if (currentSum == 0) {
                    return true
                } else if (currentSum < 0) {
                    left += 1
                } else {
                    right -= 1
                }
            }
        }

        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -1l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (true));
    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 5l.toLong, 7l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))) == (true));
    assert(triplesSumToZero((List[Long](1l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](100l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));
    }

}
"
HumanEval_41,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴷⴰ ⵜⵙⵙⵓⴼⵖ ⵜⵎⵔⵙⵜ ⴰⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵏⵖⵉ ⴰⴷ.    //ⴷⴰⵗ ⵜⴰⴱⴰⵔⴰⵜ ⵜⴰⵏ ⵏⴰⵙⴰⵏ ⵛⵓⵏⴷ ⵓⴰⵔ ⵉⵋⵋⴰ ⴰⴾⴰⵔⴰⵛⵂ    //ⵎⵇⵇⴰⵔ, ⵍⵍⴰⵏ ⵉⵎⵓⴷⴰⵔ ⵉⴷⵓⵙⵏ ⴱⴰⵀⵔⴰ ⴷ ⵉⴷⵓⵙⵏ; ⵙ ⵜⵢⴰⴼⵓⵜ, ⴷⴰ ⵙⵓⵍⵏ ⵙ ⵓⵎⵓⵙⵙⵓ.    //ⴰⵍⵓⴰⵈ ⵓⴰ ⵉⴷ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵔⵓⵙⵜ ⵜⴰ ⵜⴰⴾⴰⵍ ⵙ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ    //ⵆⴰⵙ ⴰⴾⵓⵣⴰⵏⴰⵏ ⵙ ⵜⴰⵣⴰⵉⵜ ⵉⵉⵉⴰⵜ. ⵙⴰⵏⴰⵜⴰⵜ ⵉⴾⴰⵔⴰⵏⴰⵏ ⴰⵜⵓⴰⵗⵔⴰ    //ⴷⴰ ⵜⵜⵓⵙⵙⵓⴷⵓ ⵙ ⵓⵣⵔⴼ ⵙ ⵓⵛⵍⵍ. ⵙⵏⴰⵜ ⵜⵔⵓⴱⴱⴰ ⵏ ⵜⵓⵍⵍⵉⵜⵉⵏ ⴷⴰ ⵜⵜⴱⴷⵓⵏⵜ ⵙ ⵓⴱⵔⴰⵔ ⵏ ⵣⵉⴽⴽ ⵣⵉ ⵔⴱⴰⵜ.    //ⴷⴰ ⵙⵙⵓⴷⵙⵏ n ⵏ ⵉⵎⵓⴷⴰⵔ ⵙⴳ ⵓⵥⵍⵎⴰⴹ ⵖⵔ ⵓⵥⵍⵎⴰⴹ; ⴳ ⵢⴰⵜ ⵜⵉⵣⵉ, ⵜⴰⵔⴰⴱⴱⵓⵜ ⵏ ⵉⵎⵓⴷⴰⵔ     //ⴰⵜⴰⵍⴰⵗⵉ ⴰⵙ ⴰⴱⴰⵔⴰ ⴻⵈⵈⴰⵍ ⴰⴱⴰⵔⴰ ⵓⴰ ⵓⵗⴰⴷⴰⵏ ⵂⴰⵔⴾⵓⴾ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ    def carRaceCollision(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Imagine a road that's a perfectly straight infinitely long line.
  // n cars are driving left to right; simultaneously, a different set of n cars
  // are driving right to left. The two sets of cars start out being very far from
  // each other. All cars move at the same speed. Two cars are said to collide
  // when a car that's moving left to right hits a car that's moving right to left.
  // However, the cars are infinitely sturdy and strong; as a result, they continue moving
  // in their trajectory as if they did not collide.
  // This function outputs the number of such collisions.
  def carRaceCollision(n: Long): Long = {
    n
  }
}","    }
    def main(args: Array[String]) = {
    assert(carRaceCollision((2l)) == (4l));
    assert(carRaceCollision((3l)) == (9l));
    assert(carRaceCollision((4l)) == (16l));
    assert(carRaceCollision((8l)) == (64l));
    assert(carRaceCollision((10l)) == (100l));
    }

}
"
HumanEval_42,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵍⵉⵙⵜ ⵏ ⵓⵛⵛⵉⵍ ⵙ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵢⵓⵣⵔⵏ ⵙ 1.    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))
    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))
    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))
    def incrList(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Return list with elements incremented by 1.
    def incrList(l: List[Long]): List[Long] = {
        l.map(_ + 1)
    }
}","    }
    def main(args: Array[String]) = {
    assert(incrList((List[Long]())).equals((List[Long]())));
    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));
    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));
    }

}
"
HumanEval_43,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵜⵉⴳ ⵏ ⵓⵎⵢⴰ, ⴷ ⵜⵉⵔⵡⵉ ⴳ ⵡⴰⵏⵙⴰ ⵢⴰⴹⵏ.    //ⴷⴰ ⵉⵜⵜⴰⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ     //ⴷⴰ ⵉⵜⵜⴰⵙⵉ pairs_sum_to_zero ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ.    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))
    // (true)
    // >>> pairsSumToZero((List[Long](1l.toLong)))
    // (false)
    def pairsSumToZero(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def pairsSumToZero(l: List[Long]): Boolean = {
        val seen = HashSet[Long]()
        for (num <- l) {
            if (seen.contains(-num)) {
                return true
            }
            seen.add(num)
        }
        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](1l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 30l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 31l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 30l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 31l.toLong))) == (false));
    }

}
"
HumanEval_44,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵉⵎⴹⴰⵏ ⵏ ⵜⵔⵙⴰⵍ ⴳⴰⵏ ⵉⵎⵥⵥⵉⵏ ⵙⴳ 10.    //ⴷⴰ ⵉⵜⵜⴰⵣⴰⵍ ⵓⵙⵎⴷⵢⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵏⴼⵍ.    //ⵙⵏⴼⵍ ⵜⴰⵙⵉⵍⴰ ⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵛⵛⵓⵎ x ⵙ ⵜⴰⵙⵉⵍⴰ.    // >>> changeBase((8l), (3l))
    // (""22"")
    // >>> changeBase((8l), (2l))
    // (""1000"")
    // >>> changeBase((7l), (2l))
    // (""111"")
    def changeBase(x : Long, base : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def changeBase(x: Long, base: Long): String = {
        require(base > 1 && base < 10, ""Base must be between 2 and 9"")
        
        if (x == 0) return ""0""

        val result = new StringBuilder()
        var number = x

        while (number > 0) {
            val remainder = number % base
            result.append(remainder.toString)
            number /= base
        }

        result.reverse.toString()
    }
}","    }
    def main(args: Array[String]) = {
    assert(changeBase((8l), (3l)).equals((""22"")));
    assert(changeBase((9l), (3l)).equals((""100"")));
    assert(changeBase((234l), (2l)).equals((""11101010"")));
    assert(changeBase((16l), (2l)).equals((""10000"")));
    assert(changeBase((8l), (2l)).equals((""1000"")));
    assert(changeBase((7l), (2l)).equals((""111"")));
    assert(changeBase((2l), (3l)).equals((""2"")));
    assert(changeBase((3l), (4l)).equals((""3"")));
    assert(changeBase((4l), (5l)).equals((""4"")));
    assert(changeBase((5l), (6l)).equals((""5"")));
    assert(changeBase((6l), (7l)).equals((""6"")));
    assert(changeBase((7l), (8l)).equals((""7"")));
    }

}
"
HumanEval_45,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵣⵣⵓⵣⵔ ⵏ ⵓⴳⴰⴼⴰ ⴷ ⵢⵉⴳⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵎⵇⵔⴰⵏ ⵉ ⵜⵔⵉⴳⵓⵏⵉⵜ.    // >>> triangleArea((5l), (3l))
    // (7.5f)
    def triangleArea(a : Long, h : Long) : Float = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Given length of a side and height, return area for a triangle.
    // >>> triangleArea(5l, 3l)
    // (7.5f)
    def triangleArea(a: Long, h: Long): Float = {
        (a * h / 2.0).toFloat
    }
}","    }
    def main(args: Array[String]) = {
    assert(triangleArea((5l), (3l)) == (7.5f));
    assert(triangleArea((2l), (2l)) == (2.0f));
    assert(triangleArea((10l), (8l)) == (40.0f));
    }

}
"
HumanEval_46,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵉⵟⵏ ⵉⴼⵔⴷⵉⵙ ⵏ ⵡⵉⵙⵙ n ⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ fib4. ⵓⵔ ⵜⵙⵙⵎⵔⴰⵙ ⵜⵉⵔⵔⴰ.     //fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).    //fib4(3) -> 0     //fib4(2) -> 2     //fib4(1) -> 0     //fib4(0) -> 0     //ⵜⴰⵍⵖⴰ ⵏ ⵓⵟⵟⵓⵏ ⵏ Fib4 ⵜⴳⴰ ⵜⴰⵍⵖⴰ ⵢⴰⴽⵙⵓⵍⵏ ⴷ ⵜⴰⵍⵖⴰ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ ⵓⵎⴽ ⴰⴷ:    // >>> fib4((5l))
    // (4l)
    // >>> fib4((6l))
    // (8l)
    // >>> fib4((7l))
    // (14l)
    def fib4(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fib4(n: Long): Long = {
    if (n == 0 || n == 1) return 0
    if (n == 2) return 2
    if (n == 3) return 0

    var a: Long = 0
    var b: Long = 0
    var c: Long = 2
    var d: Long = 0
    
    var result: Long = 0
    
    for (i <- 4L to n) {
      result = a + b + c + d
      a = b
      b = c
      c = d
      d = result
    }
    
    result
  }
}","    }
    def main(args: Array[String]) = {
    assert(fib4((5l)) == (4l));
    assert(fib4((8l)) == (28l));
    assert(fib4((10l)) == (104l));
    assert(fib4((12l)) == (386l));
    }

}
"
HumanEval_47,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴷⴰ ⵉⵜⵜⴰⴽⵡⵣ ⵡⴰⵎⵎⴰⵙ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵜⵍⴳⴰⵎⵜ l.     // >>> median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // 3l
    // >>> median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong)))
    // (15.0f)
    def median(l : List[Long]) : Float = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return median of elements in the list l.
  def median(l: List[Long]): Float = {
    val sortedList = l.sorted
    val n = sortedList.length
    if (n % 2 == 1) {
      sortedList(n / 2).toFloat
    } else {
      (sortedList(n / 2 - 1) + sortedList(n / 2)).toFloat / 2
    }
  }

  def main(args: Array[String]): Unit = {
    println(median(List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) // 3.0
    println(median(List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) // 15.0
  }
}","    }
    def main(args: Array[String]) = {
    assert(median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == 3l);
    assert(median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) == (8.0f));
    assert(median((List[Long](5l.toLong))) == 5l);
    assert(median((List[Long](6l.toLong, 5l.toLong))) == (5.5f));
    assert(median((List[Long](8l.toLong, 1l.toLong, 3l.toLong, 9l.toLong, 9l.toLong, 2l.toLong, 7l.toLong))) == 7l);
    }

}
"
HumanEval_48,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴷⴰ ⵉⵜⵜⵉⵔⵉ ⴰⴷ ⵉⴳ ⵍⵉⵙⵜⵔⵉⵏ ⴰⴽⴽⵡ ⵉⴳⴰⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ     // >>> isPalindrome((""""))
    // (true)
    // >>> isPalindrome((""aba""))
    // (true)
    // >>> isPalindrome((""aaaaa""))
    // (true)
    // >>> isPalindrome((""zbcd""))
    // (false)
    def isPalindrome(text : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Checks if given string is a palindrome
  def isPalindrome(text: String): Boolean = {
    val length = text.length
    for (i <- 0 until length / 2) {
      if (text(i) != text(length - i - 1)) return false
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isPalindrome(("""")) == (true));
    assert(isPalindrome((""aba"")) == (true));
    assert(isPalindrome((""aaaaa"")) == (true));
    assert(isPalindrome((""zbcd"")) == (false));
    assert(isPalindrome((""xywyx"")) == (true));
    assert(isPalindrome((""xywyz"")) == (false));
    assert(isPalindrome((""xywzx"")) == (false));
    }

}
"
HumanEval_49,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵉⵜⵓⵔ 2^n ⵎⵓⴷⵓⵍⵓ p (ⴰⴷ ⵏⵙⵙⴽⵜⵉ ⵙ ⵡⵓⵟⵟⵓⵏ).    // >>> modp((3l), (5l))
    // (3l)
    // >>> modp((1101l), (101l))
    // (2l)
    // >>> modp((0l), (101l))
    // (1l)
    // >>> modp((3l), (11l))
    // (8l)
    // >>> modp((100l), (101l))
    // (1l)
    def modp(n : Long, p : Long) : Long = {
","def modp(n: Long, p: Long): Long = {
    // Calculate 2^n modulo p using iterative exponentiation by squaring.
    def powMod(base: Long, exp: Long, mod: Long): Long = {
      var result = 1L
      var b = base % mod
      var e = exp
      
      while (e > 0) {
        if ((e & 1) == 1) { // Check if e is odd
          result = (result * b) % mod
        }
        e >>= 1
        b = (b * b) % mod
      }

      result
    }

    powMod(2, n, p)
  }
}","    }
    def main(args: Array[String]) = {
    assert(modp((3l), (5l)) == (3l));
    assert(modp((1101l), (101l)) == (2l));
    assert(modp((0l), (101l)) == (1l));
    assert(modp((3l), (11l)) == (8l));
    assert(modp((100l), (101l)) == (1l));
    assert(modp((30l), (5l)) == (4l));
    assert(modp((31l), (5l)) == (3l));
    }

}
"
HumanEval_51,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //remove_vowels ⵜⴳⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⴼⵉⵏⴰⵖ ⴱⵍⴰ ⵜⵉⴼⵉⵏⴰⵖ.     // >>> removeVowels((""""))
    // ("""")
    // >>> removeVowels((""abcdef""))
    // (""bcdf"")
    // >>> removeVowels((""aaaaa""))
    // ("""")
    // >>> removeVowels((""aaBAA""))
    // (""B"")
    // >>> removeVowels((""zbcd""))
    // (""zbcd"")
    def removeVowels(text : String) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def removeVowels(text: String): String = {
        val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
        text.filterNot(vowels.contains)
    }
}","    }
    def main(args: Array[String]) = {
    assert(removeVowels(("""")).equals(("""")));
    assert(removeVowels((""abcdef\nghijklm"")).equals((""bcdf\nghjklm"")));
    assert(removeVowels((""fedcba"")).equals((""fdcb"")));
    assert(removeVowels((""eeeee"")).equals(("""")));
    assert(removeVowels((""acBAA"")).equals((""cB"")));
    assert(removeVowels((""EcBOO"")).equals((""cB"")));
    assert(removeVowels((""ybcd"")).equals((""ybcd"")));
    }

}
"
HumanEval_52,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⴳⴰⵏ ⵉⵎⴹⴰⵏ ⴰⴽⴽⵡ ⴳ ⵜⵍⴳⴰⵎⵜ l ⴷⴷⴰⵡ ⵏ ⵓⴽⵜⵜⵓⵔ t.     // >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))
    // (true)
    // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))
    // (false)
    def belowThreshold(l : List[Long], t : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if all numbers in the list l are below threshold t.
  // >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))
  // (true)
  // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))
  // (false)
  def belowThreshold(l: List[Long], t: Long): Boolean = {
    l.forall(_ < t)
  }
}","    }
    def main(args: Array[String]) = {
    assert(belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l)) == (false));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (21l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (22l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (11l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (10l)) == (false));
    }

}
"
HumanEval_53,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙⵓⵏ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏ x ⴷ y     // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    def add(x : Long, y : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Add two numbers x and y
    // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    def add(x: Long, y: Long): Long = {
        x + y
    }
}","    }
    def main(args: Array[String]) = {
    assert(add((0l), (1l)) == (1l));
    assert(add((1l), (0l)) == (1l));
    assert(add((2l), (3l)) == (5l));
    assert(add((5l), (7l)) == (12l));
    assert(add((7l), (5l)) == (12l));
    }

}
"
HumanEval_54,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⴻⵛⴻⵛⴻ ⵎⴻⵗ ⵙⴰⵏⴰⵜⴰⵜ ⵉⵙⵎⴰⵓⴰⵏ ⵉⵍⴰⵏ ⵉⵛⵛⵉⴾⵉⵍⴰⵏ ⵓⵍⴰⵂⵏⴻⵏ.    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc""))
    // (true)
    // >>> sameChars((""abcd""), (""dddddddabc""))
    // (true)
    // >>> sameChars((""dddddddabc""), (""abcd""))
    // (true)
    // >>> sameChars((""eabcd""), (""dddddddabc""))
    // (false)
    // >>> sameChars((""abcd""), (""dddddddabce""))
    // (false)
    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc""))
    // (false)
    def sameChars(s0 : String, s1 : String) : Boolean = {
","import scala.collection.mutable._

object Problem {
  def sameChars(s0: String, s1: String): Boolean = {
    def charSet(s: String): Set[Char] = s.toSet
    charSet(s0) == charSet(s1) && charSet(s0).forall(c => s0.count(_ == c) <= s1.count(_ == c) && s1.count(_ == c) <= s0.count(_ == c))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(sameChars((""abcd""), (""dddddddabc"")) == (true));
    assert(sameChars((""dddddddabc""), (""abcd"")) == (true));
    assert(sameChars((""eabcd""), (""dddddddabc"")) == (false));
    assert(sameChars((""abcd""), (""dddddddabcf"")) == (false));
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(sameChars((""aabb""), (""aaccc"")) == (false));
    }

}
"
HumanEval_55,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵉⵜⵓⵔ ⵏ ⵜⵓⵏⴹⵜ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵛⵉ ⵜⵉⵙ n.    // >>> fib((10l))
    // (55l)
    // >>> fib((1l))
    // (1l)
    // >>> fib((8l))
    // (21l)
    def fib(n : Long) : Long = {
","def fib(n: Long): Long = {
        if (n <= 1) n
        else {
            var a: Long = 0
            var b: Long = 1
            for (_ <- 2L to n) {
                val temp = a + b
                a = b
                b = temp
            }
            b
        }
    }
}","    }
    def main(args: Array[String]) = {
    assert(fib((10l)) == (55l));
    assert(fib((1l)) == (1l));
    assert(fib((8l)) == (21l));
    assert(fib((11l)) == (89l));
    assert(fib((12l)) == (144l));
    }

}
"
HumanEval_56,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //return true ⵎⴽ ⴷⴰⵔ ⴽⵓ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵕⵥⵥⵓⵎ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵇⵇⵏ.     //brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵜⵜⵓ ⵏ ""<"" ⴷ "">"".     // >>> correctBracketing((""<""))
    // (false)
    // >>> correctBracketing((""<>""))
    // (true)
    // >>> correctBracketing((""<<><>>""))
    // (true)
    // >>> correctBracketing((""><<>""))
    // (false)
    def correctBracketing(brackets : String) : Boolean = {
","import scala.collection.mutable.Stack

object Problem {
  def correctBracketing(brackets: String): Boolean = {
    val stack = new Stack[Char]()
    for (char <- brackets) {
      if (char == '<') {
        stack.push(char)
      } else if (char == '>') {
        if (stack.isEmpty || stack.pop() != '<') {
          return false
        }
      }
    }
    stack.isEmpty
  }
}","    }
    def main(args: Array[String]) = {
    assert(correctBracketing((""<>"")) == (true));
    assert(correctBracketing((""<<><>>"")) == (true));
    assert(correctBracketing((""<><><<><>><>"")) == (true));
    assert(correctBracketing((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(correctBracketing((""<<<><>>>>"")) == (false));
    assert(correctBracketing((""><<>"")) == (false));
    assert(correctBracketing((""<"")) == (false));
    assert(correctBracketing((""<<<<"")) == (false));
    assert(correctBracketing(("">"")) == (false));
    assert(correctBracketing((""<<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>><<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>>><>"")) == (false));
    }

}
"
HumanEval_57,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Return true is ⵉⵙⵡⵓⵔⵉⵏ ⵏ ⵜⵍⴳⴰⵎⵜ ⴷⴰ ⵙⵙⵓⴷⵓⵏ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵓⵙⵙⵖⵍⵉ ⵏⵖⴷ ⵓⵙⵙⴷⵔⵓⵙ.    // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))
    // (true)
    // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))
    // (false)
    // >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))
    // (true)
    def monotonic(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if list elements are monotonically increasing or decreasing.
  // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))
  // (true)
  // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))
  // (false)
  // >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))
  // (true)
  def monotonic(l: List[Long]): Boolean = {
    if (l.isEmpty || l.length == 1) return true

    val increasing = l.sliding(2).forall { case List(a, b) => a <= b }
    val decreasing = l.sliding(2).forall { case List(a, b) => a >= b }

    increasing || decreasing
  }
}","    }
    def main(args: Array[String]) = {
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong))) == (false));
    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong))) == (true));
    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 5l.toLong, 60l.toLong))) == (false));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 60l.toLong))) == (true));
    assert(monotonic((List[Long](9l.toLong, 9l.toLong, 9l.toLong, 9l.toLong))) == (true));
    }

}
"
HumanEval_58,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⵉⵡⵏⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵉⵛⵛⴰⵔⵏ ⵉ ⵙⵏⴰⵜ ⵜⵍⴳⴰⵎⵉⵏ.    // >>> common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))
    // (List[Long](1l.toLong, 5l.toLong, 653l.toLong))
    // >>> common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))
    // (List[Long](2l.toLong, 3l.toLong))
    def common(l1 : List[Long], l2 : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return sorted unique common elements for two lists.
  def common(l1: List[Long], l2: List[Long]): List[Long] = {
    (l1.toSet intersect l2.toSet).toList.sorted
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(common(List[Long](1L, 4L, 3L, 34L, 653L, 2L, 5L), List[Long](5L, 7L, 1L, 5L, 9L, 653L, 121L)))
    println(common(List[Long](5L, 3L, 2L, 8L), List[Long](3L, 2L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 653l.toLong))));
    assert(common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 3l.toLong))));
    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 3l.toLong, 4l.toLong))));
    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));
    }

}
"
HumanEval_59,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵉⵜⵓⵔ ⵏ ⵓⵎⵙⴽⵉⵍ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ ⵏ n. ⵏⵙⵙⵉⵏ ⵉⵙ n > 1 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵎⵣⵡⴰⵔⵓ.     // >>> largestPrimeFactor((13195l))
    // (29l)
    // >>> largestPrimeFactor((2048l))
    // (2l)
    def largestPrimeFactor(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def largestPrimeFactor(n: Long): Long = {
        var number = n
        var largestFactor = 1L

        // Check for number of 2s that divide n
        while (number % 2 == 0) {
            largestFactor = 2L
            number /= 2
        }

        // n must be odd at this point, so a skip of 2 (i = i + 2) can be used
        var i = 3
        while (i <= sqrt(number)) {
            while (number % i == 0) {
                largestFactor = i
                number /= i
            }
            i += 2
        }

        // This condition is to check if number is a prime number greater than 2
        if (number > 2) {
            largestFactor = number
        }

        largestFactor
    }
}","    }
    def main(args: Array[String]) = {
    assert(largestPrimeFactor((15l)) == (5l));
    assert(largestPrimeFactor((27l)) == (3l));
    assert(largestPrimeFactor((63l)) == (7l));
    assert(largestPrimeFactor((330l)) == (11l));
    assert(largestPrimeFactor((13195l)) == (29l));
    }

}
"
HumanEval_60,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //sum_to_n ⵜⴳⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵎⵓⵏ ⵉⵎⴹⴰⵏ ⵙⴳ 1 ⴰⵔ n.     // >>> sumToN((30l))
    // (465l)
    // >>> sumToN((100l))
    // (5050l)
    // >>> sumToN((5l))
    // (15l)
    // >>> sumToN((10l))
    // (55l)
    // >>> sumToN((1l))
    // (1l)
    def sumToN(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def sumToN(n: Long): Long = {
        (1L to n).sum
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumToN((1l)) == (1l));
    assert(sumToN((6l)) == (21l));
    assert(sumToN((11l)) == (66l));
    assert(sumToN((30l)) == (465l));
    assert(sumToN((100l)) == (5050l));
    }

}
"
HumanEval_61,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //return true ⵎⴽ ⴷⴰⵔ ⴽⵓ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵕⵥⵥⵓⵎ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵇⵇⵏ.     //brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵜⵜⵓ ⵏ ""("" ⴷ "")"".    // >>> correctBracketing((""(""))
    // (false)
    // >>> correctBracketing((""()""))
    // (true)
    // >>> correctBracketing((""(()())""))
    // (true)
    // >>> correctBracketing(("")(()""))
    // (false)
    def correctBracketing(brackets : String) : Boolean = {
","var balance = 0
        for (ch <- brackets) {
            if (ch == '(') balance += 1
            else if (ch == ')') balance -= 1
            
            if (balance < 0) return false
        }
        balance == 0
    }
}","    }
    def main(args: Array[String]) = {
    assert(correctBracketing((""()"")) == (true));
    assert(correctBracketing((""(()())"")) == (true));
    assert(correctBracketing((""()()(()())()"")) == (true));
    assert(correctBracketing((""()()((()()())())(()()(()))"")) == (true));
    assert(correctBracketing((""((()())))"")) == (false));
    assert(correctBracketing(("")(()"")) == (false));
    assert(correctBracketing((""("")) == (false));
    assert(correctBracketing((""(((("")) == (false));
    assert(correctBracketing(("")"")) == (false));
    assert(correctBracketing((""(()"")) == (false));
    assert(correctBracketing((""()()(()())())(()"")) == (false));
    assert(correctBracketing((""()()(()())()))()"")) == (false));
    }

}
"
HumanEval_62,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵉⵜⵓⵔⵏ ⴷⵉⵔⵉⴼⵉⴰⵜⵉⴱ ⵏ ⴱⵓⵍⵉⵏⵓⵎⵉⵢⴰ ⴰⴷ ⴳ ⵢⴰⵜ ⵜⴰⵍⵖⴰ ⵢⴰⴽⵙⵓⵍⵏ.     //xs[0] + xs[1] * x + xs[2] * x^2 + ....     //ⴷⴰ ⵉⵙⵎⴷⵢⴰ xs ⵉⵎⴳⴳⵉⵜⵏ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵡⵜⵜⴰ.    // >>> derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // (List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))
    // >>> derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 6l.toLong))
    def derivative(xs : List[Long]) : List[Long] = {
","import scala.collection.mutable._

object Problem {
  def derivative(xs: List[Long]): List[Long] = {
    xs.zipWithIndex.tail.map { case (coeff, index) => coeff * index }
  }
}","    }
    def main(args: Array[String]) = {
    assert(derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))));
    assert(derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 6l.toLong))));
    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 2l.toLong))));
    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 0l.toLong, 16l.toLong))));
    assert(derivative((List[Long](1l.toLong))).equals((List[Long]())));
    }

}
"
HumanEval_63,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵔⵢⵣ ⵜⴰⵡⵓⵔⵉ ⵏ ⵓⵙⵉⴹⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵎⴹⴰⵏ ⵏ fibfib ⵙ ⵢⴰⵜ ⵜⵖⴰⵔⴰⵙⵜ ⵉⴼⵓⵍⴽⵉⵏ.    //fibfib{n} == fibfib{n-1} + fibfib{n-2} + fibfib{n-3}    //fib fib ((2) == 1     //fibfib{1) == 0     //fibfib{0} == 0     //ⵜⴰⵍⵖⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⴼⵉⴱ ⵜⴳⴰ ⵜⴰⵍⵖⴰ ⵢⴰⴽⵙⵓⵍⵏ ⴷ ⵜⴰⵍⵖⴰ ⵏ ⴼⵉⴱⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ ⵓⵎⴽ ⴰⴷ:    // >>> fibfib((1l))
    // (0l)
    // >>> fibfib((5l))
    // (4l)
    // >>> fibfib((8l))
    // (24l)
    def fibfib(n : Long) : Long = {
","def fibfib(n: Long): Long = {
    if (n == 0) return 0
    if (n == 1) return 0
    if (n == 2) return 1

    var a: Long = 0
    var b: Long = 0
    var c: Long = 1
    var d: Long = 0

    for (_ <- 3L to n) {
      d = a + b + c
      a = b
      b = c
      c = d
    }
    d
  }
}","    }
    def main(args: Array[String]) = {
    assert(fibfib((2l)) == (1l));
    assert(fibfib((1l)) == (0l));
    assert(fibfib((5l)) == (4l));
    assert(fibfib((8l)) == (24l));
    assert(fibfib((10l)) == (81l));
    assert(fibfib((12l)) == (274l));
    assert(fibfib((14l)) == (927l));
    }

}
"
HumanEval_64,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //ⴰⵛⵛⵉⵍ, ⵎⴰⵛⴰ ⴷⴰⵢ ⵉⴳ ⵉⵍⵍⴰ ⴳ ⵜⴳⵉⵔⴰ ⵏ ⵜⴳⵓⵔⵉ ⵉⵜⵜⵓⴼⴽⴰⵏ.    //ⵉⵎⵓⵙⵙⵓⵜⵏ ⴳ ⵡⴰⴷⴷⴰⴷ ⴰⴷ ⴳⴰⵏ ""ⴰ"", ""ⵢ"", ""ⵉ"", ""ⵓ"", ""ⵓ"". ⴷⵖⴰ, ""ⵢ"" ⵉⴳⴰ ⴰⵡⴷ ""ⴰ""    //ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴳⵓⵔⵉ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵙⵍⵉ ⴳ ⵜⵣⵍⵉⵜ.    //ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ vowels_count ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵜⴰⵡⵓⵔⵉ ⵏ     // >>> vowelsCount((""abcde""))
    // (2l)
    // >>> vowelsCount((""ACEDY""))
    // (3l)
    def vowelsCount(s : String) : Long = {
","def vowelsCount(s: String): Long = {
    val vowels = Set('a', 'e', 'i', 'o', 'u')
    val lowerCaseWord = s.toLowerCase
    var count = 0L

    for (i <- lowerCaseWord.indices) {
      if (vowels.contains(lowerCaseWord(i)) || (lowerCaseWord(i) == 'y' && i == lowerCaseWord.length - 1)) {
        count += 1
      }
    }

    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(vowelsCount((""abcde"")) == (2l));
    assert(vowelsCount((""Alone"")) == (3l));
    assert(vowelsCount((""key"")) == (2l));
    assert(vowelsCount((""bye"")) == (1l));
    assert(vowelsCount((""keY"")) == (2l));
    assert(vowelsCount((""bYe"")) == (1l));
    assert(vowelsCount((""ACEDY"")) == (3l));
    }

}
"
HumanEval_65,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵎⴽ ⵜⵍⵍⴰ ⵜⵣⵍⵉⵜ > ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵔⴰⴷ ⵙⵔⵙⵏ ⵡⵓⵟⵟⵓⵏ ⵙ ⵓⴱⵔⴷ.    //ⴷ ⴰⵔ ⵏⴰⴽⴽⴰ ⵜⴰⵢⴰⴼⵓⵜ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ.    //ⴷⴰ ⵏⵙⵎⵓⵜⵜⵔ ⵉⵎⵉⴹⵏ ⵏ ⵉⵎⵉⴹ ⴰⵎⴷⴷⴰⴷ x ⵙ ⵜⵙⵓⵜⵍⵜ, ⵏⵙⵎⵓⵜⵜⵔ ⵉⵎⵉⴹⵏ ⵙ ⵜⵙⴳⴰ ⵏ ⵓⵣⵔⴼ ⵙ ⵓⵎⵙⵓⵜⵍ.    // >>> circularShift((12l), (1l))
    // (""21"")
    // >>> circularShift((12l), (2l))
    // (""12"")
    def circularShift(x : Long, shift : Long) : String = {
","def circularShift(x: Long, shift: Long): String = {
  val digits = x.toString
  val length = digits.length
  
  if (shift >= length) {
    digits.reverse
  } else {
    val effectiveShift = (length - shift % length).toInt
    (digits.drop(effectiveShift) + digits.take(effectiveShift))
  }
}","    }
    def main(args: Array[String]) = {
    assert(circularShift((100l), (2l)).equals((""001"")));
    assert(circularShift((12l), (2l)).equals((""12"")));
    assert(circularShift((97l), (8l)).equals((""79"")));
    assert(circularShift((12l), (1l)).equals((""21"")));
    assert(circularShift((11l), (101l)).equals((""11"")));
    }

}
"
HumanEval_66,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⴾⵓⴷ ⵜⴰⵏ ⵓⵉⵏ ASCII    //ⵔⵔⴰⵎ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵖⵕⴹⴰ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴰⴳⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵏ ⵓⴼⵍⵍⴰ     //ⵜⴰⵣⵣⴰⵍⵜ     // >>> digitSum((""""))
    // (0l)
    // >>> digitSum((""abAB""))
    // (131l)
    // >>> digitSum((""abcCd""))
    // (67l)
    // >>> digitSum((""helloE""))
    // (69l)
    // >>> digitSum((""woArBld""))
    // (131l)
    // >>> digitSum((""aAaaaXa""))
    // (153l)
    def digitSum(s : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def digitSum(s: String): Long = {
    s.filter(_.isUpper).map(_.toLong).sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(digitSum(("""")) == (0l));
    assert(digitSum((""abAB"")) == (131l));
    assert(digitSum((""abcCd"")) == (67l));
    assert(digitSum((""helloE"")) == (69l));
    assert(digitSum((""woArBld"")) == (131l));
    assert(digitSum((""aAaaaXa"")) == (153l));
    assert(digitSum(("" How are yOu?"")) == (151l));
    assert(digitSum((""You arE Very Smart"")) == (327l));
    }

}
"
HumanEval_67,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵉ ⵓⵛⵛⵉⵍ:     //ⴳ ⵜⴽⵕⴹⴰ ⵔⵥⵎ ⵓⵟⵟⵓⵏ ⵏ ⵜⵢⴰⴼⵓⵜⵉⵏ ⵏ ⵍⵎⴰⵏⴳⵓ ⴳ ⵜⴽⵕⴹⴰ.     //ⵜⵉⴱⵕⴰⵏⵊⵉⵏ ⴷ ⵜⴱⵔⵖⴰ ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵙⵎⴷⵢⴰⵏⵏ ⴰⵎⴹⴰⵏ ⴰⵖⵓⵍⴰⵏ ⵏ ⵜⵢⴰⴼⵓⵜⵉⵏ     //ⴹⴰⵔⴰⵜ ⴰⵙⵉⴾⵏⵓ ⵏ ⴾⵢⵍ ⴰⴾⴰⵍ, ⴾⵢⵍ ⴰⴾⴰⵍ, ⴾⵢⵍ ⴰⴾⴰⵍ, ⴾⵢⵍ ⴰⴾⴰⵍ,    //ⴰⵈⵈⴰⵍⴰⵏ ⴰ ⵉⴾⴼⴰⵏ ⴷⴰⵗ ⵜⴰⴱⴰⵔⴰⵜ ⵏ ⵉⴼⵔⴰⵜⴰⵏ ⴰⵂⴰⵏ ⵜⴰⴱⴰⵔⴰⵜ ⵜⵢⵏ    //ⴳ ⵜⵎⵙⴰⵔⵜ ⴰⴷ, ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ ⵉⵙⵎⴷⵢⴰⵏⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴱⵔⵟⵓⴽⵜ ⴷ ⵜⴱⵔⵟⵓⴽⵜ     // >>> fruitDistribution((""5 apples and 6 oranges""), (19l))
    // (8l)
    // >>> fruitDistribution((""0 apples and 1 oranges""), (3l))
    // (2l)
    // >>> fruitDistribution((""2 apples and 3 oranges""), (100l))
    // (95l)
    // >>> fruitDistribution((""100 apples and 1 oranges""), (120l))
    // (19l)
    def fruitDistribution(s : String, n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fruitDistribution(s: String, n: Long): Long = {
    val fruits = s.split("" and "").map(_.split("" "")(0).toLong)
    val totalApplesAndOranges = fruits.sum
    n - totalApplesAndOranges
  }
}","    }
    def main(args: Array[String]) = {
    assert(fruitDistribution((""5 apples and 6 oranges""), (19l)) == (8l));
    assert(fruitDistribution((""5 apples and 6 oranges""), (21l)) == (10l));
    assert(fruitDistribution((""0 apples and 1 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""1 apples and 0 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (100l)) == (95l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (5l)) == (0l));
    assert(fruitDistribution((""1 apples and 100 oranges""), (120l)) == (19l));
    }

}
"
HumanEval_68,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ 1:    //ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⵡⴰⵜⵉⴳⵏ ⵉⵎⵎⵓⵟⵟⵓⵏ ⵏⵖⴷ ⵉⴳⴰ ⵡⴰⵔⵔⴰ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵉⵔⵡⵍ [].    //ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⵏⴼⵍ ⵜⵓⵏⵏⵓⵏⵜ ⵉⵜⵜⵓⵙⵏⴱⴹⵏ ⴳ ⵜⵍⴳⴰⵎⵜ, [ smalest_value, ⴰⵙⵖⵍ ⵏⵏⵙ ],     //ⵎⴽ ⵜⵜⵢⴰⴼⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⴰⵎⵎ ⵓⵎⴹⴰⵏ, ⵙⵙⴽⵛⵎ ⵜⵓⵏⵏⵓⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵥⵥⵢⴰⵏ.     //ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⴳ ⵜⵓⵏⵏⵓⵏⵜ ⵉⵜⵜⵓⵙⴽⵔⵏ ⵜⴰⵡⵜⵎⵉⵢⵜ ⵜⴰⵥⵥⵉⵥⵜ ⴳ ⵡⴰⵜⵉⴳ ⴰⵎⵎ ⵓⵎⵢⴰ.    //ⵜⴰⵣⴰⵍⵍⵉⵜ ⵏⴰⵙⵙ ⴷ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵢⴰⵜ ⵙⴳ ⵜⵓⵏⵏⵓⵏⵜ ⴷ ⴰⴷ ⵜⵔⴰⵔ.    //""ⴰⴽⴽⴰ ⵏ ⵢⴰⵏ ⵓⵙⵎⵉⵍ ⵏ ⵓⵡⵜⵜⵓ ⵏ ⵓⵥⵟⵟⴰ ⵏ ⵜⵙⴽⵍⴰ ⵏⵏⴰ ⵖⵓⵔ ⵍⵍⴰⵏⵜ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⴽⵕⴹⵏ     // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 1l.toLong))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 2:
    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 1l.toLong))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 3:
    // >>> pluck((List[Long]()))
    // (List[Long]())
    // Example 4:
    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong))
    // Explanation: 0 is the smallest value, but  there are two zeros,
    // so we will choose the first zero, which has the smallest index.
    // Constraints:
    // * 1 <= nodes.length <= 10000
    // * 0 <= node.value
    def pluck(arr : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def pluck(arr: List[Long]): List[Long] = {
    val evenNodes = arr.zipWithIndex.filter { case (value, _) => value % 2 == 0 }
    if (evenNodes.isEmpty) {
      List.empty[Long]
    } else {
      val (smallestValue, index) = evenNodes.minBy { case (value, index) => (value, index) }
      List(smallestValue, index.toLong)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));
    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));
    assert(pluck((List[Long]())).equals((List[Long]())));
    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));
    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));
    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));
    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));
    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));
    }

}
"
HumanEval_69,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⵜⵉⴳ ⴰⴷ, ⵔⵔⵓⵜⵓⵔ -1.    //ⵜⴰⴽⴰⵜ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵜⵜⵓⴼⴽⴰⵏ ⴳ ⵜⵍⴳⴰⵎⵜ.    //ⴰⵎⵢⴰ, ⴷ ⵖⵓⵔⵙ ⵜⴰⵔⵖⴰ ⵜⴰⵅⴰⵜⴰⵔⵜ ⵏⵖⴷ ⵉⵎⴽⵉⵏⵏⴰ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵉⵎⵉⴹ ⴰⵎⴷⴷⴰⴷ ⵉⵎⴰⵏ ⵏⵏⵙ.    //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⴰⵍⴳⴰⵎⵜ ⵓⵔ ⵉⴳⵉⵏ ⵜⵍⵍⵉⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴽⵙⵡⴰⵜⵏ. ⵔⵔⵓⵜⵓⵔ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⵏⵏⴰ ⵢⵓⴳⵔⵏ     // >>> search((List[Long](4l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))
    // (2l)
    // >>> search((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))
    // (3l)
    // >>> search((List[Long](5l.toLong, 5l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))
    // (-1l)
    def search(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def search(lst: List[Long]): Long = {
    val frequencyMap = lst.groupBy(identity).mapValues(_.size)
    lst.filter(num => frequencyMap(num) >= num).sorted(Ordering[Long].reverse) match {
      case x :: _ => x
      case Nil => -1L
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(search((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));
    assert(search((List[Long](4l.toLong, 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));
    assert(search((List[Long](3l.toLong, 3l.toLong))) == (-1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));
    assert(search((List[Long](2l.toLong, 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](2l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong, 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));
    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong, 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));
    assert(search((List[Long](6l.toLong, 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 7l.toLong, 9l.toLong))) == (1l));
    assert(search((List[Long](1l.toLong, 9l.toLong, 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));
    assert(search((List[Long](6l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong, 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (5l));
    assert(search((List[Long](1l.toLong))) == (1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong, 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 5l.toLong))) == (4l));
    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong, 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong))) == (2l));
    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong, 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong, 3l.toLong))) == (1l));
    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong, 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));
    assert(search((List[Long](2l.toLong, 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong))) == (4l));
    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong, 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong))) == (2l));
    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong, 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong, 10l.toLong, 8l.toLong))) == (-1l));
    assert(search((List[Long](10l.toLong))) == (-1l));
    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong, 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 7l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](5l.toLong, 4l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 1l.toLong, 8l.toLong))) == (1l));
    assert(search((List[Long](7l.toLong, 9l.toLong, 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));
    assert(search((List[Long](3l.toLong, 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));
    }

}
"
HumanEval_70,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⴷⴼⴼⵉⵔ ⵏ ⵓⵢⴰ, ⵔⴰⴷ ⵢⵉⵍⵉ ⵡⵓⴳⴳⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ ⵔⴰⴷ ⵢⵉⵍⵉ ⵡⵓⴳⴳⴰⵔ, ⴷ ⴰⵢⴰⴷ.    //ⴰⵙⵎⵉⵍⵍ ⴰⵎⵣⴳⵓⵏ, ⵉⴳ ⴷⴰ ⵜⵜⴱⴷⵓⴷ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ,     //ⵎⴽ ⵜⵜⵓⴼⴽⴰ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵔⴰⴷ ⵏⵕⵜⵔⵓⵏ ⵜⵍⴳⴰⵎⵜ ⵙ ⵓⵍⵓⴳ ⵓⵔ ⵉⵃⵍⵉⵏ.    // >>> strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))
    // >>> strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong)))
    // (List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))
    // >>> strangeSortList((List[Long]()))
    // (List[Long]())
    def strangeSortList(lst : List[Long]) : List[Long] = {
","def strangeSortList(lst: List[Long]): List[Long] = {
    val buffer = lst.sorted.toBuffer
    val result = ArrayBuffer[Long]()
    var takeMin = true

    while (buffer.nonEmpty) {
      if (takeMin) {
        result += buffer.remove(0) // take the minimum
      } else {
        result += buffer.remove(buffer.length - 1) // take the maximum of the remaining
      }
      takeMin = !takeMin
    }

    result.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong, 7l.toLong))));
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong, 8l.toLong, 6l.toLong, 7l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))));
    assert(strangeSortList((List[Long]())).equals((List[Long]())));
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong, 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));
    assert(strangeSortList((List[Long](0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong, 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));
    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));
    }

}
"
HumanEval_71,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //ⵓⴰⵔ ⵢⵈⵈⵢⵍ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴾⴰⵔⴰⴷ    //ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⴷⴰ ⵙⴽⴰⵔⵏ ⵢⴰⵜ ⵜⵔⴰⵢⵓⴳⵍⴰⵏⵜ ⵉⵖⵓⴷⴰⵏ ⵉⴳ ⵜⵍⵍⴰ ⵜⵔⵎⵉⵜ ⵏ ⵙⵏⴰⵜ ⵜⴼⵓⵍⵉⵏ ⴽⵔⴰ ⵢⴰⴹⵏ     //ⵎⴽ ⵓⵔ ⵉⴳⵉ, ⴷⴰ ⵉⵜⵜⵔⴰⵔ -1     //ⵜⵔⵉⴰⵏⴳⵉⵍ ⵜⵓⵔⴷⴰ ⵙ 2 ⵏ ⵜⵏⵇⵇⵉⴹⵉⵏ ⵜⵉⵎⵔⴰⵡⵉⵏ ⵎⴽ ⵜⴳⴰ ⴽⵕⴰⴹⵜ ⵜⴼⵓⵍⵉⵏ ⵢⴰⵜ ⵜⵔⵉⴰⵏⴳⵉⵍⵜ ⵜⵓⵏⵖⵉⴷⵜ.    //ⴷⴰ ⵜⵜⵓⴽⴽⴰⵏ ⵜⵉⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⴽⵕⴰⴹ ⵓⴷⵖⴰⵔ. ⵔⵎⵙⵏ ⵜⴰⵊⵓⵎⵎⴰ ⵏ     // >>> triangleArea((3l), (4l), (5l))
    // (6.0f)
    // >>> triangleArea((1l), (2l), (10l))
    // -1l
    def triangleArea(a : Long, b : Long, c : Long) : Float = {
","import scala.math._

object Problem {
  def triangleArea(a: Long, b: Long, c: Long): Float = {
    if (a + b > c && a + c > b && b + c > a) {
      val s = (a + b + c) / 2.0
      val area = sqrt(s * (s - a) * (s - b) * (s - c))
      BigDecimal(area).setScale(2, BigDecimal.RoundingMode.HALF_UP).toFloat
    } else {
      -1f
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(triangleArea((3l), (4l), (5l)) == (6.0f));
    assert(triangleArea((1l), (2l), (10l)) == -1l);
    assert(triangleArea((4l), (8l), (5l)) == (8.18f));
    assert(triangleArea((2l), (2l), (2l)) == (1.73f));
    assert(triangleArea((1l), (2l), (3l)) == -1l);
    assert(triangleArea((10l), (5l), (7l)) == (16.25f));
    assert(triangleArea((2l), (6l), (3l)) == -1l);
    assert(triangleArea((1l), (1l), (1l)) == (0.43f));
    assert(triangleArea((2l), (2l), (10l)) == -1l);
    }

}
"
HumanEval_72,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //ⵔⴰⴷ ⵉⵢⵉ ⵜⵓⴷⵔⵜ ⵏ ⵓⴷⵎ q ⵉⴳ ⵉⴳⴰ ⴰⵎⵙⴰⵙⴰ (ⵉⴳⴰ ⵢⴰⵏ ⵓⵙⵎⵉⵍ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ) ⴷ ⵡⴰⵜⵜⴰⵢⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⵙ ⵡⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⵡⴰⵜⵜⴰⵢⵏ ⵏ ⵓⴽⵙⴰⵢ ⴰⴳⴳⵓⴳ w.    //ⵔⵉⵜⵓⵔⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⴳⴰⵏ ⵜⵉⴷⵜ ⵎⴽ ⴷⴰ ⵉⵜⵜⵓⵖⴰⵍ ⵓⴱⵓⵊⵉⴽⵜ q, ⴷ ⵜⵉⴽⵕⴹⵉ ⵎⴽ ⵓⵔ ⵉⴳⵉ.    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))
    // (false)
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.
    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l))
    // (false)
    // # it's balanced, but 3+2+3 is more than the maximum possible weight.
    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))
    // (true)
    // # 3+2+3 is less than the maximum possible weight, and it's balanced.
    // >>> willItFly((List[Long](3l.toLong)), (5l))
    // (true)
    // # 3 is less than the maximum possible weight, and it's balanced.
    def willItFly(q : List[Long], w : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def willItFly(q: List[Long], w: Long): Boolean = {
    val isPalindromic = q == q.reverse
    val sumOfElements = q.sum
    isPalindromic && sumOfElements <= w
  }

  def main(args: Array[String]): Unit = {
    println(willItFly(List[Long](1L, 2L), 5L)) // false
    println(willItFly(List[Long](3L, 2L, 3L), 1L)) // false
    println(willItFly(List[Long](3L, 2L, 3L), 9L)) // true
    println(willItFly(List[Long](3L), 5L)) // true
  }
}","    }
    def main(args: Array[String]) = {
    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));
    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));
    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));
    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) == (false));
    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (6l)) == (false));
    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));
    }

}
"
HumanEval_73,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⴷⴰ ⵉⵜⵜⵓⵙⵎⴷ ⵢⴰⵏ ⵓⵎⵏⵉⴷ ⵙ ⵓⵎⵏⵉⴷ ⴷ ⵙ ⵓⵎⵏⵉⴷ. ⴳ ⵢⴰⵏ ⵓⵙⵏⴼⵍ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵏⴼⵍ ⵢⴰⵏ ⵉⴼⵔⴷⵉⵙ ⵙ ⴽⵔⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵢⴰⴹⵏ.    //ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⵏⴼⵍ ⴰⴼⴰⴷ ⴰⴷ ⵜⴳ ⵜⵍⴳⴰⵎⵜ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉⵜ. ⵜⴰⵍⴳⴰⵎⵜ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉⵜ ⵜⴳⴰ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ     //ⴹⴼⵓⵕ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷⴼⵔⵓⵏ ⴰⵎⴹⴰⵏ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ     // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))
    // (4l)
    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))
    // (1l)
    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong)))
    // (0l)
    def smallestChange(arr : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a list arr of integers, find the minimum number of elements that
  // need to be changed to make the list palindromic.

  def smallestChange(arr: List[Long]): Long = {
    var changes: Long = 0

    for (i <- 0 until arr.length / 2) {
      if (arr(i) != arr(arr.length - 1 - i)) {
        changes += 1
      }
    }

    changes
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(smallestChange(List(1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L)))  // Output: 4
    println(smallestChange(List(1L, 2L, 3L, 4L, 3L, 2L, 2L)))  // Output: 1
    println(smallestChange(List(1L, 2L, 3L, 2L, 1L)))  // Output: 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));
    assert(smallestChange((List[Long](3l.toLong, 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));
    assert(smallestChange((List[Long](1l.toLong))) == (0l));
    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) == (1l));
    }

}
"
HumanEval_74,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ    //ⵎⴽ ⴳⴰⵏ ⵙⵏⴰⵜ ⵜⵍⴳⴰⵎⵉⵏ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ, ⵙⵏⵓⵍⴼⵓ ⵜⵍⴳⴰⵎⵜ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ.    //ⴰⵟⵟⴰⵚ ⵏ ⵜⴽⴰⵔⵉⵜⵉⵏ ⴳ ⴽⵓⵍⵍⵓ ⵜⵉⵙⵉⴹⴼⴰⵏ ⵏ ⵜⵍⴳⴰⵎⵜ ⴷⵔⵓⵙⵏ ⴳ ⵜⵍⴳⴰⵎⵜ ⵢⴰⴹⵏ.    //ⵔⵔⴰⵎ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵙⵏⴰⵜ ⵜⵍⴳⴰⵎⵉⵏ ⵏ ⵉⵙⵉⴹⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ     // >>> totalMatch((List[String]()), (List[String]()))
    // (List[String]())
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""Hi"")))
    // (List[String](""hI"", ""Hi""))
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi"", ""admin"", ""project"")))
    // (List[String](""hi"", ""admin""))
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hi"")))
    // (List[String](""hI"", ""hi"", ""hi""))
    // >>> totalMatch((List[String](""4"")), (List[String](""1"", ""2"", ""3"", ""4"", ""5"")))
    // (List[String](""4""))
    def totalMatch(lst1 : List[String], lst2 : List[String]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def totalMatch(lst1: List[String], lst2: List[String]): List[String] = {
    val sum1 = lst1.map(_.length).sum
    val sum2 = lst2.map(_.length).sum
    if (sum1 <= sum2) lst1 else lst2
  }
}","    }
    def main(args: Array[String]) = {
    assert(totalMatch((List[String]()), (List[String]())).equals((List[String]())));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi""))).equals((List[String](""hi"", ""hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi"", ""admin"", ""project""))).equals((List[String](""hi"", ""admin""))));
    assert(totalMatch((List[String](""4"")), (List[String](""1"", ""2"", ""3"", ""4"", ""5""))).equals((List[String](""4""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""Hi""))).equals((List[String](""hI"", ""Hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hi""))).equals((List[String](""hI"", ""hi"", ""hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hii""))).equals((List[String](""hi"", ""admin""))));
    assert(totalMatch((List[String]()), (List[String](""this""))).equals((List[String]())));
    assert(totalMatch((List[String](""this"")), (List[String]())).equals((List[String]())));
    }

}
"
HumanEval_75,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //ⵃⵎⴰ ⴰⴷ ⵏⵙⵙⵏ ⵉⵙ (ⴰ) ⴷⵔⵓⵙ ⵙⴳ 100.    //ⴷ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ     //ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵜⴰⵔⵡⴰ ⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⵡⵓⵔⴰ     // >>> isMultiplyPrime((30l))
    // (true)
    // 30 = 2 * 3 * 5
    def isMultiplyPrime(a : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isMultiplyPrime(a: Long): Boolean = {
    def isPrime(num: Long): Boolean = {
      if (num <= 1) return false
      if (num <= 3) return true
      if (num % 2 == 0 || num % 3 == 0) return false
      var i = 5
      while (i * i <= num) {
        if (num % i == 0 || num % (i + 2) == 0) return false
        i += 6
      }
      true
    }

    val primes = (2L to 100L).filter(isPrime)
    val primeList = primes.toList

    for {
      i <- primeList.indices
      j <- i until primeList.size
      k <- j until primeList.size
      if primeList(i) * primeList(j) * primeList(k) == a
    } return true

    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(isMultiplyPrime((5l)) == (false));
    assert(isMultiplyPrime((30l)) == (true));
    assert(isMultiplyPrime((8l)) == (true));
    assert(isMultiplyPrime((10l)) == (false));
    assert(isMultiplyPrime((125l)) == (true));
    assert(isMultiplyPrime((105l)) == (true));
    assert(isMultiplyPrime((126l)) == (false));
    assert(isMultiplyPrime((729l)) == (false));
    assert(isMultiplyPrime((891l)) == (false));
    assert(isMultiplyPrime((1001l)) == (true));
    }

}
"
HumanEval_76,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //x ⴷ ⵜⴰⵣⵎⵔⵜ ⵜⴰⵎⵢⵉⵡⴰⵏⵜ ⵏ n ⵎⴽ n**int=x     //ⵜⴰⵣⵎⵔⵜ ⵏ n ⴷ ⵜⵉⵔⵡⵉ ⴳ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏ.    //ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴰⵔⵔⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ x ⵢⴰⵏ     // >>> isSimplePower((1l), (4l))
    // (true)
    // >>> isSimplePower((2l), (2l))
    // (true)
    // >>> isSimplePower((8l), (2l))
    // (true)
    // >>> isSimplePower((3l), (2l))
    // (false)
    // >>> isSimplePower((3l), (1l))
    // (false)
    // >>> isSimplePower((5l), (3l))
    // (false)
    def isSimplePower(x : Long, n : Long) : Boolean = {
","def isSimplePower(x: Long, n: Long): Boolean = {
        if (n == 1) {
            return x == 1
        }
        
        var value: Long = n
        while (value <= x) {
            if (value == x) {
                return true
            }
            
            if (value > Long.MaxValue / n) {
                return false
            }
            value *= n
        }
        
        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(isSimplePower((16l), (2l)) == (true));
    assert(isSimplePower((143214l), (16l)) == (false));
    assert(isSimplePower((4l), (2l)) == (true));
    assert(isSimplePower((9l), (3l)) == (true));
    assert(isSimplePower((16l), (4l)) == (true));
    assert(isSimplePower((24l), (2l)) == (false));
    assert(isSimplePower((128l), (4l)) == (false));
    assert(isSimplePower((12l), (6l)) == (false));
    assert(isSimplePower((1l), (1l)) == (true));
    assert(isSimplePower((1l), (12l)) == (true));
    }

}
"
HumanEval_77,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⴰⵜⵓⵉⵙⵙⴰⵎ: ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⴰⵜⵓⴰⵣⵋⴰⵎ ⴰⵙ ⵉⴾⵉ ⵏ ⴰⴾⴰⵉⴰⴷ ⵓⵍⴰⵗⴰⵏ ⵂⴰⵔⴾⵓⴾ    //ⵎⴽ ⵉⴳⴰ ⵡⵉⵏⴳⵉⵊⵔ ⴰⴷ ⴰⵎⴷⵢⴰ ⴰⵎⵖⴰⵔⴰⵏ ⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⴷⴷⴰⴷⵏ.    //ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ a ⴰⵔ ⵉⵜⵜⴰⵊⵊⴰ ⵜⵉⴷⵜ     // >>> iscube((1l))
    // (true)
    // >>> iscube((2l))
    // (false)
    // >>> iscube((-1l))
    // (true)
    // >>> iscube((64l))
    // (true)
    // >>> iscube((0l))
    // (true)
    // >>> iscube((180l))
    // (false)
    def iscube(a : Long) : Boolean = {
","def iscube(a: Long): Boolean = {
  val cubeRoot = math.cbrt(a.toDouble).round
  cubeRoot * cubeRoot * cubeRoot == a
}","    }
    def main(args: Array[String]) = {
    assert(iscube((1l)) == (true));
    assert(iscube((2l)) == (false));
    assert(iscube((-1l)) == (true));
    assert(iscube((64l)) == (true));
    assert(iscube((180l)) == (false));
    assert(iscube((1000l)) == (true));
    assert(iscube((0l)) == (true));
    assert(iscube((1729l)) == (false));
    }

}
"
HumanEval_78,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⴷ ⵉⵙⵎⴰⵡⵏ ⴰ,ⴱ,ⵙ,ⴷ,ⵢ,ⴼ ⴳⴰⵏ ⴰⵀⴰ ⵉⵎⵇⵔⴰⵏⵏ.    //ⵜⴰⵍⵖⴰ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉ ⵉⵙ ⵉⴳⴰ ⵡⴰⴷⴷⴰⴷ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵀⴰ ⵉⴳⵏ ⴰⵣⵔⴼⴰⵏ ⵏⵖⴷ ⴰⵎⵙⴷⴷⵉ ⵏ ⵡⴰⵔⵔⴰⵜⵏ,     //ⴱ (= ⴷⵢⵛⵉⵎⴰⵍ 11), ⴷ (= ⴷⵢⵛⵉⵎⴰⵍ 13).    //ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵏⵙⵙⴽⵜⵉ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ ⵡⵓⵟⵟⵓⵏ ⴰⴷ: 2, 3, 5, 7,     //ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴳⴰⵏ 2, 3, 5, 7, 11, 13, 17...    //ⴳⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵙⵡⴰⵜ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.    //ⵓⴳⴳⴰⵔ ⵏ 1 ⵓⵔ ⵉⴳⵉ ⴰⵎⵢⴰⴼⵓ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵔⴳⴰⵢⵏ ⵉⵎⵥⵥⵉⵏ).    //ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴳ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⵡⵓⵔⴰ (ⵉⴹ ⴰⵎⵣⵡⴰⵔⵓ, ⵏⵖⴷ ⴰⵎⵣⵡⴰⵔⵓ, ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⴳⴰⵎⴰⵏ     //ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⵓⵟⵟⵓⵏ ⴰⵀⵉⵣⴰⴷⵉⵎⴰⵍ ⴰⵎⵎ ⵜⴰⴹⴰ ⴷ ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⵓⵟⵟⵓⵏ ⵏ ⵓⵟⵟⵓⵏ ⴰⵀⵉⵣⴰⴷⵉⵎⴰⵍ     //ⵜⵜⵓⵣⵔⴰⴽ ⴰⴷ ⵜⴰⵔⵉⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ     // >>> hexKey((""AB""))
    // (1l)
    // >>> hexKey((""1077E""))
    // (2l)
    // >>> hexKey((""ABED1A33""))
    // (4l)
    // >>> hexKey((""123456789ABCDEF0""))
    // (6l)
    // >>> hexKey((""2020""))
    // (2l)
    def hexKey(num : String) : Long = {
","def hexKey(num: String): Long = {
  val primeHexDigits = Set('2', '3', '5', '7', 'B', 'D')
  num.count(ch => primeHexDigits.contains(ch)).toLong
}","    }
    def main(args: Array[String]) = {
    assert(hexKey((""AB"")) == (1l));
    assert(hexKey((""1077E"")) == (2l));
    assert(hexKey((""ABED1A33"")) == (4l));
    assert(hexKey((""2020"")) == (2l));
    assert(hexKey((""123456789ABCDEF0"")) == (6l));
    assert(hexKey((""112233445566778899AABBCCDDEEFF00"")) == (12l));
    }

}
"
HumanEval_79,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⵉⵍⴰⵏ ⵉⵙⵎⴰⵡⵏ ⵏ ⵓⴳⴳⴰⵔ ⴰⴼⴰⴷ ⴰⴷ ⵜⵜⵓⵙⵎⵔⴰⵙ ⵜⴰⵍⵖⴰ.    //ⵔⴰⴷ ⵉⵍⵉⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ""db"" ⴳ ⵍⴱⴷⵓ ⴷ ⵜⴳⵉⵔⴰ ⵏ ⵜⵣⵍⵉⵜ.    //ⴽⵓ ⴰⵔⵉⵎ ⴳ ⵜⵣⵍⵉⵜ ⵔⴰⴷ ⵉⴳ ""0"" ⵏⵖ ""1"".    //ⵜⴰⵍⵖⴰ ⵏ ⵜⴱⵉⵏⴰⵔⵉⵜ. ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔ ⵜⵡⵓⵔⵉ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ, ⴷ ⴽⵓ ⵉⵙⴽⴽⵉⵍ ⵉⵙⵎⴷⵢⴰⵏ ⵜⴰⴱⵉⵏⴰⵔⵉⵜ     //ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵜⴹⵉⵚⵜ ⴳ ⵜⴰⵍⵖⴰ ⵏ ⵜⴷⵉⵣⵎⵉⵜ ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⴼⵍⵜ ⵙ     // >>> decimalToBinary((15l))
    // (""db1111db"")
    // >>> decimalToBinary((32l))
    // (""db100000db"")
    def decimalToBinary(decimal : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def decimalToBinary(decimal: Long): String = {
    ""db"" + decimal.toBinaryString + ""db""
  }
}","    }
    def main(args: Array[String]) = {
    assert(decimalToBinary((0l)).equals((""db0db"")));
    assert(decimalToBinary((32l)).equals((""db100000db"")));
    assert(decimalToBinary((103l)).equals((""db1100111db"")));
    assert(decimalToBinary((15l)).equals((""db1111db"")));
    }

}
"
HumanEval_80,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⴰⴱⵙⴽⴰⵍⴰ ⵉⴳⴰ ⴰⴱⵙⴽⴰⵍⴰ ⵉⴳ ⴷⴰⵔⵙ ⵜⵉⵖⵣⵉ ⴽⵕⴰⴹ ⴷ ⴽⵓ ⴽⵕⴰⴹ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ     //ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵥⵕⵉⵖ ⵉⵖ ⵜⴳⴰ ⵜⵣⵍⵉⵜ ⵜⴰⵀⴰⴱⵙⴽⴰⵍⵉⵜ ⵏⵖ ⵓⵔ ⵜⵍⵍⵉ.    //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ s.    // >>> isHappy((""a""))
    // (false)
    // >>> isHappy((""aa""))
    // (false)
    // >>> isHappy((""abcd""))
    // (true)
    // >>> isHappy((""aabb""))
    // (false)
    // >>> isHappy((""adb""))
    // (true)
    // >>> isHappy((""xyy""))
    // (false)
    def isHappy(s : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isHappy(s: String): Boolean = {
    if (s.length < 3) return false 

    for (i <- 0 until s.length - 2) {
      if (s(i) == s(i + 1) || s(i) == s(i + 2) || s(i + 1) == s(i + 2)) {
        return false
      }
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isHappy((""a"")) == (false));
    assert(isHappy((""aa"")) == (false));
    assert(isHappy((""abcd"")) == (true));
    assert(isHappy((""aabb"")) == (false));
    assert(isHappy((""adb"")) == (true));
    assert(isHappy((""xyy"")) == (false));
    assert(isHappy((""iopaxpoi"")) == (true));
    assert(isHappy((""iopaxioi"")) == (false));
    }

}
"
HumanEval_81,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //0.0 E     //> 0.0 ⴷ-     //> 0.7 D     //> 1.0 ⴷ+     //> 1.3 C-     //> 1.7 C     //> 2.0 C+     //> 2.3 ⴱ-     //> 2.7 B     //> 3.0 ⴱ+     //> 3.3 ⴰ-     //> 3.7 ⴰ     //4.0 ⴰ+     //GPA. ⴰⵍⴾⴰⴷ ⵏ ⵜⵉⴾⴰⵔⵙⵉⵓⴻⵏ    //ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵥⴹⴰⵕⵏ ⴰⴷ ⵉⴼⴼⵖ ⵢⴰⵏ ⵓⵙⵎⵉⵍ ⵏ ⵡⴰⵏⴰⵡⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵙ ⵓⵙⵎⵔⵙ ⵏ ⵜⴼⵍⵡⵉⵜ ⴰⴷ:     //ⵜⴰⴾⴼⴰ-ⵛⴻ ⵍⵉⵙⵜⴻ ⵏ ⵗⴱⴱⴻ ⵉⵉⵉⴰⴷ ⵏ ⴰⵍⵎⴰⴷⴰⵏ ⵜⵓⵍⴰⵙ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⴻⵜ ⴰⴷ ⴰⴾⵜⴰⴱ    //ⵎⵓⵛⴰⴾⵉⵍ ⵓⴰ ⵉⵉⵉⴰⵏ ⴰⵎⵓⵙ ⴰⵙ ⵜⴰⴾⴼⴰ ⴰⵛⵓⵓⴷ ⵓⴰ ⵙ ⵉⵋⵋⴰ ⴰⴾⴰⵉⴰⴷ    //ⵆⵢⵍ ⴰⵍⵍⴰⵗⴰⵜ ⵓⴰ ⵉⵋⵋⴰⵏ ⴰⵍⵍⵗⵉⵙⴰⵔ ⴰⵍⴶⵂⵓⵔⵉⵜⵎ ⵏⵢⵜ ⵉ ⴰⴾⴾⴰⵉ ⵏ ⴰⵍⴾⴰⴷ    //ⴻⵈⴰⵍ ⴻⵎⴰⵉⵏⴰⴶ ⵓⴰ ⴷⴰⵔⴰⵎⴰⵏ ⴰⵏ ⵙⴻⵎⴻⵙⵜⴻⵔ ⴰⴷ ⵎⴰⴶⵔⴰⴷ ⵉⵍⴰ ⴰⴶⴰⵔⴰⵓ ⴰⵏ ⵜⵉⴾⴰⵔⵙⴻⵏ    // >>> gradeEquation((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat)))
    // (List[String](""A+"", ""B"", ""C-"", ""C"", ""A-""))
    def numericalLetterGrade(grades : List[Float]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def numericalLetterGrade(grades: List[Float]): List[String] = {
    grades.map { gpa =>
      gpa match {
        case g if g == 4.0 => ""A+""
        case g if g > 3.7 => ""A""
        case g if g > 3.3 => ""A-""
        case g if g > 3.0 => ""B+""
        case g if g > 2.7 => ""B""
        case g if g > 2.3 => ""B-""
        case g if g > 2.0 => ""C+""
        case g if g > 1.7 => ""C""
        case g if g > 1.3 => ""C-""
        case g if g > 1.0 => ""D+""
        case g if g > 0.7 => ""D""
        case g if g > 0.0 => ""D-""
        case _ => ""E""
      }
    }
  }

  def main(args: Array[String]): Unit = {
    val grades = List[Float](4.0f, 3.0f, 1.7f, 2.0f, 3.5f)
    println(numericalLetterGrade(grades)) // Output: List(A+, B, C-, C, A-)
  }
}","    }
    def main(args: Array[String]) = {
    assert(numericalLetterGrade((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat))).equals((List[String](""A+"", ""B"", ""C-"", ""C"", ""A-""))));
    assert(numericalLetterGrade((List[Float](1.2f.toFloat))).equals((List[String](""D+""))));
    assert(numericalLetterGrade((List[Float](0.5f.toFloat))).equals((List[String](""D-""))));
    assert(numericalLetterGrade((List[Float](0.0f.toFloat))).equals((List[String](""E""))));
    assert(numericalLetterGrade((List[Float](1.0f.toFloat, 0.3f.toFloat, 1.5f.toFloat, 2.8f.toFloat, 3.3f.toFloat))).equals((List[String](""D"", ""D-"", ""C-"", ""B"", ""B+""))));
    assert(numericalLetterGrade((List[Float](0.0f.toFloat, 0.7f.toFloat))).equals((List[String](""E"", ""D-""))));
    }

}
"
HumanEval_82,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ    //ⵜⵉⵖⵣⵉ ⵜⴳⴰ ⴰⵎⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵏⵖⴷ ⵜⵉⵔⵡⵉ     //ⵔⵉⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵍⴰⵏ ⴰⵔ ⵉⵜⵜⴰⵊⵊⴰ ⵜⵉⴷⵜ ⵎⴽ ⵜⴳⴰ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵍⴰⵏ     // >>> primeLength((""Hello""))
    // (true)
    // >>> primeLength((""abcdcba""))
    // (true)
    // >>> primeLength((""kittens""))
    // (true)
    // >>> primeLength((""orange""))
    // (false)
    def primeLength(string : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def primeLength(string: String): Boolean = {
    val length = string.length

    if (length <= 1) return false
    
    for (i <- 2 to sqrt(length).toInt) {
      if (length % i == 0) return false
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(primeLength((""Hello"")) == (true));
    assert(primeLength((""abcdcba"")) == (true));
    assert(primeLength((""kittens"")) == (true));
    assert(primeLength((""orange"")) == (false));
    assert(primeLength((""wow"")) == (true));
    assert(primeLength((""world"")) == (true));
    assert(primeLength((""MadaM"")) == (true));
    assert(primeLength((""Wow"")) == (true));
    assert(primeLength(("""")) == (false));
    assert(primeLength((""HI"")) == (true));
    assert(primeLength((""go"")) == (true));
    assert(primeLength((""gogo"")) == (false));
    assert(primeLength((""aaaaaaaaaaaaaaa"")) == (false));
    assert(primeLength((""Madam"")) == (true));
    assert(primeLength((""M"")) == (false));
    assert(primeLength((""0"")) == (false));
    }

}
"
HumanEval_83,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ ⵏⵏⴰ ⵉⵙⵙⵏⵜⵉⵢⵏ ⵏⵖⴷ ⵉⵎⵉⵔⴰⵢⵏ ⵙ 1.    //ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵏⵓⵍⴼⵓ ⴰⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ n     def startsOneEnds(n : Long) : Long = {
","def startsOneEnds(n: Long): Long = {
        if (n <= 0) return 0
        
        // Calculate numbers starting with 1: 1XX...X (n-1) digits after 1
        val startWithOne: Long = math.pow(10, n - 1).toLong
        
        // Calculate numbers ending with 1: XX...X1 (n-1) digits before 1
        // but without leading zeroes allowed, i.e., the first digit can't be zero
        val endWithOne: Long = math.pow(10, n - 1).toLong
        
        // Reverse counting: numbers starting and ending with 1 (11XX...X)
        val bothStartAndEndWithOne: Long = if (n > 1) math.pow(10, n - 2).toLong else 0
        
        // The total numbers starting or ending, or both, with 1
        startWithOne + endWithOne - bothStartAndEndWithOne
    }
}","    }
    def main(args: Array[String]) = {
    assert(startsOneEnds((1l)) == (1l));
    assert(startsOneEnds((2l)) == (18l));
    assert(startsOneEnds((3l)) == (180l));
    assert(startsOneEnds((4l)) == (1800l));
    assert(startsOneEnds((5l)) == (18000l));
    }

}
"
HumanEval_84,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ    //ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ N, ⵙⵙⴽⵛⵎ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⵙ ⵜⴱⵉⵏⴰⵔⵉⵜ.     // >>> solve((1000l))
    // (""1"")
    // >>> solve((150l))
    // (""110"")
    // >>> solve((147l))
    // (""1100"")
    // Variables:
    // @N integer
    // Constraints: 0 ≤ N ≤ 10000.
    // Output:
    // a string of binary number
    def solve(N : Long) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    // Given a positive integer N, return the total sum of its digits in binary.
    def solve(N: Long): String = {
        val sumOfDigits = N.toString.map(_.asDigit).sum
        sumOfDigits.toBinaryString
    }

    def main(args: Array[String]): Unit = {
        println(solve(1000L))  // should print ""1""
        println(solve(150L))   // should print ""110""
        println(solve(147L))   // should print ""1100""
    }
}","    }
    def main(args: Array[String]) = {
    assert(solve((1000l)).equals((""1"")));
    assert(solve((150l)).equals((""110"")));
    assert(solve((147l)).equals((""1100"")));
    assert(solve((333l)).equals((""1001"")));
    assert(solve((963l)).equals((""10010"")));
    }

}
"
HumanEval_85,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⴳ ⵜⵍⴳⴰⵎⵜ ⵓⵔ ⵉⴳⵉⵏ ⵜⵍⵍⴰⵍⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵣⵡⴰⵔ ⴰⴷ ⵏⵔⵏⵓ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ.    // >>> add((List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)))
    // (2l)
    def add(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a non-empty list of integers lst. add the even elements that are at odd indices.
  def add(lst: List[Long]): Long = {
    lst.zipWithIndex.collect {
      case (value, index) if index % 2 == 1 && value % 2 == 0 => value
    }.sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(add((List[Long](4l.toLong, 88l.toLong))) == (88l));
    assert(add((List[Long](4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 2l.toLong, 122l.toLong))) == (122l));
    assert(add((List[Long](4l.toLong, 0l.toLong, 6l.toLong, 7l.toLong))) == (0l));
    assert(add((List[Long](4l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))) == (12l));
    }

}
"
HumanEval_86,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⴰⵜⵓⵉⵙⵙⴰⵏ: ⵉⵋⵋⴰⵛⵂ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏ ⴰⴾⴰⵔⴰⵛⵂ ⵏ ⵉⵙⵎⴰⵓⴰⵏ ⴷ ⵉⵂⴰⵏⴷⴰⴶⴰⵏ ⵓⵉⵏ ⴰⴱⴰⵔⴰ ⵜⴰⵏ ⴷⴰⵗ ⵜⴰⵗⵢⵍⵉⵜ    //ⴾⵢⵍ ⴰⴾⴰⵔⴰⵛⵂ ⵏ ⴰⵍⵈⵉⵎ ⵏ ⴰⵙⵛⵉⵉ    //ⴷⴰ ⵜⵜⵓⵙⵏⴼⴰⵍ ⵙ ⵜⴳⵓⵔⵉ ⵜⴰⵎⴰⵢⵏⵓⵜ ⴳ  ⴰⵔ ⵜⵜⵓⵙⵏⵎⴰⵍⴰ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ    //ⵜⴰⵍⵖⴰ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵢⵏ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵜⴳⴰ ⵜⵉⴼⵉⵏⴰⵖ ⴳ ⵍⵍⴰⵏⵜ ⴽⵓⵍⵍⵓ ⵜⴳⵓⵔⵉⵡⵉⵏ (ⵜⵓⴱⴹⴰ ⵙ ⵓⵙⴰⵢⵔⴰⵔ)     //ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵜ ⵜⵓⵏⵖⵉⵍⵜ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵢⵏ.    // >>> antiShuffle((""Hi""))
    // (""Hi"")
    // >>> antiShuffle((""hello""))
    // (""ehllo"")
    // >>> antiShuffle((""Hello World!!!""))
    // (""Hello !!!Wdlor"")
    def antiShuffle(s : String) : String = {
","import scala.collection.mutable.ArrayBuffer

object Problem {
  def antiShuffle(s: String): String = {
    val words = s.split(""(?<=\\s)"")
    val sortedWords = words.map(word => {
      val trimmedWord = word.trim
      val sortedChars = trimmedWord.sorted
      word.replace(trimmedWord, sortedChars)
    })
    sortedWords.mkString("""")
  }

  def main(args: Array[String]): Unit = {
    println(antiShuffle(""Hi""))
    println(antiShuffle(""hello""))
    println(antiShuffle(""Hello World!!!""))
  }
}","    }
    def main(args: Array[String]) = {
    assert(antiShuffle((""Hi"")).equals((""Hi"")));
    assert(antiShuffle((""hello"")).equals((""ehllo"")));
    assert(antiShuffle((""number"")).equals((""bemnru"")));
    assert(antiShuffle((""abcd"")).equals((""abcd"")));
    assert(antiShuffle((""Hello World!!!"")).equals((""Hello !!!Wdlor"")));
    assert(antiShuffle(("""")).equals(("""")));
    assert(antiShuffle((""Hi. My name is Mister Robot. How are you?"")).equals(("".Hi My aemn is Meirst .Rboot How aer ?ouy"")));
    }

}
"
HumanEval_87,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⴰⵡⴷ, ⵙⵙⵓⴷⵙ ⴰⴽⵓⵓⵔⴷⵉⵏⴰⵜⵏ ⵏ ⵜⴰⴳⴳⴰⵢⵜ ⵙ ⵜⵔⵙⴰⵍ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⴷⴰⵔ.    //ⴷⴰ ⵜⵜⵓⵙⵎⵉⵍⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵙ ⵜⵉⵣⵡⵓⵔⵉ ⵙ ⵜⵉⵙⵉⴹⴼⵉⵏ ⵙ ⵓⵍⵜⵖ.    //ⴽⵓ ⵜⴰⴱⵍⵍⵜ ⵜⴳⴰ ⴽⵓⵓⵔⴷⵉⴷⴰⵢⵜ - (ⵜⵉⵔⵉⵜ, ⵜⵉⵔⵙⴰⵍ), ⴰⵔⵜⴰⵉ ⵙ 0.    //ⴷ ⴰⵔ ⵉⵜⵜⴰⵍⵙ ⵓⵎⵙⵎⵓⵏ ⵏ ⵜⴱⵍⵍⵢⵉⵏ, [(x1, y1), (x2, y2) ...] ⵣⵓⵏⴷ ⵎⴰⵙ     //ⴹⴼⵓⵕⵏ lst, ⴷ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ x, ⴹⴼⵓⵕⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ x ⴳ ⵜⵍⴳⴰⵎⵜ,    //ⴽⵓ ⵜⴰⵔⵙⵍⵜ ⵜⵣⵎⵔ ⴰⴷ ⵜⴰⴽⴽⴰ ⴰⵎⴹⴰⵏ ⵏ ⵜⵔⵙⴰⵍ ⵉⵣⵍⵉⵏ.    //ⴰⵢⴰ ⵢⴰⴽⵙⵓⵍ ⴷ ⵎⴰⵜⵔⵉⴽⵙ, ⵎⴰⵛⴰ ⵓⵔ ⵢⴰⴽⵙⵓⵍ ⴷ ⵎⴰⵜⵔⵉⴽⵙ,     //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⵏⵎⵎⴰⵍⵏ ⵏ ⵙⵉⵏ ⵡⵓⴳⴳⵓⴳⵏ, ⵙ ⵡⴰⵏⴰⵡ ⵏ ⵜⵍⴳⴰⵎⵉⵏ ⵉⵜⵜⵓⵙⵎⵓⵏⵏ,     // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))
    // (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))
    // >>> getRow((List[List[Long]]()), (1l))
    // (List[Tuple2[Long, Long]]())
    // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))
    // (List[Tuple2[Long, Long]]((2l, 2l)))
    def getRow(lst : List[List[Long]], x : Long) : List[Tuple2[Long, Long]] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def getRow(lst: List[List[Long]], x: Long): List[(Long, Long)] = {
    val coordinates = for {
      (row, rowIndex) <- lst.zipWithIndex
      (value, colIndex) <- row.zipWithIndex
      if value == x
    } yield (rowIndex.toLong, colIndex.toLong)

    coordinates
      .groupBy(_._1)
      .toList
      .sortBy(_._1)
      .flatMap { case (rowIndex, coords) =>
        coords.sortBy(-_._2)
      }
  }
}","    }
    def main(args: Array[String]) = {
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));
    assert(getRow((List[List[Long]]()), (1l)).equals((List[Tuple2[Long, Long]]())));
    assert(getRow((List[List[Long]](List[Long](1l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]())));
    assert(getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long, Long]]((2l, 2l)))));
    }

}
"
HumanEval_88,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //* ⵓⴰⵔⴷ ⵉⵙⵏⴼⵍ ⴰⵙⵎⵉⵍ ⵏⵏⵉ ⵉⵜⵜⵓⴼⴽⴰⵏ.    //ⴰⵜⵡⵉⵍ:     //ⵏⵖ ⴰⴷ ⵏⵙⵎⵓⵏ ⴳ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⴷⴰⵔ ⵉⵖ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵖⴰⵍ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵖⴰⵍ ⴰⵎⴳⴳⴰⵔⵓ.    //ⵔⴰⴷ ⵜⵙⵏⵙⵍⵎ ⵜⴰⵍⴳⴰⵎⵜ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵓⵙⵙⵓ ⵉⴳ ⵜⵍⵍⴰ ⵜⴳⵔⵓⵎⵎⴰ ((ⵜⵉⴳⵉ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵉⵔⴰ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵉⵔⴰ ⴰⵎⴳⴳⴰⵔⵓ) ⵓⵔ ⵉⴳⵉⵏ,     //ⴹⴼⴰⵕ ⵏ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵔⵉⵏⵉⵏ, ⵔⵎⵙ ⵜⴰⴽⵓⵙⴽⴰⵍⵜ ⵏ ⵜⵍⴳⴰⵎⵜ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵎⵙⴰⵙⴰ,    // >>> sortArray((List[Long]()))
    // (List[Long]())
    // >>> sortArray((List[Long](5l.toLong)))
    // (List[Long](5l.toLong))
    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))
    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))
    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))
    def sortArray(array : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def sortArray(array: List[Long]): List[Long] = {
    if (array.isEmpty) {
      array
    } else {
      val first = array.head
      val last = array.last
      val sum = first + last
      if (sum % 2 == 0) {
        array.sorted(Ordering[Long].reverse)
      } else {
        array.sorted
      }
    }
  }

  def main(args: Array[String]): Unit = {
    println(sortArray(List[Long]())) // (List[Long]())
    println(sortArray(List[Long](5L))) // (List[Long](5L))
    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L))) // (List[Long](0L, 1L, 2L, 3L, 4L, 5L))
    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L, 6L))) // (List[Long](6L, 5L, 4L, 3L, 2L, 1L, 0L))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortArray((List[Long]())).equals((List[Long]())));
    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));
    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));
    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));
    }

}
"
HumanEval_89,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⴰⴷⴷⵓⵙ ⵙ ⵙⵉⵏ ⵉⴽⴼⵓⴷⵏ ⵙ ⵙⵏⴰⵜ ⵜⵉⵖⴰⵔⵉⵡⵉⵏ.    //ⵉⵇⵏⴻⵏ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⴰⵍ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵜⵖⴰⵔⴰⵙⵜ ⵏⵏⴰ ⵔⴰⴷ ⵔⴰⵏⵜ ⵜⴱⵔⵔⴰⵜⵉⵏ     //ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴼⵉⵏⴰⵖ ⵉⵜⵜⵓⵃⴹⴰⵏ ⵙ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ.    //ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏ ⵓⵙⵏⴼⵍⵍⵓⵍ ⵏⵏⴰ ⵉⵜⵜⴰⵙⵉⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴰⵎⵎ ⵓⵎⴳⵔⴰⴷ ⴷ     // >>> encrypt((""hi""))
    // (""lm"")
    // >>> encrypt((""asdfghjkl""))
    // (""ewhjklnop"")
    // >>> encrypt((""gf""))
    // (""kj"")
    // >>> encrypt((""et""))
    // (""ix"")
    def encrypt(s : String) : String = {
","def encrypt(s: String): String = {
  s.map(c => {
    val rotatedChar = (c - 'a' + 4) % 26 + 'a'
    rotatedChar.toChar
  })
}","    }
    def main(args: Array[String]) = {
    assert(encrypt((""hi"")).equals((""lm"")));
    assert(encrypt((""asdfghjkl"")).equals((""ewhjklnop"")));
    assert(encrypt((""gf"")).equals((""kj"")));
    assert(encrypt((""et"")).equals((""ix"")));
    assert(encrypt((""faewfawefaewg"")).equals((""jeiajeaijeiak"")));
    assert(encrypt((""hellomyfriend"")).equals((""lippsqcjvmirh"")));
    assert(encrypt((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")).equals((""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")));
    assert(encrypt((""a"")).equals((""e"")));
    }

}
"
HumanEval_90,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⵉⵜⵓⵔⵏ ⵏⵓⵜⵢ ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵓⵏⴰⵡ ⴰⴷ.    //ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ next_smallest (() ⵏⵏⴰ ⵉⵙⴽⵔⵏ ⵜⵉⴽⴽⵍⵜ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⴳ ⵉⵎⵥⵥⵢⴰⵏ ⴳ ⵜⵍⴳⴰⵎⵜ.     //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ.    // >>> nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))
    // Some(2l)
    // >>> nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong)))
    // Some(2l)
    // >>> nextSmallest((List[Long]()))
    // None
    // >>> nextSmallest((List[Long](1l.toLong, 1l.toLong)))
    // None
    def nextSmallest(lst : List[Long]) : Option[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def nextSmallest(lst: List[Long]): Option[Long] = {
    if (lst.size < 2) return None

    val distinctSorted = lst.distinct.sorted
    if (distinctSorted.size < 2) None
    else Some(distinctSorted(1))
  }
}","    }
    def main(args: Array[String]) = {
    assert(nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals(Some(2l)));
    assert(nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong))).equals(Some(2l)));
    assert(nextSmallest((List[Long]())).equals(None));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(1l)));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));
    assert(nextSmallest((List[Long](-35l.toLong, 34l.toLong, 12l.toLong, -45l.toLong))).equals(Some(-35l)));
    }

}
"
HumanEval_91,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⵜⵉⴼⵔⴰⵙ ⴰⵜ-ⵓ-ⴰⵗⴱⴰⵍ ⵏⴰⵜ ⵙ """", ""?"" ⵎⵢⵗ ""!""    //""ⵜⵉⵎⵙⵓⵜⴰ"" ⵜⴰⵈⵈⴰⵍ ⵜⴰⵗⵉⵍⵉⵜ ⵜⵉⵙⵙⵉⵏⵜⴰ ⵙ ⵉⵙⵉⵎ ⵓⴰⵏ ""I""    //ⴰⴷ ⴰⵜⵓⴰⴾⴰⵙⴰⵏ ⵜⴰⴱⴰⵔⴰⵜ ⴰⵏ ⵎⴰⴶⵔⴰⴷ, ⴰⴷ ⴰⵛⴰⵆⵉⵍ ⴰⵏⴻⵙ ⴰⴷ ⴰⵉⴶⵉ ⴰⵏ ⵎⴰⴶⵔⴰⴷ.    // >>> isBored((""Hello world""))
    // (0l)
    // >>> isBored((""The sky is blue. The sun is shining. I love this weather""))
    // (1l)
    def isBored(S : String) : Long = {
","def isBored(S: String): Long = {
    // Split the input string into sentences using '.', '?' or '!' as delimiters
    val sentences = S.split(""[.!?]"").map(_.trim)

    // Filter sentences that start with 'I' and count them
    sentences.count(sentence => sentence.startsWith(""I""))
  }
}","    }
    def main(args: Array[String]) = {
    assert(isBored((""Hello world"")) == (0l));
    assert(isBored((""Is the sky blue?"")) == (0l));
    assert(isBored((""I love It !"")) == (1l));
    assert(isBored((""bIt"")) == (0l));
    assert(isBored((""I feel good today. I will be productive. will kill It"")) == (2l));
    assert(isBored((""You and I are going for a walk"")) == (0l));
    }

}
"
HumanEval_92,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ    //ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⴼⵉⵔⴰⵙ ⵜⵉⵣⴳⴰⵍⵉⵏ ⴳ ⴽⵔⴰ ⵏ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏ.    //ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵢⴰⵏ ⴳ ⵡⵓⵟⵟⵓⵏⵏ ⴰⵎⵎ ⵓⴳⵣⵓⵎ ⵏ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵢⴰⴹⵏ, ⴷ ⵡⵓⵟⵟⵓⵏ ⴰⴽⴽⵡ ⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ.    //ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏ.    // >>> anyInt(5l, 2l, 7l)
    // (true)
    // >>> anyInt(3l, 2l, 2l)
    // (false)
    // >>> anyInt(3l, -2l, 1l)
    // (true)
    // >>> anyInt((3.6f), (-2.2f), 2l)
    // (false)
    def anyInt(x : Float, y : Float, z : Float) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Create a function that takes 3 numbers.
  // Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
  // Returns false in any other cases.
  def anyInt(x: Float, y: Float, z: Float): Boolean = {
    val xLong = x.toLong
    val yLong = y.toLong
    val zLong = z.toLong

    // Check if all inputs are actually integers
    if (xLong == x && yLong == y && zLong == z) {
      return xLong + yLong == zLong || xLong + zLong == yLong || yLong + zLong == xLong
    }
    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(anyInt(2l, 3l, 1l) == (true));
    assert(anyInt((2.5f), 2l, 3l) == (false));
    assert(anyInt((1.5f), 5l, (3.5f)) == (false));
    assert(anyInt(2l, 6l, 2l) == (false));
    assert(anyInt(4l, 2l, 2l) == (true));
    assert(anyInt((2.2f), (2.2f), (2.2f)) == (false));
    assert(anyInt(-4l, 6l, 2l) == (true));
    assert(anyInt(2l, 1l, 1l) == (true));
    assert(anyInt(3l, 4l, 7l) == (true));
    assert(anyInt((3.0f), 4l, 7l) == (false));
    }

}
"
HumanEval_93,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⵔⵂⴰ ⴰⴷ ⴰⴾⵜⴰⴱⴰⵏ ⴾⴰⵔⵜⵉ ⵜⴰⵏ    //ⴰⵛⵛⵉⵍ ⴷⴰⵗ ⴰⵍⴾⴰⴷ ⵓⴰⵏ ⴰⵏⴶⵍⵉⵣ    //ⵜⴰⴱⵔⴰⵜ ⵙ ⵜⴱⵔⴰⵜ ⵏⵏⴰ ⵉⵜⵜⵉⵍⵉⵏ ⵙⵏⴰⵜ ⵏ ⵡⴰⵏⵙⴰⵢⵏ ⴷⴰⵜ ⵏ ⵜⴱⵔⴰⵜ     //ⴷⴰ ⵉⵜⵜⵎⵓⵜⵜⴰⵢ ⵡⴰⵏⴰⵡ ⵏ ⵡⴰⵔⵔⴰⵜⵏ, ⴷⴰ ⵉⵜⵜⵎⵓⵜⵜⴰⵢ ⴽⵓⵍⵍⵓ ⵉⵎⵙⵍⵉ ⴳ     //ⵔⵔⴰⵎ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⴰⵔ ⵉⵜⵜⵓⵣⵎⵎⴻⵎ ⴳ     // >>> encode((""test""))
    // (""TGST"")
    // >>> encode((""This is a message""))
    // (""tHKS KS C MGSSCGG"")
    def encode(message : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def encode(message: String): String = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    val vowelMap = Map(
      'a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w',
      'A' -> 'C', 'E' -> 'G', 'I' -> 'K', 'O' -> 'Q', 'U' -> 'W'
    )
    
    message.map { char =>
      if (vowels.contains(char)) {
        vowelMap(char)
      } else if (char.isLetter) {
        if (char.isLower) char.toUpper else char.toLower
      } else {
        char
      }
    }.mkString
  }

  // Test cases
  def main(args: Array[String]): Unit = {
    println(encode(""test""))            // should print ""TGST""
    println(encode(""This is a message"")) // should print ""tHKS KS C MGSSCGG""
  }
}","    }
    def main(args: Array[String]) = {
    assert(encode((""TEST"")).equals((""tgst"")));
    assert(encode((""Mudasir"")).equals((""mWDCSKR"")));
    assert(encode((""YES"")).equals((""ygs"")));
    assert(encode((""This is a message"")).equals((""tHKS KS C MGSSCGG"")));
    assert(encode((""I DoNt KnOw WhAt tO WrItE"")).equals((""k dQnT kNqW wHcT Tq wRkTg"")));
    }

}
"
HumanEval_94,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵏⴰⴼ ⴰⵜⵉⴳ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ, ⴷ ⴰⴷ ⵏⵔⴰⵔ ⵜⴰⴳⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ.    //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ.    // >>> skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))
    // (10l)
    // >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))
    // (25l)
    // >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong)))
    // (13l)
    // >>> skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))
    // (11l)
    // >>> skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong)))
    // (3l)
    // >>> skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong)))
    // (7l)
    def skjkasdkd(lst : List[Long]) : Long = {
","def skjkasdkd(lst: List[Long]): Long = {
  def isPrime(n: Long): Boolean = {
    if (n <= 1) false
    else if (n == 2) true
    else if (n % 2 == 0) false
    else !(3L to math.sqrt(n).toLong by 2).exists(n % _ == 0)
  }

  def sumOfDigits(n: Long): Long = n.toString.map(_.asDigit).sum

  val largestPrime = lst.filter(isPrime).sorted.lastOption.getOrElse(0L)
  sumOfDigits(largestPrime)
}","    }
    def main(args: Array[String]) = {
    assert(skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong))) == (10l));
    assert(skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong))) == (25l));
    assert(skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong))) == (13l));
    assert(skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong))) == (11l));
    assert(skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong))) == (3l));
    assert(skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong))) == (7l));
    assert(skjkasdkd((List[Long](8191l.toLong))) == (19l));
    assert(skjkasdkd((List[Long](8191l.toLong, 123456l.toLong, 127l.toLong, 7l.toLong))) == (19l));
    assert(skjkasdkd((List[Long](127l.toLong, 97l.toLong, 8192l.toLong))) == (10l));
    }

}
"
HumanEval_95,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ ⵀⴰⵜ    //ⵎⴽ ⵓⵔ ⵉⴳⵉ ⴽⵓⵍⵍⵓ ⵉⵙⵍⴽⵉⵏ ⵜⵉⵙⴳⵓⵔⵉⵡⵉⵏ ⴳ ⵜⵉⵙⴳⵓⵔⵉⵡⵉⵏ ⵜⵉⵅⴰⵜⴰⵔⵉⵏ, ⵔⴰⴷ ⵢⴰⴽⵡⵣ false.    //ⵎⴽ ⵜⵍⵍⴰ ⵜⴽⴰⵕⴹⴰ, ⴰⵔ ⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⴳⴰⵏ ⴽⵓⵍⵍⵓ ⵜⵉⵙⵍⵉⵜⵉⵏ ⵜⵉⵙⵉⴹⴼⴰⵏⵉⵏ ⴳ     // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", ""b"" -> ""banana"")))
    // (true)
    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", ""A"" -> ""banana"", ""B"" -> ""banana"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", 8l -> ""banana"", ""a"" -> ""apple"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""Name"" -> ""John"", ""Age"" -> ""36"", ""City"" -> ""Houston"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""STATE"" -> ""NC"", ""ZIP"" -> ""12345"")))
    // (true)
    def checkDictCase(dict : Map[String,String]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def checkDictCase(dict: Map[String, String]): Boolean = {
    if (dict.isEmpty) return false

    val keys = dict.keys.toList
    val allLowerCase = keys.forall(key => key == key.toLowerCase)
    val allUpperCase = keys.forall(key => key == key.toUpperCase)

    allLowerCase || allUpperCase
  }
}","    }
    def main(args: Array[String]) = {
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""b"" -> ""banana""))) == (true));
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""A"" -> ""banana"", ""B"" -> ""banana""))) == (false));
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""5"" -> ""banana"", ""a"" -> ""apple""))) == (false));
    assert(checkDictCase((Map[String,String](""Name"" -> ""John"", ""Age"" -> ""36"", ""City"" -> ""Houston""))) == (false));
    assert(checkDictCase((Map[String,String](""STATE"" -> ""NC"", ""ZIP"" -> ""12345""))) == (true));
    assert(checkDictCase((Map[String,String](""fruit"" -> ""Orange"", ""taste"" -> ""Sweet""))) == (true));
    assert(checkDictCase((Map[String,String]())) == (false));
    }

}
"
HumanEval_96,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴷ ⵡⵉⵏ ⵡⴰⵔ n.     //ⵙⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⴳⵉⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ n     // >>> countUpTo((5l))
    // (List[Long](2l.toLong, 3l.toLong))
    // >>> countUpTo((11l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))
    // >>> countUpTo((0l))
    // (List[Long]())
    // >>> countUpTo((20l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))
    // >>> countUpTo((1l))
    // (List[Long]())
    // >>> countUpTo((18l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))
    def countUpTo(n : Long) : List[Long] = {
","def countUpTo(n: Long): List[Long] = {
    def isPrime(num: Long): Boolean = {
      if (num < 2) return false
      for (i <- 2L to math.sqrt(num).toLong) {
        if (num % i == 0) return false
      }
      true
    }

    (2L until n).filter(isPrime).map(_.toLong).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));
    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));
    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));
    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));
    assert(countUpTo((0l)).equals((List[Long]())));
    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));
    assert(countUpTo((1l)).equals((List[Long]())));
    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));
    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));
    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));
    }

}
"
HumanEval_97,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⴰⵜⵉⵏⴰⵣⴶⴰⵎ ⴰⵙ ⵉⴾⵉ ⵏⴰⴾⴰⵛⴰⴷ ⴰⵈⴰⵍ ⴰⴶⵓⴷⵉⵉⴰⵏ ⴰⵗⴰⵍ.    //ⴰⵎⵢⴰⴼⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴰⴳⵣⵣⵓⵎⵜ ⵏⵏⵙⵏ.    //ⵜⵢⵎⵎⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ     // >>> multiply((148l), (412l))
    // (16l)
    // >>> multiply((19l), (28l))
    // (72l)
    // >>> multiply((2020l), (1851l))
    // (0l)
    // >>> multiply((14l), (-15l))
    // (20l)
    def multiply(a : Long, b : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def multiply(a: Long, b: Long): Long = {
        val unitDigitA = abs(a % 10)
        val unitDigitB = abs(b % 10)
        unitDigitA * unitDigitB
    }

    def main(args: Array[String]): Unit = {
        println(multiply(148l, 412l))  // 16l
        println(multiply(19l, 28l))    // 72l
        println(multiply(2020l, 1851l)) // 0l
        println(multiply(14l, -15l))   // 20l
    }
}","    }
    def main(args: Array[String]) = {
    assert(multiply((148l), (412l)) == (16l));
    assert(multiply((19l), (28l)) == (72l));
    assert(multiply((2020l), (1851l)) == (0l));
    assert(multiply((14l), (-15l)) == (20l));
    assert(multiply((76l), (67l)) == (42l));
    assert(multiply((17l), (27l)) == (49l));
    assert(multiply((0l), (1l)) == (0l));
    assert(multiply((0l), (0l)) == (0l));
    }

}
"
HumanEval_98,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⵙ ⵜⵉⴼⵉⴼⵉ ⵏ ⵜⵉⴼⵉⵏⴰⵖ s, ⵔⵎⵙⵏ ⴰⵎⴹⴰⵏ ⵏ ⵉⵎⵙⵍⵉⵢⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ.     // >>> countUpper((""aBCdEf""))
    // (1l)
    // >>> countUpper((""abcdefg""))
    // (0l)
    // >>> countUpper((""dBBE""))
    // (0l)
    def countUpper(s : String) : Long = {
","def countUpper(s: String): Long = {
  val uppercaseVowels = Set('A', 'E', 'I', 'O', 'U')
  s.zipWithIndex.collect {
    case (ch, index) if index % 2 == 0 && uppercaseVowels.contains(ch) => ch
  }.size.toLong
}","    }
    def main(args: Array[String]) = {
    assert(countUpper((""aBCdEf"")) == (1l));
    assert(countUpper((""abcdefg"")) == (0l));
    assert(countUpper((""dBBE"")) == (0l));
    assert(countUpper((""B"")) == (0l));
    assert(countUpper((""U"")) == (1l));
    assert(countUpper(("""")) == (0l));
    assert(countUpper((""EEEE"")) == (2l));
    }

}
"
HumanEval_99,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ    //ⵙⴳ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴷⵓⵏ ⵙⴳ ⵓⵎⵢⴰ.    //ⴰⵔ ⵉⵜⵜⴰⴷⴼ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵉⵔⵉⵡ ⴰⴽⴽⵡ ⵉⵎⵉⵔⵉⵡⵏ. ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵉⵔⵉⵡ ⴰⵎⵣⴰⵔⴰⵢ     //ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵡⴰⵜⵉⴳ (ⵜⴰⵙⵉⵔⵜ) ⵉⵙⵎⴷⵢⴰⵏ ⴰⵎⴹⴰⵏ     // >>> closestInteger((""10""))
    // (10l)
    // >>> closestInteger((""15.3""))
    // (15l)
    // Note:
    // Rounding away from zero means that if the given number is equidistant
    // from two integers, the one you should return is the one that is the
    // farthest from zero. For example closest_integer(""14.5"") should
    // return 15 and closest_integer(""-14.5"") should return -15.
    def closestInteger(value : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def closestInteger(value: String): Long = {
    val num = value.toDouble
    val lower = floor(num).toLong
    val upper = ceil(num).toLong
    
    if (abs(num - lower) == abs(num - upper)) {
      if (num > 0) upper else lower
    } else {
      round(num)
    }
  }

  def main(args: Array[String]): Unit = {
    println(closestInteger(""10""))  // 10
    println(closestInteger(""15.3"")) // 15
    println(closestInteger(""14.5"")) // 15
    println(closestInteger(""-14.5"")) // -15
  }
}","    }
    def main(args: Array[String]) = {
    assert(closestInteger((""10"")) == (10l));
    assert(closestInteger((""14.5"")) == (15l));
    assert(closestInteger((""-15.5"")) == (-16l));
    assert(closestInteger((""15.3"")) == (15l));
    assert(closestInteger((""0"")) == (0l));
    }

}
"
HumanEval_100,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //i ⴰⵎⵓⵙ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⵉⵂⵓⴾⴰⵏ ⴷⴰⵗ ⵢⴷⴰⴶ ⵓⴰⵏ (ⵉ+1)    //ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵊⴷⴷⵉⴳⵏ ⴳ ⴽⵓ ⴰⵙⵡⵉⵔ ⴳ ⵜⵍⴳⴰⵎⵜ, ⴳ ⵉⵍⵍⴰ ⵉⴼⵔⴷⵉⵙ ⴳ ⵓⵙⵏⵎⵍ     //- ⴰⵎⴹⴰⵏ ⴰⵎⵎⵓⵟⵟⵓⵏ ⴰⵎⵎⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵉⴳ n ⴰⵎⵎⵓⵟⵟⵓⵏ.     //- ⴰⵎⴹⴰⵏ ⴰⵎⵣⴰⵔⴰⵢ ⴰⵎⴹⴰⵏ ⴰⵎⵣⴰⵔⴰⵢ ⵉⴳ n ⴰⵎⵣⴰⵔⴰⵢ.     //ⵓⵉ-ⴷ-ⵉⵍⵍⴰⵏ ⴷⴰⵗ ⵜⴰⵂⵔⵉⴾⴻ ⵜⴰⵏ ⵙⴰⵏⴰⵜⴰⵜⴰⵜ ⴰⵎⵓⵙⴰⵏ:    //ⴰⵙⵉⵔⵜⴰⵉ ⵓⴰ ⵢⵣⵣⴰⵔⴰⵏ ⵉⵍⴰ N ⵉⵂⴰⵏⴷⴰⴶⴰⵏ    //ⵎⴽ ⴷ ⵢⴰⴽⴽⴰ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔ ⵢⴰⵜ ⵜⵔⴱⴰⵜ ⵏ n ⵉⵙⵡⵉⵔⵏ ⵏ ⵉⵅⵅⴰⵏⵏ.    // >>> makeAPile((3l))
    // (List[Long](3l.toLong, 5l.toLong, 7l.toLong))
    def makeAPile(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
    def makeAPile(n: Long): List[Long] = {
        val pile = ListBuffer[Long]()
        var currentStones = n
        for (_ <- 0 until n.toInt) {
            pile += currentStones
            currentStones += (if (currentStones % 2 == 0) 2 else 2)
        }
        pile.toList
    }

    def main(args: Array[String]): Unit = {
        val result = makeAPile(3L)
        println(result)
    }
}","    }
    def main(args: Array[String]) = {
    assert(makeAPile((3l)).equals((List[Long](3l.toLong, 5l.toLong, 7l.toLong))));
    assert(makeAPile((4l)).equals((List[Long](4l.toLong, 6l.toLong, 8l.toLong, 10l.toLong))));
    assert(makeAPile((5l)).equals((List[Long](5l.toLong, 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));
    assert(makeAPile((6l)).equals((List[Long](6l.toLong, 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));
    assert(makeAPile((8l)).equals((List[Long](8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));
    }

}
"
HumanEval_101,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⴰⴷ ⵜⴱⴹⵓ ⵜⵉⴼⵉⵏⴰⵖ ⵖⵔ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ.    //ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⵢⵈⵈⵉⵍ ⴾⵢⵍ ⵉⵙⵎⴰⵓⴰⵏ ⴰⵋⵋⵓⵜⵏⵢⵏ ⵉⵋⵋⴰⵏⵢⵏ ⵙ ⵛⵓⵎⴰ ⵜⴰⵏ ⵎⵢⵗ ⵙⴱⵢⵛⵢⵙ ⵜⴰⵏ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ    // >>> wordsString((""Hi, my name is John""))
    // (List[String](""Hi"", ""my"", ""name"", ""is"", ""John""))
    // >>> wordsString((""One, two, three, four, five, six""))
    // (List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))
    def wordsString(s : String) : List[String] = {
","def wordsString(s: String): List[String] = {
    s.split(""[, ]+"").toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(wordsString((""Hi, my name is John"")).equals((List[String](""Hi"", ""my"", ""name"", ""is"", ""John""))));
    assert(wordsString((""One, two, three, four, five, six"")).equals((List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))));
    assert(wordsString((""Hi, my name"")).equals((List[String](""Hi"", ""my"", ""name""))));
    assert(wordsString((""One,, two, three, four, five, six,"")).equals((List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))));
    assert(wordsString(("""")).equals((List[String]())));
    assert(wordsString((""ahmed     , gamal"")).equals((List[String](""ahmed"", ""gamal""))));
    }

}
"
HumanEval_102,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⵓⵔ ⵉⵍⵍⵉ ⵡⵓⵟⵟⵓⵏ ⴰⴷ, ⵇⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ -1.    //ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵇⵇⵔⴰⵏ ⴳ ⵓⵎⵣⴰⵔⴰⵢ [x, y] ⴳ ⵜⵓⵎⵣⵉⵏ. ⵎⴽ     //ⴷⴰ ⵜⴽⴽⴰ ⵜⵎⵔⵙⵜ ⴰⴷ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵃⵍⴰⵏ x ⴷ y ⴰⵔ ⵜⵔⴰⵔ     // >>> chooseNum((12l), (15l))
    // (14l)
    // >>> chooseNum((13l), (12l))
    // (-1l)
    def chooseNum(x : Long, y : Long) : Long = {
","def chooseNum(x: Long, y: Long): Long = {
    // Ensure x is the lesser value and y is the greater value
    val (start, end) = if (x > y) (y, x) else (x, y)
    
    // Start from the end of the range and search backwards for an even number
    for (i <- end to start by -1 if i % 2 == 0) {
      return i
    }
    
    // If no even number is found, return -1
    -1
  }
}","    }
    def main(args: Array[String]) = {
    assert(chooseNum((12l), (15l)) == (14l));
    assert(chooseNum((13l), (12l)) == (-1l));
    assert(chooseNum((33l), (12354l)) == (12354l));
    assert(chooseNum((5234l), (5233l)) == (-1l));
    assert(chooseNum((6l), (29l)) == (28l));
    assert(chooseNum((27l), (10l)) == (-1l));
    assert(chooseNum((7l), (7l)) == (-1l));
    assert(chooseNum((546l), (546l)) == (546l));
    }

}
"
HumanEval_103,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //ⵎⴽ ⵜⴳⴰ n ⴰⵅⴰⵜⴰⵔ ⵙⴳ m, ⵔⵔⵓⵜⵓⵔ -1.    //ⵔⵓⵏⴷ ⵜⵔⴰⵔⵓⵜ ⵖⵔ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵉⴹⴰⵏ ⴷ ⵜⵙⵏⴼⵍ ⵖⵔ ⴱⵉⵏⴰⵔⵉ.    //ⴰⵎⵎⴰⵙⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙⴳ n ⴰⵔ m (ⴰⵎⵓⵏ ⴷ n ⴷ m).    //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ n ⴷ m, ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵉⵟⵏ     // >>> roundedAvg((1l), (5l))
    // ""0b11""
    // >>> roundedAvg((7l), (5l))
    // -1l
    // >>> roundedAvg((10l), (20l))
    // ""0b1111""
    // >>> roundedAvg((20l), (33l))
    // ""0b11010""
    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
  // Function to compute the average of the integers from n through m
  def roundedAvg(n: Long, m: Long): Either[String, Long] = {
    if (n > m) {
      Right(-1L)
    } else {
      val count = m - n + 1
      val sum = (n + m) * count / 2
      val average = round(sum.toDouble / count)
      Left(""0b"" + average.toLong.toBinaryString)
    }
  }

  def main(args: Array[String]): Unit = {
    println(roundedAvg(1L, 5L))    // Left(""0b11"")
    println(roundedAvg(7L, 5L))    // Right(-1L)
    println(roundedAvg(10L, 20L))  // Left(""0b1111"")
    println(roundedAvg(20L, 33L))  // Left(""0b11010"")
  }
}","    }
    def main(args: Array[String]) = {
    assert(roundedAvg((1l), (5l)).equals(""0b11""));
    assert(roundedAvg((7l), (13l)).equals(""0b1010""));
    assert(roundedAvg((964l), (977l)).equals(""0b1111001010""));
    assert(roundedAvg((996l), (997l)).equals(""0b1111100100""));
    assert(roundedAvg((560l), (851l)).equals(""0b1011000010""));
    assert(roundedAvg((185l), (546l)).equals(""0b101101110""));
    assert(roundedAvg((362l), (496l)).equals(""0b110101101""));
    assert(roundedAvg((350l), (902l)).equals(""0b1001110010""));
    assert(roundedAvg((197l), (233l)).equals(""0b11010111""));
    assert(roundedAvg((7l), (5l)).equals(-1l));
    assert(roundedAvg((5l), (1l)).equals(-1l));
    assert(roundedAvg((5l), (5l)).equals(""0b101""));
    }

}
"
HumanEval_104,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⴰⵜⵓⵉⵙⵙⴰⵎ: ⵍⵉⵙⵜ ⵉⴾⴼⴰⵏ ⴰⴷ ⴰⵜⵓⴰⵣⴰⵉ ⴷⴰⵗ ⴰⵍⴾⴰⴷ ⵓⴰ ⵙ ⵉⵋⵋⴰ ⵢⴼⵢⵙ    //ⵉⴼⵔⴷⵉⵙⵏ ⵓⵔ ⵉⵍⵉⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ.    //ⴳ ⵓⵎⵉⴹⴰⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴽⵙⵡⴰⵜⵏ x, ⵔⴰⵏⵜⵔ ⵢⴰⵜ ⵜⵍⴳⴰⵎⵜ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵏ ⴽⵓⵍⵍⵓ     // >>> uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong)))
    // (List[Long](1l.toLong, 15l.toLong, 33l.toLong))
    // >>> uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong)))
    // (List[Long]())
    def uniqueDigits(x : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def uniqueDigits(x: List[Long]): List[Long] = {
    def hasEvenDigit(n: Long): Boolean = {
      n.toString.exists(c => (c - '0') % 2 == 0)
    }

    x.filterNot(hasEvenDigit).sorted
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(uniqueDigits(List[Long](15L, 33L, 1422L, 1L)))
    println(uniqueDigits(List[Long](152L, 323L, 1422L, 10L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 15l.toLong, 33l.toLong))));
    assert(uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong))).equals((List[Long]())));
    assert(uniqueDigits((List[Long](12345l.toLong, 2033l.toLong, 111l.toLong, 151l.toLong))).equals((List[Long](111l.toLong, 151l.toLong))));
    assert(uniqueDigits((List[Long](135l.toLong, 103l.toLong, 31l.toLong))).equals((List[Long](31l.toLong, 135l.toLong))));
    }

}
"
HumanEval_105,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //""ⵢⵉⴰⵏ"", ""ⵉⵏⵏⴰ"", ""ⵜⵕⴰⴹ"", ""ⴽⵓⵥ"", ""ⵎⵎⵓⵙ"", ""ⵙⴹⵉⵙ"", ""ⴰⵙⵙⴰ"", ""ⵜⴰⵎⵔⴰⵡ"".     //ⵔⵔⵣⵓ ⵏ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ, ⴷ ⴼⴼⵉⵔ ⴰⴷ ⵙⵏⴼⵍ ⴽⵓ ⵓⵟⵟⵓⵏ ⵙ ⵢⵉⵙⵎ ⵏⵏⵙ ⵙⴳ     //ⴹⴼⵕⵏ ⴰⵙⵍⵎ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴷⵙ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳⵔ 1 ⴷ 9 ⴳ ⵢⴰⵎⵓⵏ,     // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))
    // (List[String](""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""))
    // If the list is empty, return an empty list:
    // >>> byLength((List[Long]()))
    // (List[String]())
    // If the list has any strange number ignore it:
    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))
    // (List[String](""One""))
    def byLength(arr : List[Long]) : List[String] = {
","import scala.collection.mutable._

object Problem {
  def byLength(arr: List[Long]): List[String] = {
    // Map of digit to its corresponding name
    val numToName = Map(
      1L -> ""One"",
      2L -> ""Two"",
      3L -> ""Three"",
      4L -> ""Four"",
      5L -> ""Five"",
      6L -> ""Six"",
      7L -> ""Seven"",
      8L -> ""Eight"",
      9L -> ""Nine""
    )

    // Filter numbers between 1 and 9
    val filteredAndSorted = arr.filter(num => num >= 1 && num <= 9).sorted(Ordering[Long].reverse)
    // Map filtered and sorted numbers to their corresponding names
    filteredAndSorted.map(numToName)
  }
}","    }
    def main(args: Array[String]) = {
    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""))));
    assert(byLength((List[Long]())).equals((List[String]())));
    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](""One""))));
    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](""Three"", ""Two"", ""One""))));
    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](""Nine"", ""Eight"", ""Four""))));
    }

}
"
HumanEval_106,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //ⵉⴳⴰ ⵓⴼⴰⴽⵜⵓⵔⵢⴰⵍ ⵏ ""ⵉ"" ⴰⵙⴼⵓⴽⵍⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ 1 ⴰⵔ ""ⵉ"" (1 * 2 * ... * ""ⵉ"").    //ⵔⴰⴷ ⵙⵏⵜⵉ ⵙⴳ 1.    //ⵏⵖⴷ ⵜⴳⵎⵉⴹⵉ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ 1 ⴰⵔ i.     //ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵡⵓⵟⵟⵓⵏ n, ⵣⵓⵏⴷ ⵎⴰⵙⴷ ⴰⵜⵉⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵙⵖⵍ i ⵉⴳⴰ ⵜⴰⴳⴳⴰⵢⵜ ⵏ i ⵎⴽ ⵜⴳⴰ i     //ⵙⵙⵎⵔⵙ ⵜⴰⵡⵓⵔⵉ f ⵏⵏⴰ ⵢⵓⵎⵥⵏ n ⴰⵎⵎ ⵓⵎⵙⴽⴰⵔ,     // >>> f((5l))
    // (List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))
    def f(n : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def f(n: Long): List[Long] = {
        def factorial(x: Long): Long = if (x == 0) 1 else x * factorial(x - 1)
        
        (1L to n).map { i =>
            if (i % 2 == 0) factorial(i) else (1L to i).sum
        }.toList
    }
}","    }
    def main(args: Array[String]) = {
    assert(f((5l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))));
    assert(f((7l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong, 720l.toLong, 28l.toLong))));
    assert(f((1l)).equals((List[Long](1l.toLong))));
    assert(f((3l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong))));
    }

}
"
HumanEval_107,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ 1:    //ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏⵜ ⵜⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵎⵎⴰⵙ ((1, n), ⴳ ⵜⴰⵎⵎⵏⵜ.    //ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵙⴽⵛⵎ ⵜⴰⴱⵍⵍⵜ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵉⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷ ⵉⵎⵣⴰⵔⴰⵢⵏ     // >>> evenOddPalindrome((3l))
    // ((1l, 2l))
    // Explanation:
    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
    // Example 2:
    // >>> evenOddPalindrome((12l))
    // ((4l, 6l))
    // Explanation:
    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
    // Note:
    // 1. 1 <= n <= 10^3
    // 2. returned tuple has the number of even and odd integer palindromes respectively.
    def evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {
","def evenOddPalindrome(n: Long): (Long, Long) = {
  def isPalindrome(x: Long): Boolean = {
    val str = x.toString
    str == str.reverse
  }

  var evenCount: Long = 0
  var oddCount: Long = 0

  for (i <- 1L to n) {
    if (isPalindrome(i)) {
      if (i % 2 == 0) evenCount += 1
      else oddCount += 1
    }
  }

  (evenCount, oddCount)
}","    }
    def main(args: Array[String]) = {
    assert(evenOddPalindrome((123l)).equals(((8l, 13l))));
    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));
    assert(evenOddPalindrome((3l)).equals(((1l, 2l))));
    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));
    assert(evenOddPalindrome((25l)).equals(((5l, 6l))));
    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));
    assert(evenOddPalindrome((9l)).equals(((4l, 5l))));
    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));
    }

}
"
HumanEval_108,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ -123 ⵉⵍⴰ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ -1, 2, ⴷ 3.     //ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⵎⴳⵓⵔ, ⵔⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵏ ⵜⴱⵔⴰⵜ ⵏⵏⵙ ⴰⵎⴳⵓⵔ:    //ⴰⵎⴹⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ > 0.     //ⵔⵔⴰⵎ ⵜⴰⵡⵓⵔⵉ count_nums ⵏⵏⴰ ⵉⵜⵜⵓⵎⵉ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴰ     // >>> countNums((List[Long]()))
    // (0l)
    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))
    // (1l)
    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))
    // (3l)
    def countNums(arr : List[Long]) : Long = {
","def countNums(arr: List[Long]): Long = {
  arr.count(num => {
    val sumOfDigits = num.toString.foldLeft(0) { (acc, char) =>
      if (char == '-') acc else acc + (char - '0')
    }
    sumOfDigits > 0
  }).toLong
}","    }
    def main(args: Array[String]) = {
    assert(countNums((List[Long]())) == (0l));
    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));
    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));
    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));
    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));
    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));
    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));
    assert(countNums((List[Long](1l.toLong))) == (1l));
    }

}
"
HumanEval_109,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⴰⵜⵓⵉⵣⴶⴰⵔ: ⴰⵍⴾⴰⴷ ⵓⴰ ⵉⴾⴼⴰⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏ ⴰⵍⴰⵙⴰⵍ    //ⵎⴽ ⵉⴳⴰ ⵡⴰⵔⵔⴰ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵉⵔⵡⵍ true.     //ⴹⴰⵕⵜ ⵓⵢⴰ ⵔⴰⴷ ⴷ-ⵜⵓⵖⴰⵍ ⵜⵉⴷⵜ ⵏⵖ ⵔⴰⴷ ⴷ-ⵜⵓⵖⴰⵍ ⵜⵉⴱⵔⵙⴳⴳⵡⴰⴷⵜ.    //ⵉⵖ ⵜⵣⵎⵔⵎ ⴰⴷ ⵜⴰⵡⵉ ⵜⵍⴳⴰⵎⵜ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵜⵉⴳⴳⵉ ⵏ ⵜⵎⵀⵍⴰ ⵏ ⴰⴼⵍⵍⴰ     //ⵜⵉⵜⴱⴰⵈⴻⵜ ⵜⴰⵏ ⵜⵉⵣⴰⵔⴰⵜ ⴷⴰⵗ ⴰⵍⴾⴰⴷ ⵓⴰ ⵙ ⵉⵜⴰⵓⴰⵏ 0ⵜⵂ ⵉⵏⴷⴻⵆ    //ⴰⴷⴷⴰⴱⴰⵔⴰ ⵏ ⵓⵛⵔⴰⵉ ⵏ ⵜⵢⵍⵉⵜ ⴰⴷ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⵓ ⵙ     //ⵜⵉⵎⴰⵜⵜⴰⴳⵜ ⵏ ⵓⵙⵙⴼⵍⴷ ⵙ ⵓⵣⵔⴼ ⵜⵔⵏⴰ ⴰⵙⴼⵍⴷ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵜⵍⴳⴰⵎⵜ ⵙ ⵢⴰⵏ.    //ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⴽⵔⵎ ⵜⵉⴳⴳⵉⵜ ⵏ ⵓⵙⵏⴼⵍ ⵙ ⵓⵣⵔⴼ ⴽⵉⴳⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ.    //ⵜⵉⴳⴳⵉⵜ ⴰⴷ ⴳ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ ⴷ ⵉⴼⴽⴰⵏ:     //ⵉⵖⵢ ⴰⴷ ⵜⵢⵉⵍⵉ ⵜⵍⴳⴰⵎⵜ ⵙ ⵓⵙⵍⴳⵏ ⵓⵔ ⵉⴷⵔⵓⵙⵏ ⵙ ⵓⴽⵓⴷ ⵏ ⵓⵙⴽⴰⵔ ⵏ     //ⴹⵉⴱⵉⵜⵉⵓⵔ ⵜⴰⵏ ⵓⵉⵏ ⵜⵢⵎⵢⴷⵜ ⴰⴷ ⴰⵈⵈⵉⵍⴰⵏ ⵙ ⴰⵍⵆⴰⵍ    //ⵖⵓⵔⵖ ⵜⴰⵍⴳⴰⵎⵜ 'ⴰⵔⵔ' ⵏ N ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ arr[1], arr[2], ..., arr[N].    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))
    // (true)
    // Explanation: By performin 2 right shift operations, non-decreasing order can
    // be achieved for the given list.
    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong)))
    // (false)
    // Explanation:It is not possible to get non-decreasing order for the given
    // list by performing any number of right shift operations.
    def moveOneBall(arr : List[Long]) : Boolean = {
","def moveOneBall(arr: List[Long]): Boolean = {
  if (arr.isEmpty) return true

  // Find how many times the array needs to be shifted to become sorted
  val n = arr.length
  var shiftIndex = -1

  for (i <- 0 until n) {
    if (arr(i) > arr((i + 1) % n)) {
      // More than one place where the order breaks means it can't be sorted with a shift
      if (shiftIndex != -1) return false
      shiftIndex = i + 1
    }
  }

  // If no break in order was found, the array is already sorted
  if (shiftIndex == -1) return true

  // Check if shifting by the found index sorts the array
  for (i <- 1 until n) {
    if (arr((shiftIndex + i) % n) < arr((shiftIndex + i - 1) % n)) return false
  }
  
  true
}","    }
    def main(args: Array[String]) = {
    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));
    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));
    assert(moveOneBall((List[Long](4l.toLong, 3l.toLong, 1l.toLong, 2l.toLong))) == (false));
    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));
    assert(moveOneBall((List[Long]())) == (true));
    }

}
"
HumanEval_110,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⵎⴽ ⵓⵔ ⵜⵍⵍⵉ, ⵙⵓⵍ ""ⵓⵀⵓ"".    //ⵎⴰⵔ ⴰⴷ ⴳⵉⵏ ⴰⴽⴽⵡ ⵉⴼⵔⴷⵉⵙⵏ ⵏ lst1 ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵙⵙⴽⵔ ""YES"".    //ⵉⵖ ⵜⵣⵎⵔⵎ ⴰⴷ ⵏⵙⵎⵓⵜⵜⵔ ⵉⴼⵔⴷⵉⵙⵏ ⴳⵔ lst1 ⴷ lst2 ⵃⵎⴰ ⴰⴷ ⵏⵙⴽⵔ     //ⵓⵔ ⵉⵍⵍⵉ ⵓⵜⵜⵓ ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴳⵔ lst1 ⴷ lst2.    //ⵔⴰⵔⵏ ⴰⵙⵏⵎⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ     //ⴷ ⴷⴰ ⵉⵜⵜⵉⵔⵉ ⵎⴰⵢⴷ ⵉⵥⴹⴰⵕ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵉⴼⵔⴷⵉⵙⵏ     //ⴳ ⵜⵎⵓⴽⵔⵉⵙⵜ ⴰⴷ, ⵔⴰⴷ ⵜⵙⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵙⵏⴰⵜ ⵜⵍⴳⴰⵎⵉⵏ ⵏ ⵡⵓⵟⵟⵓⵏ,     // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (""YES"")
    // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))
    // (""NO"")
    // It is assumed that the input lists will be non-empty.
    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def exchange(lst1: List[Long], lst2: List[Long]): String = {
    // Check if all elements in lst1 are already even
    if (lst1.forall(_ % 2 == 0)) return ""YES""

    // Find if there's any even number in lst2 to exchange with lst1
    val lst2EvensExist = lst2.exists(_ % 2 == 0)

    // Check if there's also at least one odd in lst1 to swap it out
    val lst1OddsExist = lst1.exists(_ % 2 != 0)

    // Only possible if both an even element in lst2 and an odd element in lst1 exist
    if (lst2EvensExist && lst1OddsExist) ""YES"" else ""NO""
  }
}","    }
    def main(args: Array[String]) = {
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((""YES"")));
    }

}
"
HumanEval_111,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //ⵎⴽ ⴳⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉ ⵜⵉⴽⴽⵉ ⵢⴰⵜ, ⵔⵎⵙⵏ ⴰⴽⴽⵡ.    //ⵏ ⵜⴰⴱⵔⴰⵜ ⵏⵏⴰ ⵉⵜⵜⵓⵢⴰⵍⵙⵏ ⴽⵉⴳⴰⵏ ⴷ ⵉⵍⵍⴰ ⴳⵉⵙ ⵓⵟⵟⵓⵏ ⵏ ⵜⴱⵔⴰⵜ ⵏⵏⴰ ⵉⵇⵇⵏⵏ ⴰⴽⴷ ⵜⴱⵔⴰⵜ.    //ⵎⴽ ⵜⵍⵍⴰ ⵜⴰⵡⵉⵍⴰ ⵉⵙⵎⴷⵢⴰⵏ ⵜⵉⵔⵔⴰ ⵜⵉⵎⵥⵥⵢⴰⵏⵉⵏ ⵉⵜⵜⵢⴰⴼⴰⵏ ⵙ ⵜⵉⴽⵍⵉⵜ, ⵙⵙⵓⴼⵖ ⵜⴰⴽⴰⵕⴹⴰ     // >>> histogram((""a b c""))
    // (Map[String,Long](""a"" -> 1l, ""b"" -> 1l, ""c"" -> 1l))
    // >>> histogram((""a b b a""))
    // (Map[String,Long](""a"" -> 2l, ""b"" -> 2l))
    // >>> histogram((""a b c a b""))
    // (Map[String,Long](""a"" -> 2l, ""b"" -> 2l))
    // >>> histogram((""b b b b a""))
    // (Map[String,Long](""b"" -> 4l))
    // >>> histogram((""""))
    // (Map[String,Long]())
    def histogram(test : String) : Map[String,Long] = {
","def histogram(test: String): Map[String, Long] = {
        val words = test.split("" "")
        val frequencyMap = words.groupBy(identity).mapValues(_.length.toLong)

        if (frequencyMap.isEmpty) return Map.empty[String, Long]

        val maxCount = frequencyMap.values.max
        frequencyMap.filter { case (_, count) => count == maxCount }
    }
}","    }
    def main(args: Array[String]) = {
    assert(histogram((""a b b a"")).equals((Map[String,Long](""a"" -> 2l, ""b"" -> 2l))));
    assert(histogram((""a b c a b"")).equals((Map[String,Long](""a"" -> 2l, ""b"" -> 2l))));
    assert(histogram((""a b c d g"")).equals((Map[String,Long](""a"" -> 1l, ""b"" -> 1l, ""c"" -> 1l, ""d"" -> 1l, ""g"" -> 1l))));
    assert(histogram((""r t g"")).equals((Map[String,Long](""r"" -> 1l, ""t"" -> 1l, ""g"" -> 1l))));
    assert(histogram((""b b b b a"")).equals((Map[String,Long](""b"" -> 4l))));
    assert(histogram((""r t g"")).equals((Map[String,Long](""r"" -> 1l, ""t"" -> 1l, ""g"" -> 1l))));
    assert(histogram(("""")).equals((Map[String,Long]())));
    assert(histogram((""a"")).equals((Map[String,Long](""a"" -> 1l))));
    }

}
"
HumanEval_112,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ    //ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⴷ-ⵜⵔⴰⵔⴷ ⵜⴰⴱⵔⵔⵉⵜ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵢⴰⴼⵓⵜ ⴷ true/false ⵉ ⵓⵣⵣⵔⴰⵢ.    //ⴷⴰ ⵜⵜⵉⵏⵉⵏ ⵉ ⵡⵓⵟⵟⵓⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ ⵉⵖ ⵉⴳⴰ ⵡⴰⵏⵏⴰⵢ ⵏⵏⵙ ⴰⵎ ⵡⴰⵏⵏⴰⵢ ⵏⵏⵙ ⵙ ⴷⴰⵜ.    //ⴹⴰⵕⵜ ⵓⵢⴰ, ⵥⵕⵖ ⵉⵙ ⵜⴳⴰ ⵜⵉⴼⵔⵜ ⵏ ⵜⵢⴰⴼⵓⵜ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ.    //ⴷⴰ ⵏⵜⵜⴰⴽⴽⴰ ⵙⵉⵏ ⵉⵙⵉⵔⵎⵏ s ⴷ c, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ s ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ c.    //ⵜⴰⵣⵣⴰⵍⵜ     // >>> reverseDelete((""abcde""), (""ae""))
    // ((""bcd"", false))
    // >>> reverseDelete((""abcdef""), (""b""))
    // ((""acdef"", false))
    // >>> reverseDelete((""abcdedcba""), (""ab""))
    // ((""cdedc"", true))
    def reverseDelete(s : String, c : String) : Tuple2[String, Boolean] = {
","def reverseDelete(s: String, c: String): Tuple2[String, Boolean] = {
    // Convert the characters to be deleted into a set for quick lookup
    val deleteSet = c.toSet
    
    // Filter out characters from s that are present in deleteSet
    val filteredString = s.filterNot(deleteSet.contains)
    
    // Check if the filtered string is a palindrome
    val isPalindrome = filteredString == filteredString.reverse
    
    // Return the tuple with the filtered string and the palindrome check result
    (filteredString, isPalindrome)
  }
}","    }
    def main(args: Array[String]) = {
    assert(reverseDelete((""abcde""), (""ae"")).equals(((""bcd"", false))));
    assert(reverseDelete((""abcdef""), (""b"")).equals(((""acdef"", false))));
    assert(reverseDelete((""abcdedcba""), (""ab"")).equals(((""cdedc"", true))));
    assert(reverseDelete((""dwik""), (""w"")).equals(((""dik"", false))));
    assert(reverseDelete((""a""), (""a"")).equals((("""", true))));
    assert(reverseDelete((""abcdedcba""), ("""")).equals(((""abcdedcba"", true))));
    assert(reverseDelete((""abcdedcba""), (""v"")).equals(((""abcdedcba"", true))));
    assert(reverseDelete((""vabba""), (""v"")).equals(((""abba"", true))));
    assert(reverseDelete((""mamma""), (""mia"")).equals((("""", true))));
    }

}
"
HumanEval_113,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵏ ⵡⵓⵟⵟⵓⵏ ⵓⵔ ⵉⵎⵙⴰⵙⴰⵏ ⴳ ⵜⵣⵍⵉⵜ ⵜⵉⵙⵙ i ⵏ ⵓⵙⴽⵛⵎ.    //"" ⴳ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴽⵓⵍⵍⵓ ⵜⵉⵖⵔⵎⵉⵡⵉⵏ ""ⵉ"" ⵙ ⵓⵟⵟⵓⵏ     //ⴽⵓ ⵉⴼⵔⴷⵉⵙ i ⵏ ⵜⵢⴰⴼⵓⵜ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ "" ⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ     //ⵎⴽ ⴷ ⵢⴰⴽⴽⴰ ⵓⵎⵙⵎⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⴳ ⵉⵍⵍⴰ ⴽⵓ ⵜⵉⴼⵉⵏⴰⵖ ⴳⵉⵙ ⵡⵓⵟⵟⵓⵏ, ⵙⵙⵓⴼⵖ ⴰⵎⵙⵎⵉⵍ.    // >>> oddCount((List[String](""1234567"")))
    // (List[String](""the number of odd elements 4n the str4ng 4 of the 4nput.""))
    // >>> oddCount((List[String](""3"", ""11111111"")))
    // (List[String](""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""))
    def oddCount(lst : List[String]) : List[String] = {
","def oddCount(lst: List[String]): List[String] = {
    lst.map { str =>
      val oddCount = str.count(c => c.asDigit % 2 != 0)
      val replacedString = s""the number of odd elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${oddCount}nput.""
      replacedString
    }
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(oddCount(List(""1234567"")))  // List(""the number of odd elements 4n the str4ng 4 of the 4nput."")
    println(oddCount(List(""3"", ""11111111"")))  // List(""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput."")
  }
}","    }
    def main(args: Array[String]) = {
    assert(oddCount((List[String](""1234567""))).equals((List[String](""the number of odd elements 4n the str4ng 4 of the 4nput.""))));
    assert(oddCount((List[String](""3"", ""11111111""))).equals((List[String](""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""))));
    assert(oddCount((List[String](""271"", ""137"", ""314""))).equals((List[String](""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""))));
    }

}
"
HumanEval_114,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ    //ⵏ ⵉⵎⴹⴰⵏⵏ.    //ⴳ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵜⵓⵜⵜⵉ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵜⴰⴷⵔⵓⵙⵜ ⵏ ⴽⵓ ⵜⵍⴳⴰⵎⵜ ⵜⴰⵡⵜⵎⵉⵢⵜ ⵓⵔ ⵉⴳⵉⵏ ⵜⵍⵍⴰⵍⵜ     // >>> minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)))
    // (1l)
    // >>> minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)))
    // (-6l)
    def minSubArraySum(nums : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def minSubArraySum(nums: List[Long]): Long = {
    var minEndingHere = nums.head
    var minSoFar = nums.head
    
    for (i <- 1 until nums.length) {
      minEndingHere = min(nums(i), minEndingHere + nums(i))
      minSoFar = min(minSoFar, minEndingHere)
    }
    
    minSoFar
  }

  // Test Cases
  def main(args: Array[String]): Unit = {
    println(minSubArraySum(List(2l, 3l, 4l, 1l, 2l, 4l))) // Output: 1
    println(minSubArraySum(List(-1l, -2l, -3l))) // Output: -6
  }
}","    }
    def main(args: Array[String]) = {
    assert(minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));
    assert(minSubArraySum((List[Long](-9999999999999999l.toLong))) == (-9999999999999999l));
    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong, 20l.toLong, 1000000l.toLong))) == (0l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](100l.toLong, -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong, 3l.toLong, 4l.toLong))) == (3l));
    assert(minSubArraySum((List[Long](100l.toLong, -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));
    assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));
    assert(minSubArraySum((List[Long](7l.toLong))) == (7l));
    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));
    }

}
"
HumanEval_115,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ 1:    //ⴰⴾⵜⴰⴱ ⵏ ⵉⵎⵎⵉⴾ ⵓⴰ ⵙ ⵉⵋⵋⴰ ⴰⵓⵢⵏ ⴰⴷⴷⵓⴱⴰⵜ ⵏⵢⵜ ⴰⴷ ⵉⴾⴼ-ⴰ ⵉⵂⴰⵔⴰⵏ    //ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ ⴰⵆⴰⴷⴰⵎ ⵏ ⴱⵓⴾⵢⵜ ⵜⴰⵏ ⵉ ⴰⵙⵉⵓⴰⴷ ⵏ ⵉⵋⵉⵜⴰⵏ    //ⴷ ⵉⵛⵛⵉⴾⵉⵍⴰⵏ ⴼⵓⴾ ⵉⵍⴰⵏⴰⵏ ⵜⴰⵣⵓⵏⵜ ⵉⵉⵉⴰⵜ    //ⴾⴻⵍ ⵜⴰⵂⴰⵏⵉⵏⵜ ⵉⵍⴰ ⴱⵓⴾⴻⵜ ⵉⵋⵋⴰⵏ ⵉⵋⵋⵉ ⵏ ⴰⵎⴰⵏ ⴷⴰⵗ ⴻⴷⴰⴶ ⵓⴻⵏ    //ⴷ ⴽⵓ 1 ⴳ ⵜⴰⴳⵔⵡⵜ ⵉⵙⵎⴷⵢⴰⵏ ⵜⴰⵢⵎⵓⵏⵜ ⵏ ⵡⴰⵎⴰⵏ.    //ⴰⵜⵓⴰⵗⵔⴰⴱⴰⵏ ⵙⴰⴾⴰⵍ ⵏⵓⴾⴰⵉⴰⵏ ⵏⵓⴾⴰⵉⴰⵏ. ⵔⵉⴾⵓⴾ ⵢⵈⵈⴰⵍ ⴰⴾⴰⵉⴰⵏ ⵉⵉⵉⴰⵏ    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))
    // (6l)
    // Example 2:
    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l))
    // (5l)
    // Example 3:
    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))
    // (0l)
    // Constraints:
    // * all wells have the same length
    // * 1 <= grid.length <= 10^2
    // * 1 <= grid[:,1].length <= 10^2
    // * grid[i][j] -> 0 | 1
    // * 1 <= capacity <= 10
    def maxFill(grid : List[List[Long]], capacity : Long) : Long = {
","def maxFill(grid: List[List[Long]], capacity: Long): Long = {
  var totalWaterUnits = 0L

  for (row <- grid) {
    totalWaterUnits += row.sum
  }

  // Calculate the number of times you need to lower the buckets
  val bucketOperations = totalWaterUnits / capacity + (if (totalWaterUnits % capacity != 0) 1 else 0)

  bucketOperations
}","    }
    def main(args: Array[String]) = {
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) == (0l));
    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (4l));
    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (9l)) == (2l));
    }

}
"
HumanEval_116,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⴽⴰⵔ ⵣⵓⵏⴷ ⴰⵢⴰ:     //ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵢⴰⵖⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ, ⵙⵙⵓⴷⵙ ⵅⴼ ⵡⴰⵜⵉⴳ ⴰⵎⵔⴰⵡ.    //ⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵉⴹⵏ ⴳ ⵓⵙⵎⴷⵢⴰ ⵏⵏⵙⵏ ⴰⵎⵉⵏⴰⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵓⵇⵕⴰⵏ.    //ⴳ ⴽⴰⵜⴰ ⴰⴷ, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵔⵉⵏⵉⵏ ⵖⴼ     // >>> sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))
    // >>> sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))
    // (List[Long](-6l.toLong, -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))
    // >>> sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))
    def sortArray(arr : List[Long]) : List[Long] = {
","def sortArray(arr: List[Long]): List[Long] = {
        arr.sortBy(n => (n.toBinaryString.count(_ == '1'), n))
    }
}","    }
    def main(args: Array[String]) = {
    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));
    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));
    assert(sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));
    assert(sortArray((List[Long]())).equals((List[Long]())));
    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong, 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 7l.toLong, 77l.toLong))));
    assert(sortArray((List[Long](3l.toLong, 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong, 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));
    }

}
"
HumanEval_117,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⵜⴰⵍⵖⴰ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴽⴷ ⵉⵙ ⴳⴰⵏ ⵉⵣⵔⵉⴳⵏ ⵏ ⵓⵙⴽⵛⵎ ⵖⴰⵙ ⵉⵙⴽⴽⵉⵍⵏ ⴷ ⵉⵎⵣⴰⵔⴰⵢⵏ.    //ⵎⴽ ⵜⴳⴰ ⵜⵉⴼⵔⴽⵜ s ⵜⵍⵍⵉⵜ, ⵇⴰⴷ ⵜⵕⵓⵡⵉ ⵜⴰⵡⵓⵔⵉ ⵜⴰⵍⴳⴰⵎⵜ ⵜⵍⵍⵉⵜ.    //n ⵉⵎⵙⴰⵙⴰⵏ, ⵙ ⵓⵍⵖⴰ ⵏⵏⴰ ⴳ ⵜⵜⵉⵍⵉⵏⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴷ ⴳ ⵜⵣⵍⵉⵜ s.     //ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵙⴽⴰⵔⵏ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴽⴽⵡ ⵙⴳ ⵜⵉⴼⵉⵏⴰⵖ s ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ     //ⴳ ⵜⵉⴽⴽⵉ ⵏ ⵢⴰⵏ ⵓⵙⵏⴼⵍⵓⵍ s ⴷ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⴳⴰⵎⴰⵏ n, ⵜⵜⵓⵣⵔⴰⴽ ⴰⴷ ⵜⵙⵙⴽⵔ     // >>> selectWords((""Mary had a little lamb""), (4l))
    // (List[String](""little""))
    // >>> selectWords((""Mary had a little lamb""), (3l))
    // (List[String](""Mary"", ""lamb""))
    // >>> selectWords((""simple white space""), (2l))
    // (List[String]())
    // >>> selectWords((""Hello world""), (4l))
    // (List[String](""world""))
    // >>> selectWords((""Uncle sam""), (3l))
    // (List[String](""Uncle""))
    def selectWords(s : String, n : Long) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def selectWords(s: String, n: Long): List[String] = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    
    def consonantCount(word: String): Int = {
      word.count(c => c.isLetter && !vowels.contains(c))
    }

    if (s.isEmpty) {
      List()
    } else {
      s.split(""\\s+"").filter(word => consonantCount(word) == n).toList
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(selectWords((""Mary had a little lamb""), (4l)).equals((List[String](""little""))));
    assert(selectWords((""Mary had a little lamb""), (3l)).equals((List[String](""Mary"", ""lamb""))));
    assert(selectWords((""simple white space""), (2l)).equals((List[String]())));
    assert(selectWords((""Hello world""), (4l)).equals((List[String](""world""))));
    assert(selectWords((""Uncle sam""), (3l)).equals((List[String](""Uncle""))));
    assert(selectWords((""""), (4l)).equals((List[String]())));
    assert(selectWords((""a b c d e f""), (1l)).equals((List[String](""b"", ""c"", ""d"", ""f""))));
    }

}
"
HumanEval_118,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉ ⵎⴰⵙ ⴷ ⵜⴰⴳⵓⵔⵉ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴰⵙ ⵜⵍⴰ ⵜⴰⴱⵔⵉⴷⵜ ⵜⴰⵏⴳⵍⵉⵣⵜ.    //ⴹⴼⵔ ⵉ ⴽⵓ ⴰⵖⵔⵉⵎ ⵏⵏⴰ ⵉⵔⵡⴰⵏ ⵙ ⵡⴰⴷⴷⴰⴷ ⵏ ⴰⴼⵍⵍⴰ.    //ⵓⵔ ⴷⴰ ⵜⵜⵓⵙⵉⴹⵏ ⵉⵎⵙⵍⵉ ⴳ ⵜⵉⵣⵡⵉⵔⵉ ⴷ ⵜⴳⵉⵔⴰ. ⵔⴰⵏⵜⵔ ⵜⴰⵣⵍⵉⵜ ⵜⴰⵅⵍⴰⴼⵜ ⵎⴽ ⵓⵔ ⵜⵍⵍⵉ     //ⵙⵉⵏ ⵉⵎⵙⴰⵙⴰⵏ ⵙⴳ ⵜⵙⴳⴰ ⵏ ⵡⴰⵡⴰⵍ (ⴰⵙⵙⵏ ⵜⴱⵔⵉⴷⵜ).    //ⴷⴰ ⵜⵜⵓⴳⴰ ⴽⵔⴰ ⵏ ⵜⴳⵓⵔⵉ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴰⴼⴷ ⵓⴱⵓⵅⵉⵍ ⵏⵏⴰ ⵢⵓⴳⵔⵏ ⴳⵔ     // >>> getClosestVowel((""yogurt""))
    // (""u"")
    // >>> getClosestVowel((""FULL""))
    // (""U"")
    // >>> getClosestVowel((""quick""))
    // ("""")
    // >>> getClosestVowel((""ab""))
    // ("""")
    def getClosestVowel(word : String) : String = {
","def getClosestVowel(word: String): String = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    
    for (i <- word.length - 2 until 0 by -1) {
      if (!vowels.contains(word(i)) && vowels.contains(word(i + 1)) && !vowels.contains(word(i + 2))) {
        return word(i + 1).toString
      }
    }
    
    """"
  }
}","    }
    def main(args: Array[String]) = {
    assert(getClosestVowel((""yogurt"")).equals((""u"")));
    assert(getClosestVowel((""full"")).equals((""u"")));
    assert(getClosestVowel((""easy"")).equals(("""")));
    assert(getClosestVowel((""eAsy"")).equals(("""")));
    assert(getClosestVowel((""ali"")).equals(("""")));
    assert(getClosestVowel((""bad"")).equals((""a"")));
    assert(getClosestVowel((""most"")).equals((""o"")));
    assert(getClosestVowel((""ab"")).equals(("""")));
    assert(getClosestVowel((""ba"")).equals(("""")));
    assert(getClosestVowel((""quick"")).equals(("""")));
    assert(getClosestVowel((""anime"")).equals((""i"")));
    assert(getClosestVowel((""Asia"")).equals(("""")));
    assert(getClosestVowel((""Above"")).equals((""o"")));
    }

}
"
HumanEval_119,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⵔⵉⵜⵓⵔⵏ ""ⵉⵀ"" ⵎⴽ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴱⵔⵉⴷ ⵉ ⵓⵙⴽⴰⵔ ⵏ ⵢⴰⵏ ⵓⵙⵉⴹⵏ ⵉⵖⵓⴷⴰⵏ, ⴷ ⵔⵉⵜⵓⵔⵏ ""ⵓⵅⴰ"" ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⴷⴷⴰⴷ.    //"" ((()) "" ⵓⵔ ⵉⴳⵉ.    //ⴳⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ. ⵙ ⵓⵎⴷⵢⴰ: ⵜⵉⴼⵉⵏⴰⵖ ""(((() "" ⵜⴳⴰ ⵉⵖⵓⴷⴰⵏ, ⵎⴰⵛⴰ ⵜⵉⴼⵉⵏⴰⵖ     //ⴷⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⵢⴰⵏ ⵓⵙⵏⴼⵍⵓⵍ S ⵙ ⵉⵙ ⵉⴳⴰ ⵉⵖⵓⴷⴰⵏ ⵉⴳ ⴷ ⵖⴰⵙ ⵉⴳ ⵎⴰⵕⵕⴰ ⵉⴽⵕⵕⴰⵥⵏ ⴳ S     //ⴽⵔⴰ ⵏ ⵓⴽⵓⴷ, ⵎⴰⵙⴷ ⵜⵉⴼⵔⴽⵜ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⵔⴰⴷ ⵜⴳ ⵉⵖⵓⴷⴰⵏ.    //ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ ⴰⴾⴰⵉⴰⴷ ⴰⵙ ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⵉⴾⵉⵉ ⵙⴰⵏⴰⵜⴰⵜⴰⵜ ⵜⵉⵣⵓⵏⴰⵓⴻⵏ ⴷⴰⵗ    //ⴷⴰⵢ ⴷⴰ ⵜⵜⵓⵣⵎⵎⴻⵎⵏ ⵉⴹⵕⵉⵚⵏ "" (() "" ⵏⵖⴷ ⵉⴹⵕⵉⵚⵏ ⵏ ⵜⴳⵏⵓⵜ "") "".    //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵍⴳⴰⵎⵜ ⵏ ⵙⵏⴰⵜ ⵜⵣⵍⵖⴰ, ⵙⵏⴰⵜ ⵜⵣⵍⵖⴰ ⴷⵉⴳⵙⵏ ⵜⵉⴼⵔⴽⴰ     // >>> matchParens((List[String](""()("", "")"")))
    // (""Yes"")
    // >>> matchParens((List[String]("")"", "")"")))
    // (""No"")
    def matchParens(lst : List[String]) : String = {
","def matchParens(lst: List[String]): String = {
    def isBalanced(s: String): Boolean = {
      var balance = 0
      for (char <- s) {
        if (char == '(') balance += 1
        else if (char == ')') balance -= 1
        if (balance < 0) return false
      }
      balance == 0
    }
    
    val combinations = List(
      lst(0) + lst(1),
      lst(1) + lst(0)
    )
    
    if (combinations.exists(isBalanced)) ""Yes"" else ""No""
  }
}","    }
    def main(args: Array[String]) = {
    assert(matchParens((List[String](""()("", "")""))).equals((""Yes"")));
    assert(matchParens((List[String]("")"", "")""))).equals((""No"")));
    assert(matchParens((List[String](""(()(())"", ""())())""))).equals((""No"")));
    assert(matchParens((List[String]("")())"", ""(()()(""))).equals((""Yes"")));
    assert(matchParens((List[String](""(())))"", ""(()())((""))).equals((""Yes"")));
    assert(matchParens((List[String](""()"", ""())""))).equals((""No"")));
    assert(matchParens((List[String](""(()("", ""()))()""))).equals((""Yes"")));
    assert(matchParens((List[String](""(((("", ""((())""))).equals((""No"")));
    assert(matchParens((List[String]("")(()"", ""(()(""))).equals((""No"")));
    assert(matchParens((List[String]("")("", "")(""))).equals((""No"")));
    assert(matchParens((List[String](""("", "")""))).equals((""Yes"")));
    assert(matchParens((List[String]("")"", ""(""))).equals((""Yes"")));
    }

}
"
HumanEval_120,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ 1:    //ⵏ ⵜⵉⵖⵣⵉ k ⴷ ⵡⵓⵟⵟⵓⵏ k ⴳ arr.     //ⵎⴽ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵍⴳⴰⵎⵜ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ k, ⵙⵙⴽⵛⵎ ⵜⴰⵍⴳⴰⵎⵜ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ     // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))
    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))
    // Example 2:
    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))
    // (List[Long](4l.toLong, 4l.toLong))
    // Example 3:
    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))
    // (List[Long](2l.toLong))
    // Note:
    // 1. The length of the list will be in the range of [1, 1000].
    // 2. The elements in the list will be in the range of [-1000, 1000].
    // 3. 0 <= k <= len(arr)
    def maximum(arr : List[Long], k : Long) : List[Long] = {
","def maximum(arr: List[Long], k: Long): List[Long] = {
    arr.sorted(Ordering[Long].reverse).take(k.toInt).sorted
  }
}","    }
    def main(args: Array[String]) = {
    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));
    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));
    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));
    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));
    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));
    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));
    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));
    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));
    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));
    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));
    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));
    }

}
"
HumanEval_121,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ    //ⵎⴽ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵅⵡⴰⵏ, ⵙⵙⴽⵛⵎ ⵜⴰⴳⵓⵜ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵡⴰⵏⵙⴰ ⵉⵎⵣⴰⵔⴰⵢⵏ.     // >>> solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong)))
    // (12l)
    // >>> solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong)))
    // (9l)
    // >>> solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong)))
    // (0l)
    def solution(lst : List[Long]) : Long = {
","def solution(lst: List[Long]): Long = {
  lst.zipWithIndex.collect {
    case (num, idx) if idx % 2 == 0 && num % 2 != 0 => num
  }.sum
}","    }
    def main(args: Array[String]) = {
    assert(solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong))) == (12l));
    assert(solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong))) == (9l));
    assert(solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong))) == (0l));
    assert(solution((List[Long](5l.toLong, 9l.toLong))) == (5l));
    assert(solution((List[Long](2l.toLong, 4l.toLong, 8l.toLong))) == (0l));
    assert(solution((List[Long](30l.toLong, 13l.toLong, 23l.toLong, 32l.toLong))) == (23l));
    assert(solution((List[Long](3l.toLong, 13l.toLong, 2l.toLong, 9l.toLong))) == (3l));
    }

}
"
HumanEval_122,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //ⴰⵎⵎⴰⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵙⵏⴰⵜ ⵜⴽⵕⴹⵉⵡⵉⵏ ⴳ ⵓⴳⴳⴰⵔ ⵙⴳ ⴽ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ arr.    //ⴳ ⵓⵙⴰⵜⵉ ⵏ ⵜⵍⴳⴰⵎⵜ ⵓⵔ ⵉⴳⵉⵏ ⵜⵍⵍⵓⵏⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ arr ⴷ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ k,  return    // >>> addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l))
    // (24l)
    // Constraints:
    // 1. 1 <= len(arr) <= 100
    // 2. 1 <= k <= len(arr)
    def addElements(arr : List[Long], k : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def addElements(arr: List[Long], k: Long): Long = {
    arr.take(k.toInt).filter(x => x >= -99 && x <= 99).sum
  }

  def main(args: Array[String]): Unit = {
    val result = addElements(List[Long](111L, 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L), 4L)
    println(result) // Output will be 24L
  }
}","    }
    def main(args: Array[String]) = {
    assert(addElements((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 41l.toLong, 57l.toLong, 76l.toLong, 87l.toLong, 88l.toLong, 99l.toLong)), (3l)) == (-4l));
    assert(addElements((List[Long](111l.toLong, 121l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong)), (2l)) == (0l));
    assert(addElements((List[Long](11l.toLong, 21l.toLong, 3l.toLong, 90l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (125l));
    assert(addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (24l));
    assert(addElements((List[Long](1l.toLong)), (1l)) == (1l));
    }

}
"
HumanEval_123,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //get_odd_collatz(5) ⴷⴰ ⵉⵜⵜⵔⴰⵔ [1, 5] # ⵜⴰⵍⵖⴰ ⵏ ⴽⵓⵍⵍⴰⵜⵣ ⵉ 5 ⵜⴳⴰ [5, 16, 8, 4, 2, 1], ⴰⵢⴰⴷ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵅⴰⵙ 1, ⴷ 5.     //ⵙ ⵓⵎⴷⵢⴰ:     //2. ⵜⵍⴳⴰⵎⵜ ⵉⵜⵜⵓⵣⵏⴰⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⵢⵓⵡⵢⵏ.    //1. ⴽⵓⵍⵍⴰⵜⵣ ((1) ⵉⴳⴰ [1].    //ⴰⵜⵡⵉⵍ:     //ⴷⴰ ⵉⵜⵜⵉⵏⵉ ⵓⵙⵏⵓⵎⵎⵓ ⵎⴰⵙ ⴷ ⵡⴰⵜⵉⴳ ⴰⴽⴽⵡ ⵏ n, ⵔⴰⴷ ⵜⵍⴽⵎ ⵜⵉⴼⵔⴽⵜ ⴰⵀⴰ 1.    //ⵎⴽ ⵜⴳⴰ ⵜⴳⵓⵔⵉ ⵉⵣⵔⵉⵏ ⵜⴰⴳⴳⴰⵢⵜ, ⵜⴳⵓⵔⵉ ⵜⴰⴹⴼⴰⵕⵜ ⵔⴰⴷ ⵜⴳ 3 ⵏ ⵜⵉⴽⴽⴰⵍ ⵏ ⵜⴳⵓⵔⵉ ⵉⵣⵔⵉⵏ.    //ⵜⵉⴼⵔⵉⵜ ⵉⵣⵔⵉⵏ ⵙ ⵓⵎⴽ ⴰⴷ: ⵉⴳ ⵉⴳⴰ ⵜⵉⴼⵔⵉⵜ ⵉⵣⵔⵉⵏ ⵉⵎⵣⴷⴰⵢⵏ, ⵜⵉⴼⵔⵉⵜ ⵜⴰⴹⴼⴰⵕⵜ ⵜⴳⴰ ⵢⴰⵏ ⵓⵣⴳⵏ ⵏ     //ⵙ ⵓⵎⴽ ⴰⴷ: ⵙⵙⵏⵜⵉ ⵙ ⴽⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ n. ⴷⴼⴼⵉⵔ ⵏ ⵓⵢⴰ, ⴷⴰ ⵜⵜⵓⵢⴰⴽⴽⴰ ⴽⵓ ⵜⴰⵙⴳⵓⵔⵉ ⵙⴳ     //ⵜⴰⴳⵏⵉⵜ ⵏ ⴽⵓⵍⵍⴰⵣ ⵜⴳⴰ ⵜⴰⴳⵏⵉⵜ ⴳ ⵜⵓⵙⵏⴰⴽⵜ ⵏⵏⴰ ⵉⵥⵍⵉⵏ ⵙ ⵢⴰⵏ ⵓⴹⴼⴼⵓⵕ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ     //ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵙⴽⵛⵎ ⵜⴰⵍⴳⴰⵎⵜ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵙⵓⵔⵙ ⵏ ⴽⵓⵍⴰⵜⵣ.    // >>> getOddCollatz((5l))
    // (List[Long](1l.toLong, 5l.toLong))
    def getOddCollatz(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
  def getOddCollatz(n: Long): List[Long] = {
    val oddNumbers = ListBuffer[Long]()
    var number = n
    while (number != 1) {
      if (number % 2 == 1) {
        oddNumbers += number
      }
      number = if (number % 2 == 0) number / 2 else 3 * number + 1
    }
    oddNumbers += 1
    oddNumbers.sorted.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));
    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong, 5l.toLong))));
    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong, 3l.toLong, 5l.toLong))));
    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));
    }

}
"
HumanEval_124,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //4. ⴷⴰⵜⵢ ⵜ ⵉⵋⵋⴰ ⴷⴰⵗ ⴼⵓⵔⵎⴰⵜⵉ: ⵎⵎ-ⴷⴷ-ⵢⵢⵢⵢⵢⵉ    //3. ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵉⴳ ⵡⴰⵢⵢⵓⵔⵏ ⴷⴷⵔⵓⵙⵏ ⵙⴳ 1 ⵏⵖ ⵓⴳⴳⴰⵔ ⵏ 12.    //2. ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⴰⵍⵓⴰⵈ ⵓⴰⵔ ⵢⵈⵈⵢⵍ ⵓⴰ ⵢⴷⵢⵙ ⵎⵢⵗ ⵓⵋⵋⴰⵔⴰⵏ 31 ⵏ ⴰⵍⵓⴰⵈ ⵉ ⴰⵛⵂⵢⵢⵢⵎ ⵓⴰⵏ 1,3,5,7,8,10,12 ⴷ ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⴰⵍⵓⴰⵈ ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵓⴰ ⵢⴷⵢⵙ ⵎⵢⵗ ⵓⵋⵋⴰⵔⴰⵏ 30 ⵏ ⴰⵍⵓⴰⵈ ⵉ ⴰⵛⵂⵢⵎ ⵓⴰⵏ 4,6,9,11 ⴷ ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⴰⵍⵓⴰⵈ ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵓⴰ ⵢⴷⵢⵙ ⵎⵢⵗ ⵓⵋⵋⴰⵔⴰⵏ 29 ⵏ ⴰⵍⵓⴰⵈ ⵉ ⴰⵛⵂⵢⵎ ⵓⴰⵏ 2    //1. ⵜⴰⵣⵓⵏⵜ ⵏ ⵡⴰⵙⵙ ⵓⵔ ⵜⴳⵉ ⵜⵍⵍⴰⵍⵜ.    //ⴷⴰⵜⴰ ⵜ ⴰⵈⵈⴰⵍ ⴰ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ ⴰ ⴼⴰⵍ ⵉⵍⴾⴰⵎⴰⵏ ⴼⵓⴾ ⵏⴰⵙⴰⵏ:    //ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⴰⵙⵙ ⴰⵣⵔⴼⴰⵏ ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵜⵉⴷⵜ.     //ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⵉⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙⵏ ⵜⵉⴼⵔⴽⵜ ⵏ ⵡⴰⵙⵙ ⴷ     // >>> validDate((""03-11-2000""))
    // (true)
    // >>> validDate((""15-01-2012""))
    // (false)
    // >>> validDate((""04-0-2040""))
    // (false)
    // >>> validDate((""06-04-2020""))
    // (true)
    // >>> validDate((""06/04/2020""))
    // (false)
    def validDate(date : String) : Boolean = {
","import scala.util.Try

object Problem {
  def validDate(date: String): Boolean = {
    if (date.isEmpty) return false
    
    val datePattern = """"""^(\d{2})-(\d{2})-(\d{4})$"""""".r

    date match {
      case datePattern(monthStr, dayStr, yearStr) => 
        (Try(monthStr.toInt).toOption, Try(dayStr.toInt).toOption) match {
          case (Some(month), Some(day)) if month >= 1 && month <= 12 =>
            month match {
              case 1 | 3 | 5 | 7 | 8 | 10 | 12 => day >= 1 && day <= 31
              case 4 | 6 | 9 | 11 => day >= 1 && day <= 30
              case 2 => day >= 1 && day <= 29
              case _ => false
            }
          case _ => false
        }
      case _ => false
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(validDate((""03-11-2000"")) == (true));
    assert(validDate((""15-01-2012"")) == (false));
    assert(validDate((""04-0-2040"")) == (false));
    assert(validDate((""06-04-2020"")) == (true));
    assert(validDate((""01-01-2007"")) == (true));
    assert(validDate((""03-32-2011"")) == (false));
    assert(validDate(("""")) == (false));
    assert(validDate((""04-31-3000"")) == (false));
    assert(validDate((""06-06-2005"")) == (true));
    assert(validDate((""21-31-2000"")) == (false));
    assert(validDate((""04-12-2003"")) == (true));
    assert(validDate((""04122003"")) == (false));
    assert(validDate((""20030412"")) == (false));
    assert(validDate((""2003-04"")) == (false));
    assert(validDate((""2003-04-12"")) == (false));
    assert(validDate((""04-2003"")) == (false));
    }

}
"
HumanEval_125,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ    //ⴰⵍⵍⴰⵙ, ord{""a"") = 0, ord{""b"") = 1, ... ord{""z"") = 25     //ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⴱⴹⵓ ⵅⴼ ⵜⵉⴼⵉⵏⴰⵖ ',' ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵜⵉⴼⵉⵏⴰⵖ  ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵔⴰⵔⵉⴹ ⵓⵟⵟⵓⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵢⴰⵏⴰⵡ ⴳ     //ⵎⴽ ⵜⵍⵍⴰ ⵢⴰⵜ ⵜⵣⵍⵉⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ, ⵙⵙⴽⵛⵎ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵙ ⵜⴱⴹⴰⵢⵜ ⵅⴼ ⵡⴰⵏⵙⴰ ⴰⵎⵥⵥⵢⴰⵏ, ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⵏⵙⴰ ⴰⵎⵥⵥⵢⴰⵏ ⴳ ⵓⴹⵕⵉⵚ ⵏⵏⴰ ⵜⵔⴰ     // >>> splitWords((""Hello world!""))
    // List[String](""Hello"", ""world!"")
    // >>> splitWords((""Hello,world!""))
    // List[String](""Hello"", ""world!"")
    // >>> splitWords((""abcdef""))
    // 3l
    def splitWords(txt : String) : Either[List[String], Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def splitWords(txt: String): Either[List[String], Long] = {
    if (txt.contains("" "")) {
      Left(txt.split(""\\s+"").toList)
    } else if (txt.contains("","")) {
      Left(txt.split("","").toList)
    } else {
      val oddOrderCount = txt.toCharArray
        .count(c => ('a' to 'z').contains(c) && (c - 'a') % 2 == 0)
      Right(oddOrderCount.toLong)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(splitWords((""Hello world!"")).equals(List[String](""Hello"", ""world!"")));
    assert(splitWords((""Hello,world!"")).equals(List[String](""Hello"", ""world!"")));
    assert(splitWords((""Hello world,!"")).equals(List[String](""Hello"", ""world,!"")));
    assert(splitWords((""Hello,Hello,world !"")).equals(List[String](""Hello,Hello,world"", ""!"")));
    assert(splitWords((""abcdef"")).equals(3l));
    assert(splitWords((""aaabb"")).equals(2l));
    assert(splitWords((""aaaBb"")).equals(1l));
    assert(splitWords(("""")).equals(0l));
    }

}
"
HumanEval_126,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ    //number, return false. ⵓⵔ ⴷⴰ ⵏⵜⵜⴰⴼⴰ ⵉⵎⴹⴰⵏ ⵉⵔⵉⵏⵉⵏ ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ.    //ⴾⵓⴷⴷⵢⵗ ⴰⵙ ⵉⵍⵍⵢⵙⴰⵏ ⵓⵋⵋⴰⵔⴰⵏ ⴾⵢⵍ ⵢⴷⴰⴶ ⵉⵉⵉⴰⵏ    //ⴹⴰⵗ ⵜⴰⵍⵉⵜ ⵏ ⵉⴷⴷⵉⴾⵓⴷⴰⵏ, ⴰⴷ ⵉⴾⴼ-ⴰ ⴰⵍⵆⴰⵍ ⵏⴰⵙⴰⵏ ⵎⴻⵗ ⵓⴰⵔ ⵏ ⴰⵈⵈⵉⵍⴰⵏ    // >>> isSorted((List[Long](5l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // (false)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))
    // (false)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (false)
    def isSorted(lst : List[Long]) : Boolean = {
","def isSorted(lst: List[Long]): Boolean = {
    if (lst.isEmpty || lst.length == 1) return true

    var hasDuplicate = false

    for (i <- 1 until lst.length) {
        if (lst(i) < lst(i - 1)) {
            return false
        }
        if (lst(i) == lst(i - 1)) {
            if (hasDuplicate) return false
            hasDuplicate = true
        } else {
            hasDuplicate = false
        }
    }

    true
}","    }
    def main(args: Array[String]) = {
    assert(isSorted((List[Long](5l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (false));
    assert(isSorted((List[Long]())) == (true));
    assert(isSorted((List[Long](1l.toLong))) == (true));
    assert(isSorted((List[Long](3l.toLong, 2l.toLong, 1l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (true));
    }

}
"
HumanEval_127,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //[ⵉⵏⴱⵓⵜ/ⵓⵓⵜⴱⵓⵜ] ⵙⵜⵓⵎⴱⵍⵙ:     //ⵎⴽ ⵓⵔ ⴷⴰ ⵜⵜⵎⴳⴰⵍⵏⵜ ⵙⵏⴰⵜ ⵜⵣⵎⵎⴰⵔ, ⵙⵓⵍⵏ ""ⵓⵀⵓ"".    //ⵎⴽ ⵓⵔ ⵉⴳⵉ, ⵔⵔⵓⵜⵓⵔ ""ⵓⵀⵓ"".    //ⵎⴽ ⵉⴳⴰ ⵓⵖⵣⵉ ⵏ ⵓⵙⵎⴽⵍ ⴰⵎⵉⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⵙⵙⴽⵛⵎ ""YES"",     //ⴷ ⴰⵖⵣⵉ ⵏⵏⵙ ⵉⴳⴰⵜ 1, ⴷ ⵓⵔ ⵉⴳⵉ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ.    //ⴰⵎⴷⵢⴰ, ⴰⵙⵎⵓⵜⵜⴳ ⵏ ⵉⵎⵣⴰⵣⴰⵍ (1, 3), (2, 4) ⵉⴳⴰ (2, 3)     //ⵉⵙⵎ ⵏ ⵉⵏⴱⵉⵔⴰⵍⵏ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ.    //ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵜⴰⵢⴷ ⵎⴰⵢⴷ ⵉⴳⴰⵏ ⵜⵉⵖⵣⵉ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵙⵏⴰⵜ     //ⵉ ⴽⵓ ⴰⵣⵎⵣ, ⴷⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⵉⵙ ⵉⴳⴰ ⵍⴱⴷⵓ ⵏⵏⵙ ⵉⵎⵥⵥⵉⵢⵏ ⵏⵖⴷ ⵉⵎⴽⵉⵏⵏⴰ ⴷ ⵜⴳⵉⵔⴰ ⵏⵏⵙ.    //ⵢⵂⴰⵉ ⵜⵉⵣⴰⵔⴰⵜ ⴷ ⴰⵎⵉⵏⴷⵉ    //ⴷⴰ ⵜⵜⵓⵙⵎⵓⵏⴰⵏ ⵡⴰⵏⵙⵉⵡⵏ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ, ⵎⴰⵢⴰⴷ ⵉⴳⴰⵏ ⵡⴰⵏⵙⵉⵡⵏ (ⵜⴱⴷⴰⴷⵜ, ⵜⴳⵉⵔⴰ)     //ⴳ ⵉⴳⴰⵏ ⴽⵓ ⵓⵣⵎⵣ ⵢⴰⵏ ⵓⵣⴳⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙ ⵓⵎⴷⵢⴰ, ⴰⵣⵎⵣ = (ⵜⴱⴷⴰⴷⵜ, ⵜⴳⵉⵔⴰ) = (1, 2).    //ⴾⵢⵍ ⴰⴾⴰⵍ ⵉⵍⴰⵏ ⵜⵉ ⵉⵙⵙⵉⵏ ⵉⴾⴰⵏⵏⴰⵏ,    // >>> intersection(((1l, 2l)), ((2l, 3l)))
    // (""NO"")
    // >>> intersection(((-1l, 1l)), ((0l, 4l)))
    // (""NO"")
    // >>> intersection(((-3l, -1l)), ((-5l, 5l)))
    // (""YES"")
    def intersection(interval1 : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : String = {
","import scala.math._

object Problem {
  def isPrime(n: Long): Boolean = {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    var i = 5
    while (i * i <= n) {
      if (n % i == 0 || n % (i + 2) == 0) return false
      i += 6
    }
    true
  }

  def intersection(interval1: (Long, Long), interval2: (Long, Long)): String = {
    val start = max(interval1._1, interval2._1)
    val end = min(interval1._2, interval2._2)
    if (start > end) return ""NO""

    val length = end - start
    if (isPrime(length)) ""YES"" else ""NO""
  }
}","    }
    def main(args: Array[String]) = {
    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((""NO"")));
    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((""NO"")));
    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((""YES"")));
    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((""YES"")));
    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((""NO"")));
    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((""NO"")));
    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((""NO"")));
    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((""NO"")));
    }

}
"
HumanEval_128,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //Note: return None for empty arr.  ⴰⴱⵔⵉⴷ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵡⴰⵏⵙⴰ    //ⵏ ⴽⵓ ⵓⵟⵟⵓⵏ ⴳ ⵜⵍⴳⴰⵎⵜ, ⵉⵜⵜⵓⵙⵎⴷⵢⴰ ⵙ 1, -1 ⵏⵖⴷ 0.    //ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵜⵉⵙⵎⴽⵜⵉⵜⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙ ⵜⵢⴰⴼⵓⵜ ⵏ ⵉⵙⵎⴰⵡⵏ ⴰⴽⴽⵡ     //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵔⴰⵔ.    // >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong)))
    // Some(9l)
    // >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))
    // Some(0l)
    // >>> prodSigns((List[Long]()))
    // None
    def prodSigns(arr : List[Long]) : Option[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def prodSigns(arr: List[Long]): Option[Long] = {
    if (arr.isEmpty) return None

    val productOfSigns = arr.foldLeft(1l)((acc, num) => acc * sign(num))
    val sumOfMagnitudes = arr.map(_.abs).sum

    Some(sumOfMagnitudes * productOfSigns)
  }

  private def sign(num: Long): Long = {
    if (num > 0) 1
    else if (num < 0) -1
    else 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(Some(-9l)));
    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(Some(0l)));
    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(Some(-10l)));
    assert(prodSigns((List[Long]())).equals(None));
    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(Some(20l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(Some(4l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(Some(-4l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(0l)));
    }

}
"
HumanEval_129,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵙⵎⵉⵍ ⵏ ⵡⴰⵜⵉⴳⵏ ⵉⵜⵜⵓⵙⵓⴷⵙⵏ ⴳ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⵙ ⵉⴳⴳⵡⵣ ⵓⴱⵔⵉⴷ.     //ⴾⴰⵍⴰ ⵉⵋⵋⴰ ⴰⵓⵢⵏ, ⴰⵍⵓⴰⵣⴰⴱ ⵓⴰⵔ ⵢⵈⵈⵢⵍ ⵓⴰ ⵢⵣⵣⴰⵔⴰⵏ    //lst_A[j] = lst_B[j]     //ⵣⵓⵏⴷ lst_A[i] < lst_B[i] ⴷ ⴽⵓ j (1 <= j < i) ⵖⵓⵔⵖ     //ⵙⴳ lst_B, ⵙ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵢⴰⴹⵏ, ⵉⵍⵍⴰ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ i (1 <= i <= k)     //ⵙⴳ (ⴰⴷ ⵏⵙⵎⵎⴰ ⵜⵏ lst_A ⴷ lst_B), lst_A ⴷ ⵡⵉⵏ ⵍⴰⴽⵙⵉⴽⵓⵊⵔⴰⴼⵉ     //ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⴽⴰⵔ ⵏ ⵜⵍⴳⴰⵎⵉⵏ ⵏ ⵡⴰⵜⵉⴳⵏ ⴳ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⵔⴰⴷ ⵙⴽⵔⵏ A ⴷ B    //ⴷⴰ ⵉⵜⵜⵓⵙⵡⵉⵏⴳⵎ ⵓⴱⵔⵉⴷ A (ⵙ ⵜⵉⵖⵣⵉ k) ⴷⵔⵓⵙⵏ ⵓⴱⵔⵉⴷ B (ⵙ ⵜⵉⵖⵣⵉ k) ⵎⴽ     //ⵓⴰⵔ ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⴰⴾⵉⵛⵉⴷ ⴷⴰⵗ ⴶⵔⵉⴷ    //ⴰⵍⴰⵗⵉ ⵏ ⴰⵍⴰⵗⵉ    //ⴰⵜⵓⴰⵣⴰⵉ ⴰⵙ ⴰⴱⴰⵔⴰ ⵓⴰⵏ ⵜⵉⵛⵉⵋⵔⵉⵜ ⵏ k ⴰⵎⵓⵙ ⴰⵙⵉⴾⵉ ⵏ ⵛⵢⵍⵍ ⵜⴰⵏ ⵓⵉⵏ k (ⵓⴰⵔ ⵏ ⴰⵈⵈⵢⵍ     //ⵜⴰⴱⵍⵉⵜ.     //ⵙ ⵜⴳⵓⵔⵉ ⵢⴰⴹⵏ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵣⵔⵉⴷ ⵙ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⴷⴰⵔ ⵜⴰⴳⵓⵜ ⵏ ⵓⵥⴰⵡⴰⵏ     //ⵙⴳ ⴽⴰ ⵉⴳⴰⵜ ⵜⴰⵖⵔⴰⵙⵜ, ⴷ ⴳ ⴽⵓ ⵜⴰⵙⵓⵔⵉⴼⵜ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵓⵜⵍⵜ ⵖⵔ ⴽⴰ ⵉⴳⴰⵜ ⵜⴰⵖⵔⴰⵙⵜ ⵜⴰⴷⴷⴰⵔⵜ ⵜⵓⵎⵍⵉⵍⵜ,     //ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵏⴰⴼ ⴰⴱⵔⵉⴷ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵜⵉⵖⵣⵉ k ⴳ ⵜⴽⵔⵔⴰⵢⵜ. ⵉⵖⵢ ⴰⴷ ⵏⴱⴷⵓ     //ⴷⴰ ⵉⵜⵜⵓⵢⴼⴼⵖ ""inclusive"" ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ ⴳ ⵜⵖⵔⴰⵙⵉⵏ ⵏ ⵜⵔⴰⴱⴱⵓⵜ.    //ⴽⵓ ⵜⴰⵖⵔⴰⵙⵜ ⵏ ⵜⴽⴰⵔⴹⴰ ⵜⵍⵍⴰ ⴳ ⵡⴰⵜⵉⴳ. ⴽⵓ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵙⵏⴼⵍ [1, N * N]     //ⴳ ⵜⴽⵔⵔⴰⵢⵜ ⵏ N ⵏ ⵜⵉⵙⵉⴹⴼⵉⵏ ⴷ N ⵏ ⵜⵔⵙⴰⵍ (N >= 2) ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ k,     // >>> minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l))
    // (List[Long](1l.toLong, 2l.toLong, 1l.toLong))
    // >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l))
    // (List[Long](1l.toLong))
    def minPath(grid : List[List[Long]], k : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def minPath(grid: List[List[Long]], k: Long): List[Long] = {
    val n = grid.length
    val directions = List((0, 1), (1, 0), (0, -1), (-1, 0))

    def isValid(x: Int, y: Int): Boolean = x >= 0 && y >= 0 && x < n && y < n

    def dfs(x: Int, y: Int, path: List[Long]): List[Long] = {
      if (path.length == k) return path
      var minPath: List[Long] = List.fill(k)(Long.MaxValue)
      for ((dx, dy) <- directions) {
        val nx = x + dx
        val ny = y + dy
        if (isValid(nx, ny)) {
          val newPath = dfs(nx, ny, path :+ grid(nx)(ny))
          if (lexCompare(newPath, minPath)) {
            minPath = newPath
          }
        }
      }
      minPath
    }

    def lexCompare(a: List[Long], b: List[Long]): Boolean = {
      a.zip(b).find { case (x, y) => x != y } match {
        case Some((x, y)) => x < y
        case None => false
      }
    }

    var minPathOverall = List.fill(k)(Long.MaxValue)
    for {
      i <- 0 until n
      j <- 0 until n
    } {
      val startingPath = List(grid(i)(j))
      val currentPath = dfs(i, j, startingPath)
      if (lexCompare(currentPath, minPathOverall)) {
        minPathOverall = currentPath
      }
    }
    minPathOverall
  }
}","    }
    def main(args: Array[String]) = {
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong, 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));
    assert(minPath((List[List[Long]](List[Long](6l.toLong, 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong, 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong, 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong, 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));
    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong), List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong, 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    assert(minPath((List[List[Long]](List[Long](6l.toLong, 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong, 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong), List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    }

}
"
HumanEval_130,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⵉⵎⴹⴰⵏ ⵏ ⵜⵔⵉⴱⵓⵏⴰⵛⵛⵉ ⵏ n + 1 ⴰⵎⵣⵡⴰⵔⵓ.    //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⴹ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⵏⴳⴰⵍ n, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵍⴳⴰⵎⵜ ⵏ     //= 2 + 3 + 3= 8     //tri(3) = tri(2) + tri(1) + tri(4)     //tri(4) = 3     //tri(2) = 1 + (2 / 2) = 2     //ⵙ ⵓⵎⴷⵢⴰ:     //tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ⵉⴳ n ⵓⵔ ⵉⴳⵉ ⴰⵎⵣⴰⵔⴰⵢ.     //tri{n} = 1 + n / 2, ⵉⴳ ⵉⴳⴰ n ⵉⵎⵣⴰⵔⴰⵢⵏ.     //tri(1) = 3     //ⴷⴰ ⵜⵜⵓⵙⵏⵎⵍ ⵜⴹⴰ ⵏ ⵜⵔⵉⴱⵓⵏⴰⵛⵛⵉ ⵙ ⵓⵙⵏⴼⵍ:     //ⵎⴰⵛⴰ, ⵓⵔ ⵉⵙⵙⵉⵏ ⵎⵉⴷⴷⵏ ⵙ ⵓⴹⴼⵕ ⵏ ⵟⵔⵉⴱⵓⵏⴰⵛⵛⵉ.    //ⴷⴰ ⵉⵜⵜⵢⴰⵔⴰ ⴽⵓ ⵢⴰⵏ ⵙ ⵓⵙⵏⵙⵍ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵛⵉ, ⴰⵔ ⵜⵜⵎⵔⴰⵔⴰⵏ ⵉⵎⵓⵙⵏⴰⵡⵏ ⵏ ⵜⵓⵙⵏⴰⴽⵜ ⴳ     // >>> tri((3l))
    // (List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))
    def tri(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
  def tri(n: Long): List[Long] = {
    // Initialize list with the first element of the Tribonacci sequence
    val tribonacciSeq = ListBuffer[Long](3)

    // Generate remaining elements up to the nth element
    for (i <- 1L to n) {
      if (i % 2 == 0) {
        // If even, the formula is 1 + n / 2
        tribonacciSeq.append(1 + i / 2)
      } else {
        // If odd, the formula is tri(n - 1) + tri(n - 2) + tri(n + 1)
        // tri(n + 1) is handled as we iterate further
        val tri_i_minus_1 = if (i - 1 >= 0) tribonacciSeq((i - 1).toInt) else 0
        val tri_i_minus_2 = if (i - 2 >= 0) tribonacciSeq((i - 2).toInt) else 0
        val tri_i_plus_1 = if (i + 1 <= n) 1 + (i + 1) / 2 else 0 // calculated as if the next is even
        tribonacciSeq.append(tri_i_minus_1 + tri_i_minus_2 + tri_i_plus_1)
      }
    }

    // Return as a list
    tribonacciSeq.toList
  }

  // Test examples
  def main(args: Array[String]): Unit = {
    println(tri(3)) // List(3, 2, 8)
  }
}","    }
    def main(args: Array[String]) = {
    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));
    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));
    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));
    assert(tri((6l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));
    assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));
    assert(tri((8l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong))));
    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong))));
    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong, 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));
    assert(tri((0l)).equals((List[Long](1l.toLong))));
    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));
    }

}
"
HumanEval_131,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ 0 ⵎⴽ ⴳⴰⵏ ⴰⴽⴽⵡ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴳⵓⵏⵏ.     //ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵏⵓⵍⴼⵓ ⵜⴰⵢⴰⴼⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ.     // >>> digits((1l))
    // (1l)
    // >>> digits((4l))
    // (0l)
    // >>> digits((235l))
    // (15l)
    def digits(n : Long) : Long = {
","def digits(n: Long): Long = {
    val product = n.toString.map(_.asDigit).filter(_ % 2 != 0).product
    if (product == 1 && n.toString.forall(_.asDigit % 2 == 0)) 0L else product
}","    }
    def main(args: Array[String]) = {
    assert(digits((5l)) == (5l));
    assert(digits((54l)) == (5l));
    assert(digits((120l)) == (1l));
    assert(digits((5014l)) == (5l));
    assert(digits((98765l)) == (315l));
    assert(digits((5576543l)) == (2625l));
    assert(digits((2468l)) == (0l));
    }

}
"
HumanEval_132,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴳ ⵉⵍⵍⴰ ⵓⵙⵎⵓⵏ ⵏ ⴽⵔⴰ ⵏ ⵜⴽⵕⵕⵓⵎⵜ ⴳ ⵜⴹⴼⴼⵓⵕⵜ.    //ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⵏ ⵜⵉⴷⵜ ⵎⴽ ⴷ ⵖⴰⵙ ⵎⴽ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴹⴼⴼⵓⵕ ⵉⵣⵔⴼⴰⵏ ⵏ ⵜⴱⵕⴰⴽⴰⵜⵉⵏ     //ⵔⵥⵎ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⴱⵕⴰⴽⴰⵜⵉⵏ ⵜⵉⴽⵓⴷⴰⵕⵉⵏ     // >>> isNested((""[[]]""))
    // (true)
    // >>> isNested((""[]]]]]]][[[[[]""))
    // (false)
    // >>> isNested((""[][]""))
    // (false)
    // >>> isNested((""[]""))
    // (false)
    // >>> isNested((""[[][]]""))
    // (true)
    // >>> isNested((""[[]][[""))
    // (true)
    def isNested(string : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isNested(string: String): Boolean = {
    var stack = new Stack[Char]()
    var nested = false

    for (char <- string) {
      char match {
        case '[' => stack.push(char)
        case ']' =>
          if (stack.nonEmpty) {
            stack.pop()
            if (stack.nonEmpty) {
              nested = true
            }
          }
      }
      if (nested) return true
    }

    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(isNested((""[[]]"")) == (true));
    assert(isNested((""[]]]]]]][[[[[]"")) == (false));
    assert(isNested((""[][]"")) == (false));
    assert(isNested((""[]"")) == (false));
    assert(isNested((""[[[[]]]]"")) == (true));
    assert(isNested((""[]]]]]]]]]]"")) == (false));
    assert(isNested((""[][][[]]"")) == (true));
    assert(isNested((""[[]"")) == (false));
    assert(isNested((""[]]"")) == (false));
    assert(isNested((""[[]][["")) == (true));
    assert(isNested((""[[][]]"")) == (true));
    assert(isNested(("""")) == (false));
    assert(isNested((""[[[[[[[["")) == (false));
    assert(isNested((""]]]]]]]]"")) == (false));
    }

}
"
HumanEval_133,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⴷⴰ ⵉⵜⵜⵓⵙⵎⵓⵏ ⴽⵓ ⵉⴼⵔⴷⵉⵙ ⴳ ⵜⵍⴳⴰⵎⵜ ⵙ ⵓⴼⵍⵍⴰ ⵏ int ((ⵜⵉⴳⵡⵉⵜ)) ⴳ ⵜⵉⵣⵡⵉⵔⵉ.    //ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⴷ-ⵜⵔⵡⵍ ⵜⵓⵎⴰⵏⵜ ⵏ ⵉⵎⴹⴰⵏ ⵏ ⵓⴽⵓⴱⴰⵕ ⴳ ⵜⵍⴳⴰⵎⵜ ⵉⵜⵜⵓⴼⴽⴰⵏ,     //ⴷⴰ ⵜⵜⵓⵢⴰⴽⴽⴰ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵡⵓⵟⵟⵓⵏ.    // >>> lst((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)))
    // (14l)
    // >>> lst((List[Float](1.0f.toFloat, 4.0f.toFloat, 9.0f.toFloat)))
    // (98l)
    // >>> lst((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat)))
    // (84l)
    // >>> lst((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat)))
    // (29l)
    // >>> lst((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat)))
    // (6l)
    def sumSquares(lst : List[Float]) : Long = {
","import scala.math._

object Problem {
  def sumSquares(lst: List[Float]): Long = {
    lst.map(x => ceil(x.toDouble).toLong)
      .map(x => x * x)
      .sum
  }

  // Example usage, you can test the function with the given examples:
  def main(args: Array[String]): Unit = {
    println(sumSquares(List(1.0f, 2.0f, 3.0f))) // Output: 14
    println(sumSquares(List(1.0f, 4.0f, 9.0f))) // Output: 98
    println(sumSquares(List(1.0f, 3.0f, 5.0f, 7.0f))) // Output: 84
    println(sumSquares(List(1.4f, 4.2f, 0.0f))) // Output: 29
    println(sumSquares(List(-2.4f, 1.0f, 1.0f))) // Output: 6
  }
}","    }
    def main(args: Array[String]) = {
    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));
    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));
    assert(sumSquares((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));
    assert(sumSquares((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat))) == (29l));
    assert(sumSquares((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat))) == (6l));
    assert(sumSquares((List[Float](100.0f.toFloat, 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));
    assert(sumSquares((List[Float](10000.0f.toFloat, 10000.0f.toFloat))) == (200000000l));
    assert(sumSquares((List[Float](-1.4f.toFloat, 4.6f.toFloat, 6.3f.toFloat))) == (75l));
    assert(sumSquares((List[Float](-1.4f.toFloat, 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));
    assert(sumSquares((List[Float](0.0f.toFloat))) == (0l));
    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));
    assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) == (2l));
    }

}
"
HumanEval_134,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⴰⵜⵓⵉⵣⴶⴰⵔ: ""ⴰⵍⵎⴰⵗⵏⴰ"" ⵢⵈⴰⵍ ⵜⴰⵈⵈⵉⵎⵜ ⴰⵏ ⵎⴰⴶⵔⴰⴷ ⴰⵜⵉⵓⴰⵣⴰⵉⴰⵏ ⵙ ⵢⴷⴰⴶ.    //ⴰⵛⵔⵓⵜ ⵏ ⴰⵍⵎⴰⵗⵏⴰ ⴷ ⵓⴰⵔ ⵏ ⵓⵍⴰⵗ ⵋⵉⵔ ⴰⵓⵢⵏ    //ⵏ ⵢⴰⵏ ⵓⵡⵔⵉⴽ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵔⵉⴽ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵓⵔ ⵉⴳⵉ     //ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵎⵓⵖ ⴰⵎⴳⴳⴰⵔⵓ     // >>> checkIfLastCharIsALetter((""apple pie""))
    // (false)
    // >>> checkIfLastCharIsALetter((""apple pi e""))
    // (true)
    // >>> checkIfLastCharIsALetter((""apple pi e ""))
    // (false)
    // >>> checkIfLastCharIsALetter((""""))
    // (false)
    def checkIfLastCharIsALetter(txt : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def checkIfLastCharIsALetter(txt: String): Boolean = {
        if (txt.isEmpty) return false
        val trimmed = txt.trim
        if (trimmed.isEmpty) return false
        val parts = trimmed.split("" "")
        val lastChars = parts.map(_.last)
        if (lastChars.isEmpty) return false
        val lastChar = trimmed.last
        lastChars.contains(lastChar) && lastChar.isLetter
    }
}","    }
    def main(args: Array[String]) = {
    assert(checkIfLastCharIsALetter((""apple"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e"")) == (true));
    assert(checkIfLastCharIsALetter((""eeeee"")) == (false));
    assert(checkIfLastCharIsALetter((""A"")) == (true));
    assert(checkIfLastCharIsALetter((""Pumpkin pie "")) == (false));
    assert(checkIfLastCharIsALetter((""Pumpkin pie 1"")) == (false));
    assert(checkIfLastCharIsALetter(("""")) == (false));
    assert(checkIfLastCharIsALetter((""eeeee e "")) == (false));
    assert(checkIfLastCharIsALetter((""apple pie"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e "")) == (false));
    }

}
"
HumanEval_135,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⴰⵜⵉⴳⵏ ⵉⵎⵎⵓⵟⵟⵓⵏⵏ.    //ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵓⵏⴰⵡ ⴰⴷ, ⵔⴰⴷ ⵏⵔⴰⵔ -1. ⵓⵔ ⵔⴰⴷ ⵜⵍⵍⴰ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ ⴷ ⵉⴼⴽⴰⵏ     //ⵓⵔ ⵉⴳⵉ ⴰⵅⴰⵜⴰⵔ ⵏⵖⴷ ⵉⵎⴽⵏ ⵉ ⵓⵏⴰⵡ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⴷⴰⵜ ⵏⵏⵙ. ⵎⴽ     //ⵔⴰⵏⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⴰⵏⵎⴰⵜⴰⵔ ⴰⵅⴰⵜⴰⵔ ⵏ ⵢⴰⵏ ⵉⴼⵔⴷⵉⵙ ⵏⵏⴰ     // >>> canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))
    // (3l)
    // >>> canArrange((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (-1l)
    def canArrange(arr : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
  def canArrange(arr: List[Long]): Long = {
    for (i <- arr.indices.drop(1)) {
      if (arr(i) < arr(i - 1)) return i.toLong
    }
    -1L
  }
}","    }
    def main(args: Array[String]) = {
    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));
    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));
    assert(canArrange((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong))) == (2l));
    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));
    assert(canArrange((List[Long]())) == (-1l));
    }

}
"
HumanEval_136,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵖⴷ ⵉⵎⵏⴳⵉⵏⵏ, ⵙⵙⴽⵛⵎ-ⴷ None.    //ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵜⵍⴳⴰⵎⵜ.    //ⴰⵎⵇⵇⵔⴰⵏ ⴳ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵔⵡⵉⵏ, ⴷ ""ⴱ"" ⵉⴳⴰ ⴰⵎⵥⵥⵢⴰⵏ     //ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⴰⴱⵔⵔⵉⵜ (ⴰ,ⴱ), ⴳ ⵉⵍⵍⴰ 'ⴰ'     // >>> largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))
    // (Some(None), Some(1l))
    // >>> largestSmallestIntegers((List[Long]()))
    // (Some(None), Some(None))
    // >>> largestSmallestIntegers((List[Long](0l.toLong)))
    // (Some(None), Some(None))
    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long], Option[Long]] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def largestSmallestIntegers(lst: List[Long]): Tuple2[Option[Long], Option[Long]] = {
    val negativeIntegers = lst.filter(_ < 0)
    val positiveIntegers = lst.filter(_ > 0)

    val largestNegative = if (negativeIntegers.nonEmpty) Some(negativeIntegers.max) else None
    val smallestPositive = if (positiveIntegers.nonEmpty) Some(positiveIntegers.min) else None

    (largestNegative, smallestPositive)
  }
}","    }
    def main(args: Array[String]) = {
    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));
    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));
    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));
    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));
    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));
    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));
    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None), Some(None))));
    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));
    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));
    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, 1l.toLong))).equals((-3l, 1l)));
    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));
    }

}
"
HumanEval_138,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ    //ⵔⵣⵓ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵡⵓⵟⵟⵓⵏ n ⵉⵖⵢ ⴰⴷ ⵉⵜⵜⵢⴰⵔⴰ ⵙ ⵓⵖⵣⵓⵔ ⵏ ⴽⴽⵓⵥ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉⵃⵍⴰⵏ     // >>> isEqualToSumEven((4l))
    // (false)
    // >>> isEqualToSumEven((6l))
    // (false)
    // >>> isEqualToSumEven((8l))
    // (true)
    def isEqualToSumEven(n : Long) : Boolean = {
","def isEqualToSumEven(n: Long): Boolean = {
    // Explanation: A number is the sum of 4 positive even numbers if it is at least 8 and even.
    n >= 8 && n % 2 == 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(isEqualToSumEven((4l)) == (false));
    assert(isEqualToSumEven((6l)) == (false));
    assert(isEqualToSumEven((8l)) == (true));
    assert(isEqualToSumEven((10l)) == (true));
    assert(isEqualToSumEven((11l)) == (false));
    assert(isEqualToSumEven((12l)) == (true));
    assert(isEqualToSumEven((13l)) == (false));
    assert(isEqualToSumEven((16l)) == (true));
    }

}
"
HumanEval_139,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⴳ ⵉⵍⵍⴰ n > 0     //brazilian_factorial{n} = n! * (n-1)! * (n-2)! * ... * 1!     //ⴷⴰ ⵉⵜⵜⵓⵙⵏⵎⵍ ⵓⴼⴰⴽⵜⵓⵔⴰⵍ ⴰⴱⵕⴰⵣⵉⵍⵉ ⵙ:     // >>> specialFactorial((4l))
    // (288l)
    // The function will receive an integer as input and should return the special
    // factorial of this integer.
    def specialFactorial(n : Long) : Long = {
","def specialFactorial(n: Long): Long = {
        def factorial(x: Long): Long = {
            if (x == 0 || x == 1) 1L
            else x * factorial(x - 1)
        }

        (1L to n).map(factorial).product
    }
}","    }
    def main(args: Array[String]) = {
    assert(specialFactorial((4l)) == (288l));
    assert(specialFactorial((5l)) == (34560l));
    assert(specialFactorial((7l)) == (125411328000l));
    assert(specialFactorial((1l)) == (1l));
    }

}
"
HumanEval_140,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴷⴼⴼⵉⵔ ⴰⴷ ⵙⵏⴼⵍ ⵉⵙⴰⵢⵔⴰⵔⵏ ⴰⴽⴽⵡ ⵉⵎⵣⴷⴰⵢⵏ ⵙ -     //ⴷ ⵎⴽ ⴳⴰⵏ ⵜⵉⵙⵉⴹⴼⴰⵏⵉⵏ ⵓⴳⴳⴰⵔ ⵏ 2 ⵏ ⵡⴰⵏⵙⴰ ⵉⵎⴹⴼⴰⵕⵏ,     //ⴹⴰⵗ ⵜⴰⵙⴰⵙⵙⴰⵗⵔⴰⵓⵜ ⵏ ⵉⴾⵉⵜⴱⴰⵏ, ⵙⴰⵎⵎⵓⵜⵜⵉ ⵏ ⵉⵂⴰⵏⴷⴰⴶⴰⵏ ⴼⵓⴾ ⴷⴰⵗ ⵢⴷⵢⵙ ⵏ ⴾⴰⵔⵜⵉ ⵜⴰⵏ    // >>> fixSpaces(("" Example""))
    // (""Example"")
    // >>> fixSpaces(("" Example 1""))
    // (""Example_1"")
    // >>> fixSpaces(("" Example 2""))
    // (""_Example_2"")
    // >>> fixSpaces(("" Example 3""))
    // (""_Example-3"")
    def fixSpaces(text : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fixSpaces(text: String): String = {
    val result = new StringBuilder()
    var spaceCount = 0
    var leadingSpace = true
    
    for (ch <- text) {
      if (ch == ' ') {
        spaceCount += 1
      } else {
        if (spaceCount > 0) {
          if (leadingSpace && result.isEmpty) {
            result.append('_')
          } else if (spaceCount == 1) {
            result.append('_')
          } else if (spaceCount > 1) {
            result.append('-')
          }
          spaceCount = 0
        }
        result.append(ch)
        leadingSpace = false
      }
    }
    
    if (spaceCount == 1) {
      result.append('_')
    } else if (spaceCount > 1) {
      result.append('-')
    }
    
    result.toString()
  }
}","    }
    def main(args: Array[String]) = {
    assert(fixSpaces((""Example"")).equals((""Example"")));
    assert(fixSpaces((""Mudasir Hanif "")).equals((""Mudasir_Hanif_"")));
    assert(fixSpaces((""Yellow Yellow  Dirty  Fellow"")).equals((""Yellow_Yellow__Dirty__Fellow"")));
    assert(fixSpaces((""Exa   mple"")).equals((""Exa-mple"")));
    assert(fixSpaces((""   Exa 1 2 2 mple"")).equals((""-Exa_1_2_2_mple"")));
    }

}
"
HumanEval_141,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //- ⵉⵇⵏⴻⵏ ⴰⴷ ⵉⴳ ⵓⵙⵏⴼⵍⵓⵍ ⴷⴼⴼⵉⵔ ⵜⴱⵔⵉⴷⵜ ⵢⴰⵏ ⴳ ⵡⴰⵏⵏⴰ ⴷⴷⵖ: ['txt', 'exe', 'dll']     //ⴰⵍⴾⴰⴷⴰⵏ ⵓⵉⵏ ⵍⴰⵜⵉⵏ (""ⴰ-ⵣ"" ⴷ ""ⴰ-ⵣ"")    //- ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵢⵉⵍⵉ ⵡⴰⵏⵙⴰ ⴷⴰⵜ ⵏ ⵜⴱⵔⵉⴷⵜ, ⴰⵔ ⵜⴱⴷⴰⴷ ⵙ ⵓⴱⵔⵉⴷ     //- ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⵉⵍⵍⴰ ⴳⵉⵙ ⵢⴰⵏ ⵓⴱⵔⵉⴽⵜ '.'     //- ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵉⵍⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⴽⵕⴰⴹ ⵏ ⵡⵓⵟⵟⵓⵏ (""0"" - ""9"") ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ.     //ⵜⵜⵓⵙⵎⵓⵏ:     //ⵉⵙⵎ ⵏ ⵓⴱⵔⵓⴹⵉⵣ ⴰⵔ ⵉⵜⵜⵓⵙⵡⴰⵏ ⵉⵙ ⵉⴳⴰ ⵡⴰⵍⵍⵉ ⵉⵣⵔⵉⵏ ⵎⴽ ⴷ ⵎⴽ ⴷⴰ ⵇⵇⴰⵔⵏ ⴽⵓⵍⵍⵓ ⵜⵎⵙⴰⵔⵉⵏ ⴷⴷⵖ     //""ⴷⴰ"" ⵉⵖ ⵉⴳⴰ ⵢⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⴰⵣⵔⴼⴰⵏ, ⴰⵔ ⵉⵜⵜⵔⴰⵔ ""ⵓⵀⵓ"" ⵎⴽ ⵓⵔ ⵉⴳⵉ.     //ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵜⵜⵓ ⵉⵙⵎⴷⵢⴰ ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ, ⴰⵔ ⵉⵜⵜⵔⴰⵔ     // >>> fileNameCheck((""example.txt""))
    // (""Yes"")
    // >>> fileNameCheck((""1example.dll""))
    // (""No"")
    def fileNameCheck(file_name : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fileNameCheck(file_name: String): String = {
    val validExtensions = Set(""txt"", ""exe"", ""dll"")
    val dotIndex = file_name.lastIndexOf('.')

    if (dotIndex == -1) return ""No""

    val beforeDot = file_name.substring(0, dotIndex)
    val afterDot = file_name.substring(dotIndex + 1)

    if (beforeDot.isEmpty || !beforeDot.head.isLetter) return ""No""

    val digitCount = beforeDot.count(_.isDigit)
    if (digitCount > 3) return ""No""

    if (!validExtensions.contains(afterDot)) return ""No""

    ""Yes""
  }

  def main(args: Array[String]): Unit = {
    println(fileNameCheck(""example.txt"")) // ""Yes""
    println(fileNameCheck(""1example.dll"")) // ""No""
    println(fileNameCheck(""test123.exe"")) // ""Yes""
    println(fileNameCheck("".hidden.txt"")) // ""No""
    println(fileNameCheck(""file..txt"")) // ""No""
  }
}","    }
    def main(args: Array[String]) = {
    assert(fileNameCheck((""example.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""1example.dll"")).equals((""No"")));
    assert(fileNameCheck((""s1sdf3.asd"")).equals((""No"")));
    assert(fileNameCheck((""K.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""MY16FILE3.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""His12FILE94.exe"")).equals((""No"")));
    assert(fileNameCheck((""_Y.txt"")).equals((""No"")));
    assert(fileNameCheck((""?aREYA.exe"")).equals((""No"")));
    assert(fileNameCheck((""/this_is_valid.dll"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.wow"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""this_is_valid.txtexe"")).equals((""No"")));
    assert(fileNameCheck((""#this2_i4s_5valid.ten"")).equals((""No"")));
    assert(fileNameCheck((""@this1_is6_valid.exe"")).equals((""No"")));
    assert(fileNameCheck((""this_is_12valid.6exe4.txt"")).equals((""No"")));
    assert(fileNameCheck((""all.exe.txt"")).equals((""No"")));
    assert(fileNameCheck((""I563_No.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""Is3youfault.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""no_one#knows.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""1I563_Yes3.exe"")).equals((""No"")));
    assert(fileNameCheck((""I563_Yes3.txtt"")).equals((""No"")));
    assert(fileNameCheck((""final..txt"")).equals((""No"")));
    assert(fileNameCheck((""final132"")).equals((""No"")));
    assert(fileNameCheck((""_f4indsartal132."")).equals((""No"")));
    assert(fileNameCheck(("".txt"")).equals((""No"")));
    assert(fileNameCheck((""s."")).equals((""No"")));
    }

}
"
HumanEval_142,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⵔⴰⴷ ⵜⵙⵏⴼⵍ ⵜⵎⵙⴽⵜⵉⵜⵉⵏ ⴳ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵏ 3 ⵏⵖⴷ 4. ⵔⴰⴷ ⵜⵕⵡⵍ ⵜⵡⵡⵓⵔⵉ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵜⵎⵙⴽⵜⵉⵜⵉⵏ ⴰⴽⴽⵡ.    //ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3 ⴷ ⵔⴰⴷ ⵢⴰⴽⵣ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴳ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 4 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3. ⵓⵔ ⵔⴰⴷ ⵜⴳⴳ ⵜⴰⵡⵓⵔⵉ ⴰⴷ     //ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⵕⵥⵎ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵉ ⴽⵓⵍⵍⵓ ⵜⵉⴽⵛⵛⵓⵎⵉⵏ ⴳ ⵜⵍⴳⴰⵎⵜ, ⵔⴰⴷ ⵜⵕⵥⵎ ⵜⴰⵡⵓⵔⵉ ⵜⴰⴽⵕⴹⴰ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴳ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ     //""     // >>> lst
    // List[Long](1l.toLong, 2l.toLong, 3l.toLong)
    // >>> lst
    // List[Long]()
    // >>> lst
    // List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong)
    def sumSquares(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def sumSquares(lst: List[Long]): Long = {
        lst.zipWithIndex.map { case (value, index) =>
            if (index % 3 == 0) {
                value * value
            } else if (index % 4 == 0) {
                value * value * value
            } else {
                value
            }
        }.sum
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumSquares((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (6l));
    assert(sumSquares((List[Long](1l.toLong, 4l.toLong, 9l.toLong))) == (14l));
    assert(sumSquares((List[Long]())) == (0l));
    assert(sumSquares((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))) == (9l));
    assert(sumSquares((List[Long](-1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong))) == (-3l));
    assert(sumSquares((List[Long](0l.toLong))) == (0l));
    assert(sumSquares((List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong))) == (-126l));
    assert(sumSquares((List[Long](-56l.toLong, -99l.toLong, 1l.toLong, 0l.toLong, -2l.toLong))) == (3030l));
    assert(sumSquares((List[Long](-1l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, -1l.toLong))) == (0l));
    assert(sumSquares((List[Long](-16l.toLong, -9l.toLong, -2l.toLong, 36l.toLong, 36l.toLong, 26l.toLong, -20l.toLong, 25l.toLong, -40l.toLong, 20l.toLong, -4l.toLong, 12l.toLong, -26l.toLong, 35l.toLong, 37l.toLong))) == (-14196l));
    assert(sumSquares((List[Long](-1l.toLong, -3l.toLong, 17l.toLong, -1l.toLong, -15l.toLong, 13l.toLong, -1l.toLong, 14l.toLong, -14l.toLong, -12l.toLong, -5l.toLong, 14l.toLong, -14l.toLong, 6l.toLong, 13l.toLong, 11l.toLong, 16l.toLong, 16l.toLong, 4l.toLong, 10l.toLong))) == (-1448l));
    }

}
"
HumanEval_143,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ 1:    //ⵍⴰⵀⴰⵏ ⵏ ⵡⴰⵡⴰⵍ ⴳ ⵜⵣⵍⵉⵜ ⵜⴰⵎⴰⵢⵏⵓⵜ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⵎⴽⵉⵏ ⵡⵉⵙⵙ ⵓⵣⵡⴰⵔⵓ.    //ⵜⵉⵖⵣⵉ ⵏⵏⵙ ⵜⴳⴰ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ,     //ⴷ ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⵉⵜⵓⵔ ⵙⵜⵔⵉⴳ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵏ ⵜⴳⵓⵔⵉ ⵜⴰⵢⵎⵎⴰⵜ,     //ⵜⴰⴳⵓⵔⵉ ⵜⵍⴰ ⴽⵔⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵜⵜⵓⵢⴼⵔⴰⵔⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ,     //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎ ⵉⵙⵎⴷⵢⴰⵏ ⵜⴰⴳⵓⵔⵉ,     // >>> wordsInSentence((""This is a test""))
    // (""is"")
    // Example 2:
    // >>> wordsInSentence((""lets go for swimming""))
    // (""go for"")
    // Constraints:
    // * 1 <= len(sentence) <= 100
    // * sentence contains only letters
    def wordsInSentence(sentence : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isPrime(n: Int): Boolean = {
    if (n < 2) false
    else if (n == 2) true
    else !(2 to sqrt(n).toInt).exists(n % _ == 0)
  }

  def wordsInSentence(sentence: String): String = {
    val words = sentence.split("" "")
    val primeLengthWords = words.filter(word => isPrime(word.length))
    primeLengthWords.mkString("" "")
  }
  
  // Example usage:
  // println(wordsInSentence(""This is a test""))
  // println(wordsInSentence(""lets go for swimming""))
}","    }
    def main(args: Array[String]) = {
    assert(wordsInSentence((""This is a test"")).equals((""is"")));
    assert(wordsInSentence((""lets go for swimming"")).equals((""go for"")));
    assert(wordsInSentence((""there is no place available here"")).equals((""there is no place"")));
    assert(wordsInSentence((""Hi I am Hussein"")).equals((""Hi am Hussein"")));
    assert(wordsInSentence((""go for it"")).equals((""go for it"")));
    assert(wordsInSentence((""here"")).equals(("""")));
    assert(wordsInSentence((""here is"")).equals((""is"")));
    }

}
"
HumanEval_144,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉ ⵎⴰⵙ ⴷ x, ⴷ n ⴳⴰⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵖⵓⴷⴰⵏ, ⴷ ⵓⵔ ⴷⴰⵔⵙⵏ ⵓⵎⵢⴰ ⴰⵎⵎ ⵓⵎⵙⵙⴰⵖ.    //<numerator>/<denominator> ⴳⴰⵏ ⵙⵉⵏ ⵉⵎⵉⴹⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵉⵎⵙⵙⴰⵖⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ.     //ⵎⴽⵍⵍⵉ, ⴳⴰⵏ x ⴷ n, ⴰⵙⵎⴷⵢⴰ ⵏ ⵓⴽⵙⴰⵢ ⵏ ⵜⴳⵣⵣⵓⵎⵜ, ⴷ ⵖⵓⵔⵙⵏ ⵜⴰⵍⵖⴰ ⴷ ⵢⵓⵛⴽⴰⵏ,     //x * n. ⴷⴰ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ ⵜⵉⴷⵜ ⵎⴽ ⵜⵙⵙⵎⵔⴰⵙ x * n ⵉ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴷ ⵜⵉⴷⵜ     //ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵜ ⵏⵏⴰ ⵔⴰⴷ ⵉⵙⴱⴷⵉⴷ ⴰⵙⵏⵓⵎⵎⵍ     // >>> simplify((""1/5""), (""5/1""))
    // (true)
    // >>> simplify((""1/6""), (""2/1""))
    // (false)
    // >>> simplify((""7/10""), (""10/2""))
    // (false)
    def simplify(x : String, n : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def simplify(x: String, n: String): Boolean = {
    def parseFraction(fraction: String): (Int, Int) = {
      val parts = fraction.split(""/"")
      (parts(0).toInt, parts(1).toInt)
    }

    val (numX, denX) = parseFraction(x)
    val (numN, denN) = parseFraction(n)

    val multipliedNumerator = numX * numN
    val multipliedDenominator = denX * denN

    multipliedNumerator % multipliedDenominator == 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/6""), (""2/1"")) == (false));
    assert(simplify((""5/1""), (""3/1"")) == (true));
    assert(simplify((""7/10""), (""10/2"")) == (false));
    assert(simplify((""2/10""), (""50/10"")) == (true));
    assert(simplify((""7/2""), (""4/2"")) == (true));
    assert(simplify((""11/6""), (""6/1"")) == (true));
    assert(simplify((""2/3""), (""5/2"")) == (false));
    assert(simplify((""5/2""), (""3/5"")) == (false));
    assert(simplify((""2/4""), (""8/4"")) == (true));
    assert(simplify((""2/4""), (""4/2"")) == (true));
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/5""), (""1/5"")) == (false));
    }

}
"
HumanEval_145,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⵔⴰⵏⵜ-ⴰⵙ ⵙ ⵜⴰⵍⵗⴰ ⵜⴰⵏ ⴾⴰⵔⵜⵉ ⵜⴰⵏ ⵏⴰⵙⴰⵏ ⴷⴰⵗ ⵍⵉⵙⵜ ⵓⴰⵏ ⴰⵍⴰⵙⴰⵍ    //ⴰⵜⵡⵉⵍ: ⵉⵖ ⵉⵍⵍⴰ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵙ ⵡⴰⵜⵉⴳ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ,     //ⵙ ⵓⵍⵖⵓ ⴰⵎⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ.    //ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵙⵎⵓⵏⵏ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ     // >>> orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong)))
    // (List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))
    // >>> orderByPoints((List[Long]()))
    // (List[Long]())
    def orderByPoints(nums : List[Long]) : List[Long] = {
","def orderByPoints(nums: List[Long]): List[Long] = {
    def digitSum(n: Long): Int = n.abs.toString.map(_.asDigit).sum
    
    nums.zipWithIndex
      .sortBy { case (num, index) => (digitSum(num), index) }
      .map(_._1)
  }
}","    }
    def main(args: Array[String]) = {
    assert(orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));
    assert(orderByPoints((List[Long](1234l.toLong, 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong, 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong, 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));
    assert(orderByPoints((List[Long]())).equals((List[Long]())));
    assert(orderByPoints((List[Long](1l.toLong, -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong, -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));
    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong, 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))));
    assert(orderByPoints((List[Long](0l.toLong, 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong, -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));
    }

}
"
HumanEval_146,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏⵜ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⵉⵏ ⴹⴰⵕⵜ ⵓⴳⴳⴰⵔ ⵏ ⵡⵓⵟⵟⵓⵏ (1, 3, 5, 7, 9).    //ⴰⵎⴹⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ ⵢⵓⴳⵔⵏ 10 ⴷ ⵙⵏⴰⵜ     //ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴷ ⵓⵙⵏⴼⵍ     // >>> specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong)))
    // (1l)
    // >>> specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong)))
    // (2l)
    def specialFilter(nums : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def specialFilter(nums: List[Long]): Long = {
    def isOddDigit(c: Char): Boolean = c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
    
    nums.count { num =>
      val absNumStr = num.abs.toString
      val firstDigit = absNumStr.head
      val lastDigit = absNumStr.last
      
      num > 10 && isOddDigit(firstDigit) && isOddDigit(lastDigit)
    }.toLong
  }

  def main(args: Array[String]): Unit = {
    println(specialFilter(List(15L, -73L, 14L, -15L))) // Output: 1
    println(specialFilter(List(33L, -2L, -3L, 45L, 21L, 109L))) // Output: 2
  }
}","    }
    def main(args: Array[String]) = {
    assert(specialFilter((List[Long](5l.toLong, -2l.toLong, 1l.toLong, -5l.toLong))) == (0l));
    assert(specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong))) == (1l));
    assert(specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong))) == (2l));
    assert(specialFilter((List[Long](43l.toLong, -12l.toLong, 93l.toLong, 125l.toLong, 121l.toLong, 109l.toLong))) == (4l));
    assert(specialFilter((List[Long](71l.toLong, -2l.toLong, -33l.toLong, 75l.toLong, 21l.toLong, 19l.toLong))) == (3l));
    assert(specialFilter((List[Long](1l.toLong))) == (0l));
    assert(specialFilter((List[Long]())) == (0l));
    }

}
"
HumanEval_147,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:    //ⴷ a[i] + a[j] + a[k] ⴷ ⴰⵎⵔⴰⵔⵓ ⵏ 3.     //ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵔⴱⵉⵍⵉⵏ (ⴰ[i], ⴰ[ⵊ], ⴰ[ⴽ]) ⵏ ⴰ ⴳ ⵉⵍⵍⴰ i < ⵊ < ⴽ,     //ⵉ ⴽⵓ i (1 ≤ i ≤ n), ⴰⵜⵉⴳ ⵏ a[i] = i * i - i + 1.     //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ n. ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⴽⴰⵔ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⵏ ⵜⵉⵖⵣⵉ n.     // >>> getMaxTriples((5l))
    // (1l)
    // Explanation: 
    // a = [1, 3, 7, 13, 21]
    // The only valid triple is (1, 7, 13).
    def getMaxTriples(n : Long) : Long = {
","def getMaxTriples(n: Long): Long = {
    val a = (1L to n).map(i => i * i - i + 1).toList
    var count = 0L

    for {
      i <- 0L until n
      j <- i + 1 until n
      k <- j + 1 until n
    } {
      if ((a(i.toInt) + a(j.toInt) + a(k.toInt)) % 3 == 0) {
        count += 1
      }
    }

    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(getMaxTriples((5l)) == (1l));
    assert(getMaxTriples((6l)) == (4l));
    assert(getMaxTriples((10l)) == (36l));
    assert(getMaxTriples((100l)) == (53361l));
    }

}
"
HumanEval_148,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ    //ⵓⵔ ⴳⵉⵏ ⵉⵙⵎⴰⵡⵏ ⵏ ⵉⵜⵔⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ.    //ⵜⵣⵎⵔ ⵜⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵏⵓ ⵜⴰⴱⵍⵓⵜ ⵜⴰⵅⵅⴰⵔⵜ ⵎⴽ ⵜⴳⴰ planete1 ⵏⵖ planete2     //ⵜⴰⵣⵓⵍⵉ ⵏ ⵜⴰⴼⵓⴾⵜ    //ⵉⵍⵍⴰⵏ ⵋⵉⵔ ⵜⴰⵗⵉⵙⵙⴰ ⵏ ⴱⵍⴰⵢⵏⵢⵜ1 ⴷ ⵜⴰⵗⵉⵙⵙⴰ ⵏ ⴱⵍⴰⵢⵏⵢⵜ2, ⵉⵋⵋⴰⵏ ⵙ     //ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⵡⴰⵍ ⵜⴰⴱⵍⵓⵜ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⴰⴽⴽⵡ ⵉⵜⵔⴰⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⵜⵉⵖⵔⴱⴰⵏ ⵏⵏⵙⵏ     //ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵙⵎⴰⵡⵏ ⵏ ⵉⵜⵔⴰⵏ ⴰⵎⵎ ⵜⵉⵙⵉⴹⴼⵕⵉⵏ planet1 ⴷ planet2.    //ⵓⵓⵔⴰⵏⵓⵙ, ⵏⴻⴱⵜⵓⵏⴻ.    //ⵉⴳⴰ ⵎⵉⵔⴽⵓⵔⵉ, ⵡⴰⵏⵏⴰ ⴷ ⵉⴷⴷⴰⵏ ⵉⴳⴰ ⵡⵉⵏⵓⵙ, ⴷⴼⴼⵉⵔ ⵏ ⵖⵉⵍⴰⴷ ⵉⴳⴰ ⵡⴰⴽⴰⵍ, ⵎⴰⵕⵙ, ⵊⵓⴱⵉⵜⵔ, ⵙⴰⵜⵓⵔⵏ,     //ⵍⵍⴰⵏⵜ 8 ⵏ ⵜⵣⵡⵉⵏⵏⵉⵜⵉⵏ ⴳ ⵓⵏⴳⵔⴰⵡ ⵏ ⵜⴰⴼⵓⴽⵜ ⵏⵏⵖ: ⵜⵉⴷⵙⵜ ⵜⴰⴷⵙⵜⵔⴰⵔⵜ ⵏ ⵜⴰⴼⵓⴽⵜ.    // >>> bf((""Jupiter""), (""Neptune""))
    // (List[String](""Saturn"", ""Uranus""))
    // >>> bf((""Earth""), (""Mercury""))
    // (List[String](""Venus""))
    // >>> bf((""Mercury""), (""Uranus""))
    // (List[String](""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""))
    def bf(planet1 : String, planet2 : String) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def bf(planet1: String, planet2: String): List[String] = {
    val planets = List(""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    
    // Find the indices of the given planets
    val index1Opt = planets.indexOf(planet1)
    val index2Opt = planets.indexOf(planet2)
    
    // If either planet is not found, return an empty list
    if (index1Opt == -1 || index2Opt == -1) {
      return List.empty
    }
    
    // Sort indices to ensure proper traversal direction
    val (startIndex, endIndex) = if (index1Opt < index2Opt) (index1Opt, index2Opt) else (index2Opt, index1Opt)
    
    // Get the planets between the indices
    planets.slice(startIndex + 1, endIndex)
  }
}","    }
    def main(args: Array[String]) = {
    assert(bf((""Jupiter""), (""Neptune"")).equals((List[String](""Saturn"", ""Uranus""))));
    assert(bf((""Earth""), (""Mercury"")).equals((List[String](""Venus""))));
    assert(bf((""Mercury""), (""Uranus"")).equals((List[String](""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""))));
    assert(bf((""Neptune""), (""Venus"")).equals((List[String](""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""))));
    assert(bf((""Earth""), (""Earth"")).equals((List[String]())));
    assert(bf((""Mars""), (""Earth"")).equals((List[String]())));
    assert(bf((""Jupiter""), (""Makemake"")).equals((List[String]())));
    }

}
"
HumanEval_149,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴷ ⵉⵙ ⵇⴰⴷ ⵢⵉⵍⵉ ⵓⵖⵣⵉ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴽⴽⵡ.    //ⵍⴰⵇⴱⴰⵍ ⴰⴷ ⵜⵙⴽⵔ ⵜⵡⵓⵔⵉ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⵉⴼⵔⵉⵙⵉⵏ ⵙ ⵓⵏⵎⴰⵍⴰ ⵏ ⵓⵙⵎⵙⴰⵙⴰ.    //ⵎⴽ ⴳⴰⵏ ⵙⵉⵏ ⵡⴰⵡⴰⵍⵏ ⵖⵓⵔⵙⵏ ⵜⵉⵖⵣⵉ ⵉⵎⴽⵏ, ⵙⵙⵓⴷⵙ ⵉⵙⵎ ⴳ ⵓⵏⵎⴰⵍⴰ ⵏ ⵓⵙⴽⴽⵉⵍ.    //ⵉⵇⵏⴻⵏ ⴰⴷ ⴷ-ⵔⴻⴱⵜⵔⴻ ⵜⴰⵍⵉⵜ ⵙ ⵜⴰⵍⵉⵜ.    //ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵢⵉⵍⵉ ⵓⵙⵙⵓⴷⵙ ⵏ ⵜⵍⴳⴰⵎⵜ ⵙ ⵓⵙⵙⴼⵍⴷ ⵙ ⵜⵉⵖⵣⵉ ⵏ ⴽⵓ ⵜⴳⵓⵔⵉ, ⴷ ⵇⴰⴷ     //ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⵢⵂⴰ ⵉⴾⵉⵜⴱⴰⵏ    //ⵀⴰⵜ ⵉⴳⴰ ⵡⴰⵔⵔⴰ ⴰⵀⴰ ⵢⴰⵏ ⵡⴰⵔⵔⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵓⵔ ⵉⴳⵉ ⵡⴰⵔⵔⴰ ⵏ ⵉⵎⴹⴰⵏ,    //ⴷ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⴰⵍⴳⴰⵎⵜ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⵙ ⵓⵙⵓⴷⵙ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ,     //ⴷⴰ ⵉⵜⵜⵓⵙⴽⵙⵉ ⵜⵉⴼⵔⴽⵉⵏ ⵏⵏⴰ ⵖⵓⵔ ⵍⵍⴰⵏ ⵜⵉⵖⵣⵉⵡⵉⵏ ⵓⵔ ⵉⵎⵙⴰⵙⴰⵏ,     //ⵔⵔⴰⵎ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⵉⴼⵔⵉⵙⵉⵏ ⴰⵎⵎ ⵓⵎⵙⴽⴰⵔ,    // >>> listSort((List[String](""aa"", ""a"", ""aaa"")))
    // (List[String](""aa""))
    // >>> listSort((List[String](""ab"", ""a"", ""aaa"", ""cd"")))
    // (List[String](""ab"", ""cd""))
    def sortedListSum(lst : List[String]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def listSort(lst: List[String]): List[String] = {
        lst.filter(_.length % 2 == 0)
           .sorted
           .sortBy(_.length)
    }
}","    }
    def main(args: Array[String]) = {
    assert(sortedListSum((List[String](""aa"", ""a"", ""aaa""))).equals((List[String](""aa""))));
    assert(sortedListSum((List[String](""school"", ""AI"", ""asdf"", ""b""))).equals((List[String](""AI"", ""asdf"", ""school""))));
    assert(sortedListSum((List[String](""d"", ""b"", ""c"", ""a""))).equals((List[String]())));
    assert(sortedListSum((List[String](""d"", ""dcba"", ""abcd"", ""a""))).equals((List[String](""abcd"", ""dcba""))));
    assert(sortedListSum((List[String](""AI"", ""ai"", ""au""))).equals((List[String](""AI"", ""ai"", ""au""))));
    assert(sortedListSum((List[String](""a"", ""b"", ""b"", ""c"", ""c"", ""a""))).equals((List[String]())));
    assert(sortedListSum((List[String](""aaaa"", ""bbbb"", ""dd"", ""cc""))).equals((List[String](""cc"", ""dd"", ""aaaa"", ""bbbb""))));
    }

}
"
HumanEval_150,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⵔⴰⴷ ⵢⴰⴽⴽⴰ ⵡⴰⵜⵉⴳ ⵏ y ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵡⴰⵜⵉⴳ ⴰⵎⵣⵡⴰⵔⵓ.    //ⴰⵖⴰⵡⴰⵙ ⴰⵎⵢⵉⵡⵏ ⵏⵏⴰ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⴰ ⴰⵜⵉⴳ ⵏ x ⵎⴽ ⵉⴳⴰ n     // >>> xOrY((7l), (34l), (12l))
    // (34l)
    // >>> xOrY((15l), (8l), (5l))
    // (5l)
    def xOrY(n : Long, x : Long, y : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  
  def isPrime(num: Long): Boolean = {
    if (num <= 1) return false
    if (num <= 3) return true
    if (num % 2 == 0 || num % 3 == 0) return false
    var i = 5
    while (i * i <= num) {
      if (num % i == 0 || num % (i + 2) == 0) return false
      i += 6
    }
    true
  }

  def xOrY(n: Long, x: Long, y: Long): Long = {
    if (isPrime(n)) x else y
  }
}","    }
    def main(args: Array[String]) = {
    assert(xOrY((7l), (34l), (12l)) == (34l));
    assert(xOrY((15l), (8l), (5l)) == (5l));
    assert(xOrY((3l), (33l), (5212l)) == (33l));
    assert(xOrY((1259l), (3l), (52l)) == (3l));
    assert(xOrY((7919l), (-1l), (12l)) == (-1l));
    assert(xOrY((3609l), (1245l), (583l)) == (583l));
    assert(xOrY((91l), (56l), (129l)) == (129l));
    assert(xOrY((6l), (34l), (1234l)) == (1234l));
    assert(xOrY((1l), (2l), (0l)) == (0l));
    assert(xOrY((2l), (2l), (0l)) == (2l));
    }

}
"
HumanEval_151,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴳ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ ⵓⵔ ⵉⵎⴽⵍⵉ. ⵅⵙⵉ ⵉⵎⴹⴰⵏ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ.    //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵍⴳⴰⵎⵜ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵙⵏⵓⵍⴼⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ     // >>> doubleTheDifference((List[Float](1l.toLong, 3l.toLong, 2l.toLong, 0l.toLong)))
    // (10l)
    // >>> doubleTheDifference((List[Float](-1l.toLong, -2l.toLong, 0l.toLong)))
    // (0l)
    // >>> doubleTheDifference((List[Float](9l.toLong, -2l.toLong)))
    // (81l)
    // >>> doubleTheDifference((List[Float](0l.toLong)))
    // (0l)
    // If the input list is empty, return 0.
    def doubleTheDifference(lst : List[Float]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def doubleTheDifference(lst: List[Float]): Long = {
    lst.filter(x => x > 0 && x.isValidLong && x.toLong % 2 != 0)
      .map(x => x.toLong * x.toLong)
      .sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(doubleTheDifference((List[Float]())) == (0l));
    assert(doubleTheDifference((List[Float](5.0f.toFloat, 4.0f.toFloat))) == (25l));
    assert(doubleTheDifference((List[Float](0.1f.toFloat, 0.2f.toFloat, 0.3f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](-10.0f.toFloat, -20.0f.toFloat, -30.0f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](-1.0f.toFloat, -2.0f.toFloat, 8.0f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](0.2f.toFloat, 3.0f.toFloat, 5.0f.toFloat))) == (34l));
    assert(doubleTheDifference((List[Float](-9.0f.toFloat, -7.0f.toFloat, -5.0f.toFloat, -3.0f.toFloat, -1.0f.toFloat, 1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat, 9.0f.toFloat))) == (165l));
    }

}
"
HumanEval_152,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:    //ⴰⵍⵈⵉⵎ ⵢⵈⵈⴰⵍ 0, ⵎⵢⵗ ⴰ ⴼⴰⵍ ⵓⴰⵔ ⵢⵈⵈⵢⵍ, ⴰⵍⵈⵉⵎ ⵢⵈⵈⴰⵍ ⴰⵏⵎⵉⵣⵍⴰⵉ ⵓⵍⴰⵗⴰⵏ ⵋⵉⵔ ⵜⴰ-ⵉⵜⵢ ⴷ ⵜⵢⵗⴰⵔⵢ    //ⵔⵉⵜⵓⵔⵏ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⵉⵖⵣⵉ ⵏⵏⴰ ⴷ ⵢⴰⴽⴽⴰⵏ ⵜⴰⵖⵣⵉ ⵏ ⴽⵓ ⴰⵙⵏⵖⵍ. ⵎⴽ ⵜⵔⵏⴰ ⵙ ⵜⴷⵓⵙⵉ,     //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵏⴰⵜ ⵜⵍⴳⴰⵎⵉⵏ ⵏ ⵜⵏⴰⴼⵓⵜⵉⵏ ⴷ ⵉⵙⵡⵉⵏⴳⵉⵎⵏ ⵏ ⵜⵉⵖⵣⵉ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⴳ ⴷⴰ ⵉⵙⵙⴼⵔⴰⵢ ⴽⵓ ⵉⵎⵉⴹ ⵢⴰⵜ ⵜⵎⵙⴰⵙⴰ.    //ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ ⴰⴾⴰⵉⴰⴷ ⴰⵙ ⴰⵓⴰⴷⵉⵎ ⵉⵋⵋⴰ ⴰⴾⴰⵉⴰⴷ ⵙ ⵜⵉⴷⵉⵜⵜ ⴼⴰⵍ ⵜⵉⵏⴼⴰ ⵏ ⵉⵛⵂ-ⵉⴾⵉⵍⴰⵏ    //ⴰⵍⴰⵗⵉ ⵏⴰⵜ ⴰⵙ ⵉⵋⵋⴰ ⴰⴾⴰⵉⴰⴷ ⴷ ⴰⵙⵉⴾⵉ ⵏⵢⵜ    //ⴰⴾⴰⵉⴰⴷ ⵓⴰ ⵉⴾⵏⴰⵏ ⵜⴰ-ⵉⵜⵢ ⵏ-ⴰⴾⴰⵉⴰⴷ ⵓⴰ ⵉⴾⵏⴰⵏ ⴰⵍⵓⴰⵈ ⵓⵢⵏ    //ⴰⵂⴰⵏⴰⵉ ⴰⵏ ⵏⴰⴾⴰⵍ ⴰⵜⵉⵓⴰⵏⵏⴰ ⴰⵏ ⵜⴰ-ⵉⵜⵢ ⴰⵏ ⵜⴰ-ⵉⵜⵢ ⵜⴰ-ⵉⵜⵢ ⵜⴰ-ⵉⵜⵢ ⵜⴰ-ⵉⵜⵢ ⵜⴰ-ⵉⵜⵢ    // >>> compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong)))
    // (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))
    // >>> compare((List[Long](0l.toLong, 5l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 4l.toLong)), (List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, -2l.toLong)))
    // (List[Long](4l.toLong, 4l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, 6l.toLong))
    def compare(game : List[Long], guess : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def compare(game: List[Long], guess: List[Long]): List[Long] = {
    game.zip(guess).map { case (g, gs) => abs(g - gs) }
  }
}","    }
    def main(args: Array[String]) = {
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));
    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));
    }

}
"
HumanEval_153,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //(ⵜⵓⵙⴷⵉⴷⵜ ⵏⵏⵙ ⵜⴳⴰ -1).    //return ""Slices.SErviNGSliCes"" ⴰⵛⴽⵓ ""SErviNGSliCes"" ⵉⴳⴰ ⵓⵙⵙⵖⵣⵏ ⵉⴷⵓⵙⵏ     //ⵉⵙⵎ ⵏ ⵓⵙⵙⴰⵔⵓ: ['ⵙⵉⵔⴼⵉⵏⴳⵙⵍⵉⵛⵙ', 'ⵛⵉⵣ', 'ⵙⵜⵓⴼⴼⵉⴷ'], ⵇⴰⴷ ⵜⵙⵙⵏⴷ    //ⵙ ⵓⵎⴷⵢⴰ, ⵎⴽ ⵜⵜⵓⴼⴽⴰ ""ⵙⵍⴰⵢⵛⵙ"" ⴰⵎⵎ ⵜⵣⵎⵎⴰⵔ ⴷ ⵜⵍⴳⴰⵎⵜ ⵏ     //ⴰⴷⴷⴰⴱⴰⵔⴰ ⵏ ⴰⴾⴰⵍ    //ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵏ ⵉⵙⵖⵣⵣⵉⴼⵏ ⵏⵖ ⵓⴳⴳⴰⵔ ⵙ ⵢⴰⵜ ⵜⵉⴷⵜ, ⵇⴰⴷ ⵜⵙⵙⴽⵛⵎ     //format: ClassName.StrongestExtensionName.     //ⵇⴰⴷ ⵜⵙⵙⵉⴼⴹ ⵜⴰⴳⵣⵉⵔⵜ ⵜⴰⴷⵓⵙⵜ ⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵉⵍⴰ ⴳ ⵓⵢⴰ     //ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵣⵉⴼ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵣⵎⵔⵜ ⵙ ⵜⴽⵕⴹⵉ CAP - SM.     //ⵜⵉⴼⵔⵉⵙⵉⵏ ⴳ ⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵣⵉⴼ, ⴷ ⴰⴷ ⵜⴳ SM ⴰⵎⴹⴰⵏ ⵏ ⵜⵉⴼⵔⵉⵙⵉⵏ ⵜⵉⵎⵥⵥⵢⴰⵏⵉⵏ     //ⵜⴰⵣⵓⵏⵜ ⵏ ⵓⵙⵙⵖⵣⵣⵉⴼ ⵜⴳⴰ ⵣⵓⵏⴷ ⴰⵢⴰ: ⴰⴷ ⵜⴳ CAP ⴰⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⵔⵔⴰ     //ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏⵜ ⵜⵔⵏⵓⵜⵉⵏ ⵃⵎⴰ ⴰⴷ ⵜⵜⵓⵙⴽⵛⵎⵏ ⵉⵙⵍⵎⴰⴷⵏ ⵢⴰⴹⵏⵉⵏ ⴳ ⵓⵙⵍⵎⴷ.    //ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵢⵉⵙⵎ ⵏ ⵜⵔⴳⴰ (ⵜⴰⵏⴳⵉ) ⴷ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵙⵖⵣⵏ.    // >>> StrongestExtension((""my_class""), (List[String](""AA"", ""Be"", ""CC"")))
    // (""my_class.AA"")
    def StrongestExtension(class_name : String, extensions : List[String]) : String = {
","def StrongestExtension(class_name: String, extensions: List[String]): String = {
        extensions.map { extension =>
            val capCount = extension.count(_.isUpper)
            val lowerCount = extension.count(_.isLower)
            val strength = capCount - lowerCount
            (extension, strength)
        }.maxBy(_._2)._1
    } match {
        case strongest => s""$class_name.$strongest""
    }
}","    }
    def main(args: Array[String]) = {
    assert(StrongestExtension((""Watashi""), (List[String](""tEN"", ""niNE"", ""eIGHt8OKe""))).equals((""Watashi.eIGHt8OKe"")));
    assert(StrongestExtension((""Boku123""), (List[String](""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""))).equals((""Boku123.YEs.WeCaNe"")));
    assert(StrongestExtension((""__YESIMHERE""), (List[String](""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""))).equals((""__YESIMHERE.NuLl__"")));
    assert(StrongestExtension((""K""), (List[String](""Ta"", ""TAR"", ""t234An"", ""cosSo""))).equals((""K.TAR"")));
    assert(StrongestExtension((""__HAHA""), (List[String](""Tab"", ""123"", ""781345"", ""-_-""))).equals((""__HAHA.123"")));
    assert(StrongestExtension((""YameRore""), (List[String](""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""))).equals((""YameRore.okIWILL123"")));
    assert(StrongestExtension((""finNNalLLly""), (List[String](""Die"", ""NowW"", ""Wow"", ""WoW""))).equals((""finNNalLLly.WoW"")));
    assert(StrongestExtension((""_""), (List[String](""Bb"", ""91245""))).equals((""_.Bb"")));
    assert(StrongestExtension((""Sp""), (List[String](""671235"", ""Bb""))).equals((""Sp.671235"")));
    }

}
"
HumanEval_154,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵏⴰⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵇⴰⴷ ⵜⵔⴰⵔⴷ true ⵎⴽ ⵜⴳⴰ ⵜⴳⵓⵔⵉ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⵏⵖ ⴽⵔⴰ ⵏ ⵜⵙⵓⵜⵍⵉⵏ ⵏⵏⵙ ⵜⴰⴳⵓⵔⵉ ⵜⴰⴷⵙⵍⴰⵏⵜ ⴳ ⵜⴳⵓⵔⵉ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ.    // >>> cycpatternCheck((""abcd""), (""abd""))
    // (false)
    // >>> cycpatternCheck((""hello""), (""ell""))
    // (true)
    // >>> cycpatternCheck((""whassup""), (""psus""))
    // (false)
    // >>> cycpatternCheck((""abab""), (""baa""))
    // (true)
    // >>> cycpatternCheck((""efef""), (""eeff""))
    // (false)
    // >>> cycpatternCheck((""himenss""), (""simen""))
    // (true)
    def cycpatternCheck(a : String, b : String) : Boolean = {
","def cycpatternCheck(a: String, b: String): Boolean = {
  val bLength = b.length
  val bDouble = b + b // Create a string with b concatenated with itself to represent all rotations
  for (i <- 0 until bLength) {
    val rotation = bDouble.substring(i, i + bLength) // Get the current rotation
    if (a.contains(rotation)) return true
  }
  false
}","    }
    def main(args: Array[String]) = {
    assert(cycpatternCheck((""xyzw""), (""xyw"")) == (false));
    assert(cycpatternCheck((""yello""), (""ell"")) == (true));
    assert(cycpatternCheck((""whattup""), (""ptut"")) == (false));
    assert(cycpatternCheck((""efef""), (""fee"")) == (true));
    assert(cycpatternCheck((""abab""), (""aabb"")) == (false));
    assert(cycpatternCheck((""winemtt""), (""tinem"")) == (true));
    }

}
"
HumanEval_155,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //ⵉⴳ ⵏⵙⴽⵔ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ, ⵏⵙⵙⴽⵛⵎ ⵜⴰⴱⵍⵜ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵎⵉⴷⵏ ⴷ ⵉⵎⵎⵉⴷⵏ ⵙ ⵓⵎⵣⴰⵔⴰⵢ.    // >>> evenOddCount((-12l))
    // ((1l, 1l))
    // >>> evenOddCount((123l))
    // ((1l, 2l))
    def evenOddCount(num : Long) : Tuple2[Long, Long] = {
","def evenOddCount(num: Long): Tuple2[Long, Long] = {
  val digits = num.abs.toString.map(_.asDigit)
  val evenCount = digits.count(_ % 2 == 0).toLong
  val oddCount = digits.count(_ % 2 != 0).toLong
  (evenCount, oddCount)
}","    }
    def main(args: Array[String]) = {
    assert(evenOddCount((7l)).equals(((0l, 1l))));
    assert(evenOddCount((-78l)).equals(((1l, 1l))));
    assert(evenOddCount((3452l)).equals(((2l, 2l))));
    assert(evenOddCount((346211l)).equals(((3l, 3l))));
    assert(evenOddCount((-345821l)).equals(((3l, 3l))));
    assert(evenOddCount((-2l)).equals(((1l, 0l))));
    assert(evenOddCount((-45347l)).equals(((2l, 3l))));
    assert(evenOddCount((0l)).equals(((1l, 0l))));
    }

}
"
HumanEval_156,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:    //ⵜⵉⵎⵥⴰⴳⵉⵏ: 1 <= num <= 1000     //ⴷ ⵙ ⵜⵉⴼⵉⵏⴰⵖ     //ⵙ ⵓⴽⵙⴰⵢ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ, ⵙⵙⵓⵜⵔ ⴰⵎⵙⴽⴰⵔ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵕⵓⵎⵉⵢⵏ ⵏⵏⵙ ⴰⵎⵎ ⵜⴰⴳⵔⵓⵎⵎⴰ,     // >>> intToMiniRoman((19l))
    // (""xix"")
    // >>> intToMiniRoman((152l))
    // (""clii"")
    // >>> intToMiniRoman((426l))
    // (""cdxxvi"")
    def intToMiniRoman(number : Long) : String = {
","import scala.collection.mutable._

object Problem {
  def intToMiniRoman(number: Long): String = {
    val romanMap: List[(Int, String)] = List(
      (1000, ""m""),
      (900, ""cm""),
      (500, ""d""),
      (400, ""cd""),
      (100, ""c""),
      (90, ""xc""),
      (50, ""l""),
      (40, ""xl""),
      (10, ""x""),
      (9, ""ix""),
      (5, ""v""),
      (4, ""iv""),
      (1, ""i"")
    )

    var num = number.toInt
    val stringBuilder = new StringBuilder

    for ((value, roman) <- romanMap) {
      while (num >= value) {
        stringBuilder.append(roman)
        num -= value
      }
    }

    stringBuilder.toString()
  }
}","    }
    def main(args: Array[String]) = {
    assert(intToMiniRoman((19l)).equals((""xix"")));
    assert(intToMiniRoman((152l)).equals((""clii"")));
    assert(intToMiniRoman((251l)).equals((""ccli"")));
    assert(intToMiniRoman((426l)).equals((""cdxxvi"")));
    assert(intToMiniRoman((500l)).equals((""d"")));
    assert(intToMiniRoman((1l)).equals((""i"")));
    assert(intToMiniRoman((4l)).equals((""iv"")));
    assert(intToMiniRoman((43l)).equals((""xliii"")));
    assert(intToMiniRoman((90l)).equals((""xc"")));
    assert(intToMiniRoman((94l)).equals((""xciv"")));
    assert(intToMiniRoman((532l)).equals((""dxxxii"")));
    assert(intToMiniRoman((900l)).equals((""cm"")));
    assert(intToMiniRoman((994l)).equals((""cmxciv"")));
    assert(intToMiniRoman((1000l)).equals((""m"")));
    }

}
"
HumanEval_157,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //90 ⴷⴻⴶⵔⴻⴻⴻ.    //ⵜⴰⴾⴾⵓⵣⵜ ⵜⴰ ⵜⴰⵂⴰⵜ ⵜⴰⵂⵔⵉⴾⴻ ⵜⴰ ⵜⴰⵈⵈⴰⵍ ⵜⴰⴾⴾⵓⵣⵜ ⴷⴰⵗ ⵜⴰⵈⵈⴰⵍ ⴰⴾⴾⵓⵣ ⵉⵉⵉⴰⵏ ⴰⴾⴾⵓⵣ ⵎⴻⵗ    //ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⵉⵖⵎⵔⵉⵏ ⵜⵉⴷⵙⵍⴰⵏⵉⵏ, ⵓⵔ ⵉⴳⵉ ⵜⵉⴷⵙⵜ.    //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵉⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⵉⵙⴳⵡⵉⵏ. ⵔⴰⴷ ⵏⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⵔⴰⴷ ⴽⵕⴰⴹ     // >>> rightAngleTriangle((3l), (4l), (5l))
    // (true)
    // >>> rightAngleTriangle((1l), (2l), (3l))
    // (false)
    def rightAngleTriangle(a : Long, b : Long, c : Long) : Boolean = {
","def rightAngleTriangle(a: Long, b: Long, c: Long): Boolean = {
        val sides = List(a, b, c).sorted
        pow(sides(0), 2) + pow(sides(1), 2) == pow(sides(2), 2)
    }
}","    }
    def main(args: Array[String]) = {
    assert(rightAngleTriangle((3l), (4l), (5l)) == (true));
    assert(rightAngleTriangle((1l), (2l), (3l)) == (false));
    assert(rightAngleTriangle((10l), (6l), (8l)) == (true));
    assert(rightAngleTriangle((2l), (2l), (2l)) == (false));
    assert(rightAngleTriangle((7l), (24l), (25l)) == (true));
    assert(rightAngleTriangle((10l), (5l), (7l)) == (false));
    assert(rightAngleTriangle((5l), (12l), (13l)) == (true));
    assert(rightAngleTriangle((15l), (8l), (17l)) == (true));
    assert(rightAngleTriangle((48l), (55l), (73l)) == (true));
    assert(rightAngleTriangle((1l), (1l), (1l)) == (false));
    assert(rightAngleTriangle((2l), (2l), (10l)) == (false));
    }

}
"
HumanEval_158,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵔⴻⵜⵔⵓⵏ ⵆⴰⵔⴻⵛⵜⴻⵔⵙ , ⴰⴷⴷoⴱⴰⵜ ⵓⴰ ⴰⵣⵣⴰⵔⴰⵏ ⴷⴰⵗ ⴰⵍⴾⴰⴷ ⵏ ⴰⵍⵎⴰⵗⵏⴰ ⵏ ⵉⵙⵎⴰⵓⴰⵏ    //ⵎⴽ ⴳⴰⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ ⴽⵉⴳⴰⵏ,     //ⵉⵍⵍⴰ ⴳ ⵜⵍⴳⴰⵎⵜ ⴽⵉⴳⴰⵏ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵔⵎⵙ ⵜⴰⴳⵓⵔⵉ ⵙ ⵓⵟⵟⵓⵏ ⴰⵎⵇⵔⴰⵏ     //ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⵉⴼⵉⵏⴰⵖ.    // >>> findMax((List[String](""name"", ""of"", ""string"")))
    // (""string"")
    // >>> findMax((List[String](""name"", ""enam"", ""game"")))
    // (""enam"")
    // >>> findMax((List[String](""aaaaaaa"", ""bb"", ""cc"")))
    // (""aaaaaaa"")
    def findMax(words : List[String]) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def findMax(words: List[String]): String = {
    words.maxBy(word => (word.toSet.size, -word.toLowerCase))
  }
}","    }
    def main(args: Array[String]) = {
    assert(findMax((List[String](""name"", ""of"", ""string""))).equals((""string"")));
    assert(findMax((List[String](""name"", ""enam"", ""game""))).equals((""enam"")));
    assert(findMax((List[String](""aaaaaaa"", ""bb"", ""cc""))).equals((""aaaaaaa"")));
    assert(findMax((List[String](""abc"", ""cba""))).equals((""abc"")));
    assert(findMax((List[String](""play"", ""this"", ""game"", ""of"", ""footbott""))).equals((""footbott"")));
    assert(findMax((List[String](""we"", ""are"", ""gonna"", ""rock""))).equals((""gonna"")));
    assert(findMax((List[String](""we"", ""are"", ""a"", ""mad"", ""nation""))).equals((""nation"")));
    assert(findMax((List[String](""this"", ""is"", ""a"", ""prrk""))).equals((""this"")));
    assert(findMax((List[String](""b""))).equals((""b"")));
    assert(findMax((List[String](""play"", ""play"", ""play""))).equals((""play"")));
    }

}
"
HumanEval_159,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ:     //ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⵉⵔⵖⵉⵢⵏ ⵉⵇⵇⵉⵎⵏ, ⵔⴰⴷ ⵜⵙⵙⵓⵜⵎ ⴰⴽⴽⵡ ⵉⵔⵖⵉⵢⵏ ⵉⵇⵇⵉⵎⵏ, ⵎⴰⴽⴰ ⵔⴰⴷ ⵜⵇⵇⵉⵎ ⵜⵔⵖⵉ.    //ⴰⴹⵏ ⵏ ⵉⴽⴰⵔⵓⵟⵏ ⵏⵏⴰ ⴷ ⵉⵇⵇⵉⵎⵏ ⴷⴼⴼⵉⵔ ⵏ ⵡⵓⵜⵛⵉ ⵏⵏⴽ ]     //ⵉⵇⵏⴻⵏ ⴰⴷ ⵜⴰⵔⴻⴷ ⵜⴰⵍⵖⴰ ⵏ [ ⴰⵟⵟⴰⵚ ⵏ ⵉⴽⴰⵔⵓⵜⴻⵏ ⵉⵛⴻⵡⵏⴻⵏ ⴷⴻⴼⴼⵉⵔ ⵏ ⵜⵉⵛⵛⵉⵋⵔⵉⵜⴻⵏ ⵏⴻⵜ,     //ⵎⴰⵛⴰ ⴷⵖⴰ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵜⵜⵓⵢⴷ ⴽⵉⴳⴰⵏ ⵏ ⵉⴽⴰⵔⵓⵟⵏ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵎⵓⵔⵎ ⵜⴰⵢⵢⵉⵔⴰ ⵏ ⵡⴰⵙⵙ.    //ⴻⵈⴰⵍⴻ ⵜⴰⵛⵉⵛⴻⵜ ⵜⴰ ⵜⴰⴶⴰⵏⴻⵏ ⴰⵛⴻⵛ, ⴰⴷ ⴾⴰⵍⴰ ⵉⴶⵔⴰⵓⴻⵜ ⴰⴶⵓⴷⴰⵏ ⴰⵏ ⵜⴰⵛⵉⵛⴻⵜ ⴰⵏ ⴾⴰⵔⵓⵜⴻⵏ,    // >>> eat((5l), (6l), (10l))
    // (List[Long](11l.toLong, 4l.toLong))
    // >>> eat((4l), (8l), (9l))
    // (List[Long](12l.toLong, 1l.toLong))
    // >>> eat((1l), (10l), (10l))
    // (List[Long](11l.toLong, 0l.toLong))
    // >>> eat((2l), (11l), (5l))
    // (List[Long](7l.toLong, 0l.toLong))
    // Variables:
    // @number : integer
    // the number of carrots that you have eaten.
    // @need : integer
    // the number of carrots that you need to eat.
    // @remaining : integer
    // the number of remaining carrots thet exist in stock
    // Constrain:
    // * 0 <= number <= 1000
    // * 0 <= need <= 1000
    // * 0 <= remaining <= 1000
    // Have fun :)
    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def eat(number: Long, need: Long, remaining: Long): List[Long] = {
    val totalNeeded = number + need
    if (remaining >= need) {
      List(totalNeeded, remaining - need)
    } else {
      List(number + remaining, 0)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));
    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));
    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));
    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));
    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));
    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));
    }

}
"
HumanEval_160,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵉⵍⵍⴰ ⴳ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⵙⴽⴰⵔⵏ ⵢⴰⵏ ⵓⵎⵙⴽⴰⵔ ⵙ ⵓⴳⴳⴰⵔ, ⴷ ⵉⵍⵍⴰ ⴳ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⵙⴽⴰⵔⵏ ⵙ ⵙⵉⵏ ⵉⵎⵙⴽⴰⵔⵏ ⵙ ⵓⴳⴳⴰⵔ.    //ⵉⴳⴰ ⵓⴱⵢⵔⴰⵏⴷ ⵢⴰⵏ ⵓⵙⵎⵉⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵔⵉⵏ.    //ⵜⵉⵖⵣⵉ ⵏ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⵙⴽⴰⵔⵏ ⵜⴳⴰ ⵜⵜ ⵜⵉⵖⵣⵉ ⵏ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⵙⴽⴰⵔⵏ ⴱⵍⴰ ⵢⴰⵏ.    //ⴰⵜⵡⵉⵍ:     //=> ⵜⴰⵢⴰⴼⵓⵜ = 9     //ⵜⴰⵢⴰⴼⵓⵜ = 2 + 3 * 4 - 5     //ⵜⵍⴳⴰⵎⵜ = [2, 3, 4, 5]     //ⴰⵎⵙⵙⵎⵔⵙⴰⵍ['+', '*', '-']     //ⴰⵍⵎⵉⵜⴰⵍ:     //ⴰⵙⵎⵓⵜⵜⴳ (**)     //ⴰⴱⵟⵟⵓ ⵏ ⵜⵣⴰⵍⵖⵉⵡⵉⵏ ( //)     //ⴰⵙⴼⵓⴷⴷⵓ (*)     //ⵜⵓⴽⴽⵙⴰ ( - )     //ⴰⵙⵎⵓⵏ ( +)     //ⵜⵉⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ ⵏ ⵓⵙⵉⵙⵙⵏ:     //ⵉⵙⵎ ⵏ ⵓⵙⵏⵓⵎⵎⵍ ⴷ ⵓⵙⵡⴰⵍⴰ ⵏ ⵓⵙⵎⵉⵍ ⴰⴷ.     //ⵜⴰⵍⴳⴰⵎⵜ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⵜⴳⴰ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙⵎⵔⵙⵏⵜ ⵙⵏⴰⵜ ⵜⵍⴳⴰⵎⵉⵏ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵉ ⵓⵙⴽⵓ ⵏ ⵍⵊⵉⴱⵔⵉⵜ     //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵏⴰⵜ ⵜⵍⴳⴰⵎⵉⵏ ⵏ ⵓⵎⵙⴽⴰⵔ, ⴷ ⵓⵎⵙⴽⴰⵔ. ⵜⵍⴳⴰⵎⵜ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ ⵖⵓⵔⵙ ⵜⵉⵎⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ, ⴷ     def doAlgebra(op : List[String], operand : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def doAlgebra(op: List[String], operand: List[Long]): Long = {
    var result = operand.head
    for (i <- 0 until op.length) {
      op(i) match {
        case ""+"" => result += operand(i + 1)
        case ""-"" => result -= operand(i + 1)
        case ""*"" => result *= operand(i + 1)
        case ""//"" => result /= operand(i + 1)
        case ""**"" => result = pow(result.toDouble, operand(i + 1).toDouble).toLong
      }
    }
    result
  }

  def main(args: Array[String]): Unit = {
    val operators = List(""+"", ""*"", ""-"")
    val operands = List(2L, 3L, 4L, 5L)
    println(doAlgebra(operators, operands)) // Output: 9
  }
}","    }
    def main(args: Array[String]) = {
    assert(doAlgebra((List[String](""**"", ""*"", ""+"")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));
    assert(doAlgebra((List[String](""+"", ""*"", ""-"")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));
    assert(doAlgebra((List[String](""//"", ""*"")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));
    }

}
"
HumanEval_161,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ    //ⵍⴰⵇⴱⴰⵍ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⴹⵓ ⵜⵉⴼⵔⴽⵜ ⵏ ⵜⵢⴰⴼⵓⵜ.    //ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴳ ⵜⵉⴼⵔⵜ ⴽⵔⴰ ⵏ ⵡⴰⵔⵔⴰⵜⵏ, ⵙⵙⵓⵜⵍ ⵜⵉⴼⵔⵜ.    //ⵎⴽ ⵓⵔ ⵉⴳⵉ ⴰⵢⴰ ⵃⴹⵓ ⵖⵉⴽⵍⵍⵉ ⵉⴳⴰ.    //ⵎⴽ ⵜⴳⴰ s[i] ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⵙⵙⵓⵜⵔ ⵜⴰⵡⴰⵍⵜ ⵏⵏⵙ ⵙⴳ ⴷⴷⴰⵡ ⴰⵔ ⴰⴼⵍⵍⴰ ⵏⵖⴷ ⵙ ⵓⵎⵣⴰⵔⴰⵢ,     //ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ s.    // >>> solve((""1234""))
    // (""4321"")
    // >>> solve((""ab""))
    // (""AB"")
    // >>> solve((""#a@C""))
    // (""#A@c"")
    def solve(s : String) : String = {
","def solve(s: String): String = {
    if (s.exists(_.isLetter)) {
      s.map {
        case c if c.isLetter && c.isLower => c.toUpper
        case c if c.isLetter && c.isUpper => c.toLower
        case c => c
      }.mkString
    } else {
      s.reverse
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(solve((""AsDf"")).equals((""aSdF"")));
    assert(solve((""1234"")).equals((""4321"")));
    assert(solve((""ab"")).equals((""AB"")));
    assert(solve((""#a@C"")).equals((""#A@c"")));
    assert(solve((""#AsdfW^45"")).equals((""#aSDFw^45"")));
    assert(solve((""#6@2"")).equals((""2@6#"")));
    assert(solve((""#$a^D"")).equals((""#$A^d"")));
    assert(solve((""#ccc"")).equals((""#CCC"")));
    }

}
"
HumanEval_162,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵎⴽ ⵉⴳⴰ 'text' ⵢⴰⵏ ⵓⴹⵕⵉⵚ ⵓⵔ ⵉⵍⵉⵏ ⴽⵔⴰ, ⵔⵉⵜⵓⵔⵏ None.    //ⵙ ⵜⵉⴽⴽⵉ ⵏ ""ⵜⵉⴽⵙⵜ"" ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵙⵓⵍⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵏ ""ⵀⴰⵛⵉ"" ⵏ md5 ⵏⵏⵙ.     // >>> stringToMd5((""Hello world""))
    // Some(""3e25960a79dbc69b674cd4ec67a72c62"")
    def stringToMd5(text : String) : Option[String] = {
","import java.security.MessageDigest

object Problem {
  def stringToMd5(text: String): Option[String] = {
    if (text.isEmpty) None
    else {
      val md = MessageDigest.getInstance(""MD5"")
      val digest = md.digest(text.getBytes)
      Some(digest.map(""%02x"".format(_)).mkString)
    }
  }
}

// Example usage:
// println(Problem.stringToMd5(""Hello world""))  // Output: Some(""3e25960a79dbc69b674cd4ec67a72c62"")","    }
    def main(args: Array[String]) = {
    assert(stringToMd5((""Hello world"")).equals(Some(""3e25960a79dbc69b674cd4ec67a72c62"")));
    assert(stringToMd5(("""")).equals(None));
    assert(stringToMd5((""A B C"")).equals(Some(""0ef78513b0cb8cef12743f5aeb35f888"")));
    assert(stringToMd5((""password"")).equals(Some(""5f4dcc3b5aa765d61d8327deb882cf99"")));
    }

}
"
HumanEval_163,taq_Tfng,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ⵙ ⵓⵎⴷⵢⴰ:     //ⴷ ⴱ, ⵙ ⵓⵍⵍⵙ ⵏ ⵓⵙⵙⴰⵔⵓ.    //ⴳ ⵜⵉⴽⴽⵉ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ a ⴷ b, ⵙⵙⴽⵛⵎ ⵉⵎⴹⴰⵏ ⵉⵎⵎⵔⵡⵉⵏ ⴳⵔ a     // >>> generateIntegers((2l), (8l))
    // (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))
    // >>> generateIntegers((8l), (2l))
    // (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))
    // >>> generateIntegers((10l), (14l))
    // (List[Long]())
    def generateIntegers(a : Long, b : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def generateIntegers(a: Long, b: Long): List[Long] = {
    val start = min(a, b)
    val end = max(a, b)
    val evenNumbers = for (i <- start to end if i % 2 == 0) yield i
    evenNumbers.map(_.toLong).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(generateIntegers((2l), (10l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((10l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((132l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((17l), (89l)).equals((List[Long]())));
    }

}
"
