[{"task_id":"HumanEval_0","nl":"glg_Latn","pl":"r","prompt":"límite de referencia.Comprobar se na lista de números, hai dous números máis próximos entre si que # >>> has_close_elements(c(1.0, 2.0, 3.0), 0.5)\n# FALSE\n# >>> has_close_elements(c(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n# TRUE\nhas_close_elements <- function(numbers, threshold) {","canonical_solution":"has_close_elements <- function(numbers, threshold) {\n  for (i in seq_along(numbers)) {\n    for (j in seq_along(numbers)) {\n      if (i != j && abs(numbers[i] - numbers[j]) < threshold) {\n        return(TRUE)\n      }\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- has_close_elements\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0), 0.95), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0), 0.8), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1), 1.0), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1), 0.5), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_1","nl":"glg_Latn","pl":"r","prompt":"Ignore os espazos na cadea de entrada.Os grupos separados están equilibrados (cada braza aberta está debidamente pechada) e non anidados entre si.separar os grupos en cadeas separadas e devolver a lista dos mesmos.A entrada desta función é unha cadea que contén varios grupos de parénteses anidados. O seu obxectivo é # >>> separate_paren_groups('( ) (( )) (( )( ))')\n# c('()', '(())', '(()())')\nseparate_paren_groups <- function(paren_string) {","canonical_solution":"separate_paren_groups <- function(paren_string) {\n  # Remove spaces from the input string\n  paren_string <- gsub(\" \", \"\", paren_string)\n  \n  # Initialize variables for processing\n  result <- c()\n  current_group <- \"\"\n  balance <- 0\n  \n  # Iterate through each character in the string\n  for (char in strsplit(paren_string, \"\")[[1]]) {\n    current_group <- paste0(current_group, char)\n    if (char == \"(\") {\n      balance <- balance + 1\n    } else if (char == \")\") {\n      balance <- balance - 1\n    }\n    \n    # If balance is zero, we found a complete group\n    if (balance == 0 && nchar(current_group) > 0) {\n      result <- c(result, current_group)\n      current_group <- \"\"\n    }\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- separate_paren_groups\n    stopifnot(isTRUE(all.equal(candidate('(()()) ((())) () ((())()())'), c('(()())', '((()))', '()', '((())()())'))))\n    stopifnot(isTRUE(all.equal(candidate('() (()) ((())) (((())))'), c('()', '(())', '((()))', '(((())))'))))\n    stopifnot(isTRUE(all.equal(candidate('(()(())((())))'), c('(()(())((())))'))))\n    stopifnot(isTRUE(all.equal(candidate('( ) (( )) (( )( ))'), c('()', '(())', '(()())'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_2","nl":"glg_Latn","pl":"r","prompt":"Devolve a parte decimal do número.(a parte sobrante sempre é menor que 1).e parte enteira (o maior número enteiro menor que o número dado) e decimais Dado un número de punto flotante positivo, pódese descompoñer en # >>> truncate_number(3.5)\n# 0.5\ntruncate_number <- function(number) {","canonical_solution":"truncate_number <- function(number) {\n  return(number - floor(number))\n}","tests":"test_humaneval <- function() {\n    candidate <- truncate_number\n    stopifnot(isTRUE(all.equal(candidate(3.5), 0.5)))\n    stopifnot(isTRUE(all.equal(candidate(1.25), 0.25)))\n    stopifnot(isTRUE(all.equal(candidate(123.0), 0.0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_3","nl":"glg_Latn","pl":"r","prompt":"Neste punto, a función debería devolver TRUE.O seu obxectivo é detectar se en calquera momento o saldo da conta cae por baixo de cero, e Dámosche unha lista de operacións de depósito e retirada dunha conta bancaria que comeza con # >>> below_zero(c(1, 2, 3))\n# FALSE\n# >>> below_zero(c(1, 2, -4, 5))\n# TRUE\nbelow_zero <- function(operations) {","canonical_solution":"below_zero <- function(operations) {\n  balance <- 0\n  for (op in operations) {\n    balance <- balance + op\n    if (balance < 0) {\n      return(TRUE)\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- below_zero\n    stopifnot(isTRUE(all.equal(candidate(c()), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, -3, 1, 2, -3)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, -4, 5, 6)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 2, -2, 5, -5, 4, -4)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 2, -2, 5, -5, 4, -5)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -2, 2, -2, 5, -5, 4, -4)), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_4","nl":"glg_Latn","pl":"r","prompt":"MAD = media. x - x_mean. elemento e un punto central (media neste caso): A desviación absoluta media é a diferenza absoluta media entre cada un dos dous.ao redor da media deste conxunto de datos. Para unha lista dada de números de entrada, calcule a desviación absoluta media.# >>> mean_absolute_deviation(c(1.0, 2.0, 3.0, 4.0))\n# 1.0\nmean_absolute_deviation <- function(numbers) {","canonical_solution":"mean_absolute_deviation <- function(numbers) {\n  x_mean <- mean(numbers)\n  mad <- mean(abs(numbers - x_mean))\n  return(mad)\n}\n\n# Example usage\nmean_absolute_deviation(c(1.0, 2.0, 3.0, 4.0))","tests":"test_humaneval <- function() {\n    candidate <- mean_absolute_deviation\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0)), 0.5)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0)), 1.0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), 1.2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_5","nl":"glg_Latn","pl":"r","prompt":"Insira un número \"delimitador\" entre cada dous elementos consecutivos da lista de entrada ∀números\" # >>> intersperse(c(), 4)\n# c()\n# >>> intersperse(c(1, 2, 3), 4)\n# c(1, 4, 2, 4, 3)\nintersperse <- function(numbers, delimeter) {","canonical_solution":"intersperse <- function(numbers, delimeter) {\n  if (length(numbers) <= 1) {\n    return(numbers)\n  }\n  result <- c()\n  for (i in 1:(length(numbers) - 1)) {\n    result <- c(result, numbers[i], delimeter)\n  }\n  result <- c(result, numbers[length(numbers)])\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- intersperse\n    stopifnot(isTRUE(all.equal(candidate(c(), 7), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 2), 8), c(5, 8, 6, 8, 3, 8, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 2, 2), 2), c(2, 2, 2, 2, 2))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_6","nl":"glg_Latn","pl":"r","prompt":"Por exemplo, (() (()) ten un máximo de dous niveis de anidación mentres que ((())) ten tres. Para cada grupo, a saída o nivel máis profundo de anidación de parénteses. A entrada desta función é unha cadea representada por múltiples grupos para parénteses anidados separados por espazos.# >>> parse_nested_parens('(()()) ((())) () ((())()())')\n# c(2, 3, 1, 3)\nparse_nested_parens <- function(paren_string) {","canonical_solution":"parse_nested_parens <- function(paren_string) {\n  sapply(strsplit(paren_string, \" \")[[1]], function(group) {\n    max_nesting <- 0\n    current_nesting <- 0\n    for (char in strsplit(group, \"\")[[1]]) {\n      if (char == \"(\") {\n        current_nesting <- current_nesting + 1\n        max_nesting <- max(max_nesting, current_nesting)\n      } else if (char == \")\") {\n        current_nesting <- current_nesting - 1\n      }\n    }\n    return(max_nesting)\n  })\n}","tests":"test_humaneval <- function() {\n    candidate <- parse_nested_parens\n    stopifnot(isTRUE(all.equal(candidate('(()()) ((())) () ((())()())'), c(2, 3, 1, 3))))\n    stopifnot(isTRUE(all.equal(candidate('() (()) ((())) (((())))'), c(1, 2, 3, 4))))\n    stopifnot(isTRUE(all.equal(candidate('(()(())((())))'), c(4))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_7","nl":"glg_Latn","pl":"r","prompt":"Filtrar unha lista de entrada de cadeas só para aquelas que conteñan unha determinada subcadena# >>> filter_by_substring(c(), 'a')\n# c()\n# >>> filter_by_substring(c('abc', 'bacd', 'cde', 'array'), 'a')\n# c('abc', 'bacd', 'array')\nfilter_by_substring <- function(strings, substring) {","canonical_solution":"filter_by_substring <- function(strings, substring) {\n  return(strings[grepl(substring, strings)])\n}","tests":"test_humaneval <- function() {\n    candidate <- filter_by_substring\n    stopifnot(isTRUE(all.equal(candidate(c(), 'john'), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'), 'xxx'), c('xxx', 'xxxAAA', 'xxx'))))\n    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'), 'xx'), c('xxx', 'aaaxxy', 'xxxAAA', 'xxx'))))\n    stopifnot(isTRUE(all.equal(candidate(c('grunt', 'trumpet', 'prune', 'gruesome'), 'run'), c('grunt', 'prune'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_8","nl":"glg_Latn","pl":"r","prompt":"A suma baleira debe ser igual a 0 e o produto baleiro debe ser igual a 1.Para unha lista de enteiros, devolve unha lista que consiste na suma e no produto de todos os enteiros dunha lista.# >>> sum_product(c())\n# c(0, 1)\n# >>> sum_product(c(1, 2, 3, 4))\n# c(10, 24)\nsum_product <- function(numbers) {","canonical_solution":"sum_product <- function(numbers) {\n  sum_val <- sum(numbers)\n  prod_val <- ifelse(length(numbers) == 0, 1, prod(numbers))\n  return(c(sum_val, prod_val))\n}","tests":"test_humaneval <- function() {\n    candidate <- sum_product\n    stopifnot(isTRUE(all.equal(candidate(c()), c(0, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1)), c(3, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(100, 0)), c(100, 0))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 7)), c(15, 105))))\n    stopifnot(isTRUE(all.equal(candidate(c(10)), c(10, 10))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_9","nl":"glg_Latn","pl":"r","prompt":"na secuencia.A partir dunha lista de números enteiros, xerar unha lista de elementos máximos encontrados ata o momento dado.# >>> rolling_max(c(1, 2, 3, 2, 3, 4, 2))\n# c(1, 2, 3, 3, 3, 4, 4)\nrolling_max <- function(numbers) {","canonical_solution":"rolling_max <- function(numbers) {\n  max_list <- c()\n  current_max <- -Inf\n  for (number in numbers) {\n    current_max <- max(current_max, number)\n    max_list <- c(max_list, current_max)\n  }\n  return(max_list)\n}","tests":"test_humaneval <- function() {\n    candidate <- rolling_max\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 1)), c(4, 4, 4, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3, 100, 3)), c(3, 3, 3, 100, 100))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_10","nl":"glg_Latn","pl":"r","prompt":"- Engadir ao final da cadea reversa dun prefixo de cadea que vén antes do sufixo palindromo.- Encontre o postfix máis longo da cadea de caracteres que é un palíndromo. A idea do algoritmo é simple:Atopa o palíndromo máis curto que comece cunha cadea de caracteres.# >>> make_palindrome('')\n# ''\n# >>> make_palindrome('cat')\n# 'catac'\n# >>> make_palindrome('cata')\n# 'catac'\nmake_palindrome <- function(string) {","canonical_solution":"make_palindrome <- function(string) {\n  is_palindrome <- function(s) {\n    return(s == stringi::stri_reverse(s))\n  }\n  \n  n <- nchar(string)\n  \n  for (i in seq(n, 0, by = -1)) {\n    suffix <- substr(string, i, n)\n    if (is_palindrome(suffix)) {\n      prefix <- substr(string, 1, i - 1)\n      return(paste0(string, stringi::stri_reverse(prefix)))\n    }\n  }\n  \n  return(string) # for the empty string case\n}","tests":"test_humaneval <- function() {\n    candidate <- make_palindrome\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('x'), 'x')))\n    stopifnot(isTRUE(all.equal(candidate('xyz'), 'xyzyx')))\n    stopifnot(isTRUE(all.equal(candidate('xyx'), 'xyx')))\n    stopifnot(isTRUE(all.equal(candidate('jerry'), 'jerryrrej')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_11","nl":"glg_Latn","pl":"r","prompt":"Realizar XOR binario sobre estas entradas e devolver o resultado tamén como unha cadea.A entrada son dúas cadeas a e b que consisten só en 1s e 0s.# >>> string_xor('010', '110')\n# '100'\nstring_xor <- function(a, b) {","canonical_solution":"string_xor <- function(a, b) {\n  xor_result <- mapply(function(x, y) { \n    ifelse(x == y, 0, 1) \n  }, strsplit(a, NULL)[[1]], strsplit(b, NULL)[[1]])\n  return(paste(xor_result, collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- string_xor\n    stopifnot(isTRUE(all.equal(candidate('111000', '101010'), '010010')))\n    stopifnot(isTRUE(all.equal(candidate('1', '1'), '0')))\n    stopifnot(isTRUE(all.equal(candidate('0101', '0000'), '0101')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_12","nl":"glg_Latn","pl":"r","prompt":"Devolve NULL no caso de que a lista de entrada estea baleira.De volta a máis longa da lista de cadeas de caracteres. De volta a primeira en caso de múltiple # >>> longest(c())\n# NULL\n# >>> longest(c('a', 'b', 'c'))\n# 'a'\n# >>> longest(c('a', 'bb', 'ccc'))\n# 'ccc'\nlongest <- function(strings) {","canonical_solution":"longest <- function(strings) {\n  if (length(strings) == 0) return(NULL)\n  longest_string <- strings[1]\n  for (s in strings) {\n    if (nchar(s) > nchar(longest_string)) {\n      longest_string <- s\n    }\n  }\n  return(longest_string)\n}","tests":"test_humaneval <- function() {\n    candidate <- longest\n    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z')), 'x')))\n    stopifnot(isTRUE(all.equal(candidate(c('x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc')), 'zzzz')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_13","nl":"glg_Latn","pl":"r","prompt":"Retorna o maior común divisor de dous números enteiros a e b # >>> greatest_common_divisor(3, 5)\n# 1\n# >>> greatest_common_divisor(25, 15)\n# 5\ngreatest_common_divisor <- function(a, b) {","canonical_solution":"greatest_common_divisor <- function(a, b) {\n  while (b != 0) {\n    temp <- b\n    b <- a %% b\n    a <- temp\n  }\n  return(abs(a))\n}","tests":"test_humaneval <- function() {\n    candidate <- greatest_common_divisor\n    stopifnot(isTRUE(all.equal(candidate(3, 7), 1)))\n    stopifnot(isTRUE(all.equal(candidate(10, 15), 5)))\n    stopifnot(isTRUE(all.equal(candidate(49, 14), 7)))\n    stopifnot(isTRUE(all.equal(candidate(144, 60), 12)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_14","nl":"glg_Latn","pl":"r","prompt":"Devolve a lista de todos os prefixos desde o máis curto ao máis longo da cadea de entrada.# >>> all_prefixes('abc')\n# c('a', 'ab', 'abc')\nall_prefixes <- function(string) {","canonical_solution":"all_prefixes <- function(string) {\n  prefixes <- character(nchar(string))\n  for (i in seq_along(prefixes)) {\n    prefixes[i] <- substr(string, 1, i)\n  }\n  return(prefixes)\n}","tests":"test_humaneval <- function() {\n    candidate <- all_prefixes\n    stopifnot(isTRUE(all.equal(candidate(''), c())))\n    stopifnot(isTRUE(all.equal(candidate('asdfgh'), c('a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'))))\n    stopifnot(isTRUE(all.equal(candidate('WWW'), c('W', 'WW', 'WWW'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_15","nl":"glg_Latn","pl":"r","prompt":"Devolve unha cadea que contén números delimitados por espazo que comezan de 0 ata n inclusive. # >>> string_sequence(0)\n# '0'\n# >>> string_sequence(5)\n# '0 1 2 3 4 5'\nstring_sequence <- function(n) {","canonical_solution":"string_sequence <- function(n) {\n  return(paste(0:n, collapse = \" \"))\n}","tests":"test_humaneval <- function() {\n    candidate <- string_sequence\n    stopifnot(isTRUE(all.equal(candidate(0), '0')))\n    stopifnot(isTRUE(all.equal(candidate(3), '0 1 2 3')))\n    stopifnot(isTRUE(all.equal(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_16","nl":"glg_Latn","pl":"r","prompt":"Dada unha cadea, descubra cantos caracteres distintos (independentemente da caixa) consta de # >>> count_distinct_characters('xyzXYZ')\n# 3\n# >>> count_distinct_characters('Jerry')\n# 4\ncount_distinct_characters <- function(string) {","canonical_solution":"count_distinct_characters <- function(string) {\n  # Convert the string to lowercase to handle case insensitivity\n  lower_string <- tolower(string)\n  # Split the string into individual characters\n  chars <- strsplit(lower_string, NULL)[[1]]\n  # Find the unique characters and count them\n  distinct_count <- length(unique(chars))\n  return(distinct_count)\n}","tests":"test_humaneval <- function() {\n    candidate <- count_distinct_characters\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n    stopifnot(isTRUE(all.equal(candidate('abcde'), 5)))\n    stopifnot(isTRUE(all.equal(candidate('abcdecadeCADE'), 5)))\n    stopifnot(isTRUE(all.equal(candidate('aaaaAAAAaaaa'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('Jerry jERRY JeRRRY'), 5)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_17","nl":"glg_Latn","pl":"r","prompt":"'Hacir' - nota de cuarto, dura un tempo.\"O\" - media nota, dura dous tempos.\"O\" - nota completa, dura catro tempos.Aquí está unha lenda:Non o último.A súa tarefa é analizar esta cadea e devolver unha lista de números enteiros correspondentes a cantos golpes fai cada un.A entrada desta función é unha cadea que representa notas musicais nun formato especial ASCII.# >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n# c(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4)\nparse_music <- function(music_string) {","canonical_solution":"parse_music <- function(music_string) {\n  # Split the input string by spaces to get individual notes\n  notes <- strsplit(music_string, \" \")[[1]]\n  \n  # Map each note to its corresponding beat duration\n  beats <- sapply(notes, function(note) {\n    if (note == 'o') {\n      return(4)\n    } else if (note == 'o|') {\n      return(2)\n    } else if (note == '.|') {\n      return(1)\n    } else {\n      stop(\"Invalid note\")\n    }\n  })\n  \n  return(beats)\n}\n\n# Example usage:\n# parse_music('o o| .| o| o| .| .| .| .| o o')\n# c(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4)","tests":"test_humaneval <- function() {\n    candidate <- parse_music\n    stopifnot(isTRUE(all.equal(candidate(''), c())))\n    stopifnot(isTRUE(all.equal(candidate('o o o o'), c(4, 4, 4, 4))))\n    stopifnot(isTRUE(all.equal(candidate('.| .| .| .|'), c(1, 1, 1, 1))))\n    stopifnot(isTRUE(all.equal(candidate('o| o| .| .| o o o o'), c(2, 2, 1, 1, 4, 4, 4, 4))))\n    stopifnot(isTRUE(all.equal(candidate('o| .| o| .| o o| o o|'), c(2, 1, 2, 1, 4, 2, 4, 2))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_18","nl":"glg_Latn","pl":"r","prompt":"Descubra cantas veces se pode atopar unha determinada subcadena na cadea orixinal. Conta os casos de sobreposición.# >>> how_many_times('', 'a')\n# 0\n# >>> how_many_times('aaa', 'a')\n# 3\n# >>> how_many_times('aaaa', 'aa')\n# 3\nhow_many_times <- function(string, substring) {","canonical_solution":"how_many_times <- function(string, substring) {\n  if (nchar(substring) == 0) {\n    return(0)\n  }\n  \n  count <- 0\n  for (i in seq(nchar(string) - nchar(substring) + 1)) {\n    if (substr(string, i, i + nchar(substring) - 1) == substring) {\n      count <- count + 1\n    }\n  }\n  \n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- how_many_times\n    stopifnot(isTRUE(all.equal(candidate('', 'x'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('xyxyxyx', 'x'), 4)))\n    stopifnot(isTRUE(all.equal(candidate('cacacacac', 'cac'), 4)))\n    stopifnot(isTRUE(all.equal(candidate('john doe', 'john'), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_19","nl":"glg_Latn","pl":"r","prompt":"Devolve a cadea de caracteres con números ordenados do menor ao maior .As opcións válidas son \"cero\", \"un\", \"dous\", \"tres\", \"quatro\", \"cinco\", \"seis\", \"sete\", \"oito\" e \"nueve\". A entrada é unha cadea de números delimitada por espazo desde o cero ao nove.# >>> sort_numbers('three one five')\n# 'one three five'\nsort_numbers <- function(numbers) {","canonical_solution":"sort_numbers <- function(numbers) {\n  words_to_numbers <- c(\n    \"zero\" = 0, \"one\" = 1, \"two\" = 2, \"three\" = 3, \"four\" = 4, \n    \"five\" = 5, \"six\" = 6, \"seven\" = 7, \"eight\" = 8, \"nine\" = 9\n  )\n  \n  number_list <- strsplit(numbers, \" \")[[1]]\n  sorted_numbers <- number_list[order(sapply(number_list, function(word) words_to_numbers[word]))]\n  return(paste(sorted_numbers, collapse = \" \"))\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_numbers\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('three'), 'three')))\n    stopifnot(isTRUE(all.equal(candidate('three five nine'), 'three five nine')))\n    stopifnot(isTRUE(all.equal(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')))\n    stopifnot(isTRUE(all.equal(candidate('six five four three two one zero'), 'zero one two three four five six')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_20","nl":"glg_Latn","pl":"r","prompt":"outros e devolveos por orde (menor número, maior número).De entre unha lista de números (de polo menos dous) seleccione e devolva os dous máis próximos a cada un deles.# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))\n# c(2.0, 2.2)\n# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))\n# c(2.0, 2.0)\nfind_closest_elements <- function(numbers) {","canonical_solution":"find_closest_elements <- function(numbers) {\n  sorted_numbers <- sort(numbers)\n  min_diff <- Inf\n  closest_pair <- c()\n\n  for (i in 1:(length(sorted_numbers) - 1)) {\n    diff <- sorted_numbers[i + 1] - sorted_numbers[i]\n    if (diff < min_diff) {\n      min_diff <- diff\n      closest_pair <- c(sorted_numbers[i], sorted_numbers[i + 1])\n    }\n  }\n\n  return(closest_pair)\n}","tests":"test_humaneval <- function() {\n    candidate <- find_closest_elements\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), c(3.9, 4.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0)), c(5.0, 5.9))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2)), c(2.0, 2.2))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), c(2.0, 2.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1)), c(2.2, 3.1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_21","nl":"glg_Latn","pl":"r","prompt":"de tal forma que o número máis pequeno será 0 e o maior será 1 Dada unha lista de números (de polo menos dous elementos), aplique unha transformación lineal a esa lista, # >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))\n# c(0.0, 0.25, 0.5, 0.75, 1.0)\nrescale_to_unit <- function(numbers) {","canonical_solution":"rescale_to_unit <- function(numbers) {\n  min_val <- min(numbers)\n  max_val <- max(numbers)\n  (numbers - min_val) \/ (max_val - min_val)\n}","tests":"test_humaneval <- function() {\n    candidate <- rescale_to_unit\n    stopifnot(isTRUE(all.equal(candidate(c(2.0, 49.9)), c(0.0, 1.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(100.0, 49.9)), c(1.0, 0.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), c(0.0, 0.25, 0.5, 0.75, 1.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(2.0, 1.0, 5.0, 3.0, 4.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))\n    stopifnot(isTRUE(all.equal(candidate(c(12.0, 11.0, 15.0, 13.0, 14.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_22","nl":"glg_Latn","pl":"r","prompt":"Filtrar a lista de valores de rthon só para números enteiros.# >>> filter_integers(list('a', 3.14, 5))\n# c(5)\n# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))\n# c(1, 2, 3)\nfilter_integers <- function(values) {","canonical_solution":"filter_integers <- function(values) {\n  return(unlist(Filter(is.integer, values)))\n}","tests":"test_humaneval <- function() {\n    candidate <- filter_integers\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(list(4, list(), c(), 23.2, 9, 'adasd')), c(4, 9))))\n    stopifnot(isTRUE(all.equal(candidate(list(3, 'c', 3, 3, 'a', 'b')), c(3, 3, 3))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_23","nl":"glg_Latn","pl":"r","prompt":"Retorno da lonxitude da cadea dada# >>> strlen('')\n# 0\n# >>> strlen('abc')\n# 3\nstrlen <- function(string) {","canonical_solution":"strlen <- function(string) {\n  return(nchar(string))\n}","tests":"test_humaneval <- function() {\n    candidate <- strlen\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n    stopifnot(isTRUE(all.equal(candidate('x'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('asdasnakj'), 9)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_24","nl":"glg_Latn","pl":"r","prompt":"Para un número dado n, atopar o maior número que divide n uniformemente, menor que n # >>> largest_divisor(15)\n# 5\nlargest_divisor <- function(n) {","canonical_solution":"largest_divisor <- function(n) {\n  for (i in (n-1):1) {\n    if (n %% i == 0) {\n      return(i)\n    }\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- largest_divisor\n    stopifnot(isTRUE(all.equal(candidate(3), 1)))\n    stopifnot(isTRUE(all.equal(candidate(7), 1)))\n    stopifnot(isTRUE(all.equal(candidate(10), 5)))\n    stopifnot(isTRUE(all.equal(candidate(100), 50)))\n    stopifnot(isTRUE(all.equal(candidate(49), 7)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_25","nl":"glg_Latn","pl":"r","prompt":"O número de entrada debe ser igual ao produto de todos os factores.Cada un dos factores debe ser listado o número de veces que corresponde ao número de veces que aparece na factorización.Devolve a lista de factores primos dun número enteiro dado en orde de menor a maior.# >>> factorize(8)\n# c(2, 2, 2)\n# >>> factorize(25)\n# c(5, 5)\n# >>> factorize(70)\n# c(2, 5, 7)\nfactorize <- function(n) {","canonical_solution":"factorize <- function(n) {\n  if (n < 2) {\n    return(c())\n  }\n  factors <- c()\n  divisor <- 2\n  \n  while (n > 1) {\n    while (n %% divisor == 0) {\n      factors <- c(factors, divisor)\n      n <- n \/ divisor\n    }\n    divisor <- divisor + 1\n  }\n  \n  return(factors)\n}","tests":"test_humaneval <- function() {\n    candidate <- factorize\n    stopifnot(isTRUE(all.equal(candidate(2), c(2))))\n    stopifnot(isTRUE(all.equal(candidate(4), c(2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(8), c(2, 2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(57), c(3, 19))))\n    stopifnot(isTRUE(all.equal(candidate(3249), c(3, 3, 19, 19))))\n    stopifnot(isTRUE(all.equal(candidate(185193), c(3, 3, 3, 19, 19, 19))))\n    stopifnot(isTRUE(all.equal(candidate(20577), c(3, 19, 19, 19))))\n    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 3))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_26","nl":"glg_Latn","pl":"r","prompt":"Manter a orde dos elementos deixados igual que na entrada.A partir dunha lista de números enteiros, elimine todos os elementos que aparecen máis dunha vez.# >>> remove_duplicates(c(1, 2, 3, 2, 4))\n# c(1, 3, 4)\nremove_duplicates <- function(numbers) {","canonical_solution":"remove_duplicates <- function(numbers) {\n  unique_numbers <- numbers[!duplicated(numbers) & !duplicated(numbers, fromLast = TRUE)]\n  return(unique_numbers)\n}","tests":"test_humaneval <- function() {\n    candidate <- remove_duplicates\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 4, 3, 5)), c(1, 4, 5))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_27","nl":"glg_Latn","pl":"r","prompt":"Para unha cadea dada, volve os caracteres minúsculos a maiúsculas e maiúsculas a minúsculas.# >>> flip_case('Hello')\n# 'hELLO'\nflip_case <- function(string) {","canonical_solution":"flip_case <- function(string) {\n  chars <- strsplit(string, NULL)[[1]]\n  flipped_chars <- sapply(chars, function(c) {\n    if (grepl(\"[a-z]\", c)) {\n      return(toupper(c))\n    } else if (grepl(\"[A-Z]\", c)) {\n      return(tolower(c))\n    } else {\n      return(c)\n    }\n  })\n  return(paste(flipped_chars, collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- flip_case\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('Hello!'), 'hELLO!')))\n    stopifnot(isTRUE(all.equal(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_28","nl":"glg_Latn","pl":"r","prompt":"Concatenate lista de cadeas nunha soa cadea# >>> concatenate(c())\n# ''\n# >>> concatenate(c('a', 'b', 'c'))\n# 'abc'\nconcatenate <- function(strings) {","canonical_solution":"concatenate <- function(strings) {\n  paste(strings, collapse = \"\")\n}","tests":"test_humaneval <- function() {\n    candidate <- concatenate\n    stopifnot(isTRUE(all.equal(candidate(c()), '')))\n    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z')), 'xyz')))\n    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z', 'w', 'k')), 'xyzwk')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_29","nl":"glg_Latn","pl":"r","prompt":"Filtrar unha lista de entrada de cadeas só para aquelas que comezan cun prefixo dado.# >>> filter_by_prefix(c(), 'a')\n# c()\n# >>> filter_by_prefix(c('abc', 'bcd', 'cde', 'array'), 'a')\n# c('abc', 'array')\nfilter_by_prefix <- function(strings, prefix) {","canonical_solution":"filter_by_prefix <- function(strings, prefix) {\n  return(strings[startsWith(strings, prefix)])\n}","tests":"test_humaneval <- function() {\n    candidate <- filter_by_prefix\n    stopifnot(isTRUE(all.equal(candidate(c(), 'john'), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'), 'xxx'), c('xxx', 'xxxAAA', 'xxx'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_30","nl":"glg_Latn","pl":"r","prompt":"Devolve só números positivos da lista.# >>> get_positive(c(-1, 2, -4, 5, 6))\n# c(2, 5, 6)\n# >>> get_positive(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n# c(5, 3, 2, 3, 9, 123, 1)\nget_positive <- function(l) {","canonical_solution":"get_positive <- function(l) {\n  return(l[l > 0])\n}","tests":"test_humaneval <- function() {\n    candidate <- get_positive\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 4, 5, 6)), c(4, 5, 6))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10)), c(5, 3, 2, 3, 3, 9, 123, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2)), c())))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_31","nl":"glg_Latn","pl":"r","prompt":"Devolve verdadeiro se un número dado é primo, e falso doutro xeito.# >>> is_prime(6)\n# FALSE\n# >>> is_prime(101)\n# TRUE\n# >>> is_prime(11)\n# TRUE\n# >>> is_prime(13441)\n# TRUE\n# >>> is_prime(61)\n# TRUE\n# >>> is_prime(4)\n# FALSE\n# >>> is_prime(1)\n# FALSE\nis_prime <- function(n) {","canonical_solution":"is_prime <- function(n) {\n  if (n <= 1) {\n    return(FALSE)\n  }\n  if (n <= 3) {\n    return(TRUE)\n  }\n  if (n %% 2 == 0 || n %% 3 == 0) {\n    return(FALSE)\n  }\n  i <- 5\n  while (i * i <= n) {\n    if (n %% i == 0 || n %% (i + 2) == 0) {\n      return(FALSE)\n    }\n    i <- i + 6\n  }\n  return(TRUE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_prime\n    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(101), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(11), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(13441), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(61), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(5), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(11), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(17), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(85), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(77), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(255379), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_33","nl":"glg_Latn","pl":"r","prompt":"para os valores dos índices correspondentes de l, pero ordenados.l' é idéntico a l nos índices que non son divisible por tres, mentres que os seus valores nos índices que son divisible por tres son iguais Esta función toma unha lista l e devolve unha lista l' tal que # >>> sort_third(c(1, 2, 3))\n# c(1, 2, 3)\n# >>> sort_third(c(5, 6, 3, 4, 8, 9, 2))\n# c(2, 6, 3, 4, 8, 9, 5)\nsort_third <- function(l) {","canonical_solution":"sort_third <- function(l) {\n  # Find the indices that are divisible by three\n  indices_div_by_3 <- seq(3, length(l), by = 3)\n  \n  # Extract the elements at those indices and sort them\n  elements_to_sort <- l[indices_div_by_3]\n  sorted_elements <- sort(elements_to_sort)\n  \n  # Replace the original elements at those indices with sorted ones\n  l[indices_div_by_3] <- sorted_elements\n  \n  return(l)\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_third\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 4, 8, 9, 2)), c(2, 6, 3, 4, 8, 9, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 3, 4, 6, 9, 2)), c(2, 8, 3, 4, 6, 9, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 9, 4, 8, 3, 2)), c(2, 6, 9, 4, 8, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 4, 8, 9, 2, 1)), c(2, 6, 3, 4, 8, 9, 5, 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_34","nl":"glg_Latn","pl":"r","prompt":"Devolve elementos únicos ordenados nunha lista# >>> unique(c(5, 3, 5, 2, 3, 3, 9, 0, 123))\n# c(0, 2, 3, 5, 9, 123)\nunique <- function(l) {","canonical_solution":"unique <- function(l) {\n  return(sort(unique(l)))\n}","tests":"test_humaneval <- function() {\n    candidate <- unique\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 5, 2, 3, 3, 9, 0, 123)), c(0, 2, 3, 5, 9, 123))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_35","nl":"glg_Latn","pl":"r","prompt":"Devolve o elemento máximo da lista.# >>> max_element(c(1, 2, 3))\n# 3\n# >>> max_element(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n# 123\nmax_element <- function(l) {","canonical_solution":"max_element <- function(l) {\n  return(max(l))\n}","tests":"test_humaneval <- function() {\n    candidate <- max_element\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10)), 124)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_36","nl":"glg_Latn","pl":"r","prompt":"Devolve o número de veces que aparece o díxito 7 en números enteiros menores que n que son divídibles por 11 ou 13. # >>> fizz_buzz(50)\n# 0\n# >>> fizz_buzz(78)\n# 2\n# >>> fizz_buzz(79)\n# 3\nfizz_buzz <- function(n) {","canonical_solution":"fizz_buzz <- function(n) {\n  count <- 0\n  for (i in 1:(n-1)) {\n    if (i %% 11 == 0 || i %% 13 == 0) {\n      count <- count + sum(unlist(strsplit(as.character(i), \"\")) == \"7\")\n    }\n  }\n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- fizz_buzz\n    stopifnot(isTRUE(all.equal(candidate(50), 0)))\n    stopifnot(isTRUE(all.equal(candidate(78), 2)))\n    stopifnot(isTRUE(all.equal(candidate(79), 3)))\n    stopifnot(isTRUE(all.equal(candidate(100), 3)))\n    stopifnot(isTRUE(all.equal(candidate(200), 6)))\n    stopifnot(isTRUE(all.equal(candidate(4000), 192)))\n    stopifnot(isTRUE(all.equal(candidate(10000), 639)))\n    stopifnot(isTRUE(all.equal(candidate(100000), 8026)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_37","nl":"glg_Latn","pl":"r","prompt":"para os valores dos índices pares de l, pero ordenados.l' é idéntico a l nos índices impares, mentres que os seus valores nos índices pares son iguais Esta función toma unha lista l e devolve unha lista l' tal que # >>> sort_even(c(1, 2, 3))\n# c(1, 2, 3)\n# >>> sort_even(c(5, 6, 3, 4))\n# c(3, 6, 5, 4)\nsort_even <- function(l) {","canonical_solution":"sort_even <- function(l) {\n  even_indices <- seq(2, length(l), by=2)\n  l[even_indices] <- sort(l[even_indices])\n  return(l)\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_even\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(1, 2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)), c(-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 8, -12, 4, 23, 2, 3, 11, 12, -10)), c(-12, 8, 3, 4, 5, 2, 12, 11, 23, -10))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_39","nl":"glg_Latn","pl":"r","prompt":"prime_fib devolve o n-ésimo número que é un número de Fibonacci e tamén é primo. # >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n# 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n# 89\nprime_fib <- function(n) {","canonical_solution":"prime_fib <- function(n) {\n  is_prime <- function(num) {\n    if (num < 2) return(FALSE)\n    for (i in 2:sqrt(num)) {\n      if (num %% i == 0) return(FALSE)\n    }\n    return(TRUE)\n  }\n  \n  fibonacci <- function() {\n    a <- 0\n    b <- 1\n    while (TRUE) {\n      yield <- a + b\n      a <<- b\n      b <<- yield\n      yield\n    }\n  }\n  \n  fib_gen <- fibonacci()\n  count <- 0\n  repeat {\n    current_fib <- fib_gen()\n    if (is_prime(current_fib)) {\n      count <- count + 1\n      if (count == n) return(current_fib)\n    }\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- prime_fib\n    stopifnot(isTRUE(all.equal(candidate(1), 2)))\n    stopifnot(isTRUE(all.equal(candidate(2), 3)))\n    stopifnot(isTRUE(all.equal(candidate(3), 5)))\n    stopifnot(isTRUE(all.equal(candidate(4), 13)))\n    stopifnot(isTRUE(all.equal(candidate(5), 89)))\n    stopifnot(isTRUE(all.equal(candidate(6), 233)))\n    stopifnot(isTRUE(all.equal(candidate(7), 1597)))\n    stopifnot(isTRUE(all.equal(candidate(8), 28657)))\n    stopifnot(isTRUE(all.equal(candidate(9), 514229)))\n    stopifnot(isTRUE(all.equal(candidate(10), 433494437)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_40","nl":"glg_Latn","pl":"r","prompt":"suma a cero, e FALSO doutro xeito.devolve TRUE se hai tres elementos distintos na lista que triples_sum_to_zero toma unha lista de números enteiros como entrada.# >>> triples_sum_to_zero(c(1, 3, 5, 0))\n# FALSE\n# >>> triples_sum_to_zero(c(1, 3, -2, 1))\n# TRUE\n# >>> triples_sum_to_zero(c(1, 2, 3, 7))\n# FALSE\n# >>> triples_sum_to_zero(c(2, 4, -5, 3, 9, 7))\n# TRUE\n# >>> triples_sum_to_zero(c(1))\n# FALSE\ntriples_sum_to_zero <- function(l) {","canonical_solution":"triples_sum_to_zero <- function(l) {\n  n <- length(l)\n  if (n < 3) {\n    return(FALSE)\n  }\n  for (i in 1:(n - 2)) {\n    for (j in (i + 1):(n - 1)) {\n      for (k in (j + 1):n) {\n        if (l[i] + l[j] + l[k] == 0) {\n          return(TRUE)\n        }\n      }\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- triples_sum_to_zero\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, -1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 5, 7)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 9, 7)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, -100)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(100, 3, 5, -100)), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_41","nl":"glg_Latn","pl":"r","prompt":"Esta función dá como resultado o número de colisións deste tipo. na súa traxectoria como se non chocasen.Con todo, os coches son infinitamente resistentes e fortes; como resultado, seguen en movemento.Cando un coche que se move de esquerda a dereita choca cun coche que se move de dereita a esquerda.Todos os coches se moven á mesma velocidade.Os dous pares de coches comezan a estar moi lonxe de...n coches están a conducir de esquerda a dereita; simultaneamente, un conxunto diferente de n coches Imaxina unha estrada que é unha liña perfectamente recta infinitamente longa.car_race_collision <- function(n) {","canonical_solution":"car_race_collision <- function(n) {\n  # Each car moving left to right will eventually collide with each car moving right to left\n  return(n)\n}","tests":"test_humaneval <- function() {\n    candidate <- car_race_collision\n    stopifnot(isTRUE(all.equal(candidate(2), 4)))\n    stopifnot(isTRUE(all.equal(candidate(3), 9)))\n    stopifnot(isTRUE(all.equal(candidate(4), 16)))\n    stopifnot(isTRUE(all.equal(candidate(8), 64)))\n    stopifnot(isTRUE(all.equal(candidate(10), 100)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_42","nl":"glg_Latn","pl":"r","prompt":"Lista de devolución con elementos incrementados por 1. # >>> incr_list(c(1, 2, 3))\n# c(2, 3, 4)\n# >>> incr_list(c(5, 3, 5, 2, 3, 3, 9, 0, 123))\n# c(6, 4, 6, 3, 4, 4, 10, 1, 124)\nincr_list <- function(l) {","canonical_solution":"incr_list <- function(l) {\n  return(l + 1)\n}","tests":"test_humaneval <- function() {\n    candidate <- incr_list\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), c(4, 3, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 2, 5, 2, 3, 3, 9, 0, 123)), c(6, 3, 6, 3, 4, 4, 10, 1, 124))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_43","nl":"glg_Latn","pl":"r","prompt":"suma a cero, e FALSO doutro xeito.devolve TRUE se hai dous elementos distintos na lista que pairs_sum_to_zero toma unha lista de números enteiros como entrada.# >>> pairs_sum_to_zero(c(1, 3, 5, 0))\n# FALSE\n# >>> pairs_sum_to_zero(c(1, 3, -2, 1))\n# FALSE\n# >>> pairs_sum_to_zero(c(1, 2, 3, 7))\n# FALSE\n# >>> pairs_sum_to_zero(c(2, 4, -5, 3, 5, 7))\n# TRUE\n# >>> pairs_sum_to_zero(c(1))\n# FALSE\npairs_sum_to_zero <- function(l) {","canonical_solution":"pairs_sum_to_zero <- function(l) {\n  n <- length(l)\n  if (n < 2) return(FALSE)\n  \n  for (i in 1:(n-1)) {\n    for (j in (i+1):n) {\n      if (l[i] + l[j] == 0) {\n        return(TRUE)\n      }\n    }\n  }\n  \n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- pairs_sum_to_zero\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 5, 7)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 30)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 31)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 30)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 31)), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_44","nl":"glg_Latn","pl":"r","prompt":"Os números de base son menores a 10.devolver a representación de cadea despois da conversión.Cambiar a base numérica do número de entrada x á base.# >>> change_base(8, 3)\n# '22'\n# >>> change_base(8, 2)\n# '1000'\n# >>> change_base(7, 2)\n# '111'\nchange_base <- function(x, base) {","canonical_solution":"change_base <- function(x, base) {\n  if (x == 0) return('0')\n  result <- ''\n  while (x > 0) {\n    remainder <- x %% base\n    result <- paste0(remainder, result)\n    x <- x %\/% base\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- change_base\n    stopifnot(isTRUE(all.equal(candidate(8, 3), '22')))\n    stopifnot(isTRUE(all.equal(candidate(9, 3), '100')))\n    stopifnot(isTRUE(all.equal(candidate(234, 2), '11101010')))\n    stopifnot(isTRUE(all.equal(candidate(16, 2), '10000')))\n    stopifnot(isTRUE(all.equal(candidate(8, 2), '1000')))\n    stopifnot(isTRUE(all.equal(candidate(7, 2), '111')))\n    stopifnot(isTRUE(all.equal(candidate(2, 3), '2')))\n    stopifnot(isTRUE(all.equal(candidate(3, 4), '3')))\n    stopifnot(isTRUE(all.equal(candidate(4, 5), '4')))\n    stopifnot(isTRUE(all.equal(candidate(5, 6), '5')))\n    stopifnot(isTRUE(all.equal(candidate(6, 7), '6')))\n    stopifnot(isTRUE(all.equal(candidate(7, 8), '7')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_45","nl":"glg_Latn","pl":"r","prompt":"Dado o lonxitude dun lado e a área de retorno máis alta para un triángulo.# >>> triangle_area(5, 3)\n# 7.5\ntriangle_area <- function(a, h) {","canonical_solution":"triangle_area <- function(a, h) {\n  return(0.5 * a * h)\n}","tests":"test_humaneval <- function() {\n    candidate <- triangle_area\n    stopifnot(isTRUE(all.equal(candidate(5, 3), 7.5)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2), 2.0)))\n    stopifnot(isTRUE(all.equal(candidate(10, 8), 40.0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_46","nl":"glg_Latn","pl":"r","prompt":"Por favor, escriba unha función para calcular de forma eficiente o elemento n da secuencia de números fib4. Non use a recursión.fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).fib4(3) -> 0 fib4(2) -> 2 fib4(1) -> 0 fib4(0) -> 0 A secuencia de números Fib4 é unha secuencia similar á secuencia de Fibbonacci que se define do seguinte xeito: # >>> fib4(5)\n# 4\n# >>> fib4(6)\n# 8\n# >>> fib4(7)\n# 14\nfib4 <- function(n) {","canonical_solution":"fib4 <- function(n) {\n  if (n == 0) return(0)\n  if (n == 1) return(0)\n  if (n == 2) return(2)\n  if (n == 3) return(0)\n  \n  fib_seq <- c(0, 0, 2, 0) # Initialize with base cases\n  for (i in 4:n) {\n    fib_seq[i] <- fib_seq[i-1] + fib_seq[i-2] + fib_seq[i-3] + fib_seq[i-4]\n  }\n  return(fib_seq[n])\n}","tests":"test_humaneval <- function() {\n    candidate <- fib4\n    stopifnot(isTRUE(all.equal(candidate(5), 4)))\n    stopifnot(isTRUE(all.equal(candidate(8), 28)))\n    stopifnot(isTRUE(all.equal(candidate(10), 104)))\n    stopifnot(isTRUE(all.equal(candidate(12), 386)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_47","nl":"glg_Latn","pl":"r","prompt":"Mediana de retorno dos elementos da lista l. # >>> median(c(3, 1, 2, 4, 5))\n# 3\n# >>> median(c(-10, 4, 6, 1000, 10, 20))\n# 15.0\nmedian <- function(l) {","canonical_solution":"median <- function(l) {\n  return(median(l))\n}","tests":"test_humaneval <- function() {\n    candidate <- median\n    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 2, 4, 5)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(-10, 4, 6, 1000, 10, 20)), 8.0)))\n    stopifnot(isTRUE(all.equal(candidate(c(5)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(6, 5)), 5.5)))\n    stopifnot(isTRUE(all.equal(candidate(c(8, 1, 3, 9, 9, 2, 7)), 7)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_48","nl":"glg_Latn","pl":"r","prompt":"Comprobar se a cadea é un palíndromo# >>> is_palindrome('')\n# TRUE\n# >>> is_palindrome('aba')\n# TRUE\n# >>> is_palindrome('aaaaa')\n# TRUE\n# >>> is_palindrome('zbcd')\n# FALSE\nis_palindrome <- function(text) {","canonical_solution":"is_palindrome <- function(text) {\n  return(text == paste(rev(unlist(strsplit(text, NULL))), collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- is_palindrome\n    stopifnot(isTRUE(all.equal(candidate(''), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('aba'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('aaaaa'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('zbcd'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('xywyx'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('xywyz'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('xywzx'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_49","nl":"glg_Latn","pl":"r","prompt":"Retorna 2^n módulo p (ten en conta os números).# >>> modp(3, 5)\n# 3\n# >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100, 101)\n# 1\nmodp <- function(n, p) {","canonical_solution":"modp <- function(n, p) {\n  result <- 1\n  base <- 2\n  \n  while (n > 0) {\n    if (n %% 2 == 1) {\n      result <- (result * base) %% p\n    }\n    base <- (base * base) %% p\n    n <- n %\/% 2\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- modp\n    stopifnot(isTRUE(all.equal(candidate(3, 5), 3)))\n    stopifnot(isTRUE(all.equal(candidate(1101, 101), 2)))\n    stopifnot(isTRUE(all.equal(candidate(0, 101), 1)))\n    stopifnot(isTRUE(all.equal(candidate(3, 11), 8)))\n    stopifnot(isTRUE(all.equal(candidate(100, 101), 1)))\n    stopifnot(isTRUE(all.equal(candidate(30, 5), 4)))\n    stopifnot(isTRUE(all.equal(candidate(31, 5), 3)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_51","nl":"glg_Latn","pl":"r","prompt":"remove_vowels é unha función que toma string e devolve string sen vogais. # >>> remove_vowels('')\n# ''\n# >>> remove_vowels('abcdef')\n# 'bcdf'\n# >>> remove_vowels('aaaaa')\n# ''\n# >>> remove_vowels('aaBAA')\n# 'B'\n# >>> remove_vowels('zbcd')\n# 'zbcd'\nremove_vowels <- function(text) {","canonical_solution":"remove_vowels <- function(text) {\n  gsub(\"[aeiouAEIOU]\", \"\", text)\n}","tests":"test_humaneval <- function() {\n    candidate <- remove_vowels\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('abcdef\\nghijklm'), 'bcdf\\nghjklm')))\n    stopifnot(isTRUE(all.equal(candidate('fedcba'), 'fdcb')))\n    stopifnot(isTRUE(all.equal(candidate('eeeee'), '')))\n    stopifnot(isTRUE(all.equal(candidate('acBAA'), 'cB')))\n    stopifnot(isTRUE(all.equal(candidate('EcBOO'), 'cB')))\n    stopifnot(isTRUE(all.equal(candidate('ybcd'), 'ybcd')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_52","nl":"glg_Latn","pl":"r","prompt":"Devolve TRUE se todos os números da lista l están por baixo do limiar t. # >>> below_threshold(c(1, 2, 4, 10), 100)\n# TRUE\n# >>> below_threshold(c(1, 20, 4, 10), 5)\n# FALSE\nbelow_threshold <- function(l, t) {","canonical_solution":"below_threshold <- function(l, t) {\n  return(all(l < t))\n}","tests":"test_humaneval <- function() {\n    candidate <- below_threshold\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10), 100), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 5), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 21), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 22), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 11), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 10), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_53","nl":"glg_Latn","pl":"r","prompt":"Adicionar dous números x e y.# >>> add(2, 3)\n# 5\n# >>> add(5, 7)\n# 12\nadd <- function(x, y) {","canonical_solution":"add <- function(x, y) {\n  return(x + y)\n}","tests":"test_humaneval <- function() {\n    candidate <- add\n    stopifnot(isTRUE(all.equal(candidate(0, 1), 1)))\n    stopifnot(isTRUE(all.equal(candidate(1, 0), 1)))\n    stopifnot(isTRUE(all.equal(candidate(2, 3), 5)))\n    stopifnot(isTRUE(all.equal(candidate(5, 7), 12)))\n    stopifnot(isTRUE(all.equal(candidate(7, 5), 12)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_54","nl":"glg_Latn","pl":"r","prompt":"Comprobar se dúas palabras teñen os mesmos caracteres.# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n# TRUE\n# >>> same_chars('abcd', 'dddddddabc')\n# TRUE\n# >>> same_chars('dddddddabc', 'abcd')\n# TRUE\n# >>> same_chars('eabcd', 'dddddddabc')\n# FALSE\n# >>> same_chars('abcd', 'dddddddabce')\n# FALSE\n# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n# FALSE\nsame_chars <- function(s0, s1) {","canonical_solution":"same_chars <- function(s0, s1) {\n  return(identical(sort(unique(unlist(strsplit(s0, \"\")))), sort(unique(unlist(strsplit(s1, \"\"))))))\n}","tests":"test_humaneval <- function() {\n    candidate <- same_chars\n    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabc'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('dddddddabc', 'abcd'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('eabcd', 'dddddddabc'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabcf'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('aabb', 'aaccc'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_55","nl":"glg_Latn","pl":"r","prompt":"Devolve o n-ésimo número de Fibonacci. # >>> fib(10)\n# 55\n# >>> fib(1)\n# 1\n# >>> fib(8)\n# 21\nfib <- function(n) {","canonical_solution":"fib <- function(n) {\n  if (n <= 1) {\n    return(n)\n  }\n  a <- 0\n  b <- 1\n  for (i in 2:n) {\n    temp <- b\n    b <- a + b\n    a <- temp\n  }\n  return(b)\n}","tests":"test_humaneval <- function() {\n    candidate <- fib\n    stopifnot(isTRUE(all.equal(candidate(10), 55)))\n    stopifnot(isTRUE(all.equal(candidate(1), 1)))\n    stopifnot(isTRUE(all.equal(candidate(8), 21)))\n    stopifnot(isTRUE(all.equal(candidate(11), 89)))\n    stopifnot(isTRUE(all.equal(candidate(12), 144)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_56","nl":"glg_Latn","pl":"r","prompt":"return TRUE se cada corcheta de apertura ten unha corcheta de peche correspondente. paréntesis é unha cadea de caracteres de \"<\" e \">\". # >>> correct_bracketing('<')\n# FALSE\n# >>> correct_bracketing('<>')\n# TRUE\n# >>> correct_bracketing('<<><>>')\n# TRUE\n# >>> correct_bracketing('><<>')\n# FALSE\ncorrect_bracketing <- function(brackets) {","canonical_solution":"correct_bracketing <- function(brackets) {\n  count <- 0\n  for (char in strsplit(brackets, NULL)[[1]]) {\n    if (char == \"<\") {\n      count <- count + 1\n    } else if (char == \">\") {\n      count <- count - 1\n    }\n    if (count < 0) {\n      return(FALSE)\n    }\n  }\n  return(count == 0)\n}","tests":"test_humaneval <- function() {\n    candidate <- correct_bracketing\n    stopifnot(isTRUE(all.equal(candidate('<>'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('<<><>>'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('<><><<<><><>><>><<><><<>>>'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('<<<><>>>>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('><<>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<<<<'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<<>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>><<>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>>><>'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_57","nl":"glg_Latn","pl":"r","prompt":"Devolve TRUE se os elementos da lista están aumentando ou diminuíndo monotónicamente.# >>> monotonic(c(1, 2, 4, 20))\n# TRUE\n# >>> monotonic(c(1, 20, 4, 10))\n# FALSE\n# >>> monotonic(c(4, 1, 0, -10))\n# TRUE\nmonotonic <- function(l) {","canonical_solution":"monotonic <- function(l) {\n  is_increasing <- all(diff(l) >= 0)\n  is_decreasing <- all(diff(l) <= 0)\n  return(is_increasing || is_decreasing)\n}","tests":"test_humaneval <- function() {\n    candidate <- monotonic\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 20)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 0, -10)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 1, 0)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 5, 60)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 60)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 9, 9, 9)), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_58","nl":"glg_Latn","pl":"r","prompt":"Devolve elementos únicos ordenados comúns para dúas listas.# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n# c(1, 5, 653)\n# >>> common(c(5, 3, 2, 8), c(3, 2))\n# c(2, 3)\ncommon <- function(l1, l2) {","canonical_solution":"common <- function(l1, l2) {\n  common_elements <- intersect(l1, l2)\n  sorted_unique_common <- sort(unique(common_elements))\n  return(sorted_unique_common)\n}","tests":"test_humaneval <- function() {\n    candidate <- common\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c()), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_59","nl":"glg_Latn","pl":"r","prompt":"Devolve o maior factor primo de n. Supoñamos que n > 1 e non é un primo. # >>> largest_prime_factor(13195)\n# 29\n# >>> largest_prime_factor(2048)\n# 2\nlargest_prime_factor <- function(n) {","canonical_solution":"largest_prime_factor <- function(n) {\n  # Initialize the largest prime factor\n  largest_prime <- -1\n  \n  # Remove factors of 2\n  while (n %% 2 == 0) {\n    largest_prime <- 2\n    n <- n \/ 2\n  }\n  \n  # Try odd factors from 3 upwards\n  factor <- 3\n  while (factor * factor <= n) {\n    while (n %% factor == 0) {\n      largest_prime <- factor\n      n <- n \/ factor\n    }\n    factor <- factor + 2\n  }\n  \n  # If n is a prime number greater than 2\n  if (n > 2) {\n    largest_prime <- n\n  }\n  \n  # Return the largest prime factor found\n  return(largest_prime)\n}","tests":"test_humaneval <- function() {\n    candidate <- largest_prime_factor\n    stopifnot(isTRUE(all.equal(candidate(15), 5)))\n    stopifnot(isTRUE(all.equal(candidate(27), 3)))\n    stopifnot(isTRUE(all.equal(candidate(63), 7)))\n    stopifnot(isTRUE(all.equal(candidate(330), 11)))\n    stopifnot(isTRUE(all.equal(candidate(13195), 29)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_60","nl":"glg_Latn","pl":"r","prompt":"sum_to_n é unha función que suma números de 1 a n.# >>> sum_to_n(30)\n# 465\n# >>> sum_to_n(100)\n# 5050\n# >>> sum_to_n(5)\n# 15\n# >>> sum_to_n(10)\n# 55\n# >>> sum_to_n(1)\n# 1\nsum_to_n <- function(n) {","canonical_solution":"sum_to_n <- function(n) {\n  return(sum(1:n))\n}","tests":"test_humaneval <- function() {\n    candidate <- sum_to_n\n    stopifnot(isTRUE(all.equal(candidate(1), 1)))\n    stopifnot(isTRUE(all.equal(candidate(6), 21)))\n    stopifnot(isTRUE(all.equal(candidate(11), 66)))\n    stopifnot(isTRUE(all.equal(candidate(30), 465)))\n    stopifnot(isTRUE(all.equal(candidate(100), 5050)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_61","nl":"glg_Latn","pl":"r","prompt":"return TRUE se cada corcheta de apertura ten unha corcheta de peche correspondente. paréntesis é unha cadea de caracteres de \"(\" e \")\". # >>> correct_bracketing('(')\n# FALSE\n# >>> correct_bracketing('()')\n# TRUE\n# >>> correct_bracketing('(()())')\n# TRUE\n# >>> correct_bracketing(')(()')\n# FALSE\ncorrect_bracketing <- function(brackets) {","canonical_solution":"correct_bracketing <- function(brackets) {\n  balance <- 0\n  for (char in strsplit(brackets, NULL)[[1]]) {\n    if (char == \"(\") {\n      balance <- balance + 1\n    } else if (char == \")\") {\n      balance <- balance - 1\n    }\n    if (balance < 0) {\n      return(FALSE)\n    }\n  }\n  return(balance == 0)\n}","tests":"test_humaneval <- function() {\n    candidate <- correct_bracketing\n    stopifnot(isTRUE(all.equal(candidate('()'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('(()())'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('()()(()())()'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('()()((()()())())(()()(()))'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('((()())))'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(')(()'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('('), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('(((('), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(')'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('(()'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('()()(()())())(()'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('()()(()())()))()'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_62","nl":"glg_Latn","pl":"r","prompt":"Devolve a derivada deste polinomio na mesma forma.xs[0] + xs[1] * x + xs[2] * x^2 + .... xs representan coeficientes dun polinomio.# >>> derivative(c(3, 1, 2, 4, 5))\n# c(1, 4, 12, 20)\n# >>> derivative(c(1, 2, 3))\n# c(2, 6)\nderivative <- function(xs) {","canonical_solution":"derivative <- function(xs) {\n  n <- length(xs)\n  if (n <= 1) return(numeric(0))  # Derivative of a constant is zero\n  \n  deriv <- numeric(n - 1)\n  for (i in 2:n) {\n    deriv[i - 1] <- xs[i] * (i - 1)\n  }\n  return(deriv)\n}","tests":"test_humaneval <- function() {\n    candidate <- derivative\n    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 2, 4, 5)), c(1, 4, 12, 20))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(2, 6))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), c(2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1, 0, 4)), c(2, 2, 0, 16))))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_63","nl":"glg_Latn","pl":"r","prompt":"Por favor, escriba unha función para calcular de forma eficiente o elemento n da secuencia de números fibfib.fibfib (n) == fibfib (n-1) + fibfib (n-2) + fibfib (n-3). fibfib(2) == 1 fibfib ((1) == 0 fibfib(0) == 0 A secuencia de números FibFib é unha secuencia similar á secuencia de Fibbonacci que se define do seguinte xeito: # >>> fibfib(1)\n# 0\n# >>> fibfib(5)\n# 4\n# >>> fibfib(8)\n# 24\nfibfib <- function(n) {","canonical_solution":"fibfib <- function(n) {\n  # Base cases\n  if (n == 0) return(0)\n  if (n == 1) return(0)\n  if (n == 2) return(1)\n\n  # Initialize the first three values\n  fibfib_values <- c(0, 0, 1)\n  \n  # Compute fibfib for the rest using iteration\n  for (i in 3:n) {\n    fibfib_values[i + 1] <- fibfib_values[i] + fibfib_values[i - 1] + fibfib_values[i - 2]\n  }\n  # Return the nth value\n  return(fibfib_values[n + 1])\n}","tests":"test_humaneval <- function() {\n    candidate <- fibfib\n    stopifnot(isTRUE(all.equal(candidate(2), 1)))\n    stopifnot(isTRUE(all.equal(candidate(1), 0)))\n    stopifnot(isTRUE(all.equal(candidate(5), 4)))\n    stopifnot(isTRUE(all.equal(candidate(8), 24)))\n    stopifnot(isTRUE(all.equal(candidate(10), 81)))\n    stopifnot(isTRUE(all.equal(candidate(12), 274)))\n    stopifnot(isTRUE(all.equal(candidate(14), 927)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_64","nl":"glg_Latn","pl":"r","prompt":"Exemplo: Vocabular, pero só cando está ao final da palabra dada.As vogais neste caso son \"a\", \"e\", \"i\", \"o\", \"u\". Aquí, \"y\" é tamén un Unha palabra como entrada e devolve o número de vogais na cadea.Escribe unha función vowels_count que leva unha cadea que representa # >>> vowels_count('abcde')\n# 2\n# >>> vowels_count('ACEDY')\n# 3\nvowels_count <- function(s) {","canonical_solution":"vowels_count <- function(s) {\n  s <- tolower(s)\n  n <- nchar(s)\n  count <- sum(unlist(strsplit(s, NULL)) %in% c('a', 'e', 'i', 'o', 'u'))\n  if (n > 0 && substr(s, n, n) == 'y') {\n    count <- count + 1\n  }\n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- vowels_count\n    stopifnot(isTRUE(all.equal(candidate('abcde'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('Alone'), 3)))\n    stopifnot(isTRUE(all.equal(candidate('key'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('bye'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('keY'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('bYe'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('ACEDY'), 3)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_65","nl":"glg_Latn","pl":"r","prompt":"Se shift > número de díxitos, devolver díxitos invertidos. e devolve o resultado como unha cadea. Circular desprazar os díxitos do número enteiro x, desprazar os díxitos á dereita por desprazamento # >>> circular_shift(12, 1)\n# '21'\n# >>> circular_shift(12, 2)\n# '12'\ncircular_shift <- function(x, shift) {","canonical_solution":"circular_shift <- function(x, shift) {\n  digits <- as.character(x)\n  n <- nchar(digits)\n  \n  if (shift > n) {\n    return(paste0(rev(unlist(strsplit(digits, \"\"))), collapse = \"\"))\n  }\n  \n  shift <- shift %% n\n  if (shift == 0) {\n    return(digits)\n  }\n  \n  right_part <- substr(digits, n - shift + 1, n)\n  left_part <- substr(digits, 1, n - shift)\n  result <- paste0(right_part, left_part)\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- circular_shift\n    stopifnot(isTRUE(all.equal(candidate(100, 2), '001')))\n    stopifnot(isTRUE(all.equal(candidate(12, 2), '12')))\n    stopifnot(isTRUE(all.equal(candidate(97, 8), '79')))\n    stopifnot(isTRUE(all.equal(candidate(12, 1), '21')))\n    stopifnot(isTRUE(all.equal(candidate(11, 101), '11')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_66","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Códigos ASCII. Escribir unha función que toma unha cadea como entrada e devolve a suma dos caracteres superiores só' Tarefa # >>> digitSum('')\n# 0\n# >>> digitSum('abAB')\n# 131\n# >>> digitSum('abcCd')\n# 67\n# >>> digitSum('helloE')\n# 69\n# >>> digitSum('woArBld')\n# 131\n# >>> digitSum('aAaaaXa')\n# 153\ndigitSum <- function(s) {","canonical_solution":"digitSum <- function(s) {\n  sum(sapply(unlist(strsplit(s, \"\")), function(x) {\n    if (grepl(\"[A-Z]\", x)) {\n      return(as.integer(charToRaw(x)))\n    } else {\n      return(0)\n    }\n  }))\n}","tests":"test_humaneval <- function() {\n    candidate <- digitSum\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n    stopifnot(isTRUE(all.equal(candidate('abAB'), 131)))\n    stopifnot(isTRUE(all.equal(candidate('abcCd'), 67)))\n    stopifnot(isTRUE(all.equal(candidate('helloE'), 69)))\n    stopifnot(isTRUE(all.equal(candidate('woArBld'), 131)))\n    stopifnot(isTRUE(all.equal(candidate('aAaaaXa'), 153)))\n    stopifnot(isTRUE(all.equal(candidate(' How are yOu?'), 151)))\n    stopifnot(isTRUE(all.equal(candidate('You arE Very Smart'), 327)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_67","nl":"glg_Latn","pl":"r","prompt":"para exámbulo: no cesto devolve o número de froitos de manga no cesto. As laranxas e as mazás e un número enteiro que represente o número total de froitas Mango, laranxa e mazás, dada a cadea que representa o número total de que se distribuíron nunha cesta de froitas que contén esta cesta.Nesta tarefa, recibirás unha cadea que representa un número de mazás e laranxas.# >>> fruit_distribution('5 apples and 6 oranges', 19)\n# 8\n# >>> fruit_distribution('0 apples and 1 oranges', 3)\n# 2\n# >>> fruit_distribution('2 apples and 3 oranges', 100)\n# 95\n# >>> fruit_distribution('100 apples and 1 oranges', 120)\n# 19\nfruit_distribution <- function(s, n) {","canonical_solution":"fruit_distribution <- function(s, n) {\n  # Extract numbers using regular expressions\n  matches <- regmatches(s, gregexpr(\"\\\\d+\", s))\n  # Convert extracted number strings to integers\n  fruits_count <- as.integer(unlist(matches))\n  # Total fruits described in the string\n  total_apples_oranges <- sum(fruits_count)\n  # Calculate mangoes\n  mangoes <- n - total_apples_oranges\n  return(mangoes)\n}","tests":"test_humaneval <- function() {\n    candidate <- fruit_distribution\n    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 19), 8)))\n    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 21), 10)))\n    stopifnot(isTRUE(all.equal(candidate('0 apples and 1 oranges', 3), 2)))\n    stopifnot(isTRUE(all.equal(candidate('1 apples and 0 oranges', 3), 2)))\n    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 100), 95)))\n    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 5), 0)))\n    stopifnot(isTRUE(all.equal(candidate('1 apples and 100 oranges', 120), 19)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_68","nl":"glg_Latn","pl":"r","prompt":"Exemplo 1: Se non hai valores pares ou o vector dado está baleiro, devolve [].O nodo arrancado debe ser devolto nunha lista, [smallest_value, o seu índice], Se se atopan varios nodos co mesmo valor par máis pequeno, devolve o nodo que ten o índice máis pequeno. O nodo arrancado debe ser o nodo co menor valor par.A túa tarefa é arrancar un dos nós e devolvelo.\"Dado un vector que representa unha rama dunha árbore que ten nodos de números enteiros non negativos # >>> pluck(c(4, 2, 3))\n# c(2, 1)\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck(c(1, 2, 3))\n# c(2, 1)\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck(c())\n# c()\n# Example 4:\n# >>> pluck(c(5, 0, 3, 0, 4, 2))\n# c(0, 1)\n# Explanation: 0 is the smallest value, but  there are two zeros,\n#              so we will choose the first zero, which has the smallest index.\n# Constraints:\n#     * 1 <= nodes.length <= 10000\n#     * 0 <= node.value\npluck <- function(arr) {","canonical_solution":"pluck <- function(arr) {\n  # Find indices for even numbers in the array\n  even_indices <- which(arr %% 2 == 0)\n  \n  # If no even numbers are found, return an empty list\n  if (length(even_indices) == 0) {\n    return(c())\n  }\n  \n  # Extract even numbers\n  even_values <- arr[even_indices]\n  \n  # Find the smallest even value\n  min_even_value <- min(even_values)\n  \n  # Find the index of the first occurrence of the smallest even value\n  min_index <- even_indices[which.min(even_values)]\n  \n  # Return the smallest even value and its index (0-based index)\n  return(c(min_even_value, min_index - 1))\n}","tests":"test_humaneval <- function() {\n    candidate <- pluck\n    stopifnot(isTRUE(all.equal(candidate(c(4, 2, 3)), c(2, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(2, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 0, 3, 0, 4, 2)), c(0, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 0, 5, 3)), c(0, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 8, 4, 8)), c(4, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(7, 6, 7, 1)), c(6, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 7, 1)), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_69","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Se non existe tal valor, devolve -1.A frecuencia dun número enteiro é o número de veces que aparece na lista.cero, e ten unha frecuencia maior ou igual ao valor do propio número enteiro.Dámosche unha lista non baleira de enteiros positivos.# >>> search(c(4, 1, 2, 2, 3, 1))\n# 2\n# >>> search(c(1, 2, 2, 3, 3, 3, 4, 4, 4))\n# 3\n# >>> search(c(5, 5, 4, 4, 4))\n# -1\nsearch <- function(lst) {","canonical_solution":"search <- function(lst) {\n  # Calculate the frequency table\n  freq_table <- table(lst)\n  \n  # Convert to a data frame for easier processing\n  freq_df <- as.data.frame(freq_table)\n  \n  # Rename columns for convenience\n  names(freq_df) <- c(\"value\", \"frequency\")\n  \n  # Filter the values where the frequency is greater than or equal to the value itself\n  valid_values <- freq_df[freq_df$value <= freq_df$frequency, \"value\"]\n  \n  # If no valid values exist, return -1\n  if (length(valid_values) == 0) {\n    return(-1)\n  }\n  \n  # Otherwise, return the greatest valid value\n  return(max(valid_values))\n}","tests":"test_humaneval <- function() {\n    candidate <- search\n    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5, 1)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 4, 1, 4, 4)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 3)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 8, 8, 8, 8, 8, 8)), 8)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 3, 2, 2)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 8, 2)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 3, 6, 5, 6, 4)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 9, 10, 1, 3)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(10)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 10, 10, 9, 2)), -1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_70","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Entón máximo dos números enteiros restantes, entón mínimo e así por diante.Sorteo estraño, é cando comeza co valor mínimo, Dada a lista de números enteiros, devolve a lista en orde estraña.# >>> strange_sort_list(c(1, 2, 3, 4))\n# c(1, 4, 2, 3)\n# >>> strange_sort_list(c(5, 5, 5, 5))\n# c(5, 5, 5, 5)\n# >>> strange_sort_list(c())\n# c()\nstrange_sort_list <- function(lst) {","canonical_solution":"strange_sort_list <- function(lst) {\n  result <- c()\n  while (length(lst) > 0) {\n    # Find and append the minimum of the list\n    min_val <- min(lst)\n    result <- c(result, min_val)\n    lst <- lst[lst != min_val]\n    \n    # Check if list is not empty before finding maximum\n    if (length(lst) > 0) {\n      # Find and append the maximum of the list\n      max_val <- max(lst)\n      result <- c(result, max_val)\n      lst <- lst[lst != max_val]\n    }\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- strange_sort_list\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 4, 2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 7, 8, 9)), c(5, 9, 6, 8, 7))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), c(1, 5, 2, 4, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 7, 8, 9, 1)), c(1, 9, 5, 8, 6, 7))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5)), c(5, 5, 5, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7, 8)), c(1, 8, 2, 7, 3, 6, 4, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 2, 2, 2, 5, 5, -5, -5)), c(-5, 5, -5, 5, 0, 2, 2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(111111)), c(111111))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_71","nl":"glg_Latn","pl":"r","prompt":"Exemplo: que o terceiro lado.Tres lados forman un triángulo válido cando a suma de calquera dos dous lados é maior.Se non, devolve -1 O triángulo redondeado a 2 décimas se os tres lados forman un triángulo válido. Dadas as lonxitudes dos tres lados dun triángulo, devolve a área de # >>> triangle_area(3, 4, 5)\n# 6.0\n# >>> triangle_area(1, 2, 10)\n# -1\ntriangle_area <- function(a, b, c) {","canonical_solution":"triangle_area <- function(a, b, c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    # Using Heron's formula\n    s <- (a + b + c) \/ 2\n    area <- sqrt(s * (s - a) * (s - b) * (s - c))\n    return(round(area, 2))\n  } else {\n    return(-1)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- triangle_area\n    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), 6.0)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2, 10), -1)))\n    stopifnot(isTRUE(all.equal(candidate(4, 8, 5), 8.18)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), 1.73)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), -1)))\n    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), 16.25)))\n    stopifnot(isTRUE(all.equal(candidate(2, 6, 3), -1)))\n    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), 0.43)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), -1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_72","nl":"glg_Latn","pl":"r","prompt":"Exemplo: O obxecto q voará se está equilibrado (é unha lista palindrómica) e a suma dos seus elementos é menor ou igual ao peso máximo posible w.Escribe unha función que devolva VERDADEIRO se o obxecto q voará, e FALSO doutra forma. # >>> will_it_fly(c(1, 2), 5)\n# FALSE\n# # 1+2 is less than the maximum possible weight, but it's unbalanced.\n# >>> will_it_fly(c(3, 2, 3), 1)\n# FALSE\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n# >>> will_it_fly(c(3, 2, 3), 9)\n# TRUE\n# # 3+2+3 is less than the maximum possible weight, and it's balanced.\n# >>> will_it_fly(c(3), 5)\n# TRUE\n# # 3 is less than the maximum possible weight, and it's balanced.\nwill_it_fly <- function(q, w) {","canonical_solution":"will_it_fly <- function(q, w) {\n  is_palindromic <- function(lst) {\n    return(all(lst == rev(lst)))\n  }\n  \n  is_balanced <- is_palindromic(q)\n  sum_elements <- sum(q)\n  \n  return(is_balanced && (sum_elements <= w))\n}","tests":"test_humaneval <- function() {\n    candidate <- will_it_fly\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 9), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2), 5), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3), 5), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 1), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), 6), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(5), 5), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_73","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: é a mesma lectura cara atrás e cara adiante. Nun cambio, podes cambiar un elemento a calquera outro elemento.Un vector palindromo é un vector que Dado un vector arr de enteiros, atopa o número mínimo de elementos que # >>> smallest_change(c(1, 2, 3, 5, 4, 7, 9, 6))\n# 4\n# >>> smallest_change(c(1, 2, 3, 4, 3, 2, 2))\n# 1\n# >>> smallest_change(c(1, 2, 3, 2, 1))\n# 0\nsmallest_change <- function(arr) {","canonical_solution":"smallest_change <- function(arr) {\n  n <- length(arr)\n  changes <- 0\n  \n  for (i in 1:(n %\/% 2)) {\n    if (arr[i] != arr[n - i + 1]) {\n      changes <- changes + 1\n    }\n  }\n  \n  return(changes)\n}","tests":"test_humaneval <- function() {\n    candidate <- smallest_change\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5, 4, 7, 9, 6)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 3, 2, 2)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 4, 2)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 1, 3)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_74","nl":"glg_Latn","pl":"r","prompt":"Exemplos Se as dúas listas teñen o mesmo número de caracteres, devolve a primeira lista.O número total de caracteres en todas as cadeas da lista é menor que a outra lista.Escribe unha función que acepte dúas listas de cadeas e devolva a lista que ten # >>> total_match(c(), c())\n# c()\n# >>> total_match(c('hi', 'admin'), c('hI', 'Hi'))\n# c('hI', 'Hi')\n# >>> total_match(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project'))\n# c('hi', 'admin')\n# >>> total_match(c('hi', 'admin'), c('hI', 'hi', 'hi'))\n# c('hI', 'hi', 'hi')\n# >>> total_match(c('4'), c('1', '2', '3', '4', '5'))\n# c('4')\ntotal_match <- function(lst1, lst2) {","canonical_solution":"total_match <- function(lst1, lst2) {\n  chars_count <- function(lst) {\n    sum(nchar(lst))\n  }\n  \n  count1 <- chars_count(lst1)\n  count2 <- chars_count(lst2)\n  \n  if (count1 < count2) {\n    return(lst1)\n  } else if (count1 > count2) {\n    return(lst2)\n  } else {\n    return(lst1)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- total_match\n    stopifnot(isTRUE(all.equal(candidate(c(), c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi')), c('hi', 'hi'))))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project')), c('hi', 'admin'))))\n    stopifnot(isTRUE(all.equal(candidate(c('4'), c('1', '2', '3', '4', '5')), c('4'))))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'Hi')), c('hI', 'Hi'))))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hi')), c('hI', 'hi', 'hi'))))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hii')), c('hi', 'admin'))))\n    stopifnot(isTRUE(all.equal(candidate(c(), c('this')), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('this'), c()), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_75","nl":"glg_Latn","pl":"r","prompt":"Exemplo: Sabendo que (a) é menor que 100.e falso doutro xeito.Escribe unha función que devolva a verdade se o número dado é a multiplicación de 3 números primos # >>> is_multiply_prime(30)\n# TRUE\n# 30 = 2 * 3 * 5\nis_multiply_prime <- function(a) {","canonical_solution":"is_multiply_prime <- function(a) {\n  is_prime <- function(n) {\n    if (n <= 1) return(FALSE)\n    if (n <= 3) return(TRUE)\n    if (n %% 2 == 0 || n %% 3 == 0) return(FALSE)\n    i <- 5\n    while (i * i <= n) {\n      if (n %% i == 0 || n %% (i + 2) == 0) return(FALSE)\n      i <- i + 6\n    }\n    return(TRUE)\n  }\n\n  if (a >= 100) return(FALSE)\n  \n  primes <- c()\n  for (i in 2:a) {\n    if (is_prime(i)) {\n      primes <- c(primes, i)\n    }\n  }\n  \n  for (i in 1:length(primes)) {\n    for (j in i:length(primes)) {\n      for (k in j:length(primes)) {\n        if (primes[i] * primes[j] * primes[k] == a) {\n          return(TRUE)\n        }\n      }\n    }\n  }\n  \n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_multiply_prime\n    stopifnot(isTRUE(all.equal(candidate(5), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(30), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(10), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(125), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(105), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(126), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(729), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(891), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1001), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_76","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: x é unha potencia simple de n se n**int=x potencia de n e falsa noutros casos.A súa tarefa é escribir unha función que devolva verdadeiro se un número x é un simple # >>> is_simple_power(1, 4)\n# TRUE\n# >>> is_simple_power(2, 2)\n# TRUE\n# >>> is_simple_power(8, 2)\n# TRUE\n# >>> is_simple_power(3, 2)\n# FALSE\n# >>> is_simple_power(3, 1)\n# FALSE\n# >>> is_simple_power(5, 3)\n# FALSE\nis_simple_power <- function(x, n) {","canonical_solution":"is_simple_power <- function(x, n) {\n  if (x == 1) return(TRUE)\n  power <- 1\n  while (power < x) {\n    power <- power * n\n    if (power == x) return(TRUE)\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_simple_power\n    stopifnot(isTRUE(all.equal(candidate(16, 2), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(143214, 16), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(4, 2), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(9, 3), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(16, 4), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(24, 2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(128, 4), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(12, 6), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1, 1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(1, 12), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_77","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Nota: pode asumir que a entrada é sempre válida.se este ingeger é un cubo de algún número enteiro.Escribe unha función que tome un enteiro a e devolva TRUE # >>> iscube(1)\n# TRUE\n# >>> iscube(2)\n# FALSE\n# >>> iscube(-1)\n# TRUE\n# >>> iscube(64)\n# TRUE\n# >>> iscube(0)\n# TRUE\n# >>> iscube(180)\n# FALSE\niscube <- function(a) {","canonical_solution":"iscube <- function(a) {\n  if (a == 0) return(TRUE)\n  root <- round(abs(a)^(1\/3))\n  return(root^3 == abs(a))\n}","tests":"test_humaneval <- function() {\n    candidate <- iscube\n    stopifnot(isTRUE(all.equal(candidate(1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(-1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(64), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(180), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1000), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(0), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(1729), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_78","nl":"glg_Latn","pl":"r","prompt":"Exemplos: e os símbolos A,B,C,D,E,F son sempre maiúsculas.Nota: pode asumir que a entrada é sempre correcta ou cadea baleira, B (= decimal 11), D (= decimal 13). Así que tes que determinar un número dos seguintes díxitos: 2, 3, 5, 7, Os números primos son 2, 3, 5, 7, 11, 13, 17,...Os díxitos hexadecimais son 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. maior que 1 que non é un produto de dous números naturais máis pequenos).díxitos que son primos (un número primo, ou un primo, é un número natural un número hexadecimal como unha cadea e conta o número de hexadecimal Foi encargado de escribir unha función que recibe # >>> hex_key('AB')\n# 1\n# >>> hex_key('1077E')\n# 2\n# >>> hex_key('ABED1A33')\n# 4\n# >>> hex_key('123456789ABCDEF0')\n# 6\n# >>> hex_key('2020')\n# 2\nhex_key <- function(num) {","canonical_solution":"hex_key <- function(num) {\n  # Define the set of prime hexadecimal digits\n  prime_hex_digits <- c('2', '3', '5', '7', 'B', 'D')\n  \n  # Initialize a counter\n  count <- 0\n  \n  # Convert the input string to a list of characters\n  chars <- strsplit(num, NULL)[[1]]\n  \n  # Loop over each character in the list\n  for (char in chars) {\n    # Check if the character is in the list of prime hexadecimal digits\n    if (char %in% prime_hex_digits) {\n      # Increment the count\n      count <- count + 1\n    }\n  }\n  \n  # Return the count\n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- hex_key\n    stopifnot(isTRUE(all.equal(candidate('AB'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('1077E'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('ABED1A33'), 4)))\n    stopifnot(isTRUE(all.equal(candidate('2020'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('123456789ABCDEF0'), 6)))\n    stopifnot(isTRUE(all.equal(candidate('112233445566778899AABBCCDDEEFF00'), 12)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_79","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Os caracteres adicionais están aí para axudar co formato.Haberá un par de caracteres 'db' extra ao comezo e ao final da cadea.Cada carácter da cadea será '0' ou '1'.O formato binario. A función debe devolver unha cadea, con cada carácter que representa un binario Terás un número en forma decimal e a túa tarefa é convertelo en # >>> decimal_to_binary(15)\n# 'db1111db'\n# >>> decimal_to_binary(32)\n# 'db100000db'\ndecimal_to_binary <- function(decimal) {","canonical_solution":"decimal_to_binary <- function(decimal) {\n  binary_string <- as.character(intToBits(decimal))\n  binary_clean <- paste0(rev(binary_string), collapse = \"\")\n  binary_trimmed <- sub(\"^0+\", \"\", binary_clean)\n  return(paste0(\"db\", binary_trimmed, \"db\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- decimal_to_binary\n    stopifnot(isTRUE(all.equal(candidate(0), 'db0db')))\n    stopifnot(isTRUE(all.equal(candidate(32), 'db100000db')))\n    stopifnot(isTRUE(all.equal(candidate(103), 'db1100111db')))\n    stopifnot(isTRUE(all.equal(candidate(15), 'db1111db')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_80","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: Unha cadea é hapr se a súa lonxitude é polo menos 3 e cada 3 letras consecutivas son distintas.A túa tarefa é comprobar se a cadea é correcta ou non.Vostede está dado unha cadea de caracteres.# >>> is_happy('a')\n# FALSE\n# >>> is_happy('aa')\n# FALSE\n# >>> is_happy('abcd')\n# TRUE\n# >>> is_happy('aabb')\n# FALSE\n# >>> is_happy('adb')\n# TRUE\n# >>> is_happy('xyy')\n# FALSE\nis_happy <- function(s) {","canonical_solution":"is_happy <- function(s) {\n  n <- nchar(s)\n  if (n < 3) {\n    return(FALSE)\n  }\n  for (i in 1:(n - 2)) {\n    if (length(unique(substring(s, i, i + 2))) != 3) {\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_happy\n    stopifnot(isTRUE(all.equal(candidate('a'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('aa'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('abcd'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('aabb'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('adb'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('xyy'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('iopaxpoi'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('iopaxioi'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_81","nl":"glg_Latn","pl":"r","prompt":"Exemplo: 0.0 E > 0,0 D- > 0,7 D > 1,0 D+ > 1,3 C- > 1,7 °C > 2,0 C+ > 2.3 B- > 2,7 B > 3,0 B+ > 3.3 A- > 3,7 A 4.0 A+ GPA. Nota de letras.Unha función que pode producir unha lista de graos de letras usando a seguinte táboa: Ela deuche unha lista de GPAs para algúns estudantes e tes que escribir.O único problema é que perdeu o código que usaba para a clasificación.O profesorado desenvolveu o seu propio algoritmo de puntuación.É a última semana do semestre e o profesor ten que dar as notas .# >>> grade_equation(c(4.0, 3, 1.7, 2, 3.5))\n# c('A+', 'B', 'C-', 'C', 'A-')\nnumerical_letter_grade <- function(grades) {","canonical_solution":"numerical_letter_grade <- function(grades) {\n  letter_grades <- sapply(grades, function(gpa) {\n    if (gpa == 4.0) {\n      \"A+\"\n    } else if (gpa > 3.7) {\n      \"A\"\n    } else if (gpa > 3.3) {\n      \"A-\"\n    } else if (gpa > 3.0) {\n      \"B+\"\n    } else if (gpa > 2.7) {\n      \"B\"\n    } else if (gpa > 2.3) {\n      \"B-\"\n    } else if (gpa > 2.0) {\n      \"C+\"\n    } else if (gpa > 1.7) {\n      \"C\"\n    } else if (gpa > 1.3) {\n      \"C-\"\n    } else if (gpa > 1.0) {\n      \"D+\"\n    } else if (gpa > 0.7) {\n      \"D\"\n    } else if (gpa > 0.0) {\n      \"D-\"\n    } else {\n      \"E\"\n    }\n  })\n  return(letter_grades)\n}","tests":"test_humaneval <- function() {\n    candidate <- numerical_letter_grade\n    stopifnot(isTRUE(all.equal(candidate(c(4.0, 3, 1.7, 2, 3.5)), c('A+', 'B', 'C-', 'C', 'A-'))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.2)), c('D+'))))\n    stopifnot(isTRUE(all.equal(candidate(c(0.5)), c('D-'))))\n    stopifnot(isTRUE(all.equal(candidate(c(0.0)), c('E'))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 0.3, 1.5, 2.8, 3.3)), c('D', 'D-', 'C-', 'B', 'B+'))))\n    stopifnot(isTRUE(all.equal(candidate(c(0.0, 0.7)), c('E', 'D-'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_82","nl":"glg_Latn","pl":"r","prompt":"Exemplos longitude é un número primo ou FALSO doutro xeito Escribe unha función que toma unha cadea e devolve TRUE se a cadea # >>> prime_length('Hello')\n# TRUE\n# >>> prime_length('abcdcba')\n# TRUE\n# >>> prime_length('kittens')\n# TRUE\n# >>> prime_length('orange')\n# FALSE\nprime_length <- function(string) {","canonical_solution":"prime_length <- function(string) {\n  is_prime <- function(n) {\n    if (n <= 1) return(FALSE)\n    if (n <= 3) return(TRUE)\n    if (n %% 2 == 0 || n %% 3 == 0) return(FALSE)\n    \n    i <- 5\n    while (i * i <= n) {\n      if (n %% i == 0 || n %% (i + 2) == 0) return(FALSE)\n      i <- i + 6\n    }\n    \n    return(TRUE)\n  }\n  \n  string_length <- nchar(string)\n  return(is_prime(string_length))\n}","tests":"test_humaneval <- function() {\n    candidate <- prime_length\n    stopifnot(isTRUE(all.equal(candidate('Hello'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('abcdcba'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('kittens'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('orange'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('wow'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('world'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('MadaM'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('Wow'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('HI'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('go'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('gogo'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('aaaaaaaaaaaaaaa'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('Madam'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('M'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('0'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_83","nl":"glg_Latn","pl":"r","prompt":"Os números enteiros positivos que comezan ou rematan con 1.Dado un número enteiro positivo n, devolve o número de díxitos n.starts_one_ends <- function(n) {","canonical_solution":"starts_one_ends <- function(n) {\n  if (n == 1) {\n    return(1)\n  } else {\n    return(9 * (10^(n-2)) * 2)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- starts_one_ends\n    stopifnot(isTRUE(all.equal(candidate(1), 1)))\n    stopifnot(isTRUE(all.equal(candidate(2), 18)))\n    stopifnot(isTRUE(all.equal(candidate(3), 180)))\n    stopifnot(isTRUE(all.equal(candidate(4), 1800)))\n    stopifnot(isTRUE(all.equal(candidate(5), 18000)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_84","nl":"glg_Latn","pl":"r","prompt":"Exemplo Dado un número enteiro positivo N, devolve a suma total dos seus díxitos en binario. # >>> solve(1000)\n# '1'\n# >>> solve(150)\n# '110'\n# >>> solve(147)\n# '1100'\n# Variables:\n#     @N integer\n#          Constraints: 0 ≤ N ≤ 10000.\n# Output:\n#      a string of binary number\nsolve <- function(N) {","canonical_solution":"solve <- function(N) {\n  # Sum the digits of the number\n  digit_sum <- sum(as.numeric(unlist(strsplit(as.character(N), \"\"))))\n  # Convert the sum to binary and return as a string\n  return(as.character(as.binary(digit_sum)))\n}\n\n# Helper function to convert number to binary\nas.binary <- function(number) {\n  if (number == 0) return(\"0\")\n  binary <- \"\"\n  while (number > 0) {\n    binary <- paste0(number %% 2, binary)\n    number <- number %\/% 2\n  }\n  return(binary)\n}","tests":"test_humaneval <- function() {\n    candidate <- solve\n    stopifnot(isTRUE(all.equal(candidate(1000), '1')))\n    stopifnot(isTRUE(all.equal(candidate(150), '110')))\n    stopifnot(isTRUE(all.equal(candidate(147), '1100')))\n    stopifnot(isTRUE(all.equal(candidate(333), '1001')))\n    stopifnot(isTRUE(all.equal(candidate(963), '10010')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_85","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Dado unha lista non baleira de números enteiros, primeiro engadimos os elementos pares que están en índices impares.# >>> add(c(4, 2, 6, 7))\n# 2\nadd <- function(lst) {","canonical_solution":"add <- function(lst) {\n  # Select elements at odd indices (which are even positions)\n  elements_at_odd_indices <- lst[seq(2, length(lst), by=2)]\n  # Keep only the even elements\n  even_elements <- elements_at_odd_indices[elements_at_odd_indices %% 2 == 0]\n  # Sum the even elements\n  sum(even_elements)\n}","tests":"test_humaneval <- function() {\n    candidate <- add\n    stopifnot(isTRUE(all.equal(candidate(c(4, 88)), 88)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 6, 7, 2, 122)), 122)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 0, 6, 7)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 4, 6, 8)), 12)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_86","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: Nota: Debe manter a orde das palabras e os espazos en branco na frase.Orde ascendente baseada no valor ASCII.son substituídas por unha nova palabra onde todos os caracteres dispostos en Versión ordenada de cadea, é unha cadea onde todas as palabras (separadas por espazos) Escribe unha función que toma unha cadea e devolve unha versión ordenada dela.# >>> anti_shuffle('Hi')\n# 'Hi'\n# >>> anti_shuffle('hello')\n# 'ehllo'\n# >>> anti_shuffle('Hello World!!!')\n# 'Hello !!!Wdlor'\nanti_shuffle <- function(s) {","canonical_solution":"anti_shuffle <- function(s) {\n  words <- strsplit(s, \"(\\\\s+)\", perl = TRUE)[[1]]\n  sorted_words <- sapply(words, function(word) {\n    if (word == \"\") return(word)\n    chars <- unlist(strsplit(word, split = \"\"))\n    return(paste0(sort(chars), collapse = \"\"))\n  })\n  return(paste0(sorted_words, collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- anti_shuffle\n    stopifnot(isTRUE(all.equal(candidate('Hi'), 'Hi')))\n    stopifnot(isTRUE(all.equal(candidate('hello'), 'ehllo')))\n    stopifnot(isTRUE(all.equal(candidate('number'), 'bemnru')))\n    stopifnot(isTRUE(all.equal(candidate('abcd'), 'abcd')))\n    stopifnot(isTRUE(all.equal(candidate('Hello World!!!'), 'Hello !!!Wdlor')))\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_87","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Tamén, ordenar as coordenadas da fila por columnas en orde descendente.Ordenar as coordenadas inicialmente por filas en orde ascendente.cada lista é unha coordenada - (fila, columnas), comezando por 0. e devolve lista de listas, [(x1, y1), (x2, y2) ...] tal que Dado lst, e o número enteiro x, atopa os números enteiros x na lista, cada liña pode conter un número diferente de columnas. que é semellante á matriz, con todo, a diferenza de matrices, Vostede é dado un 2 datos dimensionais, como unha lista anidada, # >>> get_row(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1)\n# list(c(0, 0), c(1, 4), c(1, 0), c(2, 5), c(2, 0))\n# >>> get_row(c(), 1)\n# c()\n# >>> get_row(list(c(), c(1), c(1, 2, 3)), 3)\n# list(c(2, 2))\nget_row <- function(lst, x) {","canonical_solution":"get_row <- function(lst, x) {\n  result <- list()\n  for (i in seq_along(lst)) {\n    row <- lst[[i]]\n    cols <- which(row == x)\n    for (col in rev(sort(cols - 1))) {\n      result <- append(result, list(c(i - 1, col)))\n    }\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- get_row\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1), list(c(0, 0), c(1, 4), c(1, 0), c(2, 5), c(2, 0)))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6)), 2), list(c(0, 1), c(1, 1), c(2, 1), c(3, 1), c(4, 1), c(5, 1)))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 1, 3, 4, 5, 6), c(1, 2, 1, 4, 5, 6), c(1, 2, 3, 1, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1), list(c(0, 0), c(1, 0), c(2, 1), c(2, 0), c(3, 2), c(3, 0), c(4, 3), c(4, 0), c(5, 4), c(5, 0), c(6, 5), c(6, 0)))))\n    stopifnot(isTRUE(all.equal(candidate(c(), 1), c())))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1)), 2), c())))\n    stopifnot(isTRUE(all.equal(candidate(list(c(), c(1), c(1, 2, 3)), 3), list(c(2, 2)))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_88","nl":"glg_Latn","pl":"r","prompt":"Exemplos: * non cambiar o vector dado. Nota: ou ordenalo en orde descendente se a suma ((primeiro valor do índice, último valor do índice) é par. ordenarás o vector en orde ascendente se a suma ((primeiro valor do índice, último valor do índice) é impar, Dado un vector de números enteiros non negativos, devolve un cor do vector dado despois da ordenación, # >>> sort_array(c())\n# c()\n# >>> sort_array(c(5))\n# c(5)\n# >>> sort_array(c(2, 4, 3, 0, 1, 5))\n# c(0, 1, 2, 3, 4, 5)\n# >>> sort_array(c(2, 4, 3, 0, 1, 5, 6))\n# c(6, 5, 4, 3, 2, 1, 0)\nsort_array <- function(array) {","canonical_solution":"sort_array <- function(array) {\n  if (length(array) <= 1) {\n    return(array)\n  }\n  \n  first_value <- array[1]\n  last_value <- array[length(array)]\n  sum_values <- first_value + last_value\n  \n  if (sum_values %% 2 == 1) {\n    return(sort(array))\n  } else {\n    return(sort(array, decreasing = TRUE))\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_array\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(5)), c(5))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5)), c(0, 1, 2, 3, 4, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5, 6)), c(6, 5, 4, 3, 2, 1, 0))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 1)), c(1, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(15, 42, 87, 32, 11, 0)), c(0, 11, 15, 32, 42, 87))))\n    stopifnot(isTRUE(all.equal(candidate(c(21, 14, 23, 11)), c(23, 21, 14, 11))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_89","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: desprazarse por dous multiplicado por dous lugares.O alfabeto debe rotarse de tal xeito que as letras devolve unha cadea cifrada co alfabeto rotado.Crea unha función de cifrado que tome unha cadea como argumento e # >>> encrypt('hi')\n# 'lm'\n# >>> encrypt('asdfghjkl')\n# 'ewhjklnop'\n# >>> encrypt('gf')\n# 'kj'\n# >>> encrypt('et')\n# 'ix'\nencrypt <- function(s) {","canonical_solution":"encrypt <- function(s) {\n  alphabet <- letters\n  shift <- 2 * 2\n  encrypted <- sapply(strsplit(s, NULL)[[1]], function(char) {\n    if (char %in% alphabet) {\n      new_index <- (match(char, alphabet) + shift - 1) %% 26 + 1\n      alphabet[new_index]\n    } else {\n      char\n    }\n  })\n  paste(encrypted, collapse = \"\")\n}","tests":"test_humaneval <- function() {\n    candidate <- encrypt\n    stopifnot(isTRUE(all.equal(candidate('hi'), 'lm')))\n    stopifnot(isTRUE(all.equal(candidate('asdfghjkl'), 'ewhjklnop')))\n    stopifnot(isTRUE(all.equal(candidate('gf'), 'kj')))\n    stopifnot(isTRUE(all.equal(candidate('et'), 'ix')))\n    stopifnot(isTRUE(all.equal(candidate('faewfawefaewg'), 'jeiajeaijeiak')))\n    stopifnot(isTRUE(all.equal(candidate('hellomyfriend'), 'lippsqcjvmirh')))\n    stopifnot(isTRUE(all.equal(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')))\n    stopifnot(isTRUE(all.equal(candidate('a'), 'e')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_90","nl":"glg_Latn","pl":"r","prompt":"Devolve NULL se non existe tal elemento. Escriba unha función next_smallest (en inglés) que devolva o segundo elemento máis pequeno da lista.Dámosche unha lista de números enteiros.# >>> next_smallest(c(1, 2, 3, 4, 5))\n# 2\n# >>> next_smallest(c(5, 1, 4, 3, 2))\n# 2\n# >>> next_smallest(c())\n# NULL\n# >>> next_smallest(c(1, 1))\n# NULL\nnext_smallest <- function(lst) {","canonical_solution":"next_smallest <- function(lst) {\n  # Sort the list and remove duplicates\n  unique_sorted_lst <- sort(unique(lst))\n  \n  # Check if list contains at least two distinct elements\n  if (length(unique_sorted_lst) < 2) {\n    return(NULL)\n  }\n  \n  # Return the second smallest element\n  return(unique_sorted_lst[2])\n}","tests":"test_humaneval <- function() {\n    candidate <- next_smallest\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 1, 4, 3, 2)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 0)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c(-35, 34, 12, -45)), -35)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_91","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: As frases están delimitadas por '.', '?' ou '!'. Un aburrimento é unha frase que comeza coa palabra \"eu\".Darásche unha serie de palabras, e a túa tarefa é contar o número.# >>> is_bored('Hello world')\n# 0\n# >>> is_bored('The sky is blue. The sun is shining. I love this weather')\n# 1\nis_bored <- function(S) {","canonical_solution":"is_bored <- function(S) {\n  # Split the string into sentences using '.', '?', and '!' as delimiters\n  sentences <- unlist(strsplit(S, split = \"[.?!]\"))\n  \n  # Trim leading and trailing whitespace from each sentence\n  sentences <- trimws(sentences)\n  \n  # Count the number of sentences that start with \"I\"\n  boredom_count <- sum(startsWith(sentences, \"I\"))\n  \n  return(boredom_count)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_bored\n    stopifnot(isTRUE(all.equal(candidate('Hello world'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('Is the sky blue?'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('I love It !'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('bIt'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('I feel good today. I will be productive. will kill It'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('You and I are going for a walk'), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_92","nl":"glg_Latn","pl":"r","prompt":"Exemplos Devolve falso en calquera outro caso.Devolve verdadeiro se un dos números é igual á suma dos outros dous, e todos os números son enteiros.Crea unha función que tome 3 números.# >>> any_int(5, 2, 7)\n# TRUE\n# >>> any_int(3, 2, 2)\n# FALSE\n# >>> any_int(3, -2, 1)\n# TRUE\n# >>> any_int(3.6, -2.2, 2)\n# FALSE\nany_int <- function(x, y, z) {","canonical_solution":"any_int <- function(x, y, z) {\n  if (is.integer(x) && is.integer(y) && is.integer(z)) {\n    return(x == y + z || y == x + z || z == x + y)\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- any_int\n    stopifnot(isTRUE(all.equal(candidate(2, 3, 1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2.5, 2, 3), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1.5, 5, 3.5), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(2, 6, 2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(4, 2, 2), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2.2, 2.2, 2.2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(-4, 6, 2), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2, 1, 1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(3, 4, 7), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(3.0, 4, 7), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_93","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Supoñamos só letras.Vocais do alfabeto inglés.A mensaxe coa letra que aparece 2 lugares antes que iso.De xeito que cambia de caso de todas as letras, substitúe todas as vogais en Escribir unha función que toma un mensaxe, e codifica en tal # >>> encode('test')\n# 'TGST'\n# >>> encode('This is a message')\n# 'tHKS KS C MGSSCGG'\nencode <- function(message) {","canonical_solution":"encode <- function(message) {\n  # Function to swap case of letters\n  swap_case <- function(char) {\n    if (grepl(\"[A-Za-z]\", char)) {\n      if (char %in% LETTERS) {\n        return(tolower(char))\n      } else {\n        return(toupper(char))\n      }\n    } else {\n      return(char)\n    }\n  }\n  \n  # Vowel replacement rules\n  vowel_replacement <- function(char) {\n    vowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n    replacements <- c(\"c\", \"g\", \"k\", \"q\", \"w\", \"C\", \"G\", \"K\", \"Q\", \"W\")\n    if (char %in% vowels) {\n      index <- match(char, vowels)\n      return(replacements[index])\n    } else {\n      return(char)\n    }\n  }\n  \n  # Splitting the message into its characters\n  message_chars <- strsplit(message, \"\")[[1]]\n  \n  # Apply swap case and vowel replacement\n  encoded_chars <- sapply(message_chars, function(x) vowel_replacement(swap_case(x)))\n  \n  # Combine the characters back into a single string\n  return(paste(encoded_chars, collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- encode\n    stopifnot(isTRUE(all.equal(candidate('TEST'), 'tgst')))\n    stopifnot(isTRUE(all.equal(candidate('Mudasir'), 'mWDCSKR')))\n    stopifnot(isTRUE(all.equal(candidate('YES'), 'ygs')))\n    stopifnot(isTRUE(all.equal(candidate('This is a message'), 'tHKS KS C MGSSCGG')))\n    stopifnot(isTRUE(all.equal(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_94","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Necesitas atopar o maior valor primo e devolver a suma dos seus díxitos.Dámosche unha lista de números enteiros.# >>> skjkasdkd(c(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3))\n# 10\n# >>> skjkasdkd(c(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1))\n# 25\n# >>> skjkasdkd(c(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3))\n# 13\n# >>> skjkasdkd(c(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6))\n# 11\n# >>> skjkasdkd(c(0, 81, 12, 3, 1, 21))\n# 3\n# >>> skjkasdkd(c(0, 8, 1, 2, 1, 7))\n# 7\nskjkasdkd <- function(lst) {","canonical_solution":"skjkasdkd <- function(lst) {\n  is_prime <- function(n) {\n    if (n <= 1) return(FALSE)\n    if (n == 2) return(TRUE)\n    if (n %% 2 == 0) return(FALSE)\n    for (i in 3:sqrt(n)) {\n      if (n %% i == 0) return(FALSE)\n    }\n    return(TRUE)\n  }\n  \n  prime_values <- lst[sapply(lst, is_prime)]\n  if (length(prime_values) == 0) return(0)\n  \n  largest_prime <- max(prime_values)\n  \n  sum_of_digits <- function(n) {\n    sum(as.numeric(unlist(strsplit(as.character(n), \"\"))))\n  }\n  \n  return(sum_of_digits(largest_prime))\n}","tests":"test_humaneval <- function() {\n    candidate <- skjkasdkd\n    stopifnot(isTRUE(all.equal(candidate(c(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3)), 10)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1)), 25)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3)), 13)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6)), 11)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 81, 12, 3, 1, 21)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 8, 1, 2, 1, 7)), 7)))\n    stopifnot(isTRUE(all.equal(candidate(c(8191)), 19)))\n    stopifnot(isTRUE(all.equal(candidate(c(8191, 123456, 127, 7)), 19)))\n    stopifnot(isTRUE(all.equal(candidate(c(127, 97, 8192)), 10)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_95","nl":"glg_Latn","pl":"r","prompt":"Exemplos: A función debería devolver FALSE se a lista de nomes dada está baleira. case ou todas as teclas son cadeas en maiúsculas, se non devolve FALSE. Dada unha lista nomeada, devolve TRUE se todas as teclas son cadeas en menor # >>> check_dict_case(list('a' = 'apple', 'b' = 'banana'))\n# TRUE\n# >>> check_dict_case(list('a' = 'apple', 'A' = 'banana', 'B' = 'banana'))\n# FALSE\n# >>> check_dict_case(list('a' = 'apple', 8 = 'banana', 'a' = 'apple'))\n# FALSE\n# >>> check_dict_case(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston'))\n# FALSE\n# >>> check_dict_case(list('STATE' = 'NC', 'ZIP' = '12345'))\n# TRUE\ncheck_dict_case <- function(dict) {","canonical_solution":"check_dict_case <- function(dict) {\n  if (length(dict) == 0) return(FALSE)\n  \n  keys <- names(dict)\n  \n  all_lower <- all(keys == tolower(keys))\n  all_upper <- all(keys == toupper(keys))\n  \n  return(all_lower || all_upper)\n}","tests":"test_humaneval <- function() {\n    candidate <- check_dict_case\n    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'b' = 'banana')), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'A' = 'banana', 'B' = 'banana')), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', '5' = 'banana', 'a' = 'apple')), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston')), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(list('STATE' = 'NC', 'ZIP' = '12345')), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(list('fruit' = 'Orange', 'taste' = 'Sweet')), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(list()), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_96","nl":"glg_Latn","pl":"r","prompt":"por exemplo: Os números enteiros que son números primos e menores que n.Implementar unha función que toma un enteiro non negativo e devolve un vector do primeiro n # >>> count_up_to(5)\n# c(2, 3)\n# >>> count_up_to(11)\n# c(2, 3, 5, 7)\n# >>> count_up_to(0)\n# c()\n# >>> count_up_to(20)\n# c(2, 3, 5, 7, 11, 13, 17, 19)\n# >>> count_up_to(1)\n# c()\n# >>> count_up_to(18)\n# c(2, 3, 5, 7, 11, 13, 17)\ncount_up_to <- function(n) {","canonical_solution":"count_up_to <- function(n) {\n  is_prime <- function(num) {\n    if (num <= 1) return(FALSE)\n    if (num == 2) return(TRUE)\n    if (num %% 2 == 0) return(FALSE)\n    for (i in 3:sqrt(num)) {\n      if (num %% i == 0) return(FALSE)\n    }\n    return(TRUE)\n  }\n  \n  primes_below_n <- c()\n  for (i in 2:(n-1)) {\n    if (is_prime(i)) {\n      primes_below_n <- c(primes_below_n, i)\n    }\n  }\n  \n  return(primes_below_n)\n}","tests":"test_humaneval <- function() {\n    candidate <- count_up_to\n    stopifnot(isTRUE(all.equal(candidate(5), c(2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(6), c(2, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(7), c(2, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(10), c(2, 3, 5, 7))))\n    stopifnot(isTRUE(all.equal(candidate(0), c())))\n    stopifnot(isTRUE(all.equal(candidate(22), c(2, 3, 5, 7, 11, 13, 17, 19))))\n    stopifnot(isTRUE(all.equal(candidate(1), c())))\n    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 5, 7, 11, 13, 17))))\n    stopifnot(isTRUE(all.equal(candidate(47), c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43))))\n    stopifnot(isTRUE(all.equal(candidate(101), c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_97","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Supoñamos que a entrada é sempre válida.o produto dos seus díxitos unitarios. Completa a función que toma dous enteros e devolve # >>> multiply(148, 412)\n# 16\n# >>> multiply(19, 28)\n# 72\n# >>> multiply(2020, 1851)\n# 0\n# >>> multiply(14, -15)\n# 20\nmultiply <- function(a, b) {","canonical_solution":"multiply <- function(a, b) {\n  unit_digit_a <- abs(a) %% 10\n  unit_digit_b <- abs(b) %% 10\n  return(unit_digit_a * unit_digit_b)\n}","tests":"test_humaneval <- function() {\n    candidate <- multiply\n    stopifnot(isTRUE(all.equal(candidate(148, 412), 16)))\n    stopifnot(isTRUE(all.equal(candidate(19, 28), 72)))\n    stopifnot(isTRUE(all.equal(candidate(2020, 1851), 0)))\n    stopifnot(isTRUE(all.equal(candidate(14, -15), 20)))\n    stopifnot(isTRUE(all.equal(candidate(76, 67), 42)))\n    stopifnot(isTRUE(all.equal(candidate(17, 27), 49)))\n    stopifnot(isTRUE(all.equal(candidate(0, 1), 0)))\n    stopifnot(isTRUE(all.equal(candidate(0, 0), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_98","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: Dado unha cadea s, conta o número de vogais maiúsculas en índices pares.# >>> count_upper('aBCdEf')\n# 1\n# >>> count_upper('abcdefg')\n# 0\n# >>> count_upper('dBBE')\n# 0\ncount_upper <- function(s) {","canonical_solution":"count_upper <- function(s) {\n  # Define uppercase vowels\n  uppercase_vowels <- c('A', 'E', 'I', 'O', 'U')\n  \n  # Initialize counter\n  count <- 0\n  \n  # Iterate over string indices\n  for (i in seq(1, nchar(s), by=2)) {\n    # Check if character at even index is an uppercase vowel\n    if (substr(s, i, i) %in% uppercase_vowels) {\n      count <- count + 1\n    }\n  }\n  \n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- count_upper\n    stopifnot(isTRUE(all.equal(candidate('aBCdEf'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('abcdefg'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('dBBE'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('B'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('U'), 1)))\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n    stopifnot(isTRUE(all.equal(candidate('EEEE'), 2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_99","nl":"glg_Latn","pl":"r","prompt":"Exemplos de dous números enteiros, redondealo lonxe de cero.e devolve o número enteiro máis próximo a el.Crear unha función que tome un valor (cadena) que represente un número # >>> closest_integer('10')\n# 10\n# >>> closest_integer('15.3')\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\nclosest_integer <- function(value) {","canonical_solution":"closest_integer <- function(value) {\n  num <- as.numeric(value)\n  if (num %% 1 == 0.5 || num %% 1 == -0.5) {\n    return(ifelse(num > 0, ceiling(num), floor(num)))\n  } else {\n    return(round(num))\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- closest_integer\n    stopifnot(isTRUE(all.equal(candidate('10'), 10)))\n    stopifnot(isTRUE(all.equal(candidate('14.5'), 15)))\n    stopifnot(isTRUE(all.equal(candidate('-15.5'), -16)))\n    stopifnot(isTRUE(all.equal(candidate('15.3'), 15)))\n    stopifnot(isTRUE(all.equal(candidate('0'), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_100","nl":"glg_Latn","pl":"r","prompt":"Exemplos: i representa o número de pedras no nivel (i+1). Devolve o número de pedras en cada nivel dunha lista, onde o elemento en índice - o seguinte número par se n é par. - o seguinte número impar se n é impar. O número de pedras no seguinte nivel é:O primeiro nivel ten n pedras.Dado un número enteiro positivo n, tes que facer unha pila de n niveis de pedras.# >>> make_a_pile(3)\n# c(3, 5, 7)\nmake_a_pile <- function(n) {","canonical_solution":"make_a_pile <- function(n) {\n  stones <- numeric(n)\n  stones[1] <- n\n  for (i in 2:n) {\n    if (n %% 2 == 0) {\n      stones[i] <- stones[i - 1] + 2\n    } else {\n      stones[i] <- stones[i - 1] + 2\n    }\n  }\n  return(stones)\n}","tests":"test_humaneval <- function() {\n    candidate <- make_a_pile\n    stopifnot(isTRUE(all.equal(candidate(3), c(3, 5, 7))))\n    stopifnot(isTRUE(all.equal(candidate(4), c(4, 6, 8, 10))))\n    stopifnot(isTRUE(all.equal(candidate(5), c(5, 7, 9, 11, 13))))\n    stopifnot(isTRUE(all.equal(candidate(6), c(6, 8, 10, 12, 14, 16))))\n    stopifnot(isTRUE(all.equal(candidate(8), c(8, 10, 12, 14, 16, 18, 20, 22))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_101","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: para dividir a cadea en palabras e devolver un vector das palabras.Terás unha serie de palabras separadas por comas ou espazos.# >>> words_string('Hi, my name is John')\n# c('Hi', 'my', 'name', 'is', 'John')\n# >>> words_string('One, two, three, four, five, six')\n# c('One', 'two', 'three', 'four', 'five', 'six')\nwords_string <- function(s) {","canonical_solution":"words_string <- function(s) {\n  s <- gsub(\",\", \" \", s)\n  words <- unlist(strsplit(s, \"\\\\s+\"))\n  words <- words[words != \"\"]\n  return(words)\n}","tests":"test_humaneval <- function() {\n    candidate <- words_string\n    stopifnot(isTRUE(all.equal(candidate('Hi, my name is John'), c('Hi', 'my', 'name', 'is', 'John'))))\n    stopifnot(isTRUE(all.equal(candidate('One, two, three, four, five, six'), c('One', 'two', 'three', 'four', 'five', 'six'))))\n    stopifnot(isTRUE(all.equal(candidate('Hi, my name'), c('Hi', 'my', 'name'))))\n    stopifnot(isTRUE(all.equal(candidate('One,, two, three, four, five, six,'), c('One', 'two', 'three', 'four', 'five', 'six'))))\n    stopifnot(isTRUE(all.equal(candidate(''), c())))\n    stopifnot(isTRUE(all.equal(candidate('ahmed     , gamal'), c('ahmed', 'gamal'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_102","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: non hai tal número, entón a función debería devolver -1.O maior número par que está no rango [x, y] inclusive.Esta función toma dous números positivos x e y e devolve o # >>> choose_num(12, 15)\n# 14\n# >>> choose_num(13, 12)\n# -1\nchoose_num <- function(x, y) {","canonical_solution":"choose_num <- function(x, y) {\n  if (x > y) {\n    return(-1)\n  }\n  \n  for (num in seq(y, x, by = -1)) {\n    if (num %% 2 == 0) {\n      return(num)\n    }\n  }\n  \n  return(-1)\n}","tests":"test_humaneval <- function() {\n    candidate <- choose_num\n    stopifnot(isTRUE(all.equal(candidate(12, 15), 14)))\n    stopifnot(isTRUE(all.equal(candidate(13, 12), -1)))\n    stopifnot(isTRUE(all.equal(candidate(33, 12354), 12354)))\n    stopifnot(isTRUE(all.equal(candidate(5234, 5233), -1)))\n    stopifnot(isTRUE(all.equal(candidate(6, 29), 28)))\n    stopifnot(isTRUE(all.equal(candidate(27, 10), -1)))\n    stopifnot(isTRUE(all.equal(candidate(7, 7), -1)))\n    stopifnot(isTRUE(all.equal(candidate(546, 546), 546)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_103","nl":"glg_Latn","pl":"r","prompt":"Exemplo: Se n é maior que m, devolve -1.Redondea a resposta ao número enteiro máis próximo e convertela a binaria.media dos números enteiros de n a m (incluíndo n e m).Dámosche dous números enteiros positivos n e m, e a túa tarefa é calcular o # >>> rounded_avg(1, 5)\n# '0b11'\n# >>> rounded_avg(7, 5)\n# -1\n# >>> rounded_avg(10, 20)\n# '0b1111'\n# >>> rounded_avg(20, 33)\n# '0b11010'\nrounded_avg <- function(n, m) {","canonical_solution":"rounded_avg <- function(n, m) {\n  if (n > m) {\n    return(-1)\n  }\n  avg <- mean(n:m)\n  rounded_avg <- round(avg)\n  binary_avg <- as.character(as.binary(rounded_avg))\n  return(paste0(\"0b\", binary_avg))\n}\n\nas.binary <- function(num) {\n  if (num == 0) {\n    return(\"0\")\n  }\n  binary <- \"\"\n  while (num > 0) {\n    binary <- paste0(num %% 2, binary)\n    num <- num %\/% 2\n  }\n  return(binary)\n}","tests":"test_humaneval <- function() {\n    candidate <- rounded_avg\n    stopifnot(isTRUE(all.equal(candidate(1, 5), '0b11')))\n    stopifnot(isTRUE(all.equal(candidate(7, 13), '0b1010')))\n    stopifnot(isTRUE(all.equal(candidate(964, 977), '0b1111001010')))\n    stopifnot(isTRUE(all.equal(candidate(996, 997), '0b1111100100')))\n    stopifnot(isTRUE(all.equal(candidate(560, 851), '0b1011000010')))\n    stopifnot(isTRUE(all.equal(candidate(185, 546), '0b101101110')))\n    stopifnot(isTRUE(all.equal(candidate(362, 496), '0b110101101')))\n    stopifnot(isTRUE(all.equal(candidate(350, 902), '0b1001110010')))\n    stopifnot(isTRUE(all.equal(candidate(197, 233), '0b11010111')))\n    stopifnot(isTRUE(all.equal(candidate(7, 5), -1)))\n    stopifnot(isTRUE(all.equal(candidate(5, 1), -1)))\n    stopifnot(isTRUE(all.equal(candidate(5, 5), '0b101')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_104","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: Nota: A lista devolta debe ordenarse en orde crecente.elementos que non teñen ningún díxito par.Dado unha lista de números enteiros positivos x. devolve unha lista ordenada de todos os números enteiros positivos x.# >>> unique_digits(c(15, 33, 1422, 1))\n# c(1, 15, 33)\n# >>> unique_digits(c(152, 323, 1422, 10))\n# c()\nunique_digits <- function(x) {","canonical_solution":"unique_digits <- function(x) {\n  has_no_even_digit <- function(num) {\n    digits <- as.numeric(strsplit(as.character(num), \"\")[[1]])\n    return(all(digits %% 2 != 0))\n  }\n  \n  result <- Filter(has_no_even_digit, x)\n  return(sort(result))\n}","tests":"test_humaneval <- function() {\n    candidate <- unique_digits\n    stopifnot(isTRUE(all.equal(candidate(c(15, 33, 1422, 1)), c(1, 15, 33))))\n    stopifnot(isTRUE(all.equal(candidate(c(152, 323, 1422, 10)), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(12345, 2033, 111, 151)), c(111, 151))))\n    stopifnot(isTRUE(all.equal(candidate(c(135, 103, 31)), c(31, 135))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_105","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: \"Unha\", \"Dos\", \"Tres\", \"Catro\", \"Cinco\", \"Seis\", \"Sete\", \"Oito\", \"Nove\".inverter o vector resultante e substituír cada díxito polo seu nome correspondente de Dado un vector de enteiros, ordena os enteiros que están entre 1 e 9 inclusive, # >>> by_length(c(2, 1, 1, 4, 5, 8, 2, 3))\n# c('Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One')\n#   If the vector is empty, return an empty vector:\n# >>> by_length(c())\n# c()\n#   If the vector has any strange number ignore it:\n# >>> by_length(c(1, -1, 55))\n# c('One')\nby_length <- function(arr) {","canonical_solution":"by_length <- function(arr) {\n  # Filter numbers between 1 and 9\n  valid_nums <- arr[arr >= 1 & arr <= 9]\n  # Sort the numbers\n  sorted_nums <- sort(valid_nums, decreasing = TRUE)\n  # Map numbers to their names\n  num_to_name <- c(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n  result <- num_to_name[sorted_nums]\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- by_length\n    stopifnot(isTRUE(all.equal(candidate(c(2, 1, 1, 4, 5, 8, 2, 3)), c('Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 55)), c('One'))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 3, 2)), c('Three', 'Two', 'One'))))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 4, 8)), c('Nine', 'Eight', 'Four'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_106","nl":"glg_Latn","pl":"r","prompt":"Exemplo: O factorial de i é a multiplicación dos números de 1 a i (1 * 2 * ... * i).i comeza a partir de 1. ou a suma dos números de 1 a i. e devolve unha lista de tamaño n, tal que o valor do elemento no índice i é o factorial de i se i é par Implementar a función f que toma n como parámetro, # >>> f(5)\n# c(1, 2, 6, 24, 15)\nf <- function(n) {","canonical_solution":"f <- function(n) {\n  result <- numeric(n)  # Initialize a numeric vector of length n\n  for (i in 1:n) {\n    if (i %% 2 == 0) {  # Check if i is even\n      result[i] <- factorial(i)\n    } else {\n      result[i] <- sum(1:i)\n    }\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- f\n    stopifnot(isTRUE(all.equal(candidate(5), c(1, 2, 6, 24, 15))))\n    stopifnot(isTRUE(all.equal(candidate(7), c(1, 2, 6, 24, 15, 720, 28))))\n    stopifnot(isTRUE(all.equal(candidate(1), c(1))))\n    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2, 6))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_107","nl":"glg_Latn","pl":"r","prompt":"Exemplo 1: palindromos enteiros que caen dentro do rango ((1, n), inclusive. Dado un número enteiro positivo n, devolve unha lista que ten o número de pares e impares # >>> even_odd_palindrome(3)\n# c(1, 2)\n#     Explanation:\n#     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# >>> even_odd_palindrome(12)\n# c(4, 6)\n#     Explanation:\n#     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n#     1. 1 <= n <= 10^3\n#     2. returned list has the number of even and odd integer palindromes respectively.\neven_odd_palindrome <- function(n) {","canonical_solution":"even_odd_palindrome <- function(n) {\n  is_palindrome <- function(x) {\n    str_x <- as.character(x)\n    return(str_x == paste(rev(unlist(strsplit(str_x, \"\"))), collapse = \"\"))\n  }\n  \n  even_count <- 0\n  odd_count <- 0\n  \n  for (i in 1:n) {\n    if (is_palindrome(i)) {\n      if (i %% 2 == 0) {\n        even_count <- even_count + 1\n      } else {\n        odd_count <- odd_count + 1\n      }\n    }\n  }\n  \n  return(c(even_count, odd_count))\n}","tests":"test_humaneval <- function() {\n    candidate <- even_odd_palindrome\n    stopifnot(isTRUE(all.equal(candidate(123), c(8, 13))))\n    stopifnot(isTRUE(all.equal(candidate(12), c(4, 6))))\n    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2))))\n    stopifnot(isTRUE(all.equal(candidate(63), c(6, 8))))\n    stopifnot(isTRUE(all.equal(candidate(25), c(5, 6))))\n    stopifnot(isTRUE(all.equal(candidate(19), c(4, 6))))\n    stopifnot(isTRUE(all.equal(candidate(9), c(4, 5))))\n    stopifnot(isTRUE(all.equal(candidate(1), c(0, 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_108","nl":"glg_Latn","pl":"r","prompt":"Por exemplo, -123 ten os díxitos -1, 2 e 3.Se un número é negativo, entón o seu primeiro díxito asinado será negativo: o número de elementos cuxa suma de díxitos sexa > 0. Escribe unha función count_nums que toma un vector de enteiros e devolve # >>> count_nums(c())\n# 0\n# >>> count_nums(c(-1, 11, -11))\n# 1\n# >>> count_nums(c(1, 1, 2))\n# 3\ncount_nums <- function(arr) {","canonical_solution":"count_nums <- function(arr) {\n  # Helper function to calculate sum of digits\n  sum_of_digits <- function(num) {\n    digits <- as.numeric(unlist(strsplit(as.character(num), \"\")))\n    return(sum(digits, na.rm = TRUE))\n  }\n  \n  # Apply the sum_of_digits function and count numbers with sum > 0\n  return(sum(sapply(arr, sum_of_digits) > 0))\n}","tests":"test_humaneval <- function() {\n    candidate <- count_nums\n    stopifnot(isTRUE(all.equal(candidate(c()), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 2, -2, 3, 4, 5)), 6)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 9, -6, 0, 1, 5)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 100, 98, -7, 1, -1)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(12, 23, 34, -45, -56, 0)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_109","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: Nota: A lista indicada ten garantía de ter elementos únicos.Se o vector dado é baleiro, devolve TRUE. Entón devolve TRUE ou devolve FALSE. Se é posible obter o vector ordenado realizando a operación anterior a posición inicial no vector, é dicir, o índice 0.O último elemento do vector moverase a Unha operación de desprazamento á dereita significa desprazar todos os elementos do vector por un.Está permitido realizar a operación de cambio de posición á dereita calquera número de veces.a seguinte operación sobre o vector dado: é posible obter un vector ordenado en orde non decrecente realizando Os números no vector serán ordenados aleatoriamente.Temos un vector 'arr' de N enteiros arr[1], arr[2], ..., arr[N].# >>> move_one_ball(c(3, 4, 5, 1, 2))\n# TRUE\n# Explanation: By performin 2 right shift operations, non-decreasing order can\n#              be achieved for the given vector.\n# >>> move_one_ball(c(3, 5, 4, 1, 2))\n# FALSE\n# Explanation:It is not possible to get non-decreasing order for the given\n#             vector by performing any number of right shift operations.\nmove_one_ball <- function(arr) {","canonical_solution":"move_one_ball <- function(arr) {\n  if (length(arr) == 0) {\n    return(TRUE)\n  }\n  \n  n <- length(arr)\n  for (i in 1:n) {\n    shifted_arr <- c(tail(arr, n - i), head(arr, i))\n    if (all(diff(shifted_arr) >= 0)) {\n      return(TRUE)\n    }\n  }\n  \n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- move_one_ball\n    stopifnot(isTRUE(all.equal(candidate(c(3, 4, 5, 1, 2)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 10, 1, 2)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 1, 2)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 4, 1, 2)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_110","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: Se non, devolve \"NO\".Todos os elementos de lst1 para ser par, devolve \"SI\".Se é posible intercambiar elementos entre lst1 e lst2 para facer Non hai límite no número de elementos intercambiados entre lst1 e lst2. entre eles para facer lst1 unha lista de só números pares.e determina se é posible realizar un intercambio de elementos Neste problema, implementarás unha función que leva dúas listas de números, # >>> exchange(c(1, 2, 3, 4), c(1, 2, 3, 4))\n# 'YES'\n# >>> exchange(c(1, 2, 3, 4), c(1, 5, 3, 4))\n# 'NO'\n# It is assumed that the input lists will be non-empty.\nexchange <- function(lst1, lst2) {","canonical_solution":"exchange <- function(lst1, lst2) {\n  # Identify even and odd numbers in lst1\n  lst1_even <- lst1[lst1 %% 2 == 0]\n  lst1_odd <- lst1[lst1 %% 2 != 0]\n  \n  # Identify even numbers in lst2\n  lst2_even <- lst2[lst2 %% 2 == 0]\n  \n  # Check if the number of odd elements in lst1 can be replaced with even elements from lst2\n  if (length(lst1_odd) <= length(lst2_even)) {\n    return(\"YES\")\n  } else {\n    return(\"NO\")\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- exchange\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 2, 3, 4)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 5, 3, 4)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(2, 1, 4, 3)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 4)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 3)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 6, 1, 8, 9), c(3, 5, 5, 1, 1, 1)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(100, 200), c(200, 200)), 'YES')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_111","nl":"glg_Latn","pl":"r","prompt":"Exemplo: Se varias letras teñen a mesma ocorrencia, devolvelas todas.A letra que máis se repite e que contén o número correspondente.Dada unha cadea que representa letras minúsculas separadas por espazos, devolve unha lista nomeada.# >>> histogram('a b c')\n# list('a' = 1, 'b' = 1, 'c' = 1)\n# >>> histogram('a b b a')\n# list('a' = 2, 'b' = 2)\n# >>> histogram('a b c a b')\n# list('a' = 2, 'b' = 2)\n# >>> histogram('b b b b a')\n# list('b' = 4)\n# >>> histogram('')\n# list()\nhistogram <- function(test) {","canonical_solution":"histogram <- function(test) {\n  # Split the string into individual letters.\n  letters <- unlist(strsplit(test, \" \"))\n  \n  # Create a table to count the occurrences of each letter.\n  count_table <- table(letters)\n  \n  # Find the maximum frequency of occurrences.\n  max_count <- max(count_table, na.rm = TRUE)\n  \n  # Find all letters that have the maximum frequency.\n  max_letters <- names(count_table[count_table == max_count])\n  \n  # Create a named list with letters as names and their max occurrences as values.\n  result <- setNames(as.list(rep(max_count, length(max_letters))), max_letters)\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- histogram\n    stopifnot(isTRUE(all.equal(candidate('a b b a'), list('a' = 2, 'b' = 2))))\n    stopifnot(isTRUE(all.equal(candidate('a b c a b'), list('a' = 2, 'b' = 2))))\n    stopifnot(isTRUE(all.equal(candidate('a b c d g'), list('a' = 1, 'b' = 1, 'c' = 1, 'd' = 1, 'g' = 1))))\n    stopifnot(isTRUE(all.equal(candidate('r t g'), list('r' = 1, 't' = 1, 'g' = 1))))\n    stopifnot(isTRUE(all.equal(candidate('b b b b a'), list('b' = 4))))\n    stopifnot(isTRUE(all.equal(candidate('r t g'), list('r' = 1, 't' = 1, 'g' = 1))))\n    stopifnot(isTRUE(all.equal(candidate(''), list())))\n    stopifnot(isTRUE(all.equal(candidate('a'), list('a' = 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_112","nl":"glg_Latn","pl":"r","prompt":"Exemplo Debe devolver unha lista que conteña a cadea de resultados e TRUE\/FALSE para a comprobación.Unha cadea é chamada palíndromo se se le o mesmo cara atrás como cara adiante.A continuación, comprobar se a cadea de resultados é palíndromo.Temos dúas cadeas de caracteres s e c, temos que eliminar todos os caracteres en s que son iguais a calquera carácter en c Tarefa # >>> reverse_delete('abcde', 'ae')\n# list('bcd', FALSE)\n# >>> reverse_delete('abcdef', 'b')\n# list('acdef', FALSE)\n# >>> reverse_delete('abcdedcba', 'ab')\n# list('cdedc', TRUE)\nreverse_delete <- function(s, c) {","canonical_solution":"reverse_delete <- function(s, c) {\n  # Remove characters in 'c' from 's'\n  for (char in strsplit(c, '')[[1]]) {\n    s <- gsub(char, \"\", s)\n  }\n  \n  # Check if the resultant string is a palindrome\n  is_palindrome <- s == paste(rev(strsplit(s, NULL)[[1]]), collapse = \"\")\n  \n  # Return the resultant string and the palindrome check result\n  return(list(s, is_palindrome))\n}","tests":"test_humaneval <- function() {\n    candidate <- reverse_delete\n    stopifnot(isTRUE(all.equal(candidate('abcde', 'ae'), list('bcd', FALSE))))\n    stopifnot(isTRUE(all.equal(candidate('abcdef', 'b'), list('acdef', FALSE))))\n    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'ab'), list('cdedc', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('dwik', 'w'), list('dik', FALSE))))\n    stopifnot(isTRUE(all.equal(candidate('a', 'a'), list('', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('abcdedcba', ''), list('abcdedcba', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'v'), list('abcdedcba', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('vabba', 'v'), list('abba', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('mamma', 'mia'), list('', TRUE))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_113","nl":"glg_Latn","pl":"r","prompt":"de díxitos impares na cadea i'th da entrada. string i da entrada. \" onde todas as i deben ser substituídas polo número Cada elemento i da saída debe ser o número de elementos impares na serie.Dado unha lista de cadeas, onde cada cadea consiste só en díxitos, devolve unha lista.# >>> odd_count(c('1234567'))\n# c('the number of odd elements 4n the str4ng 4 of the 4nput.')\n# >>> odd_count(c('3', '11111111'))\n# c('the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.')\nodd_count <- function(lst) {","canonical_solution":"odd_count <- function(lst) {\n  sapply(lst, function(x) {\n    odd_digits <- sum(as.numeric(unlist(strsplit(x, \"\"))) %% 2 == 1)\n    sprintf(\"the number of odd elements %dn the str%2$sing %1$d of the %3$nput.\", odd_digits, odd_digits, odd_digits)\n  })\n}\n\n# Example usage\nprint(odd_count(c('1234567')))\nprint(odd_count(c('3', '11111111')))","tests":"test_humaneval <- function() {\n    candidate <- odd_count\n    stopifnot(isTRUE(all.equal(candidate(c('1234567')), c('the number of odd elements 4n the str4ng 4 of the 4nput.'))))\n    stopifnot(isTRUE(all.equal(candidate(c('3', '11111111')), c('the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'))))\n    stopifnot(isTRUE(all.equal(candidate(c('271', '137', '314')), c('the number of odd elements 2n the str2ng 2 of the 2nput.', 'the number of odd elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng 2 of the 2nput.'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_114","nl":"glg_Latn","pl":"r","prompt":"Exemplo de números.Dado un vector de números enteiros n, atopa a suma mínima de calquera subvector non baleiro # >>> minSubArraySum(c(2, 3, 4, 1, 2, 4))\n# 1\n# >>> minSubArraySum(c(-1, -2, -3))\n# -6\nminSubArraySum <- function(nums) {","canonical_solution":"minSubArraySum <- function(nums) {\n  min_sum <- nums[1]\n  current_sum <- 0\n  \n  for (num in nums) {\n    if (current_sum > 0) {\n      current_sum <- 0\n    }\n    current_sum <- current_sum + num\n    if (current_sum < min_sum) {\n      min_sum <- current_sum\n    }\n  }\n  \n  return(min_sum)\n}","tests":"test_humaneval <- function() {\n    candidate <- minSubArraySum\n    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 4, 1, 2, 4)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3)), -6)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3, 2, -10)), -14)))\n    stopifnot(isTRUE(all.equal(candidate(c(-9999999999999999)), -9999999999999999)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 10, 20, 1000000)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3, 10, -5)), -6)))\n    stopifnot(isTRUE(all.equal(candidate(c(100, -1, -2, -3, 10, -5)), -6)))\n    stopifnot(isTRUE(all.equal(candidate(c(10, 11, 13, 8, 3, 4)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(100, -33, 32, -1, 0, -2)), -33)))\n    stopifnot(isTRUE(all.equal(candidate(c(-10)), -10)))\n    stopifnot(isTRUE(all.equal(candidate(c(7)), 7)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1)), -1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_115","nl":"glg_Latn","pl":"r","prompt":"Exemplo 1: Output o número de veces que precisa para baixar os cubos. A súa tarefa é usar os baldes para baleirar os pozos.e todos os cubos teñen a mesma capacidade.Cada pozo ten un balde correspondente que se pode usar para extraer auga del, e cada 1 nunha liña representa unha única unidade de auga.Cada liña representa un único pozo.# >>> max_fill(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1)\n# 6\n# Example 2:\n# >>> max_fill(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2)\n# 5\n# Example 3:\n# >>> max_fill(list(c(0, 0, 0), c(0, 0, 0)), 5)\n# 0\n# Constraints:\n#     * all wells have the same length\n#     * 1 <= grid.length <= 10^2\n#     * 1 <= grid[:,1].length <= 10^2\n#     * grid[i][j] -> 0 | 1\n#     * 1 <= capacity <= 10\nmax_fill <- function(grid, capacity) {","canonical_solution":"max_fill <- function(grid, capacity) {\n  total_water <- sum(unlist(grid))\n  num_buckets_needed <- ceiling(total_water \/ capacity)\n  return(num_buckets_needed)\n}","tests":"test_humaneval <- function() {\n    candidate <- max_fill\n    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1), 6)))\n    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2), 5)))\n    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 0), c(0, 0, 0)), 5), 0)))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 2), 4)))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 9), 2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_116","nl":"glg_Latn","pl":"r","prompt":"Debe aplicarse así: Para un número similar de uns, ordenar en base ao valor decimal.número de unidades na súa representación binaria en orde ascendente. Neste kata, tes que ordenar un vector de enteiros non negativos segundo # >>> sort_array(c(1, 5, 2, 3, 4))\n# c(1, 2, 3, 4, 5)\n# >>> sort_array(c(-2, -3, -4, -5, -6))\n# c(-6, -5, -4, -3, -2)\n# >>> sort_array(c(1, 0, 2, 3, 4))\n# c(0, 1, 2, 3, 4)\nsort_array <- function(arr) {","canonical_solution":"sort_array <- function(arr) {\n  # Filter out negative numbers and sort them directly\n  negative_numbers <- sort(arr[arr < 0])\n  \n  # Process non-negative numbers\n  non_negative_numbers <- arr[arr >= 0]\n  \n  # Sort non-negative numbers based on number of 1s in binary representation, then by decimal value\n  sorted_non_negative_numbers <- non_negative_numbers[order(sapply(non_negative_numbers, function(x) {\n    sum(as.integer(intToBits(x)))\n  }), non_negative_numbers)]\n  \n  # Combine sorted negative and non-negative numbers\n  c(negative_numbers, sorted_non_negative_numbers)\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_array\n    stopifnot(isTRUE(all.equal(candidate(c(1, 5, 2, 3, 4)), c(1, 2, 4, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(-2, -3, -4, -5, -6)), c(-4, -2, -6, -5, -3))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 2, 3, 4)), c(0, 1, 2, 4, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4)), c(2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 6, 44, 12, 32, 5)), c(32, 3, 5, 6, 12, 44))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8, 16, 32)), c(2, 4, 8, 16, 32))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8, 16, 32)), c(2, 4, 8, 16, 32))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_117","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Nota: pode asumir que a cadea de entrada contén só letras e espazos.Se a cadea s está baleira, a función devolverá unha lista baleira.n consoantes, na orde en que aparecen as palabras na cadea s.Unha función que devolve unha lista de todas as palabras da cadea s que conteñen exactamente Dada unha cadea s e un número natural n, foi encargado de implementar # >>> select_words('Mary had a little lamb', 4)\n# c('little')\n# >>> select_words('Mary had a little lamb', 3)\n# c('Mary', 'lamb')\n# >>> select_words('simple white space', 2)\n# c()\n# >>> select_words('Hello world', 4)\n# c('world')\n# >>> select_words('Uncle sam', 3)\n# c('Uncle')\nselect_words <- function(s, n) {","canonical_solution":"select_words <- function(s, n) {\n  vowels <- c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n  words <- strsplit(s, \" \")[[1]]\n  result <- sapply(words, function(word) {\n    consonants_count <- nchar(gsub(paste(vowels, collapse = \"|\"), \"\", word))\n    if (consonants_count == n) return(word)\n    else return(NULL)\n  })\n  result <- result[!sapply(result, is.null)]\n  unname(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- select_words\n    stopifnot(isTRUE(all.equal(candidate('Mary had a little lamb', 4), c('little'))))\n    stopifnot(isTRUE(all.equal(candidate('Mary had a little lamb', 3), c('Mary', 'lamb'))))\n    stopifnot(isTRUE(all.equal(candidate('simple white space', 2), c())))\n    stopifnot(isTRUE(all.equal(candidate('Hello world', 4), c('world'))))\n    stopifnot(isTRUE(all.equal(candidate('Uncle sam', 3), c('Uncle'))))\n    stopifnot(isTRUE(all.equal(candidate('', 4), c())))\n    stopifnot(isTRUE(all.equal(candidate('a b c d e f', 1), c('b', 'c', 'd', 'f'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_118","nl":"glg_Latn","pl":"r","prompt":"Exemplo: Pode asumir que a cadea de caracteres dada contén letra en inglés só.atopar calquera vocal que cumpra a condición anterior.As vogais no comezo e no final non contan.dúas consoantes do lado dereito da palabra (sensibles á maiúscula e minúscula).A túa tarefa é atopar a vocal máis próxima que se interpone entre# >>> get_closest_vowel('yogurt')\n# 'u'\n# >>> get_closest_vowel('FULL')\n# 'U'\n# >>> get_closest_vowel('quick')\n# ''\n# >>> get_closest_vowel('ab')\n# ''\nget_closest_vowel <- function(word) {","canonical_solution":"get_closest_vowel <- function(word) {\n  vowels <- c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n  n <- nchar(word)\n  \n  # Iterate from the second to last position to the second position\n  for (i in (n-1):2) {\n    if (substr(word, i, i) %in% vowels) {\n      if (!substr(word, i-1, i-1) %in% vowels && !substr(word, i+1, i+1) %in% vowels) {\n        return(substr(word, i, i))\n      }\n    }\n  }\n  \n  # Return empty string if no vowel is found\n  return('')\n}","tests":"test_humaneval <- function() {\n    candidate <- get_closest_vowel\n    stopifnot(isTRUE(all.equal(candidate('yogurt'), 'u')))\n    stopifnot(isTRUE(all.equal(candidate('full'), 'u')))\n    stopifnot(isTRUE(all.equal(candidate('easy'), '')))\n    stopifnot(isTRUE(all.equal(candidate('eAsy'), '')))\n    stopifnot(isTRUE(all.equal(candidate('ali'), '')))\n    stopifnot(isTRUE(all.equal(candidate('bad'), 'a')))\n    stopifnot(isTRUE(all.equal(candidate('most'), 'o')))\n    stopifnot(isTRUE(all.equal(candidate('ab'), '')))\n    stopifnot(isTRUE(all.equal(candidate('ba'), '')))\n    stopifnot(isTRUE(all.equal(candidate('quick'), '')))\n    stopifnot(isTRUE(all.equal(candidate('anime'), 'i')))\n    stopifnot(isTRUE(all.equal(candidate('Asia'), '')))\n    stopifnot(isTRUE(all.equal(candidate('Above'), 'o')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_119","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Devolve \"Si\" se hai unha forma de facer unha boa cadea, e devolve \"Non\" doutra forma.\" (()) \" non é.Por exemplo: a cadea '(()))) é boa, mentres que a cadea Unha cadea S considérase boa se e só se todos os parénteses en S algunha orde, que a cadea resultante será boa.O teu traballo é comprobar se é posible concatenar as dúas cordas.só entre paréntesis \" ((\") ou entre paréntesis \") \".Vostede recibe unha lista de dúas cadeas, ambas cadeas consisten en aberto # >>> match_parens(c('()(', ')'))\n# 'Yes'\n# >>> match_parens(c(')', ')'))\n# 'No'\nmatch_parens <- function(lst) {","canonical_solution":"match_parens <- function(lst) {\n  is_balanced <- function(s) {\n    balance <- 0\n    for (ch in strsplit(s, \"\")[[1]]) {\n      if (ch == '(') {\n        balance <- balance + 1\n      } else {\n        balance <- balance - 1\n      }\n      if (balance < 0) return(FALSE)\n    }\n    return(balance == 0)\n  }\n  \n  s1 <- lst[1]\n  s2 <- lst[2]\n  \n  if (is_balanced(paste0(s1, s2)) || is_balanced(paste0(s2, s1))) {\n    return('Yes')\n  } else {\n    return('No')\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- match_parens\n    stopifnot(isTRUE(all.equal(candidate(c('()(', ')')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c(')', ')')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c('(()(())', '())())')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c(')())', '(()()(')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c('(())))', '(()())((')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c('()', '())')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c('(()(', '()))()')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c('((((', '((())')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c(')(()', '(()(')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c(')(', ')(')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c('(', ')')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c(')', '(')), 'Yes')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_120","nl":"glg_Latn","pl":"r","prompt":"Exemplo 1: de lonxitude k con o máximo de k números en arr. Dado un vector arr de enteiros e un enteiro positivo k, devolve unha lista ordenada # >>> maximum(c(-3, -4, 5), 3)\n# c(-4, -3, 5)\n# Example 2:\n# >>> maximum(c(4, -4, 4), 2)\n# c(4, 4)\n# Example 3:\n# >>> maximum(c(-3, 2, 1, 2, -1, -2, 1), 1)\n# c(2)\n# Note:\n#     1. The length of the vector will be in the range of [1, 1000].\n#     2. The elements in the vector will be in the range of [-1000, 1000].\n#     3. 0 <= k <= len(arr)\nmaximum <- function(arr, k) {","canonical_solution":"maximum <- function(arr, k) {\n  return(sort(tail(sort(arr), k)))\n}","tests":"test_humaneval <- function() {\n    candidate <- maximum\n    stopifnot(isTRUE(all.equal(candidate(c(-3, -4, 5), 3), c(-4, -3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, -4, 4), 2), c(4, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 2, 1, 2, -1, -2, 1), 1), c(2))))\n    stopifnot(isTRUE(all.equal(candidate(c(123, -123, 20, 0, 1, 2, -3), 3), c(2, 20, 123))))\n    stopifnot(isTRUE(all.equal(candidate(c(-123, 20, 0, 1, 2, -3), 4), c(0, 1, 2, 20))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 15, 0, 3, -13, -8, 0), 7), c(-13, -8, 0, 0, 3, 5, 15))))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 0, 2, 5, 3, -10), 2), c(3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 5, -7), 1), c(5))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, -4), 2), c(-4, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(-10, 10), 2), c(-10, 10))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, -23, 243, -400, 0), 0), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_121","nl":"glg_Latn","pl":"r","prompt":"Exemplos Dado unha lista non baleira de enteiros, devolve a suma de todos os elementos impares que están en posicións pares.# >>> solution(c(5, 8, 7, 1))\n# 12\n# >>> solution(c(3, 3, 3, 3, 3))\n# 9\n# >>> solution(c(30, 13, 24, 321))\n# 0\nsolution <- function(lst) {","canonical_solution":"solution <- function(lst) {\n  sum(lst[seq(2, length(lst), by = 2)][lst[seq(2, length(lst), by = 2)] %% 2 != 0])\n}","tests":"test_humaneval <- function() {\n    candidate <- solution\n    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 7, 1)), 12)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 3, 3, 3, 3)), 9)))\n    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 24, 321)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 9)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 23, 32)), 23)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 13, 2, 9)), 3)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_122","nl":"glg_Latn","pl":"r","prompt":"Exemplo: a suma dos elementos con, como máximo, dous díxitos dos primeiros k elementos de arr. Dado un vector non baleiro de enteiros arr e un enteiro k, devolve # >>> add_elements(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4)\n# 24\n# Constraints:\n#     1. 1 <= len(arr) <= 100\n#     2. 1 <= k <= len(arr)\nadd_elements <- function(arr, k) {","canonical_solution":"add_elements <- function(arr, k) {\n  sum(arr[1:k][nchar(abs(arr[1:k])) <= 2])\n}","tests":"test_humaneval <- function() {\n    candidate <- add_elements\n    stopifnot(isTRUE(all.equal(candidate(c(1, -2, -3, 41, 57, 76, 87, 88, 99), 3), -4)))\n    stopifnot(isTRUE(all.equal(candidate(c(111, 121, 3, 4000, 5, 6), 2), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(11, 21, 3, 90, 5, 6, 7, 8, 9), 4), 125)))\n    stopifnot(isTRUE(all.equal(candidate(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4), 24)))\n    stopifnot(isTRUE(all.equal(candidate(c(1), 1), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_123","nl":"glg_Latn","pl":"r","prompt":"get_odd_collatz(5) devolve [1, 5] # A secuencia de collatz para 5 é [5, 16, 8, 4, 2, 1], polo que os números impares son só 1, e 5. Por exemplo: 2. lista devolta ordenada en orde crecente.1. Collatz ((1) é [1]. Nota: O termo máis 1. A conxectura é que non importa que valor de n, a secuencia sempre chegará a 1.Se o anterior é impar, o seguinte é 3 veces o anterior.Termo anterior do seguinte xeito: se o termo anterior é par, o seguinte termo é a metade de como segue: comeza con calquera número enteiro positivo n. A continuación, cada termo é obtido a partir do A conxectura de Collatz é unha conxectura matemática que se refire a unha secuencia definida.Dado un número enteiro positivo n, devolve unha lista ordenada que ten os números impares na secuencia de collatz. # >>> get_odd_collatz(5)\n# c(1, 5)\nget_odd_collatz <- function(n) {","canonical_solution":"get_odd_collatz <- function(n) {\n  collatz_sequence <- function(n) {\n    sequence <- c(n)\n    while (n != 1) {\n      if (n %% 2 == 0) {\n        n <- n \/ 2\n      } else {\n        n <- 3 * n + 1\n      }\n      sequence <- c(sequence, n)\n    }\n    return(sequence)\n  }\n  \n  sequence <- collatz_sequence(n)\n  odd_numbers <- unique(sequence[sequence %% 2 != 0])\n  return(sort(odd_numbers))\n}","tests":"test_humaneval <- function() {\n    candidate <- get_odd_collatz\n    stopifnot(isTRUE(all.equal(candidate(14), c(1, 5, 7, 11, 13, 17))))\n    stopifnot(isTRUE(all.equal(candidate(5), c(1, 5))))\n    stopifnot(isTRUE(all.equal(candidate(12), c(1, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(1), c(1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_124","nl":"glg_Latn","pl":"r","prompt":"4. A data debe estar no formato: mm-dd-aaaa 3. Os meses non deben ser inferiores a 1 ou superiores a 12.2. O número de días non é inferior a 1 ou superior a 31 días para os meses 1,3,5,7,8,10,12. E o número de días non é inferior a 1 ou superior a 30 días para os meses 4,6,9,11. E, o número de días non é inferior a 1 ou superior a 29 para o mes 2.1. A cadea de datas non está baleira.A data é válida se se cumpren todas as seguintes regras: devolve TRUE se a data é válida, doutro xeito FALSE. Ten que escribir unha función que valida unha cadea de datas e # >>> valid_date('03-11-2000')\n# TRUE\n# >>> valid_date('15-01-2012')\n# FALSE\n# >>> valid_date('04-0-2040')\n# FALSE\n# >>> valid_date('06-04-2020')\n# TRUE\n# >>> valid_date('06\/04\/2020')\n# FALSE\nvalid_date <- function(date) {","canonical_solution":"valid_date <- function(date) {\n  # Check if the date is not empty\n  if (date == \"\") {\n    return(FALSE)\n  }\n  \n  # Check the format of the date\n  if (!grepl(\"^\\\\d{2}-\\\\d{2}-\\\\d{4}$\", date)) {\n    return(FALSE)\n  }\n  \n  # Extract the month, day, and year\n  parts <- unlist(strsplit(date, \"-\"))\n  month <- as.numeric(parts[1])\n  day <- as.numeric(parts[2])\n  year <- as.numeric(parts[3])\n  \n  # Check if the month is valid\n  if (month < 1 || month > 12) {\n    return(FALSE)\n  }\n  \n  # Check if the day is valid\n  if (month %in% c(1, 3, 5, 7, 8, 10, 12) && (day < 1 || day > 31)) {\n    return(FALSE)\n  }\n  \n  if (month %in% c(4, 6, 9, 11) && (day < 1 || day > 30)) {\n    return(FALSE)\n  }\n  \n  if (month == 2 && (day < 1 || day > 29)) {\n    return(FALSE)\n  }\n  \n  return(TRUE)\n}","tests":"test_humaneval <- function() {\n    candidate <- valid_date\n    stopifnot(isTRUE(all.equal(candidate('03-11-2000'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('15-01-2012'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('04-0-2040'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('06-04-2020'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('01-01-2007'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('03-32-2011'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('04-31-3000'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('06-06-2005'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('21-31-2000'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('04-12-2003'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('04122003'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('20030412'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('2003-04'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('2003-04-12'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('04-2003'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_125","nl":"glg_Latn","pl":"r","prompt":"Exemplos alfabeto, ord{\"a\") = 0, ord{\"b\") = 1, ... ord{\"z\") = 25 debe dividir en comas ',' se non existe coma debe devolver o número de letras minúsculas con orde impar na Dada unha cadea de palabras, devolve unha lista de palabras divididas en espazos en branco, se non existen espazos en branco no texto que desexa.# >>> split_words('Hello world!')\n# c('Hello', 'world!')\n# >>> split_words('Hello,world!')\n# c('Hello', 'world!')\n# >>> split_words('abcdef')\n# 3\nsplit_words <- function(txt) {","canonical_solution":"split_words <- function(txt) {\n  if (grepl(\"\\\\s\", txt)) {\n    return(strsplit(txt, \"\\\\s+\")[[1]])\n  } else if (grepl(\",\", txt)) {\n    return(strsplit(txt, \",\")[[1]])\n  } else {\n    odd_order_count <- sum(\n      sapply(unlist(strsplit(txt, \"\")), function(x) {\n        ord <- utf8ToInt(tolower(x)) - utf8ToInt(\"a\")\n        ord %% 2 == 1\n      })\n    )\n    return(odd_order_count)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- split_words\n    stopifnot(isTRUE(all.equal(candidate('Hello world!'), c('Hello', 'world!'))))\n    stopifnot(isTRUE(all.equal(candidate('Hello,world!'), c('Hello', 'world!'))))\n    stopifnot(isTRUE(all.equal(candidate('Hello world,!'), c('Hello', 'world,!'))))\n    stopifnot(isTRUE(all.equal(candidate('Hello,Hello,world !'), c('Hello,Hello,world', '!'))))\n    stopifnot(isTRUE(all.equal(candidate('abcdef'), 3)))\n    stopifnot(isTRUE(all.equal(candidate('aaabb'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('aaaBb'), 1)))\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_126","nl":"glg_Latn","pl":"r","prompt":"Exemplos número, devolve FALSE.Se a lista ten máis dun duplicado da mesma Dado unha lista de números, devolve se están ordenados ou non.# >>> is_sorted(c(5))\n# TRUE\n# >>> is_sorted(c(1, 2, 3, 4, 5))\n# TRUE\n# >>> is_sorted(c(1, 3, 2, 4, 5))\n# FALSE\n# >>> is_sorted(c(1, 2, 3, 4, 5, 6))\n# TRUE\n# >>> is_sorted(c(1, 2, 3, 4, 5, 6, 7))\n# TRUE\n# >>> is_sorted(c(1, 3, 2, 4, 5, 6, 7))\n# FALSE\n# >>> is_sorted(c(1, 2, 2, 3, 3, 4))\n# TRUE\n# >>> is_sorted(c(1, 2, 2, 2, 3, 4))\n# FALSE\nis_sorted <- function(lst) {","canonical_solution":"is_sorted <- function(lst) {\n  if (length(lst) <= 1) {\n    return(TRUE)\n  }\n  \n  # Check for duplicates more than once\n  tbl <- table(lst)\n  if (any(tbl > 2)) {\n    return(FALSE)\n  }\n  \n  # Check if the list is sorted in ascending order\n  for (i in 2:length(lst)) {\n    if (lst[i] < lst[i - 1]) {\n      return(FALSE)\n    }\n  }\n  \n  return(TRUE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_sorted\n    stopifnot(isTRUE(all.equal(candidate(c(5)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, 7)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 2, 3, 4)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 3, 3, 4)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 3, 3, 4)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_127","nl":"glg_Latn","pl":"r","prompt":"[entrada\/saída] mostras: Se os dous intervalos non se cruzan, devolve \"NO\".En caso contrario, devolva \"NO\". Se a lonxitude da intersección é un número primo, devolva \"SI\", que a súa lonxitude é 1, que non é un número primo.Exemplo, a intersección dos intervalos (1, 3), (2, 4) é (2, 3) intervalo é un número primo.A súa tarefa é determinar se a lonxitude da intersección destes dous Para cada intervalo dado, supónse que o seu inicio é menor ou igual ao seu final.incluír tanto o inicio como o final. Os intervalos dados son pechados, o que significa que o intervalo (iniciado, rematado) onde cada intervalo é un par de números enteiros. por exemplo, intervalo = (inicio, fin) = (1, 2).Ten dous intervalos.# >>> intersection(c(1, 2), c(2, 3))\n# 'NO'\n# >>> intersection(c(-1, 1), c(0, 4))\n# 'NO'\n# >>> intersection(c(-3, -1), c(-5, 5))\n# 'YES'\nintersection <- function(interval1, interval2) {","canonical_solution":"intersection <- function(interval1, interval2) {\n  start1 <- interval1[1]\n  end1 <- interval1[2]\n  start2 <- interval2[1]\n  end2 <- interval2[2]\n  \n  # Determine the start and end of the intersection\n  intersection_start <- max(start1, start2)\n  intersection_end <- min(end1, end2)\n  \n  # Calculate the length of the intersection\n  length_of_intersection <- intersection_end - intersection_start\n  \n  # If there's no intersection, return \"NO\"\n  if (length_of_intersection < 0) {\n    return('NO')\n  }\n  \n  # Check if the length is a prime number\n  is_prime <- function(num) {\n    if (num <= 1) {\n      return(FALSE)\n    }\n    for (i in 2:sqrt(num)) {\n      if (num %% i == 0) {\n        return(FALSE)\n      }\n    }\n    return(TRUE)\n  }\n  \n  # Return \"YES\" if the length is prime, otherwise \"NO\"\n  if (is_prime(length_of_intersection)) {\n    return('YES')\n  } else {\n    return('NO')\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- intersection\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(2, 3)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 1), c(0, 4)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, -1), c(-5, 5)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(-2, 2), c(-4, 0)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(-11, 2), c(-1, -1)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(3, 5)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(1, 2)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(-2, -2), c(-3, -2)), 'NO')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_128","nl":"glg_Latn","pl":"r","prompt":"Exemplo: Nota: devolve NULL para arr baleiro. de cada número no vector, representado por 1, -1 ou 0. A suma das magnitudes dos números enteiros multiplicada polo produto de todos os signos.Dámosche un vector arr de números enteiros e tes que devolver # >>> prod_signs(c(1, 2, 2, -4))\n# 9\n# >>> prod_signs(c(0, 1))\n# 0\n# >>> prod_signs(c())\n# NULL\nprod_signs <- function(arr) {","canonical_solution":"prod_signs <- function(arr) {\n  if (length(arr) == 0) {\n    return(NULL)\n  }\n  magnitude_sum <- sum(abs(arr))\n  sign_product <- prod(sign(arr))\n  return(magnitude_sum * sign_product)\n}","tests":"test_humaneval <- function() {\n    candidate <- prod_signs\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, -4)), -9)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 2, 3, -1, 1)), -10)))\n    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 2, -1, -1, 9)), 20)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, -1, 1)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, 1, 1)), -4)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, 1, 0)), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_129","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Devolve unha lista ordenada dos valores das celas que percorre o camiño mínimo.A resposta é única.lst_A[j] = lst_B[j].tal que lst_A[i] < lst_B[i] e para calquera j (1 <= j < i) temos que lst_B, noutras palabras, existe un índice inteiro i (1 <= i <= k) A través de (chamémoslles lst_A e lst_B), lst_A é lexicográficamente menos Despois de facer as listas ordenadas dos valores nas celas que A e B van Considérase menor un trazo A (de lonxitude k) que un trazo B (de lonxitude k) se Non podes desaparecer.necesariamente distintos).Teña en conta que un camiño de lonxitude k significa visitar exactamente k celas (non celular. En outras palabras, podes ir a celas que comparten unha beira coa túa corrente.de calquera cela, e en cada paso pode moverse a calquera das celas veciñas, Temos que atopar o camiño mínimo de lonxitude k na grella.incluído aparece exactamente unha vez nas celas da grella. Cada cela da grella contén un valor.Dada unha grella con N filas e N columnas (N >= 2) e un número enteiro positivo k, # >>> minPath(list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)), 3)\n# c(1, 2, 1)\n# >>> minPath(list(c(5, 9, 3), c(4, 1, 6), c(7, 8, 2)), 1)\n# c(1)\nminPath <- function(grid, k) {","canonical_solution":"minPath <- function(grid, k) {\n  N <- length(grid)\n  directions <- list(c(0, 1), c(1, 0), c(0, -1), c(-1, 0))\n  \n  is_valid <- function(x, y) {\n    return(x >= 1 && x <= N && y >= 1 && y <= N)\n  }\n  \n  # DFS to find all paths\n  dfs <- function(x, y, path) {\n    if (length(path) == k) {\n      paths <<- append(paths, list(path))\n      return()\n    }\n    \n    for (direction in directions) {\n      nx <- x + direction[1]\n      ny <- y + direction[2]\n      if (is_valid(nx, ny)) {\n        dfs(nx, ny, c(path, grid[[nx]][[ny]]))\n      }\n    }\n  }\n  \n  paths <- list()\n  \n  # Start from every cell\n  for (i in 1:N) {\n    for (j in 1:N) {\n      dfs(i, j, c(grid[[i]][[j]]))\n    }\n  }\n  \n  # Find and return the lexicographically smallest path\n  min_path <- paths[[1]]\n  for (path in paths) {\n    if (path < min_path) {\n      min_path <- path\n    }\n  }\n  \n  return(min_path)\n}","tests":"test_humaneval <- function() {\n    candidate <- minPath\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)), 3), c(1, 2, 1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(5, 9, 3), c(4, 1, 6), c(7, 8, 2)), 1), c(1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4), c(5, 6, 7, 8), c(9, 10, 11, 12), c(13, 14, 15, 16)), 4), c(1, 2, 1, 2))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(6, 4, 13, 10), c(5, 7, 12, 1), c(3, 16, 11, 15), c(8, 14, 9, 2)), 7), c(1, 10, 1, 10, 1, 10, 1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(8, 14, 9, 2), c(6, 4, 13, 15), c(5, 7, 1, 12), c(3, 10, 11, 16)), 5), c(1, 7, 1, 7, 1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(11, 8, 7, 2), c(5, 16, 14, 4), c(9, 3, 15, 6), c(12, 13, 10, 1)), 9), c(1, 6, 1, 6, 1, 6, 1, 6, 1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(12, 13, 10, 1), c(9, 3, 15, 6), c(5, 16, 14, 4), c(11, 8, 7, 2)), 12), c(1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(2, 7, 4), c(3, 1, 5), c(6, 8, 9)), 8), c(1, 3, 1, 3, 1, 3, 1, 3))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(6, 1, 5), c(3, 8, 9), c(2, 7, 4)), 8), c(1, 5, 1, 5, 1, 5, 1, 5))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2), c(3, 4)), 10), c(1, 2, 1, 2, 1, 2, 1, 2, 1, 2))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 3), c(3, 2)), 10), c(1, 3, 1, 3, 1, 3, 1, 3, 1, 3))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_130","nl":"glg_Latn","pl":"r","prompt":"Exemplos: primeiros n + 1 números da secuencia de Tribonacci.Dámoslle un número enteiro non negativo n, ten que devolver unha lista de = 2 + 3 + 3 = 8 tri(3) = tri(2) + tri(1) + tri(4) tri(4) = 3 tri(2) = 1 + (2 \/ 2) = 2 Por exemplo: tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), se n é impar. tri (n) = 1 + n \/ 2, se n é par. tri(1) = 3 A secuencia de Tribonacci defínese pola recorrencia: Con todo, o que a xente non sabe é a secuencia de Tribonacci.Todo o mundo sabe a secuencia de Fibonacci, foi estudada profundamente por matemáticos en # >>> tri(3)\n# c(1, 3, 2, 8)\ntri <- function(n) {","canonical_solution":"tri <- function(n) {\n  if (n == 0) return(c(3))\n  \n  tribonacci <- numeric(n + 1)\n  tribonacci[1] <- 3\n  \n  for (i in 2:(n + 1)) {\n    if (i %% 2 == 0) {\n      tribonacci[i] <- 1 + i \/ 2\n    } else {\n      if (i == 3) {\n        tribonacci[i] <- tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1]  # tri(3) requires tri(4)\n      } else {\n        # When i > 3 and i is odd, dependencies are always available\n        tribonacci[i] <- tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3 + 2]  # i + 1 becomes i - 3 + 2\n      }\n    }\n  }\n  \n  return(tribonacci)\n}","tests":"test_humaneval <- function() {\n    candidate <- tri\n    stopifnot(isTRUE(all.equal(candidate(3), c(1, 3, 2, 8))))\n    stopifnot(isTRUE(all.equal(candidate(4), c(1, 3, 2, 8, 3))))\n    stopifnot(isTRUE(all.equal(candidate(5), c(1, 3, 2, 8, 3, 15))))\n    stopifnot(isTRUE(all.equal(candidate(6), c(1, 3, 2, 8, 3, 15, 4))))\n    stopifnot(isTRUE(all.equal(candidate(7), c(1, 3, 2, 8, 3, 15, 4, 24))))\n    stopifnot(isTRUE(all.equal(candidate(8), c(1, 3, 2, 8, 3, 15, 4, 24, 5))))\n    stopifnot(isTRUE(all.equal(candidate(9), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35))))\n    stopifnot(isTRUE(all.equal(candidate(20), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11))))\n    stopifnot(isTRUE(all.equal(candidate(0), c(1))))\n    stopifnot(isTRUE(all.equal(candidate(1), c(1, 3))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_131","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: Devolve 0 se todos os díxitos son pares. Dado un número enteiro positivo n, devolve o produto dos díxitos impares. # >>> digits(1)\n# 1\n# >>> digits(4)\n# 0\n# >>> digits(235)\n# 15\ndigits <- function(n) {","canonical_solution":"digits <- function(n) {\n  # Convert the number to a character vector\n  digits_vector <- unlist(strsplit(as.character(n), \"\"))\n  \n  # Convert the character vector back to numeric\n  digits_vector <- as.numeric(digits_vector)\n  \n  # Filter out the odd digits\n  odd_digits <- digits_vector[digits_vector %% 2 != 0]\n  \n  # If all digits are even, return 0\n  if (length(odd_digits) == 0) {\n    return(0)\n  }\n  \n  # Calculate and return the product of odd digits\n  return(prod(odd_digits))\n}","tests":"test_humaneval <- function() {\n    candidate <- digits\n    stopifnot(isTRUE(all.equal(candidate(5), 5)))\n    stopifnot(isTRUE(all.equal(candidate(54), 5)))\n    stopifnot(isTRUE(all.equal(candidate(120), 1)))\n    stopifnot(isTRUE(all.equal(candidate(5014), 5)))\n    stopifnot(isTRUE(all.equal(candidate(98765), 315)))\n    stopifnot(isTRUE(all.equal(candidate(5576543), 2625)))\n    stopifnot(isTRUE(all.equal(candidate(2468), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_132","nl":"glg_Latn","pl":"r","prompt":"onde polo menos un corredor da subseguencia está anidado. A función debe devolver TRUE se e só se existe unha subseguencia válida de corchetes Crea unha función que toma unha cadea como entrada que contén só corchetes.# >>> is_nested('[[]]')\n# TRUE\n# >>> is_nested('[]]]]]]][[[[[]')\n# FALSE\n# >>> is_nested('[][]')\n# FALSE\n# >>> is_nested('[]')\n# FALSE\n# >>> is_nested('[[][]]')\n# TRUE\n# >>> is_nested('[[]][[')\n# TRUE\nis_nested <- function(string) {","canonical_solution":"is_nested <- function(string) {\n  open_count <- 0\n  for (char in unlist(strsplit(string, \"\"))) {\n    if (char == \"[\") {\n      open_count <- open_count + 1\n    } else if (char == \"]\") {\n      if (open_count > 1) {\n        return(TRUE)\n      }\n      open_count <- open_count - 1\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_nested\n    stopifnot(isTRUE(all.equal(candidate('[[]]'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('[]]]]]]][[[[[]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[][]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[[[[]]]]'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('[]]]]]]]]]]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[][][[]]'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('[[]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[]]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[[]][['), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('[[][]]'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[[[[[[[['), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(']]]]]]]]'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_133","nl":"glg_Latn","pl":"r","prompt":"Exemplos: arredondar cada elemento da lista ao máximo.Necesitas devolver a suma dos números ao cuadrado da lista dada, Dámosche unha lista de números.# >>> lst(c(1.0, 2.0, 3.0))\n# 14\n# >>> lst(c(1.0, 4.0, 9.0))\n# 98\n# >>> lst(c(1.0, 3.0, 5.0, 7.0))\n# 84\n# >>> lst(c(1.4, 4.2, 0.0))\n# 29\n# >>> lst(c(-2.4, 1.0, 1.0))\n# 6\nsum_squares <- function(lst) {","canonical_solution":"sum_squares <- function(lst) {\n  sum(ceiling(lst)^2)\n}","tests":"test_humaneval <- function() {\n    candidate <- sum_squares\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 3.0, 5.0, 7.0)), 84)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.4, 4.2, 0.0)), 29)))\n    stopifnot(isTRUE(all.equal(candidate(c(-2.4, 1.0, 1.0)), 6)))\n    stopifnot(isTRUE(all.equal(candidate(c(100.0, 1.0, 15.0, 2.0)), 10230)))\n    stopifnot(isTRUE(all.equal(candidate(c(10000.0, 10000.0)), 200000000)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 4.6, 6.3)), 75)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 17.9, 18.9, 19.9)), 1086)))\n    stopifnot(isTRUE(all.equal(candidate(c(0.0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.0)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.0, 1.0, 0.0)), 2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_134","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Nota: \"word\" é un grupo de caracteres separados por espazos.parte dunha palabra, e FALSO doutro xeito.dunha cadea dada é un carácter alfabético e non é Crea unha función que devolva TRUE se o último carácter # >>> check_if_last_char_is_a_letter('apple pie')\n# FALSE\n# >>> check_if_last_char_is_a_letter('apple pi e')\n# TRUE\n# >>> check_if_last_char_is_a_letter('apple pi e ')\n# FALSE\n# >>> check_if_last_char_is_a_letter('')\n# FALSE\ncheck_if_last_char_is_a_letter <- function(txt) {","canonical_solution":"check_if_last_char_is_a_letter <- function(txt) {\n  # Trim any trailing whitespace\n  trimmed_txt <- trimws(txt, which = \"right\")\n  \n  # If the trimmed text is empty, return FALSE\n  if (nchar(trimmed_txt) == 0) {\n    return(FALSE)\n  }\n  \n  # Get the last character\n  last_char <- substr(trimmed_txt, nchar(trimmed_txt), nchar(trimmed_txt))\n  \n  # Check if the last character is an alphabetical character\n  if (grepl(\"[a-zA-Z]\", last_char)) {\n    # Split the text by spaces\n    words <- strsplit(trimmed_txt, \" \")[[1]]\n    # Get the last word\n    last_word <- tail(words, n = 1)\n    # If last character is the only character in the last \"word\", return TRUE\n    # Otherwise, it is part of a word, return FALSE\n    return(nchar(last_word) == 1)\n  }\n  \n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- check_if_last_char_is_a_letter\n    stopifnot(isTRUE(all.equal(candidate('apple'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('apple pi e'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('eeeee'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('A'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie '), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie 1'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('eeeee e '), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('apple pie'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('apple pi e '), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_135","nl":"glg_Latn","pl":"r","prompt":"Exemplos: valores duplicados.se non existe tal elemento, devolve -1. O vector dado non contén non é maior ou igual ao elemento inmediatamente anterior.Crear unha función que devolva o índice máis grande dun elemento que # >>> can_arrange(c(1, 2, 4, 3, 5))\n# 3\n# >>> can_arrange(c(1, 2, 3))\n# -1\ncan_arrange <- function(arr) {","canonical_solution":"can_arrange <- function(arr) {\n  for (i in seq(length(arr) - 1, 1)) {\n    if (arr[i] > arr[i + 1]) {\n      return(i)\n    }\n  }\n  return(-1)\n}","tests":"test_humaneval <- function() {\n    candidate <- can_arrange\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 3, 5)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 5)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2, 5, 6, 7, 8, 9, 10)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 8, 5, 7, 3)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c()), -1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_136","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Se non hai números enteiros negativos ou positivos, devolve-los como NULL.de números enteiros positivos nunha lista.o maior dos enteiros negativos, e \"b\" é o menor Crea unha función que devolva unha lista (a, b), onde 'a' é # >>> largest_smallest_integers(c(2, 4, 1, 3, 5, 7))\n# list(NULL, 1)\n# >>> largest_smallest_integers(c())\n# list(NULL, NULL)\n# >>> largest_smallest_integers(c(0))\n# list(NULL, NULL)\nlargest_smallest_integers <- function(lst) {","canonical_solution":"largest_smallest_integers <- function(lst) {\n  negatives <- lst[lst < 0]\n  positives <- lst[lst > 0]\n  \n  largest_negative <- if(length(negatives) > 0) max(negatives) else NULL\n  smallest_positive <- if(length(positives) > 0) min(positives) else NULL\n  \n  list(largest_negative, smallest_positive)\n}","tests":"test_humaneval <- function() {\n    candidate <- largest_smallest_integers\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 3, 5, 7)), list(NULL, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 3, 5, 7, 0)), list(NULL, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, -2)), c(-2, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 3, 6, 2, 7, -7)), c(-7, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(7, 3, 8, 4, 9, 2, 5, -9)), c(-9, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c()), list(NULL, NULL))))\n    stopifnot(isTRUE(all.equal(candidate(c(0)), list(NULL, NULL))))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, -5, -6)), list(-1, NULL))))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, -5, -6, 0)), list(-1, NULL))))\n    stopifnot(isTRUE(all.equal(candidate(c(-6, -4, -4, -3, 1)), c(-3, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(-6, -4, -4, -3, -100, 1)), c(-3, 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_137","nl":"glg_Latn","pl":"r","prompt":"Nota: Se un número real se representa como unha cadea, o punto flotante pode ser . ou , Devolve NULL se os valores son iguais. números reais, e devolve a variable maior no seu tipo de variable.Crea unha función que tome enteiros, floats ou cadeas que representen # >>> compare_one(1, 2.5)\n# 2.5\n# >>> compare_one(1, '2,3')\n# '2,3'\n# >>> compare_one('5,1', '6')\n# '6'\n# >>> compare_one('1', 1)\n# NULL\ncompare_one <- function(a, b) {","canonical_solution":"compare_one <- function(a, b) {\n  to_number <- function(x) {\n    if (is.character(x)) {\n      x <- gsub(\",\", \".\", x)\n      as.numeric(x)\n    } else {\n      as.numeric(x)\n    }\n  }\n  \n  a_num <- to_number(a)\n  b_num <- to_number(b)\n  \n  if (a_num == b_num) {\n    return(NULL)\n  } else if (a_num > b_num) {\n    return(a)\n  } else {\n    return(b)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- compare_one\n    stopifnot(isTRUE(all.equal(candidate(1, 2), 2)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2.5), 2.5)))\n    stopifnot(isTRUE(all.equal(candidate(2, 3), 3)))\n    stopifnot(isTRUE(all.equal(candidate(5, 6), 6)))\n    stopifnot(isTRUE(all.equal(candidate(1, '2,3'), '2,3')))\n    stopifnot(isTRUE(all.equal(candidate('5,1', '6'), '6')))\n    stopifnot(isTRUE(all.equal(candidate('1', '2'), '2')))\n    stopifnot(isTRUE(all.equal(candidate('1', 1), NULL)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_138","nl":"glg_Latn","pl":"r","prompt":"Exemplo Avaliar se o número dado n pode ser escrito como a suma de exactamente 4 números pares positivos # >>> is_equal_to_sum_even(4)\n# FALSE\n# >>> is_equal_to_sum_even(6)\n# FALSE\n# >>> is_equal_to_sum_even(8)\n# TRUE\nis_equal_to_sum_even <- function(n) {","canonical_solution":"is_equal_to_sum_even <- function(n) {\n  if (n <= 0 || n %% 2 != 0 || n < 8) {\n    return(FALSE)\n  }\n  remaining_sum <- n\n  count <- 0\n  for (i in seq(2, n, by = 2)) {\n    if (remaining_sum - i >= 2 * (4 - count - 1)) {\n      remaining_sum <- remaining_sum - i\n      count <- count + 1\n    }\n    if (count == 4) {\n      return(TRUE)\n    }\n  }\n  return(FALSE)\n}\n\n# Examples\nis_equal_to_sum_even(4)   # FALSE\nis_equal_to_sum_even(6)   # FALSE\nis_equal_to_sum_even(8)   # TRUE","tests":"test_humaneval <- function() {\n    candidate <- is_equal_to_sum_even\n    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(10), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(11), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(12), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(13), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(16), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_139","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: onde n > 0 brasileiro_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! O factorial brasileiro defínese como: # >>> special_factorial(4)\n# 288\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\nspecial_factorial <- function(n) {","canonical_solution":"special_factorial <- function(n) {\n  result <- 1\n  for (i in 1:n) {\n    result <- result * factorial(i)\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- special_factorial\n    stopifnot(isTRUE(all.equal(candidate(4), 288)))\n    stopifnot(isTRUE(all.equal(candidate(5), 34560)))\n    stopifnot(isTRUE(all.equal(candidate(7), 125411328000)))\n    stopifnot(isTRUE(all.equal(candidate(1), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_140","nl":"glg_Latn","pl":"r","prompt":"Entón substituír todos os espazos consecutivos por - e se unha cadea ten máis de 2 espazos consecutivos, Dado unha cadea de texto, substituír todos os espazos con subíndices, # >>> fix_spaces(' Example')\n# 'Example'\n# >>> fix_spaces(' Example 1')\n# 'Example_1'\n# >>> fix_spaces(' Example 2')\n# '_Example_2'\n# >>> fix_spaces(' Example 3')\n# '_Example-3'\nfix_spaces <- function(text) {","canonical_solution":"fix_spaces <- function(text) {\n  # Trim leading and trailing spaces\n  text <- trimws(text)\n  # Replace 3 or more consecutive spaces with a dash\n  text <- gsub(\" {3,}\", \"-\", text)\n  # Replace remaining spaces with underscores\n  text <- gsub(\" \", \"_\", text)\n  return(text)\n}","tests":"test_humaneval <- function() {\n    candidate <- fix_spaces\n    stopifnot(isTRUE(all.equal(candidate('Example'), 'Example')))\n    stopifnot(isTRUE(all.equal(candidate('Mudasir Hanif '), 'Mudasir_Hanif_')))\n    stopifnot(isTRUE(all.equal(candidate('Yellow Yellow  Dirty  Fellow'), 'Yellow_Yellow__Dirty__Fellow')))\n    stopifnot(isTRUE(all.equal(candidate('Exa   mple'), 'Exa-mple')))\n    stopifnot(isTRUE(all.equal(candidate('   Exa 1 2 2 mple'), '-Exa_1_2_2_mple')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_141","nl":"glg_Latn","pl":"r","prompt":"Exemplos: - A subcadena despois do punto debe ser un destes: ['txt', 'exe', 'dll'] o alfabeto latino ('a'-'z' e 'A'-'Z'). - A subcadena antes do punto non debe estar baleiro, e comeza cunha letra de - O nome do ficheiro contén exactamente un punto '.'- O nome do ficheiro non debe ter máis de tres díxitos ('0'-'9'). son cumpridas: Considérase válido o nome dun ficheiro se e só se se cumpren todas as seguintes condicións:\"Si\" se o nome do ficheiro é válido, e devolve \"Non\" se non é así. Crea unha función que toma unha cadea que representa o nome dun ficheiro e devolve # >>> file_name_check('example.txt')\n# 'Yes'\n# >>> file_name_check('1example.dll')\n# 'No'\nfile_name_check <- function(file_name) {","canonical_solution":"file_name_check <- function(file_name) {\n  # Split the file name into the name part and the extension part\n  parts <- strsplit(file_name, \"\\\\.\", fixed = TRUE)[[1]]\n  \n  # Check there is exactly one dot\n  if (length(parts) != 2) {\n    return('No')\n  }\n  \n  # Extract the name and extension\n  name_part <- parts[1]\n  ext_part <- parts[2]\n  \n  # Check the extension is valid\n  if (!(ext_part %in% c('txt', 'exe', 'dll'))) {\n    return('No')\n  }\n  \n  # Check the name part is not empty and starts with a letter\n  if (nchar(name_part) == 0 || !grepl(\"^[A-Za-z]\", name_part)) {\n    return('No')\n  }\n  \n  # Count digits in the name part\n  digit_count <- nchar(gsub(\"[^0-9]\", \"\", name_part))\n  \n  # Check there are no more than three digits\n  if (digit_count > 3) {\n    return('No')\n  }\n  \n  return('Yes')\n}","tests":"test_humaneval <- function() {\n    candidate <- file_name_check\n    stopifnot(isTRUE(all.equal(candidate('example.txt'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('1example.dll'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('s1sdf3.asd'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('K.dll'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('MY16FILE3.exe'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('His12FILE94.exe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('_Y.txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('?aREYA.exe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('\/this_is_valid.dll'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('this_is_valid.wow'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txt'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txtexe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('#this2_i4s_5valid.ten'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('@this1_is6_valid.exe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('this_is_12valid.6exe4.txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('all.exe.txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('I563_No.exe'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('Is3youfault.txt'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('no_one#knows.dll'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('1I563_Yes3.exe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('I563_Yes3.txtt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('final..txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('final132'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('_f4indsartal132.'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('.txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('s.'), 'No')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_142","nl":"glg_Latn","pl":"r","prompt":"Exemplos: cambiar as entradas da lista cuxos índices non son un múltiplo de 3 ou 4. A función devolverá a suma de todas as entradas. multiplo de 3 e cubrirá a entrada enteira se o seu índice é un múltiplo de 4 e non un múltiplo de 3. A función non Esta función tomará unha lista de enteiros. Para todas as entradas na lista, a función elevará ao cuadrado a entrada enteira se o seu índice é un \" # >>> lst\n# c(1, 2, 3)\n# >>> lst\n# c()\n# >>> lst\n# c(-1, -5, 2, -1, -5)\nsum_squares <- function(lst) {","canonical_solution":"sum_squares <- function(lst) {\n  lst <- sapply(seq_along(lst), function(i) {\n    if (i %% 3 == 0) {\n      return(lst[i]^2)\n    } else if (i %% 4 == 0) {\n      return(lst[i]^3)\n    } else {\n      return(lst[i])\n    }\n  })\n  return(sum(lst))\n}","tests":"test_humaneval <- function() {\n    candidate <- sum_squares\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), 6)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 9)), 14)))\n    stopifnot(isTRUE(all.equal(candidate(c()), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 1, 1, 1, 1, 1)), 9)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -1, -1, -1, -1, -1, -1, -1, -1)), -3)))\n    stopifnot(isTRUE(all.equal(candidate(c(0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -5, 2, -1, -5)), -126)))\n    stopifnot(isTRUE(all.equal(candidate(c(-56, -99, 1, 0, -2)), 3030)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 0, 0, 0, 0, 0, 0, 0, -1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37)), -14196)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10)), -1448)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_143","nl":"glg_Latn","pl":"r","prompt":"Exemplo 1: A orde das palabras na nova cadea debe ser a mesma que a orixinal.cuxas lonxitudes son números primos, e ten que devolver unha cadea que contén as palabras da frase orixinal, a frase contén algunhas palabras separadas por un espazo, Dámosche unha cadea que representa unha frase,# >>> words_in_sentence('This is a test')\n# 'is'\n# Example 2:\n# >>> words_in_sentence('lets go for swimming')\n# 'go for'\n# Constraints:\n#     * 1 <= len(sentence) <= 100\n#     * sentence contains only letters\nwords_in_sentence <- function(sentence) {","canonical_solution":"words_in_sentence <- function(sentence) {\n  is_prime <- function(n) {\n    if (n <= 1) return(FALSE)\n    if (n == 2) return(TRUE)\n    for (i in 2:sqrt(n)) {\n      if (n %% i == 0) return(FALSE)\n    }\n    return(TRUE)\n  }\n  \n  words <- strsplit(sentence, \" \")[[1]]\n  prime_words <- words[sapply(words, function(word) is_prime(nchar(word)))]\n  return(paste(prime_words, collapse = \" \"))\n}","tests":"test_humaneval <- function() {\n    candidate <- words_in_sentence\n    stopifnot(isTRUE(all.equal(candidate('This is a test'), 'is')))\n    stopifnot(isTRUE(all.equal(candidate('lets go for swimming'), 'go for')))\n    stopifnot(isTRUE(all.equal(candidate('there is no place available here'), 'there is no place')))\n    stopifnot(isTRUE(all.equal(candidate('Hi I am Hussein'), 'Hi am Hussein')))\n    stopifnot(isTRUE(all.equal(candidate('go for it'), 'go for it')))\n    stopifnot(isTRUE(all.equal(candidate('here'), '')))\n    stopifnot(isTRUE(all.equal(candidate('here is'), 'is')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_144","nl":"glg_Latn","pl":"r","prompt":"Podes asumir que x e n son fraccións válidas e non teñen cero como denominador.<numerador>\/<denominador> onde tanto o numerador como o denominador son números enteiros positivos.Tanto x como n son representacións de cadea dunha fracción, e teñen o seguinte formato, x * n. A función devolve TRUE se x * n é un número enteiro e FALSE A súa tarefa é implementar unha función que simplifique a expresión.# >>> simplify('1\/5', '5\/1')\n# TRUE\n# >>> simplify('1\/6', '2\/1')\n# FALSE\n# >>> simplify('7\/10', '10\/2')\n# FALSE\nsimplify <- function(x, n) {","canonical_solution":"simplify <- function(x, n) {\n  parse_fraction <- function(fraction) {\n    parts <- strsplit(fraction, \"\/\")[[1]]\n    return(as.numeric(parts[1]) \/ as.numeric(parts[2]))\n  }\n  \n  x_value <- parse_fraction(x)\n  n_value <- parse_fraction(n)\n  \n  product <- x_value * n_value\n  \n  # Check if the product is a whole number\n  return(product == floor(product))\n}","tests":"test_humaneval <- function() {\n    candidate <- simplify\n    stopifnot(isTRUE(all.equal(candidate('1\/5', '5\/1'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('1\/6', '2\/1'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('5\/1', '3\/1'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('7\/10', '10\/2'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('2\/10', '50\/10'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('7\/2', '4\/2'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('11\/6', '6\/1'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('2\/3', '5\/2'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('5\/2', '3\/5'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('2\/4', '8\/4'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('2\/4', '4\/2'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('1\/5', '5\/1'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('1\/5', '1\/5'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_145","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: ordenalos segundo o seu índice na lista orixinal.Nota: se hai varias partidas coa mesma suma dos seus díxitos, en orde ascendente segundo a suma dos seus díxitos. Escribe unha función que ordena a lista de enteiros dada.# >>> order_by_points(c(1, 11, -1, -11, -12))\n# c(-1, -11, 1, -12, 11)\n# >>> order_by_points(c())\n# c()\norder_by_points <- function(nums) {","canonical_solution":"order_by_points <- function(nums) {\n  # Helper function to calculate the sum of digits\n  sum_of_digits <- function(n) {\n    sum(as.integer(unlist(strsplit(as.character(abs(n)), \"\"))))\n  }\n  \n  # Order the numbers based on the sum of their digits first, \n  # and then by their original index\n  indices <- seq_along(nums)\n  nums[order(sapply(nums, sum_of_digits), indices)]\n}","tests":"test_humaneval <- function() {\n    candidate <- order_by_points\n    stopifnot(isTRUE(all.equal(candidate(c(1, 11, -1, -11, -12)), c(-1, -11, 1, -12, 11))))\n    stopifnot(isTRUE(all.equal(candidate(c(1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46)), c(0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -11, -32, 43, 54, -98, 2, -3)), c(-3, -32, -98, -11, 1, 2, 43, 54))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), c(1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9))))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 6, 6, -76, -21, 23, 4)), c(-76, -21, 0, 4, 23, 6, 6))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_146","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: Os primeiros e últimos díxitos dun número son impares (1, 3, 5, 7, 9).o número de elementos no vector que son maiores que 10 e ambos Escribe unha función que toma un vector de números como entrada e devolve # >>> specialFilter(c(15, -73, 14, -15))\n# 1\n# >>> specialFilter(c(33, -2, -3, 45, 21, 109))\n# 2\nspecialFilter <- function(nums) {","canonical_solution":"specialFilter <- function(nums) {\n  # Helper function to check if both first and last digits are odd\n  are_first_last_digits_odd <- function(x) {\n    str_num <- as.character(abs(x))\n    first_digit <- as.numeric(substr(str_num, 1, 1))\n    last_digit <- as.numeric(substr(str_num, nchar(str_num), nchar(str_num)))\n    first_digit %% 2 == 1 && last_digit %% 2 == 1\n  }\n\n  # Filter numbers greater than 10 with both first and last digits odd\n  filtered_nums <- nums[nums > 10 & sapply(nums, are_first_last_digits_odd)]\n  \n  # Return the count of such numbers\n  length(filtered_nums)\n}","tests":"test_humaneval <- function() {\n    candidate <- specialFilter\n    stopifnot(isTRUE(all.equal(candidate(c(5, -2, 1, -5)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(15, -73, 14, -15)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(33, -2, -3, 45, 21, 109)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(43, -12, 93, 125, 121, 109)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(71, -2, -33, 75, 21, 19)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c()), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_147","nl":"glg_Latn","pl":"r","prompt":"Exemplo:e a[i] + a[j] + a[k] é un múltiplo de 3.Devolve o número de triples (a[i], a[j], a[k]) de a onde i < j < k, Para cada i (1 ≤ i ≤ n), o valor de a[i] = i * i - i + 1. Dámosche un número enteiro positivo n. Tes que crear un vector enteiro a de lonxitude n.#     >>> get_max_triples(5)\n#     1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7, 13).\nget_max_triples <- function(n) {","canonical_solution":"get_max_triples <- function(n) {\n  # Create the vector a according to the given rule\n  a <- sapply(1:n, function(i) i * i - i + 1)\n  \n  # Initialize the count of valid triples\n  count <- 0\n  \n  # Iterate over all possible triples (i, j, k) with i < j < k\n  for (i in 1:(n-2)) {\n    for (j in (i+1):(n-1)) {\n      for (k in (j+1):n) {\n        # Check if the sum of the selected triple is a multiple of 3\n        if ((a[i] + a[j] + a[k]) %% 3 == 0) {\n          count <- count + 1\n        }\n      }\n    }\n  }\n  \n  # Return the count of valid triples\n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- get_max_triples\n    stopifnot(isTRUE(all.equal(candidate(5), 1)))\n    stopifnot(isTRUE(all.equal(candidate(6), 4)))\n    stopifnot(isTRUE(all.equal(candidate(10), 36)))\n    stopifnot(isTRUE(all.equal(candidate(100), 53361)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_148","nl":"glg_Latn","pl":"r","prompt":"Exemplos Non son nomes de planetas correctos.A función devolverá unha lista baleira se planet1 ou planet2 A proximidade ao sol.situado entre a órbita do planeta 1 e a órbita do planeta 2, ordenado por A función debería devolver unha lista con todos os planetas cuxas órbitas son Escribe unha función que tome dous nomes de planetas como cadeas planet1 e planet2.Urano, Neptuno.é Mercurio, o seguinte é Venus, entón a Terra, Marte, Xúpiter, Saturno, Hai oito planetas no noso sistema solar: os máis próximos ao Sol .# >>> bf('Jupiter', 'Neptune')\n# c('Saturn', 'Uranus')\n# >>> bf('Earth', 'Mercury')\n# 'Venus'\n# >>> bf('Mercury', 'Uranus')\n# c('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')\nbf <- function(planet1, planet2) {","canonical_solution":"bf <- function(planet1, planet2) {\n  planets <- c('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\n  if (!(planet1 %in% planets) || !(planet2 %in% planets)) {\n    return(c())\n  }\n  \n  index1 <- which(planets == planet1)\n  index2 <- which(planets == planet2)\n  \n  if (index1 < index2) {\n    return(planets[(index1 + 1):(index2 - 1)])\n  } else if (index2 < index1) {\n    return(planets[(index2 + 1):(index1 - 1)])\n  } else {\n    return(c())\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- bf\n    stopifnot(isTRUE(all.equal(candidate('Jupiter', 'Neptune'), c('Saturn', 'Uranus'))))\n    stopifnot(isTRUE(all.equal(candidate('Earth', 'Mercury'), c('Venus'))))\n    stopifnot(isTRUE(all.equal(candidate('Mercury', 'Uranus'), c('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'))))\n    stopifnot(isTRUE(all.equal(candidate('Neptune', 'Venus'), c('Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'))))\n    stopifnot(isTRUE(all.equal(candidate('Earth', 'Earth'), c())))\n    stopifnot(isTRUE(all.equal(candidate('Mars', 'Earth'), c())))\n    stopifnot(isTRUE(all.equal(candidate('Jupiter', 'Makemake'), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_149","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: Pode asumir que todas as palabras terán a mesma lonxitude.A función debería devolver unha lista de cadeas de caracteres ordenadas.Se dúas palabras teñen a mesma lonxitude, ordena a lista por orde alfabética.debería devolver a lista ordenada por esa regra. A orde da lista debe ser ascendente en función da lonxitude de cada palabra, e vostede e pode conter duplicados.A lista é sempre unha lista de cadeas e nunca un vector de números, e devolve a lista resultante cunha orde ordenada, elimina as cadeas que teñen lonxitudes impares, Escribe unha función que acepte unha lista de cadeas como parámetro, # >>> list_sort(c('aa', 'a', 'aaa'))\n# c('aa')\n# >>> list_sort(c('ab', 'a', 'aaa', 'cd'))\n# c('ab', 'cd')\nsorted_list_sum <- function(lst) {","canonical_solution":"list_sort <- function(lst) {\n  # Filter out strings with odd lengths\n  filtered_list <- lst[nchar(lst) %% 2 == 0]\n  \n  # Sort the list first by length, then alphabetically\n  sorted_list <- filtered_list[order(nchar(filtered_list), filtered_list)]\n  \n  return(sorted_list)\n}","tests":"test_humaneval <- function() {\n    candidate <- sorted_list_sum\n    stopifnot(isTRUE(all.equal(candidate(c('aa', 'a', 'aaa')), c('aa'))))\n    stopifnot(isTRUE(all.equal(candidate(c('school', 'AI', 'asdf', 'b')), c('AI', 'asdf', 'school'))))\n    stopifnot(isTRUE(all.equal(candidate(c('d', 'b', 'c', 'a')), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('d', 'dcba', 'abcd', 'a')), c('abcd', 'dcba'))))\n    stopifnot(isTRUE(all.equal(candidate(c('AI', 'ai', 'au')), c('AI', 'ai', 'au'))))\n    stopifnot(isTRUE(all.equal(candidate(c('a', 'b', 'b', 'c', 'c', 'a')), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('aaaa', 'bbbb', 'dd', 'cc')), c('cc', 'dd', 'aaaa', 'bbbb'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_150","nl":"glg_Latn","pl":"r","prompt":"Exemplos: un número primo e devolvería o valor de y doutro xeito.Un programa simple que debería devolver o valor de x se n é # >>> x_or_y(7, 34, 12)\n# 34\n# >>> x_or_y(15, 8, 5)\n# 5\nx_or_y <- function(n, x, y) {","canonical_solution":"x_or_y <- function(n, x, y) {\n  is_prime <- function(num) {\n    if (num <= 1) {\n      return(FALSE)\n    }\n    for (i in 2:sqrt(num)) {\n      if (num %% i == 0) {\n        return(FALSE)\n      }\n    }\n    return(TRUE)\n  }\n  \n  if (is_prime(n)) {\n    return(x)\n  } else {\n    return(y)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- x_or_y\n    stopifnot(isTRUE(all.equal(candidate(7, 34, 12), 34)))\n    stopifnot(isTRUE(all.equal(candidate(15, 8, 5), 5)))\n    stopifnot(isTRUE(all.equal(candidate(3, 33, 5212), 33)))\n    stopifnot(isTRUE(all.equal(candidate(1259, 3, 52), 3)))\n    stopifnot(isTRUE(all.equal(candidate(7919, -1, 12), -1)))\n    stopifnot(isTRUE(all.equal(candidate(3609, 1245, 583), 583)))\n    stopifnot(isTRUE(all.equal(candidate(91, 56, 129), 129)))\n    stopifnot(isTRUE(all.equal(candidate(6, 34, 1234), 1234)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2, 0), 0)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 0), 2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_151","nl":"glg_Latn","pl":"r","prompt":"Ignore os números que son negativos ou non son enteiros.Dado unha lista de números, devolve a suma dos cadrados dos números.# >>> double_the_difference(c(1, 3, 2, 0))\n# 10\n# >>> double_the_difference(c(-1, -2, 0))\n# 0\n# >>> double_the_difference(c(9, -2))\n# 81\n# >>> double_the_difference(c(0))\n# 0\n# If the input list is empty, return 0.\ndouble_the_difference <- function(lst) {","canonical_solution":"double_the_difference <- function(lst) {\n  # Filter out non-positive, non-integer, and non-odd numbers\n  lst <- lst[lst > 0 & lst %% 1 == 0 & lst %% 2 == 1]\n  # Calculate the sum of squares of remaining numbers\n  sum(lst^2)\n}","tests":"test_humaneval <- function() {\n    candidate <- double_the_difference\n    stopifnot(isTRUE(all.equal(candidate(c()), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(5.0, 4.0)), 25)))\n    stopifnot(isTRUE(all.equal(candidate(c(0.1, 0.2, 0.3)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-10.0, -20.0, -30.0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.0, -2.0, 8.0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(0.2, 3.0, 5.0)), 34)))\n    stopifnot(isTRUE(all.equal(candidate(c(-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0)), 165)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_152","nl":"glg_Latn","pl":"r","prompt":"exemplo: O valor é 0, e se non é, o valor é a diferenza absoluta entre a suposición e a puntuación. Devolve un vector da mesma lonxitude que denota a distancia de cada adiviñación.Dámosche dous vectores de puntuacións e adiviñas de igual lonxitude, onde cada índice mostra unha coincidencia.A súa tarefa é determinar se unha persoa adiviñou correctamente os resultados dun número de partidos.Definitivamente vale a pena anotalo e comparalo.Os sentimentos e pensamentos que tes nese momento son os que teñan que ver co teu futuro.Creo que todos recordamos esa sensación cando o resultado dun longo agardado ...# >>> compare(c(1, 2, 3, 4, 5, 1), c(1, 2, 3, 4, 2, -2))\n# c(0, 0, 0, 0, 3, 3)\n# >>> compare(c(0, 5, 0, 0, 0, 4), c(4, 1, 1, 0, 0, -2))\n# c(4, 4, 1, 0, 0, 6)\ncompare <- function(game, guess) {","canonical_solution":"compare <- function(game, guess) {\n  abs(game - guess)\n}","tests":"test_humaneval <- function() {\n    candidate <- compare\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 1), c(1, 2, 3, 4, 2, -2)), c(0, 0, 0, 0, 3, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 0, 0, 0, 0, 0), c(0, 0, 0, 0, 0, 0)), c(0, 0, 0, 0, 0, 0))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), c(-1, -2, -3)), c(2, 4, 6))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5), c(-1, 2, 3, 4)), c(2, 0, 0, 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_153","nl":"glg_Latn","pl":"r","prompt":"Exemplo: (a súa forza é -1).devolver \"Slices.SErviNGSliCes\" xa que \"SErviNGSliCes\" é a extensión máis forte extensións: ['SErviNGSliCes', 'Cheese', 'StuFfed'] entón deberías Por exemplo, se se lle dá \"Slices\" como a clase e unha lista de elixe o que aparece primeiro na lista.Se hai dúas ou máis extensións coa mesma forza, debe formato: ClassName.StrongestExtensionName. Debería atopar a extensión máis forte e devolver unha cadea nesta.no nome da extensión, a forza débese á fracción CAP - SM. letras no nome da extensión, e que SM sexa o número de letras minúsculas A forza da extensión é a seguinte: Sexa CAP o número da letra maiúscula As extensións deben usarse para cargar clases adicionais á clase.Daráslle o nome dunha clase (unha cadea) e unha lista de extensións.# >>> Strongest_Extension('my_class', c('AA', 'Be', 'CC'))\n# 'my_class.AA'\nStrongest_Extension <- function(class_name, extensions) {","canonical_solution":"Strongest_Extension <- function(class_name, extensions) {\n  # Function to calculate the strength of an extension\n  extension_strength <- function(ext) {\n    cap_count <- sum(grepl(\"[A-Z]\", strsplit(ext, \"\")[[1]]))\n    sm_count <- sum(grepl(\"[a-z]\", strsplit(ext, \"\")[[1]]))\n    return(cap_count - sm_count)\n  }\n  \n  # Calculate strength for each extension and find the strongest one\n  strengths <- sapply(extensions, extension_strength)\n  max_strength_index <- which.max(strengths)\n  \n  # Construct the result string\n  return(paste0(class_name, \".\", extensions[max_strength_index]))\n}","tests":"test_humaneval <- function() {\n    candidate <- Strongest_Extension\n    stopifnot(isTRUE(all.equal(candidate('Watashi', c('tEN', 'niNE', 'eIGHt8OKe')), 'Watashi.eIGHt8OKe')))\n    stopifnot(isTRUE(all.equal(candidate('Boku123', c('nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg')), 'Boku123.YEs.WeCaNe')))\n    stopifnot(isTRUE(all.equal(candidate('__YESIMHERE', c('t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321')), '__YESIMHERE.NuLl__')))\n    stopifnot(isTRUE(all.equal(candidate('K', c('Ta', 'TAR', 't234An', 'cosSo')), 'K.TAR')))\n    stopifnot(isTRUE(all.equal(candidate('__HAHA', c('Tab', '123', '781345', '-_-')), '__HAHA.123')))\n    stopifnot(isTRUE(all.equal(candidate('YameRore', c('HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-')), 'YameRore.okIWILL123')))\n    stopifnot(isTRUE(all.equal(candidate('finNNalLLly', c('Die', 'NowW', 'Wow', 'WoW')), 'finNNalLLly.WoW')))\n    stopifnot(isTRUE(all.equal(candidate('_', c('Bb', '91245')), '_.Bb')))\n    stopifnot(isTRUE(all.equal(candidate('Sp', c('671235', 'Bb')), 'Sp.671235')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_154","nl":"glg_Latn","pl":"r","prompt":"Ten que devolver TRUE se a segunda palabra ou calquera das súas rotacións é unha subcadena na primeira palabra.# >>> cycpattern_check('abcd', 'abd')\n# FALSE\n# >>> cycpattern_check('hello', 'ell')\n# TRUE\n# >>> cycpattern_check('whassup', 'psus')\n# FALSE\n# >>> cycpattern_check('abab', 'baa')\n# TRUE\n# >>> cycpattern_check('efef', 'eeff')\n# FALSE\n# >>> cycpattern_check('himenss', 'simen')\n# TRUE\ncycpattern_check <- function(a, b) {","canonical_solution":"cycpattern_check <- function(a, b) {\n  n <- nchar(b)\n  # Check all rotations of b\n  for (i in 0:(n-1)) {\n    # Rotate the string b by i characters\n    rotated_b <- substring(b, i+1, n) %\/% substring(b, 1, i)\n    # Check if the rotated string is a substring of a\n    if (grepl(rotated_b, a)) {\n      return(TRUE)\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- cycpattern_check\n    stopifnot(isTRUE(all.equal(candidate('xyzw', 'xyw'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('yello', 'ell'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('whattup', 'ptut'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('efef', 'fee'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('abab', 'aabb'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('winemtt', 'tinem'), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_155","nl":"glg_Latn","pl":"r","prompt":"Exemplo: Dado un número enteiro. devolve unha lista que ten o número de díxitos pares e impares respectivamente. #     >>> even_odd_count(-12)\n#     c(1, 1)\n#     >>> even_odd_count(123)\n#     c(1, 2)\neven_odd_count <- function(num) {","canonical_solution":"even_odd_count <- function(num) {\n  # Handle negative numbers by taking the absolute value\n  num <- abs(num)\n  \n  # Convert the number to a character vector to access digits\n  digits <- unlist(strsplit(as.character(num), \"\"))\n  \n  # Convert character vector back to integer\n  digits <- as.integer(digits)\n  \n  # Count even digits\n  even_count <- sum(digits %% 2 == 0)\n  \n  # Count odd digits\n  odd_count <- length(digits) - even_count\n  \n  # Return a vector with even and odd counts\n  return(c(even_count, odd_count))\n}","tests":"test_humaneval <- function() {\n    candidate <- even_odd_count\n    stopifnot(isTRUE(all.equal(candidate(7), c(0, 1))))\n    stopifnot(isTRUE(all.equal(candidate(-78), c(1, 1))))\n    stopifnot(isTRUE(all.equal(candidate(3452), c(2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(346211), c(3, 3))))\n    stopifnot(isTRUE(all.equal(candidate(-345821), c(3, 3))))\n    stopifnot(isTRUE(all.equal(candidate(-2), c(1, 0))))\n    stopifnot(isTRUE(all.equal(candidate(-45347), c(2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(0), c(1, 0))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_156","nl":"glg_Latn","pl":"r","prompt":"Exemplos: Limitacións: 1 <= num <= 1000 e devolve-lo en minúsculas.Dado un número enteiro positivo, obtén o seu equivalente numérico romano como unha cadea, # >>> int_to_mini_roman(19)\n# 'xix'\n# >>> int_to_mini_roman(152)\n# 'clii'\n# >>> int_to_mini_roman(426)\n# 'cdxxvi'\nint_to_mini_roman <- function(number) {","canonical_solution":"int_to_mini_roman <- function(number) {\n  values <- c(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n  numerals <- c(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n  \n  result <- \"\"\n  remainder <- number\n  \n  for (i in seq_along(values)) {\n    while (remainder >= values[i]) {\n      result <- paste0(result, numerals[i])\n      remainder <- remainder - values[i]\n    }\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- int_to_mini_roman\n    stopifnot(isTRUE(all.equal(candidate(19), 'xix')))\n    stopifnot(isTRUE(all.equal(candidate(152), 'clii')))\n    stopifnot(isTRUE(all.equal(candidate(251), 'ccli')))\n    stopifnot(isTRUE(all.equal(candidate(426), 'cdxxvi')))\n    stopifnot(isTRUE(all.equal(candidate(500), 'd')))\n    stopifnot(isTRUE(all.equal(candidate(1), 'i')))\n    stopifnot(isTRUE(all.equal(candidate(4), 'iv')))\n    stopifnot(isTRUE(all.equal(candidate(43), 'xliii')))\n    stopifnot(isTRUE(all.equal(candidate(90), 'xc')))\n    stopifnot(isTRUE(all.equal(candidate(94), 'xciv')))\n    stopifnot(isTRUE(all.equal(candidate(532), 'dxxxii')))\n    stopifnot(isTRUE(all.equal(candidate(900), 'cm')))\n    stopifnot(isTRUE(all.equal(candidate(994), 'cmxciv')))\n    stopifnot(isTRUE(all.equal(candidate(1000), 'm')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_157","nl":"glg_Latn","pl":"r","prompt":"Exemplo: 90 graos.Un triángulo rectángulo é un triángulo no que un dos ángulos é recto ou Os lados forman un triángulo rectángulo, FALSO doutro xeito.Dadas as lonxitudes dos tres lados dun triángulo, devolve TRUE se os tres lados son iguais.# >>> right_angle_triangle(3, 4, 5)\n# TRUE\n# >>> right_angle_triangle(1, 2, 3)\n# FALSE\nright_angle_triangle <- function(a, b, c) {","canonical_solution":"right_angle_triangle <- function(a, b, c) {\n  # Sort the sides to easily compare the largest side\n  sides <- sort(c(a, b, c))\n  \n  # Check if the sum of squares of the two smaller sides equals the square of the largest side\n  return(sides[1]^2 + sides[2]^2 == sides[3]^2)\n}","tests":"test_humaneval <- function() {\n    candidate <- right_angle_triangle\n    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(10, 6, 8), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(7, 24, 25), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(5, 12, 13), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(15, 8, 17), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(48, 55, 73), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_158","nl":"glg_Latn","pl":"r","prompt":"caracteres, devolve o que aparece primeiro en orde lexicográfica. Se varias cadeas teñen o número máximo de caracteres únicos A lista contén palabras diferentes.Escribe unha función que acepte unha lista de cadeas.# >>> find_max(c('name', 'of', 'string'))\n# 'string'\n# >>> find_max(c('name', 'enam', 'game'))\n# 'enam'\n# >>> find_max(c('aaaaaaa', 'bb', 'cc'))\n# 'aaaaaaa'\nfind_max <- function(words) {","canonical_solution":"find_max <- function(words) {\n  max_unique_chars <- 0\n  result <- \"\"\n  \n  for (word in words) {\n    unique_chars_count <- length(unique(strsplit(word, NULL)[[1]]))\n    \n    if (unique_chars_count > max_unique_chars ||\n       (unique_chars_count == max_unique_chars && word < result)) {\n      max_unique_chars <- unique_chars_count\n      result <- word\n    }\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- find_max\n    stopifnot(isTRUE(all.equal(candidate(c('name', 'of', 'string')), 'string')))\n    stopifnot(isTRUE(all.equal(candidate(c('name', 'enam', 'game')), 'enam')))\n    stopifnot(isTRUE(all.equal(candidate(c('aaaaaaa', 'bb', 'cc')), 'aaaaaaa')))\n    stopifnot(isTRUE(all.equal(candidate(c('abc', 'cba')), 'abc')))\n    stopifnot(isTRUE(all.equal(candidate(c('play', 'this', 'game', 'of', 'footbott')), 'footbott')))\n    stopifnot(isTRUE(all.equal(candidate(c('we', 'are', 'gonna', 'rock')), 'gonna')))\n    stopifnot(isTRUE(all.equal(candidate(c('we', 'are', 'a', 'mad', 'nation')), 'nation')))\n    stopifnot(isTRUE(all.equal(candidate(c('this', 'is', 'a', 'prrk')), 'this')))\n    stopifnot(isTRUE(all.equal(candidate(c('b')), 'b')))\n    stopifnot(isTRUE(all.equal(candidate(c('play', 'play', 'play')), 'play')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_159","nl":"glg_Latn","pl":"r","prompt":"Exemplo: Se non hai suficientes cenouras, comerás todas as que te queden, pero aínda así terás fame.o número de zanahorias que quedan despois das comidas ] Debería devolver un vector de [número total de zanahorias consumidas despois das comidas, Pero agora tes que comer máis zanahorias para completar as comidas do día.Es un coello con fame, e xa comeste unha certa cantidade de zanahorias,# >>> eat(5, 6, 10)\n# c(11, 4)\n# >>> eat(4, 8, 9)\n# c(12, 1)\n# >>> eat(1, 10, 10)\n# c(11, 0)\n# >>> eat(2, 11, 5)\n# c(7, 0)\n# Variables:\n# @number : integer\n#     the number of carrots that you have eaten.\n# @need : integer\n#     the number of carrots that you need to eat.\n# @remaining : integer\n#     the number of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\neat <- function(number, need, remaining) {","canonical_solution":"eat <- function(number, need, remaining) {\n  total_eaten <- number + min(need, remaining)\n  remaining_carrots <- max(0, remaining - need)\n  return(c(total_eaten, remaining_carrots))\n}","tests":"test_humaneval <- function() {\n    candidate <- eat\n    stopifnot(isTRUE(all.equal(candidate(5, 6, 10), c(11, 4))))\n    stopifnot(isTRUE(all.equal(candidate(4, 8, 9), c(12, 1))))\n    stopifnot(isTRUE(all.equal(candidate(1, 10, 10), c(11, 0))))\n    stopifnot(isTRUE(all.equal(candidate(2, 11, 5), c(7, 0))))\n    stopifnot(isTRUE(all.equal(candidate(4, 5, 7), c(9, 2))))\n    stopifnot(isTRUE(all.equal(candidate(4, 5, 1), c(5, 0))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_160","nl":"glg_Latn","pl":"r","prompt":"A lista de operadores ten polo menos un operador e a lista de operandos ten polo menos dous operandos.O operando é unha lista de números enteiros non negativos.A lonxitude da lista de operadores é igual á lonxitude da lista de operandos menos un.Nota: => resultado = 9 resultado = 2 + 3 * 4 - 5 vector = [2, 3, 4, 5] operador['+', '*', '-'] Exemplo: Exponenciación (**) División de piso ( \/\/) Multiplicación ( *) Subtracción ( - ) Adición (+) As operacións básicas de álxebra:expreso e devolve a avaliación desta expresión.A segunda lista é unha lista de números enteiros.A primeira lista ten operacións básicas de álxebra, e do_algebra <- function(operator, operand) {","canonical_solution":"do_algebra <- function(operator, operand) {\n  if (length(operator) != length(operand) - 1) {\n    stop(\"The length of operator list must be equal to the length of operand list minus one.\")\n  }\n  \n  # Initialize the result with the first operand\n  result <- operand[1]\n  \n  # Iterate through the operators and operands\n  for (i in 1:length(operator)) {\n    op <- operator[i]\n    num <- operand[i + 1]\n    \n    # Apply the appropriate operation\n    if (op == '+') {\n      result <- result + num\n    } else if (op == '-') {\n      result <- result - num\n    } else if (op == '*') {\n      result <- result * num\n    } else if (op == '\/\/') {\n      result <- result %\/% num\n    } else if (op == '**') {\n      result <- result ^ num\n    } else {\n      stop(\"Unsupported operation\")\n    }\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- do_algebra\n    stopifnot(isTRUE(all.equal(candidate(c('**', '*', '+'), c(2, 3, 4, 5)), 37)))\n    stopifnot(isTRUE(all.equal(candidate(c('+', '*', '-'), c(2, 3, 4, 5)), 9)))\n    stopifnot(isTRUE(all.equal(candidate(c('\/\/', '*'), c(7, 3, 4)), 8)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_161","nl":"glg_Latn","pl":"r","prompt":"Exemplos A función debería devolver a cadea resultante.Se a cadea non contén letras, invertir a cadea.Se non, deixalo como está.se s[i] é unha letra, inverte a súa casa de baixo para arriba ou viceversa, Vostede está dado unha cadea de caracteres s.# >>> solve('1234')\n# '4321'\n# >>> solve('ab')\n# 'AB'\n# >>> solve('#a@C')\n# '#A@c'\nsolve <- function(s) {","canonical_solution":"solve <- function(s) {\n  if (grepl(\"[a-zA-Z]\", s)) {\n    return(chartr(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n                  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", s))\n  } else {\n    return(intToUtf8(rev(utf8ToInt(s))))\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- solve\n    stopifnot(isTRUE(all.equal(candidate('AsDf'), 'aSdF')))\n    stopifnot(isTRUE(all.equal(candidate('1234'), '4321')))\n    stopifnot(isTRUE(all.equal(candidate('ab'), 'AB')))\n    stopifnot(isTRUE(all.equal(candidate('#a@C'), '#A@c')))\n    stopifnot(isTRUE(all.equal(candidate('#AsdfW^45'), '#aSDFw^45')))\n    stopifnot(isTRUE(all.equal(candidate('#6@2'), '2@6#')))\n    stopifnot(isTRUE(all.equal(candidate('#$a^D'), '#$A^d')))\n    stopifnot(isTRUE(all.equal(candidate('#ccc'), '#CCC')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_162","nl":"glg_Latn","pl":"r","prompt":"Se 'text' é unha cadea baleira, devolve NULL. Dado unha cadea de caracteres 'text', devolva a súa cadea de caracteres equivalente ao hash md5. # >>> string_to_md5('Hello world')\n# '3e25960a79dbc69b674cd4ec67a72c62'\nstring_to_md5 <- function(text) {","canonical_solution":"string_to_md5 <- function(text) {\n  if (text == \"\") {\n    return(NULL)\n  } else {\n    return(digest::digest(text, algo = \"md5\", serialize = FALSE))\n  }\n}\n\n# Ensure the required library is loaded\nif(!requireNamespace(\"digest\", quietly = TRUE)) {\n  install.packages(\"digest\")\n}\n\n# Load the digest library\nlibrary(digest)","tests":"test_humaneval <- function() {\n    candidate <- string_to_md5\n    stopifnot(isTRUE(all.equal(candidate('Hello world'), '3e25960a79dbc69b674cd4ec67a72c62')))\n    stopifnot(isTRUE(all.equal(candidate(''), NULL)))\n    stopifnot(isTRUE(all.equal(candidate('A B C'), '0ef78513b0cb8cef12743f5aeb35f888')))\n    stopifnot(isTRUE(all.equal(candidate('password'), '5f4dcc3b5aa765d61d8327deb882cf99')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_163","nl":"glg_Latn","pl":"r","prompt":"Por exemplo: e b, en orde ascendente. Dadas dúas enteras positivas a e b, devolve os díxitos pares entre a # >>> generate_integers(2, 8)\n# c(2, 4, 6, 8)\n# >>> generate_integers(8, 2)\n# c(2, 4, 6, 8)\n# >>> generate_integers(10, 14)\n# c()\ngenerate_integers <- function(a, b) {","canonical_solution":"generate_integers <- function(a, b) {\n  start <- min(a, b)\n  end <- max(a, b)\n  even_digits <- seq(start, end)[seq(start, end) %% 2 == 0 & seq(start, end) <= 8]\n  return(even_digits)\n}","tests":"test_humaneval <- function() {\n    candidate <- generate_integers\n    stopifnot(isTRUE(all.equal(candidate(2, 10), c(2, 4, 6, 8))))\n    stopifnot(isTRUE(all.equal(candidate(10, 2), c(2, 4, 6, 8))))\n    stopifnot(isTRUE(all.equal(candidate(132, 2), c(2, 4, 6, 8))))\n    stopifnot(isTRUE(all.equal(candidate(17, 89), c())))\n}\ntest_humaneval()"}]