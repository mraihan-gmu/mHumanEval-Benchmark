task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,isl_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Athugaðu hvort í gefnum tölulista séu einhverjar tvær tölur nærri hvor annarri en gefið þröskuld. Dæmi: >>> hefur_nægra_þáttum (([1.0, 2.0, 3.0], 0.5) False >>> hefur_nægra_þáttum (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,isl_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Input til þessa hlutverki er strengur sem inniheldur margar hópar af hreiðraðum faðma. Markmið þitt er að aðskilja þá hópa í aðskilin strengur og skila listanum yfir þá. Aðskilin hópar eru jafnvægi (hver opinn fönn er rétt lokað) og ekki hreiðraðir innra með sér Ignorðu hvaða rými í innleggstrengnum. Dæmi: >>> separate_paren_groups' ((( ) (() (()))))) ['() ', '(()) ', '((()) ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,isl_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Ef gefinn er jákvæður sveifulýsingartölur er hægt að brjóta hann niður í heildarhlut (stærsta heildarhlut sem er minni en gefið númer) og tíundahlut (leftur hluti er alltaf minni en 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,isl_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Þú færð lista yfir inn- og útgreiðsluviðgerðir á bankareikningi sem byrjar með núll jafnvægi. Verkefni þitt er að greina ef á einhverjum tímapunkti jafnvægi reikningsins fellur undir núll, og á þeim tímapunkti ætti að skila sannri. Annars ætti það að skila fals. Dæmi: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,isl_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Fyrir tiltekinn lista af innleggstölum reiknaðu Mean Absolute Deviation um miðgildi þessa gagna. Mean Absolute Deviation er meðaltal algjörs mismunar á milli hvers þátta og miðpunkts (miðgildi í þessu tilfelli): MAD = meðaltali. x - x_mean. Dæmi: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,isl_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Setjið tölur ""afmörkunartíma"" á milli tveggja samfelldra þátta í innleggslistanum `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,isl_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Input til þessa hlutverki er strengur sem táknar margar hópar fyrir hreiðraða foreldra aðskilin með rými. Fyrir hvern hópinn, útgáfa dýpstu stig hreiðraða foreldra. T.d. (() (()) hefur hámark tvö stig hreiðraða meðan ((())) hefur þrjú. >>> parse_nested_parens('((()) ((())) () ((()) ((()))) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,isl_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Fyltra innangreindum strengjalista aðeins fyrir þá sem innihalda gefið undirstreng >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,isl_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Fyrir gefinn lista af heilum tölum, skilar tuple sem samanstendur af a summa og a vara af öllum heilum tölum í lista. Tólt summa ætti að vera jafnt 0 og tóm vara ætti að vera jafnt 1. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,isl_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Af gefnum lista af heilum tölum, búa til lista yfir rúlla hámarksatriði fundist til tiltekins augnabliks í röðinni. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,isl_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Finndu stytta palindróminn sem byrjar á veittri streng. Hugmynd algoritmsins er einföld: - Finndu lengsta eftirfylgni veittra strengja sem er palindróm. - Bættu við lok strengjarins aftur af strengjaforyfirliti sem kemur fyrir palindrómíska viðauka. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Prófaðu hvort strengi sé palindrómur""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,isl_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Input eru tvær strengur a og b sem samanstanda aðeins af 1s og 0s. Framkvæma tvíeiningar XOR á þessum inngangi og skila niðurstöðu einnig sem strengur. >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,isl_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Endurendur fyrsta ef fleiri strengir eru með sömu lengd. Endurendur Ekkert ef innleggslista er tóm. >>> lengsti (([]) >>> lengsti ((['a', 'b', 'c']) 'a' >>> lengsti ((['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,isl_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Senda aftur stærsta sameiginlega deili tveggja heilstjóra a og b >>> stærsta_samstæða_deili ((3, 5) 1 >>> stærsta_samstæða_deili ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,isl_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Aftur listi yfir öll fororð frá styttasta til lengsta inngáfu strenginn >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,isl_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Skila streng sem inniheldur rými afmarkaðar tölur sem byrja frá 0 upp í n. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,isl_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Gefið streng, finna út hversu margir mismunandi stafi (háð því hvernig) er það samanstendur af >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,isl_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Input til þessa hlutverki er strengur tákna tónlistar nótur í sérstökum ASCII sniði. Verkefni þitt er að greina strengur lista af heilum samsvarandi mörgum beats gerir Hér er legend: 'o' nóta, síðast beats 'o' - fjórir beats - hálf nóta, síðast tveir beats - quater nóta, síðast einn beats >>> parse_music. 'o o .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,isl_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Finna hversu oft ákveðin undirstrengur er að finna í upprunalegu strengnum. Telja yfirlagast tilfelli. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,isl_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Input er rými afmarkaður strengur af númeral frá ""núll"" til ""níu"". Gild val eru ""núll"", ""ein"", ""tveir"", ""þrír"", ""fjögur"", ""fimm"", ""sex"", ""sjö"", "" átta"" og ""níu"". Endur skilar strenginn með tölum raðað frá minnsta til stærsta >>> sort_numbers (('þrjú eitt fimm') 'ein þrjú fimm' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,isl_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Af gefnum lista af tölum (með lengd að minnsta kosti tvö) velja og skila tveimur sem eru næst hvor öðrum og skila þeim í röð (minni númer, stærri númer). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,isl_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Gefið lista af tölum (af að minnsta kosti tveimur þáttum), beita línulegum umbreytingu á þennan lista, þannig að minnsta tala verði 0 og stærsta verði 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,isl_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filter gefið lista yfir hvaða Python gildi aðeins fyrir heilstölur >>> filter_integers(['a', 3.14, 5]) [5] >>> filter_integers([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,isl_Latn,python,"

def strlen(string: str) -> int:
    """"""Afturlengd vefþráðar >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,isl_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Fyrir gefin n tala, finna stærstu tala sem deilir n jafnt, minni en n >>> stærsti_deildarinn ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,isl_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Aftur listann af frumþáttum gefna heiltala í röð frá minnsta til stærsta. Hver af þáttunum ætti að vera skráður fjölda sinnum sem samsvarar því hversu oft það birtist í þátta. Input númer ætti að vera jafnt við margfaldið af öllum þáttum >>> þátta(8) [2, 2, 2] >>> þátta(25) [5, 5] >>> þátta(70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,isl_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Af lista með heilum tölum skal fjarlægja alla þá hluti sem koma fram oftar en einu sinni. Halda röð þá hluta sem eftir eru sömu og í inngáfunni. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,isl_Latn,python,"

def flip_case(string: str) -> str:
    """"""Fyrir ákveðna streng, snúa litlum stafi til stórstafa og stórstafa til litla. >>> flip_case (('Hello') 'hELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,isl_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Samþætt listi af strengjum í eina streng >>> samþætt (a, b, c) ""abc""""""""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,isl_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Fyltraðu innangreindum strengjalista aðeins fyrir þá sem byrja á tilteknu fororð. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,isl_Latn,python,"

def get_positive(l: list):
    """"""Senda aðeins jákvæðar tölur í listanum. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,isl_Latn,python,"

def is_prime(n):
    """"""Senda sannar ef gefin tala er frumtal, og rangar annars. >>> er_fyrir-tal (e. prime) og fals annars. >>> er_fyrir-tal (e. prime) og fals annars.""""""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,isl_Latn,python,"import math


def poly(xs: list, x: float):
    """"""xs eru hlutfall fjölnöfn. find_zero finna x þannig að poly(x) = 0. find_zero skilar aðeins aðeins núllpunkti, jafnvel þótt það séu margir. auk þess tekur find_zero aðeins lista xs með jafnvel fjölda hlutfalls og stærsta ekki núll hlutfall þar sem það tryggir lausn. >>> hring >>> find_zero[1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> hring(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Metur fjölnöfn með hlutföllum xs á punkti x. skilar xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,isl_Latn,python,"

def sort_third(l: list):
    """"""Þessi virkni tekur lista l og skilar lista l' þannig að l' sé eins og l í vísitölum sem eru ekki deilanleg á þrjú, en gildi þess á vísitölum sem eru deilanleg á þrjú eru jafnt gildum samsvarandi vísitölum l, en raðað. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,isl_Latn,python,"

def unique(l: list):
    """"""Skila flokkuðum einstökum atriðum í lista >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,isl_Latn,python,"

def max_element(l: list):
    """"""Senda til baka hámarksatriði á listanum. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,isl_Latn,python,"

def fizz_buzz(n: int):
    """"""Skilgreiningin gefur upp fjölda þeirra sinnum sem tölustafurinn 7 birtist í heilum tölum sem eru minni en n og deilanlegar með 11 eða 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,isl_Latn,python,"

def sort_even(l: list):
    """"""Þessi hlutverk tekur lista l og skilar lista l' þannig að l' sé eins og l í ólíkum vísitölum, en gildi þess á jöfnum vísitölum eru jafnt gildum jöfnum vísitölum l, en raðað. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,isl_Latn,python,"

def encode_cyclic(s: str):
    """"""tekur sem inntak strengur kóðaður með encode_cyclic hlutverki. Endurendur afkóðaður strengur. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""skilar kóðaðum streng eftir hjólreiðarhópa þriggja stafa. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,isl_Latn,python,"

def prime_fib(n: int):
    """"""prime_fib skilar n-þriggja númer sem er Fibonacci númer og það er einnig frumtal. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,isl_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero tekur lista af heilum tölum sem inngang. Það skilar True ef það eru þrír mismunandi þættir í listanum sem leggja saman til núll, og False annars. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,isl_Latn,python,"

def car_race_collision(n: int):
    """"""Ímyndaðu þér veg sem er fullkomlega beinn óendanlega langur lína. n bílar eru að keyra vinstri til hægri; samtímis, mismunandi sett af n bílum eru að keyra hægri til vinstri. Tvær bílasettir byrja að vera mjög langt frá hvor öðrum. Allir bílar hreyfast á sama hraða. Tveir bílar eru sagðir að lenda í árekstri þegar bíll sem er að hreyfast vinstri til hægri hittir bíl sem er að hreyfast hægri til vinstri. En bílar eru óendanlega fastir og sterkir; í kjölfarið halda þeir áfram að hreyfa sig í braut sinni eins og þeir hafi ekki lent í árekstri. Þessi virkni gefur út fjölda slíkra árekstra.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,isl_Latn,python,"

def incr_list(l: list):
    """"""Aftur listann með atriðum sem eru aukin með 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,isl_Latn,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero tekur lista af heilum tölum sem inngang. Það skilar True ef það eru tveir mismunandi þættir í listanum sem leggja saman til núll, og False annars. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,isl_Latn,python,"

def change_base(x: int, base: int):
    """"""Breyta tölulegum grunn inngáfu númer x til grunn. skila strengur táknmyndun eftir umbreytingu. grunnnúmer eru minni en 10. >>> breyting_grundvöllur(8, 3) '22' >>> breyting_grundvöllur(8, 2) '1000' >>> breyting_grundvöllur(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,isl_Latn,python,"

def triangle_area(a, h):
    """"""Gefin lengd hliðar og hæsta skila svæði fyrir þríhyrning. >>> þríhyrningur_svæði""""""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,isl_Latn,python,"

def fib4(n: int):
    """"""Fib4 tölustafurinn er svipaður Fibbonacci-söðunni sem er skilgreindur sem hér segir: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Vinsamlegast skrifaðu hlutverk til að reikna n-th þáttur af fib4 tölustafurnum. Ekki nota endurtekningu. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,isl_Latn,python,"

def median(l: list):
    """"""Endurkomu miðgildi þátta í listanum l. >>> miðgildi (([3, 1, 2, 4, 5]) 3 >>> miðgildi (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,isl_Latn,python,"

def is_palindrome(text: str):
    """"""Skoðar hvort veitt strengur er palindróm >>> is_palindróm (('') Sannur >>> is_palindróm (('aba') Sannur >>> is_palindróm (('aaaaa') Sannur >>> is_palindróm (('zbcd') False """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,isl_Latn,python,"

def modp(n: int, p: int):
    """"""Snúðu aftur 2^n módul p (vertu meðvitaður um tölur). >>> módulp(3, 5) 3 >>> módulp(1101, 101) 2 >>> módulp(0, 101) 1 >>> módulp(3, 11) 8 >>> módulp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,isl_Latn,python,"

def encode_shift(s: str):
    """"""tekur sem inntak strengur kóðaður með encode_shift hlutverki. Endurendur afkóðaður strengur. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""skilar kóðuðum streng með því að færa hvert tákn um 5 í stafrófinu.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,isl_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels er hlutverk sem tekur streng og skilar streng án sjálfrófs. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,isl_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Senda sannar ef allar tölur í listanum eru undir þröskuld t. >>> below_threshold (([1, 2, 4, 10], 100) Sannar >>> below_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,isl_Latn,python,"

def add(x: int, y: int):
    """"""Bæta við tvær tölur x og y >>> bætast við ((2, 3) 5 >>> bætast við ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,isl_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Athugaðu hvort tvö orð hafi sömu stafi. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') Sannur >>> same_chars (('abcd', 'dddddddabc') Sannur >>> same_chars (('dddddddabc', 'abcd') Sannur >>> same_chars (('eabcd', 'dddddddddabc') Falskur >>> same_chars ((('abcd', 'dddddddabddce') Falskur >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') Falskur """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,isl_Latn,python,"

def fib(n: int):
    """"""Skilgreiningin er að finna í tölunni.""""""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,isl_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets er strengur af ""<"" og "">"". skila sannar ef hver opnun bracket hefur samsvarandi loka bracket. >>> rétt_bracketing ((""<"") False >>> rétt_bracketing ((""<>"") Sannar >>> rétt_bracketing ((""<><>>"") Sannar >>> rétt_bracketing ((""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,isl_Latn,python,"

def monotonic(l: list):
    """"""Senda sannar ef listaþáttum er fjölgað eða fækkað einhljóðlega. >>> einhljóðlegt (([1, 2, 4, 20]) Sannar >>> einhljóðlegt (([1, 20, 4, 10]) False >>> einhljóðlegt (([4, 1, 0, -10]) Sannar """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,isl_Latn,python,"

def common(l1: list, l2: list):
    """"""Skila flokkuðum einstökum sameiginlegum atriðum fyrir tvo lista. >>> sameiginlegur (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> sameiginlegur (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,isl_Latn,python,"

def largest_prime_factor(n: int):
    """"""Skilgreiningin er að finna í tölvunni.""""""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,isl_Latn,python,"

def sum_to_n(n: int):
    """"""sum_to_n er hlutverk sem leggur saman tölur frá 1 til n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,isl_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets er strengur af ""("" og "")"". skila sannar ef hver opnun bracket hefur samsvarandi loka bracket. >>> rétt_bracketing (((""("") False >>> rétt_bracketing ((("")) Sannar >>> rétt_bracketing (((())) Sannar >>> rétt_bracketing ((("") False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,isl_Latn,python,"

def derivative(xs: list):
    """"""xs tákna hlutfall margnefnis. xs[0] + xs[1] * x + xs[2] * x^2 + .... Skila afleiðu þessa margnefnis í sama formi. >>> afleiða (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> afleiða[(1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,isl_Latn,python,"

def fibfib(n: int):
    """"""FibFib-númeraröð er röð svipuð Fibbonacci-söðinni sem er skilgreind sem hér segir: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Vinsamlegast skrifaðu hlutverk til að reikna n-th þáttur af Fibfib-númeraröðinni. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,isl_Latn,python,"
FIX = """"""Skrifaðu hlutverk vowels_count sem tekur streng sem táknar orð sem innlag og skilar fjölda hljóðröddar í strengnum. Hljómorð í þessu tilfelli eru 'a', 'e', 'i', 'o', 'u'. Hér er 'y' einnig hljóðrödd, en aðeins þegar það er í lok orðsins. Dæmi: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Bæta við fleiri próftilvikum. """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,isl_Latn,python,"
def circular_shift(x, shift):
    """"""Hringlaga færðu tölustafi heildartali x, færðu tölustafi til hægri með færslu og skilaðu niðurstöðunni sem streng. Ef færsla > fjöldi tölustafa, skilaðu tölustafum aftur á móti. >>> hringlaga_skipti(12, 1) ""21"" >>> hringlaga_skipti(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,isl_Latn,python,"
def digitSum(s):
    """"""Verkefni Skrifaðu hlutverk sem tekur streng sem innlag og skilar aðeins uppsöfn efri stafa ASCII kóða. Dæmi: digitSum ((("""") => 0 digitSum ((""abAB"") => 131 digitSum ((""abcCd"") => 67 digitSum (((""helloE"") => 69 digitSum (((""woArBld"") => 131 digitSum ((""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,isl_Latn,python,"
def fruit_distribution(s,n):
    """"""Í þessu verkefni, verður þú gefið streng sem táknar fjölda epli og appelsínur sem eru dreift í körfu ávöxtum þessi körfu inniheldur epli, appelsínur og mangó ávexti. Gefið streng sem táknar heildarfjölda appelsínur og epli og heil tala sem táknar heildarfjölda ávexti í körfu skila fjölda mangó ávexti í körfunni. til dæmis: fruit_distribution""5(eppla og 6 appelsínur"", 19) -> 19 - 5 - 6 = 8 ávexti_distributíón""0 eppla og 1 appelsínur"",3) -> 3 - 0 - 1 = 2 ávexti_distributíón""2 eppla og 3 appelsínur"", 100) -> 100 - 2 - 3 = 95 ávexti_distributíón""100 eppla og 120) "",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,isl_Latn,python,"
def pluck(arr):
    """"""""Gefnum röð sem táknar grein tré sem hefur ekki neikvæð heiltal hnúta er verkefni þitt að plokka einn af hnútum og skila honum. Plukkaður hnútur ætti að vera hnútur með minnsta jafnvel gildi. Ef fleiri hnútar með sama minnsta jafnvel gildi eru fundin skila hnútum sem hefur minnsta vísitölu. Plukkaður hnútur ætti að skila í lista, [small_value, vísitölu þess ], Ef það eru engin jafnvel gildi eða gefið röð er tóm, skila []. Dæmi 1: Innflutning: [4,2,3] Útflutning: [2, 1] Skýring: 2 hefur minnsta jafnvel gildi, og 2 hefur minnsta vísitölu. Dæmi 2: Innflutning: [1,2,3] Útflutning: [2, 1] Skýring: 2 hefur minnsta jafnvel gildi, og 2 hefur minnsta vísitölu. Dæmi 3: Innflutning: [] Útflutning: [4: 5, 3, 4, 2] Útflutning: 1 0, Útflutning: 0 * Hnútur sem hefur minnsta vísitölu, svo við munum velja fyrsta hnút, sem hefur tvö núll, en núll er þar. * lengd = 0 * Dæmi:""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,isl_Latn,python,"
def search(lst):
    '''Þú færð ekki tóman lista með jákvæðum heilum tölum. Sendu stærstu heiltöluna sem er meiri en núll og hefur tíðni sem er meiri en eða jafngildir gildi heiltölunnar sjálfrar. Tíðni heiltölunnar er hversu oft hún birtist á listanum. Ef slíkt gildi er ekki til, skilaðu -1. Dæmi: leitaðu [4, 1, 2, 2, 3, 1]) == 2 leitaðu [1, 2, 2, 3, 3, 3, 4, 4]) == 3 leitaðu [5, 5, 4, 4]) == -1 '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,isl_Latn,python,"
def strange_sort_list(lst):
    '''Gefin lista af heilum tölum, skilar lista í skrítinni röð. Skrítin röðun er þegar þú byrjar með lágmarksgildi, þá hámarksgildi af hinum heilum tölum, þá lágmarksgildi og svo framvegis. Dæmi: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,isl_Latn,python,"
def triangle_area(a, b, c):
    '''Gefin lengdir þriggja hliða þríhyrnings. Endurheimta svæði þríhyrningsins sem er afrætt á 2 tímamörk ef hliðarnar þrjár mynda gildan þríhyrning. Annars endurheimta -1 Þrjár hliðar gera gildan þríhyrning þegar uppsöfn hvaða tveggja hliða er meiri en þriðja hliðin. Dæmi: þríhyrningur_svæði{}3, 4, 5) == 6.00 þríhyrningur_svæði{}1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,isl_Latn,python,"
def will_it_fly(q,w):
    '''Skrifaðu hlutverk sem skilar True ef hlutinn q mun fljúga og False annars. Hluturinn q mun fljúga ef hann er jafnvægi (það er palindróm listi) og súm þátta hans er minni en eða jafnt hámarks mögulega þyngd w. Dæmi: will_it_fly (([1, 2], 5) â -> False # 1+2 er minna en hámarks mögulega þyngd, en það er ójafnvægi. will_it_fly (([3, 2, 3], 1) â -> False # það er jafnvægi, en 3+2+3 er meira en hámarks mögulegt þyngd. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 er minna en hámarks mögulegt þyngd, og það er jafnvægi. will_it_fly ((([3], â 5) -> True # 3 er minna en hámarks mögulegt þyngd, og það er jafnvægi '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,isl_Latn,python,"
def smallest_change(arr):
    """"""Í röð með heilum tölum, finndu lágmarksfjölda þátta sem þarf að breyta til að gera röðina palindróm. Palindróm röð er röð sem er lesin sömu leið fram og til baka. Í einni breytingu geturðu breytt einum þætti í annan þætti. Til dæmis: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,isl_Latn,python,"
def total_match(lst1, lst2):
    '''Skrifaðu hlutverk sem tekur við tveimur strengi og skilar þeim lista sem hefur færri stafi en hinn. Ef listarnir tveir hafa sömu stafi skilar þú fyrsta listann. Dæmi: total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4' , ['5']) -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,isl_Latn,python,"
def is_multiply_prime(a):
    """"""Skrifaðu hlutverk sem skilar sannri ef gefinn tala er margföldun 3 frumtal og fals annars. Að vita að (a) er minna en 100. Dæmi: is_multiply_prime(30) == Sannur 30 = 2 * 3 * 5 """"""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,isl_Latn,python,"
def is_simple_power(x, n):
    """"""Verkefni þitt er að skrifa hlutverk sem skilar sannleika ef tala x er einföld krafta af n og ósannleikur í öðrum tilvikum. x er einföld krafta af n ef n**int=x Til dæmis: er_einföld_krafta(1, 4) => sannur er_einföld_krafta(2, 2) => sannur er_einföld_krafta(8, 2) => sannur er_einföld_krafta(3, 2) => ósannleikur er_einföld_krafta_(3, 1) ósannleikur => er_einföld_krafta_(5, 3) => ósannleikur """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,isl_Latn,python,"
def iscube(a):
    '''Skrifaðu hlutverk sem tekur heiltal a og skilar True ef þetta er stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð við stærð'''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,isl_Latn,python,"
def hex_key(num):
    """"""Þú hefur fengið að skrifa hlutverk sem tekur við sextugtal sem streng og telur fjölda sextugtals stafa sem eru frumtal (prímtal eða frumtal er náttúruleg tala stærri en 1 sem er ekki afleiðsla tveggja minni náttúrulegra tals). Sextugtals stafir eru 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Prímtölur eru 2, 3, 5, 7, 11, 13, 17,... Svo þú þarft að ákvarða fjölda eftirfarandi stafa: 2, 3, 5, 7, B (= tíuletra 11), D (= tíuletra 13). Athugið: þú getur gert ráð fyrir að inngangurinn sé alltaf réttur eða tómur strengur, og tákn A,B,C,D,E,F eru alltaf stórstafir. Dæmi: Fyrir num = AB, útgangurinn ætti að vera num = 1. Fyrir num = 1077E, útgangurinn ætti að vera 2. Fyrir num = ""AB33"" AB1ED ætti að vera num = 4. ""BC""A = 6.0891234567 fyrir útganginn ætti að vera num = 2. ""2020DEF""""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,isl_Latn,python,"
def decimal_to_binary(decimal):
    """"""Þú færð tölur í tímanúmer og verkefni þitt er að umbreyta þeim í tvíeiningar. Funktiónin ætti að skila streng, þar sem hver stafur táknar tvíeiningar. Hver stafur í strengnum verður '0' eða '1'. Það verður aukalegt par stafa 'db' í upphafi og í lok strengsins.""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,isl_Latn,python,"
def is_happy(s):
    """"""Þú færð streng s. Verkefni þitt er að athuga hvort strengurinn sé ánægður eða ekki. Strengur er ánægður ef lengd hans er að minnsta kosti 3 og hverir 3 raðstafir eru mismunandi Til dæmis: is_happy(a) => False is_happy(aa) => False is_happy(abcd) => True is_happy(aabb) => False is_happy(adb) => True is_happy(xyy) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,isl_Latn,python,"
def numerical_letter_grade(grades):
    """"""Það er síðasta vika í háskóladeildinni og kennarinn þarf að gefa nemendum einkunnir. Kennarinn hefur verið að búa til sína eigin reiknifræði fyrir einkunnir. Eina vandamálið er að hún hefur misst kóðinn sem hún notaði til einkunnir. Hún hefur gefið þér lista yfir GPA fyrir suma nemendur og þú þarft að skrifa hlutverk sem getur gefið út lista yfir stafræna einkunnir með eftirfarandi töflu: GPA. Stafræna einkunn 4.0 A + > 3.7 A > 3.3 A- > 3.0 B + > 2.7 B- > 2.3 B- > 2.0 C + > 1.7 C > 1.3 C- > 1.0 D + > 0.7 D > 0.0 D- 0.0 E: Grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,isl_Latn,python,"
def prime_length(string):
    """"""Skrifaðu hlutverk sem tekur streng og skilar True ef strenglengdin er frumtal eða False annars Dæmi prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,isl_Latn,python,"
def starts_one_ends(n):
    """"""Gefið jákvæð heiltal n, skila tali n-síða jákvæðra heiltal sem byrja eða enda með 1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,isl_Latn,python,"
def solve(N):
    """"""Ef N er jákvæð heil tala, skilaðu heildarsöfn stafrana í tvírænum tölum. Dæmi Fyrir N = 1000, verður stafrasafn 1 útgáfa ætti að vera ""1"". Fyrir N = 150, verður stafrasafn 6 útgáfa ætti að vera ""110"". Fyrir N = 147, verður stafrasafn 12 útgáfa ætti að vera ""1100"". Breytilegir: @N heil tala Þrengingar: 0 â‰¤ N â‰¤ 10000. Útgáfa: streng af tvírænum tölum """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,isl_Latn,python,"
def add(lst):
    """"""Gefin er ótaldur listi með heilum tölum lst. Bæta við jöfnum þáttum sem eru á ólíkum vísitölum.. Dæmi: bætast við (([4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,isl_Latn,python,"
def anti_shuffle(s):
    """"""Skrifaðu hlutverk sem tekur streng og skilar skipulagðri útgáfu af því. Skipulagð útgáfa af streng er streng þar sem öll orð (aðskilin með rými) eru skipt út fyrir nýtt orð þar sem allir stafirnir eru raðaðir í uppstigandi röð miðað við ascii gildi. Athugið: Þú ættir að halda röð orða og tóm rými í setningunni. Til dæmis: anti_shuffle ((('Hi') skilar 'Hi' anti_shuffle (('hello') skilar 'ehllo' anti_shuffle (('Hello World!!!') skilar 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,isl_Latn,python,"
def get_row(lst, x):
    """"""Þú færð tvívíða gögn, sem er svipað og stafróður, en ólíkt stafróðum, getur hver röð innihaldið mismunandi fjölda dálka. Gefin lst og heilfjölda x, finndu heiltölur x á listanum og skila lista af tuples, [(x1, y1), (x2, y2) ...] þannig að hver tuple er samræmi - (röð, dálkar), byrja með 0. Raða samræmi í upphafi eftir röðum í vaxandi röð. Einnig raða samræmi röð eftir dálkum í lækkandi röð. Dæmi: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1] ], 1) == [0,0, 0, 0, 1, 4], 0 (1, 4), 0 (2, 5), (2, 0) get_(], 1) [] == [[röð]], [1, 2, 3]], [2, 2]]""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,isl_Latn,python,"
def sort_array(array):
    """"""Gefið er röð af óneikvæðum heilum tölum, skilaðu eintaki af gefnu röðinni eftir flokkun, þú munt raða gefnu röðinni í uppstigandi röð ef súman ((fyrsta vísitölugildi, síðasta vísitölugildi) er ólíðandi, eða raða henni í lækkandi röð ef súman ((fyrsta vísitölugildi, síðasta vísitölugildi) er jafnt. Athugið: * ekki breyta gefnu röðinni. Dæmi: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,isl_Latn,python,"
def encrypt(s):
    """"""Búðu til löggjöf sem tekur streng sem argument og skilar streng dulkóðuðu með stafrófinu sem er snúið. Stafrófið ætti að snúast þannig að stafirnir færist niður með tvö margfalda til tveggja staða. Til dæmis: dulkóða (('hi') skilar 'lm' dulkóða (('asdfghjkl') skilar 'ewhjklnop' dulkóða (('gf') skilar 'kj' dulkóða (('et') skilar 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,isl_Latn,python,"
def next_smallest(lst):
    """"""Þú færð lista af heilum tölum. Skrifaðu hlutverk next_smallest (() sem skilar 2. minnsta atriði listans. Skilar None ef það er enginn slíkur þáttur. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == Ekkert next_smallest (([1, 1]) == Ekkert """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,isl_Latn,python,"
def is_bored(S):
    """"""Þú færð orðastreng og verkefnið þitt er að telja fjölda leiðindanna. leiðind er setning sem byrjar á orðinu ""ég"". Setningar eru afmarkaðar með '.', '?' eða '! ' Til dæmis: >>> er_þreyttur(""Hello world"") 0 >>> er_þreyttur(""Himinn er bláur. Sólin skín. Ég elska þetta veður"") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,isl_Latn,python,"
def any_int(x, y, z):
    '''Búðu til hlutverk sem tekur 3 tölur. Gefur sannar ef ein af tölunum er jafnt og súm af hinum tveimur, og allar tölur eru heilorðin. Gefur ósann í öllum öðrum tilvikum. Dæmi: any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,isl_Latn,python,"
def encode(message):
    """"""Skrifaðu hlutverk sem tekur skilaboð og kóðar þannig að það skipti um stærð á öllum bókstafi, skiptist fyrir öll einhljóða í skilaboðunum með bókstaf sem birtist 2 stöðum fyrirfram einhljóða í ensku stafrófinu. Gera ráð fyrir aðeins bókstafi. Dæmi: >>> kóða (('próf') 'TGST' >>> kóða (('Þetta er skilaboð') 'tHKS KS C MGSSCGG' """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,isl_Latn,python,"

def skjkasdkd(lst):
    """"""Þú færð lista af heilum tölum. Þú þarft að finna stærsta frumgildi og skila samantali stafirnar. Dæmi: Fyrir lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] útkoman ætti að vera 10 Fyrir lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] útkoman ætti að vera 25 Fyrir lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] útkoman ætti að vera 13 Fyrir lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] útkoman ætti að vera 11 Fyrir lst = [0,81,12,3,21,1] útkoman ætti að vera 3 Fyrir lst = [0,1,8,2,1,7] útkoman ætti að vera 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,isl_Latn,python,"
def check_dict_case(dict):
    """"""Ef orðabók er gefinn skal skila True ef allir lyklar eru strengi í litlum bókstaf eða allir lyklar eru strengi í stórum bókstaf, annars skila False. Hlutverkið ætti að skila False ef gefið orðabók er tóm. Dæmi: check_dict_case{""a"":""apple"", ""b"":""banana""}) ætti að skila True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) ætti að skila False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) ætti að skila False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) ætti að skila False. check_dict_case{""NC"":""STATE"", ""ZIP"":""45"") ætti að skila True.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,isl_Latn,python,"
def count_up_to(n):
    """"""Settu í framkvæmd hlutverk sem tekur ekki neikvæða heiltal og skilar svið af fyrstu n heiltölum sem eru frumtal og minni en n. Til dæmis: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,isl_Latn,python,"
def multiply(a, b):
    """"""Fylgdu við hlutverkið sem tekur tvær heiltölur og skilar afurð einingarstafanna þeirra. Gerum ráð fyrir að innflutningurinn sé alltaf gildur. Dæmi: fjölga 148, 412) ætti að skila 16. fjölga 19 28 ætti að skila 72. fjölga 2020 1851) ætti að skila 0. fjölga 14-15 ætti að skila 20.""""""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,isl_Latn,python,"
def count_upper(s):
    """"""Gefið reitur s, telja fjölda stórstafa hljóðróm í jafnt vísitölur. Til dæmis: count_upper (('aBCdEf') skilar 1 count_upper (('abcdefg') skilar 0 count_upper (('dBBE') skilar 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,isl_Latn,python,"
def closest_integer(value):
    '''Búa til hlutverk sem tekur gildi (streng) sem táknar tölur og skilar næstinni heiltali til þeirra. Ef tölurnar eru jafn fjarlægðar frá tveimur heiltölum, þá afrundarðu hana frá núli. Dæmi >>> closest_integer ((""10"") 10 >>> closest_integer ((""15.3"") 15 Athugið: Að afrunda frá núli þýðir að ef gefnar tölur eru jafn fjarlægðar frá tveimur heiltölum, þá er sá sem þú ættir að skila sem er lengst frá núli. Fyrir dæmi ætti closest_integer "" ((14.5"") að skila 15 og closest_integer "" ((-14.5"") ætti að skila -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,isl_Latn,python,"
def make_a_pile(n):
    """"""Gefin jákvæð heiltal n, þarftu að búa til högg af n stigum steina. Fyrsta stig hefur n steina. Fjöldi steina í næsta stigi er: - næsta ólíðandi tala ef n er ólíðandi. - næsta jöfn tala ef n er jafnt.""""""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,isl_Latn,python,"
def words_string(s):
    """"""Þú færð streng af orðum sem eru aðskilin með kommum eða rýmum. Verkefni þitt er að skipta strengnum í orð og skila sviði orða. Til dæmis: words_string ((""Hæ, ég heiti John"") == [""Hæ"", ""mín"", ""nafn"", ""er"", ""John""] words_string ((""Einn, tveir, þrír, fjórir, fimm, sex"") == [""Einn"", ""tveir"", ""þrír"", ""fjögur"", ""fem"", ""sjötta""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,isl_Latn,python,"
def choose_num(x, y):
    """"""Þessi virkni tekur tvær jákvæðar tölur x og y og skilar stærsta jafna heiltali sem er í bilinu [x, y] innifalið. Ef það er engin slík tala, þá ætti virkjunin að skila -1. Til dæmis: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1 """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,isl_Latn,python,"
def rounded_avg(n, m):
    """"""Þú færð tvær jákvæðar heiltölur n og m og verkefnið þitt er að reikna meðaltal heiltölna frá n til m (þar með talið n og m). Hringdu svarið í næsta heiltöl og umbreyttu því í tvíeiningar. Ef n er stærri en m, skilaðu -1. Dæmi: rounded_avg ((1, 5) => ""0b11"" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => ""0b1111"" rounded_avg ((20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,isl_Latn,python,"
def unique_digits(x):
    """"""Gefið er lista yfir jákvæðar heiltölur x. skila flokkuðum lista yfir alla þá hluti sem ekki hafa neina jafna tölustafi. Athugið: Skilaður listi ætti að vera flokkuð í vaxandi röð. Til dæmis: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,isl_Latn,python,"
def by_length(arr):
    """"""Gefið röð heilorða, raða heilorðum sem eru á milli 1 og 9 innifalið, snúa niðurstöðuflokki, og þá skipta hver stafur með samsvarandi nafni frá ""Einn"", ""Tveir"", ""Þrír"", ""Fjórir"", ""Fimm"", ""Sex"", ""Sjö"", ""Eitt"", ""Nín"". Til dæmis: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> raða arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> aftur arrar -> [8, 5, 4, 3, 2, 2, 1, 1] skila [""Eight"", ""Fem"", ""Three"", ""Two"", ""Two"", ""One"", ""One""] Ef röðin er tóm, skila laus: arr = [] skila [] Ef röðin hefur einhverja undarlega númer, hunsa það: arr = [1, -1 , 55 -> arr - 1 , 55 -> [-1, 1] -> aftur arr = [51] - ['One' 1] """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,isl_Latn,python,"
def f(n):
    """"""Skilgreiningin f sem tekur n sem skilmerki og skilar lista af stærð n þannig að gildi þættisins í vísitölu i sé hlutfall i ef i er jafnt eða summa tölugjafa frá 1 til i annars. i byrjar frá 1. hlutfall i er margföldun tölugjafa frá 1 til i (1 * 2 * ... * i). Dæmi: f (((5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,isl_Latn,python,"
def even_odd_palindrome(n):
    """"""Ef gefinn er jákvæður heiltal n, skilaðu tuppli sem hefur fjölda jafnt og ójafntala heiltal palindróm sem falla innan sviðsins ((1, n), þ.e.a.s.""""""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,isl_Latn,python,"
def count_nums(arr):
    """"""Skrifaðu hlutverk count_nums sem tekur röð heiltalna og skilar fjölda þátta sem hefur númeratölu > 0. Ef tala er neikvæð, þá verður fyrsta undirritaða stafur hennar neikvæður: t.d. -123 hefur undirritaða tölustafi -1, 2 og 3. >>> count_nums[]) == 0 >>> count_nums[-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,isl_Latn,python,"
def move_one_ball(arr):
    """"""Við höfum röð 'arr' af N heilum tölum arr[1], arr[2], ..., arr[N].Tölurnar í röðinni verða raðaðar handahófi. Verkefni þitt er að ákvarða hvort hægt er að fá röð raðað í ófækkandi röð með því að framkvæma eftirfarandi aðgerð á gefnu röð: Þú hefur leyfi til að framkvæma hægri færslu aðgerð nokkurn fjölda sinnum. Ein hægri færslu aðgerð þýðir að færa alla þætti röðinni um eina stöðu í rétta átt. Síðasti þáttur röðinni verður fluttur til byrjunarstöðu í röðinni þ.e. 0th vísitölu. Ef það er hægt að fá raðaða röð með því að framkvæma aðgerðina hér að ofan þá skila True annars skila False. Ef gefið röð er tómt þá skila True. Athugasemd: Gefin listi er tryggður að hafa einstök þætti. Til dæmis: flytja_einn_einn ([3, 4, 5, 2]==============================================================================================================================================================================================================================================================================""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,isl_Latn,python,"
def exchange(lst1, lst2):
    """"""Í þessu vandamáli, þú munt framkvæma hlutverk sem tekur tvo lista af tölum, og ákveður hvort það er hægt að framkvæma skipti á þætti milli þeirra til að gera lst1 lista af aðeins jafnvel tölur. Það er engin takmörk á fjölda skipt þætti milli lst1 og lst2. Ef það er hægt að skipta þætti milli lst1 og lst2 til að gera alla þætti lst1 til að vera jafnvel, skila ""JÁ"". Annars, skila ""NEI"". Til dæmis: skiptum [(1, 2, 3, 4], [1, 2, 3, 4]) => ""JÁ"" skiptum [(1, 2, 3, 4], [1, 5, 3, 4]) => ""NEI"" Það er gert ráð fyrir að innlögin verða ekki tóm. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,isl_Latn,python,"
def histogram(test):
    """"""Ef strengi er með litla bókstafi með rými á milli skila við orðabók með bókstafi með flestum endurtekningum og með viðkomandi tali. Ef fleiri stafir hafa sama fyrirkomulag skila við öllum þeim. Dæmi: histogram (('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram (('a b b a') == {'a': 2, 'b': 2} histogram (('a b c a b') == {'a': 2, 'b': 2} histogram (('b b a b') == {'b 4}: histogram (('a b') == {'b 4}) == {} """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,isl_Latn,python,"
def reverse_delete(s,c):
    """"""Verkefni Við fáum tvær strengur s og c, þú þarft að eyða öllum stafi í s sem eru jafngildir einhverjum stafi í c og athuga hvort niðurstaðan strengur er palindrome. Strengur er kallað palindrome ef það les sama afturábak og fram. Þú ættir að skila tuple innihalda niðurstaða strengur og True/False fyrir athugun. Dæmi fyrir s = ""abcde"", c = ""ae"", niðurstaðan ætti að vera ('bcd', False) Fyrir s = ""abcdef"", c = ""b"" niðurstaðan ætti að vera ('acdef', False) Fyrir s = ""abcdedcba"", c = ""ab"", niðurstaðan ætti að vera ('cdedc', True)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,isl_Latn,python,"
def odd_count(lst):
    """"""Gefið er lista af strengjum, þar sem hver strengur samanstendur aðeins af tölustafum, skila lista. Hver hlutur i af útgáfunni ætti að vera ""fjöldi ólíkra þátta í streng i innleggsins"". þar sem öll i ætti að vera skipt út fyrir fjölda ólíkra stafa í i'th streng innleggsins. >>> odd_count['1234567']) [""fjöldi ólíkra þátta 4n str4ng 4 af 4nput.""] >>> odd_count['3',""111111""]) [""fjöldi ólíkra þátta 1n str1ng 1 af 1nput. "", ""fjöldi ólíkra þátta 8n str8ng 8 af 8nput.""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,isl_Latn,python,"
def minSubArraySum(nums):
    """"""Ef gefin er röð heilrétta n, skal finna lágmarksupphæð hvers konar ótýrs undirröð af n. Dæmi minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,isl_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Þú færð rétthvíga ret af brunnum. Hver röð táknar eina brunn og hver 1 í röð táknar eina einingu vatns. Hver brunnur hefur samsvarandi öskju sem hægt er að nota til að draga vatn úr honum og allar öskjur hafa sama getu. Verkefni þitt er að nota öskjurnar til að tæma brunnana. Útgang fjölda sinnum sem þú þarft að lækka öskjurnar. Dæmi 1: Innborð: ret: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Útgang: Dæmi 6: Innborð: ret: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 Útgang: 5 Dæmi 5: [[:0,0,0], [0,0]] bucket_capacity: 5 Útgang: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,isl_Latn,python,"
def sort_array(arr):
    """"""Í þessu Kata, þú þarft að raða röð af non-negative heiltal eftir fjölda einnar í tvíeiningarmyndun þeirra í uppstigandi röð. Fyrir svipaðan fjölda einnar, raða miðað við tímatal gildi. Það verður að vera framkvæmt eins og þetta: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,isl_Latn,python,"
def select_words(s, n):
    """"""Ef þú hefur streng s og náttúrulega tölu n, hefurðu fengið að framkvæma hlutverk sem skilar lista yfir öll orð úr streng s sem innihalda nákvæmlega n samhljóða, til þess að þessi orð birtist í streng s. Ef strengurinn s er tómur þá ætti hlutverkið að skila tómum lista. Athugið: þú getur gert ráð fyrir að innleiðandi strengur innihaldi aðeins stafi og rými. Dæmi: select_words ""Mary had a little lamb"", 4) ==> [""little""] select_words ""Mary had a little lamb"", 3) ==> [""Mary"", ""lamb""] select_words ""simple white space"", 2) ==> [] select_words ""Hello world"", 4) ==> [""world""] select_words ""Uncle sam"", 3) ==> [""Uncle""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,isl_Latn,python,"
def get_closest_vowel(word):
    """"""Þú færð orð. Verkefni þitt er að finna næstann tónleika sem stendur á milli tveggja samhljóða frá hægri hlið orðsins (stærri og minni bókstaf). Tónlist í upphafi og lok telst ekki. Sendu tóman streng ef þú fann ekki neitt tónleika uppfyllti skilyrði hér að ofan. Þú getur gert ráð fyrir að strengi gefin innihaldi enska bókstaf aðeins. Dæmi: get_closest_vowel (((""jógúrt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" ((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,isl_Latn,python,"
def match_parens(lst):
    '''Þú færð lista yfir tvær strengur, báðar strengur eru aðeins opnar brúnir '(' eða lokaðar brúnir ') '. Verkefni þitt er að athuga hvort hægt er að tengja tvær strengur í einhverri röð, að afleiðingin verði góð. Strengur S er talinn góður ef og aðeins ef allar brúnir í S eru í jafnvægi. Til dæmis: Strengurinn '((()) 'er góður, en strengurinn '())' er ekki. Sendu 'Já' ef það er leið til að gera góða streng og skila 'Nei' annars. Dæmi: match_parens[('() ', ') ']) == 'Já' match_parens[(') ', ') ']) == 'Nei' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,isl_Latn,python,"
def maximum(arr, k):
    """"""Gefið er röð með heilum tölum og jákvæða heilstölur k, skilaðu röðinni með lengd k með hámarks k tölum í röðinni. Dæmi1: Input: arr = [-3, -4, 5], k = 3 Útgang: [-4, -3, 5] Dæmi2: Input: arr = [4, -4, 4], k = 2 Útgang: [4, 4] Dæmi3: Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Útgang: [2] Athugið: 1. Lengd röðinni verður á bilinu [1, 1000]. 2. Elementefnin í röðinni verða á bilinu [-1000, 1000].""""""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,isl_Latn,python,"
def solution(lst):
    """"""Gefið er ótaldur listi með heilum tölum, skilaðu uppsöfnun allra ólíkra þátta sem eru í jafnt stöðum.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,isl_Latn,python,"
def add_elements(arr, k):
    """"""Gefið er ekki tómt röð af heilum tölum arr og heilum tölum k, skilaðu uppsöfnunum með að hámarki tveimur tölustafum frá fyrstu k þáttunum í arr. Dæmi: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # sum 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)""""""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,isl_Latn,python,"
def get_odd_collatz(n):
    """"""Ef við fáum jákvæða heiltal n, skila við flokkuðum lista sem hefur ólíkar tölur í Collatz röð. Collatz-gátan er gátur í stærðfræði sem varðar röð sem skilgreind er sem hér segir: byrjaðu með hvaða jákvæða heiltal n. Þá er hver frestur fenginn frá fyrri fresti sem hér segir: ef fyrri frestur er jafnháttur er næsti frestur einn helmingur fyrri frests. Ef fyrri frestur er ólíkur er næsti frestur 3 sinnum fyrri frestur auk 1. Gátan er sú að sama hvaða gildi n, þá mun röðin alltaf ná 1.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,isl_Latn,python,"
def valid_date(date):
    """"""Þú þarft að skrifa hlutverk sem staðfestir ákveðinn dagsetningarstreng og skilar True ef dagsetningin er gild annars False. Dagsetningin er gild ef allar eftirfarandi reglur eru uppfyllt: 1. dagsetningarstrengurinn er ekki tómur. 2. fjöldi daga er ekki minna en 1 eða meiri en 31 daga fyrir mánuði 1,3,5,7,8,10,12. Og fjöldi daga er ekki minna en 1 eða meiri en 30 daga fyrir mánuði 4,6,9,11. Og fjöldi daga er ekki minna en 1 eða meiri en 29 fyrir mánuðinn 2. 3. mánuðirnir ættu ekki að vera minna en 1 eða meiri en 12. 4. dagsetningin ætti að vera í sniði: mm-dd-yyyy til dæmis: valid_date (e.g.""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,isl_Latn,python,"
def split_words(txt):
    '''Gefið streng af orðum, skila lista yfir orð skipt á hvítu pláss, ef engin hvítu pláss er til í texta sem þú ættir að skipta á kommum ',' ef engin kommur eru til þá ættir þú að skila fjölda smámáls stafa með ólíkum röð í stafrófinu, ord ((('a') = 0, ord ((('b') = 1, ... ord ((('z') = 25 Dæmi split_words ((""Hello world!"") â -> [""Hello"", ""world!""] split_words ((""Hello,world!"") â -> [""Hello"", ""world!"" split_words"")'''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,isl_Latn,python,"
def is_sorted(lst):
    '''Ef þú færð lista af tölum skaltu skila því hvort þær eru raðaðar í uppstigandi röð. Ef lista er með fleiri en eitt eintak af sömu tölum skaltu skila False. Gera ráð fyrir að neinar neikvæðar tölur séu og aðeins heiltölur. Dæmi er_sorted (e.'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,isl_Latn,python,"
def intersection(interval1, interval2):
    """"""Þú færð tvö bil, þar sem hvert bil er pari af heilum tölum. Til dæmis, bil = (byrjun, endir) = (1, 2). Gefin bil eru lokað sem þýðir að bil (byrjun, endir) inniheldur bæði byrjun og endir. Fyrir hvert gefið bil, það er gert ráð fyrir að byrjun þess er minni eða jafnt endir þess. Verkefni þitt er að ákvarða hvort lengd á milli þessara tveggja bil er frumtal. Dæmi, á millibil (1, 3), (2, 4) er (2, 3) sem lengd hennar er 1, sem er ekki frumtal. Ef lengd á millibil er frumtal, skila ""JÁ"", annars skila ""NEI"". Ef tvö bil ekki skera, skila ""NEI"". [input/output] sýnishorn: millibil (((1, 2), (2, 3) ==> ""miðil-1, ((1), 4) ==> ""miðil"", (0, ""NO"", 5), ((1), ==> ""ES"", (-3, 5) ))""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,isl_Latn,python,"
def prod_signs(arr):
    """"""Þú færð röð af heilum tölum og þú þarft að skila summanum af stærðum heilra talna margfaldað með vörum allra tákna hvers númer í röðinni, sem er fulltrúi 1, -1 eða 0. Athugið: skila Ekkert fyrir tómt röð. Dæmi: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == Ekkert""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,isl_Latn,python,"
def minPath(grid, k):
    """"""Í kerti með N röðum og N dálkum (N >= 2) og jákvæðri heiltali k, inniheldur hver klefi kerfisins gildi. Hver heiltali í bilinu [1, N * N] birtist nákvæmlega einu sinni á klefunum kerfisins. Þú verður að finna lágmarksleið lengd k í kerfinu. Þú getur byrjað frá hvaða klefi sem er og í hverju skrefi getur þú farið í hverja nágranna klefi, með öðrum orðum, þú getur farið í klefi sem deila kant með þér núverandi klefi. Athugið að leið lengd k þýðir að heimsækja nákvæmlega k klefi (ekki endilega mismunandi). Þú getur ekki farið út úr kerfinu. Leið A (lengd k) er talin minni en leið B (lengd k) ef eftir að hafa raðað lista yfir gildin sem A og B fara í gegnum (ég skulum kalla þau l_stA og l_stB), l_stA er lexicographically minna en l_stB, með öðrum orðum, með heiltali í kerfinu. Þú getur byrjað frá hvaða klefi sem er og í hverju skrefi geturðuðuðuðu á hverri sem er, með öðrum orðum, þú getur farið í hvaða klefi sem er með kant með þér núverandi klefi.""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,isl_Latn,python,"
def tri(n):
    """"""Fibonacci-söð er skilgreind með endurteknum: tri(1) = 3 tri(n) = 1 + n / 2, ef n er jafnt. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ef n er ólík. Til dæmis: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Þú færð neikvæða heiltal n, þú þarft að skila lista yfir fyrstu n + 1 tölur Tribonacci-söðvarinnar. Dæmi: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,isl_Latn,python,"
def digits(n):
    """"""Gefið er jákvæð heiltal n, skilaðu afurðinni af ólíkum tölustafum. Skilaðu 0 ef allir tölustafir eru jafngirnir. Til dæmis: tölustafir""""""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,isl_Latn,python,"
def is_nested(string):
    '''Búðu til hlutverk sem tekur streng sem inntak sem inniheldur aðeins fermetra brúnkur. Hlutverkið ætti að skila sannri ef og aðeins ef það er gild undirfylgni af brúnkum þar sem að minnsta kosti einn brúnkur í undirfylgni er nested. is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]]]]]]]]]]'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,isl_Latn,python,"

def sum_squares(lst):
    """"""Þú færð lista af tölum. Þú þarft að skila uppsöfn ferfætis tölur í gefnum lista, hringja hvert atriði á listanum til efri int ((Loft) fyrst. Dæmi: Fyrir lst = [1,2,3] útgáfa ætti að vera 14 Fyrir lst = [1,4,9] útgáfa ætti að vera 98 Fyrir lst = [1,3,5,7] útgáfa ætti að vera 84 Fyrir lst = [1.4,4.2,0] útgáfa ætti að vera 29 Fyrir lst = [-2.4,1,1] útgáfa ætti að vera 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,isl_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Búðu til hlutverk sem skilar True ef síðasta stafur af ákveðinni streng er stafrófsstafur og er ekki hluti af orði, og False annars. Athugið: ""orð"" er hópur stafa aðskilin með rými. Dæmi: check_if_last_char_is_a_letter"" ""apple pie"") â -> False check_if_last_char_is_a_letter"" ""apple pi e"") â -> True check_if_last_char_is_a_letter"" ""apple pi e"") â -> False check_if_last_char_is_a_letter"" ""apple pi e"") â -> False check_if_last_char_is_a_letter"" ""'''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,isl_Latn,python,"
def can_arrange(arr):
    """"""Búðu til hlutverk sem skilar stærstu vísitölu þættis sem er ekki stærri en eða jafnt þættinum sem er rétt á undan því. Ef enginn þættir er til þá skilar -1. Gefið svið mun ekki innihalda tvöföld gildi. Dæmi: can_arrange{}[1,2,4,3,5]) = 3 can_arrange{}[1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,isl_Latn,python,"
def largest_smallest_integers(lst):
    '''Búa til hlutverk sem skilar tuppli (a, b), þar sem a er stærsta neikvæða heildartalið og b er minnsta jákvæða heildartalið á listanum. Ef það eru engar neikvæðar eða jákvæðar heildartali skilar þú þeim sem Ekkert. Dæmi: stærsta_minstu_heildartalið[2, 4, 1, 3, 5, 7]) == (Engin, 1) stærsta_minstu_heildartalið([]) == (Engin, Ekkert) stærsta_minstu_heildartalið[0]) == (Engin, Ekkert)'''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,isl_Latn,python,"
def compare_one(a, b):
    """"""Búðu til hlutverk sem tekur heilstölur, floats eða strengja sem tákna rauntölur og skilar stærri breytunni í tilteknum breytustýpi. Skilar Ekkert ef gildi eru jöfn. Athugið: Ef rauntölu er táknað sem strengur gæti sveiflukreppan verið . eða , compare_one{1, 2.5) â -> 2.5 compare_one{1, ""2,3"") â -> ""2,3"" compare_one{5,1"", ""6"") â -> ""6"" compare_one{1"", 1) â -> Ekkert """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,isl_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Gera mat á hvort hægt sé að skrifa n sem sameiningu nákvæmlega 4 jákvæðra jafna talna. Dæmi:""""""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,isl_Latn,python,"
def special_factorial(n):
    """"""Brasilíska factorial er skilgreind sem: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! þar sem n > 0 Til dæmis: >>> special_factorial ((4) 288 Virkið mun fá heiltal sem inngangur og ætti að skila sérstökum factorial þessarar heiltali. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,isl_Latn,python,"
def fix_spaces(text):
    """"""_Dæmi-3 fyrir skal skipta öllum rýmum í honum út fyrir undirstrika og ef strengi hefur fleiri en 2 samfellda rýmum skal skipta öllum samfelldum rýmum út fyrir - fix_spaces ((""Example"") == ""Example"" fix_spaces ((""Example1"") == ""Example_1"" fix_spaces (((""Example2"") == ""_Example_2"" fix_spaces ((""Example 3"") == ""_Example-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,isl_Latn,python,"
def file_name_check(file_name):
    """"""Búðu til hlutverk sem tekur streng sem táknar nafn skráar og skilar ""Já"" ef nafn skráarinnar er gilt og skilar ""Nei"" annars. Nafn skráar er talið gilt ef og aðeins ef öll eftirfarandi skilyrði eru uppfyllt: - Það ætti ekki að vera fleiri en þrír tölustafir ('0'-'9') í nafni skráarinnar. - Nafn skráarinnar inniheldur nákvæmlega einn punktur '.' - Undirstrengurinn fyrir punktinum ætti ekki að vera tómur og hann ætti að byrja með bókstafi frá latneska bókstafanum ('a'-'z' og 'A'Z'). - Undirstrengurinn eftir punktinum ætti að vera einn af þessum: ['txt', 'exe', 'll'd] Dæmi: file_name_check""{example.txt.} # => 'Já' file_name_check""{example.dll.1} => 'Nei' (#' (nafn skráarinnar ætti að byrja með latneska bókstafi)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,isl_Latn,python,"


def sum_squares(lst):
    """""""" Þessi virkni tekur lista af heilum tölum. Fyrir allar færslur á listanum skal virkjunin kvadera heilorða færslu ef vísitölur hennar eru margfaldar 3 og þéttara heilorða færslu ef vísitölur hennar eru margfaldar 4 en ekki margfaldar 3. Virkjunin mun ekki breyta færslum á listanum sem vísitölur eru ekki margfaldar 3 eða 4. Virkjunin skal síðan skila heildarfjölum allra færslna. Dæmi: Fyrir lst = [1,2,3] útkoman ætti að vera 6 Fyrir lst = [] útkoman ætti að vera 0 Fyrir lst = [-1,-5,2,-1,-5] útkoman ætti að vera -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,isl_Latn,python,"
def words_in_sentence(sentence):
    """"""Þú færð streng sem táknar setningu, setningin inniheldur nokkur orð aðskilin með bili, og þú þarft að skila streng sem inniheldur orð úr upprunalegu setningunni, sem lengdir eru frumtal, raðsetning orða í nýju strengnum ætti að vera sama og upprunalegu.""""""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,isl_Latn,python,"
def simplify(x, n):
    """"""Verkefni þitt er að framkvæma hlutverk sem einfaldar tjáninguna x * n. Hlutverkið skilar True ef x * n er heil tala og False annars. Bæði x og n eru strengja sýnishorn brot, og hafa eftirfarandi sniði, <tölumaður>/<nefndarmaður> þar sem bæði telumaður og nefndarmaður eru jákvæðar heil tölur. Þú getur gert ráð fyrir að x og n séu gild brot, og hafa ekki núll sem nefndarmaður. einfaldar "" 1/5 "", ""5/1"") = Sannur einfaldar "" 1/6 "", ""2/1"") = False einfaldar "" 7/10 "", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,isl_Latn,python,"
def order_by_points(nums):
    """"""Skrifaðu hlutverk sem raðar upptalningu heildartala í uppstigandi röð eftir númeratölu þeirra. athuga: ef það eru nokkrir hlutir með svipaða númeratölu, raða þeim eftir vísitölu þeirra í upprunalegum lista.""""""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,isl_Latn,python,"
def specialFilter(nums):
    """"""Skrifaðu hlutverk sem tekur töflur af tölum sem inngangur og skilar fjölda þátta í töflunni sem eru stærri en 10 og bæði fyrsta og síðasta stafur tölu eru ólífrar (1, 3, 5, 7, 9). Til dæmis: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,isl_Latn,python,"
def get_max_triples(n):
    """"""Þú færð jákvæða heiltal n. Þú verður að búa til heiltal svið a af lengd n. Fyrir hvert i (1 ‰¤ i ‰¤ n), gildið af a[i] = i * i - i + 1.""""""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,isl_Latn,python,"
def bf(planet1, planet2):
    '''Það eru átta plánetur í sólkerfinu: næst nálægasta sólinni er Merkúr, næst er Venus, svo Jörðin, Mars, Júpíter, Satúrnus, Úranus, Neptúnus. Skrifaðu hlutverk sem tekur tvö plánetunafn sem strengir planet1 og planet2. Hlutverkið ætti að skila tómum tuple sem inniheldur allar plánetur sem eru á braut milli braut planets1 og braut planets2, flokkaðar eftir nálægð við sólina. Hlutverkið ætti að skila tómum tuple ef planet1 eða planet2 eru ekki réttar plánetunafn. Dæmi bf""(Júpíter"", ""Neptúnus"") ==> (""Saturn"", ""Uranus"") bf(""Jörðin"", ""Merkuríus"") ==> (""Venus"") bf (((""Mercury"", ""Uranus"") ==> (""Venus"", ""Jörðin"", ""Mars"", ""Júpíter"", ""Sn"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,isl_Latn,python,"
def sorted_list_sum(lst):
    """"""Skrifaðu hlutverk sem tekur við lista af strengjum sem viðmið, eyðir strengjum sem hafa ólíkar lengdir frá því og skilar niðurstöðulistanum með raðaðri röð. Listið er alltaf listi af strengjum og aldrei röð tölur og það getur innihaldið endurtekningar. Raðsetning listans ætti að vera hækkandi eftir lengd hvers orðs og þú ættir að skila listanum raðaðri eftir þeirri reglu. Ef tvö orð eru jafnlangir, raðaðu listanum stafrófsröð.""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,isl_Latn,python,"
def x_or_y(n, x, y):
    """"""Einfalt forrit sem ætti að skila gildi x ef n er frumtal og ætti að skila gildi y annars. Dæmi: fyrir x_or_y(7, 34, 12) == 34 fyrir x_or_y(15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,isl_Latn,python,"
def double_the_difference(lst):
    '''Gefið er lista af tölum, skilaðu uppsöfnun ferli tölur á listanum sem eru ólíkar. Ignoreraðu tölur sem eru neikvæðar eða ekki heiltölur. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Ef innleggslista er tóm, skilaðu 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,isl_Latn,python,"
def compare(game,guess):
    """"""Ég held að við munum öll eftir þeirri tilfinningu þegar niðurstaða einhvers langþráðs atburðar er loksins þekkt. Tilfinningar og hugsanir sem þú hefur á þeim tíma eru örugglega þess virði að taka til og bera saman. Verkefni þitt er að ákvarða hvort manneskja hafi giskað rétt á niðurstöður fjölda samræminga. Þú færð tvö svið af einkunnum og giska á jafnri lengd, þar sem hver vísitölur sýnir samræmi. Sendu svið af sömu lengd sem gefur til kynna hversu langt frá hverri giska var. Ef þeir hafa giskað rétt er gildið 0, og ef ekki, er gildið algjörur munur á giska og einkunn.""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,isl_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Þú færð nafn á bekk (streng) og lista yfir viðbætur. Viðbæturnar eru notaðar til að hlaða viðbótarflokka í bekkinn. Styrkur viðbótanna er eftirfarandi: Láttu CAP vera fjölda stórstafa í nafni viðbótanna og SM vera fjölda smámáta í nafni viðbótanna, styrkur er gefið með brotinu CAP - SM. Þú ættir að finna sterkasta viðbótina og skila streng í þessu sniði: ClassName.StrongestExtensionName. Ef það eru tvær eða fleiri viðbætur með sömu styrk, ættir þú að velja þá sem kemur fyrst á listanum. Til dæmis, ef þú færð ""Slices"" sem bekk og lista yfir viðbætur: ['SEviRNGSliCes', 'Cheese', 'StuFfed'] þá ættir þú að skila 'Slices.SEviRNGSliCes' þar sem 'SviRNGSliCes' er sterkasta viðbótinn.""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,isl_Latn,python,"
def cycpattern_check(a , b):
    """"""Þú færð tvö orð. Þú þarft að skila sannar ef annað orðið eða einhver af snúningum þess er undirstrengur í fyrsta orði cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,isl_Latn,python,"
def even_odd_count(num):
    """"""Gefin heil tala. skilar tuple sem hefur fjölda jafnt og ójafn stafir í senn. Dæmi: jafnvel_ójafn_tal(-12) ==> (1, 1) jafnvel_ójafn_tal(123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,isl_Latn,python,"
def int_to_mini_roman(number):
    """"""Gefin jákvæð heiltal, fáðu rómverska tölutöluna sem hliðstæða strengi og skilaðu henni í litlum bókstafi.""""""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,isl_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Gefin lengdir þriggja hliða þríhyrnings. Gefur sannar ef hliðarnar þrjár mynda rétthvíta þríhyrning, falskt annars. Réttvinkul þríhyrningur er þríhyrningur þar sem einn horn er rétthvíta eða 90 gráður. Dæmi: rétt_horn_þríhyrningur ((3, 4, 5) == Sannur rétt_þríhyrningur ((1, 2, 3) == Falskt '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,isl_Latn,python,"
def find_max(words):
    """"""Skrifaðu hlutverk sem tekur við lista af strengjum. Listið inniheldur mismunandi orð. Skila orði með hámarksfjölda einstaka stafa. Ef fleiri strengir hafa hámarksfjölda einstaka stafa, skila þeim sem kemur fyrst í orðasafnaraðferð.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,isl_Latn,python,"
def eat(number, need, remaining):
    """"""Þú ert svöng kanína og hefur þegar borðað ákveðinn fjölda gulrætur, en nú þarftu að borða fleiri gulrætur til að ljúka máltíðum dagsins. þú ættir að skila svif [almenni fjölda borðaðra gulrætur eftir máltíðir þínar, fjölda gulrætur eftir eftir máltíðir þínar ] ef það eru ekki nóg eftirbært gulrætur, þú munt borða alla eftirbært gulrætur, en verður samt svöng. Dæmi: * borða ((5, 6, 10) -> [11, 4] * borða ((4, 8, 9) -> [12, 1] * borða ((1, 10, 10) -> [11, 0] * borða ((2, 11, 5) -> [7, 0] Breytist: @fjölda: heil númer af gulrætur sem þú hefur borðað. @þörf: heil númer af gulrætur sem þú þarft að borða. @remaining: heil númer af eftirbært gulrætur í lager Constrain: * 0 = <= 0 * 0 = <= 1000 * 0 = <= 1000 <= 0 = 0""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,isl_Latn,python,"
def do_algebra(operator, operand):
    """"""Given two lists operator, and operand. Fyrsti listinn hefur grunn algebru aðgerðir, og seinni listinn er listi af heilum tölum. Notaðu tvo gefna lista til að byggja algebru tjáningu og skila mati á þessari tjáningu. Grunn algebru aðgerðir: Viðbót (+) Frádráttur ( - ) Margföldun ( *) Gólf deild ( // ) Exponentiation ( ** Dæmi ): aðgerð['+', '*', '-'] röð = [2, 3, 4, 5] niðurstaða = 2 + 3 * 4 - 5 => niðurstaða = 9 Athugið: Lengd listans af aðgerð er jafnt lengd listans af aðgerð mínus einn. Aðgerð er listi af óneikvæðum heilum tölum. Aðgerð hefur að minnsta kosti einn aðgerð lista, og aðgerð lista hefur að minnsta kosti tvo aðgerð.""""""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,isl_Latn,python,"
def solve(s):
    """"""Ef þú ert með streng s. Ef s[i] er bókstaf skaltu snúa fallmyndinni frá neðri til efri eða öfugt, annars skaltu halda því eins og það er. Ef strengurinn inniheldur engar bókstafir skaltu snúa strengnum.""""""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,isl_Latn,python,"
def string_to_md5(text):
    """"""Ef strengi er ""text"" skal skila md5 hash-snúrunni. Ef ""text"" er tómur strengi skal skila None. >>> string_to_md5 (('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,isl_Latn,python,"
def generate_integers(a, b):
    """"""Gefin tvær jákvæðar heiltölur a og b, skila jafnmörgum tölustafum á milli a og b, í vaxandi röð. Til dæmis: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
