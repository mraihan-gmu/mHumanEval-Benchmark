[{"task_id":"HumanEval_0","nl":"yor_Latn","pl":"rb","prompt":"ì ì ì ì ì ì ì ì ì ì ìṢayẹwo boya ninu awọn ti a fi fun awọn nọmba, ni o wa eyikeyi meji awọn nọmba sunmọ si ọkan miran ju # >>> has_close_elements.call([1.0, 2.0, 3.0], 0.5)\n# false\n# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# true\ndef has_close_elements(numbers, threshold)\n","canonical_solution":"def has_close_elements(numbers, threshold)\n  numbers.combination(2).any? { |a, b| (a - b).abs < threshold }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_has_close_elements\n    candidate = method(:has_close_elements)\n    assert_equal(true, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))\n    assert_equal(false, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))\n    assert_equal(true, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95))\n    assert_equal(false, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8))\n    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1))\n    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0))\n    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))\n  end\nend\n"},{"task_id":"HumanEval_1","nl":"yor_Latn","pl":"rb","prompt":"Maṣe fi àyè kankan sínú ìlà ìkọsílẹ̀ ìkọsílẹ̀.Àwọn àwùjọ tó yàtọ̀ síra wọn wà ní ìmúrasílẹ̀ (ìdìpọ̀ ọ̀kọ̀ọ̀kan tí ó wà ní ṣíṣí ni a ti pa tì dáadáa) wọn kò sì ní kó ara wọn sínú ara wọn.Yọ àwọn àwùjọ wọ̀nyí sí àwọn ìlà ọ̀tọ̀ọ̀tọ̀ kí o sì dá àwọn ìlà wọ̀nyí padà.Ohun tí a fi wọlé sí iṣẹ́ yìí jẹ́ ìlà tí ó ní àwọn ẹgbẹ́ ọ̀pọ̀lọpọ̀ ti àwọn àlééfà tí a fi sínú.# >>> separate_paren_groups.call(\"( ) (( )) (( )( ))\")\n# [\"()\", \"(())\", \"(()())\"]\ndef separate_paren_groups(paren_string)\n","canonical_solution":"def separate_paren_groups(paren_string)\n  # Remove spaces from the string\n  paren_string = paren_string.gsub(\" \", \"\")\n  \n  result = []\n  current_group = \"\"\n  balance = 0\n\n  paren_string.each_char do |char|\n    current_group += char\n    balance += 1 if char == '('\n    balance -= 1 if char == ')'\n\n    if balance == 0 && !current_group.empty?\n      result << current_group\n      current_group = \"\"\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_separate_paren_groups\n    candidate = method(:separate_paren_groups)\n    assert_equal([\"(()())\", \"((()))\", \"()\", \"((())()())\"], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([\"()\", \"(())\", \"((()))\", \"(((())))\"], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([\"(()(())((())))\"], candidate.call(\"(()(())((())))\"))\n    assert_equal([\"()\", \"(())\", \"(()())\"], candidate.call(\"( ) (( )) (( )( ))\"))\n  end\nend\n"},{"task_id":"HumanEval_2","nl":"yor_Latn","pl":"rb","prompt":"Yípadà apá àpapọ̀ iye tí ó wà ní ìsàlẹ̀.(apá tó kù á máa kéré ju ìkan lọ).ati ipin iye (iye ti o tobi julọ ti o kere ju nọmba ti a fun) ati awọn decimals Ti a ba fun ni nọmba ti o ni iyatọ iyatọ, a le tú u sinu # >>> truncate_number.call(3.5)\n# 0.5\ndef truncate_number(number)\n","canonical_solution":"def truncate_number(number)\n  number - number.to_i\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_truncate_number\n    candidate = method(:truncate_number)\n    assert_equal(0.5, candidate.call(3.5))\n    assert_equal(0.25, candidate.call(1.25))\n    assert_equal(0.0, candidate.call(123.0))\n  end\nend\n"},{"task_id":"HumanEval_3","nl":"yor_Latn","pl":"rb","prompt":"ní àkókò yẹn, iṣẹ́ náà yóò padà sí òtítọ́. bí bẹ́ẹ̀ kọ́, yóò padà sí irọ́.ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ìO ni a fun ni awọn iṣiro ti idogo ati awọn iṣẹ yiyọ kuro lori akọọlẹ banki kan ti o bẹrẹ pẹlu # >>> below_zero.call([1, 2, 3])\n# false\n# >>> below_zero.call([1, 2, -4, 5])\n# true\ndef below_zero(operations)\n","canonical_solution":"def below_zero(operations)\n  balance = 0\n  operations.each do |operation|\n    balance += operation\n    return true if balance < 0\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_zero\n    candidate = method(:below_zero)\n    assert_equal(false, candidate.call([]))\n    assert_equal(false, candidate.call([1, 2, -3, 1, 2, -3]))\n    assert_equal(true, candidate.call([1, 2, -4, 5, 6]))\n    assert_equal(false, candidate.call([1, -1, 2, -2, 5, -5, 4, -4]))\n    assert_equal(true, candidate.call([1, -1, 2, -2, 5, -5, 4, -5]))\n    assert_equal(true, candidate.call([1, -2, 2, -2, 5, -5, 4, -4]))\n  end\nend\n"},{"task_id":"HumanEval_4","nl":"yor_Latn","pl":"rb","prompt":"MAD = apapọ ∙ x - x_mean ∙ohun kan ati aarin (ohun ti o jẹ ninu ọran yii): Mean Absolute Deviation ni apapọ iyatọ abinibi laarin kọọkan ó tó nǹkan bí ìlàjì ìsọfúnni yìí. Fun awọn nọmba ti a fi sinu, ṣe iṣiro Ìyípadà Gbogbogbo Gbogbogbo # >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])\n# 1.0\ndef mean_absolute_deviation(numbers)\n","canonical_solution":"def mean_absolute_deviation(numbers)\n  mean = numbers.sum.to_f \/ numbers.size\n  deviations = numbers.map { |num| (num - mean).abs }\n  deviations.sum \/ numbers.size\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_mean_absolute_deviation\n    candidate = method(:mean_absolute_deviation)\n    assert_equal(0.5, candidate.call([1.0, 2.0]))\n    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))\n    assert_equal(1.2, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n  end\nend\n"},{"task_id":"HumanEval_5","nl":"yor_Latn","pl":"rb","prompt":"Fi nọmba kan \"delimeter\" laarin awọn eroja meji ti o tẹle ara ti iṣiro input ∀numbers\" # >>> intersperse.call([], 4)\n# []\n# >>> intersperse.call([1, 2, 3], 4)\n# [1, 4, 2, 4, 3]\ndef intersperse(numbers, delimeter)\n","canonical_solution":"def intersperse(numbers, delimeter)\n  return numbers if numbers.empty?\n  result = []\n  numbers.each_with_index do |num, index|\n    result << num\n    result << delimeter unless index == numbers.size - 1\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersperse\n    candidate = method(:intersperse)\n    assert_equal([], candidate.call([], 7))\n    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))\n    assert_equal([2, 2, 2, 2, 2], candidate.call([2, 2, 2], 2))\n  end\nend\n"},{"task_id":"HumanEval_6","nl":"yor_Latn","pl":"rb","prompt":"E.g. (() (()) ni o ni o pọju meji awọn ipele ti nesting nigba ti ((())) ni o ni mẹta. Fun ẹgbẹ kọọkan, ṣe igbasilẹ ipele ti o jinlẹ julọ ti awọn ibọwọ ti awọn ibọwọ. Ohun tí ó wọlé sí iṣẹ́ yìí jẹ́ ìlà tí ó dúró fún àwọn ẹgbẹ́ bíi mélòó kan fún àwọn àlàfo tí a yàtọ̀ nípa àwọn àlàfo.# >>> parse_nested_parens.call(\"(()()) ((())) () ((())()())\")\n# [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n","canonical_solution":"def parse_nested_parens(paren_string)\n  paren_string.split.map do |group|\n    max_depth = current_depth = 0\n    group.chars.each do |char|\n      if char == '('\n        current_depth += 1\n        max_depth = [max_depth, current_depth].max\n      elsif char == ')'\n        current_depth -= 1\n      end\n    end\n    max_depth\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"))\n  end\nend\n"},{"task_id":"HumanEval_7","nl":"yor_Latn","pl":"rb","prompt":"Ṣàtúnṣe ìlà ìkọsílẹ̀ tí ó ní àwọn ìlà tí ó ní ìlà ìsàlẹ̀ tí a fún # >>> filter_by_substring.call([], \"a\")\n# []\n# >>> filter_by_substring.call([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"bacd\", \"array\"]\ndef filter_by_substring(strings, substring)\n","canonical_solution":"def filter_by_substring(strings, substring)\n  strings.select { |string| string.include?(substring) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_substring\n    candidate = method(:filter_by_substring)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n    assert_equal([\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"))\n    assert_equal([\"grunt\", \"prune\"], candidate.call([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"))\n  end\nend\n"},{"task_id":"HumanEval_8","nl":"yor_Latn","pl":"rb","prompt":"Àkójọ òfo yẹ kó dọ́gba sí 0 àti èso òfo yẹ kó dọ́gba sí 1.Fun a fun ni awọn titobi ti awọn integers, pada a titobi ti o ni a iye ati a ọja ti gbogbo awọn integers ni a titobi. # >>> sum_product.call([])\n# [0, 1]\n# >>> sum_product.call([1, 2, 3, 4])\n# [10, 24]\ndef sum_product(numbers)\n","canonical_solution":"def sum_product(numbers)\n  sum = numbers.reduce(0, :+)\n  product = numbers.reduce(1, :*)\n  [sum, product]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_product\n    candidate = method(:sum_product)\n    assert_equal([0, 1], candidate.call([]))\n    assert_equal([3, 1], candidate.call([1, 1, 1]))\n    assert_equal([100, 0], candidate.call([100, 0]))\n    assert_equal([15, 105], candidate.call([3, 5, 7]))\n    assert_equal([10, 10], candidate.call([10]))\n  end\nend\n"},{"task_id":"HumanEval_9","nl":"yor_Latn","pl":"rb","prompt":"nínú ìtòlẹ́sẹẹsẹ náà.Lati inu awọn nọmba odidi ti a fun, ṣe agbekalẹ awọn nọmba ti awọn eroja ti o pọju ti a ri titi di akoko ti a fun # >>> rolling_max.call([1, 2, 3, 2, 3, 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\ndef rolling_max(numbers)\n","canonical_solution":"def rolling_max(numbers)\n  max_so_far = numbers.first\n  numbers.map do |num|\n    max_so_far = [max_so_far, num].max\n  end\nend\n\n# Example usage:\n# puts rolling_max([1, 2, 3, 2, 3, 4, 2]).inspect","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rolling_max\n    candidate = method(:rolling_max)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([4, 4, 4, 4], candidate.call([4, 3, 2, 1]))\n    assert_equal([3, 3, 3, 100, 100], candidate.call([3, 2, 3, 100, 3]))\n  end\nend\n"},{"task_id":"HumanEval_10","nl":"yor_Latn","pl":"rb","prompt":"- Fi sí ìparí ìsòkò ìsòkò ìsòkò tí ó wà níwájú ìsòkò palindromic.- Wá postfix tó gùn jùlọ nínú àwọn ìlà tí a pèsè tí ó jẹ́ palindrome. Èrò alugorítìmu náà kò ṣòro rárá: Wá palindrome tó kúrú jùlọ tí ó bẹ̀rẹ̀ pẹ̀lú òpó tí a fi fún wa. # >>> make_palindrome.call(\"\")\n# \"\"\n# >>> make_palindrome.call(\"cat\")\n# \"catac\"\n# >>> make_palindrome.call(\"cata\")\n# \"catac\"\ndef make_palindrome(string)\n","canonical_solution":"def make_palindrome(string)\n  return string if string.empty?\n\n  def is_palindrome?(s)\n    s == s.reverse\n  end\n\n  (0...string.length).reverse_each do |i|\n    if is_palindrome?(string[i..-1])\n      return string + string[0...i].reverse\n    end\n  end\n\n  string\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\", candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"},{"task_id":"HumanEval_11","nl":"yor_Latn","pl":"rb","prompt":"Ṣe XOR ìkejì lórí àwọn ìsọfúnni wọ̀nyí kí o sì dá èsì padà gẹ́gẹ́ bí òpó.Input ni meji okun a ati b ti o ni nikan 1s ati 0s. # >>> string_xor.call(\"010\", \"110\")\n# \"100\"\ndef string_xor(a, b)\n","canonical_solution":"def string_xor(a, b)\n  result = \"\"\n  a.length.times do |i|\n    result << (a[i] == b[i] ? \"0\" : \"1\")\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"},{"task_id":"HumanEval_12","nl":"yor_Latn","pl":"rb","prompt":"return nil ni ọran ti iṣiro titẹsi jẹ ofo. Láti inú ìlà àwọn òpó, dá èyí tó gùn jùlọ padà. Dá èyí àkọ́kọ́ padà bí ó bá jẹ́ pé ó pọ̀jù # >>> longest.call([])\n# nil\n# >>> longest.call([\"a\", \"b\", \"c\"])\n# \"a\"\n# >>> longest.call([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\ndef longest(strings)\n","canonical_solution":"def longest(strings)\n  return nil if strings.empty?\n  strings.max_by(&:length)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n    assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n  end\nend\n"},{"task_id":"HumanEval_13","nl":"yor_Latn","pl":"rb","prompt":"Pada a tobi ti o wọpọ divisor ti meji integers a ati b # >>> greatest_common_divisor.call(3, 5)\n# 1\n# >>> greatest_common_divisor.call(25, 15)\n# 5\ndef greatest_common_divisor(a, b)\n","canonical_solution":"def greatest_common_divisor(a, b)\n  while b != 0\n    a, b = b, a % b\n  end\n  a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_greatest_common_divisor\n    candidate = method(:greatest_common_divisor)\n    assert_equal(1, candidate.call(3, 7))\n    assert_equal(5, candidate.call(10, 15))\n    assert_equal(7, candidate.call(49, 14))\n    assert_equal(12, candidate.call(144, 60))\n  end\nend\n"},{"task_id":"HumanEval_14","nl":"yor_Latn","pl":"rb","prompt":"Return array of all prefixes from shortest to longest of the input string  ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì# >>> all_prefixes.call(\"abc\")\n# [\"a\", \"ab\", \"abc\"]\ndef all_prefixes(string)\n","canonical_solution":"def all_prefixes(string)\n  (1..string.length).map { |i| string[0, i] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_all_prefixes\n    candidate = method(:all_prefixes)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"], candidate.call(\"asdfgh\"))\n    assert_equal([\"W\", \"WW\", \"WWW\"], candidate.call(\"WWW\"))\n  end\nend\n"},{"task_id":"HumanEval_15","nl":"yor_Latn","pl":"rb","prompt":"Return a string containing space-delimited numbers starting from 0 upto n inclusive.  Ìyàsípadà òpópónà tí ó ní àwọn iye tí ó ní àlàfo àlàfo.# >>> string_sequence.call(0)\n# \"0\"\n# >>> string_sequence.call(5)\n# \"0 1 2 3 4 5\"\ndef string_sequence(n)\n","canonical_solution":"def string_sequence(n)\n  (0..n).to_a.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_sequence\n    candidate = method(:string_sequence)\n    assert_equal(\"0\", candidate.call(0))\n    assert_equal(\"0 1 2 3\", candidate.call(3))\n    assert_equal(\"0 1 2 3 4 5 6 7 8 9 10\", candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_16","nl":"yor_Latn","pl":"rb","prompt":"Ti a ba fun ọ ni okun kan, wa iye awọn ohun kikọ ti o yatọ (laibikita ọran) ti o ni # >>> count_distinct_characters.call(\"xyzXYZ\")\n# 3\n# >>> count_distinct_characters.call(\"Jerry\")\n# 4\ndef count_distinct_characters(string)\n","canonical_solution":"def count_distinct_characters(string)\n  string.downcase.chars.uniq.count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5, candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"},{"task_id":"HumanEval_17","nl":"yor_Latn","pl":"rb","prompt":"'Ohun tó ń ṣe' - orin kẹrin, ó máa ń gba ìlù kan.'o sa' - ìdajì nọ́ọ̀tì, ó máa ń gba ìlù méjì'o' - gbogbo nóòtì, ó máa ń gba ìlù mẹ́rin Àkọlé kan rèé:kì í ṣe èyí tó kẹ́yìn.Iṣẹ́ yín ni láti ṣàyẹ̀wò ìlà yìí kí ẹ sì dá àwọn àpapọ̀ iye tí ó bá iye ìlù tí ìlà kọ̀ọ̀kan ní padà.Ohun tí ó wọlé sí iṣẹ́ yìí ni ìlà tí ó ń ṣàpẹẹrẹ àwọn àwo orin ní ọ̀nà ASCII àkànṣe.# >>> parse_music.call(\"o o| .| o| o| .| .| .| .| o o\")\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\ndef parse_music(music_string)\n","canonical_solution":"def parse_music(music_string)\n  # Split the input string into individual notes.\n  notes = music_string.split\n\n  # Map each note to its corresponding number of beats.\n  notes.map do |note|\n    case note\n    when 'o'\n      4\n    when 'o|'\n      2\n    when '.|'\n      1\n    else\n      0\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_music\n    candidate = method(:parse_music)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([4, 4, 4, 4], candidate.call(\"o o o o\"))\n    assert_equal([1, 1, 1, 1], candidate.call(\".| .| .| .|\"))\n    assert_equal([2, 2, 1, 1, 4, 4, 4, 4], candidate.call(\"o| o| .| .| o o o o\"))\n    assert_equal([2, 1, 2, 1, 4, 2, 4, 2], candidate.call(\"o| .| o| .| o o| o o|\"))\n  end\nend\n"},{"task_id":"HumanEval_18","nl":"yor_Latn","pl":"rb","prompt":"Wá iye ìgbà tí a lè rí ìsókè-òkè tí a fún ní ìsókè-òkè àkọ́kọ́. Ka àwọn ìgbà tí ó bá ń bojú. # >>> how_many_times.call(\"\", \"a\")\n# 0\n# >>> how_many_times.call(\"aaa\", \"a\")\n# 3\n# >>> how_many_times.call(\"aaaa\", \"aa\")\n# 3\ndef how_many_times(string, substring)\n","canonical_solution":"def how_many_times(string, substring)\n  return 0 if substring.empty?\n  count = 0\n  i = 0\n  while i <= string.length - substring.length\n    if string[i, substring.length] == substring\n      count += 1\n    end\n    i += 1\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_how_many_times\n    candidate = method(:how_many_times)\n    assert_equal(0, candidate.call(\"\", \"x\"))\n    assert_equal(4, candidate.call(\"xyxyxyx\", \"x\"))\n    assert_equal(4, candidate.call(\"cacacacac\", \"cac\"))\n    assert_equal(1, candidate.call(\"john doe\", \"john\"))\n  end\nend\n"},{"task_id":"HumanEval_19","nl":"yor_Latn","pl":"rb","prompt":"Yípadà ìlà tí ó ní àwọn nóbà tí a tò láti kékeré sí ńlá Àwọn àyànfẹ́ tó bágbà mu ni \"dín\", \"kan\", \"meji\", \"mẹta\", \"mẹ́rin\", \"mẹ́fà\", \"méje\", \"méjìdínláàádọ́rùn-ún\" àti \"mẹsàn-án\". Ohun tí a fi wọlé jẹ àlàfo tí a fi àlàfo àlàfo àlàfo àlàfo láti 'dásí' sí 'sàn'.# >>> sort_numbers.call(\"three one five\")\n# \"one three five\"\ndef sort_numbers(numbers)\n","canonical_solution":"def sort_numbers(numbers)\n  numeral_map = {\n    'zero' => 0,\n    'one' => 1,\n    'two' => 2,\n    'three' => 3,\n    'four' => 4,\n    'five' => 5,\n    'six' => 6,\n    'seven' => 7,\n    'eight' => 8,\n    'nine' => 9\n  }\n\n  number_words = numbers.split\n  sorted_numbers = number_words.sort_by { |word| numeral_map[word] }\n  sorted_numbers.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_numbers\n    candidate = method(:sort_numbers)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"three\", candidate.call(\"three\"))\n    assert_equal(\"three five nine\", candidate.call(\"three five nine\"))\n    assert_equal(\"zero four five seven eight nine\", candidate.call(\"five zero four seven nine eight\"))\n    assert_equal(\"zero one two three four five six\", candidate.call(\"six five four three two one zero\"))\n  end\nend\n"},{"task_id":"HumanEval_20","nl":"yor_Latn","pl":"rb","prompt":"àwọn mìíràn, kí o sì fi wọn pa dà ní ìlà (nọ́mbà tó kéré, nọ́mbà tó tóbi).Lati inu awọn nọmba ti a pese (ti o kere ju meji lọ) yan ki o si pada meji ti o sunmọ julọ si ọkọọkan # >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n","canonical_solution":"def find_closest_elements(numbers)\n  sorted_numbers = numbers.sort\n  closest_pair = [sorted_numbers[0], sorted_numbers[1]]\n  min_difference = (sorted_numbers[1] - sorted_numbers[0]).abs\n\n  (1...(sorted_numbers.length - 1)).each do |i|\n    current_difference = (sorted_numbers[i + 1] - sorted_numbers[i]).abs\n    if current_difference < min_difference\n      min_difference = current_difference\n      closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]\n    end\n  end\n\n  closest_pair\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n"},{"task_id":"HumanEval_21","nl":"yor_Latn","pl":"rb","prompt":"irú èyí tí iye tí ó kéré jùlọ yóò di 0 àti ti tóbi jùlọ yóò di 1 Ti a ba fun ni awọn nọmba (ti o kere ju awọn eroja meji), lo iyipada ila kan si awọn nọmba yẹn, # >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\ndef rescale_to_unit(numbers)\n","canonical_solution":"def rescale_to_unit(numbers)\n  min = numbers.min\n  max = numbers.max\n  range = max - min\n  return numbers.map { |num| (num - min) \/ range.to_f }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rescale_to_unit\n    candidate = method(:rescale_to_unit)\n    assert_equal([0.0, 1.0], candidate.call([2.0, 49.9]))\n    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))\n    assert_equal([0.0, 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))\n  end\nend\n"},{"task_id":"HumanEval_22","nl":"yor_Latn","pl":"rb","prompt":"Ṣàtúnṣe àlẹmọ ti a fun ti eyikeyi awọn iye rbthon fun awọn nọmba odidi nikan # >>> filter_integers.call([\"a\", 3.14, 5])\n# [5]\n# >>> filter_integers.call([1, 2, 3, \"abc\", {}, []])\n# [1, 2, 3]\ndef filter_integers(values)\n","canonical_solution":"def filter_integers(values)\n  values.select { |value| value.is_a?(Integer) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_integers\n    candidate = method(:filter_integers)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, \"adasd\"]))\n    assert_equal([3, 3, 3], candidate.call([3, \"c\", 3, 3, \"a\", \"b\"]))\n  end\nend\n"},{"task_id":"HumanEval_23","nl":"yor_Latn","pl":"rb","prompt":"Yi pada ipari ti fifun okun # >>> strlen.call(\"\")\n# 0\n# >>> strlen.call(\"abc\")\n# 3\ndef strlen(string)\n","canonical_solution":"strlen = lambda do |string|\n  string.length\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strlen\n    candidate = method(:strlen)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(1, candidate.call(\"x\"))\n    assert_equal(9, candidate.call(\"asdasnakj\"))\n  end\nend\n"},{"task_id":"HumanEval_24","nl":"yor_Latn","pl":"rb","prompt":"Fun nọmba kan n, wa nọmba ti o tobi julo ti o pin n bakanna, ti o kere ju n lọ # >>> largest_divisor.call(15)\n# 5\ndef largest_divisor(n)\n","canonical_solution":"def largest_divisor(n)\n  (n - 1).downto(1) do |i|\n    return i if n % i == 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_divisor\n    candidate = method(:largest_divisor)\n    assert_equal(1, candidate.call(3))\n    assert_equal(1, candidate.call(7))\n    assert_equal(5, candidate.call(10))\n    assert_equal(50, candidate.call(100))\n    assert_equal(7, candidate.call(49))\n  end\nend\n"},{"task_id":"HumanEval_25","nl":"yor_Latn","pl":"rb","prompt":"Nọmba ìléwọ̀n náà yóò dọ́gba sí ìmúpò gbogbo àwọn èròjà Kọọkan ninu awọn ifosiwewe yẹ ki o wa ni arrayed nọmba ti igba ti o baamu si bi ọpọlọpọ igba ti o han ni factorization. Return array of prime factors of given integer in the order from smallest to largest.  Ìmúlò àwọn kókó pàtàkì tí a fún ní iye tó ṣe pàtó ní ìlà láti kékeré sí ńlá# >>> factorize.call(8)\n# [2, 2, 2]\n# >>> factorize.call(25)\n# [5, 5]\n# >>> factorize.call(70)\n# [2, 5, 7]\ndef factorize(n)\n","canonical_solution":"def factorize(n)\n  factors = []\n  divisor = 2\n  while n > 1\n    while n % divisor == 0\n      factors << divisor\n      n \/= divisor\n    end\n    divisor += 1\n  end\n  factors\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_factorize\n    candidate = method(:factorize)\n    assert_equal([2], candidate.call(2))\n    assert_equal([2, 2], candidate.call(4))\n    assert_equal([2, 2, 2], candidate.call(8))\n    assert_equal([3, 19], candidate.call(57))\n    assert_equal([3, 3, 19, 19], candidate.call(3249))\n    assert_equal([3, 3, 3, 19, 19, 19], candidate.call(185193))\n    assert_equal([3, 19, 19, 19], candidate.call(20577))\n    assert_equal([2, 3, 3], candidate.call(18))\n  end\nend\n"},{"task_id":"HumanEval_26","nl":"yor_Latn","pl":"rb","prompt":"Pa aṣẹ ti awọn eroja osi kanna bi ninu awọn input. Lati inu awọn nọmba odidi, yọ gbogbo awọn eroja ti o waye ju ẹẹkan lọ.# >>> remove_duplicates.call([1, 2, 3, 2, 4])\n# [1, 3, 4]\ndef remove_duplicates(numbers)\n","canonical_solution":"def remove_duplicates(numbers)\n  numbers.select { |num| numbers.count(num) == 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_duplicates\n    candidate = method(:remove_duplicates)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([1, 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))\n  end\nend\n"},{"task_id":"HumanEval_27","nl":"yor_Latn","pl":"rb","prompt":"Fun okun ti a fun, yi awọn ohun kikọ kekere pada si nla ati nla si kekere. # >>> flip_case.call(\"Hello\")\n# \"hELLO\"\ndef flip_case(string)\n","canonical_solution":"def flip_case(string)\n  string.swapcase\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_flip_case\n    candidate = method(:flip_case)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"hELLO!\", candidate.call(\"Hello!\"))\n    assert_equal(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\", candidate.call(\"These violent delights have violent ends\"))\n  end\nend\n"},{"task_id":"HumanEval_28","nl":"yor_Latn","pl":"rb","prompt":"Ṣípò àwọn ìlà-ìpín-ìpín-ìpín-ìpín-ìpín-ìpín-ìpín-ìpín-ìpín-ìpín-ìpín-ìpín # >>> concatenate.call([])\n# \"\"\n# >>> concatenate.call([\"a\", \"b\", \"c\"])\n# \"abc\"\ndef concatenate(strings)\n","canonical_solution":"def concatenate(strings)\n  strings.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_concatenate\n    candidate = method(:concatenate)\n    assert_equal(\"\", candidate.call([]))\n    assert_equal(\"xyz\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"xyzwk\", candidate.call([\"x\", \"y\", \"z\", \"w\", \"k\"]))\n  end\nend\n"},{"task_id":"HumanEval_29","nl":"yor_Latn","pl":"rb","prompt":"Ṣàwòrán ìlà ìsọfúnni tí ó jẹ́ ìsọfúnni fún àwọn tí ó bẹ̀rẹ̀ pẹ̀lú àfikún tí a fún. # >>> filter_by_prefix.call([], \"a\")\n# []\n# >>> filter_by_prefix.call([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"array\"]\ndef filter_by_prefix(strings, prefix)\n","canonical_solution":"def filter_by_prefix(strings, prefix)\n  strings.select { |string| string.start_with?(prefix) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_prefix\n    candidate = method(:filter_by_prefix)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n  end\nend\n"},{"task_id":"HumanEval_30","nl":"yor_Latn","pl":"rb","prompt":"Ó ń dá àwọn iye tó jẹ́ àbáyọ padà nínú àpapọ̀.# >>> get_positive.call([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\ndef get_positive(l)\n","canonical_solution":"get_positive = lambda do |l|\n  l.select { |num| num > 0 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_positive\n    candidate = method(:get_positive)\n    assert_equal([4, 5, 6], candidate.call([-1, -2, 4, 5, 6]))\n    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([], candidate.call([-1, -2]))\n    assert_equal([], candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_31","nl":"yor_Latn","pl":"rb","prompt":"Yi pada otitọ ti o ba ti a fun nọmba jẹ akọkọ, ati eke bibẹkọ ti. # >>> is_prime.call(6)\n# false\n# >>> is_prime.call(101)\n# true\n# >>> is_prime.call(11)\n# true\n# >>> is_prime.call(13441)\n# true\n# >>> is_prime.call(61)\n# true\n# >>> is_prime.call(4)\n# false\n# >>> is_prime.call(1)\n# false\ndef is_prime(n)\n","canonical_solution":"is_prime = lambda do |n|\n  return false if n <= 1\n  return true if n == 2\n  return false if n.even?\n\n  max_divisor = Math.sqrt(n).to_i\n  (3..max_divisor).step(2).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_prime\n    candidate = method(:is_prime)\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(101))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(13441))\n    assert_equal(true, candidate.call(61))\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(1))\n    assert_equal(true, candidate.call(5))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(17))\n    assert_equal(false, candidate.call(85))\n    assert_equal(false, candidate.call(77))\n    assert_equal(false, candidate.call(255379))\n  end\nend\n"},{"task_id":"HumanEval_33","nl":"yor_Latn","pl":"rb","prompt":" ti awọn iye ti awọn ti o baamu indices ti l, sugbon ti yan.l' jẹ kanna si l ni awọn itọka ti ko pin nipasẹ mẹta, lakoko ti awọn iye rẹ ni awọn itọka ti o pin nipasẹ mẹta jẹ dogba Iṣẹ́ yìí gba ìlà l ó sì dá ìlà l' padà tí # >>> sort_third.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])\n# [2, 6, 3, 4, 8, 9, 5]\ndef sort_third(l)\n","canonical_solution":"def sort_third(l)\n  divisible_by_three = l.each_with_index.select { |_, idx| idx % 3 == 0 }.map(&:first).sort\n  l.each_with_index.map { |val, idx| idx % 3 == 0 ? divisible_by_three.shift : val }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_third\n    candidate = method(:sort_third)\n    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5, 6, 3, 4, 8, 9, 2]))\n    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5, 8, 3, 4, 6, 9, 2]))\n    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5, 6, 9, 4, 8, 3, 2]))\n    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5, 6, 3, 4, 8, 9, 2, 1]))\n  end\nend\n"},{"task_id":"HumanEval_34","nl":"yor_Latn","pl":"rb","prompt":"Return sorted unique elements in an array  Àwọn ohun tó wà nínú àtẹ̀wò# >>> unique.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\ndef unique(l)\n","canonical_solution":"def unique(l)\n  l.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique\n    candidate = method(:unique)\n    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5, 3, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_35","nl":"yor_Latn","pl":"rb","prompt":"Ó dá ẹ̀yà tó pọ̀ jùlọ padà nínú àpapọ̀.# >>> max_element.call([1, 2, 3])\n# 3\n# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\ndef max_element(l)\n","canonical_solution":"def max_element(l)\n  l.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_element\n    candidate = method(:max_element)\n    assert_equal(3, candidate.call([1, 2, 3]))\n    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]))\n  end\nend\n"},{"task_id":"HumanEval_36","nl":"yor_Latn","pl":"rb","prompt":"Yí iye ìgbà tí dígí 7 fara hàn nínú àwọn iye tó kéré ju n tí ó ṣeé pín sí 11 tàbí 13. # >>> fizz_buzz.call(50)\n# 0\n# >>> fizz_buzz.call(78)\n# 2\n# >>> fizz_buzz.call(79)\n# 3\ndef fizz_buzz(n)\n","canonical_solution":"def fizz_buzz(n)\n  count = 0\n  (1...n).each do |i|\n    if i % 11 == 0 || i % 13 == 0\n      count += i.to_s.count('7')\n    end\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fizz_buzz\n    candidate = method(:fizz_buzz)\n    assert_equal(0, candidate.call(50))\n    assert_equal(2, candidate.call(78))\n    assert_equal(3, candidate.call(79))\n    assert_equal(3, candidate.call(100))\n    assert_equal(6, candidate.call(200))\n    assert_equal(192, candidate.call(4000))\n    assert_equal(639, candidate.call(10000))\n    assert_equal(8026, candidate.call(100000))\n  end\nend\n"},{"task_id":"HumanEval_37","nl":"yor_Latn","pl":"rb","prompt":"si awọn iye ti awọn ani indices ti l, sugbon ti yan. l' jẹ kanna si l ni awọn itọka ti o yatọ, lakoko ti awọn iye rẹ ni awọn itọka ti o dọgba jẹ dọgbadọgba Iṣẹ́ yìí gba ìlà l ó sì dá ìlà l' padà tí # >>> sort_even.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_even.call([5, 6, 3, 4])\n# [3, 6, 5, 4]\ndef sort_even(l)\n","canonical_solution":"def sort_even(l)\n  even_indices = l.each_index.select { |i| i.even? }\n  even_values = even_indices.map { |i| l[i] }.sort\n  \n  even_index = 0\n  l.each_with_index.map do |value, index|\n    if index.even?\n      even_values[even_index].tap { even_index += 1 }\n    else\n      value\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_even\n    candidate = method(:sort_even)\n    assert_equal([1, 2, 3], candidate.call([1, 2, 3]))\n    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n  end\nend\n"},{"task_id":"HumanEval_39","nl":"yor_Latn","pl":"rb","prompt":"prime_fib á dá n-th iye tí ó jẹ́ iye Fibonacci tí ó sì tún jẹ́ iye kálukú. # >>> prime_fib.call(1)\n# 2\n# >>> prime_fib.call(2)\n# 3\n# >>> prime_fib.call(3)\n# 5\n# >>> prime_fib.call(4)\n# 13\n# >>> prime_fib.call(5)\n# 89\ndef prime_fib(n)\n","canonical_solution":"def prime_fib(n)\n  require 'prime'\n  \n  fibs = Enumerator.new do |y|\n    a, b = 0, 1\n    loop do\n      a, b = b, a + b\n      y << b\n    end\n  end\n  \n  prime_fibs = fibs.lazy.select { |fib| Prime.prime?(fib) }\n  prime_fibs.first(n).last\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_fib\n    candidate = method(:prime_fib)\n    assert_equal(2, candidate.call(1))\n    assert_equal(3, candidate.call(2))\n    assert_equal(5, candidate.call(3))\n    assert_equal(13, candidate.call(4))\n    assert_equal(89, candidate.call(5))\n    assert_equal(233, candidate.call(6))\n    assert_equal(1597, candidate.call(7))\n    assert_equal(28657, candidate.call(8))\n    assert_equal(514229, candidate.call(9))\n    assert_equal(433494437, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_40","nl":"yor_Latn","pl":"rb","prompt":"iye náà jẹ́ òfo, tí kò bá sì jẹ́ bẹ́ẹ̀, ó jẹ́ òdì.ó padà sí òtítọ́ bí ó bá jẹ́ pé àwọn ohun tí ó yàtọ̀ síra mẹ́ta wà nínú àpapọ̀ tí triples_sum_to_zero gba ìlà àwọn iye tó pé bí ìsọfúnni. # >>> triples_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> triples_sum_to_zero.call([1, 3, -2, 1])\n# true\n# >>> triples_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])\n# true\n# >>> triples_sum_to_zero.call([1])\n# false\ndef triples_sum_to_zero(l)\n","canonical_solution":"def triples_sum_to_zero(l)\n  n = l.length\n  (0...n-2).each do |i|\n    ((i+1)...n-1).each do |j|\n      ((j+1)...n).each do |k|\n        return true if l[i] + l[j] + l[k] == 0\n      end\n    end\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false, candidate.call([100, 3, 5, -100]))\n  end\nend\n"},{"task_id":"HumanEval_41","nl":"yor_Latn","pl":"rb","prompt":"Àṣirò yìí ń mú iye irú ìkọlù bẹ́ẹ̀ jáde.bí ẹni pé wọn ò bára wọn fà á.Àmọ́, àwọn ọkọ̀ náà lágbára gan-an, ìdí nìyẹn tí wọ́n fi ń rìn lọ.nígbà tí ọkọ̀ tó ń lọ láti apá òsì sí apá ọ̀tún bá kọlu ọkọ̀ tó ń lọ láti apá ọ̀tún sí apá òsì.gbogbo ọkọ̀ ń rìn ní iyara kan náà. a sọ pé ọkọ̀ méjì ń kọlu ara wọn.àwọn ọkọ̀ méjì náà ti jìnnà gan-an sí n ọkọ̀ ń wakọ̀ láti òsì sí ọ̀tún; ní àkókò kan náà, àwọn ọkọ̀ mìíràn tí ó jẹ́ n ọkọ̀ Fojú inú wo òpópónà kan tó dúró ṣánṣán, tí kò ní ààlà.def car_race_collision(n)\n","canonical_solution":"def car_race_collision(n)\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_car_race_collision\n    candidate = method(:car_race_collision)\n    assert_equal(4, candidate.call(2))\n    assert_equal(9, candidate.call(3))\n    assert_equal(16, candidate.call(4))\n    assert_equal(64, candidate.call(8))\n    assert_equal(100, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_42","nl":"yor_Latn","pl":"rb","prompt":"Yipo array pẹlu awọn eroja ti o pọ si nipasẹ 1. # >>> incr_list.call([1, 2, 3])\n# [2, 3, 4]\n# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6, 4, 6, 3, 4, 4, 10, 1, 124]\ndef incr_list(l)\n","canonical_solution":"def incr_list(l)\n  l.map { |x| x + 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_incr_list\n    candidate = method(:incr_list)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))\n    assert_equal([6, 3, 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_43","nl":"yor_Latn","pl":"rb","prompt":"iye náà jẹ́ òfo, tí kò bá sì jẹ́ bẹ́ẹ̀, ó jẹ́ òdì.ó padà sí òtítọ́ bí ó bá jẹ́ pé àwọn ohun méjì tó yàtọ̀ nínú àpapọ̀ náà tí pairs_sum_to_zero gba ìlà àwọn iye tó pé bí ìsọfúnni. # >>> pairs_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> pairs_sum_to_zero.call([1, 3, -2, 1])\n# false\n# >>> pairs_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\n# true\n# >>> pairs_sum_to_zero.call([1])\n# false\ndef pairs_sum_to_zero(l)\n","canonical_solution":"def pairs_sum_to_zero(l)\n  num_set = l.to_set\n  l.each do |num|\n    return true if num != 0 && num_set.include?(-num)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"},{"task_id":"HumanEval_44","nl":"yor_Latn","pl":"rb","prompt":"àwọn iye tí ó wà nínú àwọn báìsì kò tó 10.fi ìsọ̀rí ìsọ̀rí padà lẹ́yìn ìyípadà.Yípadà ìpìlẹ̀ ìṣirò ti ìmúṣẹ iye x sí ìpìlẹ̀.# >>> change_base.call(8, 3)\n# \"22\"\n# >>> change_base.call(8, 2)\n# \"1000\"\n# >>> change_base.call(7, 2)\n# \"111\"\ndef change_base(x, base)\n","canonical_solution":"def change_base(x, base)\n  return '0' if x == 0\n  digits = []\n  while x > 0\n    digits << (x % base).to_s\n    x \/= base\n  end\n  digits.reverse.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_change_base\n    candidate = method(:change_base)\n    assert_equal(\"22\", candidate.call(8, 3))\n    assert_equal(\"100\", candidate.call(9, 3))\n    assert_equal(\"11101010\", candidate.call(234, 2))\n    assert_equal(\"10000\", candidate.call(16, 2))\n    assert_equal(\"1000\", candidate.call(8, 2))\n    assert_equal(\"111\", candidate.call(7, 2))\n    assert_equal(\"2\", candidate.call(2, 3))\n    assert_equal(\"3\", candidate.call(3, 4))\n    assert_equal(\"4\", candidate.call(4, 5))\n    assert_equal(\"5\", candidate.call(5, 6))\n    assert_equal(\"6\", candidate.call(6, 7))\n    assert_equal(\"7\", candidate.call(7, 8))\n  end\nend\n"},{"task_id":"HumanEval_45","nl":"yor_Latn","pl":"rb","prompt":"A fun ni gígùn ẹgbẹ kan ati agbegbe ipadabọ giga fun onigun mẹta kan.# >>> triangle_area.call(5, 3)\n# 7.5\ndef triangle_area(a, h)\n","canonical_solution":"def triangle_area(a, h)\n  (a * h) \/ 2.0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(7.5, candidate.call(5, 3))\n    assert_equal(2.0, candidate.call(2, 2))\n    assert_equal(40.0, candidate.call(10, 8))\n  end\nend\n"},{"task_id":"HumanEval_46","nl":"yor_Latn","pl":"rb","prompt":"Jọwọ kọ iṣẹ kan lati ṣe iṣiro daradara ti eroja n-th ti awọn nọmba nọmba fib4. Maṣe lo atunṣe. fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). fib4(3) -> 0 fib4(2) -> 2 fib4(1) -> 0 fib4(0) -> 0 Àkọlé Fib4 jẹ́ àtẹ̀lé tí ó jọ àtẹ̀lé Fibbonacci tí a fi ṣe àlàyé bí èyí: # >>> fib4.call(5)\n# 4\n# >>> fib4.call(6)\n# 8\n# >>> fib4.call(7)\n# 14\ndef fib4(n)\n","canonical_solution":"def fib4(n)\n  return 0 if n == 0 || n == 1 || n == 3\n  return 2 if n == 2\n\n  fib4_seq = [0, 0, 2, 0]\n  (4..n).each do |i|\n    fib4_seq[i] = fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]\n  end\n  fib4_seq[n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib4\n    candidate = method(:fib4)\n    assert_equal(4, candidate.call(5))\n    assert_equal(28, candidate.call(8))\n    assert_equal(104, candidate.call(10))\n    assert_equal(386, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_47","nl":"yor_Latn","pl":"rb","prompt":"Yi pada median ti awọn eroja ninu awọn array l. # >>> median.call([3, 1, 2, 4, 5])\n# 3\n# >>> median.call([-10, 4, 6, 1000, 10, 20])\n# 15.0\ndef median(l)\n","canonical_solution":"def median(l)\n  sorted = l.sort\n  len = sorted.length\n  if len.odd?\n    sorted[len \/ 2]\n  else\n    (sorted[len \/ 2 - 1] + sorted[len \/ 2]) \/ 2.0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_median\n    candidate = method(:median)\n    assert_equal(3, candidate.call([3, 1, 2, 4, 5]))\n    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))\n    assert_equal(5, candidate.call([5]))\n    assert_equal(5.5, candidate.call([6, 5]))\n    assert_equal(7, candidate.call([8, 1, 3, 9, 9, 2, 7]))\n  end\nend\n"},{"task_id":"HumanEval_48","nl":"yor_Latn","pl":"rb","prompt":"Ó ń ṣayẹwo bóyá ìlà tí a fún ni palindrome # >>> is_palindrome.call(\"\")\n# true\n# >>> is_palindrome.call(\"aba\")\n# true\n# >>> is_palindrome.call(\"aaaaa\")\n# true\n# >>> is_palindrome.call(\"zbcd\")\n# false\ndef is_palindrome(text)\n","canonical_solution":"is_palindrome = lambda do |text|\n  text == text.reverse\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_palindrome\n    candidate = method(:is_palindrome)\n    assert_equal(true, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"aba\"))\n    assert_equal(true, candidate.call(\"aaaaa\"))\n    assert_equal(false, candidate.call(\"zbcd\"))\n    assert_equal(true, candidate.call(\"xywyx\"))\n    assert_equal(false, candidate.call(\"xywyz\"))\n    assert_equal(false, candidate.call(\"xywzx\"))\n  end\nend\n"},{"task_id":"HumanEval_49","nl":"yor_Latn","pl":"rb","prompt":"Yi pada 2^n modulo p (máa mọ̀ nípa àwọn nómíríkì).# >>> modp.call(3, 5)\n# 3\n# >>> modp.call(1101, 101)\n# 2\n# >>> modp.call(0, 101)\n# 1\n# >>> modp.call(3, 11)\n# 8\n# >>> modp.call(100, 101)\n# 1\ndef modp(n, p)\n","canonical_solution":"def modp(n, p)\n  return 1 if p == 1\n  2.pow(n, p)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"},{"task_id":"HumanEval_51","nl":"yor_Latn","pl":"rb","prompt":"remove_vowels jẹ́ iṣẹ́ tí ó gba ìlà tí ó sì dá ìlà padà láì ní àwọn oníró. # >>> remove_vowels.call(\"\")\n# \"\"\n# >>> remove_vowels.call(\"abcdef\")\n# \"bcdf\"\n# >>> remove_vowels.call(\"aaaaa\")\n# \"\"\n# >>> remove_vowels.call(\"aaBAA\")\n# \"B\"\n# >>> remove_vowels.call(\"zbcd\")\n# \"zbcd\"\ndef remove_vowels(text)\n","canonical_solution":"def remove_vowels(text)\n  text.delete('aeiouAEIOU')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_vowels\n    candidate = method(:remove_vowels)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"bcdf\nghjklm\", candidate.call(\"abcdef\nghijklm\"))\n    assert_equal(\"fdcb\", candidate.call(\"fedcba\"))\n    assert_equal(\"\", candidate.call(\"eeeee\"))\n    assert_equal(\"cB\", candidate.call(\"acBAA\"))\n    assert_equal(\"cB\", candidate.call(\"EcBOO\"))\n    assert_equal(\"ybcd\", candidate.call(\"ybcd\"))\n  end\nend\n"},{"task_id":"HumanEval_52","nl":"yor_Latn","pl":"rb","prompt":"Return true ti gbogbo àwọn nọ́mbà inú àtẹ l bá wà lábẹ́ ìlà t. # >>> below_threshold.call([1, 2, 4, 10], 100)\n# true\n# >>> below_threshold.call([1, 20, 4, 10], 5)\n# false\ndef below_threshold(l, t)\n","canonical_solution":"def below_threshold(l, t)\n  l.all? { |num| num < t }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_threshold\n    candidate = method(:below_threshold)\n    assert_equal(true, candidate.call([1, 2, 4, 10], 100))\n    assert_equal(false, candidate.call([1, 20, 4, 10], 5))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 21))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 22))\n    assert_equal(true, candidate.call([1, 8, 4, 10], 11))\n    assert_equal(false, candidate.call([1, 8, 4, 10], 10))\n  end\nend\n"},{"task_id":"HumanEval_53","nl":"yor_Latn","pl":"rb","prompt":"Fi nọmba meji x ati y pọ # >>> add.call(2, 3)\n# 5\n# >>> add.call(5, 7)\n# 12\ndef add(x, y)\n","canonical_solution":"add = ->(x, y) { x + y }","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(1, candidate.call(0, 1))\n    assert_equal(1, candidate.call(1, 0))\n    assert_equal(5, candidate.call(2, 3))\n    assert_equal(12, candidate.call(5, 7))\n    assert_equal(12, candidate.call(7, 5))\n  end\nend\n"},{"task_id":"HumanEval_54","nl":"yor_Latn","pl":"rb","prompt":"Wá a wò bóyá àwọn ọ̀rọ̀ méjì kan náà ni wọ́n ń kọ. # >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n# true\n# >>> same_chars.call(\"abcd\", \"dddddddabc\")\n# true\n# >>> same_chars.call(\"dddddddabc\", \"abcd\")\n# true\n# >>> same_chars.call(\"eabcd\", \"dddddddabc\")\n# false\n# >>> same_chars.call(\"abcd\", \"dddddddabce\")\n# false\n# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n# false\ndef same_chars(s0, s1)\n","canonical_solution":"def same_chars(s0, s1)\n  s0.chars.uniq.all? { |char| s1.include?(char) } &&\n  s1.chars.uniq.all? { |char| s0.include?(char) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_same_chars\n    candidate = method(:same_chars)\n    assert_equal(true, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"))\n    assert_equal(true, candidate.call(\"abcd\", \"dddddddabc\"))\n    assert_equal(true, candidate.call(\"dddddddabc\", \"abcd\"))\n    assert_equal(false, candidate.call(\"eabcd\", \"dddddddabc\"))\n    assert_equal(false, candidate.call(\"abcd\", \"dddddddabcf\"))\n    assert_equal(false, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n    assert_equal(false, candidate.call(\"aabb\", \"aaccc\"))\n  end\nend\n"},{"task_id":"HumanEval_55","nl":"yor_Latn","pl":"rb","prompt":"Yípadà n-th iye Fibonacci. # >>> fib.call(10)\n# 55\n# >>> fib.call(1)\n# 1\n# >>> fib.call(8)\n# 21\ndef fib(n)\n","canonical_solution":"def fib(n)\n  return n if n <= 1\n  fib(n - 1) + fib(n - 2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib\n    candidate = method(:fib)\n    assert_equal(55, candidate.call(10))\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(8))\n    assert_equal(89, candidate.call(11))\n    assert_equal(144, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_56","nl":"yor_Latn","pl":"rb","prompt":"return true bí gbogbo àlàfo tí ó ṣí ní àlàfo tí ó ń pa. brackets jẹ okun ti \"<\" ati \">\". # >>> correct_bracketing.call(\"<\")\n# false\n# >>> correct_bracketing.call(\"<>\")\n# true\n# >>> correct_bracketing.call(\"<<><>>\")\n# true\n# >>> correct_bracketing.call(\"><<>\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.chars.each do |char|\n    if char == '<'\n      balance += 1\n    elsif char == '>'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"<>\"))\n    assert_equal(true, candidate.call(\"<<><>>\"))\n    assert_equal(true, candidate.call(\"<><><<><>><>\"))\n    assert_equal(true, candidate.call(\"<><><<<><><>><>><<><><<>>>\"))\n    assert_equal(false, candidate.call(\"<<<><>>>>\"))\n    assert_equal(false, candidate.call(\"><<>\"))\n    assert_equal(false, candidate.call(\"<\"))\n    assert_equal(false, candidate.call(\"<<<<\"))\n    assert_equal(false, candidate.call(\">\"))\n    assert_equal(false, candidate.call(\"<<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>><<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>>><>\"))\n  end\nend\n"},{"task_id":"HumanEval_57","nl":"yor_Latn","pl":"rb","prompt":"Return true is array elements are monotonically increasing or decreasing.  Ìyàsópòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpòpò# >>> monotonic.call([1, 2, 4, 20])\n# true\n# >>> monotonic.call([1, 20, 4, 10])\n# false\n# >>> monotonic.call([4, 1, 0, -10])\n# true\ndef monotonic(l)\n","canonical_solution":"def monotonic(l)\n  increasing = true\n  decreasing = true\n\n  (0...l.length - 1).each do |i|\n    if l[i] < l[i + 1]\n      decreasing = false\n    elsif l[i] > l[i + 1]\n      increasing = false\n    end\n  end\n\n  increasing || decreasing\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2, 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false, candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1, 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false, candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\nend\n"},{"task_id":"HumanEval_58","nl":"yor_Latn","pl":"rb","prompt":"Yípadà àwọn ohun tí ó wà nípò fún àwọn àlàfo méjì.# >>> common.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common.call([5, 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2)\n","canonical_solution":"def common(l1, l2)\n  (l1 & l2).uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5, 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3, 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"},{"task_id":"HumanEval_59","nl":"yor_Latn","pl":"rb","prompt":"Pada awọn tobi akọkọ ifosiwewe ti n. Gbigba n > 1 ati ki o jẹ ko kan akọkọ. # >>> largest_prime_factor.call(13195)\n# 29\n# >>> largest_prime_factor.call(2048)\n# 2\ndef largest_prime_factor(n)\n","canonical_solution":"def largest_prime_factor(n)\n  factor = 2\n  while factor * factor <= n\n    if n % factor == 0\n      n \/= factor\n    else\n      factor += 1\n    end\n  end\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n  end\nend\n"},{"task_id":"HumanEval_60","nl":"yor_Latn","pl":"rb","prompt":"sum_to_n jẹ́ iṣẹ́ tí ó ń ṣe àkójọpọ̀ àwọn iye láti 1 sí n. # >>> sum_to_n.call(30)\n# 465\n# >>> sum_to_n.call(100)\n# 5050\n# >>> sum_to_n.call(5)\n# 15\n# >>> sum_to_n.call(10)\n# 55\n# >>> sum_to_n.call(1)\n# 1\ndef sum_to_n(n)\n","canonical_solution":"def sum_to_n(n)\n  (1..n).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_to_n\n    candidate = method(:sum_to_n)\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(6))\n    assert_equal(66, candidate.call(11))\n    assert_equal(465, candidate.call(30))\n    assert_equal(5050, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_61","nl":"yor_Latn","pl":"rb","prompt":"return true bí gbogbo àlàfo tí ó ṣí ní àlàfo tí ó ń pa. brackets jẹ okun ti \"(\" ati \")\". # >>> correct_bracketing.call(\"(\")\n# false\n# >>> correct_bracketing.call(\"()\")\n# true\n# >>> correct_bracketing.call(\"(()())\")\n# true\n# >>> correct_bracketing.call(\")(()\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.each_char do |char|\n    if char == '('\n      balance += 1\n    elsif char == ')'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"()\"))\n    assert_equal(true, candidate.call(\"(()())\"))\n    assert_equal(true, candidate.call(\"()()(()())()\"))\n    assert_equal(true, candidate.call(\"()()((()()())())(()()(()))\"))\n    assert_equal(false, candidate.call(\"((()())))\"))\n    assert_equal(false, candidate.call(\")(()\"))\n    assert_equal(false, candidate.call(\"(\"))\n    assert_equal(false, candidate.call(\"((((\"))\n    assert_equal(false, candidate.call(\")\"))\n    assert_equal(false, candidate.call(\"(()\"))\n    assert_equal(false, candidate.call(\"()()(()())())(()\"))\n    assert_equal(false, candidate.call(\"()()(()())()))()\"))\n  end\nend\n"},{"task_id":"HumanEval_62","nl":"yor_Latn","pl":"rb","prompt":"Yípadà àbájáde ti ọ̀pòpòpò yìí ní ọ̀nà kan náà.xs[0] + xs[1] * x + xs[2] * x^2 + .... xs dúró fún àwọn kóòtífítì ti ọ̀kan lára àwọn orúkọ ọ̀pọ̀lọpọ̀.# >>> derivative.call([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative.call([1, 2, 3])\n# [2, 6]\ndef derivative(xs)\n","canonical_solution":"def derivative(xs)\n  return [] if xs.length < 2\n  xs.each_with_index.map { |coef, index| coef * index }[1..-1]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_derivative\n    candidate = method(:derivative)\n    assert_equal([1, 4, 12, 20], candidate.call([3, 1, 2, 4, 5]))\n    assert_equal([2, 6], candidate.call([1, 2, 3]))\n    assert_equal([2, 2], candidate.call([3, 2, 1]))\n    assert_equal([2, 2, 0, 16], candidate.call([3, 2, 1, 0, 4]))\n    assert_equal([], candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_63","nl":"yor_Latn","pl":"rb","prompt":"Jọwọ kọ iṣẹ kan lati ṣe iṣiro daradara ti n-th eroja ti nọmba nọmba fibfib. fibìfì (n) == fibìfì (n-1) + fibìfì (n-2) + fibìfì (n-3). fibìfìììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììfibìfìììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììììfib fib ((0) == 0 Àkọlé FibFib jẹ́ àtẹ̀lé tí ó jọ àtẹ̀lé Fibbonacci tí a fi ṣe àlàyé bí èyí: # >>> fibfib.call(1)\n# 0\n# >>> fibfib.call(5)\n# 4\n# >>> fibfib.call(8)\n# 24\ndef fibfib(n)\n","canonical_solution":"def fibfib(n)\n  return 0 if n == 0 || n == 1\n  return 1 if n == 2\n\n  a, b, c = 0, 0, 1\n  (3..n).each do\n    a, b, c = b, c, a + b + c\n  end\n  c\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fibfib\n    candidate = method(:fibfib)\n    assert_equal(1, candidate.call(2))\n    assert_equal(0, candidate.call(1))\n    assert_equal(4, candidate.call(5))\n    assert_equal(24, candidate.call(8))\n    assert_equal(81, candidate.call(10))\n    assert_equal(274, candidate.call(12))\n    assert_equal(927, candidate.call(14))\n  end\nend\n"},{"task_id":"HumanEval_64","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: ó máa ń wà ní òpin ọ̀rọ̀ kan.Àwọn ọ̀rọ̀ tí a ń pè ní 'a', 'e', 'i', 'o', 'u' ni àwọn ọ̀rọ̀ tí a ń pè ní 'y' nínú ẹsẹ yìí.a ọrọ bi input ati ki o pada awọn nọmba ti vowels ninu awọn okun. Kọ iṣẹ vowels_count ti o gba okun ti o n ṣojuuṣe # >>> vowels_count.call(\"abcde\")\n# 2\n# >>> vowels_count.call(\"ACEDY\")\n# 3\ndef vowels_count(s)\n","canonical_solution":"def vowels_count(s)\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  count = 0\n  \n  s.chars.each_with_index do |char, index|\n    if vowels.include?(char.downcase)\n      count += 1\n    elsif char.downcase == 'y' && index == s.length - 1\n      count += 1\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_vowels_count\n    candidate = method(:vowels_count)\n    assert_equal(2, candidate.call(\"abcde\"))\n    assert_equal(3, candidate.call(\"Alone\"))\n    assert_equal(2, candidate.call(\"key\"))\n    assert_equal(1, candidate.call(\"bye\"))\n    assert_equal(2, candidate.call(\"keY\"))\n    assert_equal(1, candidate.call(\"bYe\"))\n    assert_equal(3, candidate.call(\"ACEDY\"))\n  end\nend\n"},{"task_id":"HumanEval_65","nl":"yor_Latn","pl":"rb","prompt":"Ti shift > iye awọn oniye, pada awọn oniye pada. ó sì dá èsì náà padà gẹ́gẹ́ bí òpó. A máa ń yí àwọn dígítì tí ó wà nínú iye x padà, a máa ń yí àwọn dígítì náà padà sí apá ọ̀tún.# >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12, 2)\n# \"12\"\ndef circular_shift(x, shift)\n","canonical_solution":"def circular_shift(x, shift)\n  digits = x.to_s.chars\n  num_digits = digits.length\n\n  if shift > num_digits\n    return digits.reverse.join\n  else\n    shift = shift % num_digits\n    shifted_digits = digits.rotate(-shift)\n    return shifted_digits.join\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100, 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\", candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"11\", candidate.call(11, 101))\n  end\nend\n"},{"task_id":"HumanEval_66","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Àwọn kókó ASCII. Kọ iṣẹ kan ti o gba okun bi ohun titẹsi ati pada awọn iye ti awọn loke awọn ohun kikọ nikan' Iṣẹ́ # >>> digitSum.call(\"\")\n# 0\n# >>> digitSum.call(\"abAB\")\n# 131\n# >>> digitSum.call(\"abcCd\")\n# 67\n# >>> digitSum.call(\"helloE\")\n# 69\n# >>> digitSum.call(\"woArBld\")\n# 131\n# >>> digitSum.call(\"aAaaaXa\")\n# 153\ndef digitSum(s)\n","canonical_solution":"def digitSum(s)\n  s.chars.select { |char| char =~ \/[A-Z]\/ }.map(&:ord).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digitSum\n    candidate = method(:digitSum)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(131, candidate.call(\"abAB\"))\n    assert_equal(67, candidate.call(\"abcCd\"))\n    assert_equal(69, candidate.call(\"helloE\"))\n    assert_equal(131, candidate.call(\"woArBld\"))\n    assert_equal(153, candidate.call(\"aAaaaXa\"))\n    assert_equal(151, candidate.call(\" How are yOu?\"))\n    assert_equal(327, candidate.call(\"You arE Very Smart\"))\n  end\nend\n"},{"task_id":"HumanEval_67","nl":"yor_Latn","pl":"rb","prompt":"fún àyọkà: nínú apẹ̀rẹ̀ padà sí iye èso mango nínú apẹ̀rẹ̀. àwọn òróró àti èso ápù àti iye kan tó dúró fún iye èso náà Apá, òróró, àti èso mango.tí wọ́n pín sí àgbá èso tí àgbá yìí ní Nínú iṣẹ́ yìí, a ó fún ọ ní ìlà kan tó dúró fún iye èso ápù àti èso ápù.# >>> fruit_distribution.call(\"5 apples and 6 oranges\", 19)\n# 8\n# >>> fruit_distribution.call(\"0 apples and 1 oranges\", 3)\n# 2\n# >>> fruit_distribution.call(\"2 apples and 3 oranges\", 100)\n# 95\n# >>> fruit_distribution.call(\"100 apples and 1 oranges\", 120)\n# 19\ndef fruit_distribution(s, n)\n","canonical_solution":"def fruit_distribution(s, n)\n  numbers = s.scan(\/\\d+\/).map(&:to_i)\n  apples = numbers[0]\n  oranges = numbers[1]\n  total_fruits = n\n  mangos = total_fruits - (apples + oranges)\n  mangos\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fruit_distribution\n    candidate = method(:fruit_distribution)\n    assert_equal(8, candidate.call(\"5 apples and 6 oranges\", 19))\n    assert_equal(10, candidate.call(\"5 apples and 6 oranges\", 21))\n    assert_equal(2, candidate.call(\"0 apples and 1 oranges\", 3))\n    assert_equal(2, candidate.call(\"1 apples and 0 oranges\", 3))\n    assert_equal(95, candidate.call(\"2 apples and 3 oranges\", 100))\n    assert_equal(0, candidate.call(\"2 apples and 3 oranges\", 5))\n    assert_equal(19, candidate.call(\"1 apples and 100 oranges\", 120))\n  end\nend\n"},{"task_id":"HumanEval_68","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ 1: Bí kò bá sí iye tó bá dọ́gba tàbí tí àpapọ̀ tí a fún ní kò sí, padà sí [].A ó dá òpó tí a mú padà nínú àtòjọ, [smallest_value, its index ], Bí a bá rí ọ̀pọ̀lọpọ̀ àwọn ìkànnì pẹ̀lú iye ìdìpọ̀ tó kéré jùlọ, a ó dá ìkànnì tí ó ní ìlà ìlà ìdìpọ̀ tó kéré jùlọ padà. Nódù tí a mú yẹ kó jẹ nóódù tí iye tó kéré jù lọ nínú wọn jẹ́ iye tó dọ́gba.Iṣẹ́ rẹ ni láti fa ọ̀kan nínú àwọn ìkànnì náà, kí o sì dá a padà.\"Nítorí pé a fún wa ní àpapọ̀ tí ó dúró fún ẹ̀ka igi tí ó ní àwọn ìkànnì tí kì í ṣe àbùkù # >>> pluck.call([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck.call([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck.call([])\n# []\n# Example 4:\n# >>> pluck.call([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n","canonical_solution":"def pluck(arr)\n  smallest_even = nil\n  smallest_index = nil\n  \n  arr.each_with_index do |value, index|\n    if value.even?\n      if smallest_even.nil? || value < smallest_even\n        smallest_even = value\n        smallest_index = index\n      end\n    end\n  end\n\n  smallest_even.nil? ? [] : [smallest_even, smallest_index]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"},{"task_id":"HumanEval_69","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Ti ko ba si iye bẹẹ, pada -1. Àìmọye ìgbà tí iye kan ń fara hàn nínú ìlà náà ni iye ìgbà tí iye náà ń fara hàn.zero, ati pe o ni igbohunsafẹfẹ ti o tobi ju tabi dọgba si iye ti iye iye ara rẹ. O ni a fun ọ ni a ti kii-fowo ti awọn nọmba odidi rere. Pada awọn tobi gbogbo iye ti o tobi ju # >>> search.call([4, 1, 2, 2, 3, 1])\n# 2\n# >>> search.call([1, 2, 2, 3, 3, 3, 4, 4, 4])\n# 3\n# >>> search.call([5, 5, 4, 4, 4])\n# -1\ndef search(lst)\n","canonical_solution":"def search(lst)\n  freq_hash = lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }\n  valid_numbers = freq_hash.select { |num, freq| freq >= num }.keys\n  valid_numbers.empty? ? -1 : valid_numbers.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_search\n    candidate = method(:search)\n    assert_equal(1, candidate.call([5, 5, 5, 5, 1]))\n    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))\n    assert_equal(-1, candidate.call([3, 3]))\n    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8, 8, 8]))\n    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))\n    assert_equal(1, candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]))\n    assert_equal(2, candidate.call([3, 2, 8, 2]))\n    assert_equal(1, candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))\n    assert_equal(-1, candidate.call([8, 8, 3, 6, 5, 6, 4]))\n    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))\n    assert_equal(1, candidate.call([1, 9, 10, 1, 3]))\n    assert_equal(5, candidate.call([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))\n    assert_equal(1, candidate.call([1]))\n    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))\n    assert_equal(2, candidate.call([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))\n    assert_equal(1, candidate.call([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))\n    assert_equal(4, candidate.call([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]))\n    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))\n    assert_equal(2, candidate.call([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))\n    assert_equal(-1, candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]))\n    assert_equal(-1, candidate.call([10]))\n    assert_equal(2, candidate.call([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))\n    assert_equal(1, candidate.call([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))\n    assert_equal(1, candidate.call([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))\n    assert_equal(-1, candidate.call([3, 10, 10, 9, 2]))\n  end\nend\n"},{"task_id":"HumanEval_70","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: lẹ́yìn náà, a máa fi iye tó pọ̀ jù lára àwọn iye tó kù sí, a ó sì fi iye tó kéré jù sí, bẹ́ẹ̀ bẹ́ẹ̀ lọ.Ìdìbò tí kò bára dé, ni ìgbà tí o bá bẹ̀rẹ̀ pẹ̀lú iye tí ó kéré jùlọ, Ti a ba fun ni awọn nọmba odidi, pada ni awọn nọmba ni aṣẹ ajeji.# >>> strange_sort_list.call([1, 2, 3, 4])\n# [1, 4, 2, 3]\n# >>> strange_sort_list.call([5, 5, 5, 5])\n# [5, 5, 5, 5]\n# >>> strange_sort_list.call([])\n# []\ndef strange_sort_list(lst)\n","canonical_solution":"def strange_sort_list(lst)\n  result = []\n  lst.sort!\n  until lst.empty?\n    result << lst.shift\n    result << lst.pop unless lst.empty?\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strange_sort_list\n    candidate = method(:strange_sort_list)\n    assert_equal([1, 4, 2, 3], candidate.call([1, 2, 3, 4]))\n    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))\n    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))\n    assert_equal([1, 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))\n    assert_equal([5, 5, 5, 5], candidate.call([5, 5, 5, 5]))\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7, 8]))\n    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2, 5, 5, -5, -5]))\n    assert_equal([111111], candidate.call([111111]))\n  end\nend\n"},{"task_id":"HumanEval_71","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: ju ẹ̀gbẹ́ kẹta lọ.Ìhà mẹ́ta máa ń jẹ́ ẹ̀ẹ̀mẹ́ta tó bá jẹ́ pé iye ìhà méjì tó wà nínú ẹ̀ẹ̀mẹ́ta náà ju iye tó wà nínú ẹ̀ẹ̀mẹ́ta lọ.Bí bẹ́ẹ̀ kọ́ padà sí -1 a ó fi àmì ìlà ìparí méjì yí i ká bí àwọn ìhà mẹ́ta bá jẹ́ òpó mẹ́ta tó bá a mu. Ti a ba fun ni awọn gigun ti awọn ẹgbẹ mẹta ti onigun mẹta kan.# >>> triangle_area.call(3, 4, 5)\n# 6.0\n# >>> triangle_area.call(1, 2, 10)\n# -1\ndef triangle_area(a, b, c)\n","canonical_solution":"def triangle_area(a, b, c)\n  # Check for valid triangle\n  if a + b > c && a + c > b && b + c > a\n    # Calculate the semi-perimeter\n    s = (a + b + c) \/ 2.0\n    # Calculate the area using Heron's formula\n    area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n    # Round to 2 decimal points\n    return area.round(2)\n  else\n    return -1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(6.0, candidate.call(3, 4, 5))\n    assert_equal(-1, candidate.call(1, 2, 10))\n    assert_equal(8.18, candidate.call(4, 8, 5))\n    assert_equal(1.73, candidate.call(2, 2, 2))\n    assert_equal(-1, candidate.call(1, 2, 3))\n    assert_equal(16.25, candidate.call(10, 5, 7))\n    assert_equal(-1, candidate.call(2, 6, 3))\n    assert_equal(0.43, candidate.call(1, 1, 1))\n    assert_equal(-1, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_72","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Ohun q yoo fo ti o ba ti o ba ti wa ni iwontunwonsi (o ti wa ni a palindromic array) ati awọn iye ti awọn oniwe-elemeniti jẹ kere ju tabi dogba si awọn ti o pọju ṣee ṣe iwuwo w. Kọ iṣẹ kan ti o pada si otitọ ti ohun q yoo fo, ati eke bibẹkọ. # >>> will_it_fly.call([1, 2], 5)\n# false\n# # 1+2 is less than the maximum possible weight, but it's unbalanced.\n# >>> will_it_fly.call([3, 2, 3], 1)\n# false\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n# >>> will_it_fly.call([3, 2, 3], 9)\n# true\n# # 3+2+3 is less than the maximum possible weight, and it's balanced.\n# >>> will_it_fly.call([3], 5)\n# true\n# # 3 is less than the maximum possible weight, and it's balanced.\ndef will_it_fly(q, w)\n","canonical_solution":"def will_it_fly(q, w)\n  is_palindrome = q == q.reverse\n  total_weight = q.sum\n  is_balanced_and_under_weight = is_palindrome && total_weight <= w\n  is_balanced_and_under_weight\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_will_it_fly\n    candidate = method(:will_it_fly)\n    assert_equal(true, candidate.call([3, 2, 3], 9))\n    assert_equal(false, candidate.call([1, 2], 5))\n    assert_equal(true, candidate.call([3], 5))\n    assert_equal(false, candidate.call([3, 2, 3], 1))\n    assert_equal(false, candidate.call([1, 2, 3], 6))\n    assert_equal(true, candidate.call([5], 5))\n  end\nend\n"},{"task_id":"HumanEval_73","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: O le yi ohun kan pada si ohun miiran ni iyipada kan. ó nílò láti yí padà láti mú kí àtòjọ náà jẹ́ palindromic. àtòjọ palindromic jẹ́ àtòjọ tí Ti a ba fun ni array arr ti awọn nọmba odidi, wa iye ti o kere ju ti awọn eroja ti # >>> smallest_change.call([1, 2, 3, 5, 4, 7, 9, 6])\n# 4\n# >>> smallest_change.call([1, 2, 3, 4, 3, 2, 2])\n# 1\n# >>> smallest_change.call([1, 2, 3, 2, 1])\n# 0\ndef smallest_change(arr)\n","canonical_solution":"def smallest_change(arr)\n  changes = 0\n  left = 0\n  right = arr.length - 1\n\n  while left < right\n    if arr[left] != arr[right]\n      changes += 1\n    end\n    left += 1\n    right -= 1\n  end\n\n  changes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_smallest_change\n    candidate = method(:smallest_change)\n    assert_equal(4, candidate.call([1, 2, 3, 5, 4, 7, 9, 6]))\n    assert_equal(1, candidate.call([1, 2, 3, 4, 3, 2, 2]))\n    assert_equal(1, candidate.call([1, 4, 2]))\n    assert_equal(1, candidate.call([1, 4, 4, 2]))\n    assert_equal(0, candidate.call([1, 2, 3, 2, 1]))\n    assert_equal(0, candidate.call([3, 1, 1, 3]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(1, candidate.call([0, 1]))\n  end\nend\n"},{"task_id":"HumanEval_74","nl":"yor_Latn","pl":"rb","prompt":"Àwọn Àpẹẹrẹ bí àwọn ìlà méjèèjì bá ní iye kàrà kan náà, dá ìlà àkọ́kọ́ padà.iye gbogbo àwọn ìlà tí ó wà nínú àwọn ìlà náà kéré ju iye ti ìlà mìíràn lọ.Kọ iṣẹ kan ti o gba awọn iṣiro meji ti awọn okun ati pada iṣiro ti o ni # >>> total_match.call([], [])\n# []\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n# [\"hI\", \"Hi\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n# [\"hi\", \"admin\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n# [\"hI\", \"hi\", \"hi\"]\n# >>> total_match.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n# [\"4\"]\ndef total_match(lst1, lst2)\n","canonical_solution":"def total_match(lst1, lst2)\n  total_chars1 = lst1.map(&:length).sum\n  total_chars2 = lst2.map(&:length).sum\n\n  if total_chars1 < total_chars2\n    lst1\n  elsif total_chars2 < total_chars1\n    lst2\n  else\n    lst1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_total_match\n    candidate = method(:total_match)\n    assert_equal([], candidate.call([], []))\n    assert_equal([\"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]))\n    assert_equal([\"4\"], candidate.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]))\n    assert_equal([\"hI\", \"Hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"]))\n    assert_equal([\"hI\", \"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]))\n    assert_equal([], candidate.call([], [\"this\"]))\n    assert_equal([], candidate.call([\"this\"], []))\n  end\nend\n"},{"task_id":"HumanEval_75","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Mímọ̀ pé (a) kéré ju 100. àti èké níbòmíràn.Kọ iṣẹ kan ti o pada si otitọ ti nọmba ti a fun ni ba jẹ igbasilẹ ti awọn nọmba akọkọ 3 # >>> is_multiply_prime.call(30)\n# true\n# 30 = 2 * 3 * 5\ndef is_multiply_prime(a)\n","canonical_solution":"require 'prime'\n\ndef is_multiply_prime(a)\n  return false if a >= 100\n  prime_factors = a.prime_division\n  return true if prime_factors.size == 3 && prime_factors.all? { |_, exponent| exponent == 1 }\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_multiply_prime\n    candidate = method(:is_multiply_prime)\n    assert_equal(false, candidate.call(5))\n    assert_equal(true, candidate.call(30))\n    assert_equal(true, candidate.call(8))\n    assert_equal(false, candidate.call(10))\n    assert_equal(true, candidate.call(125))\n    assert_equal(true, candidate.call(105))\n    assert_equal(false, candidate.call(126))\n    assert_equal(false, candidate.call(729))\n    assert_equal(false, candidate.call(891))\n    assert_equal(true, candidate.call(1001))\n  end\nend\n"},{"task_id":"HumanEval_76","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: x jẹ́ agbára kan tí ó rọrùn láti fi n ṣe bí n**int=x agbara ti n ati eke ni awọn miiran igba. Iṣẹ́ yín ni láti kọ́ iṣẹ́ tí yóò dá òtítọ́ padà bí iye x bá jẹ́ # >>> is_simple_power.call(1, 4)\n# true\n# >>> is_simple_power.call(2, 2)\n# true\n# >>> is_simple_power.call(8, 2)\n# true\n# >>> is_simple_power.call(3, 2)\n# false\n# >>> is_simple_power.call(3, 1)\n# false\n# >>> is_simple_power.call(5, 3)\n# false\ndef is_simple_power(x, n)\n","canonical_solution":"def is_simple_power(x, n)\n  return false if x <= 0 || n <= 1\n  return true if x == 1\n\n  power = n\n  while power <= x\n    return true if power == x\n    power *= n\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_simple_power\n    candidate = method(:is_simple_power)\n    assert_equal(true, candidate.call(16, 2))\n    assert_equal(false, candidate.call(143214, 16))\n    assert_equal(true, candidate.call(4, 2))\n    assert_equal(true, candidate.call(9, 3))\n    assert_equal(true, candidate.call(16, 4))\n    assert_equal(false, candidate.call(24, 2))\n    assert_equal(false, candidate.call(128, 4))\n    assert_equal(false, candidate.call(12, 6))\n    assert_equal(true, candidate.call(1, 1))\n    assert_equal(true, candidate.call(1, 12))\n  end\nend\n"},{"task_id":"HumanEval_77","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Àkíyèsí: o lè gbà pé ìsọfúnni tí o fi sínú rẹ̀ wúlò nígbà gbogbo.bí ó bá jẹ́ pé iye yìí jẹ́ kóbù iye kan tí ó jẹ́ iye pípé.Kọ iṣẹ ti o gba iye odidi a ati ki o pada true # >>> iscube.call(1)\n# true\n# >>> iscube.call(2)\n# false\n# >>> iscube.call(-1)\n# true\n# >>> iscube.call(64)\n# true\n# >>> iscube.call(0)\n# true\n# >>> iscube.call(180)\n# false\ndef iscube(a)\n","canonical_solution":"def iscube(a)\n  cube_root = a.abs**(1.0\/3)\n  cube_root.round**3 == a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_iscube\n    candidate = method(:iscube)\n    assert_equal(true, candidate.call(1))\n    assert_equal(false, candidate.call(2))\n    assert_equal(true, candidate.call(-1))\n    assert_equal(true, candidate.call(64))\n    assert_equal(false, candidate.call(180))\n    assert_equal(true, candidate.call(1000))\n    assert_equal(true, candidate.call(0))\n    assert_equal(false, candidate.call(1729))\n  end\nend\n"},{"task_id":"HumanEval_78","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: ati awọn aami A,B,C,D,E,F nigbagbogbo jẹ nla. Àkíyèsí: o le ro pe ohun ti o wọle jẹ nigbagbogbo tọ tabi okun ofo, B (= decimal 11), D (= decimal 13). Nítorí náà, o ní láti mọ iye kan lára àwọn dígí tó wà nísàlẹ̀ yìí: 2, 3, 5, 7, Àwọn nọ́ńbà àkópọ̀ ni 2, 3, 5, 7, 11, 13, 17,... Àwọn dígí hexadecimal ni 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. o tobi ju 1 ti o jẹ ko kan ọja ti meji kere adayeba awọn nọmba).àwọn dígítì tí ó jẹ́ àwọn dígítì àkọ́kọ́ (ìdíje àkọ́kọ́, tàbí dígítì àkọ́kọ́, jẹ́ àpapọ̀ iye tí ó jẹ́ àdáni a hexadecimal iye bi a okun ati ki o ka awọn nọmba ti hexadecimal A ti fi iṣẹ́ fún ọ láti kọ iṣẹ́ tí ó ń gba # >>> hex_key.call(\"AB\")\n# 1\n# >>> hex_key.call(\"1077E\")\n# 2\n# >>> hex_key.call(\"ABED1A33\")\n# 4\n# >>> hex_key.call(\"123456789ABCDEF0\")\n# 6\n# >>> hex_key.call(\"2020\")\n# 2\ndef hex_key(num)\n","canonical_solution":"def hex_key(num)\n  prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']\n  num.chars.count { |digit| prime_hex_digits.include?(digit) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_hex_key\n    candidate = method(:hex_key)\n    assert_equal(1, candidate.call(\"AB\"))\n    assert_equal(2, candidate.call(\"1077E\"))\n    assert_equal(4, candidate.call(\"ABED1A33\"))\n    assert_equal(2, candidate.call(\"2020\"))\n    assert_equal(6, candidate.call(\"123456789ABCDEF0\"))\n    assert_equal(12, candidate.call(\"112233445566778899AABBCCDDEEFF00\"))\n  end\nend\n"},{"task_id":"HumanEval_79","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Àwọn àmì tó wà lókè yìí wà láti ràn wá lọ́wọ́ láti mọ bí a ṣe máa kọ ọ́. A ó fi àwọn àmì 'db' sí ìbẹ̀rẹ̀ àti òpin ìlà náà.Nọmba. Kọọkan ninu awọn ohun kikọ ni awọn okun yoo jẹ '0' tabi '1'.ìtòlẹ́sẹẹsẹ ìkejì. Àṣiṣẹ́ náà yẹ kí ó dá ìlà padà, pẹ̀lú kọ̀ọ̀kan àwọn àmì tí ó dúró fún ìtòlẹ́sẹẹsẹ ìkejì A ó fún ọ ní nọ́ńbà kan ní ọ̀nà díẹ̀díẹ̀ tí iṣẹ́ rẹ yóò sì jẹ́ láti yí i padà sí # >>> decimal_to_binary.call(15)\n# \"db1111db\"\n# >>> decimal_to_binary.call(32)\n# \"db100000db\"\ndef decimal_to_binary(decimal)\n","canonical_solution":"def decimal_to_binary(decimal)\n  \"db\" + decimal.to_s(2) + \"db\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_decimal_to_binary\n    candidate = method(:decimal_to_binary)\n    assert_equal(\"db0db\", candidate.call(0))\n    assert_equal(\"db100000db\", candidate.call(32))\n    assert_equal(\"db1100111db\", candidate.call(103))\n    assert_equal(\"db1111db\", candidate.call(15))\n  end\nend\n"},{"task_id":"HumanEval_80","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: Àlàfo jẹ haprb bí ì gùn rẹ̀ bá jẹ́ ó kéré tán 3 àti gbogbo lẹ́tà 3 lẹ́sẹ̀-lẹ́sẹ̀ jẹ́ àyàtọ̀ Iṣẹ́ rẹ ni láti ṣàyẹ̀wò bóyá ìlà náà jẹ́ haprb tàbí kò jẹ́ haprb.A fún ọ ní ìlà s. # >>> is_happy.call(\"a\")\n# false\n# >>> is_happy.call(\"aa\")\n# false\n# >>> is_happy.call(\"abcd\")\n# true\n# >>> is_happy.call(\"aabb\")\n# false\n# >>> is_happy.call(\"adb\")\n# true\n# >>> is_happy.call(\"xyy\")\n# false\ndef is_happy(s)\n","canonical_solution":"def is_happy(s)\n  return false if s.length < 3\n  \n  (0..s.length - 3).each do |i|\n    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]\n  end\n  \n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_happy\n    candidate = method(:is_happy)\n    assert_equal(false, candidate.call(\"a\"))\n    assert_equal(false, candidate.call(\"aa\"))\n    assert_equal(true, candidate.call(\"abcd\"))\n    assert_equal(false, candidate.call(\"aabb\"))\n    assert_equal(true, candidate.call(\"adb\"))\n    assert_equal(false, candidate.call(\"xyy\"))\n    assert_equal(true, candidate.call(\"iopaxpoi\"))\n    assert_equal(false, candidate.call(\"iopaxioi\"))\n  end\nend\n"},{"task_id":"HumanEval_81","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: 0.0 E > 0.0 D- > 0.7 D > 1,0 D+ > 1.3 C- > 1.7 C > 2.0 C+ > 2.3 B- > 2.7 B > 3.0 B+ > 3.3 A- > 3.7 A 4.0 A+ GPA. Ìpíndọ́gba ìwé iṣẹ́ tí ó lè mú ìsopọ̀ àwọn ìpele lẹ́tà jáde nípa lílo tábìlì yìí: Ó fún ọ ní àwọn àmì ìdánwò tí ó wà fún àwọn akẹ́kọ̀ọ́ kan , o sì ní láti kọ̀wé .Ìṣòro kan ṣoṣo tó wà ni pé, ó ti pàdánù kọ́ọ̀dì tó fi ń díwọ̀n àwọn ìwé.olùkọ́ náà ti ń ṣe ìlànà tirẹ̀ fún dídánwò.O jẹ ọsẹ ikẹhin ti akoko ẹkọ ati pe olukọ ni lati fun awọn kilasi # >>> grade_equation.call([4.0, 3, 1.7, 2, 3.5])\n# [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\ndef numerical_letter_grade(grades)\n","canonical_solution":"def numerical_letter_grade(grades)\n  grades.map do |gpa|\n    case \n    when gpa == 4.0\n      \"A+\"\n    when gpa > 3.7\n      \"A\"\n    when gpa > 3.3\n      \"A-\"\n    when gpa > 3.0\n      \"B+\"\n    when gpa > 2.7\n      \"B\"\n    when gpa > 2.3\n      \"B-\"\n    when gpa > 2.0\n      \"C+\"\n    when gpa > 1.7\n      \"C\"\n    when gpa > 1.3\n      \"C-\"\n    when gpa > 1.0\n      \"D+\"\n    when gpa > 0.7\n      \"D\"\n    when gpa > 0.0\n      \"D-\"\n    else\n      \"E\"\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_numerical_letter_grade\n    candidate = method(:numerical_letter_grade)\n    assert_equal([\"A+\", \"B\", \"C-\", \"C\", \"A-\"], candidate.call([4.0, 3, 1.7, 2, 3.5]))\n    assert_equal([\"D+\"], candidate.call([1.2]))\n    assert_equal([\"D-\"], candidate.call([0.5]))\n    assert_equal([\"E\"], candidate.call([0.0]))\n    assert_equal([\"D\", \"D-\", \"C-\", \"B\", \"B+\"], candidate.call([1.0, 0.3, 1.5, 2.8, 3.3]))\n    assert_equal([\"E\", \"D-\"], candidate.call([0.0, 0.7]))\n  end\nend\n"},{"task_id":"HumanEval_82","nl":"yor_Latn","pl":"rb","prompt":"Àwọn Àpẹẹrẹ ì gùn jẹ́ iye àkọ́kọ́ tàbí òdì Kọ iṣẹ ti o gba okun ati ki o pada otitọ ti o ba ti okun # >>> prime_length.call(\"Hello\")\n# true\n# >>> prime_length.call(\"abcdcba\")\n# true\n# >>> prime_length.call(\"kittens\")\n# true\n# >>> prime_length.call(\"orange\")\n# false\ndef prime_length(string)\n","canonical_solution":"def prime_length(string)\n  length = string.length\n  return false if length < 2\n\n  (2..Math.sqrt(length)).each do |i|\n    return false if length % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_length\n    candidate = method(:prime_length)\n    assert_equal(true, candidate.call(\"Hello\"))\n    assert_equal(true, candidate.call(\"abcdcba\"))\n    assert_equal(true, candidate.call(\"kittens\"))\n    assert_equal(false, candidate.call(\"orange\"))\n    assert_equal(true, candidate.call(\"wow\"))\n    assert_equal(true, candidate.call(\"world\"))\n    assert_equal(true, candidate.call(\"MadaM\"))\n    assert_equal(true, candidate.call(\"Wow\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"HI\"))\n    assert_equal(true, candidate.call(\"go\"))\n    assert_equal(false, candidate.call(\"gogo\"))\n    assert_equal(false, candidate.call(\"aaaaaaaaaaaaaaa\"))\n    assert_equal(true, candidate.call(\"Madam\"))\n    assert_equal(false, candidate.call(\"M\"))\n    assert_equal(false, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_83","nl":"yor_Latn","pl":"rb","prompt":"àwọn àpapọ̀ àpapọ̀ tó dára tí ó bẹ̀rẹ̀ tàbí tí ó parí ní 1. Ti a ba fun ni iye odidi rere n, pada iye awọn nọmba ti n-digit def starts_one_ends(n)\n","canonical_solution":"def starts_one_ends(n)\n  return 0 if n <= 0\n\n  # Count numbers starting with 1\n  start_with_1 = 9 ** (n - 1)\n\n  # Count numbers ending with 1\n  end_with_1 = 9 ** (n - 1)\n\n  # Adjust for double counting the number that both starts and ends with 1\n  both_start_and_end_with_1 = 9 ** (n - 2) if n > 1\n  \n  start_with_1 + end_with_1 - (both_start_and_end_with_1 || 0)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_starts_one_ends\n    candidate = method(:starts_one_ends)\n    assert_equal(1, candidate.call(1))\n    assert_equal(18, candidate.call(2))\n    assert_equal(180, candidate.call(3))\n    assert_equal(1800, candidate.call(4))\n    assert_equal(18000, candidate.call(5))\n  end\nend\n"},{"task_id":"HumanEval_84","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ Ti a ba fun ni iye odidi rere N, pada si iye lapapọ ti awọn oniwe-digit ni alakomeji. # >>> solve.call(1000)\n# \"1\"\n# >>> solve.call(150)\n# \"110\"\n# >>> solve.call(147)\n# \"1100\"\n# Variables:\n# @N integer\n# Constraints: 0 ≤ N ≤ 10000.\n# Output:\n# a string of binary number\ndef solve(n)\n","canonical_solution":"def solve(n)\n  sum_of_digits = n.to_s.chars.map(&:to_i).sum\n  sum_of_digits.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"1\", candidate.call(1000))\n    assert_equal(\"110\", candidate.call(150))\n    assert_equal(\"1100\", candidate.call(147))\n    assert_equal(\"1001\", candidate.call(333))\n    assert_equal(\"10010\", candidate.call(963))\n  end\nend\n"},{"task_id":"HumanEval_85","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Ti a ba fun ni a ti kii-fowo ti awọn integer lst. fi awọn paati paati ti o wa ni awọn itọka ti ko ni iyatọ .. # >>> add.call([4, 2, 6, 7])\n# 2\ndef add(lst)\n","canonical_solution":"def add(lst)\n  lst.each_with_index.select { |num, index| index.odd? && num.even? }.map(&:first).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(88, candidate.call([4, 88]))\n    assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))\n    assert_equal(0, candidate.call([4, 0, 6, 7]))\n    assert_equal(12, candidate.call([4, 4, 6, 8]))\n  end\nend\n"},{"task_id":"HumanEval_86","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: Àkíyèsí: O yẹ kí o pa ọ̀rọ̀ àti àlàfo inú gbólóhùn náà mọ́. àwọn ìsọfúnni tó wà nínú ìwé ìròyìn yìí ni a kọ sínú ìwé ìròyìn tó wà fún ìkéde yìí.A fi ọ̀rọ̀ tuntun rọ́pò rẹ̀ níbi tí gbogbo àwọn àmì tí a tò sí Ẹya ti a paṣẹ ti okun, jẹ okun nibiti gbogbo awọn ọrọ (ti a ya sọtọ nipasẹ aaye) Kọ iṣẹ ti o gba okun ati ki o pada kan ti paṣẹ ti o.# >>> anti_shuffle.call(\"Hi\")\n# \"Hi\"\n# >>> anti_shuffle.call(\"hello\")\n# \"ehllo\"\n# >>> anti_shuffle.call(\"Hello World!!!\")\n# \"Hello !!!Wdlor\"\ndef anti_shuffle(s)\n","canonical_solution":"def anti_shuffle(s)\n  s.split(\/(\\s+)\/).map { |word| word.chars.sort.join }.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_anti_shuffle\n    candidate = method(:anti_shuffle)\n    assert_equal(\"Hi\", candidate.call(\"Hi\"))\n    assert_equal(\"ehllo\", candidate.call(\"hello\"))\n    assert_equal(\"bemnru\", candidate.call(\"number\"))\n    assert_equal(\"abcd\", candidate.call(\"abcd\"))\n    assert_equal(\"Hello !!!Wdlor\", candidate.call(\"Hello World!!!\"))\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\".Hi My aemn is Meirst .Rboot How aer ?ouy\", candidate.call(\"Hi. My name is Mister Robot. How are you?\"))\n  end\nend\n"},{"task_id":"HumanEval_87","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Bákan náà, ṣa àwọn kóòtìnì ti ìlà náà ní àwọn ọ̀pá ìlà ní ìtọ̀sílẹ̀.Ṣiṣayẹwo awọn ipo-aṣẹ ni ibẹrẹ nipasẹ awọn ila ni aṣẹ ti o nlọ. ìlà kọ̀ọ̀kan jẹ́ àpapọ̀ - (ìlà, ọ̀pá), tí ó bẹ̀rẹ̀ pẹ̀lú 0. ati ki o pada array ti awọn arrays, [(x1, y1), (x2, y2) ...] iru ti Ti a ba fun lst, ati gbogbo nọmba x, wa gbogbo nọmba x ninu array, ọ̀kọ̀ọ̀kan àwọn ìlà lè ní iye ọ̀pá tó yàtọ̀ síra.èyí tí ó jọ matrix, ṣùgbọ́n, tí kò dàbí matrix, A fún ọ ní ìmúlò méjì, bí ìlà tí a so pọ̀, # >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n# >>> get_row.call([], 1)\n# []\n# >>> get_row.call([[], [1], [1, 2, 3]], 3)\n# [[2, 2]]\ndef get_row(lst, x)\n","canonical_solution":"def get_row(lst, x)\n  result = []\n\n  lst.each_with_index do |row, i|\n    row.each_with_index do |value, j|\n      result << [i, j] if value == x\n    end\n  end\n\n  result.sort_by { |coord| [coord[0], -coord[1]] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"},{"task_id":"HumanEval_88","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: * má ṣe yí àtòjọ tí a fún ọ padà. Àkíyèsí: tàbí kó o ṣa á ní ìtọ́ka tó ń lọ sí ìsàlẹ̀ bí iye ((ìkókókó iye, ìkótán iye iye) bá jẹ́ ìkan náà. o ó ṣa àwọn ìlà tí a fún ní ìtọ́ka tí ó ń gòkè bí iye ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlàTi a ba fun ni awọn iṣiro ti awọn nọmba odidi ti kii ṣe odi, pada a corb ti awọn iṣiro ti a fun lẹhin ti tito lẹsẹsẹ, # >>> sort_array.call([])\n# []\n# >>> sort_array.call([5])\n# [5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5])\n# [0, 1, 2, 3, 4, 5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5, 6])\n# [6, 5, 4, 3, 2, 1, 0]\ndef sort_array(array)\n","canonical_solution":"def sort_array(array)\n  return array if array.empty? || array.size == 1\n\n  if (array.first + array.last).odd?\n    array.sort\n  else\n    array.sort.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([], candidate.call([]))\n    assert_equal([5], candidate.call([5]))\n    assert_equal([0, 1, 2, 3, 4, 5], candidate.call([2, 4, 3, 0, 1, 5]))\n    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2, 4, 3, 0, 1, 5, 6]))\n    assert_equal([1, 2], candidate.call([2, 1]))\n    assert_equal([0, 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))\n    assert_equal([23, 21, 14, 11], candidate.call([21, 14, 23, 11]))\n  end\nend\n"},{"task_id":"HumanEval_89","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: yí padà sí ìsàlẹ̀ ní ìlọ́po méjì sí ibi méjì.Ó yẹ kí ááfábẹ́ẹ̀tì yí padà lọ síbi tí àwọn lẹ́tà náà ti fara hàn.ó dá òpó tí a fi àdàkọ tí a fi àdàkọ tí a fi àdàkọ tí a fi àdàkọ tí a fi àdàkọ tí a fi àdàkọ tí a fi àdàkọ padà padà padà. Ṣẹda iṣẹ encrypt ti o gba okun bi àlàyé ati # >>> encrypt.call(\"hi\")\n# \"lm\"\n# >>> encrypt.call(\"asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt.call(\"gf\")\n# \"kj\"\n# >>> encrypt.call(\"et\")\n# \"ix\"\ndef encrypt(s)\n","canonical_solution":"def encrypt(s)\n  s.chars.map do |char|\n    if char =~ \/[a-z]\/\n      ((char.ord - 'a'.ord + 4) % 26 + 'a'.ord).chr\n    elsif char =~ \/[A-Z]\/\n      ((char.ord - 'A'.ord + 4) % 26 + 'A'.ord).chr\n    else\n      char\n    end\n  end.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\", candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"e\", candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_90","nl":"yor_Latn","pl":"rb","prompt":"Yi pada nil ti ko ba si iru nkan bẹẹ. Kọ iṣẹ next_smallest (() tí ó dá ẹ̀yà kejì tó kéré jùlọ padà nínú àpapọ̀. A fún ọ ní àwọn àpapọ̀ iye tó pé.# >>> next_smallest.call([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest.call([5, 1, 4, 3, 2])\n# 2\n# >>> next_smallest.call([])\n# nil\n# >>> next_smallest.call([1, 1])\n# nil\ndef next_smallest(lst)\n","canonical_solution":"def next_smallest(lst)\n  unique_sorted = lst.uniq.sort\n  unique_sorted.length >= 2 ? unique_sorted[1] : nil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_next_smallest\n    candidate = method(:next_smallest)\n    assert_equal(2, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(1, candidate.call([1, 1, 1, 1, 0]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(-35, candidate.call([-35, 34, 12, -45]))\n  end\nend\n"},{"task_id":"HumanEval_91","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: Àwọn gbólóhùn ni a fi '.', '?' tàbí '!' sápá. ìnira ni gbólóhùn tó bẹ̀rẹ̀ pẹ̀lú ọ̀rọ̀ náà \"èmi\".A ó fún ọ ní ìlà àwọn ọ̀rọ̀, iṣẹ́ rẹ ni láti ka iye náà.# >>> is_bored.call(\"Hello world\")\n# 0\n# >>> is_bored.call(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\ndef is_bored(s)\n","canonical_solution":"def is_bored(s)\n  sentences = s.split(\/(?<=[.?!])\/)\n  sentences.count { |sentence| sentence.strip.start_with?('I') }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_bored\n    candidate = method(:is_bored)\n    assert_equal(0, candidate.call(\"Hello world\"))\n    assert_equal(0, candidate.call(\"Is the sky blue?\"))\n    assert_equal(1, candidate.call(\"I love It !\"))\n    assert_equal(0, candidate.call(\"bIt\"))\n    assert_equal(2, candidate.call(\"I feel good today. I will be productive. will kill It\"))\n    assert_equal(0, candidate.call(\"You and I are going for a walk\"))\n  end\nend\n"},{"task_id":"HumanEval_92","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ Ó dá False padà ní gbogbo ìgbà mìíràn.Yípadà òtítọ́ bí ọ̀kan nínú àwọn iye náà bá dọ́gba sí àpapọ̀ àwọn méjì yòókù, tí gbogbo iye náà sì jẹ́ iye pípé. Ṣẹda iṣẹ-ṣiṣe ti o gba awọn nọmba 3.# >>> any_int.call(5, 2, 7)\n# true\n# >>> any_int.call(3, 2, 2)\n# false\n# >>> any_int.call(3, -2, 1)\n# true\n# >>> any_int.call(3.6, -2.2, 2)\n# false\ndef any_int(x, y, z)\n","canonical_solution":"def any_int(x, y, z)\n  if [x, y, z].all? { |n| n.is_a?(Integer) }\n    x == y + z || y == x + z || z == x + y\n  else\n    false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_any_int\n    candidate = method(:any_int)\n    assert_equal(true, candidate.call(2, 3, 1))\n    assert_equal(false, candidate.call(2.5, 2, 3))\n    assert_equal(false, candidate.call(1.5, 5, 3.5))\n    assert_equal(false, candidate.call(2, 6, 2))\n    assert_equal(true, candidate.call(4, 2, 2))\n    assert_equal(false, candidate.call(2.2, 2.2, 2.2))\n    assert_equal(true, candidate.call(-4, 6, 2))\n    assert_equal(true, candidate.call(2, 1, 1))\n    assert_equal(true, candidate.call(3, 4, 7))\n    assert_equal(false, candidate.call(3.0, 4, 7))\n  end\nend\n"},{"task_id":"HumanEval_93","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Àwọn lẹ́tà nìkan ni kó o máa lò.ohùn tó wà nínú álífábẹ́ẹ̀tì èdè Gẹ̀ẹ́sì.ifiranṣẹ pẹlu lẹta ti o han 2 awọn aaye niwaju ti Ọ̀nà tí ó fi ń yípò àwọn lẹ́tà, tí ó sì ń rọ́pò gbogbo àwọn òǹkà nínú Kọ iṣẹ kan ti o gba ifiranṣẹ kan, ati ki o ṣe akojọpọ ninu iru a # >>> encode.call(\"test\")\n# \"TGST\"\n# >>> encode.call(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\ndef encode(message)\n","canonical_solution":"def encode(message)\n  vowels = 'aeiou'\n  swap_vowels = {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w'}\n  \n  encoded_message = message.chars.map do |char|\n    if vowels.include?(char.downcase)\n      new_char = swap_vowels[char.downcase]\n      char == char.upcase ? new_char.upcase : new_char.downcase\n    else\n      char == char.upcase ? char.downcase : char.upcase\n    end\n  end\n\n  encoded_message.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"},{"task_id":"HumanEval_94","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: O ní láti wá iye àkọ́kọ́ tó tóbi jùlọ, kó o sì dá iye àwọn dígítì rẹ̀ padà.A fún ọ ní àwọn àpapọ̀ iye tó pé.# >>> skjkasdkd.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n# 10\n# >>> skjkasdkd.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n# 25\n# >>> skjkasdkd.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n# 13\n# >>> skjkasdkd.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n# 11\n# >>> skjkasdkd.call([0, 81, 12, 3, 1, 21])\n# 3\n# >>> skjkasdkd.call([0, 8, 1, 2, 1, 7])\n# 7\ndef skjkasdkd(lst)\n","canonical_solution":"def skjkasdkd(lst)\n  require 'prime'\n\n  # Find the largest prime number in the array\n  largest_prime = lst.select { |num| Prime.prime?(num) }.max\n  \n  # Return 0 if no prime number is found\n  return 0 if largest_prime.nil?\n\n  # Calculate the sum of digits of the largest prime number\n  largest_prime.to_s.chars.map(&:to_i).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_skjkasdkd\n    candidate = method(:skjkasdkd)\n    assert_equal(10, candidate.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))\n    assert_equal(25, candidate.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))\n    assert_equal(13, candidate.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))\n    assert_equal(11, candidate.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))\n    assert_equal(3, candidate.call([0, 81, 12, 3, 1, 21]))\n    assert_equal(7, candidate.call([0, 8, 1, 2, 1, 7]))\n    assert_equal(19, candidate.call([8191]))\n    assert_equal(19, candidate.call([8191, 123456, 127, 7]))\n    assert_equal(10, candidate.call([127, 97, 8192]))\n  end\nend\n"},{"task_id":"HumanEval_95","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Iṣẹ́ náà yẹ kí ó padà sí èké ni ìsókè tí a fún ní kò ní nǹkan. case tabi gbogbo kókó jẹ ìlà ní uppercase, else return false. Ti a ba fun ni hash, pada si otitọ ti gbogbo awọn bọtini ba jẹ awọn okun ni kekere # >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n","canonical_solution":"def check_dict_case(dict)\n  return false if dict.empty?\n\n  lowercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.downcase }\n  uppercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.upcase }\n\n  lowercase_keys || uppercase_keys\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n"},{"task_id":"HumanEval_96","nl":"yor_Latn","pl":"rb","prompt":"bí àpẹẹrẹ: àwọn àpapọ̀ tí ó jẹ́ àwọn iye àkọ́kọ́ tí ó sì kéré ju n lọ. Ṣẹda iṣẹ kan ti o gba nọmba ti ko ni odi ati pada si iṣiro ti akọkọ n # >>> count_up_to.call(5)\n# [2, 3]\n# >>> count_up_to.call(11)\n# [2, 3, 5, 7]\n# >>> count_up_to.call(0)\n# []\n# >>> count_up_to.call(20)\n# [2, 3, 5, 7, 11, 13, 17, 19]\n# >>> count_up_to.call(1)\n# []\n# >>> count_up_to.call(18)\n# [2, 3, 5, 7, 11, 13, 17]\ndef count_up_to(n)\n","canonical_solution":"def count_up_to(n)\n  return [] if n <= 2\n  primes = []\n  (2...n).each do |num|\n    is_prime = true\n    (2..Math.sqrt(num)).each do |i|\n      if num % i == 0\n        is_prime = false\n        break\n      end\n    end\n    primes << num if is_prime\n  end\n  primes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_up_to\n    candidate = method(:count_up_to)\n    assert_equal([2, 3], candidate.call(5))\n    assert_equal([2, 3, 5], candidate.call(6))\n    assert_equal([2, 3, 5], candidate.call(7))\n    assert_equal([2, 3, 5, 7], candidate.call(10))\n    assert_equal([], candidate.call(0))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))\n    assert_equal([], candidate.call(1))\n    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))\n  end\nend\n"},{"task_id":"HumanEval_97","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Gbé èrò wípé ìsọfúnni tí a fi sínú rẹ̀ jẹ́ èyí tí ó tọ́ nígbà gbogbo.ìlọ́po iye tí wọ́n fi ń ṣe ẹyọ kọ̀ọ̀kan. Ṣẹ́ ẹ̀rí tí ó gba iye méjì tí ó sì padà # >>> multiply.call(148, 412)\n# 16\n# >>> multiply.call(19, 28)\n# 72\n# >>> multiply.call(2020, 1851)\n# 0\n# >>> multiply.call(14, -15)\n# 20\ndef multiply(a, b)\n","canonical_solution":"def multiply(a, b)\n  a_unit_digit = a.abs % 10\n  b_unit_digit = b.abs % 10\n  a_unit_digit * b_unit_digit\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_multiply\n    candidate = method(:multiply)\n    assert_equal(16, candidate.call(148, 412))\n    assert_equal(72, candidate.call(19, 28))\n    assert_equal(0, candidate.call(2020, 1851))\n    assert_equal(20, candidate.call(14, -15))\n    assert_equal(42, candidate.call(76, 67))\n    assert_equal(49, candidate.call(17, 27))\n    assert_equal(0, candidate.call(0, 1))\n    assert_equal(0, candidate.call(0, 0))\n  end\nend\n"},{"task_id":"HumanEval_98","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: Ti a ba fun ọ ni okun s, ka iye awọn ohun orin nla ni awọn itọka paapaa. # >>> count_upper.call(\"aBCdEf\")\n# 1\n# >>> count_upper.call(\"abcdefg\")\n# 0\n# >>> count_upper.call(\"dBBE\")\n# 0\ndef count_upper(s)\n","canonical_solution":"def count_upper(s)\n  vowels = ['A', 'E', 'I', 'O', 'U']\n  count = 0\n\n  s.chars.each_with_index do |char, index|\n    if index.even? && vowels.include?(char)\n      count += 1\n    end\n  end\n\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"EEEE\"))\n  end\nend\n"},{"task_id":"HumanEval_99","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ láti orí iye méjì, a ó yí i po láti orí iye òsì.ó sì dá iye tó sún mọ́ ọn jùlọ padà.Ṣẹda iṣẹ ti o gba iye (ìjà) ti o nṣafihan nọmba kan # >>> closest_integer.call(\"10\")\n# 10\n# >>> closest_integer.call(\"15.3\")\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\ndef closest_integer(value)\n","canonical_solution":"def closest_integer(value)\n  number = value.to_f\n  if number > 0\n    (number + 0.5).floor\n  else\n    (number - 0.5).ceil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_100","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: i jẹ́ iye òkúta tó wà ní ìpele (i+1).Yi pada awọn nọmba ti okuta ni kọọkan ipele ni ohun array, ibi ti eroja ni itọka - iye tó tẹ̀ lé e tó bá jẹ́ pé n jẹ́ iye tó bára mu. - iye tó tẹ̀ lé e tí kò bá dọ́gba tí n bá jẹ́ dọ́gba. Nọmba awọn okuta ni ipele ti o tẹle ni: Ìpele àkọ́kọ́ ní òkúta n.Nípa fífi iye kan tó dára n, o ní láti ṣe ìdìpọ̀ kan tí ó ní ìpele n ti òkúta.# >>> make_a_pile.call(3)\n# [3, 5, 7]\ndef make_a_pile(n)\n","canonical_solution":"def make_a_pile(n)\n  result = []\n  current_stones = n\n  n.times do\n    result << current_stones\n    current_stones += 2\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_a_pile\n    candidate = method(:make_a_pile)\n    assert_equal([3, 5, 7], candidate.call(3))\n    assert_equal([4, 6, 8, 10], candidate.call(4))\n    assert_equal([5, 7, 9, 11, 13], candidate.call(5))\n    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))\n    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))\n  end\nend\n"},{"task_id":"HumanEval_101","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: láti pín ìlà náà sí ọ̀rọ̀ àti láti dá àtòjọ àwọn ọ̀rọ̀ padà.A ó fún ọ ní ìlà àwọn ọ̀rọ̀ tí a fi àlàfo tàbí àlàfo yàtọ̀. Iṣẹ́ rẹ ni # >>> words_string.call(\"Hi, my name is John\")\n# [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# >>> words_string.call(\"One, two, three, four, five, six\")\n# [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\ndef words_string(s)\n","canonical_solution":"def words_string(s)\n  s.split(\/[\\s,]+\/)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_string\n    candidate = method(:words_string)\n    assert_equal([\"Hi\", \"my\", \"name\", \"is\", \"John\"], candidate.call(\"Hi, my name is John\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One, two, three, four, five, six\"))\n    assert_equal([\"Hi\", \"my\", \"name\"], candidate.call(\"Hi, my name\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One,, two, three, four, five, six,\"))\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"ahmed\", \"gamal\"], candidate.call(\"ahmed     , gamal\"))\n  end\nend\n"},{"task_id":"HumanEval_102","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: kò sí irú iye bẹ́ẹ̀, nígbà náà iṣẹ́ náà yóò padà sí -1.Nọmba odidi to tobi julọ ti o wa ni ibiti [x, y] pẹlu.Ojú-iṣẹ́ yìí gba iye rere méjì x àti y ó sì dá  padà# >>> choose_num.call(12, 15)\n# 14\n# >>> choose_num.call(13, 12)\n# -1\ndef choose_num(x, y)\n","canonical_solution":"def choose_num(x, y)\n  return -1 if x > y\n  # Start looking from the largest number\n  max_even = y.even? ? y : y - 1\n  # Iterate downwards to find the biggest even number\n  max_even.downto(x) do |n|\n    return n if n.even?\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_choose_num\n    candidate = method(:choose_num)\n    assert_equal(14, candidate.call(12, 15))\n    assert_equal(-1, candidate.call(13, 12))\n    assert_equal(12354, candidate.call(33, 12354))\n    assert_equal(-1, candidate.call(5234, 5233))\n    assert_equal(28, candidate.call(6, 29))\n    assert_equal(-1, candidate.call(27, 10))\n    assert_equal(-1, candidate.call(7, 7))\n    assert_equal(546, candidate.call(546, 546))\n  end\nend\n"},{"task_id":"HumanEval_103","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Bí n bá tóbi ju m lọ, padà sí -1.Ṣe àyípo ìdáhùn náà sí iye tó súnmọ́ ọnà kan, kó o sì yí i padà sí iye méjì.apapọ awọn nọmba odidi lati n si m (pẹlu n ati m). A fún ọ ní àwọn iye tó ṣe é kà n àti m, iṣẹ́ rẹ ni láti ṣe àròpòsò # >>> rounded_avg.call(1, 5)\n# \"0b11\"\n# >>> rounded_avg.call(7, 5)\n# -1\n# >>> rounded_avg.call(10, 20)\n# \"0b1111\"\n# >>> rounded_avg.call(20, 33)\n# \"0b11010\"\ndef rounded_avg(n, m)\n","canonical_solution":"def rounded_avg(n, m)\n  return -1 if n > m\n\n  sum = (n..m).reduce(:+)\n  count = m - n + 1\n  average = (sum.to_f \/ count).round\n  \"0b\" + average.to_i.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1, 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996, 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362, 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7, 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5, 5))\n  end\nend\n"},{"task_id":"HumanEval_104","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: Àkíyèsí: Àtòjọ tí a dá pada gbọdọ̀ wà ní ipò tí ó ń pọ̀ sí i.àwọn èròjà tí kò ní dígítì tó jẹ́ párà.Fi fun a array ti rere integers x. pada a ti yan array ti gbogbo # >>> unique_digits.call([15, 33, 1422, 1])\n# [1, 15, 33]\n# >>> unique_digits.call([152, 323, 1422, 10])\n# []\ndef unique_digits(x)\n","canonical_solution":"def unique_digits(x)\n  x.select { |num| num.to_s.chars.none? { |digit| digit.to_i.even? } }.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15, 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n    assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31, 135], candidate.call([135, 103, 31]))\n  end\nend\n"},{"task_id":"HumanEval_105","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: \"Ẹnìkan\", \"Ẹnìkan méjì\", \"Ẹnìkan mẹ́ta\", \"Ẹnìkan mẹ́rin\", \"Ẹnìkan márùn-ún\", \"Ẹnìkan mẹ́fà\", \"Ẹnìkan méje\", \"Ẹnìkan mẹ́jọ\", \"Ẹnìkan mẹ́sàn-án\".yí àbájáde ìdìpọ̀ padà, kí o sì fi orúkọ tó bá a mu dípò dígítì kọ̀ọ̀kan láti inú Ti a ba fun ni awọn iṣiro ti awọn nọmba odidi, yan awọn nọmba odidi ti o wa laarin 1 ati 9 pẹlu, # >>> by_length.call([2, 1, 1, 4, 5, 8, 2, 3])\n# [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n# If the array is empty, return an empty array:\n# >>> by_length.call([])\n# []\n# If the array has any strange number ignore it:\n# >>> by_length.call([1, -1, 55])\n# [\"One\"]\ndef by_length(arr)\n","canonical_solution":"def by_length(arr)\n  number_names = {\n    1 => \"One\",\n    2 => \"Two\",\n    3 => \"Three\",\n    4 => \"Four\",\n    5 => \"Five\",\n    6 => \"Six\",\n    7 => \"Seven\",\n    8 => \"Eight\",\n    9 => \"Nine\"\n  }\n\n  filtered_sorted_reversed = arr.select { |x| x.between?(1, 9) }.sort.reverse\n  filtered_sorted_reversed.map { |num| number_names[num] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_by_length\n    candidate = method(:by_length)\n    assert_equal([\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], candidate.call([2, 1, 1, 4, 5, 8, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([\"One\"], candidate.call([1, -1, 55]))\n    assert_equal([\"Three\", \"Two\", \"One\"], candidate.call([1, -1, 3, 2]))\n    assert_equal([\"Nine\", \"Eight\", \"Four\"], candidate.call([9, 4, 8]))\n  end\nend\n"},{"task_id":"HumanEval_106","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: ìfipínlẹ̀ ti i ni ìfipínlẹ̀ àwọn iye láti 1 sí i (1 * 2 * ... * i).Mo bẹ̀rẹ̀ láti 1.tàbí iye iye tí ó wà láti 1 dé i. ó sì dá àwárí tí ó tóbi n padà, tí iye ti eroja ní index i jẹ́ factorial ti i bí i bá jẹ́ paapa Ṣẹda iṣẹ f ti o gba n bi paramita, # >>> f.call(5)\n# [1, 2, 6, 24, 15]\ndef f(n)\n","canonical_solution":"def f(n)\n  (1..n).map do |i|\n    if i.even?\n      (1..i).inject(:*) || 1\n    else\n      (1..i).inject(:+)\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_f\n    candidate = method(:f)\n    assert_equal([1, 2, 6, 24, 15], candidate.call(5))\n    assert_equal([1, 2, 6, 24, 15, 720, 28], candidate.call(7))\n    assert_equal([1], candidate.call(1))\n    assert_equal([1, 2, 6], candidate.call(3))\n  end\nend\n"},{"task_id":"HumanEval_107","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ 1: àwọn palindromes iye-pupọ tí ó wà láàrín àlàfo ((1, n), pẹlu. Ti a ba fun ni iye odidi rere n, a o pada ni array ti o ni iye ti o jẹ paapa ati alailẹgbẹ # >>> even_odd_palindrome.call(3)\n# [1, 2]\n# Explanation:\n# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# >>> even_odd_palindrome.call(12)\n# [4, 6]\n# Explanation:\n# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n# 1. 1 <= n <= 10^3\n# 2. returned array has the number of even and odd integer palindromes respectively.\ndef even_odd_palindrome(n)\n","canonical_solution":"def even_odd_palindrome(n)\n  even_count = 0\n  odd_count = 0\n\n  (1..n).each do |num|\n    if num.to_s == num.to_s.reverse\n      if num.even?\n        even_count += 1\n      else\n        odd_count += 1\n      end\n    end\n  end\n\n  [even_count, odd_count]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_palindrome\n    candidate = method(:even_odd_palindrome)\n    assert_equal([8, 13], candidate.call(123))\n    assert_equal([4, 6], candidate.call(12))\n    assert_equal([1, 2], candidate.call(3))\n    assert_equal([6, 8], candidate.call(63))\n    assert_equal([5, 6], candidate.call(25))\n    assert_equal([4, 6], candidate.call(19))\n    assert_equal([4, 5], candidate.call(9))\n    assert_equal([0, 1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_108","nl":"yor_Latn","pl":"rb","prompt":"bí àpẹẹrẹ, -123 ní àmì dígítì -1, 2, àti 3. Bí iye kan bá jẹ́ àyínìke, nígbà náà, dígí àkọ́kọ́ tí a fi àmì sí yóò jẹ́ àyínìke: iye àwọn ohun tó ní iye dígí tó pọ̀ ju 0 lọ. Kọ iṣẹ count_nums ti o gba awọn iṣiro ti awọn nọmba odidi ati awọn pada # >>> count_nums.call([])\n# 0\n# >>> count_nums.call([-1, 11, -11])\n# 1\n# >>> count_nums.call([1, 1, 2])\n# 3\ndef count_nums(arr)\n","canonical_solution":"def count_nums(arr)\n  arr.count do |num|\n    num.to_s.chars.map(&:to_i).sum > 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_nums\n    candidate = method(:count_nums)\n    assert_equal(0, candidate.call([]))\n    assert_equal(0, candidate.call([-1, -2, 0]))\n    assert_equal(6, candidate.call([1, 1, 2, -2, 3, 4, 5]))\n    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))\n    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))\n    assert_equal(5, candidate.call([12, 23, 34, -45, -56, 0]))\n    assert_equal(1, candidate.call([0, 1]))\n    assert_equal(1, candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_109","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: Àkíyèsí: Àpapọ̀ tí a fún ni a ṣe ìdánilójú pé ó ní àwọn ohun tó jẹ́ àrà ọ̀tọ̀.Ti o ba ti fi fun awọn array jẹ ofo ki o si pada otitọ. wá padà sí òótọ́ tàbí padà sí irọ́. Ti o ba ti o ba ṣee ṣe lati gba awọn ti a ti yan array nipa ṣiṣe awọn loke isẹ ipo ibẹrẹ ninu awọn array ie 0th atọka. A ó gbé ohun èlò tí ó kẹ́yìn nínú àpapọ̀ náà sí Ìṣiṣẹ́ ìyípadà ọ̀tún kan túmọ̀ sí yípadà gbogbo àwọn ohun tó wà nínú àpapọ̀ náà ní ẹyọ kan.O le ṣe iṣẹ yiyi ọtun ni iye igba ti o fẹ.iṣẹ́ tí ó tẹ̀lé e lórí ìlà tí a fún: ó ṣeé ṣe láti rí àtòjọ tí a kò fi sí ní ìyípadà nípa ṣíṣe àwọn nọ́ńbà inú àtẹ̀jíṣẹ́ náà yóò jẹ́ èyí tí a pàṣẹ láìṣe àbáwọlé. iṣẹ́ rẹ ni láti mọ̀ bóyá A ní ìlà 'arr' ti N àwọn àpapọ̀ àpapọ̀ arr[1], arr[2], ..., arr[N].# >>> move_one_ball.call([3, 4, 5, 1, 2])\n# true\n# Explanation: By performin 2 right shift operations, non-decreasing order can\n# be achieved for the given array.\n# >>> move_one_ball.call([3, 5, 4, 1, 2])\n# false\n# Explanation:It is not possible to get non-decreasing order for the given\n# array by performing any number of right shift operations.\ndef move_one_ball(arr)\n","canonical_solution":"def move_one_ball(arr)\n  return true if arr.empty?\n\n  n = arr.size\n  count_rotation_point = 0\n  rotation_index = -1\n\n  (0...n).each do |i|\n    next_index = (i + 1) % n\n    if arr[i] > arr[next_index]\n      count_rotation_point += 1\n      rotation_index = next_index\n    end\n  end\n\n  count_rotation_point <= 1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_move_one_ball\n    candidate = method(:move_one_ball)\n    assert_equal(true, candidate.call([3, 4, 5, 1, 2]))\n    assert_equal(true, candidate.call([3, 5, 10, 1, 2]))\n    assert_equal(false, candidate.call([4, 3, 1, 2]))\n    assert_equal(false, candidate.call([3, 5, 4, 1, 2]))\n    assert_equal(true, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_110","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: Bí bẹ́ẹ̀ kọ́, dá \"KÒ\" padà.gbogbo àwọn ohun tó wà nínú lst1 láti jẹ́ páropáro, dá \"YES\" padà.Ti o ba ti o ba ṣee ṣe lati paṣipaarọ eroja laarin awọn lst1 ati lst2 lati ṣe Kò sí ààlà lórí iye àwọn ohun tí a lè pààrọ̀ láàrin lst1 àti lst2.laarin wọn lati ṣe lst1 ohun array ti nikan ani awọn nọmba. ó sì ń pinnu bóyá ó ṣeé ṣe láti ṣe pàṣípààrọ̀ àwọn ohun èlò Ninu iṣoro yii, ẹ o ṣe iṣẹ kan ti o gba awọn iṣiro meji ti awọn nọmba, # >>> exchange.call([1, 2, 3, 4], [1, 2, 3, 4])\n# \"YES\"\n# >>> exchange.call([1, 2, 3, 4], [1, 5, 3, 4])\n# \"NO\"\n# It is assumed that the input arrays will be non-empty.\ndef exchange(lst1, lst2)\n","canonical_solution":"def exchange(lst1, lst2)\n  # Check if lst1 already consists solely of even numbers\n  return \"YES\" if lst1.all?(&:even?)\n\n  # Check if there are at least as many even numbers in lst2\n  # as there are odd numbers in lst1\n  odd_count_lst1 = lst1.count(&:odd?)\n  even_count_lst2 = lst2.count(&:even?)\n\n  odd_count_lst1 <= even_count_lst2 ? \"YES\" : \"NO\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_exchange\n    candidate = method(:exchange)\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [1, 2, 3, 4]))\n    assert_equal(\"NO\", candidate.call([1, 2, 3, 4], [1, 5, 3, 4]))\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [2, 1, 4, 3]))\n    assert_equal(\"YES\", candidate.call([5, 7, 3], [2, 6, 4]))\n    assert_equal(\"NO\", candidate.call([5, 7, 3], [2, 6, 3]))\n    assert_equal(\"NO\", candidate.call([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))\n    assert_equal(\"YES\", candidate.call([100, 200], [200, 200]))\n  end\nend\n"},{"task_id":"HumanEval_111","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Bí àwọn lẹ́tà bíi mélòó kan bá ní ìṣẹ̀lẹ̀ kan náà, dá gbogbo wọn padà. lẹ́tà tó máa ń sọ ọ̀rọ̀ náà ní ọ̀pọ̀lọpọ̀ ìgbà tó sì ní iye tó bá a mu wé e. Ti a ba fun ọ ni okun ti o ṣe aṣoju awọn lẹta kekere ti a ya sọtọ, pada hash kan # >>> histogram.call(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" => 1}\n# >>> histogram.call(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"b b b b a\")\n# {\"b\" => 4}\n# >>> histogram.call(\"\")\n# {}\ndef histogram(test)\n","canonical_solution":"def histogram(test)\n  return {} if test.empty?\n\n  count = Hash.new(0)\n\n  test.split.each do |char|\n    count[char] += 1\n  end\n\n  max_count = count.values.max\n  count.select { |_, value| value == max_count }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1, \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4}, candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_112","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ O yẹ ki o pada ni ohun array ti o ni awọn esi okun ati ki o otitọ \/ eke fun awọn ayẹwo. Àwo n àwon ìlà ni a n pè ní palindrome bí ó bá kà bí ó ti kà síwájú àti s eyìn.lẹ́yìn náà ṣàyẹ̀wò bóyá ìlà tí ó jẹ́ àbájáde jẹ́ palindrome. A fún wa ní àwọn ìlà méjì s àti c, o ní láti pa gbogbo àwọn àmì nínú s tí ó bá dọ́gba sí àwọn àmì nínú c Iṣẹ́ # >>> reverse_delete.call(\"abcde\", \"ae\")\n# [\"bcd\", false]\n# >>> reverse_delete.call(\"abcdef\", \"b\")\n# [\"acdef\", false]\n# >>> reverse_delete.call(\"abcdedcba\", \"ab\")\n# [\"cdedc\", true]\ndef reverse_delete(s, c)\n","canonical_solution":"def reverse_delete(s, c)\n  # Remove all characters in c from s\n  filtered_string = s.delete(c)\n  \n  # Check if the filtered string is a palindrome\n  is_palindrome = filtered_string == filtered_string.reverse\n  \n  # Return the result array\n  [filtered_string, is_palindrome]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_reverse_delete\n    candidate = method(:reverse_delete)\n    assert_equal([\"bcd\", false], candidate.call(\"abcde\", \"ae\"))\n    assert_equal([\"acdef\", false], candidate.call(\"abcdef\", \"b\"))\n    assert_equal([\"cdedc\", true], candidate.call(\"abcdedcba\", \"ab\"))\n    assert_equal([\"dik\", false], candidate.call(\"dwik\", \"w\"))\n    assert_equal([\"\", true], candidate.call(\"a\", \"a\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"v\"))\n    assert_equal([\"abba\", true], candidate.call(\"vabba\", \"v\"))\n    assert_equal([\"\", true], candidate.call(\"mamma\", \"mia\"))\n  end\nend\n"},{"task_id":"HumanEval_113","nl":"yor_Latn","pl":"rb","prompt":"ti odd awọn oniye ni awọn i'th okun ti awọn wiwọle. ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápáKọọkan eroja i ti awọn jade yẹ ki o jẹ \"nọmba ti odd eroja ni awọn Ti a ba fun ni ìlà ti àwọn ìlà, níbi tí ìlà kọ̀ọ̀kan ti ní àwọn dígítì nìkan, padà sí ìlà kan.# >>> odd_count.call([\"1234567\"])\n# [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n# >>> odd_count.call([\"3\", \"11111111\"])\n# [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\ndef odd_count(lst)\n","canonical_solution":"def odd_count(lst)\n  lst.map do |num_str|\n    count = num_str.count('13579')\n    \"the number of odd elements #{count}n the str#{count}ng #{count} of the #{count}nput.\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_odd_count\n    candidate = method(:odd_count)\n    assert_equal([\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], candidate.call([\"1234567\"]))\n    assert_equal([\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], candidate.call([\"3\", \"11111111\"]))\n    assert_equal([\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"], candidate.call([\"271\", \"137\", \"314\"]))\n  end\nend\n"},{"task_id":"HumanEval_114","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ àwọn èèyàn.Ti a ba fun ni apapo awọn nọmba odidi n, wa iye to kere julọ ti eyikeyi awọn ipin-apapo ti ko ṣofo # >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])\n# 1\n# >>> minSubArraySum.call([-1, -2, -3])\n# -6\ndef minSubArraySum(nums)\n","canonical_solution":"def minSubArraySum(nums)\n  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    if current_sum > 0\n      current_sum = num\n    else\n      current_sum += num\n    end\n    min_sum = [min_sum, current_sum].min\n  end\n  min_sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minSubArraySum\n    candidate = method(:minSubArraySum)\n    assert_equal(1, candidate.call([2, 3, 4, 1, 2, 4]))\n    assert_equal(-6, candidate.call([-1, -2, -3]))\n    assert_equal(-14, candidate.call([-1, -2, -3, 2, -10]))\n    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))\n    assert_equal(0, candidate.call([0, 10, 20, 1000000]))\n    assert_equal(-6, candidate.call([-1, -2, -3, 10, -5]))\n    assert_equal(-6, candidate.call([100, -1, -2, -3, 10, -5]))\n    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))\n    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))\n    assert_equal(-10, candidate.call([-10]))\n    assert_equal(7, candidate.call([7]))\n    assert_equal(-1, candidate.call([1, -1]))\n  end\nend\n"},{"task_id":"HumanEval_115","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ 1: Ṣàkọsílẹ̀ iye ìgbà tí o nílò láti tú àwọn ìgò náà.Iṣẹ́ yín ni láti fi àwọn korobá náà tú àwọn kànga náà.gbogbo àgbá náà sì ní agbára ìmúlẹ̀pọ̀ kan náà.Ìkùdu kọ̀ọ̀kan ní àgbá tó bá a mu, èyí tí a lè fi fa omi jáde nínú rẹ̀, àti pé 1 kọ̀ọ̀kan nínú ìlà kan dúró fún ẹyọ omi kan ṣoṣo. A fún ọ ní àlàfo onígun mẹ́rin ti àwọn ìkùdu. Ìlà kọ̀ọ̀kan dúró fún ìkùdu kan ṣoṣo, # >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example 2:\n# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill.call([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\ndef max_fill(grid, capacity)\n","canonical_solution":"def max_fill(grid, capacity)\n  total_water_units = grid.flatten.sum\n  (total_water_units.to_f \/ capacity).ceil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0, candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 9))\n  end\nend\n"},{"task_id":"HumanEval_116","nl":"yor_Latn","pl":"rb","prompt":"O gbọdọ wa ni ṣe bi yi: Fun iye ti o jọra ti awọn kan, yan da lori iye iye mẹwa. Nọmba awọn kan ninu aṣoju meji wọn ni aṣẹ ti o npọ si. Nínú Kata yìí, o ní láti yan àwọn àpapọ̀ iye tí kò jẹ́ àbùkù ní ìbámu pẹ̀lú # >>> sort_array.call([1, 5, 2, 3, 4])\n# [1, 2, 3, 4, 5]\n# >>> sort_array.call([-2, -3, -4, -5, -6])\n# [-6, -5, -4, -3, -2]\n# >>> sort_array.call([1, 0, 2, 3, 4])\n# [0, 1, 2, 3, 4]\ndef sort_array(arr)\n","canonical_solution":"def sort_array(arr)\n  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([1, 2, 4, 3, 5], candidate.call([1, 5, 2, 3, 4]))\n    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3, -4, -5, -6]))\n    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))\n    assert_equal([], candidate.call([]))\n    assert_equal([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))\n    assert_equal([32, 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n  end\nend\n"},{"task_id":"HumanEval_117","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Àkíyèsí: o lè gbà pé ìsọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀ ìkọ̀rọ̀Ti s ba jẹ ofo, iṣẹ naa yẹ ki o pada si awo-ara ti o ṣofo. n àwọn ọ̀rọ̀ tó ń bára mu, kí àwọn ọ̀rọ̀ yìí lè fara hàn nínú ọ̀rọ̀ tó ń bára mu s. a iṣẹ ti o pada ohun array ti gbogbo awọn ọrọ lati okun s ti o ni gangan Ti a ba fun ọ ni okun s ati nọmba adayeba n, a ti fun ọ ni iṣẹ lati ṣe # >>> select_words.call(\"Mary had a little lamb\", 4)\n# [\"little\"]\n# >>> select_words.call(\"Mary had a little lamb\", 3)\n# [\"Mary\", \"lamb\"]\n# >>> select_words.call(\"simple white space\", 2)\n# []\n# >>> select_words.call(\"Hello world\", 4)\n# [\"world\"]\n# >>> select_words.call(\"Uncle sam\", 3)\n# [\"Uncle\"]\ndef select_words(s, n)\n","canonical_solution":"def select_words(s, n)\n  vowels = \"aeiouAEIOU\"\n  words = s.split\n  words.select do |word|\n    consonant_count = word.chars.count { |char| !vowels.include?(char) }\n    consonant_count == n\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_select_words\n    candidate = method(:select_words)\n    assert_equal([\"little\"], candidate.call(\"Mary had a little lamb\", 4))\n    assert_equal([\"Mary\", \"lamb\"], candidate.call(\"Mary had a little lamb\", 3))\n    assert_equal([], candidate.call(\"simple white space\", 2))\n    assert_equal([\"world\"], candidate.call(\"Hello world\", 4))\n    assert_equal([\"Uncle\"], candidate.call(\"Uncle sam\", 3))\n    assert_equal([], candidate.call(\"\", 4))\n    assert_equal([\"b\", \"c\", \"d\", \"f\"], candidate.call(\"a b c d e f\", 1))\n  end\nend\n"},{"task_id":"HumanEval_118","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: O le ro pe awọn ti a fi fun okun ni o ni awọn English lẹta nikan. rí àwọn òǹkà ohùn tó bá bá ipò tó wà lókè yìí mu.Àwọn òǹkà nínú ìbẹ̀rẹ̀ àti òpin kò kà. Fi òǹkà òfo padà bí o kò bá ṣe bẹ́ẹ̀.àwọn òǹkà méjì láti apá ọ̀tún ọ̀rọ̀ (ìmọ̀ràn nípa bí a ṣe ń kọ ọ̀rọ̀ tó ṣe pàtàkì tó).A fún ọ ní ọ̀rọ̀ kan. Iṣẹ́ rẹ ni láti wá ohùn tó sún mọ́ ọn jù lọ tí ó wà láàárín wọn.# >>> get_closest_vowel.call(\"yogurt\")\n# \"u\"\n# >>> get_closest_vowel.call(\"FULL\")\n# \"U\"\n# >>> get_closest_vowel.call(\"quick\")\n# \"\"\n# >>> get_closest_vowel.call(\"ab\")\n# \"\"\ndef get_closest_vowel(word)\n","canonical_solution":"def get_closest_vowel(word)\n  vowels = \"aeiouAEIOU\"\n  (1...word.length - 1).reverse_each do |i|\n    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])\n      return word[i]\n    end\n  end\n  return \"\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_closest_vowel\n    candidate = method(:get_closest_vowel)\n    assert_equal(\"u\", candidate.call(\"yogurt\"))\n    assert_equal(\"u\", candidate.call(\"full\"))\n    assert_equal(\"\", candidate.call(\"easy\"))\n    assert_equal(\"\", candidate.call(\"eAsy\"))\n    assert_equal(\"\", candidate.call(\"ali\"))\n    assert_equal(\"a\", candidate.call(\"bad\"))\n    assert_equal(\"o\", candidate.call(\"most\"))\n    assert_equal(\"\", candidate.call(\"ab\"))\n    assert_equal(\"\", candidate.call(\"ba\"))\n    assert_equal(\"\", candidate.call(\"quick\"))\n    assert_equal(\"i\", candidate.call(\"anime\"))\n    assert_equal(\"\", candidate.call(\"Asia\"))\n    assert_equal(\"o\", candidate.call(\"Above\"))\n  end\nend\n"},{"task_id":"HumanEval_119","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Fi 'Bẹẹni' pada ti o ba jẹ pe ọna kan wa lati ṣe okun ti o dara, ati fi 'Bẹẹkọ' pada bibẹkọ. \" (()) \" kò sí. jẹ iwontunwonsi. Fun apẹẹrẹ: okun '(())))' dara, lakoko ti okun A kà S sí òpó tí ó dára bí àti kìkì bí gbogbo àwọn àlàfo nínú S àwọn ìlà tí ó jẹ́ àbájáde yóò dára.Iṣẹ́ yín ni láti ṣàyẹ̀wò bóyá ó ṣeé ṣe láti so àwọn ìlà méjèèjì pọ̀ mọ́ra.àwọn àlàfo \" ((\" tàbí àwọn àlàfo tó súnmọ́ ara wọn \") \" nìkan. A fún ọ ní àpapọ̀ ìlà méjì, ìlà méjèèjì ní ìjápọ̀ ìlà méjì.# >>> match_parens.call([\"()(\", \")\"])\n# \"Yes\"\n# >>> match_parens.call([\")\", \")\"])\n# \"No\"\ndef match_parens(lst)\n","canonical_solution":"def match_parens(lst)\n  a, b = lst\n\n  # Define a helper method to check if a string is balanced\n  def balanced?(s)\n    count = 0\n    s.each_char do |c|\n      count += 1 if c == '('\n      count -= 1 if c == ')'\n      return false if count < 0\n    end\n    count == 0\n  end\n\n  # Check if either concatenation forms a good string\n  if balanced?(a + b) || balanced?(b + a)\n    \"Yes\"\n  else\n    \"No\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_match_parens\n    candidate = method(:match_parens)\n    assert_equal(\"Yes\", candidate.call([\"()(\", \")\"]))\n    assert_equal(\"No\", candidate.call([\")\", \")\"]))\n    assert_equal(\"No\", candidate.call([\"(()(())\", \"())())\"]))\n    assert_equal(\"Yes\", candidate.call([\")())\", \"(()()(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(())))\", \"(()())((\"]))\n    assert_equal(\"No\", candidate.call([\"()\", \"())\"]))\n    assert_equal(\"Yes\", candidate.call([\"(()(\", \"()))()\"]))\n    assert_equal(\"No\", candidate.call([\"((((\", \"((())\"]))\n    assert_equal(\"No\", candidate.call([\")(()\", \"(()(\"]))\n    assert_equal(\"No\", candidate.call([\")(\", \")(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(\", \")\"]))\n    assert_equal(\"Yes\", candidate.call([\")\", \"(\"]))\n  end\nend\n"},{"task_id":"HumanEval_120","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ 1: ti ipari k pẹlu awọn nọmba k ti o pọju ni arr. Ti a ba fun ni array ti awọn iye odidi ati nọmba odidi rere k, pada ni array ti a yan # >>> maximum.call([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum.call([4, -4, 4], 2)\n# [4, 4]\n# Example 3:\n# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1], 1)\n# [2]\n# Note:\n# 1. The length of the array will be in the range of [1, 1000].\n# 2. The elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\ndef maximum(arr, k)\n","canonical_solution":"def maximum(arr, k)\n  arr.sort.last(k).sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3, -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2], candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123, -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123, 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5, 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2, 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n    assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10], candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23, 243, -400, 0], 0))\n  end\nend\n"},{"task_id":"HumanEval_121","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ Ti a ba fun ni a non-empty array of integers, pada ni iye ti gbogbo awọn ti awọn ohun ti o jẹ odd ti o wa ni awọn ipo paapaa. # >>> solution.call([5, 8, 7, 1])\n# 12\n# >>> solution.call([3, 3, 3, 3, 3])\n# 9\n# >>> solution.call([30, 13, 24, 321])\n# 0\ndef solution(lst)\n","canonical_solution":"def solution(lst)\n  lst.each_with_index.reduce(0) do |sum, (val, idx)|\n    (idx.even? && val.odd?) ? sum + val : sum\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solution\n    candidate = method(:solution)\n    assert_equal(12, candidate.call([5, 8, 7, 1]))\n    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))\n    assert_equal(0, candidate.call([30, 13, 24, 321]))\n    assert_equal(5, candidate.call([5, 9]))\n    assert_equal(0, candidate.call([2, 4, 8]))\n    assert_equal(23, candidate.call([30, 13, 23, 32]))\n    assert_equal(3, candidate.call([3, 13, 2, 9]))\n  end\nend\n"},{"task_id":"HumanEval_122","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: iye ti awọn eroja pẹlu o kere ju awọn oni nọmba meji lati awọn k akọkọ eroja ti arr. Ti a ba fun ni a non-empty array ti awọn nọmba arọ ati k kan, pada # >>> add_elements.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n# 24\n# Constraints:\n# 1. 1 <= len(arr) <= 100\n# 2. 1 <= k <= len(arr)\ndef add_elements(arr, k)\n","canonical_solution":"def add_elements(arr, k)\n  arr.first(k).select { |num| num.abs.to_s.length <= 2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add_elements\n    candidate = method(:add_elements)\n    assert_equal(-4, candidate.call([1, -2, -3, 41, 57, 76, 87, 88, 99], 3))\n    assert_equal(0, candidate.call([111, 121, 3, 4000, 5, 6], 2))\n    assert_equal(125, candidate.call([11, 21, 3, 90, 5, 6, 7, 8, 9], 4))\n    assert_equal(24, candidate.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))\n    assert_equal(1, candidate.call([1], 1))\n  end\nend\n"},{"task_id":"HumanEval_123","nl":"yor_Latn","pl":"rb","prompt":"get_odd_collatz(5) á dá [1, 5] # Àtòjọ collatz fún 5 ni [5, 16, 8, 4, 2, 1], nítorí náà àwọn iye tí kò bára mu jẹ 1, àti 5. Bí àpẹẹrẹ: 2. fi àlàfo tí ó padà wá sípò sípò sípò sípò.1. Àkójọ ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlà ìlàÀkíyèsí: term plus 1. ìyókù ni pé kò sí iye tí n jẹ́, ìsọ̀rí náà yóò dé 1. Ti o ba ti tẹlẹ ni awọn ofin jẹ odd, awọn wọnyi ni awọn ofin jẹ 3 igba ti awọn ti tẹlẹ Previous term bí èyí: bí term tó ṣáájú bá jẹ́ párà, term tó tẹ̀lé e jẹ́ ìdajì bí èyí: bẹ̀rẹ̀ pẹ̀lú iye àpapọ̀ rere n. Nígbà náà ni a ó gba gbogbo ẹ̀ka láti inú Àròyé Collatz jẹ́ àròyé nínú ìṣirò tí ó níí ṣe pẹ̀lú ìtòlẹ́sẹẹsẹ tí a mọ̀ Ti a ba fun ni iye odidi rere n, pada ni iṣiro ti a ti yan ti o ni awọn nọmba alailẹgbẹ ni lẹsẹsẹ collatz. # >>> get_odd_collatz.call(5)\n# [1, 5]\ndef get_odd_collatz(n)\n","canonical_solution":"def get_odd_collatz(n)\n  collatz_sequence = []\n  while n != 1\n    collatz_sequence << n if n.odd?\n    if n.even?\n      n = n \/ 2\n    else\n      n = 3 * n + 1\n    end\n  end\n  collatz_sequence << 1 if n == 1\n\n  collatz_sequence.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_odd_collatz\n    candidate = method(:get_odd_collatz)\n    assert_equal([1, 5, 7, 11, 13, 17], candidate.call(14))\n    assert_equal([1, 5], candidate.call(5))\n    assert_equal([1, 3, 5], candidate.call(12))\n    assert_equal([1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_124","nl":"yor_Latn","pl":"rb","prompt":"4.Ọjọ́ náà yóò wà ní oríṣiríṣi: mm-dd-yyyy 3. Àwọn oṣù kò gbọdọ̀ dín ní 1 tàbí ju 12 lọ.2. Awọn nọmba ti ọjọ ni ko kere ju 1 tabi ti o ga ju 31 ọjọ fun osu 1,3,5,7,8,10,12. ati awọn nọmba ti ọjọ ni ko kere ju 1 tabi ti o ga ju 30 ọjọ fun osu 4,6,9,11. ati, awọn nọmba ti ọjọ ni ko kere ju 1 tabi ti o ga ju 29 fun osu 2. 1. Àlàfo ọjọ́ kò ní àlàfo.Ọjọ́ náà yóò jẹ́ èyí tó bá ní òye tó bá gbogbo ìlànà tó wà nísàlẹ̀ yìí mu: ó dá òtítọ́ padà bí ọjọ́ náà bá ṣe pàtàkì tí kò bá ṣe bẹ́ẹ̀, irọ́. O ní láti kọ iṣẹ́ tí ó fi àdàkọ ọjọ́ tí a fún ní ìdánimọ̀ hàn àti # >>> valid_date.call(\"03-11-2000\")\n# true\n# >>> valid_date.call(\"15-01-2012\")\n# false\n# >>> valid_date.call(\"04-0-2040\")\n# false\n# >>> valid_date.call(\"06-04-2020\")\n# true\n# >>> valid_date.call(\"06\/04\/2020\")\n# false\ndef valid_date(date)\n","canonical_solution":"def valid_date(date)\n  return false if date.nil? || date.empty?\n  \n  # Check if the date format is correct\n  match = date.match(\/^(\\d{2})-(\\d{2})-(\\d{4})$\/)\n  return false unless match\n  \n  month, day, year = match.captures.map(&:to_i)\n  \n  # Check if month is valid\n  return false if month < 1 || month > 12\n  \n  # Check if day is valid according to the month\n  case month\n  when 1, 3, 5, 7, 8, 10, 12\n    return day >= 1 && day <= 31\n  when 4, 6, 9, 11\n    return day >= 1 && day <= 30\n  when 2\n    return day >= 1 && day <= 29\n  else\n    return false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_valid_date\n    candidate = method(:valid_date)\n    assert_equal(true, candidate.call(\"03-11-2000\"))\n    assert_equal(false, candidate.call(\"15-01-2012\"))\n    assert_equal(false, candidate.call(\"04-0-2040\"))\n    assert_equal(true, candidate.call(\"06-04-2020\"))\n    assert_equal(true, candidate.call(\"01-01-2007\"))\n    assert_equal(false, candidate.call(\"03-32-2011\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"04-31-3000\"))\n    assert_equal(true, candidate.call(\"06-06-2005\"))\n    assert_equal(false, candidate.call(\"21-31-2000\"))\n    assert_equal(true, candidate.call(\"04-12-2003\"))\n    assert_equal(false, candidate.call(\"04122003\"))\n    assert_equal(false, candidate.call(\"20030412\"))\n    assert_equal(false, candidate.call(\"2003-04\"))\n    assert_equal(false, candidate.call(\"2003-04-12\"))\n    assert_equal(false, candidate.call(\"04-2003\"))\n  end\nend\n"},{"task_id":"HumanEval_125","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ alfabeti, ì °ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ì 'ìyẹ ki o pin lori awọn koma ',' ti o ba ti ko ba si koma o yẹ ki o pada awọn nọmba ti kekere-case awọn lẹta pẹlu odd aṣẹ ni awọn Ti a fun ni okun ọrọ kan, pada ni iṣupọ awọn ọrọ ti a pin lori aaye funfun, ti ko ba si aaye funfun ninu ọrọ ti o # >>> split_words.call(\"Hello world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"Hello,world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"abcdef\")\n# 3\ndef split_words(txt)\n","canonical_solution":"def split_words(txt)\n  if txt.include?(' ')\n    return txt.split(' ')\n  elsif txt.include?(',')\n    return txt.split(',')\n  else\n    odd_count = txt.chars.count { |char| ('a'..'z').include?(char) && (char.ord - 'a'.ord).odd? }\n    return odd_count\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_split_words\n    candidate = method(:split_words)\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello world!\"))\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello,world!\"))\n    assert_equal([\"Hello\", \"world,!\"], candidate.call(\"Hello world,!\"))\n    assert_equal([\"Hello,Hello,world\", \"!\"], candidate.call(\"Hello,Hello,world !\"))\n    assert_equal(3, candidate.call(\"abcdef\"))\n    assert_equal(2, candidate.call(\"aaabb\"))\n    assert_equal(1, candidate.call(\"aaaBb\"))\n    assert_equal(0, candidate.call(\"\"))\n  end\nend\n"},{"task_id":"HumanEval_126","nl":"yor_Latn","pl":"rb","prompt":"Àwọn Àpẹẹrẹ number, return false. Rò ó wò ó pé kò sí àwọn iye tí kò tọ́ àti àwọn iye tó pé nìkan. If array has more than 1 duplicate of the same  ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ì ìTi a ba fun ni awọn nọmba, pada boya wọn ti wa ni tito lẹsẹsẹ tabi rara # >>> is_sorted.call([5])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5])\n# false\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6, 7])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5, 6, 7])\n# false\n# >>> is_sorted.call([1, 2, 2, 3, 3, 4])\n# true\n# >>> is_sorted.call([1, 2, 2, 2, 3, 4])\n# false\ndef is_sorted(lst)\n","canonical_solution":"def is_sorted(lst)\n  lst.each_cons(2).with_index do |(a, b), index|\n    return false if a > b\n    return false if index < lst.length - 2 && a == b && lst[index + 2] == b\n  end\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_sorted\n    candidate = method(:is_sorted)\n    assert_equal(true, candidate.call([5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))\n    assert_equal(true, candidate.call([]))\n    assert_equal(true, candidate.call([1]))\n    assert_equal(false, candidate.call([3, 2, 1]))\n    assert_equal(false, candidate.call([1, 2, 2, 2, 3, 4]))\n    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 2, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_127","nl":"yor_Latn","pl":"rb","prompt":"[ìwọ̀n\/ìwọ̀n] àwọn àwòkó: Bí àlàfo méjèèjì kò bá bára wọn pàdé, dá \"KÒ\" padà.bí bẹ́ẹ̀ kọ́, dá \"KÒ SÍ\" padà. Ti ipari ti awọn agbelebu jẹ kan akọkọ nọmba, pada \"BẸẸNI\", tí gígùn rẹ̀ jẹ́ 1, tí kì í ṣe nóńbà àkọ́kọ́.Àpẹẹrẹ, ìkékúrú àwọn àlàfo (1, 3), (2, 4) jẹ (2, 3) àwọn àlàfo jẹ́ iye àkọ́kọ́.Iṣẹ́ yín ni láti mọ̀ bóyá gígùn ìkékúrú àwọn méjèèjì yìí Fun gbogbo àlàfo ti a fun, a ro pe ibẹrẹ rẹ kere ju tabi dọgba si ipari rẹ.ó ní ìbẹ̀rẹ̀ àti òpin nínú. Awọn aarin ti a fun ni pipade eyi ti o tumo si wipe aarin (bẹrẹ, opin) níbi tí àlàfo kòkòrò jẹ́ ìkejì àwọn iye tó pé. Bí àpẹẹrẹ, àlàfo = (ìbẹ̀rẹ̀, òpin) = (1, 2).A fún ọ ní àlàfo méjì, # >>> intersection.call([1, 2], [2, 3])\n# \"NO\"\n# >>> intersection.call([-1, 1], [0, 4])\n# \"NO\"\n# >>> intersection.call([-3, -1], [-5, 5])\n# \"YES\"\ndef intersection(interval1, interval2)\n","canonical_solution":"def intersection(interval1, interval2)\n  start1, end1 = interval1\n  start2, end2 = interval2\n\n  intersection_start = [start1, start2].max\n  intersection_end = [end1, end2].min\n\n  if intersection_start > intersection_end\n    return \"NO\"\n  end\n\n  intersection_length = intersection_end - intersection_start + 1\n\n  return \"YES\" if prime?(intersection_length)\n\n  \"NO\"\nend\n\ndef prime?(n)\n  return false if n <= 1\n  return true if n == 2 || n == 3\n\n  (2..Math.sqrt(n).to_i).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersection\n    candidate = method(:intersection)\n    assert_equal(\"NO\", candidate.call([1, 2], [2, 3]))\n    assert_equal(\"NO\", candidate.call([-1, 1], [0, 4]))\n    assert_equal(\"YES\", candidate.call([-3, -1], [-5, 5]))\n    assert_equal(\"YES\", candidate.call([-2, 2], [-4, 0]))\n    assert_equal(\"NO\", candidate.call([-11, 2], [-1, -1]))\n    assert_equal(\"NO\", candidate.call([1, 2], [3, 5]))\n    assert_equal(\"NO\", candidate.call([1, 2], [1, 2]))\n    assert_equal(\"NO\", candidate.call([-2, -2], [-3, -2]))\n  end\nend\n"},{"task_id":"HumanEval_128","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Àkíyèsí: padà nil fún òfo arr. ti nọmba kọọkan ninu awọn array, ti o duro fun nipa 1, -1 tabi 0. iye iye ti awọn nọmba odidi ti o pọ si nipasẹ ọja ti gbogbo awọn ami A fún ọ ní array kan ti àwọn iye tó pé, o sì ní láti dá a padà.# >>> prod_signs.call([1, 2, 2, -4])\n# 9\n# >>> prod_signs.call([0, 1])\n# 0\n# >>> prod_signs.call([])\n# nil\ndef prod_signs(arr)\n","canonical_solution":"def prod_signs(arr)\n  return nil if arr.empty?\n  \n  product_signs = arr.reduce(1) { |prod, num| prod * num <=> 0 }\n  sum_magnitudes = arr.map(&:abs).sum\n  \n  product_signs * sum_magnitudes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"},{"task_id":"HumanEval_129","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Yípadà àtòjọ tí ó wà ní àṣẹ àwọn iye lórí àwọn sẹ́ẹ̀lì tí ọ̀nà tí ó kéré jùlọ kọjá.Ó dájú pé ìdáhùn náà kò ní àrà ọ̀tọ̀. lst_A[j] = lst_B[j]. irú èyí tí lst_A[i] < lst_B[i] àti fún gbogbo j (1 <= j < i) a ní ju lst_B, ni awọn ọrọ miiran, nibẹ ni o wa kan gbogbo nọmba atọka i (1 <= i <= k) nipasẹ (jẹ ki a pe wọn lst_A ati lst_B), lst_A jẹ lexicographically kere si Lẹhin ti ṣiṣe awọn ti paṣẹ arrays ti awọn iye lori awọn sẹẹli ti A ati B lọ Awon ipa ona A (ti o gun k) ni a ka si kere ju ipa ona B (ti o gun k) bi o ba je pe O Ò LÈ pa dà síbi tó ò dé rí.ó lè máà rí bẹ́ẹ̀.Jọwọ ṣe akiyesi pe ọna ti ipari k tumọ si wiwo gangan k awọn sẹẹli (kii ṣe ì ì ì ìní ọ̀rọ̀ mìíràn, o lè lọ sí àwọn sẹẹli tí ó ní àlàfo kan pẹ̀lú ẹ̀rọ rẹláti inú sẹẹli èyíkéyìí, àti ní ìgbésẹ̀ kọ̀ọ̀kan o lè lọ sí èyíkéyìí nínú sẹẹli aládùúgbò, O ní láti wá ojú òpó tí ó kéré jùlọ tí gígùn k wà nínú gírìdì.inclusive máa ń fara hàn ní ẹ̀ẹ̀kan pàtó nínú àwọn sẹ́ẹ̀lì inú àlàfo náà. gbogbo sẹẹli ti àlàfo ní iye kan. gbogbo iye tó wà ní àlàfo [1, N * N] Ti a ba fi àlàfo kan pẹlu awọn ila N ati awọn ọwọn N (N >= 2) ati nọmba odidi rere k, # >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n# [1, 2, 1]\n# >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n# [1]\ndef minPath(grid, k)\n","canonical_solution":"def minPath(grid, k)\n  n = grid.size\n  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n  min_path = nil\n\n  n.times do |i|\n    n.times do |j|\n      queue = [[[i, j], [grid[i][j]]]]\n      until queue.empty?\n        position, path = queue.shift\n        if path.size == k\n          min_path = path if min_path.nil? || path < min_path\n          next\n        end\n        directions.each do |dx, dy|\n          x, y = position[0] + dx, position[1] + dy\n          if x.between?(0, n-1) && y.between?(0, n-1)\n            queue.push([[x, y], path + [grid[x][y]]])\n          end\n        end\n      end\n    end\n  end\n  min_path\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minPath\n    candidate = method(:minPath)\n    assert_equal([1, 2, 1], candidate.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))\n    assert_equal([1], candidate.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))\n    assert_equal([1, 2, 1, 2], candidate.call([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))\n    assert_equal([1, 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7))\n    assert_equal([1, 7, 1, 7, 1], candidate.call([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8))\n    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8))\n    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], candidate.call([[1, 2], [3, 4]], 10))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))\n  end\nend\n"},{"task_id":"HumanEval_130","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: àwọn nọ́ńbà àkọ́kọ́ n + 1 nínú àwọn nọ́ńbà tí wọ́n ń tẹ̀ lé ara wọn nínú ìlà Tribonacci. A fún ọ ní iye kan tí kì í ṣe àyínìke n, o ní láti dá array ti  padà.= 2 + 3 + 3 = 8 tri(3) = tri(2) + tri(1) + tri(4) tri ((4) = 3 tri(2) = 1 + (2 \/ 2) = 2 Bí àpẹẹrẹ: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), bí n bá jẹ́ aláìlóǹkà. tri ((n) = 1 + n \/ 2, bí n bá jẹ́ pé ó jẹ́ ìjùmọ̀. tri(1) = 3 Àkọlé ìkọ̀rọ̀ tí a mọ̀ sí Tribonacci jẹ́:Sibẹsibẹ, ohun ti awọn eniyan ko mọ ni awọn Tribonacci itẹlera.Gbogbo ènìyàn ló mọ̀ nípa ìtòlẹ́sẹẹsẹ Fibonacci, àwọn onímọ̀ ìṣirò ti kẹ́kọ̀ọ́ rẹ̀ jinlẹ̀ ní # >>> tri.call(3)\n# [1, 3, 2, 8]\ndef tri(n)\n","canonical_solution":"def tri(n)\n  sequence = [1, 3]\n  \n  (2..n).each do |i|\n    if i.even?\n      sequence[i] = 1 + i \/ 2\n    else\n      sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1] rescue 0\n    end\n  end\n  \n  sequence[0..n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_tri\n    candidate = method(:tri)\n    assert_equal([1, 3, 2, 8], candidate.call(3))\n    assert_equal([1, 3, 2, 8, 3], candidate.call(4))\n    assert_equal([1, 3, 2, 8, 3, 15], candidate.call(5))\n    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35], candidate.call(9))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))\n    assert_equal([1], candidate.call(0))\n    assert_equal([1, 3], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_131","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: Yi 0 pada ti gbogbo awọn oni nọmba ba jẹ paati. Ti a ba fun ni iye odidi rere n, pada si ọja ti awọn nọmba alailẹgbẹ. # >>> digits.call(1)\n# 1\n# >>> digits.call(4)\n# 0\n# >>> digits.call(235)\n# 15\ndef digits(n)\n","canonical_solution":"def digits(n)\n  odd_digits = n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }\n  return 0 if odd_digits.empty?\n  odd_digits.reduce(:*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5, candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5, candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625, candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"},{"task_id":"HumanEval_132","nl":"yor_Latn","pl":"rb","prompt":"níbi tí ó kéré tán, àlàfo kan nínú àlàfo náà ti wà ní ìpamọ́.Iṣẹ́ náà yẹ kí ó padà true bí ó bá sì jẹ́ pé ó wà ní ìsàlẹ̀ ìsínlọ́wọ́ tó bágbà mu Ṣẹda iṣẹ ti o gba okun bi wiwọle ti o ni awọn ibọwọ onigun mẹrin nikan. # >>> is_nested.call(\"[[]]\")\n# true\n# >>> is_nested.call(\"[]]]]]]][[[[[]\")\n# false\n# >>> is_nested.call(\"[][]\")\n# false\n# >>> is_nested.call(\"[]\")\n# false\n# >>> is_nested.call(\"[[][]]\")\n# true\n# >>> is_nested.call(\"[[]][[\")\n# true\ndef is_nested(string)\n","canonical_solution":"def is_nested(string)\n  stack = []\n  has_nested = false\n\n  string.each_char do |char|\n    if char == '['\n      stack.push(char)\n    elsif char == ']'\n      if stack.empty?\n        return false\n      end\n      stack.pop\n      has_nested = true if stack.any?\n    end\n  end\n\n  has_nested\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_nested\n    candidate = method(:is_nested)\n    assert_equal(true, candidate.call(\"[[]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]][[[[[]\"))\n    assert_equal(false, candidate.call(\"[][]\"))\n    assert_equal(false, candidate.call(\"[]\"))\n    assert_equal(true, candidate.call(\"[[[[]]]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]]]]]\"))\n    assert_equal(true, candidate.call(\"[][][[]]\"))\n    assert_equal(false, candidate.call(\"[[]\"))\n    assert_equal(false, candidate.call(\"[]]\"))\n    assert_equal(true, candidate.call(\"[[]][[\"))\n    assert_equal(true, candidate.call(\"[[][]]\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"[[[[[[[[\"))\n    assert_equal(false, candidate.call(\"]]]]]]]]\"))\n  end\nend\n"},{"task_id":"HumanEval_133","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Ojú-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwòye-ìwò-ìwò-ìwò-ìwò-ìwò-ìwò-ìwò-ìwò-ìwò-ìwòO nílò láti dá àpapọ̀ àwọn iye tí ó wà ní àléàbà nínú àtòjọ tí a fún ọ, A fún ọ ní àwọn nọ́ńbà.# >>> lst.call([1.0, 2.0, 3.0])\n# 14\n# >>> lst.call([1.0, 4.0, 9.0])\n# 98\n# >>> lst.call([1.0, 3.0, 5.0, 7.0])\n# 84\n# >>> lst.call([1.4, 4.2, 0.0])\n# 29\n# >>> lst.call([-2.4, 1.0, 1.0])\n# 6\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map { |num| (num.ceil)**2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(84, candidate.call([1.0, 3.0, 5.0, 7.0]))\n    assert_equal(29, candidate.call([1.4, 4.2, 0.0]))\n    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))\n    assert_equal(10230, candidate.call([100.0, 1.0, 15.0, 2.0]))\n    assert_equal(200000000, candidate.call([10000.0, 10000.0]))\n    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))\n    assert_equal(1086, candidate.call([-1.4, 17.9, 18.9, 19.9]))\n    assert_equal(0, candidate.call([0.0]))\n    assert_equal(1, candidate.call([-1.0]))\n    assert_equal(2, candidate.call([-1.0, 1.0, 0.0]))\n  end\nend\n"},{"task_id":"HumanEval_134","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Àkíyèsí: \"ọ̀rọ̀\" jẹ́ àwùjọ àwọn òǹkọ̀wé tí a fi àlàfo yàtọ̀.apá kan nínú ọ̀rọ̀, tí kò sì tòótọ́.ti a fi fun okun jẹ ohun alphabetical ohun kikọ ati ki o jẹ ko Ṣẹda iṣẹ́ tí ó dá òtítọ́ padà bí  bá jẹ́ pé àlàfo ìkẹyìn# >>> check_if_last_char_is_a_letter.call(\"apple pie\")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e\")\n# true\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e \")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\")\n# false\ndef check_if_last_char_is_a_letter(txt)\n","canonical_solution":"check_if_last_char_is_a_letter = ->(txt) {\n  return false if txt.strip.empty?\n  words = txt.strip.split(' ')\n  last_word = words.last\n  return false if last_word.empty?\n  last_char = last_word[-1]\n\n  last_char =~ \/[a-zA-Z]\/ && (words.size == 1 || txt[txt.rindex(last_char) - 1] == ' ')\n}","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_if_last_char_is_a_letter\n    candidate = method(:check_if_last_char_is_a_letter)\n    assert_equal(false, candidate.call(\"apple\"))\n    assert_equal(true, candidate.call(\"apple pi e\"))\n    assert_equal(false, candidate.call(\"eeeee\"))\n    assert_equal(true, candidate.call(\"A\"))\n    assert_equal(false, candidate.call(\"Pumpkin pie \"))\n    assert_equal(false, candidate.call(\"Pumpkin pie 1\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"eeeee e \"))\n    assert_equal(false, candidate.call(\"apple pie\"))\n    assert_equal(false, candidate.call(\"apple pi e \"))\n  end\nend\n"},{"task_id":"HumanEval_135","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: àwọn iye tó bára mu. kò sí irú eroja bẹ́ẹ̀ ní ńbẹ̀ wá padà sí -1. Àpapọ̀ tí a fún kò ní ní kò tóbi ju tàbí dọ́gba sí eroja tó wà ṣáájú rẹ̀.Ṣẹda iṣẹ ti o pada awọn tobi itọka ti ohun kan ti o # >>> can_arrange.call([1, 2, 4, 3, 5])\n# 3\n# >>> can_arrange.call([1, 2, 3])\n# -1\ndef can_arrange(arr)\n","canonical_solution":"def can_arrange(arr)\n  (1...arr.length).reverse_each do |i|\n    return i if arr[i] < arr[i - 1]\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_can_arrange\n    candidate = method(:can_arrange)\n    assert_equal(3, candidate.call([1, 2, 4, 3, 5]))\n    assert_equal(-1, candidate.call([1, 2, 4, 5]))\n    assert_equal(2, candidate.call([1, 4, 2, 5, 6, 7, 8, 9, 10]))\n    assert_equal(4, candidate.call([4, 8, 5, 7, 3]))\n    assert_equal(-1, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_136","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Bí kò bá sí àwọn àpapọ̀ iye tí ó jẹ́ àbùkù tàbí tí ó jẹ́ àbùkù, fi wọn ṣe nil.ti awọn nọmba odidi rere ninu apapọ. Nọmba tó tóbi jùlọ nínú àwọn iye tó jẹ́ àléébù, àti pé \"b\" ni iye tó kéré jùlọ Ṣẹda iṣẹ kan ti o pada si array (a, b), nibi ti 'a' jẹ # >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])\n# [nil, 1]\n# >>> largest_smallest_integers.call([])\n# [nil, nil]\n# >>> largest_smallest_integers.call([0])\n# [nil, nil]\ndef largest_smallest_integers(lst)\n","canonical_solution":"def largest_smallest_integers(lst)\n  largest_negative = nil\n  smallest_positive = nil\n  \n  lst.each do |num|\n    if num < 0\n      largest_negative = num if largest_negative.nil? || num > largest_negative\n    elsif num > 0\n      smallest_positive = num if smallest_positive.nil? || num < smallest_positive\n    end\n  end\n  \n  [largest_negative, smallest_positive]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_smallest_integers\n    candidate = method(:largest_smallest_integers)\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7]))\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7, 0]))\n    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5, 6, -2]))\n    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))\n    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))\n    assert_equal([nil, nil], candidate.call([]))\n    assert_equal([nil, nil], candidate.call([0]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6, 0]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, 1]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100, 1]))\n  end\nend\n"},{"task_id":"HumanEval_137","nl":"yor_Latn","pl":"rb","prompt":"Àkíyèsí: Bí a bá fi nọ́ńbà gidi hàn bí òpó, àlàfo yíò lè jẹ́ . tàbí , Yi pada nil ti awọn iye ba jẹ dogba. àwọn nọ́ńbà gidi, ó sì dá àyípadà tó tóbi jùlọ padà nínú irú àyípadà tí a fún un. Ṣẹda iṣẹ ti o gba awọn nọmba odidi, awọn floats, tabi awọn okun ti o ṣe aṣoju # >>> compare_one.call(1, 2.5)\n# 2.5\n# >>> compare_one.call(1, \"2,3\")\n# \"2,3\"\n# >>> compare_one.call(\"5,1\", \"6\")\n# \"6\"\n# >>> compare_one.call(\"1\", 1)\n# nil\ndef compare_one(a, b)\n","canonical_solution":"def compare_one(a, b)\n  a = a.to_s.tr(',', '.').to_f if a.is_a?(String) && a.include?(',')\n  b = b.to_s.tr(',', '.').to_f if b.is_a?(String) && b.include?(',')\n\n  if a.is_a?(String) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Float)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Float)\n    a = a.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Integer)\n    b = b.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Float)\n    b = b.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(String)\n    a = a.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  else\n    return nil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare_one\n    candidate = method(:compare_one)\n    assert_equal(2, candidate.call(1, 2))\n    assert_equal(2.5, candidate.call(1, 2.5))\n    assert_equal(3, candidate.call(2, 3))\n    assert_equal(6, candidate.call(5, 6))\n    assert_equal(\"2,3\", candidate.call(1, \"2,3\"))\n    assert_equal(\"6\", candidate.call(\"5,1\", \"6\"))\n    assert_equal(\"2\", candidate.call(\"1\", \"2\"))\n    assert_equal(nil, candidate.call(\"1\", 1))\n  end\nend\n"},{"task_id":"HumanEval_138","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ Ṣe àgbéyẹ̀wò bóyá iye tí a fún wa n lè kọ gẹ́gẹ́ bí àpapọ̀ iye tí ó jẹ́ iye tí ó jẹ́ iye tí ó jẹ́ iye tí ó jẹ́ iye tí ó jẹ́ iye tí ó jẹ́ iye tí ó jẹ́ iye tí ó jẹ́ iye tí ó jẹ́ iye tí ó jẹ́ iye tí ó jẹ́ iye tí ó jẹ́ iye.# >>> is_equal_to_sum_even.call(4)\n# false\n# >>> is_equal_to_sum_even.call(6)\n# false\n# >>> is_equal_to_sum_even.call(8)\n# true\ndef is_equal_to_sum_even(n)\n","canonical_solution":"def is_equal_to_sum_even(n)\n  return false if n < 8\n  n.even?\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_equal_to_sum_even\n    candidate = method(:is_equal_to_sum_even)\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(8))\n    assert_equal(true, candidate.call(10))\n    assert_equal(false, candidate.call(11))\n    assert_equal(true, candidate.call(12))\n    assert_equal(false, candidate.call(13))\n    assert_equal(true, candidate.call(16))\n  end\nend\n"},{"task_id":"HumanEval_139","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: níbi tí n > 0 brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! A ṣe àlàyé ìsọ̀rí Brazil bí: # >>> special_factorial.call(4)\n# 288\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\ndef special_factorial(n)\n","canonical_solution":"def special_factorial(n)\n  return 1 if n <= 1\n  (1..n).inject(1) { |product, i| product * factorial(i) }\nend\n\ndef factorial(num)\n  return 1 if num <= 1\n  (2..num).inject(1, :*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_special_factorial\n    candidate = method(:special_factorial)\n    assert_equal(288, candidate.call(4))\n    assert_equal(34560, candidate.call(5))\n    assert_equal(125411328000, candidate.call(7))\n    assert_equal(1, candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_140","nl":"yor_Latn","pl":"rb","prompt":"lẹ́yìn náà fi -  rọ́pò gbogbo àlàfo tó wà lẹ́yìn ara wọnàti bí òpó bá ní ju àlàfo méjì lọ lẹ́sẹ̀-lẹ́sẹ̀, Ti a ba fun ọ ni okun ọrọ kan, rọpo gbogbo awọn aaye ninu rẹ pẹlu awọn aami isalẹ, # >>> fix_spaces.call(\" Example\")\n# \"Example\"\n# >>> fix_spaces.call(\" Example 1\")\n# \"Example_1\"\n# >>> fix_spaces.call(\" Example 2\")\n# \"_Example_2\"\n# >>> fix_spaces.call(\" Example 3\")\n# \"_Example-3\"\ndef fix_spaces(text)\n","canonical_solution":"def fix_spaces(text)\n  text.strip.gsub(\/\\s{3,}\/, '-').gsub(' ', '_')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fix_spaces\n    candidate = method(:fix_spaces)\n    assert_equal(\"Example\", candidate.call(\"Example\"))\n    assert_equal(\"Mudasir_Hanif_\", candidate.call(\"Mudasir Hanif \"))\n    assert_equal(\"Yellow_Yellow__Dirty__Fellow\", candidate.call(\"Yellow Yellow  Dirty  Fellow\"))\n    assert_equal(\"Exa-mple\", candidate.call(\"Exa   mple\"))\n    assert_equal(\"-Exa_1_2_2_mple\", candidate.call(\"   Exa 1 2 2 mple\"))\n  end\nend\n"},{"task_id":"HumanEval_141","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: - Awọn substring lẹhin ti awọn dot yẹ ki o jẹ ọkan ninu awọn wọnyi: ['txt', 'exe', 'dll'] àwọn álífábẹ́ẹ̀tì èdè Látìn ('a'-'z' àti 'A'-'Z'). - Awọn substring ṣaaju ki o to awọn dot yẹ ki o wa ko ṣofo, ati awọn ti o bẹrẹ pẹlu kan lẹta lati - Orúkọ fáìlì náà ní àlàfo kan pàtó nínú.- Kò yẹ kí orúkọ fáìlì náà ju àlàfo mẹ́ta lọ ('0'-'9'). ti wa ni pade: Orúkọ àpamọ́ kan ni a kà sí pé ó bágbà mu tí gbogbo àwọn ipò tó wà nísàlẹ̀ yìí bá bára mu 'Bẹẹni' ti orukọ faili ba wulo, ati pe yoo pada 'Bẹẹkọ' bibẹkọ. Ṣẹda iṣẹ ti o gba okun ti o ṣe aṣoju orukọ faili kan, ati pada # >>> file_name_check.call(\"example.txt\")\n# \"Yes\"\n# >>> file_name_check.call(\"1example.dll\")\n# \"No\"\ndef file_name_check(file_name)\n","canonical_solution":"def file_name_check(file_name)\n  # Check if there's exactly one dot in the filename\n  return 'No' unless file_name.count('.') == 1\n  \n  # Split the filename into the name and extension\n  name, extension = file_name.split('.')\n  \n  # Check if the name part starts with a letter\n  return 'No' if name.empty? || !name[0].match?(\/[a-zA-Z]\/)\n  \n  # Check if the extension is valid\n  return 'No' unless ['txt', 'exe', 'dll'].include?(extension)\n  \n  # Count digits in the file name\n  digit_count = file_name.count(\"0-9\")\n  \n  # Check if digits are more than three\n  return 'No' if digit_count > 3\n  \n  'Yes'\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_file_name_check\n    candidate = method(:file_name_check)\n    assert_equal(\"Yes\", candidate.call(\"example.txt\"))\n    assert_equal(\"No\", candidate.call(\"1example.dll\"))\n    assert_equal(\"No\", candidate.call(\"s1sdf3.asd\"))\n    assert_equal(\"Yes\", candidate.call(\"K.dll\"))\n    assert_equal(\"Yes\", candidate.call(\"MY16FILE3.exe\"))\n    assert_equal(\"No\", candidate.call(\"His12FILE94.exe\"))\n    assert_equal(\"No\", candidate.call(\"_Y.txt\"))\n    assert_equal(\"No\", candidate.call(\"?aREYA.exe\"))\n    assert_equal(\"No\", candidate.call(\"\/this_is_valid.dll\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.wow\"))\n    assert_equal(\"Yes\", candidate.call(\"this_is_valid.txt\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.txtexe\"))\n    assert_equal(\"No\", candidate.call(\"#this2_i4s_5valid.ten\"))\n    assert_equal(\"No\", candidate.call(\"@this1_is6_valid.exe\"))\n    assert_equal(\"No\", candidate.call(\"this_is_12valid.6exe4.txt\"))\n    assert_equal(\"No\", candidate.call(\"all.exe.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"I563_No.exe\"))\n    assert_equal(\"Yes\", candidate.call(\"Is3youfault.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"no_one#knows.dll\"))\n    assert_equal(\"No\", candidate.call(\"1I563_Yes3.exe\"))\n    assert_equal(\"No\", candidate.call(\"I563_Yes3.txtt\"))\n    assert_equal(\"No\", candidate.call(\"final..txt\"))\n    assert_equal(\"No\", candidate.call(\"final132\"))\n    assert_equal(\"No\", candidate.call(\"_f4indsartal132.\"))\n    assert_equal(\"No\", candidate.call(\".txt\"))\n    assert_equal(\"No\", candidate.call(\"s.\"))\n  end\nend\n"},{"task_id":"HumanEval_142","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: yí àwọn àkọsílẹ̀ inú àtẹ tí àwọn àmì wọn kò jẹ́ ìlópò 3 tàbí 4. iṣẹ́ náà yóò wá dá àpapọ̀ gbogbo àkọsílẹ̀ padà.multiple ti 3 ati ki o yoo cube awọn integer titẹsi ti o ba ti awọn oniwe-ọya jẹ a multiple ti 4 ati ki o ko a multiple ti 3. awọn iṣẹ yoo ko Fun gbogbo awọn titẹsi ninu awọn titobi, awọn iṣẹ yoo square awọn integer titẹsi ti o ba ti awọn oniwe-ọya jẹ a \" # >>> lst\n# [1, 2, 3]\n# >>> lst\n# []\n# >>> lst\n# [-1, -5, 2, -1, -5]\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map.with_index do |num, index|\n    if index % 3 == 0\n      num ** 2\n    elsif index % 4 == 0\n      num ** 3\n    else\n      num\n    end\n  end.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(6, candidate.call([1, 2, 3]))\n    assert_equal(14, candidate.call([1, 4, 9]))\n    assert_equal(0, candidate.call([]))\n    assert_equal(9, candidate.call([1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    assert_equal(-3, candidate.call([-1, -1, -1, -1, -1, -1, -1, -1, -1]))\n    assert_equal(0, candidate.call([0]))\n    assert_equal(-126, candidate.call([-1, -5, 2, -1, -5]))\n    assert_equal(3030, candidate.call([-56, -99, 1, 0, -2]))\n    assert_equal(0, candidate.call([-1, 0, 0, 0, 0, 0, 0, 0, -1]))\n    assert_equal(-14196, candidate.call([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]))\n    assert_equal(-1448, candidate.call([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]))\n  end\nend\n"},{"task_id":"HumanEval_143","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ 1: ìtòlẹ́sẹẹsẹ àwọn ọ̀rọ̀ nínú ìlà tuntun náà gbọ́dọ̀ jẹ́ èyí tí ó jẹ́ ti ìpilẹ̀ṣẹ̀.tí àwọn gígùn rẹ̀ jẹ́ àwọn iye àkọ́kọ́, o sì ní láti dá òpó tí ó ní àwọn ọ̀rọ̀ láti inú gbólóhùn ìpilẹ̀ṣẹ̀ padà, gbólóhùn náà ní àwọn ọ̀rọ̀ kan tí àlàfo pín sí, A fún ọ ní ìlà tí ó dúró fún gbólóhùn kan, # >>> words_in_sentence.call(\"This is a test\")\n# \"is\"\n# Example 2:\n# >>> words_in_sentence.call(\"lets go for swimming\")\n# \"go for\"\n# Constraints:\n# * 1 <= len(sentence) <= 100\n# * sentence contains only letters\ndef words_in_sentence(sentence)\n","canonical_solution":"def words_in_sentence(sentence)\n  def is_prime?(num)\n    return false if num <= 1\n    (2..Math.sqrt(num)).none? { |i| num % i == 0 }\n  end\n  \n  words = sentence.split(\" \")\n  prime_length_words = words.select { |word| is_prime?(word.length) }\n  prime_length_words.join(\" \")\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_in_sentence\n    candidate = method(:words_in_sentence)\n    assert_equal(\"is\", candidate.call(\"This is a test\"))\n    assert_equal(\"go for\", candidate.call(\"lets go for swimming\"))\n    assert_equal(\"there is no place\", candidate.call(\"there is no place available here\"))\n    assert_equal(\"Hi am Hussein\", candidate.call(\"Hi I am Hussein\"))\n    assert_equal(\"go for it\", candidate.call(\"go for it\"))\n    assert_equal(\"\", candidate.call(\"here\"))\n    assert_equal(\"is\", candidate.call(\"here is\"))\n  end\nend\n"},{"task_id":"HumanEval_144","nl":"yor_Latn","pl":"rb","prompt":"O le ro pe x, ati n ni awọn fractions to wulo, ati ki o ko ni odo bi denominator. <numerator>\/<denominator> níbi tí àwọn méjèèjì ti jẹ́ iye tó kún.bákan náà ni x àti n, jẹ́ ìlà ìsopọ̀ ti ìlà ìlà, tí ó sì ní ọ̀nà tí ó tẹ̀lé, x * n. Iṣẹ́ náà yóò dá òtítọ́ padà bí x * n bá ṣe iye sí iye kan àti èké Iṣẹ́ yín ni láti ṣe àṣefihàn iṣẹ́ tí yóò mú kí ìtumọ̀ náà rọrùn # >>> simplify.call(\"1\/5\", \"5\/1\")\n# true\n# >>> simplify.call(\"1\/6\", \"2\/1\")\n# false\n# >>> simplify.call(\"7\/10\", \"10\/2\")\n# false\ndef simplify(x, n)\n","canonical_solution":"def simplify(x, n)\n  # Convert x and n to numerators and denominators\n  num_x, den_x = x.split('\/').map(&:to_i)\n  num_n, den_n = n.split('\/').map(&:to_i)\n\n  # Multiply fractions: (num_x * num_n) \/ (den_x * den_n)\n  numerator = num_x * num_n\n  denominator = den_x * den_n\n\n  # Check if the result is a whole number\n  numerator % denominator == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_simplify\n    candidate = method(:simplify)\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/6\", \"2\/1\"))\n    assert_equal(true, candidate.call(\"5\/1\", \"3\/1\"))\n    assert_equal(false, candidate.call(\"7\/10\", \"10\/2\"))\n    assert_equal(true, candidate.call(\"2\/10\", \"50\/10\"))\n    assert_equal(true, candidate.call(\"7\/2\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"11\/6\", \"6\/1\"))\n    assert_equal(false, candidate.call(\"2\/3\", \"5\/2\"))\n    assert_equal(false, candidate.call(\"5\/2\", \"3\/5\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"8\/4\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/5\", \"1\/5\"))\n  end\nend\n"},{"task_id":"HumanEval_145","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: Ṣe ètò wọn ní ìbámu pẹ̀lú ìlà wọn nínú ìlà ìpilẹ̀ṣẹ̀.Àkíyèsí: bí àwọn ohun kan bá wà tí iye àwọn dígí wọn jọra, ní ìbámu pẹ̀lú iye iye àwọn dígí wọn.Kọ iṣẹ kan ti o ṣaṣeto awọn ti a fi fun awọn titobi ti awọn integers # >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1, -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n","canonical_solution":"def order_by_points(nums)\n  nums.sort_by.with_index do |num, index|\n    [num.to_s.chars.map(&:to_i).sum.abs, index]\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11], candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32, 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6], candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"},{"task_id":"HumanEval_146","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: àlàfo àkọ́kọ́ àti ìkẹyìn nínú iye kan jẹ́ àlàfo (1, 3, 5, 7, 9).iye awọn eroja ninu awọn array ti o wa tobi ju 10 ati awọn mejeeji Kọ iṣẹ kan ti o gba awọn nọmba bi ohun ti o wọle ati awọn ipadabọ # >>> specialFilter.call([15, -73, 14, -15])\n# 1\n# >>> specialFilter.call([33, -2, -3, 45, 21, 109])\n# 2\ndef specialFilter(nums)\n","canonical_solution":"def specialFilter(nums)\n  nums.count do |num|\n    num > 10 && num.to_s[0].to_i.odd? && num.to_s[-1].to_i.odd?\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_specialFilter\n    candidate = method(:specialFilter)\n    assert_equal(0, candidate.call([5, -2, 1, -5]))\n    assert_equal(1, candidate.call([15, -73, 14, -15]))\n    assert_equal(2, candidate.call([33, -2, -3, 45, 21, 109]))\n    assert_equal(4, candidate.call([43, -12, 93, 125, 121, 109]))\n    assert_equal(3, candidate.call([71, -2, -33, 75, 21, 19]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(0, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_147","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: a[i] + a[j] + a[k] jẹ́ ìlọ́po 3. Pada iye awọn mẹta (a[i], a[j], a[k]) ti a nibi ti i < j < k, Fun gbogbo i (1 ≤ i ≤ n), iye ti a[i] = i * i - i + 1. A fún ọ ní iye tó ṣe é kà n. O ní láti dá àwùjọ àwọn iye tó ṣe é kà a tí ó gùn n. # >>> get_max_triples.call(5)\n# 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7, 13).\ndef get_max_triples(n)\n","canonical_solution":"def get_max_triples(n)\n  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }\n  count = 0\n  \n  (0...n).each do |i|\n    (i+1...n).each do |j|\n      (j+1...n).each do |k|\n        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_max_triples\n    candidate = method(:get_max_triples)\n    assert_equal(1, candidate.call(5))\n    assert_equal(4, candidate.call(6))\n    assert_equal(36, candidate.call(10))\n    assert_equal(53361, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_148","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ àwọn orúkọ àwọn pílánẹ́ẹ̀tì yìí kò tọ̀nà.Iṣẹ́ náà yẹ kí ó dá àlàfo àlàfo padà bí planet1 tàbí planet2 bí oòrùn ṣe sún mọ́ wa tó.ó wà láàrin òpó-ìmọ̀ ayé 1 àti òpó-ìmọ̀ ayé 2, tí a tò gẹ́gẹ́ bí Iṣẹ́ náà yẹ kí ó dá àtòjọ tí ó ní gbogbo àwọn pílánẹ́ẹ̀tì tí àwọn òpópónà wọn jẹ́ Kọ iṣẹ kan ti o gba awọn orukọ aye meji bi awọn okun planet1 ati planet2. Uránúsì, Neptune. Mercury ni, Venus ni o tẹle e, Earth, Mars, Jupiter, Saturn, Àwọn pílánẹ́ẹ̀tì mẹ́jọ ló wà nínú ètò oòrùn wa: àwọn tó sún mọ́ oòrùn jù lọ .# >>> bf.call(\"Jupiter\", \"Neptune\")\n# [\"Saturn\", \"Uranus\"]\n# >>> bf.call(\"Earth\", \"Mercury\")\n# \"Venus\"\n# >>> bf.call(\"Mercury\", \"Uranus\")\n# [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\ndef bf(planet1, planet2)\n","canonical_solution":"def bf(planet1, planet2)\n  planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  \n  idx1 = planets.index(planet1)\n  idx2 = planets.index(planet2)\n  \n  return [] if idx1.nil? || idx2.nil?\n\n  start_idx, end_idx = [idx1, idx2].sort\n  \n  planets[(start_idx + 1)...end_idx]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_bf\n    candidate = method(:bf)\n    assert_equal([\"Saturn\", \"Uranus\"], candidate.call(\"Jupiter\", \"Neptune\"))\n    assert_equal([\"Venus\"], candidate.call(\"Earth\", \"Mercury\"))\n    assert_equal([\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"], candidate.call(\"Mercury\", \"Uranus\"))\n    assert_equal([\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"], candidate.call(\"Neptune\", \"Venus\"))\n    assert_equal([], candidate.call(\"Earth\", \"Earth\"))\n    assert_equal([], candidate.call(\"Mars\", \"Earth\"))\n    assert_equal([], candidate.call(\"Jupiter\", \"Makemake\"))\n  end\nend\n"},{"task_id":"HumanEval_149","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: O lè gbà pé gígùn ọ̀rọ̀ kọ̀ọ̀kan á dọ́gba.Iṣẹ́ náà ní láti dá àtòjọ àwọn ìlà padà ní ìtòlẹ́sẹẹsẹ tí a tò.Bí ọ̀rọ̀ méjì bá ní gígùn kan náà, ṣa àwọn ọ̀rò̀ náà ní ẹ̀ka-èdè.ó yẹ kí ó dá àtòjọ tí a tò nípa òfin náà padà. Àtòjọ àwọn ọ̀rọ̀ náà gbọ́dọ̀ máa gòkè lọ síbi tí gígùn ọ̀rọ̀ kọ̀ọ̀kan bá wà, àti ìwọ ó sì lè ní àwọn ẹ̀dà méjì nínú.Àpapọ̀ jẹ́ àpapọ̀ àwọn ìlà, kì í ṣe àpapọ̀ àwọn iye, ó sì dá àbájáde ìlà náà padà pẹ̀lú ètò tí a tò, o pa awọn okun ti o ni odd ipari lati o, Kọ iṣẹ kan ti o gba ìlà ti awọn okun bi paramita, # >>> list_sort.call([\"aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort.call([\"ab\", \"a\", \"aaa\", \"cd\"])\n# [\"ab\", \"cd\"]\ndef sorted_list_sum(lst)\n","canonical_solution":"def list_sort(arr)\n  arr.select { |s| s.length.even? }\n     .sort_by { |s| [s.length, s] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sorted_list_sum\n    candidate = method(:sorted_list_sum)\n    assert_equal([\"aa\"], candidate.call([\"aa\", \"a\", \"aaa\"]))\n    assert_equal([\"AI\", \"asdf\", \"school\"], candidate.call([\"school\", \"AI\", \"asdf\", \"b\"]))\n    assert_equal([], candidate.call([\"d\", \"b\", \"c\", \"a\"]))\n    assert_equal([\"abcd\", \"dcba\"], candidate.call([\"d\", \"dcba\", \"abcd\", \"a\"]))\n    assert_equal([\"AI\", \"ai\", \"au\"], candidate.call([\"AI\", \"ai\", \"au\"]))\n    assert_equal([], candidate.call([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]))\n    assert_equal([\"cc\", \"dd\", \"aaaa\", \"bbbb\"], candidate.call([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]))\n  end\nend\n"},{"task_id":"HumanEval_150","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: a nọmba akọkọ ati ki o yẹ ki o pada awọn iye ti y bibẹkọ. Àtòjọ́ tí ó yẹ kí ó dá iye x padà bí n bá jẹ́ # >>> x_or_y.call(7, 34, 12)\n# 34\n# >>> x_or_y.call(15, 8, 5)\n# 5\ndef x_or_y(n, x, y)\n","canonical_solution":"def x_or_y(n, x, y)\n  require 'prime'\n  n.prime? ? x : y\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_x_or_y\n    candidate = method(:x_or_y)\n    assert_equal(34, candidate.call(7, 34, 12))\n    assert_equal(5, candidate.call(15, 8, 5))\n    assert_equal(33, candidate.call(3, 33, 5212))\n    assert_equal(3, candidate.call(1259, 3, 52))\n    assert_equal(-1, candidate.call(7919, -1, 12))\n    assert_equal(583, candidate.call(3609, 1245, 583))\n    assert_equal(129, candidate.call(91, 56, 129))\n    assert_equal(1234, candidate.call(6, 34, 1234))\n    assert_equal(0, candidate.call(1, 2, 0))\n    assert_equal(2, candidate.call(2, 2, 0))\n  end\nend\n"},{"task_id":"HumanEval_151","nl":"yor_Latn","pl":"rb","prompt":"Ko si awọn nọmba ti o jẹ odi tabi kii ṣe awọn nọmba odidi.Ti a ba fun ni awọn nọmba, pada awọn iye ti awọn square ti awọn nọmba # >>> double_the_difference.call([1, 3, 2, 0])\n# 10\n# >>> double_the_difference.call([-1, -2, 0])\n# 0\n# >>> double_the_difference.call([9, -2])\n# 81\n# >>> double_the_difference.call([0])\n# 0\n# If the input array is empty, return 0.\ndef double_the_difference(lst)\n","canonical_solution":"def double_the_difference(lst)\n  lst.select { |n| n.is_a?(Integer) && n.odd? && n >= 0 }\n     .map { |n| n ** 2 }\n     .sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_double_the_difference\n    candidate = method(:double_the_difference)\n    assert_equal(0, candidate.call([]))\n    assert_equal(25, candidate.call([5.0, 4.0]))\n    assert_equal(0, candidate.call([0.1, 0.2, 0.3]))\n    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))\n    assert_equal(0, candidate.call([-1.0, -2.0, 8.0]))\n    assert_equal(34, candidate.call([0.2, 3.0, 5.0]))\n    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]))\n  end\nend\n"},{"task_id":"HumanEval_152","nl":"yor_Latn","pl":"rb","prompt":"àpẹẹrẹ: iye náà jẹ 0, bí kò bá sì ṣe bẹ́ẹ̀, iye náà ni ìyàtọ̀ pátápátá láàárín ìparí àti ìparí. Yípadà àgbájọ kan tí ó ní gígùn kan náà tí ó ń fi bí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìparí ìA fún ọ ní àwọn ìlà méjì ti àwọn ìyọrísí àti àwọn ìparí tí ó gùn dọ́gba, níbi tí ìlà kọ̀ọ̀kan ti ń fi ìmúṣẹ hàn.Iṣẹ́ yín ni láti mọ̀ bóyá ẹnì kan ti mọ àbájáde àwọn ìdíje kan dáadáa.ó dájú pé ó yẹ kéèyàn ṣàkọsílẹ̀ rẹ̀ kó sì fi wé. ìṣẹ̀lẹ̀ náà ni a mọ̀ níkẹyìn.Mo ro pe gbogbo wa ranti pe rilara nigbati awọn esi ti diẹ ninu awọn gun-awaited # >>> compare.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n# [0, 0, 0, 0, 3, 3]\n# >>> compare.call([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n# [4, 4, 1, 0, 0, 6]\ndef compare(game, guess)\n","canonical_solution":"def compare(game, guess)\n  game.zip(guess).map { |score, prediction| (score - prediction).abs }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare\n    candidate = method(:compare)\n    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))\n    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))\n    assert_equal([2, 4, 6], candidate.call([1, 2, 3], [-1, -2, -3]))\n    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3, 5], [-1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_153","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: (ìdára rẹ̀ jẹ́ -1). return \"Slices.SErviNGSliCes\" níwọ̀n ìgbà tí \"SErviNGSliCes\" jẹ́ àfikún tó lágbára jùlọ àwọn àfikún: ['SErviNGSliCes', 'Cheese', 'StuFfed'] nígbà náà o yẹ kí o Fun apẹẹrẹ, ti o ba ti a fun \"Slices\" bi awọn kilasi ati ki o kan array ti awọn yan èyí tí ó bá kọ́kó̀ wá nínú àtẹ náà.Bí ìmúgbòòrò méjì tàbí jù bẹ́ẹ̀ lọ bá wà tí agbára wọn bára mu, o kò gbọ́dọ̀ ṣe àtúnṣe sí wọn.format: ClassName.StrongestExtensionName.  Ìtòlẹ́sẹẹsẹ ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápá ìkápáO yẹ ki o wa awọn ti o lagbara itẹsiwaju ki o si pada kan okun ni yi nínú orúkọ àfikún náà, a fi ìlà CAP - SM sọ agbára tí a ní. awọn lẹta ninu orukọ itẹsiwaju, ati jẹ ki SM jẹ nọmba awọn lẹta kekere Agbara ti awọn itẹsiwaju jẹ bi wọnyi: Jẹ ki CAP jẹ awọn nọmba ti awọn nla Awọn ìmúgbòòrò ni lati lo lati fi kún awọn kilasi si kilasi.A ó fún ọ ní orúkọ ẹ̀ka (ìlà) àti àpapọ̀ àwọn àfikún.# >>> Strongest_Extension.call(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n# \"my_class.AA\"\ndef Strongest_Extension(class_name, extensions)\n","canonical_solution":"def Strongest_Extension(class_name, extensions)\n  strongest_extension = extensions.max_by do |extension|\n    cap_count = extension.count('A-Z')\n    sm_count = extension.count('a-z')\n    cap_count - sm_count\n  end\n  \"#{class_name}.#{strongest_extension}\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_Strongest_Extension\n    candidate = method(:Strongest_Extension)\n    assert_equal(\"Watashi.eIGHt8OKe\", candidate.call(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]))\n    assert_equal(\"Boku123.YEs.WeCaNe\", candidate.call(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]))\n    assert_equal(\"__YESIMHERE.NuLl__\", candidate.call(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]))\n    assert_equal(\"K.TAR\", candidate.call(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]))\n    assert_equal(\"__HAHA.123\", candidate.call(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]))\n    assert_equal(\"YameRore.okIWILL123\", candidate.call(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]))\n    assert_equal(\"finNNalLLly.WoW\", candidate.call(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]))\n    assert_equal(\"_.Bb\", candidate.call(\"_\", [\"Bb\", \"91245\"]))\n    assert_equal(\"Sp.671235\", candidate.call(\"Sp\", [\"671235\", \"Bb\"]))\n  end\nend\n"},{"task_id":"HumanEval_154","nl":"yor_Latn","pl":"rb","prompt":"O ni lati pada si otitọ ti o ba ti awọn keji ọrọ tabi eyikeyi ti awọn oniwe-rotations jẹ a substring ni akọkọ ọrọ # >>> cycpattern_check.call(\"abcd\", \"abd\")\n# false\n# >>> cycpattern_check.call(\"hello\", \"ell\")\n# true\n# >>> cycpattern_check.call(\"whassup\", \"psus\")\n# false\n# >>> cycpattern_check.call(\"abab\", \"baa\")\n# true\n# >>> cycpattern_check.call(\"efef\", \"eeff\")\n# false\n# >>> cycpattern_check.call(\"himenss\", \"simen\")\n# true\ndef cycpattern_check(a, b)\n","canonical_solution":"def cycpattern_check(a, b)\n  (0...b.length).each do |i|\n    rotated_b = b[i..-1] + b[0...i]\n    return true if a.include?(rotated_b)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_cycpattern_check\n    candidate = method(:cycpattern_check)\n    assert_equal(false, candidate.call(\"xyzw\", \"xyw\"))\n    assert_equal(true, candidate.call(\"yello\", \"ell\"))\n    assert_equal(false, candidate.call(\"whattup\", \"ptut\"))\n    assert_equal(true, candidate.call(\"efef\", \"fee\"))\n    assert_equal(false, candidate.call(\"abab\", \"aabb\"))\n    assert_equal(true, candidate.call(\"winemtt\", \"tinem\"))\n  end\nend\n"},{"task_id":"HumanEval_155","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Ti a ba fun ni iye odidi kan. pada ni apapọ ti o ni nọmba ti awọn nọmba paapaa ati alailẹgbẹ lẹsẹsẹ. # >>> even_odd_count.call(-12)\n# [1, 1]\n# >>> even_odd_count.call(123)\n# [1, 2]\ndef even_odd_count(num)\n","canonical_solution":"def even_odd_count(num)\n  num.to_s.chars.map(&:to_i).select { |digit| digit != 0 }.partition(&:even?).map(&:count)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_count\n    candidate = method(:even_odd_count)\n    assert_equal([0, 1], candidate.call(7))\n    assert_equal([1, 1], candidate.call(-78))\n    assert_equal([2, 2], candidate.call(3452))\n    assert_equal([3, 3], candidate.call(346211))\n    assert_equal([3, 3], candidate.call(-345821))\n    assert_equal([1, 0], candidate.call(-2))\n    assert_equal([2, 3], candidate.call(-45347))\n    assert_equal([1, 0], candidate.call(0))\n  end\nend\n"},{"task_id":"HumanEval_156","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: Awọn ihamọ: 1 <= num <= 1000 kí o sì fi lẹ́tà kékeré kọ ọ́. Ti a ba fun ni iye odidi rere, gba iye rẹ ti o jẹ deede ni nọmba Romu bi okun, # >>> int_to_mini_roman.call(19)\n# \"xix\"\n# >>> int_to_mini_roman.call(152)\n# \"clii\"\n# >>> int_to_mini_roman.call(426)\n# \"cdxxvi\"\ndef int_to_mini_roman(number)\n","canonical_solution":"def int_to_mini_roman(number)\n  values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n\n  result = ''\n  values.each_with_index do |value, index|\n    while number >= value\n      number -= value\n      result += numerals[index]\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"},{"task_id":"HumanEval_157","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: 90 ìyí. Onigun mẹta ti o ni igun ọtun jẹ igun mẹta ninu eyiti igun kan jẹ igun ọtun tabi àwọn ìhà rẹ̀ máa ń di ẹ̀ẹ̀mẹ́ta tó ní igun tó dúró ṣánṣán, àyàfi bí kò bá rí bẹ́ẹ̀.Ti a ba fun ni awọn ipari ti awọn ẹgbẹ mẹta ti onigun mẹta kan.# >>> right_angle_triangle.call(3, 4, 5)\n# true\n# >>> right_angle_triangle.call(1, 2, 3)\n# false\ndef right_angle_triangle(a, b, c)\n","canonical_solution":"def right_angle_triangle(a, b, c)\n  sides = [a, b, c].sort\n  sides[0]**2 + sides[1]**2 == sides[2]**2\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_right_angle_triangle\n    candidate = method(:right_angle_triangle)\n    assert_equal(true, candidate.call(3, 4, 5))\n    assert_equal(false, candidate.call(1, 2, 3))\n    assert_equal(true, candidate.call(10, 6, 8))\n    assert_equal(false, candidate.call(2, 2, 2))\n    assert_equal(true, candidate.call(7, 24, 25))\n    assert_equal(false, candidate.call(10, 5, 7))\n    assert_equal(true, candidate.call(5, 12, 13))\n    assert_equal(true, candidate.call(15, 8, 17))\n    assert_equal(true, candidate.call(48, 55, 73))\n    assert_equal(false, candidate.call(1, 1, 1))\n    assert_equal(false, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_158","nl":"yor_Latn","pl":"rb","prompt":"àwọn òǹkọ̀wé, dá èyí tó wà ní ipò kìíní nínú ètò ọ̀rọ̀-ìwé padà. Ti o ba ti ọpọlọpọ awọn okun ni o ni o pọju nọmba ti oto Àkójọpọ̀ náà ní àwọn ọ̀rọ̀ tí ó yàtọ̀. Fi ọ̀rọ̀ tí ó pọ̀jù padà Kọ iṣẹ kan ti o gba awọn okun.# >>> find_max.call([\"name\", \"of\", \"string\"])\n# \"string\"\n# >>> find_max.call([\"name\", \"enam\", \"game\"])\n# \"enam\"\n# >>> find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\ndef find_max(words)\n","canonical_solution":"def find_max(words)\n  # Helper function to count unique characters\n  def unique_char_count(word)\n    word.chars.uniq.size\n  end\n\n  words.max_by { |word| [unique_char_count(word), -word] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n  end\nend\n"},{"task_id":"HumanEval_159","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ: bí kò bá sí èso karóètì tó tó, wàá jẹ gbogbo èso karóètì tó bá kù, àmọ́ ebi á ṣì máa pa ẹ́.iye ẹ̀pà tó kù lẹ́yìn oúnjẹ rẹ ] o ní láti dá [ iye kárọ́ọ̀tì tó o jẹ tán lẹ́yìn oúnjẹ padà, àmọ́ ní báyìí, o ní láti jẹ àwọn kérọ́tì púpọ̀ sí i láti fi kún oúnjẹ ọ̀sán.O jẹ́ ehoro kan tí ebi ń pa, o sì ti jẹ iye kan ti karóètì, # >>> eat.call(5, 6, 10)\n# [11, 4]\n# >>> eat.call(4, 8, 9)\n# [12, 1]\n# >>> eat.call(1, 10, 10)\n# [11, 0]\n# >>> eat.call(2, 11, 5)\n# [7, 0]\n# Variables:\n# @number : integer\n# the number of carrots that you have eaten.\n# @need : integer\n# the number of carrots that you need to eat.\n# @remaining : integer\n# the number of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\ndef eat(number, need, remaining)\n","canonical_solution":"def eat(number, need, remaining)\n  total_eaten = number + [need, remaining].min\n  carrots_left = [remaining - need, 0].max\n  [total_eaten, carrots_left]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_eat\n    candidate = method(:eat)\n    assert_equal([11, 4], candidate.call(5, 6, 10))\n    assert_equal([12, 1], candidate.call(4, 8, 9))\n    assert_equal([11, 0], candidate.call(1, 10, 10))\n    assert_equal([7, 0], candidate.call(2, 11, 5))\n    assert_equal([9, 2], candidate.call(4, 5, 7))\n    assert_equal([5, 0], candidate.call(4, 5, 1))\n  end\nend\n"},{"task_id":"HumanEval_160","nl":"yor_Latn","pl":"rb","prompt":"Àkójọ àwọn oníṣe ní ó kéré tán oníṣe kan, àti àkójọ àwọn oníṣe ní ó kéré tán oníṣe méjì.Operand jẹ́ àpapọ̀ àwọn iye tí kò jẹ́ àbùkù.Awọn ipari ti oniṣẹ array jẹ dogba si awọn ipari ti operand array din ọkan. Àkíyèsí: => èsì = 9 ìyọrísí = 2 + 3 * 4 - 5 ìlà = [2, 3, 4, 5] oníṣe['+', '*', '-'] Àpẹẹrẹ: Ìmúlẹ̀sílẹ̀ (**) Ìpín ìsàlè ( \/\/ ) Ìmúlùpú (*) Ìyínkúrò ( - ) Ìkójọpọ (+) Àwọn iṣẹ́ algebra pàtàkì: expression ki o si pada awọn igbelewọn ti yi expression. ìlà kejì jẹ́ ìlà àwọn iye tó pé. lo ìlà méjì tí a fún ọ láti kọ́ algebraic Fun awọn oniṣẹ meji, ati operand. Awọn akọkọ array ni o ni ipilẹ algebra isẹ, ati def do_algebra(operator, operand)\n","canonical_solution":"def do_algebra(operator, operand)\n  expression = operand[0].to_s\n  operator.each_with_index do |op, index|\n    if op == '\/\/'\n      expression += ' \/ ' + operand[index + 1].to_s\n    else\n      expression += ' ' + op + ' ' + operand[index + 1].to_s\n    end\n  end\n  eval(expression)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_do_algebra\n    candidate = method(:do_algebra)\n    assert_equal(37, candidate.call([\"**\", \"*\", \"+\"], [2, 3, 4, 5]))\n    assert_equal(9, candidate.call([\"+\", \"*\", \"-\"], [2, 3, 4, 5]))\n    assert_equal(8, candidate.call([\"\/\/\", \"*\"], [7, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_161","nl":"yor_Latn","pl":"rb","prompt":"Àpẹẹrẹ Iṣẹ́ náà ní láti dá ìlà tí ó jẹ́ àbájáde padà.Bí òpó kò bá ní àwọn lẹ́tà, yí òpó padà.bí bẹ́ẹ̀ kọ́, má ṣe yí i padà.bí s[i] bá jẹ́ lẹ́tà, yí i padà láti ìsàlẹ̀ sí òkè tàbí vice versa, A fún ọ ní ìlà s. # >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n","canonical_solution":"def solve(s)\n  if s =~ \/[a-zA-Z]\/\n    s.chars.map { |char| char =~ \/[a-zA-Z]\/ ? char.swapcase : char }.join\n  else\n    s.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\", candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"#$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"},{"task_id":"HumanEval_162","nl":"yor_Latn","pl":"rb","prompt":"Bí 'text' bá jẹ́ òpó òfo, padà sí nil. Ti a ba fun ọ ni okun 'awọn ọrọ', pada si okun ti o jẹ deede hash md5 rẹ. # >>> string_to_md5.call(\"Hello world\")\n# \"3e25960a79dbc69b674cd4ec67a72c62\"\ndef string_to_md5(text)\n","canonical_solution":"require 'digest'\n\ndef string_to_md5(text)\n  return nil if text.empty?\n  Digest::MD5.hexdigest(text)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_to_md5\n    candidate = method(:string_to_md5)\n    assert_equal(\"3e25960a79dbc69b674cd4ec67a72c62\", candidate.call(\"Hello world\"))\n    assert_equal(nil, candidate.call(\"\"))\n    assert_equal(\"0ef78513b0cb8cef12743f5aeb35f888\", candidate.call(\"A B C\"))\n    assert_equal(\"5f4dcc3b5aa765d61d8327deb882cf99\", candidate.call(\"password\"))\n  end\nend\n"},{"task_id":"HumanEval_163","nl":"yor_Latn","pl":"rb","prompt":"Bí àpẹẹrẹ: àti b, ní ìtọ́ka tó ń gòkè. Ti a ba fun ni awọn nọmba odidi rere meji a ati b, pada awọn nọmba paati laarin a # >>> generate_integers.call(2, 8)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(8, 2)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(10, 14)\n# []\ndef generate_integers(a, b)\n","canonical_solution":"def generate_integers(a, b)\n  (a..b).to_a.concat((b..a).to_a).select { |num| num.even? }.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_generate_integers\n    candidate = method(:generate_integers)\n    assert_equal([2, 4, 6, 8], candidate.call(2, 10))\n    assert_equal([2, 4, 6, 8], candidate.call(10, 2))\n    assert_equal([2, 4, 6, 8], candidate.call(132, 2))\n    assert_equal([], candidate.call(17, 89))\n  end\nend\n"}]