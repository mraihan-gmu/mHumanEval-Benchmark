[{"task_id":"HumanEval_0","nl":"dan_Latn","pl":"ts","prompt":"\/\/ i den pågældende tærskel.\/\/Tjek, om i den givne række af tal, er nogen to tal tættere på hinanden end \/\/ >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n\/\/ false\n\/\/ >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n\/\/ true\nfunction has_close_elements(numbers: number[], threshold: number): boolean {\n","canonical_solution":"function has_close_elements(numbers: number[], threshold: number): boolean {\n    for (let i = 0; i < numbers.length; i++) {\n        for (let j = i + 1; j < numbers.length; j++) {\n            if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = has_close_elements;\n  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),true);\n  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),false);\n  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95),true);\n  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8),false);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),true);\n  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0),true);\n  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5),false);\n}\n\ntest();"},{"task_id":"HumanEval_1","nl":"dan_Latn","pl":"ts","prompt":"\/\/Glem alle mellemrum i inputstrengen.\/\/Separerede grupper er afbalancerede (hver åben brace er ordentligt lukket) og ikke indlejret i hinanden.\/\/Separere disse grupper i separate strenge og returnere array af dem.\/\/Indtast til denne funktion er en streng, der indeholder flere grupper af indlejrede parenteser.\/\/ >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n\/\/ [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string: string): string[] {\n","canonical_solution":"function separate_paren_groups(paren_string: string): string[] {\n    const result: string[] = [];\n    let currentGroup: string = \"\";\n    let balance: number = 0;\n\n    for (let char of paren_string) {\n        if (char === ' ') {\n            continue; \/\/ Ignore spaces\n        }\n        \n        currentGroup += char;\n\n        if (char === '(') {\n            balance++;\n        } else if (char === ')') {\n            balance--;\n        }\n\n        if (balance === 0 && currentGroup.length > 0) {\n            result.push(currentGroup);\n            currentGroup = \"\";\n        }\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();"},{"task_id":"HumanEval_2","nl":"dan_Latn","pl":"ts","prompt":"\/\/Videregiv den decimale del af tallet. \/\/(resterende del altid mindre end 1).\/\/og heltal (største heltal mindre end det givne tal) og decimaler \/\/Hvis vi har et positivt variabeltal, kan vi dele det op i \/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunction truncate_number(number: number): number {\n","canonical_solution":"function truncate_number(number: number): number {\n    const integerPart = Math.floor(number);\n    return number - integerPart;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = truncate_number;\n  assert.deepEqual(candidate(3.5),0.5);\n  assert.deepEqual(candidate(1.25),0.25);\n  assert.deepEqual(candidate(123.0),0.0);\n}\n\ntest();"},{"task_id":"HumanEval_3","nl":"dan_Latn","pl":"ts","prompt":"\/\/På det punkt skal funktionen returnere true. Ellers skal den returnere false.\/\/Deres opgave er at opdage, om saldoen på en konto falder under nul, og \/\/Du får en række ind- og udbetalinger på en bankkonto, der starter med...\/\/ >>> below_zero([1, 2, 3])\n\/\/ false\n\/\/ >>> below_zero([1, 2, -4, 5])\n\/\/ true\nfunction below_zero(operations: number[]): boolean {\n","canonical_solution":"function below_zero(operations: number[]): boolean {\n    let balance = 0;\n    \n    for (let operation of operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = below_zero;\n  assert.deepEqual(candidate([]),false);\n  assert.deepEqual(candidate([1, 2, -3, 1, 2, -3]),false);\n  assert.deepEqual(candidate([1, 2, -4, 5, 6]),true);\n  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -4]),false);\n  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -5]),true);\n  assert.deepEqual(candidate([1, -2, 2, -2, 5, -5, 4, -4]),true);\n}\n\ntest();"},{"task_id":"HumanEval_4","nl":"dan_Latn","pl":"ts","prompt":"\/\/MAD = gennemsnit. x - x_mean. \/\/element og et midtpunkt (i dette tilfælde middelværdi): \/\/Den gennemsnitlige absolutte afvigelse er den gennemsnitlige absolutte forskel mellem hver af de to \/\/Omkring gennemsnittet af dette datasæt.\/\/For en given række inputnumre beregnes den gennemsnitlige absolutte afvigelse \/\/ >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n\/\/ 1.0\nfunction mean_absolute_deviation(numbers: number[]): number {\n","canonical_solution":"function mean_absolute_deviation(numbers: number[]): number {\n    const mean = numbers.reduce((acc, num) => acc + num, 0) \/ numbers.length;\n    const absoluteDifferences = numbers.map(num => Math.abs(num - mean));\n    const mad = absoluteDifferences.reduce((acc, diff) => acc + diff, 0) \/ numbers.length;\n    return mad;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = mean_absolute_deviation;\n  assert.deepEqual(candidate([1.0, 2.0]),0.5);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0]),1.0);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),1.2);\n}\n\ntest();"},{"task_id":"HumanEval_5","nl":"dan_Latn","pl":"ts","prompt":"\/\/Indsæt et tal \"afgrænsningsværdi\" mellem hver to på hinanden følgende elementer i inputarrayet ∀numre\" \/\/ >>> intersperse([], 4)\n\/\/ []\n\/\/ >>> intersperse([1, 2, 3], 4)\n\/\/ [1, 4, 2, 4, 3]\nfunction intersperse(numbers: number[], delimeter: number): number[] {\n","canonical_solution":"function intersperse(numbers: number[], delimeter: number): number[] {\n    if (numbers.length === 0) {\n        return [];\n    }\n\n    let result: number[] = [];\n\n    for (let i = 0; i < numbers.length; i++) {\n        result.push(numbers[i]);\n        if (i < numbers.length - 1) {\n            result.push(delimeter);\n        }\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = intersperse;\n  assert.deepEqual(candidate([], 7),[]);\n  assert.deepEqual(candidate([5, 6, 3, 2], 8),[5, 8, 6, 8, 3, 8, 2]);\n  assert.deepEqual(candidate([2, 2, 2], 2),[2, 2, 2, 2, 2]);\n}\n\ntest();"},{"task_id":"HumanEval_6","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempelvis har (() (()) højst to indkomstniveauer, mens ((())) har tre. \/\/For hver gruppe angives det dybeste niveau for indlejring af parenteser. \/\/Indgang til denne funktion er en streng repræsenteret flere grupper for indlejrede parenteser adskilt af mellemrum.\/\/ >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n\/\/ [2, 3, 1, 3]\nfunction parse_nested_parens(paren_string: string): number[] {\n","canonical_solution":"function parse_nested_parens(paren_string: string): number[] {\n    return paren_string.split(' ').map(group => {\n        let maxDepth = 0;\n        let currentDepth = 0;\n\n        for (const char of group) {\n            if (char === '(') {\n                currentDepth++;\n                if (currentDepth > maxDepth) {\n                    maxDepth = currentDepth;\n                }\n            } else if (char === ')') {\n                currentDepth--;\n            }\n        }\n\n        return maxDepth;\n    });\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = parse_nested_parens;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[2, 3, 1, 3]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[1, 2, 3, 4]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[4]);\n}\n\ntest();"},{"task_id":"HumanEval_7","nl":"dan_Latn","pl":"ts","prompt":"\/\/Filtrere en input matrix af strenge kun for dem, der indeholder givet understreng \/\/ >>> filter_by_substring([], \"a\")\n\/\/ []\n\/\/ >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n\/\/ [\"abc\", \"bacd\", \"array\"]\nfunction filter_by_substring(strings: string[], substring: string): string[] {\n","canonical_solution":"function filter_by_substring(strings: string[], substring: string): string[] {\n    return strings.filter(s => s.includes(substring));\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = filter_by_substring;\n  assert.deepEqual(candidate([], \"john\"),[]);\n  assert.deepEqual(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"),[\"xxx\", \"xxxAAA\", \"xxx\"]);\n  assert.deepEqual(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"),[\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n  assert.deepEqual(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"),[\"grunt\", \"prune\"]);\n}\n\ntest();"},{"task_id":"HumanEval_8","nl":"dan_Latn","pl":"ts","prompt":"\/\/Den tomme sum skal være lig med 0 og det tomme produkt skal være lig med 1.\/\/For en given række af heltal returnerer en række bestående af en sum og et produkt af alle de heltal i en række.\/\/ >>> sum_product([])\n\/\/ [0, 1]\n\/\/ >>> sum_product([1, 2, 3, 4])\n\/\/ [10, 24]\nfunction sum_product(numbers: number[]): [number, number] {\n","canonical_solution":"function sum_product(numbers: number[]): [number, number] {\n    const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n    const product = numbers.reduce((acc, curr) => acc * curr, 1);\n    return [sum, product];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sum_product;\n  assert.deepEqual(candidate([]),[0, 1]);\n  assert.deepEqual(candidate([1, 1, 1]),[3, 1]);\n  assert.deepEqual(candidate([100, 0]),[100, 0]);\n  assert.deepEqual(candidate([3, 5, 7]),[15, 105]);\n  assert.deepEqual(candidate([10]),[10, 10]);\n}\n\ntest();"},{"task_id":"HumanEval_9","nl":"dan_Latn","pl":"ts","prompt":"\/\/i rækkefølgen.\/\/Ud fra en given række af heltal genererer vi en række med det rulende maksimum af elementer, der findes indtil det givne øjeblik.\/\/ >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n\/\/ [1, 2, 3, 3, 3, 4, 4]\nfunction rolling_max(numbers: number[]): number[] {\n","canonical_solution":"function rolling_max(numbers: number[]): number[] {\n    let maxArray: number[] = [];\n    let currentMax: number = Number.NEGATIVE_INFINITY;\n    \n    for (let i = 0; i < numbers.length; i++) {\n        if (numbers[i] > currentMax) {\n            currentMax = numbers[i];\n        }\n        maxArray.push(currentMax);\n    }\n\n    return maxArray;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = rolling_max;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);\n  assert.deepEqual(candidate([4, 3, 2, 1]),[4, 4, 4, 4]);\n  assert.deepEqual(candidate([3, 2, 3, 100, 3]),[3, 3, 3, 100, 100]);\n}\n\ntest();"},{"task_id":"HumanEval_10","nl":"dan_Latn","pl":"ts","prompt":"\/\/- Tilføje en string-prefix, der kommer før det palindromiske suffiks, til den anden ende af strengen.\/\/- Find den længste postfix af den leverede streng, der er et palindrom. \/\/Algoritme idé er enkel: \/\/Find det korteste palindrom, der begynder med en strenge.\/\/ >>> make_palindrome(\"\")\n\/\/ \"\"\n\/\/ >>> make_palindrome(\"cat\")\n\/\/ \"catac\"\n\/\/ >>> make_palindrome(\"cata\")\n\/\/ \"catac\"\nfunction make_palindrome(string: string): string {\n","canonical_solution":"function make_palindrome(string: string): string {\n    function isPalindrome(s: string): boolean {\n        let left = 0;\n        let right = s.length - 1;\n        while (left < right) {\n            if (s[left] !== s[right]) return false;\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    const n = string.length;\n    let longestPalindromicPostfixIndex = n;\n\n    for (let i = 0; i < n; i++) {\n        if (isPalindrome(string.substring(i))) {\n            longestPalindromicPostfixIndex = i;\n            break;\n        }\n    }\n\n    const prefix = string.substring(0, longestPalindromicPostfixIndex);\n    const reversedPrefix = prefix.split('').reverse().join('');\n    return string + reversedPrefix;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = make_palindrome;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"x\"),\"x\");\n  assert.deepEqual(candidate(\"xyz\"),\"xyzyx\");\n  assert.deepEqual(candidate(\"xyx\"),\"xyx\");\n  assert.deepEqual(candidate(\"jerry\"),\"jerryrrej\");\n}\n\ntest();"},{"task_id":"HumanEval_11","nl":"dan_Latn","pl":"ts","prompt":"\/\/Udfør binær XOR på disse input og returner resultatet også som en streng. \/\/Indgang er to strenge a og b, der kun består af 1er og 0er.\/\/ >>> string_xor(\"010\", \"110\")\n\/\/ \"100\"\nfunction string_xor(a: string, b: string): string {\n","canonical_solution":"function string_xor(a: string, b: string): string {\n    let result = '';\n    for (let i = 0; i < a.length; i++) {\n        result += (a[i] === b[i] ? '0' : '1');\n    }\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = string_xor;\n  assert.deepEqual(candidate(\"111000\", \"101010\"),\"010010\");\n  assert.deepEqual(candidate(\"1\", \"1\"),\"0\");\n  assert.deepEqual(candidate(\"0101\", \"0000\"),\"0101\");\n}\n\ntest();"},{"task_id":"HumanEval_12","nl":"dan_Latn","pl":"ts","prompt":"\/\/Strings af samme længde. Returnerer uddefineret, hvis inputmængden er tom. \/\/Af en række af strenge returneres den længste.\/\/ >>> longest([])\n\/\/ undefined\n\/\/ >>> longest([\"a\", \"b\", \"c\"])\n\/\/ \"a\"\n\/\/ >>> longest([\"a\", \"bb\", \"ccc\"])\n\/\/ \"ccc\"\nfunction longest(strings: string[]): string | undefined {\n","canonical_solution":"function longest(strings: string[]): string | undefined {\n    if (strings.length === 0) {\n        return undefined;\n    }\n\n    let longestString = strings[0];\n\n    for (const str of strings) {\n        if (str.length > longestString.length) {\n            longestString = str;\n        }\n    }\n\n    return longestString;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = longest;\n  assert.deepEqual(candidate([]),undefined);\n  assert.deepEqual(candidate([\"x\", \"y\", \"z\"]),\"x\");\n  assert.deepEqual(candidate([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]),\"zzzz\");\n}\n\ntest();"},{"task_id":"HumanEval_13","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer den største fælles divisor mellem to heltal a og b \/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunction greatest_common_divisor(a: number, b: number): number {\n","canonical_solution":"function greatest_common_divisor(a: number, b: number): number {\n    while (b !== 0) {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = greatest_common_divisor;\n  assert.deepEqual(candidate(3, 7),1);\n  assert.deepEqual(candidate(10, 15),5);\n  assert.deepEqual(candidate(49, 14),7);\n  assert.deepEqual(candidate(144, 60),12);\n}\n\ntest();"},{"task_id":"HumanEval_14","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer alle præfikser fra kortest til længst i inputstrengen \/\/ >>> all_prefixes(\"abc\")\n\/\/ [\"a\", \"ab\", \"abc\"]\nfunction all_prefixes(string: string): string[] {\n","canonical_solution":"function all_prefixes(string: string): string[] {\n    const result: string[] = [];\n    for (let i = 1; i <= string.length; i++) {\n        result.push(string.substring(0, i));\n    }\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = all_prefixes;\n  assert.deepEqual(candidate(\"\"),[]);\n  assert.deepEqual(candidate(\"asdfgh\"),[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]);\n  assert.deepEqual(candidate(\"WWW\"),[\"W\", \"WW\", \"WWW\"]);\n}\n\ntest();"},{"task_id":"HumanEval_15","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer en streng med rum-afgrænsede tal fra 0 op til og med n. \/\/ >>> string_sequence(0)\n\/\/ \"0\"\n\/\/ >>> string_sequence(5)\n\/\/ \"0 1 2 3 4 5\"\nfunction string_sequence(n: number): string {\n","canonical_solution":"function string_sequence(n: number): string {\n    let result: string[] = [];\n    for (let i = 0; i <= n; i++) {\n        result.push(i.toString());\n    }\n    return result.join(' ');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = string_sequence;\n  assert.deepEqual(candidate(0),\"0\");\n  assert.deepEqual(candidate(3),\"0 1 2 3\");\n  assert.deepEqual(candidate(10),\"0 1 2 3 4 5 6 7 8 9 10\");\n}\n\ntest();"},{"task_id":"HumanEval_16","nl":"dan_Latn","pl":"ts","prompt":"\/\/Find ud af, hvor mange forskellige tegn, der er i en strenge (uanset hvor stor den er) \/\/ >>> count_distinct_characters(\"xyzXYZ\")\n\/\/ 3\n\/\/ >>> count_distinct_characters(\"Jerry\")\n\/\/ 4\nfunction count_distinct_characters(string: string): number {\n","canonical_solution":"function count_distinct_characters(inputString: string): number {\n    const lowerCasedString = inputString.toLowerCase();\n    const distinctCharacters = new Set<string>();\n\n    for (const char of lowerCasedString) {\n        distinctCharacters.add(char);\n    }\n\n    return distinctCharacters.size;\n}\n\n\/\/ Example usage:\nconsole.log(count_distinct_characters(\"xyzXYZ\")); \/\/ Output: 3\nconsole.log(count_distinct_characters(\"Jerry\"));  \/\/ Output: 4","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = count_distinct_characters;\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"abcde\"),5);\n  assert.deepEqual(candidate(\"abcdecadeCADE\"),5);\n  assert.deepEqual(candidate(\"aaaaAAAAaaaa\"),1);\n  assert.deepEqual(candidate(\"Jerry jERRY JeRRRY\"),5);\n}\n\ntest();"},{"task_id":"HumanEval_17","nl":"dan_Latn","pl":"ts","prompt":"\/\/'Hejsa' - kvartetnot, varer et slag.\/\/\"O\" betyder halv tone, der varer to slag.\/\/\"O\" - hele tonen, varer fire slag.\/\/Her er en legende:\/\/Ikke sidste.\/\/Din opgave er at analysere denne streng og returnere en række af heltal svarende til hvor mange slag hver har.\/\/Indgang til denne funktion er en streng, der repræsenterer musikalske noter i et særligt ASCII-format. \/\/ >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n\/\/ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunction parse_music(music_string: string): number[] {\n","canonical_solution":"function parse_music(music_string: string): number[] {\n    const notes = music_string.split(' ');\n    return notes.map(note => {\n        switch (note) {\n            case 'o':\n                return 4;\n            case 'o|':\n                return 2;\n            case '.|':\n                return 1;\n            default:\n                return 0;\n        }\n    });\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = parse_music;\n  assert.deepEqual(candidate(\"\"),[]);\n  assert.deepEqual(candidate(\"o o o o\"),[4, 4, 4, 4]);\n  assert.deepEqual(candidate(\".| .| .| .|\"),[1, 1, 1, 1]);\n  assert.deepEqual(candidate(\"o| o| .| .| o o o o\"),[2, 2, 1, 1, 4, 4, 4, 4]);\n  assert.deepEqual(candidate(\"o| .| o| .| o o| o o|\"),[2, 1, 2, 1, 4, 2, 4, 2]);\n}\n\ntest();"},{"task_id":"HumanEval_18","nl":"dan_Latn","pl":"ts","prompt":"\/\/Find hvor mange gange en given understreng kan findes i den oprindelige streng. Tæl overlappende tilfælde. \/\/ >>> how_many_times(\"\", \"a\")\n\/\/ 0\n\/\/ >>> how_many_times(\"aaa\", \"a\")\n\/\/ 3\n\/\/ >>> how_many_times(\"aaaa\", \"aa\")\n\/\/ 3\nfunction how_many_times(string: string, substring: string): number {\n","canonical_solution":"function how_many_times(string: string, substring: string): number {\n    if (substring.length === 0) return 0;\n    let count = 0;\n    for (let i = 0; i <= string.length - substring.length; i++) {\n        if (string.substring(i, i + substring.length) === substring) {\n            count++;\n        }\n    }\n    return count;\n}\n\n\/\/ Example usage:\n\/\/ console.log(how_many_times(\"aaa\", \"a\")); \/\/ Output: 3\n\/\/ console.log(how_many_times(\"aaaa\", \"aa\")); \/\/ Output: 3\n\/\/ console.log(how_many_times(\"\", \"a\")); \/\/ Output: 0","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = how_many_times;\n  assert.deepEqual(candidate(\"\", \"x\"),0);\n  assert.deepEqual(candidate(\"xyxyxyx\", \"x\"),4);\n  assert.deepEqual(candidate(\"cacacacac\", \"cac\"),4);\n  assert.deepEqual(candidate(\"john doe\", \"john\"),1);\n}\n\ntest();"},{"task_id":"HumanEval_19","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer strengen med tal sorteret fra mindste til største .\/\/Gyldige valg er \"nul\", \"en\", \"to\", \"tre\", \"fire\", \"fem\", \"seks\", \"syv\", \"otte\" og \"ni\". \/\/Indgang er en pladsbegrænset streng af tal fra \"nul\" til \"ni\".\/\/ >>> sort_numbers(\"three one five\")\n\/\/ \"one three five\"\nfunction sort_numbers(numbers: string): string {\n","canonical_solution":"function sort_numbers(numbers: string): string {\n    const numberWords = [\n        'zero', 'one', 'two', 'three', 'four', \n        'five', 'six', 'seven', 'eight', 'nine'\n    ];\n    \n    \/\/ Split the input string into an array of words\n    const wordsArray = numbers.split(' ');\n\n    \/\/ Sort the wordsArray based on the index of each word in numberWords\n    wordsArray.sort((a, b) => numberWords.indexOf(a) - numberWords.indexOf(b));\n\n    \/\/ Join the sorted array back into a space-delimited string and return\n    return wordsArray.join(' ');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_numbers;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"three\"),\"three\");\n  assert.deepEqual(candidate(\"three five nine\"),\"three five nine\");\n  assert.deepEqual(candidate(\"five zero four seven nine eight\"),\"zero four five seven eight nine\");\n  assert.deepEqual(candidate(\"six five four three two one zero\"),\"zero one two three four five six\");\n}\n\ntest();"},{"task_id":"HumanEval_20","nl":"dan_Latn","pl":"ts","prompt":"\/\/andre og returneres i rækkefølge (mindre antal, større antal).\/\/Ud fra en række af tal (med en længde på mindst to) vælges og returneres to tal, der er tættest på hver af dem.\/\/ >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/ [2.0, 2.2]\n\/\/ >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/ [2.0, 2.0]\nfunction find_closest_elements(numbers: number[]): [number, number] {\n","canonical_solution":"function find_closest_elements(numbers: number[]): [number, number] {\n    if (numbers.length < 2) {\n        throw new Error(\"Array must contain at least two numbers\");\n    }\n\n    \/\/ Sort the array so that we can check consecutive elements\n    numbers.sort((a, b) => a - b);\n\n    let closestPair: [number, number] = [numbers[0], numbers[1]];\n    let minDifference = Math.abs(numbers[1] - numbers[0]);\n\n    for (let i = 1; i < numbers.length - 1; i++) {\n        let currentDifference = Math.abs(numbers[i + 1] - numbers[i]);\n        if (currentDifference < minDifference) {\n            minDifference = currentDifference;\n            closestPair = [numbers[i], numbers[i + 1]];\n        }\n    }\n\n    return closestPair;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = find_closest_elements;\n  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0]);\n  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0]),[5.0, 5.9]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),[2.0, 2.2]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),[2.0, 2.0]);\n  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2, 3.1]);\n}\n\ntest();"},{"task_id":"HumanEval_21","nl":"dan_Latn","pl":"ts","prompt":"\/\/Således bliver det mindste tal 0 og det største bliver 1 .\/\/Hvis vi har en række tal (med mindst to elementer), skal vi anvende en lineær transformation på den række, \/\/ >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/ [0.0, 0.25, 0.5, 0.75, 1.0]\nfunction rescale_to_unit(numbers: number[]): number[] {\n","canonical_solution":"function rescale_to_unit(numbers: number[]): number[] {\n    if (numbers.length < 2) {\n        throw new Error(\"Array must contain at least two elements\");\n    }\n\n    const min = Math.min(...numbers);\n    const max = Math.max(...numbers);\n    const range = max - min;\n\n    if (range === 0) {\n        throw new Error(\"All numbers are the same; rescale not possible\");\n    }\n\n    return numbers.map(num => (num - min) \/ range);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = rescale_to_unit;\n  assert.deepEqual(candidate([2.0, 49.9]),[0.0, 1.0]);\n  assert.deepEqual(candidate([100.0, 49.9]),[1.0, 0.0]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5, 0.75, 1.0]);\n  assert.deepEqual(candidate([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);\n  assert.deepEqual(candidate([12.0, 11.0, 15.0, 13.0, 14.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n\ntest();"},{"task_id":"HumanEval_22","nl":"dan_Latn","pl":"ts","prompt":"\/\/Filtrere givet række af alle tsthon værdier kun for heltal \/\/ >>> filter_integers([\"a\", 3.14, 5])\n\/\/ [5]\n\/\/ >>> filter_integers([1, 2, 3, \"abc\", {}, []])\n\/\/ [1, 2, 3]\nfunction filter_integers(values: any[]): number[] {\n","canonical_solution":"function filter_integers(values: any[]): number[] {\n    return values.filter(value => Number.isInteger(value));\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = filter_integers;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([4, {}, [], 23.2, 9, \"adasd\"]),[4, 9]);\n  assert.deepEqual(candidate([3, \"c\", 3, 3, \"a\", \"b\"]),[3, 3, 3]);\n}\n\ntest();"},{"task_id":"HumanEval_23","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returlængde af den givne streng\/\/ >>> strlen(\"\")\n\/\/ 0\n\/\/ >>> strlen(\"abc\")\n\/\/ 3\nfunction strlen(string: string): number {\n","canonical_solution":"function strlen(string: string): number {\n    return string.length;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = strlen;\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"x\"),1);\n  assert.deepEqual(candidate(\"asdasnakj\"),9);\n}\n\ntest();"},{"task_id":"HumanEval_24","nl":"dan_Latn","pl":"ts","prompt":"\/\/Find det største tal, der deler n jævnt, mindre end n.\/\/ >>> largest_divisor(15)\n\/\/ 5\nfunction largest_divisor(n: number): number {\n","canonical_solution":"function largest_divisor(n: number): number {\n    for (let i = n - 1; i > 0; i--) {\n        if (n % i === 0) {\n            return i;\n        }\n    }\n    return 1; \/\/ By mathematical definition, 1 is a divisor of any integer.\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = largest_divisor;\n  assert.deepEqual(candidate(3),1);\n  assert.deepEqual(candidate(7),1);\n  assert.deepEqual(candidate(10),5);\n  assert.deepEqual(candidate(100),50);\n  assert.deepEqual(candidate(49),7);\n}\n\ntest();"},{"task_id":"HumanEval_25","nl":"dan_Latn","pl":"ts","prompt":"\/\/Indtastningsnummeret skal være lig med produktet af alle faktorer.\/\/Hver faktor skal rangordnes i forhold til antallet af gange, den optræder i faktorisering.\/\/Returnerer en række af primfaktorer for et givet heltal i rækkefølge fra mindste til største.\/\/ >>> factorize(8)\n\/\/ [2, 2, 2]\n\/\/ >>> factorize(25)\n\/\/ [5, 5]\n\/\/ >>> factorize(70)\n\/\/ [2, 5, 7]\nfunction factorize(n: number): number[] {\n","canonical_solution":"function factorize(n: number): number[] {\n    const factors: number[] = [];\n    let divisor = 2;\n    \n    while (n >= 2) {\n        if (n % divisor === 0) {\n            factors.push(divisor);\n            n \/= divisor;\n        } else {\n            divisor++;\n        }\n    }\n\n    return factors;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"},{"task_id":"HumanEval_26","nl":"dan_Latn","pl":"ts","prompt":"\/\/For at sikre, at de elementer, der er efterladt, er i samme rækkefølge som i indlæsningen.\/\/Fjern alle elementer, der forekommer mere end én gang, fra en matrix af heltal.\/\/ >>> remove_duplicates([1, 2, 3, 2, 4])\n\/\/ [1, 3, 4]\nfunction remove_duplicates(numbers: number[]): number[] {\n","canonical_solution":"function remove_duplicates(numbers: number[]): number[] {\n    const frequencyMap: Map<number, number> = new Map();\n\n    \/\/ Count the occurrences of each number\n    for (const num of numbers) {\n        frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1);\n    }\n\n    \/\/ Filter out the numbers occurring more than once\n    return numbers.filter(num => frequencyMap.get(num) === 1);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = remove_duplicates;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);\n  assert.deepEqual(candidate([1, 2, 3, 2, 4, 3, 5]),[1, 4, 5]);\n}\n\ntest();"},{"task_id":"HumanEval_27","nl":"dan_Latn","pl":"ts","prompt":"\/\/For en given streng skal små bogstaver vendes til store og store til små bogstaver. \/\/ >>> flip_case(\"Hello\")\n\/\/ \"hELLO\"\nfunction flip_case(string: string): string {\n","canonical_solution":"function flip_case(str: string): string {\n    let flipped = '';\n    for (let char of str) {\n        if (char === char.toUpperCase()) {\n            flipped += char.toLowerCase();\n        } else {\n            flipped += char.toUpperCase();\n        }\n    }\n    return flipped;\n}\n\n\/\/ Example usage:\nconsole.log(flip_case(\"Hello\")); \/\/ Output: \"hELLO\"","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = flip_case;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"Hello!\"),\"hELLO!\");\n  assert.deepEqual(candidate(\"These violent delights have violent ends\"),\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\");\n}\n\ntest();"},{"task_id":"HumanEval_28","nl":"dan_Latn","pl":"ts","prompt":"\/\/Koncatenere en række af strenge til en enkelt streng.\/\/ >>> concatenate([])\n\/\/ \"\"\n\/\/ >>> concatenate([\"a\", \"b\", \"c\"])\n\/\/ \"abc\"\nfunction concatenate(strings: string[]): string {\n","canonical_solution":"function concatenate(strings: string[]): string {\n    return strings.join('');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = concatenate;\n  assert.deepEqual(candidate([]),\"\");\n  assert.deepEqual(candidate([\"x\", \"y\", \"z\"]),\"xyz\");\n  assert.deepEqual(candidate([\"x\", \"y\", \"z\", \"w\", \"k\"]),\"xyzwk\");\n}\n\ntest();"},{"task_id":"HumanEval_29","nl":"dan_Latn","pl":"ts","prompt":"\/\/Filtrér en input matrix af strenge kun for dem, der starter med et givet præfix. \/\/ >>> filter_by_prefix([], \"a\")\n\/\/ []\n\/\/ >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n\/\/ [\"abc\", \"array\"]\nfunction filter_by_prefix(strings: string[], prefix: string): string[] {\n","canonical_solution":"function filter_by_prefix(strings: string[], prefix: string): string[] {\n    return strings.filter(str => str.startsWith(prefix));\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = filter_by_prefix;\n  assert.deepEqual(candidate([], \"john\"),[]);\n  assert.deepEqual(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"),[\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\n\ntest();"},{"task_id":"HumanEval_30","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer kun positive tal i matrixen.\/\/ >>> get_positive([-1, 2, -4, 5, 6])\n\/\/ [2, 5, 6]\n\/\/ >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/ [5, 3, 2, 3, 9, 123, 1]\nfunction get_positive(l: number[]): number[] {\n","canonical_solution":"function get_positive(l: number[]): number[] {\n    return l.filter(num => num > 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_positive;\n  assert.deepEqual(candidate([-1, -2, 4, 5, 6]),[4, 5, 6]);\n  assert.deepEqual(candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]),[5, 3, 2, 3, 3, 9, 123, 1]);\n  assert.deepEqual(candidate([-1, -2]),[]);\n  assert.deepEqual(candidate([]),[]);\n}\n\ntest();"},{"task_id":"HumanEval_31","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer sandt, hvis et givet tal er primt, og falsk ellers.\/\/ >>> is_prime(6)\n\/\/ false\n\/\/ >>> is_prime(101)\n\/\/ true\n\/\/ >>> is_prime(11)\n\/\/ true\n\/\/ >>> is_prime(13441)\n\/\/ true\n\/\/ >>> is_prime(61)\n\/\/ true\n\/\/ >>> is_prime(4)\n\/\/ false\n\/\/ >>> is_prime(1)\n\/\/ false\nfunction is_prime(n: number): boolean {\n","canonical_solution":"function is_prime(n: number): boolean {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 === 0 || n % 3 === 0) return false;\n    for (let i = 5; i * i <= n; i += 6) {\n        if (n % i === 0 || n % (i + 2) === 0) return false;\n    }\n    return true;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_prime;\n  assert.deepEqual(candidate(6),false);\n  assert.deepEqual(candidate(101),true);\n  assert.deepEqual(candidate(11),true);\n  assert.deepEqual(candidate(13441),true);\n  assert.deepEqual(candidate(61),true);\n  assert.deepEqual(candidate(4),false);\n  assert.deepEqual(candidate(1),false);\n  assert.deepEqual(candidate(5),true);\n  assert.deepEqual(candidate(11),true);\n  assert.deepEqual(candidate(17),true);\n  assert.deepEqual(candidate(85),false);\n  assert.deepEqual(candidate(77),false);\n  assert.deepEqual(candidate(255379),false);\n}\n\ntest();"},{"task_id":"HumanEval_33","nl":"dan_Latn","pl":"ts","prompt":"\/\/I dette tilfælde er der tale om en overførsel af de tilsvarende værdier i forhold til de tilsvarende indekser for l, men sorteret.\/\/l' er identisk med l i de indekser, der ikke er delelige med tre, mens dens værdier i de indekser, der er delelige med tre, er ens \/\/Denne funktion tager en matrix l og returnerer en matrix l' sådan at \/\/ >>> sort_third([1, 2, 3])\n\/\/ [1, 2, 3]\n\/\/ >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n\/\/ [2, 6, 3, 4, 8, 9, 5]\nfunction sort_third(l: number[]): number[] {\n","canonical_solution":"function sort_third(l: number[]): number[] {\n    const indicesDivByThree = l.map((_, i) => i).filter(i => i % 3 === 0);\n    const valuesDivByThree = indicesDivByThree.map(i => l[i]).sort((a, b) => a - b);\n\n    const result = l.slice();\n    for (let i = 0; i < indicesDivByThree.length; i++) {\n        result[indicesDivByThree[i]] = valuesDivByThree[i];\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_third;\n  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2]),[2, 6, 3, 4, 8, 9, 5]);\n  assert.deepEqual(candidate([5, 8, 3, 4, 6, 9, 2]),[2, 8, 3, 4, 6, 9, 5]);\n  assert.deepEqual(candidate([5, 6, 9, 4, 8, 3, 2]),[2, 6, 9, 4, 8, 3, 5]);\n  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2, 1]),[2, 6, 3, 4, 8, 9, 5, 1]);\n}\n\ntest();"},{"task_id":"HumanEval_34","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer sorterede unikke elementer i en matrix\/\/ >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/ [0, 2, 3, 5, 9, 123]\nfunction unique(l: number[]): number[] {\n","canonical_solution":"function unique(l: number[]): number[] {\n    const uniqueSet = new Set(l);\n    const uniqueArray = Array.from(uniqueSet);\n    uniqueArray.sort((a, b) => a - b);\n    return uniqueArray;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = unique;\n  assert.deepEqual(candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9, 123]);\n}\n\ntest();"},{"task_id":"HumanEval_35","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer det maksimale element i arrayet.\/\/ >>> max_element([1, 2, 3])\n\/\/ 3\n\/\/ >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/ 123\nfunction max_element(l: number[]): number {\n","canonical_solution":"function max_element(l: number[]): number {\n    if (l.length === 0) {\n        throw new Error(\"Array is empty\");\n    }\n    let max = l[0];\n    for (let i = 1; i < l.length; i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_element;\n  assert.deepEqual(candidate([1, 2, 3]),3);\n  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]),124);\n}\n\ntest();"},{"task_id":"HumanEval_36","nl":"dan_Latn","pl":"ts","prompt":"\/\/Angiver antallet af gange, cifferet 7 forekommer i heltal mindre end n, som er delbart med 11 eller 13. \/\/ >>> fizz_buzz(50)\n\/\/ 0\n\/\/ >>> fizz_buzz(78)\n\/\/ 2\n\/\/ >>> fizz_buzz(79)\n\/\/ 3\nfunction fizz_buzz(n: number): number {\n","canonical_solution":"function fizz_buzz(n: number): number {\n    let count = 0;\n\n    for (let i = 1; i < n; i++) {\n        if (i % 11 === 0 || i % 13 === 0) {\n            let numString = i.toString();\n            for (let char of numString) {\n                if (char === '7') {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fizz_buzz;\n  assert.deepEqual(candidate(50),0);\n  assert.deepEqual(candidate(78),2);\n  assert.deepEqual(candidate(79),3);\n  assert.deepEqual(candidate(100),3);\n  assert.deepEqual(candidate(200),6);\n  assert.deepEqual(candidate(4000),192);\n  assert.deepEqual(candidate(10000),639);\n  assert.deepEqual(candidate(100000),8026);\n}\n\ntest();"},{"task_id":"HumanEval_37","nl":"dan_Latn","pl":"ts","prompt":"\/\/I dette tilfælde er der tale om en af de to forskellige indekser, der er inddelt i de to forskellige indekser.\/\/l' er identisk med l i de ulige indekser, mens dens værdier i de lige indekser er ens \/\/Denne funktion tager en matrix l og returnerer en matrix l' sådan at \/\/ >>> sort_even([1, 2, 3])\n\/\/ [1, 2, 3]\n\/\/ >>> sort_even([5, 6, 3, 4])\n\/\/ [3, 6, 5, 4]\nfunction sort_even(l: number[]): number[] {\n","canonical_solution":"function sort_even(l: number[]): number[] {\n    const evenIndices: number[] = [];\n    const result: number[] = [...l];\n\n    \/\/ Collect values at even indices\n    for (let i = 0; i < l.length; i += 2) {\n        evenIndices.push(l[i]);\n    }\n\n    \/\/ Sort the collected even indices values\n    evenIndices.sort((a, b) => a - b);\n\n    \/\/ Place the sorted values back in their original even indices\n    for (let i = 0; i < l.length; i += 2) {\n        result[i] = evenIndices.shift()!;\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_even;\n  assert.deepEqual(candidate([1, 2, 3]),[1, 2, 3]);\n  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n  assert.deepEqual(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n\ntest();"},{"task_id":"HumanEval_39","nl":"dan_Latn","pl":"ts","prompt":"\/\/prime_fib returnerer et n-tal, der er et Fibonacci-tal, og det er også et primtal. \/\/ >>> prime_fib(1)\n\/\/ 2\n\/\/ >>> prime_fib(2)\n\/\/ 3\n\/\/ >>> prime_fib(3)\n\/\/ 5\n\/\/ >>> prime_fib(4)\n\/\/ 13\n\/\/ >>> prime_fib(5)\n\/\/ 89\nfunction prime_fib(n: number): number {\n","canonical_solution":"function isPrime(num: number): boolean {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 === 0 || num % 3 === 0) return false;\n    for (let i = 5; i * i <= num; i += 6) {\n        if (num % i === 0 || num % (i + 2) === 0) return false;\n    }\n    return true;\n}\n\nfunction* fibonacciGenerator(): Generator<number, void, unknown> {\n    let a = 0, b = 1;\n    while (true) {\n        let current = a;\n        a = b;\n        b = current + b;\n        yield current;\n    }\n}\n\nfunction prime_fib(n: number): number {\n    const fibGen = fibonacciGenerator();\n    let primeFibs: number[] = [];\n    let i = 0;\n    while (primeFibs.length < n) {\n        const fibNum = fibGen.next().value;\n        if (isPrime(fibNum)) {\n            primeFibs.push(fibNum);\n        }\n    }\n    return primeFibs[n - 1];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = prime_fib;\n  assert.deepEqual(candidate(1),2);\n  assert.deepEqual(candidate(2),3);\n  assert.deepEqual(candidate(3),5);\n  assert.deepEqual(candidate(4),13);\n  assert.deepEqual(candidate(5),89);\n  assert.deepEqual(candidate(6),233);\n  assert.deepEqual(candidate(7),1597);\n  assert.deepEqual(candidate(8),28657);\n  assert.deepEqual(candidate(9),514229);\n  assert.deepEqual(candidate(10),433494437);\n}\n\ntest();"},{"task_id":"HumanEval_40","nl":"dan_Latn","pl":"ts","prompt":"\/\/sum til nul, og falsk ellers. \/\/returnerer true, hvis der er tre forskellige elementer i matrixen, der \/\/triples_sum_to_zero tager en række af heltal som input.\/\/ >>> triples_sum_to_zero([1, 3, 5, 0])\n\/\/ false\n\/\/ >>> triples_sum_to_zero([1, 3, -2, 1])\n\/\/ true\n\/\/ >>> triples_sum_to_zero([1, 2, 3, 7])\n\/\/ false\n\/\/ >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n\/\/ true\n\/\/ >>> triples_sum_to_zero([1])\n\/\/ false\nfunction triples_sum_to_zero(l: number[]): boolean {\n","canonical_solution":"function triples_sum_to_zero(l: number[]): boolean {\n    if (l.length < 3) {\n        return false;\n    }\n\n    \/\/ Sort the array\n    l.sort((a, b) => a - b);\n\n    \/\/ Iterate through the array\n    for (let i = 0; i < l.length - 2; i++) {\n        let left = i + 1;\n        let right = l.length - 1;\n\n        \/\/ Use two pointers to find a pair that makes the sum zero with l[i]\n        while (left < right) {\n            const sum = l[i] + l[left] + l[right];\n            if (sum === 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = triples_sum_to_zero;\n  assert.deepEqual(candidate([1, 3, 5, 0]),false);\n  assert.deepEqual(candidate([1, 3, 5, -1]),false);\n  assert.deepEqual(candidate([1, 3, -2, 1]),true);\n  assert.deepEqual(candidate([1, 2, 3, 7]),false);\n  assert.deepEqual(candidate([1, 2, 5, 7]),false);\n  assert.deepEqual(candidate([2, 4, -5, 3, 9, 7]),true);\n  assert.deepEqual(candidate([1]),false);\n  assert.deepEqual(candidate([1, 3, 5, -100]),false);\n  assert.deepEqual(candidate([100, 3, 5, -100]),false);\n}\n\ntest();"},{"task_id":"HumanEval_41","nl":"dan_Latn","pl":"ts","prompt":"\/\/Denne funktion angiver antallet af sådanne kollisioner. \/\/De er i deres bane, som om de ikke kolliderede.\/\/Men vognene er uendeligt robuste og stærke, og derfor kører de videre.\/\/Når en bil, der kører fra venstre til højre, rammer en bil, der kører fra højre til venstre.\/\/Alle biler kører med samme hastighed.\/\/De to par biler starter meget langt fra hinanden.\/\/n biler kører fra venstre til højre; samtidig et andet sæt af n biler \/\/Forestil dig en vej, der er en perfekt lige uendeligt lang linje.function car_race_collision(n: number): number {\n","canonical_solution":"function car_race_collision(n: number): number {\n    \/\/ Since the cars move at the same speed and are infinitely strong,\n    \/\/ each pair of a left-to-right car and a right-to-left car will \"collide\" at some point.\n    \/\/ Therefore, every pair of cars from different sets will collide exactly once.\n    \n    \/\/ We need to find the number of such pairs, which is simply n * n.\n    return n * n;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = car_race_collision;\n  assert.deepEqual(candidate(2),4);\n  assert.deepEqual(candidate(3),9);\n  assert.deepEqual(candidate(4),16);\n  assert.deepEqual(candidate(8),64);\n  assert.deepEqual(candidate(10),100);\n}\n\ntest();"},{"task_id":"HumanEval_42","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer array med elementer, der er forøget med 1.\/\/ >>> incr_list([1, 2, 3])\n\/\/ [2, 3, 4]\n\/\/ >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/ [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunction incr_list(l: number[]): number[] {\n","canonical_solution":"function incr_list(l: number[]): number[] {\n    return l.map(num => num + 1);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = incr_list;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([3, 2, 1]),[4, 3, 2]);\n  assert.deepEqual(candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]),[6, 3, 6, 3, 4, 4, 10, 1, 124]);\n}\n\ntest();"},{"task_id":"HumanEval_43","nl":"dan_Latn","pl":"ts","prompt":"\/\/sum til nul, og falsk ellers. \/\/returnerer true, hvis der er to forskellige elementer i matrixen, der \/\/pairs_sum_to_zero tager en række af heltal som input. \/\/ >>> pairs_sum_to_zero([1, 3, 5, 0])\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([1, 3, -2, 1])\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([1, 2, 3, 7])\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n\/\/ true\n\/\/ >>> pairs_sum_to_zero([1])\n\/\/ false\nfunction pairs_sum_to_zero(l: number[]): boolean {\n","canonical_solution":"function pairs_sum_to_zero(l: number[]): boolean {\n    const seen = new Set<number>();\n\n    for (const num of l) {\n        if (seen.has(-num)) {\n            return true;\n        }\n        seen.add(num);\n    }\n\n    return false;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pairs_sum_to_zero;\n  assert.deepEqual(candidate([1, 3, 5, 0]),false);\n  assert.deepEqual(candidate([1, 3, -2, 1]),false);\n  assert.deepEqual(candidate([1, 2, 3, 7]),false);\n  assert.deepEqual(candidate([2, 4, -5, 3, 5, 7]),true);\n  assert.deepEqual(candidate([1]),false);\n  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 30]),true);\n  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 31]),true);\n  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 30]),false);\n  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 31]),false);\n}\n\ntest();"},{"task_id":"HumanEval_44","nl":"dan_Latn","pl":"ts","prompt":"\/\/Basenumre er mindre end 10.\/\/return strenge repræsentation efter konvertering. \/\/Ændre den numeriske basis for inputnummeret x til basis.\/\/ >>> change_base(8, 3)\n\/\/ \"22\"\n\/\/ >>> change_base(8, 2)\n\/\/ \"1000\"\n\/\/ >>> change_base(7, 2)\n\/\/ \"111\"\nfunction change_base(x: number, base: number): string {\n","canonical_solution":"function change_base(x: number, base: number): string {\n    if (base < 2 || base > 9) {\n        throw new Error(\"Base must be between 2 and 9 inclusive\");\n    }\n    \n    if (x === 0) return \"0\";\n\n    let result: string = \"\";\n    let number: number = x;\n\n    while (number > 0) {\n        const remainder = number % base;\n        result = remainder.toString() + result;\n        number = Math.floor(number \/ base);\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = change_base;\n  assert.deepEqual(candidate(8, 3),\"22\");\n  assert.deepEqual(candidate(9, 3),\"100\");\n  assert.deepEqual(candidate(234, 2),\"11101010\");\n  assert.deepEqual(candidate(16, 2),\"10000\");\n  assert.deepEqual(candidate(8, 2),\"1000\");\n  assert.deepEqual(candidate(7, 2),\"111\");\n  assert.deepEqual(candidate(2, 3),\"2\");\n  assert.deepEqual(candidate(3, 4),\"3\");\n  assert.deepEqual(candidate(4, 5),\"4\");\n  assert.deepEqual(candidate(5, 6),\"5\");\n  assert.deepEqual(candidate(6, 7),\"6\");\n  assert.deepEqual(candidate(7, 8),\"7\");\n}\n\ntest();"},{"task_id":"HumanEval_45","nl":"dan_Latn","pl":"ts","prompt":"\/\/Givet længde på en side og høj returareal for en trekant.\/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunction triangle_area(a: number, h: number): number {\n","canonical_solution":"function triangle_area(a: number, h: number): number {\n    return 0.5 * a * h;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = triangle_area;\n  assert.deepEqual(candidate(5, 3),7.5);\n  assert.deepEqual(candidate(2, 2),2.0);\n  assert.deepEqual(candidate(10, 8),40.0);\n}\n\ntest();"},{"task_id":"HumanEval_46","nl":"dan_Latn","pl":"ts","prompt":"\/\/Skriv en funktion, der effektivt beregner det n-te element i fib4-talsekvensen. Brug ikke rekursion. \/\/fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\/\/fib4(3) -> 0 \/\/fib4(2) -> 2 \/\/fib4(1) -> 0 \/\/fib4(0) -> 0 \/\/Fib4-talkæden er en sekvens, der ligner Fibbonacci-sekvensen, og som defineres som følger:\/\/ >>> fib4(5)\n\/\/ 4\n\/\/ >>> fib4(6)\n\/\/ 8\n\/\/ >>> fib4(7)\n\/\/ 14\nfunction fib4(n: number): number {\n","canonical_solution":"function fib4(n: number): number {\n    if (n === 0) return 0;\n    if (n === 1) return 0;\n    if (n === 2) return 2;\n    if (n === 3) return 0;\n\n    let fibNumbers = [0, 0, 2, 0];\n    for (let i = 4; i <= n; i++) {\n        const nextFib = fibNumbers[3] + fibNumbers[2] + fibNumbers[1] + fibNumbers[0];\n        fibNumbers.shift();\n        fibNumbers.push(nextFib);\n    }\n    return fibNumbers[3];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fib4;\n  assert.deepEqual(candidate(5),4);\n  assert.deepEqual(candidate(8),28);\n  assert.deepEqual(candidate(10),104);\n  assert.deepEqual(candidate(12),386);\n}\n\ntest();"},{"task_id":"HumanEval_47","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer medianen af elementer i matrixen l. \/\/ >>> median([3, 1, 2, 4, 5])\n\/\/ 3\n\/\/ >>> median([-10, 4, 6, 1000, 10, 20])\n\/\/ 15.0\nfunction median(l: number[]): number {\n","canonical_solution":"function median(l: number[]): number {\n    const sorted = l.slice().sort((a, b) => a - b);\n    const len = sorted.length;\n    \n    if (len % 2 === 0) {\n        return (sorted[len \/ 2 - 1] + sorted[len \/ 2]) \/ 2;\n    } else {\n        return sorted[Math.floor(len \/ 2)];\n    }\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = median;\n  assert.deepEqual(candidate([3, 1, 2, 4, 5]),3);\n  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);\n  assert.deepEqual(candidate([5]),5);\n  assert.deepEqual(candidate([6, 5]),5.5);\n  assert.deepEqual(candidate([8, 1, 3, 9, 9, 2, 7]),7);\n}\n\ntest();"},{"task_id":"HumanEval_48","nl":"dan_Latn","pl":"ts","prompt":"\/\/Kontrollerer, om den givne streng er et palindrom\/\/ >>> is_palindrome(\"\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aba\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aaaaa\")\n\/\/ true\n\/\/ >>> is_palindrome(\"zbcd\")\n\/\/ false\nfunction is_palindrome(text: string): boolean {\n","canonical_solution":"function is_palindrome(text: string): boolean {\n    return text === text.split('').reverse().join('');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_palindrome;\n  assert.deepEqual(candidate(\"\"),true);\n  assert.deepEqual(candidate(\"aba\"),true);\n  assert.deepEqual(candidate(\"aaaaa\"),true);\n  assert.deepEqual(candidate(\"zbcd\"),false);\n  assert.deepEqual(candidate(\"xywyx\"),true);\n  assert.deepEqual(candidate(\"xywyz\"),false);\n  assert.deepEqual(candidate(\"xywzx\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_49","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer 2^n modulo p (hvis du er opmærksom på tallene).\/\/ >>> modp(3, 5)\n\/\/ 3\n\/\/ >>> modp(1101, 101)\n\/\/ 2\n\/\/ >>> modp(0, 101)\n\/\/ 1\n\/\/ >>> modp(3, 11)\n\/\/ 8\n\/\/ >>> modp(100, 101)\n\/\/ 1\nfunction modp(n: number, p: number): number {\n","canonical_solution":"function modp(n: number, p: number): number {\n    if (n === 0) return 1 % p;\n    let result = 1;\n    let base = 2;\n    \n    while (n > 0) {\n        if (n % 2 === 1) {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        n = Math.floor(n \/ 2);\n    }\n    \n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = modp;\n  assert.deepEqual(candidate(3, 5),3);\n  assert.deepEqual(candidate(1101, 101),2);\n  assert.deepEqual(candidate(0, 101),1);\n  assert.deepEqual(candidate(3, 11),8);\n  assert.deepEqual(candidate(100, 101),1);\n  assert.deepEqual(candidate(30, 5),4);\n  assert.deepEqual(candidate(31, 5),3);\n}\n\ntest();"},{"task_id":"HumanEval_51","nl":"dan_Latn","pl":"ts","prompt":"\/\/remove_vowels er en funktion, der tager streng og returnerer streng uden vokaler. \/\/ >>> remove_vowels(\"\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"abcdef\")\n\/\/ \"bcdf\"\n\/\/ >>> remove_vowels(\"aaaaa\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"aaBAA\")\n\/\/ \"B\"\n\/\/ >>> remove_vowels(\"zbcd\")\n\/\/ \"zbcd\"\nfunction remove_vowels(text: string): string {\n","canonical_solution":"function remove_vowels(text: string): string {\n    return text.replace(\/[aeiouAEIOU]\/g, '');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = remove_vowels;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"abcdef\\nghijklm\"),\"bcdf\\nghjklm\");\n  assert.deepEqual(candidate(\"fedcba\"),\"fdcb\");\n  assert.deepEqual(candidate(\"eeeee\"),\"\");\n  assert.deepEqual(candidate(\"acBAA\"),\"cB\");\n  assert.deepEqual(candidate(\"EcBOO\"),\"cB\");\n  assert.deepEqual(candidate(\"ybcd\"),\"ybcd\");\n}\n\ntest();"},{"task_id":"HumanEval_52","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer true, hvis alle tal i matrix l er under tærskelværdien t. \/\/ >>> below_threshold([1, 2, 4, 10], 100)\n\/\/ true\n\/\/ >>> below_threshold([1, 20, 4, 10], 5)\n\/\/ false\nfunction below_threshold(l: number[], t: number): boolean {\n","canonical_solution":"function below_threshold(l: number[], t: number): boolean {\n    return l.every(num => num < t);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = below_threshold;\n  assert.deepEqual(candidate([1, 2, 4, 10], 100),true);\n  assert.deepEqual(candidate([1, 20, 4, 10], 5),false);\n  assert.deepEqual(candidate([1, 20, 4, 10], 21),true);\n  assert.deepEqual(candidate([1, 20, 4, 10], 22),true);\n  assert.deepEqual(candidate([1, 8, 4, 10], 11),true);\n  assert.deepEqual(candidate([1, 8, 4, 10], 10),false);\n}\n\ntest();"},{"task_id":"HumanEval_53","nl":"dan_Latn","pl":"ts","prompt":"\/\/Læg to tal sammen x og y.\/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunction add(x: number, y: number): number {\n","canonical_solution":"function add(x: number, y: number): number {\n    return x + y;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = add;\n  assert.deepEqual(candidate(0, 1),1);\n  assert.deepEqual(candidate(1, 0),1);\n  assert.deepEqual(candidate(2, 3),5);\n  assert.deepEqual(candidate(5, 7),12);\n  assert.deepEqual(candidate(7, 5),12);\n}\n\ntest();"},{"task_id":"HumanEval_54","nl":"dan_Latn","pl":"ts","prompt":"\/\/Kontroller, om to ord har samme tegn. \/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"abcd\", \"dddddddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"dddddddabc\", \"abcd\")\n\/\/ true\n\/\/ >>> same_chars(\"eabcd\", \"dddddddabc\")\n\/\/ false\n\/\/ >>> same_chars(\"abcd\", \"dddddddabce\")\n\/\/ false\n\/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n\/\/ false\nfunction same_chars(s0: string, s1: string): boolean {\n","canonical_solution":"function same_chars(s0: string, s1: string): boolean {\n    const charSet0: Set<string> = new Set(s0);\n    const charSet1: Set<string> = new Set(s1);\n\n    if (charSet0.size !== charSet1.size) {\n        return false;\n    }\n\n    for (const char of charSet0) {\n        if (!charSet1.has(char)) {\n            return false;\n        }\n    }\n\n    return true;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = same_chars;\n  assert.deepEqual(candidate(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"),true);\n  assert.deepEqual(candidate(\"abcd\", \"dddddddabc\"),true);\n  assert.deepEqual(candidate(\"dddddddabc\", \"abcd\"),true);\n  assert.deepEqual(candidate(\"eabcd\", \"dddddddabc\"),false);\n  assert.deepEqual(candidate(\"abcd\", \"dddddddabcf\"),false);\n  assert.deepEqual(candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"),false);\n  assert.deepEqual(candidate(\"aabb\", \"aaccc\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_55","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer n-te Fibonacci-tal. \/\/ >>> fib(10)\n\/\/ 55\n\/\/ >>> fib(1)\n\/\/ 1\n\/\/ >>> fib(8)\n\/\/ 21\nfunction fib(n: number): number {\n","canonical_solution":"function fib(n: number): number {\n    if (n <= 0) {\n        throw new Error(\"Input should be a positive integer.\");\n    }\n    if (n === 1) return 1;\n    if (n === 2) return 1;\n\n    let a = 1, b = 1;\n    for (let i = 3; i <= n; i++) {\n        const temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n\/\/ Example usage:\nconsole.log(fib(10)); \/\/ 55\nconsole.log(fib(1));  \/\/ 1\nconsole.log(fib(8));  \/\/ 21","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fib;\n  assert.deepEqual(candidate(10),55);\n  assert.deepEqual(candidate(1),1);\n  assert.deepEqual(candidate(8),21);\n  assert.deepEqual(candidate(11),89);\n  assert.deepEqual(candidate(12),144);\n}\n\ntest();"},{"task_id":"HumanEval_56","nl":"dan_Latn","pl":"ts","prompt":"\/\/return true hvis hver åbningsstykke har en tilsvarende lukke stykke. \/\/Parentes er en streng af \"<\" og \">\". \/\/ >>> correct_bracketing(\"<\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"<>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"<<><>>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"><<>\")\n\/\/ false\nfunction correct_bracketing(brackets: string): boolean {\n","canonical_solution":"function correct_bracketing(brackets: string): boolean {\n    let balance = 0;\n    for (let char of brackets) {\n        if (char === '<') {\n            balance++;\n        } else if (char === '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance === 0;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = correct_bracketing;\n  assert.deepEqual(candidate(\"<>\"),true);\n  assert.deepEqual(candidate(\"<<><>>\"),true);\n  assert.deepEqual(candidate(\"<><><<><>><>\"),true);\n  assert.deepEqual(candidate(\"<><><<<><><>><>><<><><<>>>\"),true);\n  assert.deepEqual(candidate(\"<<<><>>>>\"),false);\n  assert.deepEqual(candidate(\"><<>\"),false);\n  assert.deepEqual(candidate(\"<\"),false);\n  assert.deepEqual(candidate(\"<<<<\"),false);\n  assert.deepEqual(candidate(\">\"),false);\n  assert.deepEqual(candidate(\"<<>\"),false);\n  assert.deepEqual(candidate(\"<><><<><>><>><<>\"),false);\n  assert.deepEqual(candidate(\"<><><<><>><>>><>\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_57","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer sandt, hvis array-elementerne monotont øges eller falder.\/\/ >>> monotonic([1, 2, 4, 20])\n\/\/ true\n\/\/ >>> monotonic([1, 20, 4, 10])\n\/\/ false\n\/\/ >>> monotonic([4, 1, 0, -10])\n\/\/ true\nfunction monotonic(l: number[]): boolean {\n","canonical_solution":"function monotonic(l: number[]): boolean {\n    if (l.length <= 1) return true;\n    \n    let increasing = true;\n    let decreasing = true;\n    \n    for (let i = 1; i < l.length; i++) {\n        if (l[i] > l[i - 1]) decreasing = false;\n        if (l[i] < l[i - 1]) increasing = false;\n        \n        if (!increasing && !decreasing) return false;\n    }\n    \n    return increasing || decreasing;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = monotonic;\n  assert.deepEqual(candidate([1, 2, 4, 10]),true);\n  assert.deepEqual(candidate([1, 2, 4, 20]),true);\n  assert.deepEqual(candidate([1, 20, 4, 10]),false);\n  assert.deepEqual(candidate([4, 1, 0, -10]),true);\n  assert.deepEqual(candidate([4, 1, 1, 0]),true);\n  assert.deepEqual(candidate([1, 2, 3, 2, 5, 60]),false);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 60]),true);\n  assert.deepEqual(candidate([9, 9, 9, 9]),true);\n}\n\ntest();"},{"task_id":"HumanEval_58","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer sorterede unikke fælles elementer for to arrays. \/\/ >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n\/\/ [1, 5, 653]\n\/\/ >>> common([5, 3, 2, 8], [3, 2])\n\/\/ [2, 3]\nfunction common(l1: number[], l2: number[]): number[] {\n","canonical_solution":"function common(l1: number[], l2: number[]): number[] {\n    const set1 = new Set(l1);\n    const set2 = new Set(l2);\n    const commonElements = Array.from(set1).filter(item => set2.has(item));\n    return commonElements.sort((a, b) => a - b);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = common;\n  assert.deepEqual(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);\n  assert.deepEqual(candidate([5, 3, 2, 8], [3, 2]),[2, 3]);\n  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2, 4]),[2, 3, 4]);\n  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);\n}\n\ntest();"},{"task_id":"HumanEval_59","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer den største primtalende faktor af n. Antag n > 1 og er ikke primtalende. \/\/ >>> largest_prime_factor(13195)\n\/\/ 29\n\/\/ >>> largest_prime_factor(2048)\n\/\/ 2\nfunction largest_prime_factor(n: number): number {\n","canonical_solution":"function largest_prime_factor(n: number): number {\n    let largestFactor = 1;\n\n    \/\/ Divide n by 2 until it becomes odd\n    while (n % 2 === 0) {\n        largestFactor = 2;\n        n \/= 2;\n    }\n\n    \/\/ Check for odd factors from 3 upwards\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        while (n % i === 0) {\n            largestFactor = i;\n            n \/= i;\n        }\n    }\n\n    \/\/ If n becomes a prime number greater than 2\n    if (n > 2) {\n        largestFactor = n;\n    }\n\n    return largestFactor;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = largest_prime_factor;\n  assert.deepEqual(candidate(15),5);\n  assert.deepEqual(candidate(27),3);\n  assert.deepEqual(candidate(63),7);\n  assert.deepEqual(candidate(330),11);\n  assert.deepEqual(candidate(13195),29);\n}\n\ntest();"},{"task_id":"HumanEval_60","nl":"dan_Latn","pl":"ts","prompt":"\/\/sum_to_n er en funktion, der summerer tal fra 1 til n. \/\/ >>> sum_to_n(30)\n\/\/ 465\n\/\/ >>> sum_to_n(100)\n\/\/ 5050\n\/\/ >>> sum_to_n(5)\n\/\/ 15\n\/\/ >>> sum_to_n(10)\n\/\/ 55\n\/\/ >>> sum_to_n(1)\n\/\/ 1\nfunction sum_to_n(n: number): number {\n","canonical_solution":"function sum_to_n(n: number): number {\n    return n * (n + 1) \/ 2;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sum_to_n;\n  assert.deepEqual(candidate(1),1);\n  assert.deepEqual(candidate(6),21);\n  assert.deepEqual(candidate(11),66);\n  assert.deepEqual(candidate(30),465);\n  assert.deepEqual(candidate(100),5050);\n}\n\ntest();"},{"task_id":"HumanEval_61","nl":"dan_Latn","pl":"ts","prompt":"\/\/return true hvis hver åbningsstykke har en tilsvarende lukke stykke. \/\/Parentes er en streng af \"(\" og \")\". \/\/ >>> correct_bracketing(\"(\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"()\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"(()())\")\n\/\/ true\n\/\/ >>> correct_bracketing(\")(()\")\n\/\/ false\nfunction correct_bracketing(brackets: string): boolean {\n","canonical_solution":"function correct_bracketing(brackets: string): boolean {\n    let balance = 0;\n\n    for (let char of brackets) {\n        if (char === '(') {\n            balance++;\n        } else if (char === ')') {\n            balance--;\n        }\n\n        \/\/ If balance goes negative, there's a closing bracket without a matching opening one\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    \/\/ If balance is zero, all opening brackets have matching closing brackets\n    return balance === 0;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = correct_bracketing;\n  assert.deepEqual(candidate(\"()\"),true);\n  assert.deepEqual(candidate(\"(()())\"),true);\n  assert.deepEqual(candidate(\"()()(()())()\"),true);\n  assert.deepEqual(candidate(\"()()((()()())())(()()(()))\"),true);\n  assert.deepEqual(candidate(\"((()())))\"),false);\n  assert.deepEqual(candidate(\")(()\"),false);\n  assert.deepEqual(candidate(\"(\"),false);\n  assert.deepEqual(candidate(\"((((\"),false);\n  assert.deepEqual(candidate(\")\"),false);\n  assert.deepEqual(candidate(\"(()\"),false);\n  assert.deepEqual(candidate(\"()()(()())())(()\"),false);\n  assert.deepEqual(candidate(\"()()(()())()))()\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_62","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer derivatet af dette polynom i samme form.\/\/xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/x er koefficienter for et polynom.\/\/ >>> derivative([3, 1, 2, 4, 5])\n\/\/ [1, 4, 12, 20]\n\/\/ >>> derivative([1, 2, 3])\n\/\/ [2, 6]\nfunction derivative(xs: number[]): number[] {\n","canonical_solution":"function derivative(xs: number[]): number[] {\n    return xs.slice(1).map((coef, index) => coef * (index + 1));\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = derivative;\n  assert.deepEqual(candidate([3, 1, 2, 4, 5]),[1, 4, 12, 20]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 6]);\n  assert.deepEqual(candidate([3, 2, 1]),[2, 2]);\n  assert.deepEqual(candidate([3, 2, 1, 0, 4]),[2, 2, 0, 16]);\n  assert.deepEqual(candidate([1]),[]);\n}\n\ntest();"},{"task_id":"HumanEval_63","nl":"dan_Latn","pl":"ts","prompt":"\/\/Skriv en funktion, der effektivt kan beregne det n-te element i fibfib-talsekvensen.\/\/fibfib (n) == fibfib (n-1) + fibfib (n-2) + fibfib (n-3). \/\/Fibfib ((2) == 1 \/\/Fibfib ((1)) == 0 \/\/0 = 0 \/\/FibFib-talkæden er en sekvens, der ligner Fibbonacci-sekvensen, og som defineres som følger:\/\/ >>> fibfib(1)\n\/\/ 0\n\/\/ >>> fibfib(5)\n\/\/ 4\n\/\/ >>> fibfib(8)\n\/\/ 24\nfunction fibfib(n: number): number {\n","canonical_solution":"function fibfib(n: number): number {\n    if (n === 0 || n === 1) return 0;\n    if (n === 2) return 1;\n\n    let a = 0;\n    let b = 0;\n    let c = 1;\n\n    for (let i = 3; i <= n; i++) {\n        let next = a + b + c;\n        a = b;\n        b = c;\n        c = next;\n    }\n\n    return c;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fibfib;\n  assert.deepEqual(candidate(2),1);\n  assert.deepEqual(candidate(1),0);\n  assert.deepEqual(candidate(5),4);\n  assert.deepEqual(candidate(8),24);\n  assert.deepEqual(candidate(10),81);\n  assert.deepEqual(candidate(12),274);\n  assert.deepEqual(candidate(14),927);\n}\n\ntest();"},{"task_id":"HumanEval_64","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Vokal, men kun når det er i slutningen af det givne ord.\/\/Vokaler i dette tilfælde er \"a\", \"e\", \"i\", \"o\", \"u\". Her er \"y\" også en \/\/et ord som input og returnerer antallet af vokaler i streng. \/\/Skriv en funktion, som tager en streng, der repræsenterer \/\/ >>> vowels_count(\"abcde\")\n\/\/ 2\n\/\/ >>> vowels_count(\"ACEDY\")\n\/\/ 3\nfunction vowels_count(s: string): number {\n","canonical_solution":"function vowels_count(s: string): number {\n    let count = 0;\n    const vowels = new Set(['a', 'e', 'i', 'o', 'u']);\n    const lowerCaseString = s.toLowerCase();\n\n    for (let i = 0; i < lowerCaseString.length; i++) {\n        if (vowels.has(lowerCaseString[i])) {\n            count++;\n        }\n        if (i === lowerCaseString.length - 1 && lowerCaseString[i] === 'y') {\n            count++;\n        }\n    }\n\n    return count;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = vowels_count;\n  assert.deepEqual(candidate(\"abcde\"),2);\n  assert.deepEqual(candidate(\"Alone\"),3);\n  assert.deepEqual(candidate(\"key\"),2);\n  assert.deepEqual(candidate(\"bye\"),1);\n  assert.deepEqual(candidate(\"keY\"),2);\n  assert.deepEqual(candidate(\"bYe\"),1);\n  assert.deepEqual(candidate(\"ACEDY\"),3);\n}\n\ntest();"},{"task_id":"HumanEval_65","nl":"dan_Latn","pl":"ts","prompt":"\/\/Hvis shift > antal cifre, returneres cifre omvendt. \/\/og returnerer resultatet som en streng. \/\/Vi skifter tallene i cirklen fra det hele tal x til højre.\/\/ >>> circular_shift(12, 1)\n\/\/ \"21\"\n\/\/ >>> circular_shift(12, 2)\n\/\/ \"12\"\nfunction circular_shift(x: number, shift: number): string {\n","canonical_solution":"function circular_shift(x: number, shift: number): string {\n    const strNum = x.toString();\n    const length = strNum.length;\n    if (shift >= length) {\n        return strNum.split('').reverse().join('');\n    }\n    const normalizedShift = shift % length;\n    const splitIndex = length - normalizedShift;\n    return strNum.slice(splitIndex) + strNum.slice(0, splitIndex);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = circular_shift;\n  assert.deepEqual(candidate(100, 2),\"001\");\n  assert.deepEqual(candidate(12, 2),\"12\");\n  assert.deepEqual(candidate(97, 8),\"79\");\n  assert.deepEqual(candidate(12, 1),\"21\");\n  assert.deepEqual(candidate(11, 101),\"11\");\n}\n\ntest();"},{"task_id":"HumanEval_66","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/ASCII-koder. \/\/Skriv en funktion, der tager en streng som input og kun returnerer summen af de øverste tegn' \/\/Opgave \/\/ >>> digitSum(\"\")\n\/\/ 0\n\/\/ >>> digitSum(\"abAB\")\n\/\/ 131\n\/\/ >>> digitSum(\"abcCd\")\n\/\/ 67\n\/\/ >>> digitSum(\"helloE\")\n\/\/ 69\n\/\/ >>> digitSum(\"woArBld\")\n\/\/ 131\n\/\/ >>> digitSum(\"aAaaaXa\")\n\/\/ 153\nfunction digitSum(s: string): number {\n","canonical_solution":"function digitSum(s: string): number {\n    let sum = 0;\n    for (const char of s) {\n        if (char >= 'A' && char <= 'Z') {\n            sum += char.charCodeAt(0);\n        }\n    }\n    return sum;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = digitSum;\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"abAB\"),131);\n  assert.deepEqual(candidate(\"abcCd\"),67);\n  assert.deepEqual(candidate(\"helloE\"),69);\n  assert.deepEqual(candidate(\"woArBld\"),131);\n  assert.deepEqual(candidate(\"aAaaaXa\"),153);\n  assert.deepEqual(candidate(\" How are yOu?\"),151);\n  assert.deepEqual(candidate(\"You arE Very Smart\"),327);\n}\n\ntest();"},{"task_id":"HumanEval_67","nl":"dan_Latn","pl":"ts","prompt":"\/\/for examble: \/\/i kurven angiver antallet af mangofrugter i kurven. \/\/appelsiner og æbler og et heltal, der repræsenterer det samlede antal frugter \/\/Vi har taget æbler, appelsiner og mangoer, og givet strengen, der repræsenterer det samlede antal \/\/som er fordelt i en kurv med frugt, som denne kurv indeholder \/\/I denne opgave får du en streng, der repræsenterer et antal æbler og appelsiner.\/\/ >>> fruit_distribution(\"5 apples and 6 oranges\", 19)\n\/\/ 8\n\/\/ >>> fruit_distribution(\"0 apples and 1 oranges\", 3)\n\/\/ 2\n\/\/ >>> fruit_distribution(\"2 apples and 3 oranges\", 100)\n\/\/ 95\n\/\/ >>> fruit_distribution(\"100 apples and 1 oranges\", 120)\n\/\/ 19\nfunction fruit_distribution(s: string, n: number): number {\n","canonical_solution":"function fruit_distribution(s: string, n: number): number {\n    const regex = \/(\\d+) apples and (\\d+) oranges\/;\n    const match = s.match(regex);\n    \n    if (!match) {\n        throw new Error(\"Invalid input format\");\n    }\n    \n    const apples = parseInt(match[1], 10);\n    const oranges = parseInt(match[2], 10);\n    \n    const totalApplesAndOranges = apples + oranges;\n    return n - totalApplesAndOranges;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fruit_distribution;\n  assert.deepEqual(candidate(\"5 apples and 6 oranges\", 19),8);\n  assert.deepEqual(candidate(\"5 apples and 6 oranges\", 21),10);\n  assert.deepEqual(candidate(\"0 apples and 1 oranges\", 3),2);\n  assert.deepEqual(candidate(\"1 apples and 0 oranges\", 3),2);\n  assert.deepEqual(candidate(\"2 apples and 3 oranges\", 100),95);\n  assert.deepEqual(candidate(\"2 apples and 3 oranges\", 5),0);\n  assert.deepEqual(candidate(\"1 apples and 100 oranges\", 120),19);\n}\n\ntest();"},{"task_id":"HumanEval_68","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel 1: \/\/Hvis der ikke er nogen lige værdier, eller den givne matrix er tom, returneres [].\/\/Den plukkede node skal returneres i en matrix, [ smalest_value, dens indeks ], \/\/Hvis der findes flere noder med samme mindste lige værdi, returneres den node, der har mindste indeks. \/\/Den plukkede knudepunkt skal være den knudepunkt med den mindste lige værdi.\/\/Din opgave er at plukke en af knuderne og returnere den.\/\/\"Givet en matrix, der repræsenterer en gren af et træ, der har ikke-negative heltal knuder \/\/ >>> pluck([4, 2, 3])\n\/\/ [2, 1]\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 2:\n\/\/ >>> pluck([1, 2, 3])\n\/\/ [2, 1]\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 3:\n\/\/ >>> pluck([])\n\/\/ []\n\/\/ Example 4:\n\/\/ >>> pluck([5, 0, 3, 0, 4, 2])\n\/\/ [0, 1]\n\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/ so we will choose the first zero, which has the smallest index.\n\/\/ Constraints:\n\/\/ * 1 <= nodes.length <= 10000\n\/\/ * 0 <= node.value\nfunction pluck(arr: number[]): number[] {\n","canonical_solution":"function pluck(arr: number[]): number[] {\n    let minEvenValue: number | null = null;\n    let minIndex: number | null = null;\n\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] % 2 === 0) { \/\/ Check if the number is even\n            if (minEvenValue === null || arr[i] < minEvenValue) {\n                minEvenValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n\n    if (minEvenValue !== null && minIndex !== null) {\n        return [minEvenValue, minIndex];\n    } else {\n        return [];\n    }\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"},{"task_id":"HumanEval_69","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Hvis der ikke findes en sådan værdi, returneres -1.\/\/Frekvensen af et heltal er antallet af gange det optræder i matrixen.\/\/nul, og har en frekvens, der er større end eller lig med hele talets værdi. \/\/Vi har en ikke-tom matrix af positive heltal, og returnerer det største heltal, der er større end .\/\/ >>> search([4, 1, 2, 2, 3, 1])\n\/\/ 2\n\/\/ >>> search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/ 3\n\/\/ >>> search([5, 5, 4, 4, 4])\n\/\/ -1\nfunction search(lst: number[]): number {\n","canonical_solution":"function search(lst: number[]): number {\n    const frequencyMap: Map<number, number> = new Map();\n\n    \/\/ Count frequencies of each integer in the array\n    for (const num of lst) {\n        frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1);\n    }\n\n    let result = -1;\n\n    \/\/ Determine the greatest integer that meets the condition\n    for (const [num, freq] of frequencyMap.entries()) {\n        if (freq >= num && num > result) {\n            result = num;\n        }\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = search;\n  assert.deepEqual(candidate([5, 5, 5, 5, 1]),1);\n  assert.deepEqual(candidate([4, 1, 4, 1, 4, 4]),4);\n  assert.deepEqual(candidate([3, 3]),-1);\n  assert.deepEqual(candidate([8, 8, 8, 8, 8, 8, 8, 8]),8);\n  assert.deepEqual(candidate([2, 3, 3, 2, 2]),2);\n  assert.deepEqual(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]),1);\n  assert.deepEqual(candidate([3, 2, 8, 2]),2);\n  assert.deepEqual(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]),1);\n  assert.deepEqual(candidate([8, 8, 3, 6, 5, 6, 4]),-1);\n  assert.deepEqual(candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]),1);\n  assert.deepEqual(candidate([1, 9, 10, 1, 3]),1);\n  assert.deepEqual(candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]),5);\n  assert.deepEqual(candidate([1]),1);\n  assert.deepEqual(candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]),4);\n  assert.deepEqual(candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]),2);\n  assert.deepEqual(candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]),1);\n  assert.deepEqual(candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]),4);\n  assert.deepEqual(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]),4);\n  assert.deepEqual(candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]),2);\n  assert.deepEqual(candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]),-1);\n  assert.deepEqual(candidate([10]),-1);\n  assert.deepEqual(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),2);\n  assert.deepEqual(candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]),1);\n  assert.deepEqual(candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]),1);\n  assert.deepEqual(candidate([3, 10, 10, 9, 2]),-1);\n}\n\ntest();"},{"task_id":"HumanEval_70","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Så er der maksimum for de resterende heltal, så er der minimum og så videre.\/\/Det er en mærkelig sortering, når man starter med den mindste værdi.\/\/Givet en række af heltal, returnerer vi en række i en mærkelig rækkefølge.\/\/ >>> strange_sort_list([1, 2, 3, 4])\n\/\/ [1, 4, 2, 3]\n\/\/ >>> strange_sort_list([5, 5, 5, 5])\n\/\/ [5, 5, 5, 5]\n\/\/ >>> strange_sort_list([])\n\/\/ []\nfunction strange_sort_list(lst: number[]): number[] {\n","canonical_solution":"function strange_sort_list(lst: number[]): number[] {\n    const sorted = [...lst].sort((a, b) => a - b);\n    const result: number[] = [];\n    let left = 0;\n    let right = sorted.length - 1;\n\n    while (left <= right) {\n        if (left === right) {\n            result.push(sorted[left]);\n        } else {\n            result.push(sorted[left]);\n            result.push(sorted[right]);\n        }\n        left++;\n        right--;\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = strange_sort_list;\n  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 4, 2, 3]);\n  assert.deepEqual(candidate([5, 6, 7, 8, 9]),[5, 9, 6, 8, 7]);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5]),[1, 5, 2, 4, 3]);\n  assert.deepEqual(candidate([5, 6, 7, 8, 9, 1]),[1, 9, 5, 8, 6, 7]);\n  assert.deepEqual(candidate([5, 5, 5, 5]),[5, 5, 5, 5]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8]),[1, 8, 2, 7, 3, 6, 4, 5]);\n  assert.deepEqual(candidate([0, 2, 2, 2, 5, 5, -5, -5]),[-5, 5, -5, 5, 0, 2, 2, 2]);\n  assert.deepEqual(candidate([111111]),[111111]);\n}\n\ntest();"},{"task_id":"HumanEval_71","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Det er den tredje side.\/\/Tre sider udgør en gyldig trekant, når summen af to sider er større.\/\/Ellers returneres -1 \/\/trekanten afrundet til 2 decimaler, hvis de tre sider udgør en gyldig trekant. \/\/Givet længderne på de tre sider af en trekant, returnerer vi arealet af \/\/ >>> triangle_area(3, 4, 5)\n\/\/ 6.0\n\/\/ >>> triangle_area(1, 2, 10)\n\/\/ -1\nfunction triangle_area(a: number, b: number, c: number): number {\n","canonical_solution":"function triangle_area(a: number, b: number, c: number): number {\n    \/\/ Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        \/\/ Calculate the semi-perimeter\n        const s = (a + b + c) \/ 2;\n        \/\/ Calculate the area using Heron's formula\n        const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \/\/ Return the area rounded to 2 decimal places\n        return Math.round(area * 100) \/ 100;\n    }\n    \/\/ Return -1 if the sides do not form a valid triangle\n    return -1;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = triangle_area;\n  assert.deepEqual(candidate(3, 4, 5),6.0);\n  assert.deepEqual(candidate(1, 2, 10),-1);\n  assert.deepEqual(candidate(4, 8, 5),8.18);\n  assert.deepEqual(candidate(2, 2, 2),1.73);\n  assert.deepEqual(candidate(1, 2, 3),-1);\n  assert.deepEqual(candidate(10, 5, 7),16.25);\n  assert.deepEqual(candidate(2, 6, 3),-1);\n  assert.deepEqual(candidate(1, 1, 1),0.43);\n  assert.deepEqual(candidate(2, 2, 10),-1);\n}\n\ntest();"},{"task_id":"HumanEval_72","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Objektet q flyver, hvis det er afbalanceret (det er en palindromisk matrix) og summen af dets elementer er mindre end eller lig med den maksimale mulige vægt w.\/\/Skriv en funktion, der returnerer true, hvis objektet q flyver, og false ellers. \/\/ >>> will_it_fly([1, 2], 5)\n\/\/ false\n\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/ >>> will_it_fly([3, 2, 3], 1)\n\/\/ false\n\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/ >>> will_it_fly([3, 2, 3], 9)\n\/\/ true\n\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/ >>> will_it_fly([3], 5)\n\/\/ true\n\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunction will_it_fly(q: number[], w: number): boolean {\n","canonical_solution":"function will_it_fly(q: number[], w: number): boolean {\n    \/\/ Check if the array is balanced (palindromic)\n    const isBalanced = (arr: number[]): boolean => {\n        for (let i = 0; i < arr.length \/ 2; i++) {\n            if (arr[i] !== arr[arr.length - 1 - i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    \/\/ Calculate the sum of the elements in the array\n    const sumElements = q.reduce((acc, curr) => acc + curr, 0);\n\n    \/\/ Check both conditions: balanced array and sum less than or equal to max weight\n    return isBalanced(q) && sumElements <= w;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = will_it_fly;\n  assert.deepEqual(candidate([3, 2, 3], 9),true);\n  assert.deepEqual(candidate([1, 2], 5),false);\n  assert.deepEqual(candidate([3], 5),true);\n  assert.deepEqual(candidate([3, 2, 3], 1),false);\n  assert.deepEqual(candidate([1, 2, 3], 6),false);\n  assert.deepEqual(candidate([5], 5),true);\n}\n\ntest();"},{"task_id":"HumanEval_73","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/I en ændring kan du ændre et element til et andet element.\/\/En palindrom matrix er en matrix, der \/\/Find det mindste antal elementer i en række arr af heltal, som \/\/ >>> smallest_change([1, 2, 3, 5, 4, 7, 9, 6])\n\/\/ 4\n\/\/ >>> smallest_change([1, 2, 3, 4, 3, 2, 2])\n\/\/ 1\n\/\/ >>> smallest_change([1, 2, 3, 2, 1])\n\/\/ 0\nfunction smallest_change(arr: number[]): number {\n","canonical_solution":"function smallest_change(arr: number[]): number {\n    let changes = 0;\n    let left = 0;\n    let right = arr.length - 1;\n\n    while (left < right) {\n        if (arr[left] !== arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = smallest_change;\n  assert.deepEqual(candidate([1, 2, 3, 5, 4, 7, 9, 6]),4);\n  assert.deepEqual(candidate([1, 2, 3, 4, 3, 2, 2]),1);\n  assert.deepEqual(candidate([1, 4, 2]),1);\n  assert.deepEqual(candidate([1, 4, 4, 2]),1);\n  assert.deepEqual(candidate([1, 2, 3, 2, 1]),0);\n  assert.deepEqual(candidate([3, 1, 1, 3]),0);\n  assert.deepEqual(candidate([1]),0);\n  assert.deepEqual(candidate([0, 1]),1);\n}\n\ntest();"},{"task_id":"HumanEval_74","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler \/\/Hvis de to arrays har samme antal tegn, returneres den første array.\/\/Det samlede antal tegn i alle strenge i matrixen er mindre end i den anden matrix.\/\/Skriv en funktion, der accepterer to strenge og returnerer den strenge, der har \/\/ >>> total_match([], [])\n\/\/ []\n\/\/ >>> total_match([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n\/\/ [\"hI\", \"Hi\"]\n\/\/ >>> total_match([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n\/\/ [\"hi\", \"admin\"]\n\/\/ >>> total_match([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n\/\/ [\"hI\", \"hi\", \"hi\"]\n\/\/ >>> total_match([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n\/\/ [\"4\"]\nfunction total_match(lst1: string[], lst2: string[]): string[] {\n","canonical_solution":"function total_match(lst1: string[], lst2: string[]): string[] {\n    const getTotalChars = (arr: string[]): number => {\n        return arr.reduce((acc, str) => acc + str.length, 0);\n    };\n\n    const totalChars1 = getTotalChars(lst1);\n    const totalChars2 = getTotalChars(lst2);\n\n    if (totalChars1 < totalChars2) {\n        return lst1;\n    } else if (totalChars2 < totalChars1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = total_match;\n  assert.deepEqual(candidate([], []),[]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hi\", \"hi\"]),[\"hi\", \"hi\"]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]),[\"hi\", \"admin\"]);\n  assert.deepEqual(candidate([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]),[\"4\"]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hI\", \"Hi\"]),[\"hI\", \"Hi\"]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]),[\"hI\", \"hi\", \"hi\"]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]),[\"hi\", \"admin\"]);\n  assert.deepEqual(candidate([], [\"this\"]),[]);\n  assert.deepEqual(candidate([\"this\"], []),[]);\n}\n\ntest();"},{"task_id":"HumanEval_75","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Vi ved, at a er mindre end 100.\/\/og falske i øvrigt.\/\/Skriv en funktion, der returnerer sandt, hvis det givne tal er en gang af 3 primtal.\/\/ >>> is_multiply_prime(30)\n\/\/ true\n\/\/ 30 = 2 * 3 * 5\nfunction is_multiply_prime(a: number): boolean {\n","canonical_solution":"function is_multiply_prime(a: number): boolean {\n    \/\/ Helper function to check if a number is prime\n    function isPrime(n: number): boolean {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n        if (n % 2 === 0 || n % 3 === 0) return false;\n        for (let i = 5; i * i <= n; i += 6) {\n            if (n % i === 0 || n % (i + 2) === 0) return false;\n        }\n        return true;\n    }\n\n    \/\/ Generate a list of primes less than 100\n    const primes: number[] = [];\n    for (let i = 2; i < 100; i++) {\n        if (isPrime(i)) {\n            primes.push(i);\n        }\n    }\n\n    \/\/ Check if a can be expressed as a product of 3 distinct primes\n    const primeCount = primes.length;\n    for (let i = 0; i < primeCount - 2; i++) {\n        for (let j = i + 1; j < primeCount - 1; j++) {\n            for (let k = j + 1; k < primeCount; k++) {\n                if (primes[i] * primes[j] * primes[k] === a) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_multiply_prime;\n  assert.deepEqual(candidate(5),false);\n  assert.deepEqual(candidate(30),true);\n  assert.deepEqual(candidate(8),true);\n  assert.deepEqual(candidate(10),false);\n  assert.deepEqual(candidate(125),true);\n  assert.deepEqual(candidate(105),true);\n  assert.deepEqual(candidate(126),false);\n  assert.deepEqual(candidate(729),false);\n  assert.deepEqual(candidate(891),false);\n  assert.deepEqual(candidate(1001),true);\n}\n\ntest();"},{"task_id":"HumanEval_76","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/x er en simpel potens af n, hvis n**int=x \/\/i andre tilfælde.\/\/Det er din opgave at skrive en funktion, der returnerer true, hvis et tal x er et simpelt \/\/ >>> is_simple_power(1, 4)\n\/\/ true\n\/\/ >>> is_simple_power(2, 2)\n\/\/ true\n\/\/ >>> is_simple_power(8, 2)\n\/\/ true\n\/\/ >>> is_simple_power(3, 2)\n\/\/ false\n\/\/ >>> is_simple_power(3, 1)\n\/\/ false\n\/\/ >>> is_simple_power(5, 3)\n\/\/ false\nfunction is_simple_power(x: number, n: number): boolean {\n","canonical_solution":"function is_simple_power(x: number, n: number): boolean {\n    if (x < 1 || n < 1) return false;\n    if (x === 1) return true; \/\/ n^0 is 1 for any n\n\n    let power = 1;\n    while (power < x) {\n        power *= n;\n    }\n    \n    return power === x;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_simple_power;\n  assert.deepEqual(candidate(16, 2),true);\n  assert.deepEqual(candidate(143214, 16),false);\n  assert.deepEqual(candidate(4, 2),true);\n  assert.deepEqual(candidate(9, 3),true);\n  assert.deepEqual(candidate(16, 4),true);\n  assert.deepEqual(candidate(24, 2),false);\n  assert.deepEqual(candidate(128, 4),false);\n  assert.deepEqual(candidate(12, 6),false);\n  assert.deepEqual(candidate(1, 1),true);\n  assert.deepEqual(candidate(1, 12),true);\n}\n\ntest();"},{"task_id":"HumanEval_77","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Bemærk: Du kan antage, at indlyden altid er gyldig. \/\/Hvis dette tal er en kubus af et helt tal.\/\/Skriv en funktion, der tager et heltal a og returnerer true.\/\/ >>> iscube(1)\n\/\/ true\n\/\/ >>> iscube(2)\n\/\/ false\n\/\/ >>> iscube(-1)\n\/\/ true\n\/\/ >>> iscube(64)\n\/\/ true\n\/\/ >>> iscube(0)\n\/\/ true\n\/\/ >>> iscube(180)\n\/\/ false\nfunction iscube(a: number): boolean {\n","canonical_solution":"function iscube(a: number): boolean {\n    \/\/ Calculate the cube root of the absolute value of a\n    const cubeRoot = Math.cbrt(Math.abs(a));\n    \/\/ Check if the cube root is an integer\n    return cubeRoot === Math.round(cubeRoot);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = iscube;\n  assert.deepEqual(candidate(1),true);\n  assert.deepEqual(candidate(2),false);\n  assert.deepEqual(candidate(-1),true);\n  assert.deepEqual(candidate(64),true);\n  assert.deepEqual(candidate(180),false);\n  assert.deepEqual(candidate(1000),true);\n  assert.deepEqual(candidate(0),true);\n  assert.deepEqual(candidate(1729),false);\n}\n\ntest();"},{"task_id":"HumanEval_78","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/og symbolerne A, B, C, D, E, F er altid store bogstaver. \/\/Bemærk: du kan antage, at indgangen altid er korrekt eller tom streng, \/\/B (= decimal 11), D (= decimal 13). \/\/Vi skal finde et af de følgende tal: 2, 3, 5, 7, \/\/Primtal er 2, 3, 5, 7, 11, 13, 17,...\/\/De sekstendedelte cifre er 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. \/\/større end 1, der ikke er et produkt af to mindre naturlige tal).\/\/Primmere tal er et naturligt tal.\/\/et hexadecimaltal som en streng og tæller antallet af hexadecimaler \/\/Du har fået til opgave at skrive en funktion, der modtager \/\/ >>> hex_key(\"AB\")\n\/\/ 1\n\/\/ >>> hex_key(\"1077E\")\n\/\/ 2\n\/\/ >>> hex_key(\"ABED1A33\")\n\/\/ 4\n\/\/ >>> hex_key(\"123456789ABCDEF0\")\n\/\/ 6\n\/\/ >>> hex_key(\"2020\")\n\/\/ 2\nfunction hex_key(num: string): number {\n","canonical_solution":"function hex_key(num: string): number {\n    const primeHexDigits = new Set(['2', '3', '5', '7', 'B', 'D']);\n    let count = 0;\n\n    for (let digit of num) {\n        if (primeHexDigits.has(digit)) {\n            count++;\n        }\n    }\n\n    return count;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = hex_key;\n  assert.deepEqual(candidate(\"AB\"),1);\n  assert.deepEqual(candidate(\"1077E\"),2);\n  assert.deepEqual(candidate(\"ABED1A33\"),4);\n  assert.deepEqual(candidate(\"2020\"),2);\n  assert.deepEqual(candidate(\"123456789ABCDEF0\"),6);\n  assert.deepEqual(candidate(\"112233445566778899AABBCCDDEEFF00\"),12);\n}\n\ntest();"},{"task_id":"HumanEval_79","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/De ekstra tegn er der for at hjælpe med formatet.\/\/Der vil være et ekstra par tegn 'db' i begyndelsen og slutningen af strengen. \/\/Hvert tegn i strengen vil være \"0\" eller \"1\".\/\/Funktionen skal returnere en streng, hvor hvert tegn repræsenterer en binær \/\/Du får et tal i decimalform, og din opgave er at konvertere det til \/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunction decimal_to_binary(decimal: number): string {\n","canonical_solution":"function decimal_to_binary(decimal: number): string {\n    const binaryString = decimal.toString(2);\n    return `db${binaryString}db`;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = decimal_to_binary;\n  assert.deepEqual(candidate(0),\"db0db\");\n  assert.deepEqual(candidate(32),\"db100000db\");\n  assert.deepEqual(candidate(103),\"db1100111db\");\n  assert.deepEqual(candidate(15),\"db1111db\");\n}\n\ntest();"},{"task_id":"HumanEval_80","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/En streng er hapt, hvis dens længde er mindst 3 og hver 3 på hinanden følgende bogstaver er forskellige.\/\/Din opgave er at kontrollere, om strengen er hapts eller ej.\/\/Du får en streng s.\/\/ >>> is_happy(\"a\")\n\/\/ false\n\/\/ >>> is_happy(\"aa\")\n\/\/ false\n\/\/ >>> is_happy(\"abcd\")\n\/\/ true\n\/\/ >>> is_happy(\"aabb\")\n\/\/ false\n\/\/ >>> is_happy(\"adb\")\n\/\/ true\n\/\/ >>> is_happy(\"xyy\")\n\/\/ false\nfunction is_happy(s: string): boolean {\n","canonical_solution":"function is_happy(s: string): boolean {\n    if (s.length < 3) return false;\n\n    for (let i = 0; i <= s.length - 3; i++) {\n        const set = new Set(s.substring(i, i + 3));\n        if (set.size !== 3) {\n            return false;\n        }\n    }\n    \n    return true;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_happy;\n  assert.deepEqual(candidate(\"a\"),false);\n  assert.deepEqual(candidate(\"aa\"),false);\n  assert.deepEqual(candidate(\"abcd\"),true);\n  assert.deepEqual(candidate(\"aabb\"),false);\n  assert.deepEqual(candidate(\"adb\"),true);\n  assert.deepEqual(candidate(\"xyy\"),false);\n  assert.deepEqual(candidate(\"iopaxpoi\"),true);\n  assert.deepEqual(candidate(\"iopaxioi\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_81","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/0,0 E \/\/> 0, 0 D- \/\/> 0,7 D \/\/> 1,0 D+ \/\/> 1,3 C- \/\/> 1,7 C \/\/> 2,0 C+ \/\/> 2,3 B- \/\/> 2,7 B \/\/> 3,0 B+ \/\/> 3.3 A- \/\/> 3,7 A \/\/4,0 A+ \/\/GPA.\/\/en funktion, der kan udgive en række bogstaveklasser ved hjælp af følgende tabel: \/\/Hun har givet dig en række GPA'er for nogle elever, og du skal skrive.\/\/Problemet er, at hun har mistet koden, hun brugte til at give karakterer.\/\/Læreren har udviklet sin egen algoritme til karakterisering.\/\/Det er sidste uge af semestre og læreren skal give karaktererne.\/\/ >>> grade_equation([4.0, 3, 1.7, 2, 3.5])\n\/\/ [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nfunction numerical_letter_grade(grades: number[]): string[] {\n","canonical_solution":"function numerical_letter_grade(grades: number[]): string[] {\n    return grades.map(gpa => {\n        if (gpa === 4.0) return \"A+\";\n        if (gpa > 3.7) return \"A\";\n        if (gpa > 3.3) return \"A-\";\n        if (gpa > 3.0) return \"B+\";\n        if (gpa > 2.7) return \"B\";\n        if (gpa > 2.3) return \"B-\";\n        if (gpa > 2.0) return \"C+\";\n        if (gpa > 1.7) return \"C\";\n        if (gpa > 1.3) return \"C-\";\n        if (gpa > 1.0) return \"D+\";\n        if (gpa > 0.7) return \"D\";\n        if (gpa > 0.0) return \"D-\";\n        return \"E\";\n    });\n}\n\n\/\/ Example usage:\n\/\/ console.log(numerical_letter_grade([4.0, 3, 1.7, 2, 3.5])); \/\/ [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = numerical_letter_grade;\n  assert.deepEqual(candidate([4.0, 3, 1.7, 2, 3.5]),[\"A+\", \"B\", \"C-\", \"C\", \"A-\"]);\n  assert.deepEqual(candidate([1.2]),[\"D+\"]);\n  assert.deepEqual(candidate([0.5]),[\"D-\"]);\n  assert.deepEqual(candidate([0.0]),[\"E\"]);\n  assert.deepEqual(candidate([1.0, 0.3, 1.5, 2.8, 3.3]),[\"D\", \"D-\", \"C-\", \"B\", \"B+\"]);\n  assert.deepEqual(candidate([0.0, 0.7]),[\"E\", \"D-\"]);\n}\n\ntest();"},{"task_id":"HumanEval_82","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler \/\/hvis længden er et primtal eller andet falsk \/\/Skriv en funktion, der tager en streng og returnerer true, hvis strengen \/\/ >>> prime_length(\"Hello\")\n\/\/ true\n\/\/ >>> prime_length(\"abcdcba\")\n\/\/ true\n\/\/ >>> prime_length(\"kittens\")\n\/\/ true\n\/\/ >>> prime_length(\"orange\")\n\/\/ false\nfunction prime_length(string: string): boolean {\n","canonical_solution":"function prime_length(string: string): boolean {\n    const length = string.length;\n\n    if (length < 2) return false;\n\n    for (let i = 2; i * i <= length; i++) {\n        if (length % i === 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = prime_length;\n  assert.deepEqual(candidate(\"Hello\"),true);\n  assert.deepEqual(candidate(\"abcdcba\"),true);\n  assert.deepEqual(candidate(\"kittens\"),true);\n  assert.deepEqual(candidate(\"orange\"),false);\n  assert.deepEqual(candidate(\"wow\"),true);\n  assert.deepEqual(candidate(\"world\"),true);\n  assert.deepEqual(candidate(\"MadaM\"),true);\n  assert.deepEqual(candidate(\"Wow\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"HI\"),true);\n  assert.deepEqual(candidate(\"go\"),true);\n  assert.deepEqual(candidate(\"gogo\"),false);\n  assert.deepEqual(candidate(\"aaaaaaaaaaaaaaa\"),false);\n  assert.deepEqual(candidate(\"Madam\"),true);\n  assert.deepEqual(candidate(\"M\"),false);\n  assert.deepEqual(candidate(\"0\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_83","nl":"dan_Latn","pl":"ts","prompt":"\/\/positive heltal, der begynder eller slutter med 1.\/\/Givet et positivt heltal n, returnerer antallet af n-cifrede tal function starts_one_ends(n: number): number {\n","canonical_solution":"function starts_one_ends(n: number): number {\n    if (n === 1) {\n        return 1; \/\/ The number '1' is the only 1-digit number starting or ending with '1'\n    }\n\n    const totalNumbers = Math.pow(10, n - 1); \/\/ Total n-digit numbers starting with any digit from 1 to 9\n    const startingWithOne = Math.pow(10, n - 1); \/\/ The n-digit numbers starting with '1'\n    const endingWithOne = Math.pow(10, n - 1); \/\/ The n-digit numbers ending with '1'\n    const startingAndEndingWithOne = Math.pow(10, n - 2); \/\/ The n-digit numbers starting and ending with '1' \n\n    \/\/ To find numbers that start or end with 1, add those starting with 1 \n    \/\/ and those ending with 1, then subtract the overlap (those both starting and ending with 1).\n    return startingWithOne + endingWithOne - startingAndEndingWithOne;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = starts_one_ends;\n  assert.deepEqual(candidate(1),1);\n  assert.deepEqual(candidate(2),18);\n  assert.deepEqual(candidate(3),180);\n  assert.deepEqual(candidate(4),1800);\n  assert.deepEqual(candidate(5),18000);\n}\n\ntest();"},{"task_id":"HumanEval_84","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel \/\/Hvis der er givet et positivt heltal N, returneres summen af dets cifre i binær form. \/\/ >>> solve(1000)\n\/\/ \"1\"\n\/\/ >>> solve(150)\n\/\/ \"110\"\n\/\/ >>> solve(147)\n\/\/ \"1100\"\n\/\/ Variables:\n\/\/ @N integer\n\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/ Output:\n\/\/ a string of binary number\nfunction solve(N: number): string {\n","canonical_solution":"function solve(N: number): string {\n    let sumOfDigits = 0;\n    while (N > 0) {\n        sumOfDigits += N % 10;\n        N = Math.floor(N \/ 10);\n    }\n    return sumOfDigits.toString(2);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = solve;\n  assert.deepEqual(candidate(1000),\"1\");\n  assert.deepEqual(candidate(150),\"110\");\n  assert.deepEqual(candidate(147),\"1100\");\n  assert.deepEqual(candidate(333),\"1001\");\n  assert.deepEqual(candidate(963),\"10010\");\n}\n\ntest();"},{"task_id":"HumanEval_85","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Når vi har en ikke-tom matrix af heltal, lægger vi først de lige elementer, der er på ulige indekser.\/\/ >>> add([4, 2, 6, 7])\n\/\/ 2\nfunction add(lst: number[]): number {\n","canonical_solution":"function add(lst: number[]): number {\n    return lst.reduce((sum, num, index) => {\n        if (index % 2 === 1 && num % 2 === 0) {\n            return sum + num;\n        }\n        return sum;\n    }, 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = add;\n  assert.deepEqual(candidate([4, 88]),88);\n  assert.deepEqual(candidate([4, 5, 6, 7, 2, 122]),122);\n  assert.deepEqual(candidate([4, 0, 6, 7]),0);\n  assert.deepEqual(candidate([4, 4, 6, 8]),12);\n}\n\ntest();"},{"task_id":"HumanEval_86","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/Bemærk: Du bør holde ordren og de tomme pladser i sætningen. \/\/opstigende rækkefølge baseret på ascii-værdien.\/\/er erstattet af et nyt ord, hvor alle tegnene i \/\/Ordnet version af streng, er en streng, hvor alle ord (adskilt med mellemrum) \/\/Skriv en funktion, der tager en streng og returnerer en ordnet version af den.\/\/ >>> anti_shuffle(\"Hi\")\n\/\/ \"Hi\"\n\/\/ >>> anti_shuffle(\"hello\")\n\/\/ \"ehllo\"\n\/\/ >>> anti_shuffle(\"Hello World!!!\")\n\/\/ \"Hello !!!Wdlor\"\nfunction anti_shuffle(s: string): string {\n","canonical_solution":"function anti_shuffle(s: string): string {\n  return s.split(' ').map(word =>\n    word.split('').sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0)).join('')\n  ).join(' ');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = anti_shuffle;\n  assert.deepEqual(candidate(\"Hi\"),\"Hi\");\n  assert.deepEqual(candidate(\"hello\"),\"ehllo\");\n  assert.deepEqual(candidate(\"number\"),\"bemnru\");\n  assert.deepEqual(candidate(\"abcd\"),\"abcd\");\n  assert.deepEqual(candidate(\"Hello World!!!\"),\"Hello !!!Wdlor\");\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"Hi. My name is Mister Robot. How are you?\"),\".Hi My aemn is Meirst .Rboot How aer ?ouy\");\n}\n\ntest();"},{"task_id":"HumanEval_87","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Ordne også koordinaterne i rækken efter kolonnerne i faldende rækkefølge.\/\/Ordne koordinaterne i første række i stigende rækkefølge.\/\/Hver række er en koordinat - (række, kolonner), der starter med 0.\/\/og returnere array af arrays, [(x1, y1), (x2, y2) ...] sådan at \/\/Givet lst, og heltal x, finde heltal x i matrixen, \/\/Hver række kan indeholde et andet antal kolonner.\/\/Det er ligesom matrix, men i modsætning til matricer, \/\/Du får en 2D-data, som en indlejret arrays, \/\/ >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n\/\/ [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\/\/ >>> get_row([], 1)\n\/\/ []\n\/\/ >>> get_row([[], [1], [1, 2, 3]], 3)\n\/\/ [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n","canonical_solution":"function get_row(lst: number[][], x: number): [number, number][] {\n    const coordinates: [number, number][] = [];\n\n    \/\/ Traverse the data matrix\n    lst.forEach((row, rowIndex) => {\n        row.forEach((value, colIndex) => {\n            if (value === x) {\n                coordinates.push([rowIndex, colIndex]);\n            }\n        });\n    });\n\n    \/\/ Sort the coordinates\n    coordinates.sort(([row1, col1], [row2, col2]) => {\n        if (row1 === row2) {\n            \/\/ Sort by columns in descending order\n            return col2 - col1;\n        }\n        \/\/ Sort by rows in ascending order\n        return row1 - row2;\n    });\n\n    return coordinates;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();"},{"task_id":"HumanEval_88","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/* ændrer ikke den givne matrix. \/\/Bemærk: \/\/eller sortere det i faldende rækkefølge, hvis summen ((første indeksværdi, sidste indeksværdi) er lige. \/\/Vi sorterer den givne matrix i stigende rækkefølge, hvis summen af de to værdier er ulige.\/\/Når vi har en række af ikke-negative heltal, returnerer vi en cots af den givne række efter sortering, \/\/ >>> sort_array([])\n\/\/ []\n\/\/ >>> sort_array([5])\n\/\/ [5]\n\/\/ >>> sort_array([2, 4, 3, 0, 1, 5])\n\/\/ [0, 1, 2, 3, 4, 5]\n\/\/ >>> sort_array([2, 4, 3, 0, 1, 5, 6])\n\/\/ [6, 5, 4, 3, 2, 1, 0]\nfunction sort_array(array: number[]): number[] {\n","canonical_solution":"function sort_array(array: number[]): number[] {\n    if (array.length === 0) {\n        return [];\n    }\n\n    const firstValue = array[0];\n    const lastValue = array[array.length - 1];\n    const sum = firstValue + lastValue;\n\n    const sortedArray = [...array].sort((a, b) => a - b);\n\n    if (sum % 2 === 0) {\n        return sortedArray.reverse();\n    } else {\n        return sortedArray;\n    }\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_array;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5]),[5]);\n  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5]),[0, 1, 2, 3, 4, 5]);\n  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5, 6]),[6, 5, 4, 3, 2, 1, 0]);\n  assert.deepEqual(candidate([2, 1]),[1, 2]);\n  assert.deepEqual(candidate([15, 42, 87, 32, 11, 0]),[0, 11, 15, 32, 42, 87]);\n  assert.deepEqual(candidate([21, 14, 23, 11]),[23, 21, 14, 11]);\n}\n\ntest();"},{"task_id":"HumanEval_89","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/skifte ned med to gange til to steder.\/\/Alfabetet skal drejes således, at bogstaverne \/\/returnerer en streng krypteret med alfabetet, der roteres. \/\/Opret en funktion, der krypterer en streng som argument og \/\/ >>> encrypt(\"hi\")\n\/\/ \"lm\"\n\/\/ >>> encrypt(\"asdfghjkl\")\n\/\/ \"ewhjklnop\"\n\/\/ >>> encrypt(\"gf\")\n\/\/ \"kj\"\n\/\/ >>> encrypt(\"et\")\n\/\/ \"ix\"\nfunction encrypt(s: string): string {\n","canonical_solution":"function encrypt(s: string): string {\n    const shift = 2 * 2; \/\/ Shift by 4 places\n    const alphabetSize = 26;\n    \n    return s.split('').map(char => {\n        const charCode = char.charCodeAt(0);\n        \n        \/\/ Check if the character is a lowercase letter\n        if (charCode >= 97 && charCode <= 122) {\n            let newCharCode = charCode + shift;\n            \n            \/\/ Wrap around if it goes past 'z'\n            if (newCharCode > 122) {\n                newCharCode = (newCharCode - 97) % alphabetSize + 97;\n            }\n            \n            return String.fromCharCode(newCharCode);\n        }\n\n        \/\/ Return the character unchanged if it's not a lowercase letter\n        return char;\n    }).join('');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = encrypt;\n  assert.deepEqual(candidate(\"hi\"),\"lm\");\n  assert.deepEqual(candidate(\"asdfghjkl\"),\"ewhjklnop\");\n  assert.deepEqual(candidate(\"gf\"),\"kj\");\n  assert.deepEqual(candidate(\"et\"),\"ix\");\n  assert.deepEqual(candidate(\"faewfawefaewg\"),\"jeiajeaijeiak\");\n  assert.deepEqual(candidate(\"hellomyfriend\"),\"lippsqcjvmirh\");\n  assert.deepEqual(candidate(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"),\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n  assert.deepEqual(candidate(\"a\"),\"e\");\n}\n\ntest();"},{"task_id":"HumanEval_90","nl":"dan_Latn","pl":"ts","prompt":"\/\/Returnerer undefined, hvis der ikke er noget sådant element. \/\/Skriv en funktion next_smallest (), der returnerer det næstmindste element i arrayet. \/\/Vi har en række af hele tal.\/\/ >>> next_smallest([1, 2, 3, 4, 5])\n\/\/ 2\n\/\/ >>> next_smallest([5, 1, 4, 3, 2])\n\/\/ 2\n\/\/ >>> next_smallest([])\n\/\/ undefined\n\/\/ >>> next_smallest([1, 1])\n\/\/ undefined\nfunction next_smallest(lst: number[]): number | undefined {\n","canonical_solution":"function next_smallest(lst: number[]): number | undefined {\n    if (lst.length < 2) {\n        return undefined;\n    }\n    \n    let first: number | undefined = undefined;\n    let second: number | undefined = undefined;\n    \n    for (let num of lst) {\n        if (first === undefined || num < first) {\n            second = first;\n            first = num;\n        } else if (num > first && (second === undefined || num < second)) {\n            second = num;\n        }\n    }\n\n    return second;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = next_smallest;\n  assert.deepEqual(candidate([1, 2, 3, 4, 5]),2);\n  assert.deepEqual(candidate([5, 1, 4, 3, 2]),2);\n  assert.deepEqual(candidate([]),undefined);\n  assert.deepEqual(candidate([1, 1]),undefined);\n  assert.deepEqual(candidate([1, 1, 1, 1, 0]),1);\n  assert.deepEqual(candidate([1, 1]),undefined);\n  assert.deepEqual(candidate([-35, 34, 12, -45]),-35);\n}\n\ntest();"},{"task_id":"HumanEval_91","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/Sætningerne afgrænses af \"\", \"?\" eller \"!\" \/\/En keder er en sætning, der begynder med ordet \"jeg\".\/\/Du får en række ord, og din opgave er at tælle antallet.\/\/ >>> is_bored(\"Hello world\")\n\/\/ 0\n\/\/ >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n\/\/ 1\nfunction is_bored(S: string): number {\n","canonical_solution":"function is_bored(S: string): number {\n    \/\/ Split the string into sentences using '.', '?' or '!' as delimiters\n    const sentences = S.split(\/[.!?]\/);\n\n    \/\/ Filter sentences that start with \"I\" and count them\n    const boredomCount = sentences.filter(sentence => sentence.trim().startsWith('I')).length;\n\n    return boredomCount;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_bored;\n  assert.deepEqual(candidate(\"Hello world\"),0);\n  assert.deepEqual(candidate(\"Is the sky blue?\"),0);\n  assert.deepEqual(candidate(\"I love It !\"),1);\n  assert.deepEqual(candidate(\"bIt\"),0);\n  assert.deepEqual(candidate(\"I feel good today. I will be productive. will kill It\"),2);\n  assert.deepEqual(candidate(\"You and I are going for a walk\"),0);\n}\n\ntest();"},{"task_id":"HumanEval_92","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler \/\/Returnerer falsk i alle andre tilfælde. \/\/Returnerer sandt, hvis et af tallene er lig med summen af de to andre tal, og alle tal er heltal. \/\/Opret en funktion, der tager 3 tal.\/\/ >>> any_int(5, 2, 7)\n\/\/ true\n\/\/ >>> any_int(3, 2, 2)\n\/\/ false\n\/\/ >>> any_int(3, -2, 1)\n\/\/ true\n\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/ false\nfunction any_int(x: number, y: number, z: number): boolean {\n","canonical_solution":"function any_int(x: number, y: number, z: number): boolean {\n    \/\/ Check if all numbers are integers\n    if (!Number.isInteger(x) || !Number.isInteger(y) || !Number.isInteger(z)) {\n        return false;\n    }\n    \/\/ Check if one of the numbers is the sum of the other two\n    if (x === y + z || y === x + z || z === x + y) {\n        return true;\n    }\n    return false;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = any_int;\n  assert.deepEqual(candidate(2, 3, 1),true);\n  assert.deepEqual(candidate(2.5, 2, 3),false);\n  assert.deepEqual(candidate(1.5, 5, 3.5),false);\n  assert.deepEqual(candidate(2, 6, 2),false);\n  assert.deepEqual(candidate(4, 2, 2),true);\n  assert.deepEqual(candidate(2.2, 2.2, 2.2),false);\n  assert.deepEqual(candidate(-4, 6, 2),true);\n  assert.deepEqual(candidate(2, 1, 1),true);\n  assert.deepEqual(candidate(3, 4, 7),true);\n  assert.deepEqual(candidate(3.0, 4, 7),false);\n}\n\ntest();"},{"task_id":"HumanEval_93","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Antag kun bogstaver.\/\/En vokal i det engelske alfabet.\/\/Det er den bogstav, der står to pladser foran den.\/\/Den ændrer alle bogstaver og alle vokaler i \/\/Skriv en funktion, der tager en besked, og koder i en sådan \/\/ >>> encode(\"test\")\n\/\/ \"TGST\"\n\/\/ >>> encode(\"This is a message\")\n\/\/ \"tHKS KS C MGSSCGG\"\nfunction encode(message: string): string {\n","canonical_solution":"function encode(message: string): string {\n    const swapCase = (char: string): string => {\n        if (char === char.toLowerCase()) {\n            return char.toUpperCase();\n        } else {\n            return char.toLowerCase();\n        }\n    };\n\n    const replaceVowel = (char: string): string => {\n        const vowels = 'aeiou';\n        const nextVowels = 'cgkqw';\n        const index = vowels.indexOf(char.toLowerCase());\n        if (index !== -1) {\n            return char === char.toLowerCase() \n                ? nextVowels[index] \n                : nextVowels[index].toUpperCase();\n        }\n        return char;\n    };\n\n    return message\n        .split('')\n        .map(char => swapCase(replaceVowel(char)))\n        .join('');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = encode;\n  assert.deepEqual(candidate(\"TEST\"),\"tgst\");\n  assert.deepEqual(candidate(\"Mudasir\"),\"mWDCSKR\");\n  assert.deepEqual(candidate(\"YES\"),\"ygs\");\n  assert.deepEqual(candidate(\"This is a message\"),\"tHKS KS C MGSSCGG\");\n  assert.deepEqual(candidate(\"I DoNt KnOw WhAt tO WrItE\"),\"k dQnT kNqW wHcT Tq wRkTg\");\n}\n\ntest();"},{"task_id":"HumanEval_94","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Vi skal finde den største primværdi og returnere summen af dets cifre.\/\/Vi har en række af hele tal.\/\/ >>> skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/ 10\n\/\/ >>> skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/ 25\n\/\/ >>> skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/ 13\n\/\/ >>> skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/ 11\n\/\/ >>> skjkasdkd([0, 81, 12, 3, 1, 21])\n\/\/ 3\n\/\/ >>> skjkasdkd([0, 8, 1, 2, 1, 7])\n\/\/ 7\nfunction skjkasdkd(lst: number[]): number {\n","canonical_solution":"function isPrime(n: number): boolean {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 === 0 || n % 3 === 0) return false;\n    for (let i = 5; i * i <= n; i += 6) {\n        if (n % i === 0 || n % (i + 2) === 0) return false;\n    }\n    return true;\n}\n\nfunction sumOfDigits(n: number): number {\n    let sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n = Math.floor(n \/ 10);\n    }\n    return sum;\n}\n\nfunction skjkasdkd(lst: number[]): number {\n    let maxPrime = -1;\n\n    for (const num of lst) {\n        if (isPrime(num) && num > maxPrime) {\n            maxPrime = num;\n        }\n    }\n\n    return maxPrime === -1 ? 0 : sumOfDigits(maxPrime);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = skjkasdkd;\n  assert.deepEqual(candidate([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]),10);\n  assert.deepEqual(candidate([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]),25);\n  assert.deepEqual(candidate([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]),13);\n  assert.deepEqual(candidate([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]),11);\n  assert.deepEqual(candidate([0, 81, 12, 3, 1, 21]),3);\n  assert.deepEqual(candidate([0, 8, 1, 2, 1, 7]),7);\n  assert.deepEqual(candidate([8191]),19);\n  assert.deepEqual(candidate([8191, 123456, 127, 7]),19);\n  assert.deepEqual(candidate([127, 97, 8192]),10);\n}\n\ntest();"},{"task_id":"HumanEval_95","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Funktionen skal returnere falsk, hvis det givne objekt er tomt. \/\/case eller alle nøgler er strenge i store bogstaver, ellers returnerer false. \/\/Hvis der er givet et objekt, returnerer true, hvis alle nøgler er strenge i lavere \/\/ >>> check_dict_case({\"a\": \"apple\", \"b\": \"banana\"})\n\/\/ true\n\/\/ >>> check_dict_case({\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n\/\/ false\n\/\/ >>> check_dict_case({\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n\/\/ false\n\/\/ >>> check_dict_case({\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n\/\/ false\n\/\/ >>> check_dict_case({\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n\/\/ true\nfunction check_dict_case(dict: {[key: string]: string}): boolean {\n","canonical_solution":"function check_dict_case(dict: { [key: string]: string }): boolean {\n    const keys = Object.keys(dict);\n    if (keys.length === 0) return false;\n\n    const allLowerCase = keys.every(key => key === key.toLowerCase());\n    const allUpperCase = keys.every(key => key === key.toUpperCase());\n\n    return allLowerCase || allUpperCase;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = check_dict_case;\n  assert.deepEqual(candidate({\"p\": \"pineapple\", \"b\": \"banana\"}),true);\n  assert.deepEqual(candidate({\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}),false);\n  assert.deepEqual(candidate({\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}),false);\n  assert.deepEqual(candidate({\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}),false);\n  assert.deepEqual(candidate({\"STATE\": \"NC\", \"ZIP\": \"12345\"}),true);\n  assert.deepEqual(candidate({\"fruit\": \"Orange\", \"taste\": \"Sweet\"}),true);\n  assert.deepEqual(candidate({}),false);\n}\n\ntest();"},{"task_id":"HumanEval_96","nl":"dan_Latn","pl":"ts","prompt":"\/\/for eksempel: \/\/Præmier, der er mindre end n.\/\/Implementere en funktion, der tager et ikke-negativt heltal og returnerer en matrix af de første n \/\/ >>> count_up_to(5)\n\/\/ [2, 3]\n\/\/ >>> count_up_to(11)\n\/\/ [2, 3, 5, 7]\n\/\/ >>> count_up_to(0)\n\/\/ []\n\/\/ >>> count_up_to(20)\n\/\/ [2, 3, 5, 7, 11, 13, 17, 19]\n\/\/ >>> count_up_to(1)\n\/\/ []\n\/\/ >>> count_up_to(18)\n\/\/ [2, 3, 5, 7, 11, 13, 17]\nfunction count_up_to(n: number): number[] {\n","canonical_solution":"function count_up_to(n: number): number[] {\n    function isPrime(num: number): boolean {\n        if (num < 2) return false;\n        for (let i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i === 0) return false;\n        }\n        return true;\n    }\n\n    const primes: number[] = [];\n    for (let i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            primes.push(i);\n        }\n    }\n\n    return primes;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = count_up_to;\n  assert.deepEqual(candidate(5),[2, 3]);\n  assert.deepEqual(candidate(6),[2, 3, 5]);\n  assert.deepEqual(candidate(7),[2, 3, 5]);\n  assert.deepEqual(candidate(10),[2, 3, 5, 7]);\n  assert.deepEqual(candidate(0),[]);\n  assert.deepEqual(candidate(22),[2, 3, 5, 7, 11, 13, 17, 19]);\n  assert.deepEqual(candidate(1),[]);\n  assert.deepEqual(candidate(18),[2, 3, 5, 7, 11, 13, 17]);\n  assert.deepEqual(candidate(47),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);\n  assert.deepEqual(candidate(101),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n}\n\ntest();"},{"task_id":"HumanEval_97","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Antag, at indgangen altid er gyldig.\/\/Produktet af deres enhedstallinger. \/\/Udfyld funktionen, der tager to heltal og returnerer \/\/ >>> multiply(148, 412)\n\/\/ 16\n\/\/ >>> multiply(19, 28)\n\/\/ 72\n\/\/ >>> multiply(2020, 1851)\n\/\/ 0\n\/\/ >>> multiply(14, -15)\n\/\/ 20\nfunction multiply(a: number, b: number): number {\n","canonical_solution":"function multiply(a: number, b: number): number {\n    const unitDigitA = Math.abs(a) % 10;\n    const unitDigitB = Math.abs(b) % 10;\n    return unitDigitA * unitDigitB;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = multiply;\n  assert.deepEqual(candidate(148, 412),16);\n  assert.deepEqual(candidate(19, 28),72);\n  assert.deepEqual(candidate(2020, 1851),0);\n  assert.deepEqual(candidate(14, -15),20);\n  assert.deepEqual(candidate(76, 67),42);\n  assert.deepEqual(candidate(17, 27),49);\n  assert.deepEqual(candidate(0, 1),0);\n  assert.deepEqual(candidate(0, 0),0);\n}\n\ntest();"},{"task_id":"HumanEval_98","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/Hvis man har en streng s, tæller man antallet af store vokaler i lige indekser.\/\/ >>> count_upper(\"aBCdEf\")\n\/\/ 1\n\/\/ >>> count_upper(\"abcdefg\")\n\/\/ 0\n\/\/ >>> count_upper(\"dBBE\")\n\/\/ 0\nfunction count_upper(s: string): number {\n","canonical_solution":"function count_upper(s: string): number {\n    const uppercaseVowels = new Set(['A', 'E', 'I', 'O', 'U']);\n    let count = 0;\n    \n    for (let i = 0; i < s.length; i += 2) {\n        if (uppercaseVowels.has(s[i])) {\n            count++;\n        }\n    }\n    \n    return count;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = count_upper;\n  assert.deepEqual(candidate(\"aBCdEf\"),1);\n  assert.deepEqual(candidate(\"abcdefg\"),0);\n  assert.deepEqual(candidate(\"dBBE\"),0);\n  assert.deepEqual(candidate(\"B\"),0);\n  assert.deepEqual(candidate(\"U\"),1);\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"EEEE\"),2);\n}\n\ntest();"},{"task_id":"HumanEval_99","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler \/\/Vi kan også runde det væk fra nul.\/\/Hvis tallet er lige langt væk fra det, returnerer det det nærmeste heltal.\/\/Oprette en funktion, der tager en værdi (string) der repræsenterer et tal \/\/ >>> closest_integer(\"10\")\n\/\/ 10\n\/\/ >>> closest_integer(\"15.3\")\n\/\/ 15\n\/\/ Note:\n\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/ from two integers, the one you should return is the one that is the\n\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunction closest_integer(value: string): number {\n","canonical_solution":"function closest_integer(value: string): number {\n  const num = parseFloat(value);\n  if (num > 0) {\n    return Math.floor(num + 0.5);\n  } else {\n    return Math.ceil(num - 0.5);\n  }\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = closest_integer;\n  assert.deepEqual(candidate(\"10\"),10);\n  assert.deepEqual(candidate(\"14.5\"),15);\n  assert.deepEqual(candidate(\"-15.5\"),-16);\n  assert.deepEqual(candidate(\"15.3\"),15);\n  assert.deepEqual(candidate(\"0\"),0);\n}\n\ntest();"},{"task_id":"HumanEval_100","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/i er antallet af sten i niveauet (i+1). \/\/Returnerer antallet af sten i hvert niveau i en matrix, hvor elementet er index \/\/- det næste lige tal, hvis n er lige. \/\/- det næste ulige tal, hvis n er ulige. \/\/Antallet af sten i det næste niveau er:\/\/Første niveau har n sten.\/\/Hvis vi har et positivt heltal n, skal vi lave en bunke af n niveauer af sten.\/\/ >>> make_a_pile(3)\n\/\/ [3, 5, 7]\nfunction make_a_pile(n: number): number[] {\n","canonical_solution":"function make_a_pile(n: number): number[] {\n    const result: number[] = [];\n    let currentStones = n;\n    for (let i = 0; i < n; i++) {\n        result.push(currentStones);\n        if (currentStones % 2 === 0) {\n            currentStones += 2; \/\/ next even number\n        } else {\n            currentStones += 2; \/\/ next odd number\n        }\n    }\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = make_a_pile;\n  assert.deepEqual(candidate(3),[3, 5, 7]);\n  assert.deepEqual(candidate(4),[4, 6, 8, 10]);\n  assert.deepEqual(candidate(5),[5, 7, 9, 11, 13]);\n  assert.deepEqual(candidate(6),[6, 8, 10, 12, 14, 16]);\n  assert.deepEqual(candidate(8),[8, 10, 12, 14, 16, 18, 20, 22]);\n}\n\ntest();"},{"task_id":"HumanEval_101","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/for at opdele strengen i ord og returnere en række af ordene.\/\/Du får en række ord adskilt af kommaer eller mellemrum.\/\/ >>> words_string(\"Hi, my name is John\")\n\/\/ [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n\/\/ >>> words_string(\"One, two, three, four, five, six\")\n\/\/ [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nfunction words_string(s: string): string[] {\n","canonical_solution":"function words_string(s: string): string[] {\n    return s.split(\/[\\s,]+\/).filter(word => word.length > 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = words_string;\n  assert.deepEqual(candidate(\"Hi, my name is John\"),[\"Hi\", \"my\", \"name\", \"is\", \"John\"]);\n  assert.deepEqual(candidate(\"One, two, three, four, five, six\"),[\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]);\n  assert.deepEqual(candidate(\"Hi, my name\"),[\"Hi\", \"my\", \"name\"]);\n  assert.deepEqual(candidate(\"One,, two, three, four, five, six,\"),[\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]);\n  assert.deepEqual(candidate(\"\"),[]);\n  assert.deepEqual(candidate(\"ahmed     , gamal\"),[\"ahmed\", \"gamal\"]);\n}\n\ntest();"},{"task_id":"HumanEval_102","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/Hvis der ikke er noget tal, så skal funktionen returnere -1.\/\/Det største lige heltal, der ligger i intervallet [x, y] inklusiv.\/\/Denne funktion tager to positive tal x og y og returnerer \/\/ >>> choose_num(12, 15)\n\/\/ 14\n\/\/ >>> choose_num(13, 12)\n\/\/ -1\nfunction choose_num(x: number, y: number): number {\n","canonical_solution":"function choose_num(x: number, y: number): number {\n    \/\/ Ensure x is less than or equal to y for proper range searching\n    if (x > y) {\n        [x, y] = [y, x];\n    }\n    \n    \/\/ Start looking from the upper bound of the range\n    for (let i = y; i >= x; i--) {\n        if (i % 2 === 0) {\n            return i;\n        }\n    }\n    \n    \/\/ If no even number is found in the range\n    return -1;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = choose_num;\n  assert.deepEqual(candidate(12, 15),14);\n  assert.deepEqual(candidate(13, 12),-1);\n  assert.deepEqual(candidate(33, 12354),12354);\n  assert.deepEqual(candidate(5234, 5233),-1);\n  assert.deepEqual(candidate(6, 29),28);\n  assert.deepEqual(candidate(27, 10),-1);\n  assert.deepEqual(candidate(7, 7),-1);\n  assert.deepEqual(candidate(546, 546),546);\n}\n\ntest();"},{"task_id":"HumanEval_103","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Hvis n er større end m, returneres -1.\/\/Rund svaret op til nærmeste heltal og konverter det til binært tal.\/\/gennemsnit af hele tal fra n til m (inklusive n og m).\/\/Du får to positive heltal n og m, og din opgave er at beregne \/\/ >>> rounded_avg(1, 5)\n\/\/ \"0b11\"\n\/\/ >>> rounded_avg(7, 5)\n\/\/ -1\n\/\/ >>> rounded_avg(10, 20)\n\/\/ \"0b1111\"\n\/\/ >>> rounded_avg(20, 33)\n\/\/ \"0b11010\"\nfunction rounded_avg(n: number, m: number): string | number {\n","canonical_solution":"function rounded_avg(n: number, m: number): string | number {\n    if (n > m) {\n        return -1;\n    }\n\n    const count = m - n + 1;\n    let sum = 0;\n    \n    for (let i = n; i <= m; i++) {\n        sum += i;\n    }\n\n    const avg = sum \/ count;\n    const roundedAvg = Math.round(avg);\n    return \"0b\" + roundedAvg.toString(2);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = rounded_avg;\n  assert.deepEqual(candidate(1, 5),\"0b11\");\n  assert.deepEqual(candidate(7, 13),\"0b1010\");\n  assert.deepEqual(candidate(964, 977),\"0b1111001010\");\n  assert.deepEqual(candidate(996, 997),\"0b1111100100\");\n  assert.deepEqual(candidate(560, 851),\"0b1011000010\");\n  assert.deepEqual(candidate(185, 546),\"0b101101110\");\n  assert.deepEqual(candidate(362, 496),\"0b110101101\");\n  assert.deepEqual(candidate(350, 902),\"0b1001110010\");\n  assert.deepEqual(candidate(197, 233),\"0b11010111\");\n  assert.deepEqual(candidate(7, 5),-1);\n  assert.deepEqual(candidate(5, 1),-1);\n  assert.deepEqual(candidate(5, 5),\"0b101\");\n}\n\ntest();"},{"task_id":"HumanEval_104","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/Bemærk: Returnerede matrix skal sorteres i stigende rækkefølge.\/\/Elementer, der ikke har nogen lige cifre.\/\/Når vi har en række af positive heltal x, returnerer vi en sorteret række af alle \/\/ >>> unique_digits([15, 33, 1422, 1])\n\/\/ [1, 15, 33]\n\/\/ >>> unique_digits([152, 323, 1422, 10])\n\/\/ []\nfunction unique_digits(x: number[]): number[] {\n","canonical_solution":"function unique_digits(x: number[]): number[] {\n    \/\/ Helper function to check if a number has any even digit\n    const hasEvenDigit = (num: number): boolean => {\n        while (num > 0) {\n            const digit = num % 10;\n            if (digit % 2 === 0) return true;\n            num = Math.floor(num \/ 10);\n        }\n        return false;\n    };\n\n    \/\/ Filter out numbers without even digits and sort them\n    return x.filter(num => !hasEvenDigit(num)).sort((a, b) => a - b);\n}\n\n\/\/ Example usage:\nconsole.log(unique_digits([15, 33, 1422, 1])); \/\/ [1, 15, 33]\nconsole.log(unique_digits([152, 323, 1422, 10])); \/\/ []","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = unique_digits;\n  assert.deepEqual(candidate([15, 33, 1422, 1]),[1, 15, 33]);\n  assert.deepEqual(candidate([152, 323, 1422, 10]),[]);\n  assert.deepEqual(candidate([12345, 2033, 111, 151]),[111, 151]);\n  assert.deepEqual(candidate([135, 103, 31]),[31, 135]);\n}\n\ntest();"},{"task_id":"HumanEval_105","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/\"En\", \"To\", \"Tre\", \"Fire\", \"Fem\", \"Seks\", \"Syv\", \"Otte\", \"Ni\".\/\/omvendt den resulterende matrix, og derefter erstatte hvert ciffer med det tilsvarende navn fra \/\/I en række af heltal skal vi sortere de heltal, der ligger mellem 1 og 9 inklusiv.\/\/ >>> by_length([2, 1, 1, 4, 5, 8, 2, 3])\n\/\/ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\/\/ If the array is empty, return an empty array:\n\/\/ >>> by_length([])\n\/\/ []\n\/\/ If the array has any strange number ignore it:\n\/\/ >>> by_length([1, -1, 55])\n\/\/ [\"One\"]\nfunction by_length(arr: number[]): string[] {\n","canonical_solution":"function by_length(arr: number[]): string[] {\n    const numberNames: { [key: number]: string } = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    };\n\n    return arr\n        .filter(num => num >= 1 && num <= 9)\n        .sort((a, b) => b - a)\n        .map(num => numberNames[num]);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = by_length;\n  assert.deepEqual(candidate([2, 1, 1, 4, 5, 8, 2, 3]),[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, -1, 55]),[\"One\"]);\n  assert.deepEqual(candidate([1, -1, 3, 2]),[\"Three\", \"Two\", \"One\"]);\n  assert.deepEqual(candidate([9, 4, 8]),[\"Nine\", \"Eight\", \"Four\"]);\n}\n\ntest();"},{"task_id":"HumanEval_106","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Faktorialen af i er gange af tallene fra 1 til i (1 * 2 * ... * i).\/\/i starter fra 1. \/\/eller summen af tal fra 1 til i. \/\/og returnerer en matrix af størrelse n, således at værdien af elementet ved indeks i er faktorielet af i hvis i er lige \/\/Implementer funktionen f, der tager n som parameter, \/\/ >>> f(5)\n\/\/ [1, 2, 6, 24, 15]\nfunction f(n: number): number[] {\n","canonical_solution":"function f(n: number): number[] {\n    const result: number[] = [];\n    for (let i = 1; i <= n; i++) {\n        if (i % 2 === 0) {\n            \/\/ Calculate factorial for even i\n            let factorial = 1;\n            for (let j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result.push(factorial);\n        } else {\n            \/\/ Calculate sum for odd i\n            let sum = 0;\n            for (let j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result.push(sum);\n        }\n    }\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = f;\n  assert.deepEqual(candidate(5),[1, 2, 6, 24, 15]);\n  assert.deepEqual(candidate(7),[1, 2, 6, 24, 15, 720, 28]);\n  assert.deepEqual(candidate(1),[1]);\n  assert.deepEqual(candidate(3),[1, 2, 6]);\n}\n\ntest();"},{"task_id":"HumanEval_107","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel 1: \/\/hele palindromer, der falder inden for området ((1, n), inklusiv. \/\/Givet et positivt heltal n, returnerer vi en matrix, der har antallet af lige og ulige \/\/ >>> even_odd_palindrome(3)\n\/\/ [1, 2]\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/ Example 2:\n\/\/ >>> even_odd_palindrome(12)\n\/\/ [4, 6]\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/ Note:\n\/\/ 1. 1 <= n <= 10^3\n\/\/ 2. returned array has the number of even and odd integer palindromes respectively.\nfunction even_odd_palindrome(n: number): [number, number] {\n","canonical_solution":"function isPalindrome(num: number): boolean {\n    const str = num.toString();\n    return str === str.split('').reverse().join('');\n}\n\nfunction even_odd_palindrome(n: number): [number, number] {\n    let evenCount = 0;\n    let oddCount = 0;\n\n    for (let i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 === 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return [evenCount, oddCount];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = even_odd_palindrome;\n  assert.deepEqual(candidate(123),[8, 13]);\n  assert.deepEqual(candidate(12),[4, 6]);\n  assert.deepEqual(candidate(3),[1, 2]);\n  assert.deepEqual(candidate(63),[6, 8]);\n  assert.deepEqual(candidate(25),[5, 6]);\n  assert.deepEqual(candidate(19),[4, 6]);\n  assert.deepEqual(candidate(9),[4, 5]);\n  assert.deepEqual(candidate(1),[0, 1]);\n}\n\ntest();"},{"task_id":"HumanEval_108","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempelvis har -123 tegnede cifre -1, 2 og 3.\/\/Hvis et tal er negativt, er det første tegnede ciffer negativt: \/\/antallet af elementer, hvis sum af cifre er > 0. \/\/Skriv en funktion count_nums, der tager en række af heltal og returnerer \/\/ >>> count_nums([])\n\/\/ 0\n\/\/ >>> count_nums([-1, 11, -11])\n\/\/ 1\n\/\/ >>> count_nums([1, 1, 2])\n\/\/ 3\nfunction count_nums(arr: number[]): number {\n","canonical_solution":"function count_nums(arr: number[]): number {\n    function sumOfDigits(num: number): number {\n        let sum = 0;\n        let str = num.toString();\n        for (let i = 0; i < str.length; i++) {\n            let digit = parseInt(str[i]);\n            if (i === 0 && str[i] === '-') {\n                digit = -parseInt(str[i+1]);\n                i++;\n            }\n            sum += digit;\n        }\n        return sum;\n    }\n\n    let count = 0;\n    for (const num of arr) {\n        if (sumOfDigits(num) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = count_nums;\n  assert.deepEqual(candidate([]),0);\n  assert.deepEqual(candidate([-1, -2, 0]),0);\n  assert.deepEqual(candidate([1, 1, 2, -2, 3, 4, 5]),6);\n  assert.deepEqual(candidate([1, 6, 9, -6, 0, 1, 5]),5);\n  assert.deepEqual(candidate([1, 100, 98, -7, 1, -1]),4);\n  assert.deepEqual(candidate([12, 23, 34, -45, -56, 0]),5);\n  assert.deepEqual(candidate([0, 1]),1);\n  assert.deepEqual(candidate([1]),1);\n}\n\ntest();"},{"task_id":"HumanEval_109","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/Bemærk: Det givne array har garanteret unikke elementer.\/\/Hvis den givne matrix er tom, returneres true. \/\/så returnerer true eller returnerer false. \/\/Hvis det er muligt at få den sorterede matrix ved at udføre ovenstående operation \/\/startpositionen i matrixen, dvs. 0-indekset. \/\/Det sidste element i matrixen flyttes til \/\/En højre-skiftning betyder, at alle elementer i matricen skiftes med én.\/\/Du har lov til at udføre højre skift operation et hvilket som helst antal gange.\/\/følgende operation på den givne matrix: \/\/Det er muligt at få en matrix sorteret i ikke-faldende rækkefølge ved at udføre \/\/Tal i matrixen vil blive tilfældigt ordnet.\/\/Vi har en matrix 'arr' af N heltal arr[1], arr[2], ..., arr[N].\/\/ >>> move_one_ball([3, 4, 5, 1, 2])\n\/\/ true\n\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/ be achieved for the given array.\n\/\/ >>> move_one_ball([3, 5, 4, 1, 2])\n\/\/ false\n\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/ array by performing any number of right shift operations.\nfunction move_one_ball(arr: number[]): boolean {\n","canonical_solution":"function move_one_ball(arr: number[]): boolean {\n    if (arr.length === 0) return true;\n\n    let countDecreases = 0;\n    const n = arr.length;\n\n    for (let i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            countDecreases++;\n        }\n        if (countDecreases > 1) {\n            return false;\n        }\n    }\n\n    return true;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = move_one_ball;\n  assert.deepEqual(candidate([3, 4, 5, 1, 2]),true);\n  assert.deepEqual(candidate([3, 5, 10, 1, 2]),true);\n  assert.deepEqual(candidate([4, 3, 1, 2]),false);\n  assert.deepEqual(candidate([3, 5, 4, 1, 2]),false);\n  assert.deepEqual(candidate([]),true);\n}\n\ntest();"},{"task_id":"HumanEval_110","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/Ellers returneres \"NEJ\". \/\/Hvis alle elementer i lst1 er lige, returnerer \"YES\".\/\/Hvis det er muligt at udveksle elementer mellem lst1 og lst2 for at gøre \/\/Der er ingen grænse for antallet af elementer, der kan udveksles mellem lst1 og lst2. \/\/mellem dem for at gøre lst1 en række af kun lige tal. \/\/og afgør , om det er muligt at foretage en udveksling af elementer \/\/I dette problem skal du implementere en funktion, der tager to talarrangementer, \/\/ >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])\n\/\/ \"YES\"\n\/\/ >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n\/\/ \"NO\"\n\/\/ It is assumed that the input arrays will be non-empty.\nfunction exchange(lst1: number[], lst2: number[]): string {\n","canonical_solution":"function exchange(lst1: number[], lst2: number[]): string {\n    const isEven = (num: number) => num % 2 === 0;\n    \n    \/\/ Count the odd numbers in lst1\n    const oddCountInLst1 = lst1.reduce((count, num) => count + (isEven(num) ? 0 : 1), 0);\n\n    \/\/ Count the even numbers in lst2\n    const evenCountInLst2 = lst2.reduce((count, num) => count + (isEven(num) ? 1 : 0), 0);\n\n    \/\/ Check if number of odd numbers in lst1 can be matched by even numbers in lst2\n    return oddCountInLst1 <= evenCountInLst2 ? \"YES\" : \"NO\";\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = exchange;\n  assert.deepEqual(candidate([1, 2, 3, 4], [1, 2, 3, 4]),\"YES\");\n  assert.deepEqual(candidate([1, 2, 3, 4], [1, 5, 3, 4]),\"NO\");\n  assert.deepEqual(candidate([1, 2, 3, 4], [2, 1, 4, 3]),\"YES\");\n  assert.deepEqual(candidate([5, 7, 3], [2, 6, 4]),\"YES\");\n  assert.deepEqual(candidate([5, 7, 3], [2, 6, 3]),\"NO\");\n  assert.deepEqual(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]),\"NO\");\n  assert.deepEqual(candidate([100, 200], [200, 200]),\"YES\");\n}\n\ntest();"},{"task_id":"HumanEval_111","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Hvis flere bogstaver har samme forekomst, returneres alle. \/\/Det er den bogstav, der gentages oftest, og som indeholder det tilsvarende antal.\/\/Hvis der er en streng, der repræsenterer små bogstaver med mellemrum, returnerer vi et objekt \/\/ >>> histogram(\"a b c\")\n\/\/ {\"a\": 1, \"b\": 1, \"c\": 1}\n\/\/ >>> histogram(\"a b b a\")\n\/\/ {\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"a b c a b\")\n\/\/ {\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"b b b b a\")\n\/\/ {\"b\": 4}\n\/\/ >>> histogram(\"\")\n\/\/ {}\nfunction histogram(test: string): {[key: string]: number} {\n","canonical_solution":"function histogram(test: string): { [key: string]: number } {\n    if (test.trim() === \"\") {\n        return {};\n    }\n\n    const letters = test.split(\" \");\n    const counts: { [key: string]: number } = {};\n\n    for (const letter of letters) {\n        if (letter in counts) {\n            counts[letter]++;\n        } else {\n            counts[letter] = 1;\n        }\n    }\n\n    let maxCount = 0;\n    for (const count of Object.values(counts)) {\n        if (count > maxCount) {\n            maxCount = count;\n        }\n    }\n\n    const result: { [key: string]: number } = {};\n    for (const [letter, count] of Object.entries(counts)) {\n        if (count === maxCount) {\n            result[letter] = count;\n        }\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = histogram;\n  assert.deepEqual(candidate(\"a b b a\"),{\"a\": 2, \"b\": 2});\n  assert.deepEqual(candidate(\"a b c a b\"),{\"a\": 2, \"b\": 2});\n  assert.deepEqual(candidate(\"a b c d g\"),{\"a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"r t g\"),{\"r\": 1, \"t\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"b b b b a\"),{\"b\": 4});\n  assert.deepEqual(candidate(\"r t g\"),{\"r\": 1, \"t\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"\"),{});\n  assert.deepEqual(candidate(\"a\"),{\"a\": 1});\n}\n\ntest();"},{"task_id":"HumanEval_112","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel \/\/Du skal returnere en matrix, der indeholder resultatstrengen og true\/false for kontrollen. \/\/En streng kaldes palindrom, hvis den er den samme bagud som fremad.\/\/så kontroller, om den resulterende streng er palindrom. \/\/Vi har to strenge s og c, du skal slette alle tegn i s, der er lig med et tegn i c.\/\/Opgave \/\/ >>> reverse_delete(\"abcde\", \"ae\")\n\/\/ [\"bcd\", false]\n\/\/ >>> reverse_delete(\"abcdef\", \"b\")\n\/\/ [\"acdef\", false]\n\/\/ >>> reverse_delete(\"abcdedcba\", \"ab\")\n\/\/ [\"cdedc\", true]\nfunction reverse_delete(s: string, c: string): [string, boolean] {\n","canonical_solution":"function reverse_delete(s: string, c: string): [string, boolean] {\n    \/\/ Create a Set of characters to delete for faster lookup\n    const charsToDelete = new Set(c);\n\n    \/\/ Filter out characters in 's' that are in 'c'\n    const filteredString = s.split('').filter(char => !charsToDelete.has(char)).join('');\n\n    \/\/ Check if the filtered string is a palindrome\n    const isPalindrome = filteredString === filteredString.split('').reverse().join('');\n\n    return [filteredString, isPalindrome];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = reverse_delete;\n  assert.deepEqual(candidate(\"abcde\", \"ae\"),[\"bcd\", false]);\n  assert.deepEqual(candidate(\"abcdef\", \"b\"),[\"acdef\", false]);\n  assert.deepEqual(candidate(\"abcdedcba\", \"ab\"),[\"cdedc\", true]);\n  assert.deepEqual(candidate(\"dwik\", \"w\"),[\"dik\", false]);\n  assert.deepEqual(candidate(\"a\", \"a\"),[\"\", true]);\n  assert.deepEqual(candidate(\"abcdedcba\", \"\"),[\"abcdedcba\", true]);\n  assert.deepEqual(candidate(\"abcdedcba\", \"v\"),[\"abcdedcba\", true]);\n  assert.deepEqual(candidate(\"vabba\", \"v\"),[\"abba\", true]);\n  assert.deepEqual(candidate(\"mamma\", \"mia\"),[\"\", true]);\n}\n\ntest();"},{"task_id":"HumanEval_113","nl":"dan_Latn","pl":"ts","prompt":"\/\/af ulige cifre i den i'te streng af input. \/\/String i i input. \" hvor alle i'erne skal erstattes af tallet \/\/Hvert element i i udgangen skal være \"antallet af ulige elementer i \/\/Hvis vi har en række af strenge, hvor hver streng kun består af cifre, returnerer vi en række.\/\/ >>> odd_count([\"1234567\"])\n\/\/ [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\/\/ >>> odd_count([\"3\", \"11111111\"])\n\/\/ [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nfunction odd_count(lst: string[]): string[] {\n","canonical_solution":"function odd_count(lst: string[]): string[] {\n    return lst.map(str => {\n        \/\/ Count the number of odd digits in the string\n        let oddCount = Array.from(str).reduce((count, char) => {\n            let digit = parseInt(char, 10);\n            return digit % 2 !== 0 ? count + 1 : count;\n        }, 0);\n\n        \/\/ Construct the result string\n        return `the number of odd elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${oddCount}nput.`;\n    });\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = odd_count;\n  assert.deepEqual(candidate([\"1234567\"]),[\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]);\n  assert.deepEqual(candidate([\"3\", \"11111111\"]),[\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]);\n  assert.deepEqual(candidate([\"271\", \"137\", \"314\"]),[\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"]);\n}\n\ntest();"},{"task_id":"HumanEval_114","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel \/\/af nums. \/\/Find den mindste sum af alle ikke-tomme undermatræk \/\/ >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n\/\/ 1\n\/\/ >>> minSubArraySum([-1, -2, -3])\n\/\/ -6\nfunction minSubArraySum(nums: number[]): number {\n","canonical_solution":"function minSubArraySum(nums: number[]): number {\n    let minSum = nums[0];\n    let currentSum = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        currentSum = Math.min(nums[i], currentSum + nums[i]);\n        minSum = Math.min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n\n\/\/ Example usage:\n\/\/ console.log(minSubArraySum([2, 3, 4, 1, 2, 4])); \/\/ Output: 1\n\/\/ console.log(minSubArraySum([-1, -2, -3])); \/\/ Output: -6","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = minSubArraySum;\n  assert.deepEqual(candidate([2, 3, 4, 1, 2, 4]),1);\n  assert.deepEqual(candidate([-1, -2, -3]),-6);\n  assert.deepEqual(candidate([-1, -2, -3, 2, -10]),-14);\n  assert.deepEqual(candidate([-9999999999999999]),-9999999999999999);\n  assert.deepEqual(candidate([0, 10, 20, 1000000]),0);\n  assert.deepEqual(candidate([-1, -2, -3, 10, -5]),-6);\n  assert.deepEqual(candidate([100, -1, -2, -3, 10, -5]),-6);\n  assert.deepEqual(candidate([10, 11, 13, 8, 3, 4]),3);\n  assert.deepEqual(candidate([100, -33, 32, -1, 0, -2]),-33);\n  assert.deepEqual(candidate([-10]),-10);\n  assert.deepEqual(candidate([7]),7);\n  assert.deepEqual(candidate([1, -1]),-1);\n}\n\ntest();"},{"task_id":"HumanEval_115","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel 1: \/\/Angiv antallet af gange, du skal sænke spandene. \/\/Jeres opgave er at bruge spandene til at tømme brøndene.\/\/og alle spande har samme kapacitet.\/\/Hver brønd har en tilsvarende spand, som kan bruges til at udvinde vand fra den, \/\/og hver 1 i rækken repræsenterer en enkelt vandenhed. \/\/Man får et rektangulært gitter af brønde, hvor hver række repræsenterer en enkelt brønd.\/\/ >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n\/\/ 6\n\/\/ Example 2:\n\/\/ >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n\/\/ 5\n\/\/ Example 3:\n\/\/ >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n\/\/ 0\n\/\/ Constraints:\n\/\/ * all wells have the same length\n\/\/ * 1 <= grid.length <= 10^2\n\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/ * grid[i][j] -> 0 | 1\n\/\/ * 1 <= capacity <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n","canonical_solution":"function max_fill(grid: number[][], capacity: number): number {\n    let totalBuckets = 0;\n\n    for (let row of grid) {\n        let waterUnits = row.reduce((sum, cell) => sum + cell, 0);\n        totalBuckets += Math.ceil(waterUnits \/ capacity);\n    }\n\n    return totalBuckets;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();"},{"task_id":"HumanEval_116","nl":"dan_Latn","pl":"ts","prompt":"\/\/Den skal gennemføres således: \/\/For et tilsvarende antal ener skal sorteringen foretages på basis af decimalværdien. \/\/Antal ener i deres binære repræsentation i stigende rækkefølge.\/\/I denne Kata skal du sortere en række af ikke-negative heltal efter \/\/ >>> sort_array([1, 5, 2, 3, 4])\n\/\/ [1, 2, 3, 4, 5]\n\/\/ >>> sort_array([-2, -3, -4, -5, -6])\n\/\/ [-6, -5, -4, -3, -2]\n\/\/ >>> sort_array([1, 0, 2, 3, 4])\n\/\/ [0, 1, 2, 3, 4]\nfunction sort_array(arr: number[]): number[] {\n","canonical_solution":"function sort_array(arr: number[]): number[] {\n    return arr.sort((a, b) => {\n        const countOnes = (n: number) => n.toString(2).replace(\/0\/g, \"\").length;\n        const numOnesA = countOnes(a);\n        const numOnesB = countOnes(b);\n\n        if (numOnesA !== numOnesB) {\n            return numOnesA - numOnesB;\n        } else {\n            return a - b;\n        }\n    });\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_array;\n  assert.deepEqual(candidate([1, 5, 2, 3, 4]),[1, 2, 4, 3, 5]);\n  assert.deepEqual(candidate([-2, -3, -4, -5, -6]),[-4, -2, -6, -5, -3]);\n  assert.deepEqual(candidate([1, 0, 2, 3, 4]),[0, 1, 2, 4, 3]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]),[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n  assert.deepEqual(candidate([3, 6, 44, 12, 32, 5]),[32, 3, 5, 6, 12, 44]);\n  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);\n  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);\n}\n\ntest();"},{"task_id":"HumanEval_117","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Bemærk: Du kan antage, at inputstrengen kun indeholder bogstaver og mellemrum. \/\/Hvis strengen s er tom, skal funktionen returnere en tom matrix. \/\/n konsonanter, i den rækkefølge disse ord forekommer i strengen s. \/\/en funktion, der returnerer en matrix med alle ord fra streng s, der indeholder nøjagtigt \/\/Hvis vi har en streng s og et naturligt tal n, har vi fået til opgave at implementere \/\/ >>> select_words(\"Mary had a little lamb\", 4)\n\/\/ [\"little\"]\n\/\/ >>> select_words(\"Mary had a little lamb\", 3)\n\/\/ [\"Mary\", \"lamb\"]\n\/\/ >>> select_words(\"simple white space\", 2)\n\/\/ []\n\/\/ >>> select_words(\"Hello world\", 4)\n\/\/ [\"world\"]\n\/\/ >>> select_words(\"Uncle sam\", 3)\n\/\/ [\"Uncle\"]\nfunction select_words(s: string, n: number): string[] {\n","canonical_solution":"function select_words(s: string, n: number): string[] {\n    const isConsonant = (char: string): boolean => {\n        const vowels = 'aeiouAEIOU';\n        return !vowels.includes(char) && \/[a-zA-Z]\/.test(char);\n    };\n\n    const words = s.split(' ');\n    const result: string[] = [];\n\n    for (const word of words) {\n        const consonantCount = [...word].filter(isConsonant).length;\n        if (consonantCount === n) {\n            result.push(word);\n        }\n    }\n\n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = select_words;\n  assert.deepEqual(candidate(\"Mary had a little lamb\", 4),[\"little\"]);\n  assert.deepEqual(candidate(\"Mary had a little lamb\", 3),[\"Mary\", \"lamb\"]);\n  assert.deepEqual(candidate(\"simple white space\", 2),[]);\n  assert.deepEqual(candidate(\"Hello world\", 4),[\"world\"]);\n  assert.deepEqual(candidate(\"Uncle sam\", 3),[\"Uncle\"]);\n  assert.deepEqual(candidate(\"\", 4),[]);\n  assert.deepEqual(candidate(\"a b c d e f\", 1),[\"b\", \"c\", \"d\", \"f\"]);\n}\n\ntest();"},{"task_id":"HumanEval_118","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Du kan antage, at den givne streng indeholder kun engelsk bogstav. \/\/Find en vokal, der opfylder ovenstående betingelse.\/\/Vokaler i begyndelsen og slutningen tæller ikke.\/\/to konsonanter fra ordets højre side (højre- og venstregradsspecifik).\/\/Du får et ord, og din opgave er at finde den nærmeste vokal, der står mellem dem.\/\/ >>> get_closest_vowel(\"yogurt\")\n\/\/ \"u\"\n\/\/ >>> get_closest_vowel(\"FULL\")\n\/\/ \"U\"\n\/\/ >>> get_closest_vowel(\"quick\")\n\/\/ \"\"\n\/\/ >>> get_closest_vowel(\"ab\")\n\/\/ \"\"\nfunction get_closest_vowel(word: string): string {\n","canonical_solution":"function get_closest_vowel(word: string): string {\n    const vowels = new Set<string>(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);\n    for (let i = word.length - 2; i > 0; i--) {\n        if (vowels.has(word[i]) && !vowels.has(word[i - 1]) && !vowels.has(word[i + 1])) {\n            return word[i];\n        }\n    }\n    return '';\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_closest_vowel;\n  assert.deepEqual(candidate(\"yogurt\"),\"u\");\n  assert.deepEqual(candidate(\"full\"),\"u\");\n  assert.deepEqual(candidate(\"easy\"),\"\");\n  assert.deepEqual(candidate(\"eAsy\"),\"\");\n  assert.deepEqual(candidate(\"ali\"),\"\");\n  assert.deepEqual(candidate(\"bad\"),\"a\");\n  assert.deepEqual(candidate(\"most\"),\"o\");\n  assert.deepEqual(candidate(\"ab\"),\"\");\n  assert.deepEqual(candidate(\"ba\"),\"\");\n  assert.deepEqual(candidate(\"quick\"),\"\");\n  assert.deepEqual(candidate(\"anime\"),\"i\");\n  assert.deepEqual(candidate(\"Asia\"),\"\");\n  assert.deepEqual(candidate(\"Above\"),\"o\");\n}\n\ntest();"},{"task_id":"HumanEval_119","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Returnerer 'Ja' hvis der er en måde at lave en god streng, og returnerer 'Nej' ellers.\/\/\"()) \" er ikke. \/\/er afbalanceret. For eksempel: Strengen '(()))) er god, mens strengen \/\/En streng S anses for at være god, hvis og kun hvis alle parenteser i S \/\/Det er en god ting, at den resulterende streng er god.\/\/Dit job er at kontrollere, om det er muligt at sammenkæde de to strenge i \/\/kun parenteserne \" ((\") eller parenteserne \") \".\/\/Du får en matrix af to strenge, begge strenge består af åbne \/\/ >>> match_parens([\"()(\", \")\"])\n\/\/ \"Yes\"\n\/\/ >>> match_parens([\")\", \")\"])\n\/\/ \"No\"\nfunction match_parens(lst: string[]): string {\n","canonical_solution":"function match_parens(lst: string[]): string {\n    const canFormGoodString = (s1: string, s2: string): boolean => {\n        let balance = 0;\n\n        \/\/ Check s1 followed by s2\n        for (const char of s1 + s2) {\n            if (char === '(') balance++;\n            else if (char === ')') balance--;\n\n            if (balance < 0) return false; \/\/ More closing than opening\n        }\n        if (balance === 0) return true; \/\/ Balanced\n\n        balance = 0;\n        \/\/ Check s2 followed by s1\n        for (const char of s2 + s1) {\n            if (char === '(') balance++;\n            else if (char === ')') balance--;\n\n            if (balance < 0) return false; \/\/ More closing than opening\n        }\n\n        return balance === 0; \/\/ Balanced\n    };\n\n    return canFormGoodString(lst[0], lst[1]) ? 'Yes' : 'No';\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"},{"task_id":"HumanEval_120","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel 1: \/\/af længde k med de maksimale k tal i arr. \/\/Givet en række arr af heltal og et positivt heltal k, returnerer en sorteret række \/\/ >>> maximum([-3, -4, 5], 3)\n\/\/ [-4, -3, 5]\n\/\/ Example 2:\n\/\/ >>> maximum([4, -4, 4], 2)\n\/\/ [4, 4]\n\/\/ Example 3:\n\/\/ >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n\/\/ [2]\n\/\/ Note:\n\/\/ 1. The length of the array will be in the range of [1, 1000].\n\/\/ 2. The elements in the array will be in the range of [-1000, 1000].\n\/\/ 3. 0 <= k <= len(arr)\nfunction maximum(arr: number[], k: number): number[] {\n","canonical_solution":"function maximum(arr: number[], k: number): number[] {\n    \/\/ Sort the array in descending order and then take the first k elements\n    const sortedArr = arr.sort((a, b) => b - a);\n    return sortedArr.slice(0, k).sort((a, b) => a - b);\n}\n\n\/\/ Example usage:\n\/\/ console.log(maximum([-3, -4, 5], 3)); \/\/ Output: [-4, -3, 5]\n\/\/ console.log(maximum([4, -4, 4], 2)); \/\/ Output: [4, 4]\n\/\/ console.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1)); \/\/ Output: [2]","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maximum;\n  assert.deepEqual(candidate([-3, -4, 5], 3),[-4, -3, 5]);\n  assert.deepEqual(candidate([4, -4, 4], 2),[4, 4]);\n  assert.deepEqual(candidate([-3, 2, 1, 2, -1, -2, 1], 1),[2]);\n  assert.deepEqual(candidate([123, -123, 20, 0, 1, 2, -3], 3),[2, 20, 123]);\n  assert.deepEqual(candidate([-123, 20, 0, 1, 2, -3], 4),[0, 1, 2, 20]);\n  assert.deepEqual(candidate([5, 15, 0, 3, -13, -8, 0], 7),[-13, -8, 0, 0, 3, 5, 15]);\n  assert.deepEqual(candidate([-1, 0, 2, 5, 3, -10], 2),[3, 5]);\n  assert.deepEqual(candidate([1, 0, 5, -7], 1),[5]);\n  assert.deepEqual(candidate([4, -4], 2),[-4, 4]);\n  assert.deepEqual(candidate([-10, 10], 2),[-10, 10]);\n  assert.deepEqual(candidate([1, 2, 3, -23, 243, -400, 0], 0),[]);\n}\n\ntest();"},{"task_id":"HumanEval_121","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler \/\/Givet en ikke-tom matrix af heltal, returnerer vi summen af alle de ulige elementer, der er i lige positioner.\/\/ >>> solution([5, 8, 7, 1])\n\/\/ 12\n\/\/ >>> solution([3, 3, 3, 3, 3])\n\/\/ 9\n\/\/ >>> solution([30, 13, 24, 321])\n\/\/ 0\nfunction solution(lst: number[]): number {\n","canonical_solution":"function solution(lst: number[]): number {\n    let sum: number = 0;\n    for (let i = 0; i < lst.length; i += 2) {  \/\/ Traverse even indices\n        if (lst[i] % 2 !== 0) {  \/\/ Check if the element is odd\n            sum += lst[i];\n        }\n    }\n    return sum;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = solution;\n  assert.deepEqual(candidate([5, 8, 7, 1]),12);\n  assert.deepEqual(candidate([3, 3, 3, 3, 3]),9);\n  assert.deepEqual(candidate([30, 13, 24, 321]),0);\n  assert.deepEqual(candidate([5, 9]),5);\n  assert.deepEqual(candidate([2, 4, 8]),0);\n  assert.deepEqual(candidate([30, 13, 23, 32]),23);\n  assert.deepEqual(candidate([3, 13, 2, 9]),3);\n}\n\ntest();"},{"task_id":"HumanEval_122","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/summen af de elementer, der højst har to cifre fra de første k elementer af arr. \/\/Hvis der er en ikke-tom matrix af heltal arr og et heltal k, returneres \/\/ >>> add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n\/\/ 24\n\/\/ Constraints:\n\/\/ 1. 1 <= len(arr) <= 100\n\/\/ 2. 1 <= k <= len(arr)\nfunction add_elements(arr: number[], k: number): number {\n","canonical_solution":"function add_elements(arr: number[], k: number): number {\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = add_elements;\n  assert.deepEqual(candidate([1, -2, -3, 41, 57, 76, 87, 88, 99], 3),-4);\n  assert.deepEqual(candidate([111, 121, 3, 4000, 5, 6], 2),0);\n  assert.deepEqual(candidate([11, 21, 3, 90, 5, 6, 7, 8, 9], 4),125);\n  assert.deepEqual(candidate([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4),24);\n  assert.deepEqual(candidate([1], 1),1);\n}\n\ntest();"},{"task_id":"HumanEval_123","nl":"dan_Latn","pl":"ts","prompt":"\/\/get_odd_collatz(5) returnerer [1, 5] # Collatz sekvensen for 5 er [5, 16, 8, 4, 2, 1], så de ulige tal er kun 1, og 5. \/\/For eksempel: \/\/2. returneret matrix sorteret i stigende rækkefølge.\/\/1. Collatz(1) er [1]. \/\/Bemærk: \/\/Det er en gætning, at uanset hvilken værdi af n, vil sekvensen altid nå 1.\/\/Hvis det foregående udtryk er ulige, er det næste udtryk 3 gange det foregående udtryk.\/\/Hvis det foregående led er lige, er det næste led halvdelen af \/\/som følger: start med et hvilket som helst positivt heltal n. Derefter udledes hver term fra \/\/Collatz-formodningen er en formodning i matematik, der vedrører en defineret sekvens.\/\/Givet et positivt heltal n, returnerer vi en sorteret matrix med ulige tal i Collatz-sekvensen. \/\/ >>> get_odd_collatz(5)\n\/\/ [1, 5]\nfunction get_odd_collatz(n: number): number[] {\n","canonical_solution":"function get_odd_collatz(n: number): number[] {\n    const collatzSequence: number[] = [];\n    while (n !== 1) {\n        if (n % 2 !== 0) {\n            collatzSequence.push(n);\n        }\n        if (n % 2 === 0) {\n            n = n \/ 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n    \/\/ Include 1 in the sequence if it's odd, as per standard collatz sequence\n    collatzSequence.push(1);\n    return collatzSequence.sort((a, b) => a - b);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_odd_collatz;\n  assert.deepEqual(candidate(14),[1, 5, 7, 11, 13, 17]);\n  assert.deepEqual(candidate(5),[1, 5]);\n  assert.deepEqual(candidate(12),[1, 3, 5]);\n  assert.deepEqual(candidate(1),[1]);\n}\n\ntest();"},{"task_id":"HumanEval_124","nl":"dan_Latn","pl":"ts","prompt":"\/\/4. Datoen skal være i formatet: mm-dd-ååååå\/\/3. Månedstallet må ikke være mindre end 1 og ikke over 12.\/\/2. Antallet af dage er ikke mindre end 1 eller højere end 31 dage for måneder 1,3,5,7,8,10,12. Og antallet af dage er ikke mindre end 1 eller højere end 30 dage for måneder 4,6,9,11. Og antallet af dage er ikke mindre end 1 eller højere end 29 for måned 2.\/\/1. Datoen er ikke tom.\/\/Datoen er gyldig, hvis alle følgende regler er opfyldt: \/\/returnerer sandt, hvis datoen er gyldig, ellers falsk. \/\/Du skal skrive en funktion, der validerer en given dato strenge og \/\/ >>> valid_date(\"03-11-2000\")\n\/\/ true\n\/\/ >>> valid_date(\"15-01-2012\")\n\/\/ false\n\/\/ >>> valid_date(\"04-0-2040\")\n\/\/ false\n\/\/ >>> valid_date(\"06-04-2020\")\n\/\/ true\n\/\/ >>> valid_date(\"06\/04\/2020\")\n\/\/ false\nfunction valid_date(date: string): boolean {\n","canonical_solution":"function valid_date(date: string): boolean {\n    \/\/ Check if the date is empty\n    if (date.trim() === \"\") return false;\n\n    \/\/ Split the date string into components\n    const dateParts = date.split(\"-\");\n    if (dateParts.length !== 3) return false;\n\n    const [monthStr, dayStr, yearStr] = dateParts;\n\n    \/\/ Validate each part of the date\n    const month = parseInt(monthStr, 10);\n    const day = parseInt(dayStr, 10);\n    const year = parseInt(yearStr, 10);\n\n    \/\/ Check if all parts are valid numbers\n    if (isNaN(month) || isNaN(day) || isNaN(year)) return false;\n\n    \/\/ Check the month range\n    if (month < 1 || month > 12) return false;\n\n    \/\/ Check the day range based on the month\n    if ([1, 3, 5, 7, 8, 10, 12].includes(month)) {\n        if (day < 1 || day > 31) return false;\n    } else if ([4, 6, 9, 11].includes(month)) {\n        if (day < 1 || day > 30) return false;\n    } else if (month === 2) {\n        if (day < 1 || day > 29) return false;\n    }\n\n    \/\/ All checks passed\n    return true;\n}\n\n\/\/ Example usage\nconsole.log(valid_date(\"03-11-2000\")); \/\/ true\nconsole.log(valid_date(\"15-01-2012\")); \/\/ false\nconsole.log(valid_date(\"04-0-2040\"));  \/\/ false\nconsole.log(valid_date(\"06-04-2020\")); \/\/ true\nconsole.log(valid_date(\"06\/04\/2020\")); \/\/ false","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = valid_date;\n  assert.deepEqual(candidate(\"03-11-2000\"),true);\n  assert.deepEqual(candidate(\"15-01-2012\"),false);\n  assert.deepEqual(candidate(\"04-0-2040\"),false);\n  assert.deepEqual(candidate(\"06-04-2020\"),true);\n  assert.deepEqual(candidate(\"01-01-2007\"),true);\n  assert.deepEqual(candidate(\"03-32-2011\"),false);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"04-31-3000\"),false);\n  assert.deepEqual(candidate(\"06-06-2005\"),true);\n  assert.deepEqual(candidate(\"21-31-2000\"),false);\n  assert.deepEqual(candidate(\"04-12-2003\"),true);\n  assert.deepEqual(candidate(\"04122003\"),false);\n  assert.deepEqual(candidate(\"20030412\"),false);\n  assert.deepEqual(candidate(\"2003-04\"),false);\n  assert.deepEqual(candidate(\"2003-04-12\"),false);\n  assert.deepEqual(candidate(\"04-2003\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_125","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler \/\/alfabetisk, ord (a) = 0, ord (b) = 1, ... ord (z) = 25 \/\/skal opdeles på kommaer ',' hvis der ikke findes kommaer, skal du returnere antallet af små bogstaver i ulige rækkefølge i \/\/Hvis der er en række af ord, returnerer vi en række af ord opdelt på mellemrum, hvis der ikke findes mellemrum i den tekst, du søger.\/\/ >>> split_words(\"Hello world!\")\n\/\/ [\"Hello\", \"world!\"]\n\/\/ >>> split_words(\"Hello,world!\")\n\/\/ [\"Hello\", \"world!\"]\n\/\/ >>> split_words(\"abcdef\")\n\/\/ 3\nfunction split_words(txt: string): string[] | number {\n","canonical_solution":"function split_words(txt: string): string[] | number {\n    if (txt.includes(\" \")) {\n        return txt.split(\" \");\n    }\n    if (txt.includes(\",\")) {\n        return txt.split(\",\");\n    }\n    const oddOrderCount = [...txt].reduce((count, char) => {\n        const charCode = char.charCodeAt(0) - 'a'.charCodeAt(0);\n        if (char === char.toLowerCase() && charCode % 2 === 1) {\n            return count + 1;\n        }\n        return count;\n    }, 0);\n\n    return oddOrderCount;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = split_words;\n  assert.deepEqual(candidate(\"Hello world!\"),[\"Hello\", \"world!\"]);\n  assert.deepEqual(candidate(\"Hello,world!\"),[\"Hello\", \"world!\"]);\n  assert.deepEqual(candidate(\"Hello world,!\"),[\"Hello\", \"world,!\"]);\n  assert.deepEqual(candidate(\"Hello,Hello,world !\"),[\"Hello,Hello,world\", \"!\"]);\n  assert.deepEqual(candidate(\"abcdef\"),3);\n  assert.deepEqual(candidate(\"aaabb\"),2);\n  assert.deepEqual(candidate(\"aaaBb\"),1);\n  assert.deepEqual(candidate(\"\"),0);\n}\n\ntest();"},{"task_id":"HumanEval_126","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler \/\/Antag ingen negative tal og kun heltal.\/\/Hvis array har mere end 1 duplikat af samme\/\/Hvis vi har en række tal, returneres de, uanset om de er sorterede eller ej.\/\/ >>> is_sorted([5])\n\/\/ true\n\/\/ >>> is_sorted([1, 2, 3, 4, 5])\n\/\/ true\n\/\/ >>> is_sorted([1, 3, 2, 4, 5])\n\/\/ false\n\/\/ >>> is_sorted([1, 2, 3, 4, 5, 6])\n\/\/ true\n\/\/ >>> is_sorted([1, 2, 3, 4, 5, 6, 7])\n\/\/ true\n\/\/ >>> is_sorted([1, 3, 2, 4, 5, 6, 7])\n\/\/ false\n\/\/ >>> is_sorted([1, 2, 2, 3, 3, 4])\n\/\/ true\n\/\/ >>> is_sorted([1, 2, 2, 2, 3, 4])\n\/\/ false\nfunction is_sorted(lst: number[]): boolean {\n","canonical_solution":"function is_sorted(lst: number[]): boolean {\n    for (let i = 0; i < lst.length - 1; i++) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n        if (lst[i] === lst[i + 1]) {\n            let count = 1;\n            while (lst[i + count] === lst[i]) {\n                count++;\n                if (count > 2) return false;\n            }\n        }\n    }\n    return true;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_sorted;\n  assert.deepEqual(candidate([5]),true);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5]),true);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5]),false);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6]),true);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7]),true);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, 7]),false);\n  assert.deepEqual(candidate([]),true);\n  assert.deepEqual(candidate([1]),true);\n  assert.deepEqual(candidate([3, 2, 1]),false);\n  assert.deepEqual(candidate([1, 2, 2, 2, 3, 4]),false);\n  assert.deepEqual(candidate([1, 2, 3, 3, 3, 4]),false);\n  assert.deepEqual(candidate([1, 2, 2, 3, 3, 4]),true);\n  assert.deepEqual(candidate([1, 2, 3, 4]),true);\n}\n\ntest();"},{"task_id":"HumanEval_127","nl":"dan_Latn","pl":"ts","prompt":"\/\/[input\/output] prøver: \/\/Hvis de to intervaller ikke skærer hinanden, returnerer \"NEJ\".\/\/Hvis ikke, returneres \"NEJ\". \/\/Hvis skæringspunktet er et primtal, returneres \"YES\", \/\/Det er ikke et primtal.\/\/Eksempel: Skæringspunktet mellem intervallerne (1, 3), (2, 4) er (2, 3) \/\/intervaller er et primtal.\/\/Din opgave er at finde ud af, om længden af krydset mellem disse to \/\/For hvert givet interval antages det, at dets begyndelse er mindre end eller lig med dets slutning.\/\/omfatter både start og slutning. \/\/De givne intervaller er lukkede, hvilket betyder, at intervallet (start, slut) \/\/hvor hvert interval er et par af heltal. f.eks. interval = (start, slut) = (1, 2).\/\/Du får to intervaller.\/\/ >>> intersection([1, 2], [2, 3])\n\/\/ \"NO\"\n\/\/ >>> intersection([-1, 1], [0, 4])\n\/\/ \"NO\"\n\/\/ >>> intersection([-3, -1], [-5, 5])\n\/\/ \"YES\"\nfunction intersection(interval1: [number, number], interval2: [number, number]): string {\n","canonical_solution":"function isPrime(num: number): boolean {\n    if (num <= 1) return false;\n    if (num <= 3) return true; \/\/ 2 and 3 are prime numbers\n    if (num % 2 === 0 || num % 3 === 0) return false;\n    for (let i = 5; i * i <= num; i += 6) {\n        if (num % i === 0 || num % (i + 2) === 0) return false;\n    }\n    return true;\n}\n\nfunction intersection(interval1: [number, number], interval2: [number, number]): string {\n    const start = Math.max(interval1[0], interval2[0]);\n    const end = Math.min(interval1[1], interval2[1]);\n\n    if (start > end) {\n        return \"NO\";\n    }\n\n    const length = end - start;\n\n    return isPrime(length) ? \"YES\" : \"NO\";\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = intersection;\n  assert.deepEqual(candidate([1, 2], [2, 3]),\"NO\");\n  assert.deepEqual(candidate([-1, 1], [0, 4]),\"NO\");\n  assert.deepEqual(candidate([-3, -1], [-5, 5]),\"YES\");\n  assert.deepEqual(candidate([-2, 2], [-4, 0]),\"YES\");\n  assert.deepEqual(candidate([-11, 2], [-1, -1]),\"NO\");\n  assert.deepEqual(candidate([1, 2], [3, 5]),\"NO\");\n  assert.deepEqual(candidate([1, 2], [1, 2]),\"NO\");\n  assert.deepEqual(candidate([-2, -2], [-3, -2]),\"NO\");\n}\n\ntest();"},{"task_id":"HumanEval_128","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Bemærk: return undefined for tomme arr. \/\/af hvert tal i matrixen, repræsenteret ved 1, -1 eller 0. \/\/Summen af hele tals størrelser ganget med produktet af alle tegn \/\/Vi har en række af hele tal, og vi skal returnere \/\/ >>> prod_signs([1, 2, 2, -4])\n\/\/ 9\n\/\/ >>> prod_signs([0, 1])\n\/\/ 0\n\/\/ >>> prod_signs([])\n\/\/ undefined\nfunction prod_signs(arr: number[]): number | undefined {\n","canonical_solution":"function prod_signs(arr: number[]): number | undefined {\n    if (arr.length === 0) return undefined;\n\n    let sumOfMagnitudes = 0;\n    let productOfSigns = 1;\n\n    for (const num of arr) {\n        sumOfMagnitudes += Math.abs(num);\n        productOfSigns *= Math.sign(num);\n    }\n\n    return sumOfMagnitudes * productOfSigns;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = prod_signs;\n  assert.deepEqual(candidate([1, 2, 2, -4]),-9);\n  assert.deepEqual(candidate([0, 1]),0);\n  assert.deepEqual(candidate([1, 1, 1, 2, 3, -1, 1]),-10);\n  assert.deepEqual(candidate([]),undefined);\n  assert.deepEqual(candidate([2, 4, 1, 2, -1, -1, 9]),20);\n  assert.deepEqual(candidate([-1, 1, -1, 1]),4);\n  assert.deepEqual(candidate([-1, 1, 1, 1]),-4);\n  assert.deepEqual(candidate([-1, 1, 1, 0]),0);\n}\n\ntest();"},{"task_id":"HumanEval_129","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Returnerer en ordenet matrix af de værdier i de celler, som den mindste vej går igennem. \/\/Det er garanteret, at svaret er unikt. \/\/lst_A[j] = lst_B[j]. \/\/Således at lst_A[i] < lst_B[i] og for enhver j (1 <= j < i) har vi \/\/end lst_B, med andre ord, der findes et heltalindeks i (1 <= i <= k) \/\/gennem (lad os kalde dem lst_A og lst_B), lst_A er leksikografisk mindre \/\/Efter at have lavet de ordnede arrays af værdierne på de celler, som A og B går \/\/En vej A (af længde k) anses for mindre end en vej B (af længde k), hvis \/\/Du kan IKKE forsvinde fra nettet.\/\/(forpligtende adskilt).\/\/Bemærk, at en vej af længde k betyder, at der besøges nøjagtigt k celler (ikke \/\/\/\/Med andre ord, kan du gå til celler, der deler en kant med din nuværende \/\/Fra en hvilken som helst celle, og i hvert trin kan du flytte til en hvilken som helst af de nabokæler, \/\/Vi skal finde den mindste vej af længde k i rutenettet.\/\/inklusiv vises præcis én gang på rutenettet. \/\/Hver celle i rutenettet indeholder en værdi.\/\/Hvis der er tale om et gitter med N rækker og N kolonner (N >= 2) og et positivt heltal k, \/\/ >>> minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n\/\/ [1, 2, 1]\n\/\/ >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n\/\/ [1]\nfunction minPath(grid: number[][], k: number): number[] {\n","canonical_solution":"function minPath(grid: number[][], k: number): number[] {\n    const N = grid.length;\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    \n    type State = {path: number[], x: number, y: number, len: number};\n    \n    \/\/ Compare two paths lexicographically\n    const isLess = (a: number[], b: number[]): boolean => {\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] !== b[i]) return a[i] < b[i];\n        }\n        return false;\n    };\n\n    let bestPath: number[] = new Array(k).fill(Number.MAX_VALUE);\n    \n    \/\/ DFS function to explore paths of length k\n    function dfs(x: number, y: number, path: number[], len: number): void {\n        if (len === k) {\n            if (isLess(path, bestPath)) {\n                bestPath = [...path];\n            }\n            return;\n        }\n        \n        for (const [dx, dy] of directions) {\n            const nx = x + dx;\n            const ny = y + dy;\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                dfs(nx, ny, [...path, grid[nx][ny]], len + 1);\n            }\n        }\n    }\n    \n    \/\/ Try starting from each cell\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            dfs(i, j, [grid[i][j]], 1);\n        }\n    }\n    \n    return bestPath;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = minPath;\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1),[1]);\n  assert.deepEqual(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10, 1, 10, 1]);\n  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1, 6, 1, 6, 1]);\n  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1, 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1, 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"},{"task_id":"HumanEval_130","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/De første n + 1 tal i Tribonacci-sekvensen.\/\/Vi har et ikke-negativt heltal n, og vi skal returnere en matrix af \/\/= 2 + 3 + 3 = 8 \/\/tri(3) = tri(2) + tri(1) + tri(4) \/\/tri(4) = 3 \/\/tri(2) = 1 + (2 \/ 2) = 2 \/\/For eksempel: \/\/tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), hvis n er ulige. \/\/tri (n) = 1 + n \/ 2, hvis n er lige.\/\/tri(1) = 3 \/\/Tribonacci sekvensen er defineret ved gentagelsen: \/\/Men hvad folk ikke kender er Tribonacci sekvensen.\/\/Alle kender Fibonacci sekvensen, den blev studeret dybt af matematikere i \/\/ >>> tri(3)\n\/\/ [1, 3, 2, 8]\nfunction tri(n: number): number[] {\n","canonical_solution":"function tri(n: number): number[] {\n    const tribonacci: number[] = [1, 3]; \/\/ Initialize with first two definite values\n\n    function calculateTribonacci(index: number): number {\n        if (index < tribonacci.length) {\n            return tribonacci[index];\n        }\n\n        let result: number;\n        if (index % 2 === 0) {\n            result = 1 + index \/ 2;\n        } else {\n            result = calculateTribonacci(index - 1) + calculateTribonacci(index - 2) + calculateTribonacci(index + 1);\n        }\n\n        tribonacci[index] = result; \/\/ Memoize the result\n        return result;\n    }\n\n    for (let i = 0; i <= n; i++) {\n        calculateTribonacci(i);\n    }\n\n    return tribonacci.slice(0, n + 1);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = tri;\n  assert.deepEqual(candidate(3),[1, 3, 2, 8]);\n  assert.deepEqual(candidate(4),[1, 3, 2, 8, 3]);\n  assert.deepEqual(candidate(5),[1, 3, 2, 8, 3, 15]);\n  assert.deepEqual(candidate(6),[1, 3, 2, 8, 3, 15, 4]);\n  assert.deepEqual(candidate(7),[1, 3, 2, 8, 3, 15, 4, 24]);\n  assert.deepEqual(candidate(8),[1, 3, 2, 8, 3, 15, 4, 24, 5]);\n  assert.deepEqual(candidate(9),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);\n  assert.deepEqual(candidate(20),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);\n  assert.deepEqual(candidate(0),[1]);\n  assert.deepEqual(candidate(1),[1, 3]);\n}\n\ntest();"},{"task_id":"HumanEval_131","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/Returnerer 0 hvis alle cifre er lige. \/\/Hvis vi har et positivt heltal n, returnerer vi produktet af de ulige cifre. \/\/ >>> digits(1)\n\/\/ 1\n\/\/ >>> digits(4)\n\/\/ 0\n\/\/ >>> digits(235)\n\/\/ 15\nfunction digits(n: number): number {\n","canonical_solution":"function digits(n: number): number {\n    let product = 1;\n    let hasOdd = false;\n    \n    while (n > 0) {\n        let digit = n % 10;\n        if (digit % 2 !== 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n = Math.floor(n \/ 10);\n    }\n\n    return hasOdd ? product : 0;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = digits;\n  assert.deepEqual(candidate(5),5);\n  assert.deepEqual(candidate(54),5);\n  assert.deepEqual(candidate(120),1);\n  assert.deepEqual(candidate(5014),5);\n  assert.deepEqual(candidate(98765),315);\n  assert.deepEqual(candidate(5576543),2625);\n  assert.deepEqual(candidate(2468),0);\n}\n\ntest();"},{"task_id":"HumanEval_132","nl":"dan_Latn","pl":"ts","prompt":"\/\/hvor mindst én parentes i efterfølgeren er indlejret. \/\/Funktionen skal returnere true, hvis og kun hvis der er en gyldig undersekvens af parenteser \/\/Oprette en funktion, der tager en streng som input, som kun indeholder parenteser. \/\/ >>> is_nested(\"[[]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[]]]]]]][[[[[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[][]\")\n\/\/ false\n\/\/ >>> is_nested(\"[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[[][]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[[]][[\")\n\/\/ true\nfunction is_nested(string: string): boolean {\n","canonical_solution":"function is_nested(string: string): boolean {\n    let depth = 0;\n    let hasNesting = false;\n\n    for (let char of string) {\n        if (char === '[') {\n            depth++;\n            if (depth > 1) {\n                hasNesting = true;\n            }\n        } else if (char === ']') {\n            if (depth > 0) {\n                depth--;\n            } else {\n                \/\/ More closing brackets than opening\n                return false;\n            }\n        }\n    }\n\n    \/\/ Return true if there was at least one nested bracket and all brackets are matched\n    return hasNesting && depth === 0;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_133","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Runde hvert element i matrixen til det øverste int (loft) først.\/\/Vi skal returnere summen af kvadraterne i den givne matrix, \/\/Du får en række tal.\/\/ >>> lst([1.0, 2.0, 3.0])\n\/\/ 14\n\/\/ >>> lst([1.0, 4.0, 9.0])\n\/\/ 98\n\/\/ >>> lst([1.0, 3.0, 5.0, 7.0])\n\/\/ 84\n\/\/ >>> lst([1.4, 4.2, 0.0])\n\/\/ 29\n\/\/ >>> lst([-2.4, 1.0, 1.0])\n\/\/ 6\nfunction sum_squares(lst: number[]): number {\n","canonical_solution":"function sum_squares(lst: number[]): number {\n    return lst.map(Math.ceil).reduce((sum, num) => sum + num * num, 0);\n}\n\n\/\/ Example usage:\n\/\/ console.log(sum_squares([1.0, 2.0, 3.0])); \/\/ Output: 14\n\/\/ console.log(sum_squares([1.0, 4.0, 9.0])); \/\/ Output: 98\n\/\/ console.log(sum_squares([1.0, 3.0, 5.0, 7.0])); \/\/ Output: 84\n\/\/ console.log(sum_squares([1.4, 4.2, 0.0])); \/\/ Output: 29\n\/\/ console.log(sum_squares([-2.4, 1.0, 1.0])); \/\/ Output: 6","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sum_squares;\n  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);\n  assert.deepEqual(candidate([1.0, 3.0, 5.0, 7.0]),84);\n  assert.deepEqual(candidate([1.4, 4.2, 0.0]),29);\n  assert.deepEqual(candidate([-2.4, 1.0, 1.0]),6);\n  assert.deepEqual(candidate([100.0, 1.0, 15.0, 2.0]),10230);\n  assert.deepEqual(candidate([10000.0, 10000.0]),200000000);\n  assert.deepEqual(candidate([-1.4, 4.6, 6.3]),75);\n  assert.deepEqual(candidate([-1.4, 17.9, 18.9, 19.9]),1086);\n  assert.deepEqual(candidate([0.0]),0);\n  assert.deepEqual(candidate([-1.0]),1);\n  assert.deepEqual(candidate([-1.0, 1.0, 0.0]),2);\n}\n\ntest();"},{"task_id":"HumanEval_134","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Bemærk: \"ord\" er en gruppe tegn adskilt af mellemrum. \/\/en del af et ord, og falsk ellers.\/\/af en given streng er et alfabetisk tegn og er ikke \/\/Opret en funktion , der returnerer true , hvis det sidste tegn er \/\/ >>> check_if_last_char_is_a_letter(\"apple pie\")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e\")\n\/\/ true\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e \")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"\")\n\/\/ false\nfunction check_if_last_char_is_a_letter(txt: string): boolean {\n","canonical_solution":"function check_if_last_char_is_a_letter(txt: string): boolean {\n    if (txt.trim() === \"\") return false; \/\/ Handle empty or whitespace strings\n\n    \/\/ Trim the string to remove any trailing spaces\n    txt = txt.trim();\n\n    \/\/ Check if the last character is an alphabetical letter and ensure there's a space before it\n    const lastChar = txt.charAt(txt.length - 1);\n    const isAlpha = \/[a-zA-Z]\/.test(lastChar);\n\n    return isAlpha && txt.lastIndexOf(' ') === txt.length - 2;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = check_if_last_char_is_a_letter;\n  assert.deepEqual(candidate(\"apple\"),false);\n  assert.deepEqual(candidate(\"apple pi e\"),true);\n  assert.deepEqual(candidate(\"eeeee\"),false);\n  assert.deepEqual(candidate(\"A\"),true);\n  assert.deepEqual(candidate(\"Pumpkin pie \"),false);\n  assert.deepEqual(candidate(\"Pumpkin pie 1\"),false);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"eeeee e \"),false);\n  assert.deepEqual(candidate(\"apple pie\"),false);\n  assert.deepEqual(candidate(\"apple pi e \"),false);\n}\n\ntest();"},{"task_id":"HumanEval_135","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Der er tale om dobbeltværdier.\/\/Hvis der ikke findes noget sådant element, returneres -1. Den givne matrix vil ikke indeholde \/\/er ikke større end eller lig med det element, der umiddelbart går forud for det. Hvis \/\/Oprette en funktion, der returnerer det største indeks for et element, som \/\/ >>> can_arrange([1, 2, 4, 3, 5])\n\/\/ 3\n\/\/ >>> can_arrange([1, 2, 3])\n\/\/ -1\nfunction can_arrange(arr: number[]): number {\n","canonical_solution":"function can_arrange(arr: number[]): number {\n    for (let i = arr.length - 1; i > 0; i--) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = can_arrange;\n  assert.deepEqual(candidate([1, 2, 4, 3, 5]),3);\n  assert.deepEqual(candidate([1, 2, 4, 5]),-1);\n  assert.deepEqual(candidate([1, 4, 2, 5, 6, 7, 8, 9, 10]),2);\n  assert.deepEqual(candidate([4, 8, 5, 7, 3]),4);\n  assert.deepEqual(candidate([]),-1);\n}\n\ntest();"},{"task_id":"HumanEval_136","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/Hvis der ikke er nogen negative eller positive heltal, returneres de som udefinerede.\/\/af positive heltal i en matrix.\/\/Det største af de negative heltal, og \"b\" er det mindste.\/\/Oprette en funktion, der returnerer en matrix (a, b), hvor 'a' er \/\/ >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n\/\/ [undefined, 1]\n\/\/ >>> largest_smallest_integers([])\n\/\/ [undefined, undefined]\n\/\/ >>> largest_smallest_integers([0])\n\/\/ [undefined, undefined]\nfunction largest_smallest_integers(lst: number[]): [number | undefined, number | undefined] {\n","canonical_solution":"function largest_smallest_integers(lst: number[]): [number | undefined, number | undefined] {\n    let largestNegative: number | undefined = undefined;\n    let smallestPositive: number | undefined = undefined;\n\n    for (let num of lst) {\n        if (num < 0) {\n            if (largestNegative === undefined || num > largestNegative) {\n                largestNegative = num;\n            }\n        } else if (num > 0) {\n            if (smallestPositive === undefined || num < smallestPositive) {\n                smallestPositive = num;\n            }\n        }\n    }\n\n    return [largestNegative, smallestPositive];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = largest_smallest_integers;\n  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7]),[undefined, 1]);\n  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7, 0]),[undefined, 1]);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2, 1]);\n  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);\n  assert.deepEqual(candidate([7, 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);\n  assert.deepEqual(candidate([]),[undefined, undefined]);\n  assert.deepEqual(candidate([0]),[undefined, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6]),[-1, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6, 0]),[-1, undefined]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3, 1]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);\n}\n\ntest();"},{"task_id":"HumanEval_138","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel \/\/Vurder, om det givne tal n kan skrives som summen af nøjagtigt 4 positive lige tal.\/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunction is_equal_to_sum_even(n: number): boolean {\n","canonical_solution":"function is_equal_to_sum_even(n: number): boolean {\n    \/\/ The sum of 4 positive even numbers is always even and 8 is the smallest such sum (2 + 2 + 2 + 2).\n    \/\/ Hence, if n is greater than or equal to 8 and even, n can be expressed as the sum of 4 positive even numbers.\n    return (n >= 8) && (n % 2 === 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_equal_to_sum_even;\n  assert.deepEqual(candidate(4),false);\n  assert.deepEqual(candidate(6),false);\n  assert.deepEqual(candidate(8),true);\n  assert.deepEqual(candidate(10),true);\n  assert.deepEqual(candidate(11),false);\n  assert.deepEqual(candidate(12),true);\n  assert.deepEqual(candidate(13),false);\n  assert.deepEqual(candidate(16),true);\n}\n\ntest();"},{"task_id":"HumanEval_139","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/hvor n > 0 \/\/Brasiliansk_faktorisk (n) = n! * (n-1)! * (n-2)! * ... * 1! \/\/Den brasilianske faktorie er defineret som: \/\/ >>> special_factorial(4)\n\/\/ 288\n\/\/ The function will receive an integer as input and should return the special\n\/\/ factorial of this integer.\nfunction special_factorial(n: number): number {\n","canonical_solution":"function factorial(n: number): number {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1);\n}\n\nfunction special_factorial(n: number): number {\n    if (n <= 0) throw new Error(\"Input must be a positive integer\");\n    \n    let result = 1;\n    for (let i = n; i >= 1; i--) {\n        result *= factorial(i);\n    }\n    \n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = special_factorial;\n  assert.deepEqual(candidate(4),288);\n  assert.deepEqual(candidate(5),34560);\n  assert.deepEqual(candidate(7),125411328000);\n  assert.deepEqual(candidate(1),1);\n}\n\ntest();"},{"task_id":"HumanEval_140","nl":"dan_Latn","pl":"ts","prompt":"\/\/Dertil kommer, at alle på hinanden følgende mellemrum erstattes med - \/\/og hvis en streng har mere end 2 på hinanden følgende mellemrum, \/\/Hvis der er en tekststreng, erstattes alle mellemrum i den med understreger, \/\/ >>> fix_spaces(\" Example\")\n\/\/ \"Example\"\n\/\/ >>> fix_spaces(\" Example 1\")\n\/\/ \"Example_1\"\n\/\/ >>> fix_spaces(\" Example 2\")\n\/\/ \"_Example_2\"\n\/\/ >>> fix_spaces(\" Example 3\")\n\/\/ \"_Example-3\"\nfunction fix_spaces(text: string): string {\n","canonical_solution":"function fix_spaces(text: string): string {\n    \/\/ Trim leading and trailing spaces\n    let trimmedText = text.trim();\n\n    \/\/ Use a regular expression to replace all sequences of two or more spaces with \"-\"\n    let replacedText = trimmedText.replace(\/ {2,}\/g, '-');\n\n    \/\/ Replace remaining single spaces with underscores\n    replacedText = replacedText.replace(\/ \/g, '_');\n\n    return replacedText;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fix_spaces;\n  assert.deepEqual(candidate(\"Example\"),\"Example\");\n  assert.deepEqual(candidate(\"Mudasir Hanif \"),\"Mudasir_Hanif_\");\n  assert.deepEqual(candidate(\"Yellow Yellow  Dirty  Fellow\"),\"Yellow_Yellow__Dirty__Fellow\");\n  assert.deepEqual(candidate(\"Exa   mple\"),\"Exa-mple\");\n  assert.deepEqual(candidate(\"   Exa 1 2 2 mple\"),\"-Exa_1_2_2_mple\");\n}\n\ntest();"},{"task_id":"HumanEval_141","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/- Substrengen efter punktet skal være en af disse: ['txt', 'exe', 'dll'] \/\/Det latinske alfabet (\"a\" - \"z\" og \"A\" - \"Z\").\/\/- Substrengen før punktet bør ikke være tom, og det begynder med en bogstav fra \/\/- Filens navn indeholder præcis ét prik.\/\/- Filnavnet må ikke bestå af mere end tre cifre ('0'-'9'). \/\/er opfyldt: \/\/Et filnavn anses for gyldigt, hvis og kun hvis alle følgende betingelser er opfyldt:\/\/\"Ja\", hvis filens navn er gyldigt, og returnerer \"Nej\", hvis det ikke er. \/\/Oprette en funktion, der tager en streng, der repræsenterer filens navn, og returnerer \/\/ >>> file_name_check(\"example.txt\")\n\/\/ \"Yes\"\n\/\/ >>> file_name_check(\"1example.dll\")\n\/\/ \"No\"\nfunction file_name_check(file_name: string): string {\n","canonical_solution":"function file_name_check(file_name: string): string {\n    \/\/ Split the file name into name and extension based on the dot\n    const parts = file_name.split('.');\n    \n    \/\/ Check if there's exactly one dot\n    if (parts.length !== 2) {\n        return 'No';\n    }\n    \n    const [name, extension] = parts;\n    \n    \/\/ Check if the substring before the dot is not empty and starts with a latin letter\n    if (name.length === 0 || !\/^[a-zA-Z]\/.test(name)) {\n        return 'No';\n    }\n    \n    \/\/ Check if the number of digits in the name is not more than three\n    const digitCount = (name.match(\/\\d\/g) || []).length;\n    if (digitCount > 3) {\n        return 'No';\n    }\n    \n    \/\/ Check if the extension is one of the valid options\n    const validExtensions = ['txt', 'exe', 'dll'];\n    if (!validExtensions.includes(extension)) {\n        return 'No';\n    }\n    \n    \/\/ All conditions are met, the file name is valid\n    return 'Yes';\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = file_name_check;\n  assert.deepEqual(candidate(\"example.txt\"),\"Yes\");\n  assert.deepEqual(candidate(\"1example.dll\"),\"No\");\n  assert.deepEqual(candidate(\"s1sdf3.asd\"),\"No\");\n  assert.deepEqual(candidate(\"K.dll\"),\"Yes\");\n  assert.deepEqual(candidate(\"MY16FILE3.exe\"),\"Yes\");\n  assert.deepEqual(candidate(\"His12FILE94.exe\"),\"No\");\n  assert.deepEqual(candidate(\"_Y.txt\"),\"No\");\n  assert.deepEqual(candidate(\"?aREYA.exe\"),\"No\");\n  assert.deepEqual(candidate(\"\/this_is_valid.dll\"),\"No\");\n  assert.deepEqual(candidate(\"this_is_valid.wow\"),\"No\");\n  assert.deepEqual(candidate(\"this_is_valid.txt\"),\"Yes\");\n  assert.deepEqual(candidate(\"this_is_valid.txtexe\"),\"No\");\n  assert.deepEqual(candidate(\"#this2_i4s_5valid.ten\"),\"No\");\n  assert.deepEqual(candidate(\"@this1_is6_valid.exe\"),\"No\");\n  assert.deepEqual(candidate(\"this_is_12valid.6exe4.txt\"),\"No\");\n  assert.deepEqual(candidate(\"all.exe.txt\"),\"No\");\n  assert.deepEqual(candidate(\"I563_No.exe\"),\"Yes\");\n  assert.deepEqual(candidate(\"Is3youfault.txt\"),\"Yes\");\n  assert.deepEqual(candidate(\"no_one#knows.dll\"),\"Yes\");\n  assert.deepEqual(candidate(\"1I563_Yes3.exe\"),\"No\");\n  assert.deepEqual(candidate(\"I563_Yes3.txtt\"),\"No\");\n  assert.deepEqual(candidate(\"final..txt\"),\"No\");\n  assert.deepEqual(candidate(\"final132\"),\"No\");\n  assert.deepEqual(candidate(\"_f4indsartal132.\"),\"No\");\n  assert.deepEqual(candidate(\".txt\"),\"No\");\n  assert.deepEqual(candidate(\"s.\"),\"No\");\n}\n\ntest();"},{"task_id":"HumanEval_142","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/ændrer de poster i matrixen, hvis indeks ikke er et multiplum af 3 eller 4. Funktionen skal derefter returnere summen af alle poster.\/\/Multiplikator af 3 og vil kubere hele tallet, hvis indeksen er et multiplikator af 4 og ikke et multiplikator af 3. Funktionen vil ikke \/\/Denne funktion tager en række af heltal. For alle poster i rækken skal funktionen sætte heltalsen i anden, hvis dens indeks er a \/\/\" \/\/ >>> lst\n\/\/ [1, 2, 3]\n\/\/ >>> lst\n\/\/ []\n\/\/ >>> lst\n\/\/ [-1, -5, 2, -1, -5]\nfunction sum_squares(lst: number[]): number {\n","canonical_solution":"function sum_squares(lst: number[]): number {\n    return lst.reduce((sum, value, index) => {\n        if (index % 3 === 0) {\n            return sum + (value * value);\n        } else if (index % 4 === 0) {\n            return sum + (value * value * value);\n        } else {\n            return sum + value;\n        }\n    }, 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sum_squares;\n  assert.deepEqual(candidate([1, 2, 3]),6);\n  assert.deepEqual(candidate([1, 4, 9]),14);\n  assert.deepEqual(candidate([]),0);\n  assert.deepEqual(candidate([1, 1, 1, 1, 1, 1, 1, 1, 1]),9);\n  assert.deepEqual(candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1]),-3);\n  assert.deepEqual(candidate([0]),0);\n  assert.deepEqual(candidate([-1, -5, 2, -1, -5]),-126);\n  assert.deepEqual(candidate([-56, -99, 1, 0, -2]),3030);\n  assert.deepEqual(candidate([-1, 0, 0, 0, 0, 0, 0, 0, -1]),0);\n  assert.deepEqual(candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]),-14196);\n  assert.deepEqual(candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]),-1448);\n}\n\ntest();"},{"task_id":"HumanEval_143","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel 1: \/\/Ordren i den nye tekststreng skal være den samme som i den oprindelige.\/\/hvis længder er primtal, \/\/Og du skal returnere en streng, der indeholder ordene fra den oprindelige sætning, \/\/sætningen indeholder nogle ord, der er adskilt af et mellemrum, \/\/Man får en streng, der repræsenterer en sætning.\/\/ >>> words_in_sentence(\"This is a test\")\n\/\/ \"is\"\n\/\/ Example 2:\n\/\/ >>> words_in_sentence(\"lets go for swimming\")\n\/\/ \"go for\"\n\/\/ Constraints:\n\/\/ * 1 <= len(sentence) <= 100\n\/\/ * sentence contains only letters\nfunction words_in_sentence(sentence: string): string {\n","canonical_solution":"function isPrime(num: number): boolean {\n    if (num < 2) return false;\n    for (let i = 2; i * i <= num; i++) {\n        if (num % i === 0) return false;\n    }\n    return true;\n}\n\nfunction words_in_sentence(sentence: string): string {\n    return sentence\n        .split(' ')\n        .filter(word => isPrime(word.length))\n        .join(' ');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = words_in_sentence;\n  assert.deepEqual(candidate(\"This is a test\"),\"is\");\n  assert.deepEqual(candidate(\"lets go for swimming\"),\"go for\");\n  assert.deepEqual(candidate(\"there is no place available here\"),\"there is no place\");\n  assert.deepEqual(candidate(\"Hi I am Hussein\"),\"Hi am Hussein\");\n  assert.deepEqual(candidate(\"go for it\"),\"go for it\");\n  assert.deepEqual(candidate(\"here\"),\"\");\n  assert.deepEqual(candidate(\"here is\"),\"is\");\n}\n\ntest();"},{"task_id":"HumanEval_144","nl":"dan_Latn","pl":"ts","prompt":"\/\/Vi kan antage, at x og n er gyldige brøk, og at de ikke har nul som nævner.\/\/<tæller>\/<nævner>, hvor både tæller og nævner er positive hele tal. \/\/Både x og n er strenge af en brøkdel, og har følgende format, \/\/x * n. Funktionen returnerer true, hvis x * n er et helt tal og false \/\/Det er din opgave at implementere en funktion, der forenkler udtrykket.\/\/ >>> simplify(\"1\/5\", \"5\/1\")\n\/\/ true\n\/\/ >>> simplify(\"1\/6\", \"2\/1\")\n\/\/ false\n\/\/ >>> simplify(\"7\/10\", \"10\/2\")\n\/\/ false\nfunction simplify(x: string, n: string): boolean {\n","canonical_solution":"function simplify(x: string, n: string): boolean {\n    const parseFraction = (fraction: string): [number, number] => {\n        const [numerator, denominator] = fraction.split('\/').map(Number);\n        return [numerator, denominator];\n    };\n\n    const [xNumerator, xDenominator] = parseFraction(x);\n    const [nNumerator, nDenominator] = parseFraction(n);\n\n    \/\/ Multiply the fractions: (a\/b) * (c\/d) = (a*c) \/ (b*d)\n    const resultNumerator = xNumerator * nNumerator;\n    const resultDenominator = xDenominator * nDenominator;\n\n    \/\/ A product of fractions is a whole number if its numerator divided by denominator is an integer.\n    return resultNumerator % resultDenominator === 0;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = simplify;\n  assert.deepEqual(candidate(\"1\/5\", \"5\/1\"),true);\n  assert.deepEqual(candidate(\"1\/6\", \"2\/1\"),false);\n  assert.deepEqual(candidate(\"5\/1\", \"3\/1\"),true);\n  assert.deepEqual(candidate(\"7\/10\", \"10\/2\"),false);\n  assert.deepEqual(candidate(\"2\/10\", \"50\/10\"),true);\n  assert.deepEqual(candidate(\"7\/2\", \"4\/2\"),true);\n  assert.deepEqual(candidate(\"11\/6\", \"6\/1\"),true);\n  assert.deepEqual(candidate(\"2\/3\", \"5\/2\"),false);\n  assert.deepEqual(candidate(\"5\/2\", \"3\/5\"),false);\n  assert.deepEqual(candidate(\"2\/4\", \"8\/4\"),true);\n  assert.deepEqual(candidate(\"2\/4\", \"4\/2\"),true);\n  assert.deepEqual(candidate(\"1\/5\", \"5\/1\"),true);\n  assert.deepEqual(candidate(\"1\/5\", \"1\/5\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_145","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/Ordne dem ud fra deres indeks i den oprindelige matrix.\/\/Bemærk: Hvis der er flere poster med samme sum af deres cifre, \/\/i stigende rækkefølge efter summen af deres cifre. \/\/Skriv en funktion, der sorterer den givne række af heltal \/\/ >>> order_by_points([1, 11, -1, -11, -12])\n\/\/ [-1, -11, 1, -12, 11]\n\/\/ >>> order_by_points([])\n\/\/ []\nfunction order_by_points(nums: number[]): number[] {\n","canonical_solution":"function order_by_points(nums: number[]): number[] {\n    const digitSum = (num: number): number => {\n        let sum = 0;\n        let value = Math.abs(num);\n        while (value > 0) {\n            sum += value % 10;\n            value = Math.floor(value \/ 10);\n        }\n        return sum;\n    };\n\n    return nums\n        .map((num, index) => ({ num, index, sumOfDigits: digitSum(num) }))\n        .sort((a, b) => {\n            if (a.sumOfDigits === b.sumOfDigits) {\n                return a.index - b.index;\n            }\n            return a.sumOfDigits - b.sumOfDigits;\n        })\n        .map(item => item.num);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = order_by_points;\n  assert.deepEqual(candidate([1, 11, -1, -11, -12]),[-1, -11, 1, -12, 11]);\n  assert.deepEqual(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98, -11, 1, 2, 43, 54]);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n  assert.deepEqual(candidate([0, 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6]);\n}\n\ntest();"},{"task_id":"HumanEval_146","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/et tals første og sidste cifre er ulige (1, 3, 5, 7, 9). \/\/Antallet af elementer i matrixen, der er større end 10 og begge \/\/Skriv en funktion, der tager en række tal som input og returnerer \/\/ >>> specialFilter([15, -73, 14, -15])\n\/\/ 1\n\/\/ >>> specialFilter([33, -2, -3, 45, 21, 109])\n\/\/ 2\nfunction specialFilter(nums: number[]): number {\n","canonical_solution":"function specialFilter(nums: number[]): number {\n    const isOdd = (digit: number): boolean => digit % 2 !== 0;\n\n    return nums.reduce((count, num) => {\n        const absNumStr = Math.abs(num).toString();\n        const firstDigit = parseInt(absNumStr[0]);\n        const lastDigit = parseInt(absNumStr[absNumStr.length - 1]);\n\n        if (num > 10 && isOdd(firstDigit) && isOdd(lastDigit)) {\n            return count + 1;\n        }\n\n        return count;\n    }, 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = specialFilter;\n  assert.deepEqual(candidate([5, -2, 1, -5]),0);\n  assert.deepEqual(candidate([15, -73, 14, -15]),1);\n  assert.deepEqual(candidate([33, -2, -3, 45, 21, 109]),2);\n  assert.deepEqual(candidate([43, -12, 93, 125, 121, 109]),4);\n  assert.deepEqual(candidate([71, -2, -33, 75, 21, 19]),3);\n  assert.deepEqual(candidate([1]),0);\n  assert.deepEqual(candidate([]),0);\n}\n\ntest();"},{"task_id":"HumanEval_147","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Og a[i] + a[j] + a[k] er et multiplum af 3.\/\/Returnerer antallet af trillinger (a[i], a[j], a[k]) af a, hvor i < j < k, \/\/For hver i (1 ≤ i ≤ n) er værdien af a[i] = i * i - i + 1. \/\/Vi har et helt tal n. Vi skal lave en heltalsmatrix a af længde n.\/\/ >>> get_max_triples(5)\n\/\/ 1\n\/\/ Explanation: \n\/\/ a = [1, 3, 7, 13, 21]\n\/\/ The only valid triple is (1, 7, 13).\nfunction get_max_triples(n: number): number {\n","canonical_solution":"function get_max_triples(n: number): number {\n    const a: number[] = [];\n\n    for (let i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    let count = 0;\n\n    for (let i = 0; i < n - 2; i++) {\n        for (let j = i + 1; j < n - 1; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 === 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_max_triples;\n  assert.deepEqual(candidate(5),1);\n  assert.deepEqual(candidate(6),4);\n  assert.deepEqual(candidate(10),36);\n  assert.deepEqual(candidate(100),53361);\n}\n\ntest();"},{"task_id":"HumanEval_149","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/Man kan antage, at alle ord har samme længde.\/\/Funktionen skal returnere en række af strenge i sorteret rækkefølge. \/\/Hvis to ord er af samme længde, skal vi sortere dem alfabetisk.\/\/skal returnere den matrix, der er sorteret efter denne regel. \/\/Ordren i matrixen skal stige i længden af hvert ord, og du \/\/og den kan indeholde duplikater.\/\/En matrix er altid en matrix af strenge og aldrig en matrix af tal.\/\/og returnerer den resulterende matrix med en sorteret rækkefølge, \/\/sletter de strenge, der har ulige længder fra det, \/\/Skriv en funktion, der accepterer en række af strenge som en parameter, \/\/ >>> list_sort([\"aa\", \"a\", \"aaa\"])\n\/\/ [\"aa\"]\n\/\/ >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n\/\/ [\"ab\", \"cd\"]\nfunction sorted_list_sum(lst: string[]): string[] {\n","canonical_solution":"function sorted_list_sum(lst: string[]): string[] {\n    \/\/ Filter out strings with odd lengths\n    const filtered = lst.filter(str => str.length % 2 === 0);\n    \/\/ Sort the array by length, then alphabetically\n    const sorted = filtered.sort((a, b) => {\n        if (a.length === b.length) {\n            return a.localeCompare(b);\n        }\n        return a.length - b.length;\n    });\n    return sorted;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sorted_list_sum;\n  assert.deepEqual(candidate([\"aa\", \"a\", \"aaa\"]),[\"aa\"]);\n  assert.deepEqual(candidate([\"school\", \"AI\", \"asdf\", \"b\"]),[\"AI\", \"asdf\", \"school\"]);\n  assert.deepEqual(candidate([\"d\", \"b\", \"c\", \"a\"]),[]);\n  assert.deepEqual(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]),[\"abcd\", \"dcba\"]);\n  assert.deepEqual(candidate([\"AI\", \"ai\", \"au\"]),[\"AI\", \"ai\", \"au\"]);\n  assert.deepEqual(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]),[]);\n  assert.deepEqual(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]),[\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\n\ntest();"},{"task_id":"HumanEval_150","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/et primtal og skal returnere y-værdien i modsat fald. \/\/Et simpelt program, der skal returnere x, hvis n er \/\/ >>> x_or_y(7, 34, 12)\n\/\/ 34\n\/\/ >>> x_or_y(15, 8, 5)\n\/\/ 5\nfunction x_or_y(n: number, x: number, y: number): number {\n","canonical_solution":"function x_or_y(n: number, x: number, y: number): number {\n    function isPrime(num: number): boolean {\n        if (num <= 1) return false;\n        if (num <= 3) return true;\n        \n        if (num % 2 === 0 || num % 3 === 0) return false;\n        \n        for (let i = 5; i * i <= num; i += 6) {\n            if (num % i === 0 || num % (i + 2) === 0) return false;\n        }\n        \n        return true;\n    }\n\n    return isPrime(n) ? x : y;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = x_or_y;\n  assert.deepEqual(candidate(7, 34, 12),34);\n  assert.deepEqual(candidate(15, 8, 5),5);\n  assert.deepEqual(candidate(3, 33, 5212),33);\n  assert.deepEqual(candidate(1259, 3, 52),3);\n  assert.deepEqual(candidate(7919, -1, 12),-1);\n  assert.deepEqual(candidate(3609, 1245, 583),583);\n  assert.deepEqual(candidate(91, 56, 129),129);\n  assert.deepEqual(candidate(6, 34, 1234),1234);\n  assert.deepEqual(candidate(1, 2, 0),0);\n  assert.deepEqual(candidate(2, 2, 0),2);\n}\n\ntest();"},{"task_id":"HumanEval_151","nl":"dan_Latn","pl":"ts","prompt":"\/\/Ignorer tal, der er negative eller ikke-helruter.\/\/Givet en række tal, returnerer vi summen af kvadraterne af tallene.\/\/ >>> double_the_difference([1, 3, 2, 0])\n\/\/ 10\n\/\/ >>> double_the_difference([-1, -2, 0])\n\/\/ 0\n\/\/ >>> double_the_difference([9, -2])\n\/\/ 81\n\/\/ >>> double_the_difference([0])\n\/\/ 0\n\/\/ If the input array is empty, return 0.\nfunction double_the_difference(lst: number[]): number {\n","canonical_solution":"function double_the_difference(lst: number[]): number {\n    return lst\n        .filter(num => Number.isInteger(num) && num > 0 && num % 2 !== 0)\n        .reduce((sum, num) => sum + num * num, 0);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = double_the_difference;\n  assert.deepEqual(candidate([]),0);\n  assert.deepEqual(candidate([5.0, 4.0]),25);\n  assert.deepEqual(candidate([0.1, 0.2, 0.3]),0);\n  assert.deepEqual(candidate([-10.0, -20.0, -30.0]),0);\n  assert.deepEqual(candidate([-1.0, -2.0, 8.0]),0);\n  assert.deepEqual(candidate([0.2, 3.0, 5.0]),34);\n  assert.deepEqual(candidate([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]),165);\n}\n\ntest();"},{"task_id":"HumanEval_152","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Værdien er 0, og hvis ikke, er værdien den absolutte forskel mellem gæt og score. \/\/Returnerer en matrix af samme længde, der angiver, hvor langt væk hvert gæt var.\/\/Du får to arrays af scores og gæt af samme længde, hvor hver indeks viser en match.\/\/Din opgave er at afgøre, om en person har gættet resultaterne af en række kampe korrekt.\/\/Det er bestemt værd at notere og sammenligne.\/\/De følelser og tanker, du har i det øjeblik, er \/\/Jeg tror, vi alle husker den følelse, når resultatet af en længe ventet\/\/ >>> compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n\/\/ [0, 0, 0, 0, 3, 3]\n\/\/ >>> compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n\/\/ [4, 4, 1, 0, 0, 6]\nfunction compare(game: number[], guess: number[]): number[] {\n","canonical_solution":"function compare(game: number[], guess: number[]): number[] {\n    return game.map((score, index) => Math.abs(score - guess[index]));\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = compare;\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]),[0, 0, 0, 0, 3, 3]);\n  assert.deepEqual(candidate([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]),[0, 0, 0, 0, 0, 0]);\n  assert.deepEqual(candidate([1, 2, 3], [-1, -2, -3]),[2, 4, 6]);\n  assert.deepEqual(candidate([1, 2, 3, 5], [-1, 2, 3, 4]),[2, 0, 0, 1]);\n}\n\ntest();"},{"task_id":"HumanEval_153","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/(dets styrke er -1).\/\/return \"Slices.SErviNGSliCes\", da \"SErviNGSliCes\" er den stærkeste udvidelse \/\/Hvis du har brug for en tekst, der er udformet på en anden måde end den, du har brug for, og som du har brug for, så skal du bruge en tekst, der er udformet på anden måde end den, du har brug for.\/\/For eksempel, hvis du får \"Slices\" som klassen og en matrix af \/\/Vælg den, der kommer først i rækken.\/\/Hvis der er to eller flere udvidelser med samme styrke, bør du \/\/format: ClassName.StrongestExtensionName. \/\/Du skal finde den stærkeste udvidelse og returnere en streng i denne .\/\/I udvidelsens navn er styrken angivet ved fraktionen CAP - SM. \/\/bogstaver i udvidelsens navn, og lad SM være antallet af små bogstaver \/\/Udvidelsens styrke er som følger: Lad CAP være tallet i det store bogstav \/\/Udvidelserne skal bruges til at indlæse yderligere klasser i klassen.\/\/Du får navnet på en klasse (en streng) og en række udvidelser.\/\/ >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n\/\/ \"my_class.AA\"\nfunction Strongest_Extension(class_name: string, extensions: string[]): string {\n","canonical_solution":"function Strongest_Extension(class_name: string, extensions: string[]): string {\n    let strongestExtension = '';\n    let maxStrength = -Infinity;\n\n    extensions.forEach(extension => {\n        const capCount = extension.split('').filter(char => char >= 'A' && char <= 'Z').length;\n        const smCount = extension.split('').filter(char => char >= 'a' && char <= 'z').length;\n        const strength = capCount - smCount;\n\n        if (strength > maxStrength) {\n            maxStrength = strength;\n            strongestExtension = extension;\n        }\n    });\n\n    return `${class_name}.${strongestExtension}`;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = Strongest_Extension;\n  assert.deepEqual(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]),\"Watashi.eIGHt8OKe\");\n  assert.deepEqual(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]),\"Boku123.YEs.WeCaNe\");\n  assert.deepEqual(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]),\"__YESIMHERE.NuLl__\");\n  assert.deepEqual(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]),\"K.TAR\");\n  assert.deepEqual(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]),\"__HAHA.123\");\n  assert.deepEqual(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]),\"YameRore.okIWILL123\");\n  assert.deepEqual(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]),\"finNNalLLly.WoW\");\n  assert.deepEqual(candidate(\"_\", [\"Bb\", \"91245\"]),\"_.Bb\");\n  assert.deepEqual(candidate(\"Sp\", [\"671235\", \"Bb\"]),\"Sp.671235\");\n}\n\ntest();"},{"task_id":"HumanEval_154","nl":"dan_Latn","pl":"ts","prompt":"\/\/Du skal returnere true, hvis det andet ord eller en af dets rotationer er en understreng i det første ord.\/\/ >>> cycpattern_check(\"abcd\", \"abd\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"hello\", \"ell\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"whassup\", \"psus\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"abab\", \"baa\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"efef\", \"eeff\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"himenss\", \"simen\")\n\/\/ true\nfunction cycpattern_check(a: string, b: string): boolean {\n","canonical_solution":"function cycpattern_check(a: string, b: string): boolean {\n    for (let i = 0; i < b.length; i++) {\n        const rotation = b.slice(i) + b.slice(0, i);\n        if (a.includes(rotation)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\/\/ Test cases\nconsole.log(cycpattern_check(\"abcd\", \"abd\")); \/\/ false\nconsole.log(cycpattern_check(\"hello\", \"ell\")); \/\/ true\nconsole.log(cycpattern_check(\"whassup\", \"psus\")); \/\/ false\nconsole.log(cycpattern_check(\"abab\", \"baa\")); \/\/ true\nconsole.log(cycpattern_check(\"efef\", \"eeff\")); \/\/ false\nconsole.log(cycpattern_check(\"himenss\", \"simen\")); \/\/ true","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = cycpattern_check;\n  assert.deepEqual(candidate(\"xyzw\", \"xyw\"),false);\n  assert.deepEqual(candidate(\"yello\", \"ell\"),true);\n  assert.deepEqual(candidate(\"whattup\", \"ptut\"),false);\n  assert.deepEqual(candidate(\"efef\", \"fee\"),true);\n  assert.deepEqual(candidate(\"abab\", \"aabb\"),false);\n  assert.deepEqual(candidate(\"winemtt\", \"tinem\"),true);\n}\n\ntest();"},{"task_id":"HumanEval_155","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Givet et heltal. returnerer en matrix, der har antallet af lige og ulige cifre. \/\/ >>> even_odd_count(-12)\n\/\/ [1, 1]\n\/\/ >>> even_odd_count(123)\n\/\/ [1, 2]\nfunction even_odd_count(num: number): [number, number] {\n","canonical_solution":"function even_odd_count(num: number): [number, number] {\n    const numStr = Math.abs(num).toString();\n    let evenCount = 0;\n    let oddCount = 0;\n\n    for (let char of numStr) {\n        const digit = parseInt(char);\n        if (digit % 2 === 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n\n    return [evenCount, oddCount];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = even_odd_count;\n  assert.deepEqual(candidate(7),[0, 1]);\n  assert.deepEqual(candidate(-78),[1, 1]);\n  assert.deepEqual(candidate(3452),[2, 2]);\n  assert.deepEqual(candidate(346211),[3, 3]);\n  assert.deepEqual(candidate(-345821),[3, 3]);\n  assert.deepEqual(candidate(-2),[1, 0]);\n  assert.deepEqual(candidate(-45347),[2, 3]);\n  assert.deepEqual(candidate(0),[1, 0]);\n}\n\ntest();"},{"task_id":"HumanEval_156","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler: \/\/1 <= num <= 1000 \/\/og returnerer det med små bogstaver. \/\/Hvis vi har et positivt heltal, kan vi finde dets romerske talækvivalent i form af en streng, \/\/ >>> int_to_mini_roman(19)\n\/\/ \"xix\"\n\/\/ >>> int_to_mini_roman(152)\n\/\/ \"clii\"\n\/\/ >>> int_to_mini_roman(426)\n\/\/ \"cdxxvi\"\nfunction int_to_mini_roman(number: number): string {\n","canonical_solution":"function int_to_mini_roman(number: number): string {\n    const romanNumerals: { [key: number]: string } = {\n        1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c',\n        90: 'xc', 50: 'l', 40: 'xl', 10: 'x', 9: 'ix',\n        5: 'v', 4: 'iv', 1: 'i'\n    };\n    \n    let result = '';\n    for (const value of Object.keys(romanNumerals).map(Number).sort((a, b) => b - a)) {\n        while (number >= value) {\n            result += romanNumerals[value];\n            number -= value;\n        }\n    }\n    \n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = int_to_mini_roman;\n  assert.deepEqual(candidate(19),\"xix\");\n  assert.deepEqual(candidate(152),\"clii\");\n  assert.deepEqual(candidate(251),\"ccli\");\n  assert.deepEqual(candidate(426),\"cdxxvi\");\n  assert.deepEqual(candidate(500),\"d\");\n  assert.deepEqual(candidate(1),\"i\");\n  assert.deepEqual(candidate(4),\"iv\");\n  assert.deepEqual(candidate(43),\"xliii\");\n  assert.deepEqual(candidate(90),\"xc\");\n  assert.deepEqual(candidate(94),\"xciv\");\n  assert.deepEqual(candidate(532),\"dxxxii\");\n  assert.deepEqual(candidate(900),\"cm\");\n  assert.deepEqual(candidate(994),\"cmxciv\");\n  assert.deepEqual(candidate(1000),\"m\");\n}\n\ntest();"},{"task_id":"HumanEval_157","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/90 grader.\/\/En retvinklet trekant er en trekant, hvor en vinkel er retvinkel eller \/\/siderne danner en retvinklet trekant, ellers er det falsk.\/\/Givet længderne på de tre sider af en trekant, returnerer vi true, hvis de tre \/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/ true\n\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/ false\nfunction right_angle_triangle(a: number, b: number, c: number): boolean {\n","canonical_solution":"function right_angle_triangle(a: number, b: number, c: number): boolean {\n    const sides = [a, b, c].sort((x, y) => x - y);\n    return Math.pow(sides[0], 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = right_angle_triangle;\n  assert.deepEqual(candidate(3, 4, 5),true);\n  assert.deepEqual(candidate(1, 2, 3),false);\n  assert.deepEqual(candidate(10, 6, 8),true);\n  assert.deepEqual(candidate(2, 2, 2),false);\n  assert.deepEqual(candidate(7, 24, 25),true);\n  assert.deepEqual(candidate(10, 5, 7),false);\n  assert.deepEqual(candidate(5, 12, 13),true);\n  assert.deepEqual(candidate(15, 8, 17),true);\n  assert.deepEqual(candidate(48, 55, 73),true);\n  assert.deepEqual(candidate(1, 1, 1),false);\n  assert.deepEqual(candidate(2, 2, 10),false);\n}\n\ntest();"},{"task_id":"HumanEval_158","nl":"dan_Latn","pl":"ts","prompt":"\/\/Hvis der er tale om en række tegn, returneres den, der kommer først i leksikografisk rækkefølge.\/\/Hvis flere strenge har et maksimalt antal unikke \/\/Matrizen indeholder forskellige ord. Returnerer ordet med det maksimale antal \/\/Skriv en funktion, der accepterer en række af strenge.\/\/ >>> find_max([\"name\", \"of\", \"string\"])\n\/\/ \"string\"\n\/\/ >>> find_max([\"name\", \"enam\", \"game\"])\n\/\/ \"enam\"\n\/\/ >>> find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n\/\/ \"aaaaaaa\"\nfunction find_max(words: string[]): string {\n","canonical_solution":"function find_max(words: string[]): string {\n    function uniqueCharacterCount(word: string): number {\n        const uniqueChars = new Set(word);\n        return uniqueChars.size;\n    }\n\n    let maxWord = words[0];\n    let maxUniqueCount = uniqueCharacterCount(maxWord);\n\n    for (let i = 1; i < words.length; i++) {\n        const currentUniqueCount = uniqueCharacterCount(words[i]);\n        if (\n            currentUniqueCount > maxUniqueCount ||\n            (currentUniqueCount === maxUniqueCount && words[i] < maxWord)\n        ) {\n            maxWord = words[i];\n            maxUniqueCount = currentUniqueCount;\n        }\n    }\n\n    return maxWord;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = find_max;\n  assert.deepEqual(candidate([\"name\", \"of\", \"string\"]),\"string\");\n  assert.deepEqual(candidate([\"name\", \"enam\", \"game\"]),\"enam\");\n  assert.deepEqual(candidate([\"aaaaaaa\", \"bb\", \"cc\"]),\"aaaaaaa\");\n  assert.deepEqual(candidate([\"abc\", \"cba\"]),\"abc\");\n  assert.deepEqual(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]),\"footbott\");\n  assert.deepEqual(candidate([\"we\", \"are\", \"gonna\", \"rock\"]),\"gonna\");\n  assert.deepEqual(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]),\"nation\");\n  assert.deepEqual(candidate([\"this\", \"is\", \"a\", \"prrk\"]),\"this\");\n  assert.deepEqual(candidate([\"b\"]),\"b\");\n  assert.deepEqual(candidate([\"play\", \"play\", \"play\"]),\"play\");\n}\n\ntest();"},{"task_id":"HumanEval_159","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempel: \/\/Hvis der ikke er nok gulerødder tilbage, vil du spise alle de resterende gulerødder, men du vil stadig være sulten.\/\/antallet af gulerødder efter måltiderne ] \/\/du skal returnere en række af [det samlede antal spiste gulerødder efter måltiderne, \/\/Men nu skal du spise flere gulerødder for at fuldføre dagens måltider.\/\/Du er en sulten kanin, og du har allerede spist et vist antal gulerødder.\/\/ >>> eat(5, 6, 10)\n\/\/ [11, 4]\n\/\/ >>> eat(4, 8, 9)\n\/\/ [12, 1]\n\/\/ >>> eat(1, 10, 10)\n\/\/ [11, 0]\n\/\/ >>> eat(2, 11, 5)\n\/\/ [7, 0]\n\/\/ Variables:\n\/\/ @number : integer\n\/\/ the number of carrots that you have eaten.\n\/\/ @need : integer\n\/\/ the number of carrots that you need to eat.\n\/\/ @remaining : integer\n\/\/ the number of remaining carrots thet exist in stock\n\/\/ Constrain:\n\/\/ * 0 <= number <= 1000\n\/\/ * 0 <= need <= 1000\n\/\/ * 0 <= remaining <= 1000\n\/\/ Have fun :)\nfunction eat(number: number, need: number, remaining: number): number[] {\n","canonical_solution":"function eat(number: number, need: number, remaining: number): number[] {\n    const totalEaten = number + Math.min(need, remaining);\n    const carrotsLeft = Math.max(remaining - need, 0);\n    return [totalEaten, carrotsLeft];\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = eat;\n  assert.deepEqual(candidate(5, 6, 10),[11, 4]);\n  assert.deepEqual(candidate(4, 8, 9),[12, 1]);\n  assert.deepEqual(candidate(1, 10, 10),[11, 0]);\n  assert.deepEqual(candidate(2, 11, 5),[7, 0]);\n  assert.deepEqual(candidate(4, 5, 7),[9, 2]);\n  assert.deepEqual(candidate(4, 5, 1),[5, 0]);\n}\n\ntest();"},{"task_id":"HumanEval_160","nl":"dan_Latn","pl":"ts","prompt":"\/\/Operatorarray har mindst én operator, og operandarray har mindst to operander.\/\/Operanden er en række af ikke-negative heltal.\/\/Længden af operatorarray er lig med længden af operandarray minus én.\/\/Bemærk: \/\/=> Resultat = 9 \/\/Resultatet er 2 + 3 * 4 - 5 .\/\/array = [2, 3, 4, 5] \/\/Operatøren ['+', '*', '-'] \/\/Eksempel: \/\/Eksponentiering (**) \/\/Guldinddeling ( \/\/) \/\/Multiplikation (*) \/\/Afdrag ( - ) \/\/Tilsætning (+) \/\/De grundlæggende algebraoperationer:\/\/udtryk og returnere evalueringen af dette udtryk. \/\/Den anden matrix er en matrix af heltal. Brug de to matrix til at bygge algebraen.\/\/Den første matrix har grundlæggende algebraoperationer, og function do_algebra(operator: string[], operand: number[]): number {\n","canonical_solution":"function do_algebra(operator: string[], operand: number[]): number {\n    let expression = operand[0].toString();\n\n    for (let i = 0; i < operator.length; i++) {\n        expression += ` ${operator[i]} ${operand[i + 1]}`;\n    }\n\n    return Math.floor(eval(expression));\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = do_algebra;\n  assert.deepEqual(candidate([\"**\", \"*\", \"+\"], [2, 3, 4, 5]),37);\n  assert.deepEqual(candidate([\"+\", \"*\", \"-\"], [2, 3, 4, 5]),9);\n  assert.deepEqual(candidate([\"\/\/\", \"*\"], [7, 3, 4]),8);\n}\n\ntest();"},{"task_id":"HumanEval_161","nl":"dan_Latn","pl":"ts","prompt":"\/\/Eksempler \/\/Funktionen skal returnere den resulterende streng. \/\/Hvis strengen ikke indeholder nogen bogstaver, skal strengen vendes.\/\/Ellers bevares det, som det er.\/\/Hvis s[i] er et bogstav, vendes bogstavet fra ned til op eller omvendt.\/\/Du får en streng s.\/\/ >>> solve(\"1234\")\n\/\/ \"4321\"\n\/\/ >>> solve(\"ab\")\n\/\/ \"AB\"\n\/\/ >>> solve(\"#a@C\")\n\/\/ \"#A@c\"\nfunction solve(s: string): string {\n","canonical_solution":"function solve(s: string): string {\n    let hasLetter = \/[a-zA-Z]\/.test(s);\n    if (hasLetter) {\n        return s.split('').map(char => {\n            if (\/[a-z]\/.test(char)) {\n                return char.toUpperCase();\n            } else if (\/[A-Z]\/.test(char)) {\n                return char.toLowerCase();\n            } else {\n                return char;\n            }\n        }).join('');\n    } else {\n        return s.split('').reverse().join('');\n    }\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = solve;\n  assert.deepEqual(candidate(\"AsDf\"),\"aSdF\");\n  assert.deepEqual(candidate(\"1234\"),\"4321\");\n  assert.deepEqual(candidate(\"ab\"),\"AB\");\n  assert.deepEqual(candidate(\"#a@C\"),\"#A@c\");\n  assert.deepEqual(candidate(\"#AsdfW^45\"),\"#aSDFw^45\");\n  assert.deepEqual(candidate(\"#6@2\"),\"2@6#\");\n  assert.deepEqual(candidate(\"#$a^D\"),\"#$A^d\");\n  assert.deepEqual(candidate(\"#ccc\"),\"#CCC\");\n}\n\ntest();"},{"task_id":"HumanEval_162","nl":"dan_Latn","pl":"ts","prompt":"\/\/Hvis 'text' er en tom streng, returneres undefined. \/\/Hvis der er givet en streng 'text', returneres dens md5-hash-ækvivalente streng. \/\/ >>> string_to_md5(\"Hello world\")\n\/\/ \"3e25960a79dbc69b674cd4ec67a72c62\"\nfunction string_to_md5(text: string): string | undefined {\n","canonical_solution":"import * as crypto from 'crypto';\n\nfunction string_to_md5(text: string): string | undefined {\n    if (text === \"\") {\n        return undefined;\n    }\n    return crypto.createHash('md5').update(text).digest('hex');\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = string_to_md5;\n  assert.deepEqual(candidate(\"Hello world\"),\"3e25960a79dbc69b674cd4ec67a72c62\");\n  assert.deepEqual(candidate(\"\"),undefined);\n  assert.deepEqual(candidate(\"A B C\"),\"0ef78513b0cb8cef12743f5aeb35f888\");\n  assert.deepEqual(candidate(\"password\"),\"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n\ntest();"},{"task_id":"HumanEval_163","nl":"dan_Latn","pl":"ts","prompt":"\/\/For eksempel: \/\/og b, i stigende rækkefølge. \/\/Givet to positive heltal a og b, returnerer vi de lige cifre mellem a \/\/ >>> generate_integers(2, 8)\n\/\/ [2, 4, 6, 8]\n\/\/ >>> generate_integers(8, 2)\n\/\/ [2, 4, 6, 8]\n\/\/ >>> generate_integers(10, 14)\n\/\/ []\nfunction generate_integers(a: number, b: number): number[] {\n","canonical_solution":"function generate_integers(a: number, b: number): number[] {\n    let result: number[] = [];\n    \n    \/\/ Get starting and ending points in sorted order\n    let start = Math.min(a, b);\n    let end = Math.max(a, b);\n    \n    \/\/ Loop through the range\n    for (let i = start; i <= end; i++) {\n        if (i % 2 === 0) {  \/\/ Check if the digit is even\n            result.push(i);\n        }\n    }\n    \n    return result;\n}","tests":"declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = generate_integers;\n  assert.deepEqual(candidate(2, 10),[2, 4, 6, 8]);\n  assert.deepEqual(candidate(10, 2),[2, 4, 6, 8]);\n  assert.deepEqual(candidate(132, 2),[2, 4, 6, 8]);\n  assert.deepEqual(candidate(17, 89),[]);\n}\n\ntest();"}]