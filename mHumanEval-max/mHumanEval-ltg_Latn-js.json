[{"task_id":"HumanEval_0","nl":"ltg_Latn","pl":"js","prompt":"\/ pīduovuotais slīkšņa leimiņs. \/Pruovēt, voi dūtā skaitļu sareikumā ir div skaitli tyvuok vīns ūtram nakai \/\/ >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n\/\/ false\n\/\/ >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n\/\/ true\nfunction has_close_elements(numbers, threshold){\n","canonical_solution":"function has_close_elements(numbers, threshold) {\n    \/\/ First, sort the array to ensure we check adjacency for closest elements\n    numbers.sort((a, b) => a - b);\n\n    \/\/ Iterate through the sorted list and check differences between successive elements\n    for (let i = 0; i < numbers.length - 1; i++) {\n        if (Math.abs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = has_close_elements;\n  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),true);\n  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),false);\n  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95),true);\n  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8),false);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),true);\n  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0),true);\n  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5),false);\n}\n\ntest();"},{"task_id":"HumanEval_1","nl":"ltg_Latn","pl":"js","prompt":"\/ Ignorej īejis stringā īvītuotūs atstarpeņus. \/ Vīna grupai ir sovaižuok (kotra atvārtuo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo stypruo sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty sty\/ atseviškūs ryndūs i atdūd tūs matricys.\/Itei funkcejis īvode ir rynds, kas satur vairuokys īkļautuos lūpkuortys grupys. Tovs mierkis ir \/\/ >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n\/\/ [\"()\", \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string){\n","canonical_solution":"function separate_paren_groups(paren_string) {\n    paren_string = paren_string.replace(\/\\s+\/g, ''); \/\/ Remove spaces\n    const groups = [];\n    let balance = 0;\n    let currentGroup = '';\n\n    for (let char of paren_string) {\n        currentGroup += char;\n        if (char === '(') {\n            balance++;\n        } else if (char === ')') {\n            balance--;\n        }\n        \n        if (balance === 0) {\n            groups.push(currentGroup);\n            currentGroup = '';\n        }\n    }\n\n    return groups;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();"},{"task_id":"HumanEval_2","nl":"ltg_Latn","pl":"js","prompt":"\/ Atdūd skaitļa decimaldaļu. \/ (pylna daļa vysod mozuoka par 1). \/ i vasaluo daļa (leluokais vasals skaitlis mozuoks par nūteiktu skaitli) i decimalpunkti \/Dūdūt pozitivu ūsys punktu skaitli, tū var sadaleit \/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunction truncate_number(number){\n","canonical_solution":"function truncate_number(number) {\n    return number - Math.floor(number);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = truncate_number;\n  assert.deepEqual(candidate(3.5),0.5);\n  assert.deepEqual(candidate(1.25),0.25);\n  assert.deepEqual(candidate(123.0),0.0);\n}\n\ntest();"},{"task_id":"HumanEval_3","nl":"ltg_Latn","pl":"js","prompt":"\/ itymā punktā funkcejai juobyut patīsai. Cytaidā gadīnī juobyut napareigai.Tova aizdavuma ir atkluot, voi kaidā šaļtī konta saldo krīt zam nulle, i Tev teik pīduovuots vysaids īejis i izīšonys darbeibu saroksts bankys kontā, kas suocās ar\/\/ >>> below_zero([1, 2, 3])\n\/\/ false\n\/\/ >>> below_zero([1, 2, -4, 5])\n\/\/ true\nfunction below_zero(operations){\n","canonical_solution":"function below_zero(operations) {\n    let balance = 0;\n    for (let i = 0; i < operations.length; i++) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = below_zero;\n  assert.deepEqual(candidate([]),false);\n  assert.deepEqual(candidate([1, 2, -3, 1, 2, -3]),false);\n  assert.deepEqual(candidate([1, 2, -4, 5, 6]),true);\n  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -4]),false);\n  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -5]),true);\n  assert.deepEqual(candidate([1, -2, 2, -2, 5, -5, 4, -4]),true);\n}\n\ntest();"},{"task_id":"HumanEval_4","nl":"ltg_Latn","pl":"js","prompt":"\/ MAD = vidējais. x - x_means. \/ elements i centra punkts (mejā itymā gadīnī): \/ Vydslāgts absolutuo atškireiba ir videjuo absolutuo atškireiba storp kotru \/ ap vidiejuo ituo datu kūpa. \/Par nūteiktu datu datu datu sereju apriekinuoti vidīnejuo absolutuo atškireiba.\/\/ >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n\/\/ 1.0\nfunction mean_absolute_deviation(numbers){\n","canonical_solution":"function mean_absolute_deviation(numbers) {\n    const n = numbers.length;\n    if (n === 0) return 0;\n\n    const mean = numbers.reduce((acc, val) => acc + val, 0) \/ n;\n    const deviations = numbers.map(num => Math.abs(num - mean));\n    const mad = deviations.reduce((acc, val) => acc + val, 0) \/ n;\n\n    return mad;\n}\n\n\/\/ Example usage:\nconsole.log(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])); \/\/ Output: 1.0","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = mean_absolute_deviation;\n  assert.deepEqual(candidate([1.0, 2.0]),0.5);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0]),1.0);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),1.2);\n}\n\ntest();"},{"task_id":"HumanEval_5","nl":"ltg_Latn","pl":"js","prompt":"\/Pastuot skaitli \"delimiter\" storp kotrim divom secūšom īejis kuortu elementuom `numbers' \/\/ >>> intersperse([], 4)\n\/\/ []\n\/\/ >>> intersperse([1, 2, 3], 4)\n\/\/ [1, 4, 2, 4, 3]\nfunction intersperse(numbers, delimeter){\n","canonical_solution":"function intersperse(numbers, delimiter) {\n    if (numbers.length === 0) return [];\n    \n    const result = [];\n    for (let i = 0; i < numbers.length - 1; i++) {\n        result.push(numbers[i]);\n        result.push(delimiter);\n    }\n    result.push(numbers[numbers.length - 1]);\n\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = intersperse;\n  assert.deepEqual(candidate([], 7),[]);\n  assert.deepEqual(candidate([5, 6, 3, 2], 8),[5, 8, 6, 8, 3, 8, 2]);\n  assert.deepEqual(candidate([2, 2, 2], 2),[2, 2, 2, 2, 2]);\n}\n\ntest();"},{"task_id":"HumanEval_6","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru, (() (()) ir maksimāli diveji niveli, bet ((())) treis. \/ Kotrai nu grupys izpiļdeit dziļuokū korpusūs īkuortuojumu. \/Šys funkcejis īejis viersyuna ir vairuokys grupys, kas ir īkļautys īkļautūs korpusūs, kas atškireiti ar atstarpeibom. \/\/ >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n\/\/ [2, 3, 1, 3]\nfunction parse_nested_parens(paren_string){\n","canonical_solution":"function parse_nested_parens(paren_string) {\n    \/\/ Split the input string into groups based on spaces\n    const groups = paren_string.split(' ');\n    \/\/ Map each group to its maximum nesting depth\n    return groups.map(group => {\n        let maxDepth = 0;\n        let currentDepth = 0;\n\n        \/\/ Iterate through each character in the group\n        for (let char of group) {\n            if (char === '(') {\n                \/\/ Increment current depth for '('\n                currentDepth++;\n                \/\/ Update max depth if it's greater than the previous max\n                if (currentDepth > maxDepth) {\n                    maxDepth = currentDepth;\n                }\n            } else if (char === ')') {\n                \/\/ Decrement current depth for ')'\n                currentDepth--;\n            }\n        }\n        \n        return maxDepth; \/\/ Return max depth of this group\n    });\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = parse_nested_parens;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"),[2, 3, 1, 3]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[1, 2, 3, 4]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[4]);\n}\n\ntest();"},{"task_id":"HumanEval_7","nl":"ltg_Latn","pl":"js","prompt":"\/Filtrēt īejis viļņu kuortu, kas satur nūteiktu apakškuortu.\/\/ >>> filter_by_substring([], \"a\")\n\/\/ []\n\/\/ >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n\/\/ [\"abc\", \"bacd\", \"array\"]\nfunction filter_by_substring(strings, substring){\n","canonical_solution":"function filter_by_substring(strings, substring) {\n    return strings.filter(str => str.includes(substring));\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = filter_by_substring;\n  assert.deepEqual(candidate([], \"john\"),[]);\n  assert.deepEqual(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"),[\"xxx\", \"xxxAAA\", \"xxx\"]);\n  assert.deepEqual(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"),[\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n  assert.deepEqual(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"),[\"grunt\", \"prune\"]);\n}\n\ntest();"},{"task_id":"HumanEval_8","nl":"ltg_Latn","pl":"js","prompt":"\/ Vyltai summai juobyut 0, i tukšam produktam juobyut 1. \/Pie tam nūteiktajim vasalūs skaitļu sareikom atdūd sareiku, kas sastuov nu vysūs vasalūs skaitļu sareiku summa i reizynuojums.\/\/ >>> sum_product([])\n\/\/ [0, 1]\n\/\/ >>> sum_product([1, 2, 3, 4])\n\/\/ [10, 24]\nfunction sum_product(numbers){\n","canonical_solution":"function sum_product(numbers) {\n    let sum = 0;\n    let product = 1;\n\n    for (let i = 0; i < numbers.length; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return [sum, product];\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sum_product;\n  assert.deepEqual(candidate([]),[0, 1]);\n  assert.deepEqual(candidate([1, 1, 1]),[3, 1]);\n  assert.deepEqual(candidate([100, 0]),[100, 0]);\n  assert.deepEqual(candidate([3, 5, 7]),[15, 105]);\n  assert.deepEqual(candidate([10]),[10, 10]);\n}\n\ntest();"},{"task_id":"HumanEval_9","nl":"ltg_Latn","pl":"js","prompt":"\/ sekvencejā. \/Nu nūteiktu vasalūs skaitļu sareikuojuma generēsim nūteiktajā momentā atrostū maksimaluo vierteiguo elementa sareikuojumu.\/\/ >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n\/\/ [1, 2, 3, 3, 3, 4, 4]\nfunction rolling_max(numbers){\n","canonical_solution":"function rolling_max(numbers) {\n    let result = [];\n    let currentMax = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < numbers.length; i++) {\n        currentMax = Math.max(currentMax, numbers[i]);\n        result.push(currentMax);\n    }\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = rolling_max;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);\n  assert.deepEqual(candidate([4, 3, 2, 1]),[4, 4, 4, 4]);\n  assert.deepEqual(candidate([3, 2, 3, 100, 3]),[3, 3, 3, 100, 100]);\n}\n\ntest();"},{"task_id":"HumanEval_10","nl":"ltg_Latn","pl":"js","prompt":"\/ - Pīsavīnoj string prefiksa string prefiksa beiguos, kas ir pyrma palindromu sufiksa. \/ - Atrodi ilgstūšuo postfiksa nūdrūsynuotuos ryndys, kas ir palindroms. \/ Algoritma ideja ir vīnkuorša: Atrodi īsū palindromu, kas suocās ar nūdrukuotū ryndkūpu.\/\/ >>> make_palindrome(\"\")\n\/\/ \"\"\n\/\/ >>> make_palindrome(\"cat\")\n\/\/ \"catac\"\n\/\/ >>> make_palindrome(\"cata\")\n\/\/ \"catac\"\nfunction make_palindrome(string){\n","canonical_solution":"function make_palindrome(string) {\n    \/\/ Helper function to check if a string is a palindrome\n    function isPalindrome(s) {\n        let left = 0;\n        let right = s.length - 1;\n        while (left < right) {\n            if (s[left] !== s[right]) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    \/\/ Find the longest palindromic suffix\n    let longestPalindromicSuffixLength = 0;\n    for (let i = 0; i < string.length; i++) {\n        if (isPalindrome(string.slice(i))) {\n            longestPalindromicSuffixLength = string.length - i;\n            break;\n        }\n    }\n\n    \/\/ Create the shortest palindrome\n    const prefixToReverse = string.slice(0, string.length - longestPalindromicSuffixLength);\n    const reversedPrefix = prefixToReverse.split('').reverse().join('');\n    return string + reversedPrefix;\n}\n\n\/\/ Examples\nconsole.log(make_palindrome(\"\"));     \/\/ \"\"\nconsole.log(make_palindrome(\"cat\"));  \/\/ \"catac\"\nconsole.log(make_palindrome(\"cata\")); \/\/ \"catac\"","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = make_palindrome;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"x\"),\"x\");\n  assert.deepEqual(candidate(\"xyz\"),\"xyzyx\");\n  assert.deepEqual(candidate(\"xyx\"),\"xyx\");\n  assert.deepEqual(candidate(\"jerry\"),\"jerryrrej\");\n}\n\ntest();"},{"task_id":"HumanEval_11","nl":"ltg_Latn","pl":"js","prompt":"\/ Izpiļdeit binaruos XOR iz itim īejom i atsagrīzt rezultatam ari kai ryndam. \/Iejis ir divejis stringys a i b, kas sastuov nu 1 i 0 vīņu. \/\/ >>> string_xor(\"010\", \"110\")\n\/\/ \"100\"\nfunction string_xor(a, b){\n","canonical_solution":"function string_xor(a, b) {\n    let result = \"\";\n    for (let i = 0; i < a.length; i++) {\n        result += (a[i] === b[i]) ? \"0\" : \"1\";\n    }\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = string_xor;\n  assert.deepEqual(candidate(\"111000\", \"101010\"),\"010010\");\n  assert.deepEqual(candidate(\"1\", \"1\"),\"0\");\n  assert.deepEqual(candidate(\"0101\", \"0000\"),\"0101\");\n}\n\ntest();"},{"task_id":"HumanEval_12","nl":"ltg_Latn","pl":"js","prompt":"\/ vīnaida garuma stringys. Atguodynoj nedefinātu gadīnī, ka īejis vuordskuorsts ir tukšs. \/Nu stringu viersyunys atsoka leluokū. atsoka pyrmū, ka ir vairuokys stringu viersyunys.\/\/ >>> longest([])\n\/\/ undefined\n\/\/ >>> longest([\"a\", \"b\", \"c\"])\n\/\/ \"a\"\n\/\/ >>> longest([\"a\", \"bb\", \"ccc\"])\n\/\/ \"ccc\"\nfunction longest(strings){\n","canonical_solution":"function longest(strings) {\n    if (strings.length === 0) return undefined;\n    let longestString = strings[0];\n\n    for (let i = 1; i < strings.length; i++) {\n        if (strings[i].length > longestString.length) {\n            longestString = strings[i];\n        }\n    }\n\n    return longestString;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = longest;\n  assert.deepEqual(candidate([]),undefined);\n  assert.deepEqual(candidate([\"x\", \"y\", \"z\"]),\"x\");\n  assert.deepEqual(candidate([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]),\"zzzz\");\n}\n\ntest();"},{"task_id":"HumanEval_13","nl":"ltg_Latn","pl":"js","prompt":"\/Atdūd leluokū kūpeigū daleituoju nu diveju vasalūs skaitļu a i b \/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunction greatest_common_divisor(a, b){\n","canonical_solution":"function greatest_common_divisor(a, b) {\n    while (b !== 0) {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = greatest_common_divisor;\n  assert.deepEqual(candidate(3, 7),1);\n  assert.deepEqual(candidate(10, 15),5);\n  assert.deepEqual(candidate(49, 14),7);\n  assert.deepEqual(candidate(144, 60),12);\n}\n\ntest();"},{"task_id":"HumanEval_14","nl":"ltg_Latn","pl":"js","prompt":"\/Atdūd vysu prefiksu viersrokstu nu īkšejūs da ilgokūs īejis kuortu.\/\/ >>> all_prefixes(\"abc\")\n\/\/ [\"a\", \"ab\", \"abc\"]\nfunction all_prefixes(string){\n","canonical_solution":"function all_prefixes(string) {\n    let prefixes = [];\n    for (let i = 1; i <= string.length; i++) {\n        prefixes.push(string.substring(0, i));\n    }\n    return prefixes;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = all_prefixes;\n  assert.deepEqual(candidate(\"\"),[]);\n  assert.deepEqual(candidate(\"asdfgh\"),[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]);\n  assert.deepEqual(candidate(\"WWW\"),[\"W\", \"WW\", \"WWW\"]);\n}\n\ntest();"},{"task_id":"HumanEval_15","nl":"ltg_Latn","pl":"js","prompt":"\/Atdūd ryndys, kas satur telpā īrūbežuotys skaitļus, suocūt nu 0 leidz n.\/\/ >>> string_sequence(0)\n\/\/ \"0\"\n\/\/ >>> string_sequence(5)\n\/\/ \"0 1 2 3 4 5\"\nfunction string_sequence(n){\n","canonical_solution":"function string_sequence(n) {\n    let result = [];\n    for (let i = 0; i <= n; i++) {\n        result.push(i);\n    }\n    return result.join(' ');\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = string_sequence;\n  assert.deepEqual(candidate(0),\"0\");\n  assert.deepEqual(candidate(3),\"0 1 2 3\");\n  assert.deepEqual(candidate(10),\"0 1 2 3 4 5 6 7 8 9 10\");\n}\n\ntest();"},{"task_id":"HumanEval_16","nl":"ltg_Latn","pl":"js","prompt":"\/Dūdūt string, atrassi, cik daudz atsevišku raksturu (naatkareigi nu burtu) tys sastuov nu \/\/ >>> count_distinct_characters(\"xyzXYZ\")\n\/\/ 3\n\/\/ >>> count_distinct_characters(\"Jerry\")\n\/\/ 4\nfunction count_distinct_characters(string){\n","canonical_solution":"function count_distinct_characters(string) {\n    \/\/ Convert the string to lowercase to ignore case differences\n    const lowercaseString = string.toLowerCase();\n    \/\/ Create a Set to store distinct characters\n    const distinctChars = new Set();\n    \/\/ Iterate over each character in the string\n    for (let char of lowercaseString) {\n        distinctChars.add(char); \/\/ Add character to the set\n    }\n    \/\/ Return the size of the set which represents the number of distinct characters\n    return distinctChars.size;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = count_distinct_characters;\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"abcde\"),5);\n  assert.deepEqual(candidate(\"abcdecadeCADE\"),5);\n  assert.deepEqual(candidate(\"aaaaAAAAaaaa\"),1);\n  assert.deepEqual(candidate(\"Jerry jERRY JeRRRY\"),5);\n}\n\ntest();"},{"task_id":"HumanEval_17","nl":"ltg_Latn","pl":"js","prompt":"\"Dīveņ\" - četruos notys, ilgoj vīnu beitu.\/'o sašaideja' - pusnota, ilga divejis bejis.\/ \"o\" - vysa nota, ilga četri trīcīņi.Ite ir legenda:\/ nav pādejais. \/ Tovs uzdavums ir puorbaudeit itū ryndkūpu i atsyuteit vasalūs skaitļu sakuortuojumu, kas atbylst cik bīži kotrs bejs.\/Šys funkcejis īejis ir saitis, kas attāluos muzykys notys eipašā ASCII formatā. \/\/ >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n\/\/ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunction parse_music(music_string){\n","canonical_solution":"function parse_music(music_string) {\n    let notes = music_string.split(\" \");\n    let beats = [];\n\n    for (let note of notes) {\n        switch (note) {\n            case 'o':\n                beats.push(4);\n                break;\n            case 'o|':\n                beats.push(2);\n                break;\n            case '.|':\n                beats.push(1);\n                break;\n            default:\n                \/\/ Handle unexpected notes if necessary\n                break;\n        }\n    }\n    return beats;\n}\n\n\/\/ Example usage:\n\/\/ console.log(parse_music(\"o o| .| o| o| .| .| .| .| o o\")); \n\/\/ Output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = parse_music;\n  assert.deepEqual(candidate(\"\"),[]);\n  assert.deepEqual(candidate(\"o o o o\"),[4, 4, 4, 4]);\n  assert.deepEqual(candidate(\".| .| .| .|\"),[1, 1, 1, 1]);\n  assert.deepEqual(candidate(\"o| o| .| .| o o o o\"),[2, 2, 1, 1, 4, 4, 4, 4]);\n  assert.deepEqual(candidate(\"o| .| o| .| o o| o o|\"),[2, 1, 2, 1, 4, 2, 4, 2]);\n}\n\ntest();"},{"task_id":"HumanEval_18","nl":"ltg_Latn","pl":"js","prompt":"\/Skaiti, cik reižu īteiktuos apakšregu var atrast suokūtnejā reigā.\/\/ >>> how_many_times(\"\", \"a\")\n\/\/ 0\n\/\/ >>> how_many_times(\"aaa\", \"a\")\n\/\/ 3\n\/\/ >>> how_many_times(\"aaaa\", \"aa\")\n\/\/ 3\nfunction how_many_times(string, substring){\n","canonical_solution":"function how_many_times(string, substring) {\n  if (substring.length === 0) return 0;\n  \n  let count = 0;\n  let position = 0;\n  \n  while ((position = string.indexOf(substring, position)) !== -1) {\n    count++;\n    position++;\n  }\n  \n  return count;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = how_many_times;\n  assert.deepEqual(candidate(\"\", \"x\"),0);\n  assert.deepEqual(candidate(\"xyxyxyx\", \"x\"),4);\n  assert.deepEqual(candidate(\"cacacacac\", \"cac\"),4);\n  assert.deepEqual(candidate(\"john doe\", \"john\"),1);\n}\n\ntest();"},{"task_id":"HumanEval_19","nl":"ltg_Latn","pl":"js","prompt":"\/ Atdūd ryndys ar skaitlim, kas sakuortuoti nu mozuokūs da leluokūs \/ Lykumeigys izvēlis ir \"nul\", \"vīns\", \"div\", \"trys\", \"četri\", \"pīci\", \"seši\", \"septi\", \"oši\" i \"noudi\". \/Iejums ir telpā īrūbežuota skaitļu kuorta nu \"nulle\" leidz \"nou\". \/\/ >>> sort_numbers(\"three one five\")\n\/\/ \"one three five\"\nfunction sort_numbers(numbers){\n","canonical_solution":"function sort_numbers(numbers) {\n    const numberWords = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];\n    \n    return numbers\n        .split(' ')\n        .sort((a, b) => numberWords.indexOf(a) - numberWords.indexOf(b))\n        .join(' ');\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_numbers;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"three\"),\"three\");\n  assert.deepEqual(candidate(\"three five nine\"),\"three five nine\");\n  assert.deepEqual(candidate(\"five zero four seven nine eight\"),\"zero four five seven eight nine\");\n  assert.deepEqual(candidate(\"six five four three two one zero\"),\"zero one two three four five six\");\n}\n\ntest();"},{"task_id":"HumanEval_20","nl":"ltg_Latn","pl":"js","prompt":"\/ cyti i atsyuti tūs kuorteibā (mozuoks skaits, leluoks skaits).\/Nu pīguoduotuo skaitļu sareikuojuma (nu vysmoz diveju) izavielej i atsyuti divejus, kas ir tyvuok kotram.\/\/ >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/ [2.0, 2.2]\n\/\/ >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/ [2.0, 2.0]\nfunction find_closest_elements(numbers){\n","canonical_solution":"function find_closest_elements(numbers) {\n    if (numbers.length < 2) {\n        throw new Error('Array must contain at least two elements.');\n    }\n    \n    numbers.sort((a, b) => a - b);\n\n    let minDiff = Infinity;\n    let closestPair = [numbers[0], numbers[1]];\n\n    for (let i = 0; i < numbers.length - 1; i++) {\n        let diff = numbers[i + 1] - numbers[i];\n        if (diff < minDiff) {\n            minDiff = diff;\n            closestPair = [numbers[i], numbers[i + 1]];\n        }\n    }\n\n    return closestPair;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = find_closest_elements;\n  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0]);\n  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0]),[5.0, 5.9]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),[2.0, 2.2]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),[2.0, 2.0]);\n  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2, 3.1]);\n}\n\ntest();"},{"task_id":"HumanEval_21","nl":"ltg_Latn","pl":"js","prompt":"\/ tai, ka mozuokais skaitlis palīk par 0, leluokais palīk par 1 \/Dūdams skaitļu sareiku (nu vysmoz diveju elementu), pīlītuojit linearū transformaceju tam sareiku, \/\/ >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/ [0.0, 0.25, 0.5, 0.75, 1.0]\nfunction rescale_to_unit(numbers){\n","canonical_solution":"function rescale_to_unit(numbers) {\n    if (numbers.length < 2) {\n        throw new Error(\"Array must contain at least two elements.\");\n    }\n    \n    let min = Math.min(...numbers);\n    let max = Math.max(...numbers);\n    \n    return numbers.map(num => (num - min) \/ (max - min));\n}\n\n\/\/ Example usage\nconsole.log(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])); \/\/ [0.0, 0.25, 0.5, 0.75, 1.0]","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = rescale_to_unit;\n  assert.deepEqual(candidate([2.0, 49.9]),[0.0, 1.0]);\n  assert.deepEqual(candidate([100.0, 49.9]),[1.0, 0.0]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5, 0.75, 1.0]);\n  assert.deepEqual(candidate([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);\n  assert.deepEqual(candidate([12.0, 11.0, 15.0, 13.0, 14.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n\ntest();"},{"task_id":"HumanEval_22","nl":"ltg_Latn","pl":"js","prompt":"\/Filtrēt nūteiktu viļņu nu sevkurys jsthon vierteibys tikai par vasalūs skaitļu \/\/ >>> filter_integers([\"a\", 3.14, 5])\n\/\/ [5]\n\/\/ >>> filter_integers([1, 2, 3, \"abc\", {}, []])\n\/\/ [1, 2, 3]\nfunction filter_integers(values){\n","canonical_solution":"function filter_integers(values) {\n    return values.filter(value => Number.isInteger(value));\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = filter_integers;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([4, {}, [], 23.2, 9, \"adasd\"]),[4, 9]);\n  assert.deepEqual(candidate([3, \"c\", 3, 3, \"a\", \"b\"]),[3, 3, 3]);\n}\n\ntest();"},{"task_id":"HumanEval_23","nl":"ltg_Latn","pl":"js","prompt":"\/Atvītynoj nūteiktu stringu garumu.\/\/ >>> strlen(\"\")\n\/\/ 0\n\/\/ >>> strlen(\"abc\")\n\/\/ 3\nfunction strlen(string){\n","canonical_solution":"function strlen(string) {\n    return string.length;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = strlen;\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"x\"),1);\n  assert.deepEqual(candidate(\"asdasnakj\"),9);\n}\n\ntest();"},{"task_id":"HumanEval_24","nl":"ltg_Latn","pl":"js","prompt":"\/Pi nūteiktu skaitli n atrodi leluokū skaitli, kas n divda leidzvierteigi, mozuokū par n \/\/ >>> largest_divisor(15)\n\/\/ 5\nfunction largest_divisor(n){\n","canonical_solution":"function largest_divisor(n) {\n    for (let i = n - 1; i > 0; i--) {\n        if (n % i === 0) {\n            return i;\n        }\n    }\n    return 1; \/\/ for the edge case where n is 1\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = largest_divisor;\n  assert.deepEqual(candidate(3),1);\n  assert.deepEqual(candidate(7),1);\n  assert.deepEqual(candidate(10),5);\n  assert.deepEqual(candidate(100),50);\n  assert.deepEqual(candidate(49),7);\n}\n\ntest();"},{"task_id":"HumanEval_25","nl":"ltg_Latn","pl":"js","prompt":"\/ Īejis skaitļam juobyut vīnaidam ar vysu faktoru reizynuojumu.\/ Kotram faktoram juopīmiņ reizis, kas atbylst tū skaitam, cik reižu tys pasaruoda faktorizēšonā. \/Atdūd datu pylna skaitļa pyrmskaitļu faktoru viersrokstu nu mozuokūs da leluokūs. \/\/ >>> factorize(8)\n\/\/ [2, 2, 2]\n\/\/ >>> factorize(25)\n\/\/ [5, 5]\n\/\/ >>> factorize(70)\n\/\/ [2, 5, 7]\nfunction factorize(n){\n","canonical_solution":"function factorize(n) {\n    const factors = [];\n    let divisor = 2;\n\n    while (n >= 2) {\n        if (n % divisor === 0) {\n            factors.push(divisor);\n            n \/= divisor;\n        } else {\n            divisor++;\n        }\n    }\n\n    return factors;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"},{"task_id":"HumanEval_26","nl":"ltg_Latn","pl":"js","prompt":"\/ Lai elementu seceiba byutu vīnaida kai īejis datumā. \/Nu vasalūs skaitļu sareikuojuma nūjimsim vysus elementus, kas pasaruoda vairuok kai vīnu reizi.\/\/ >>> remove_duplicates([1, 2, 3, 2, 4])\n\/\/ [1, 3, 4]\nfunction remove_duplicates(numbers){\n","canonical_solution":"function remove_duplicates(numbers) {\n    const frequency = {};\n    \/\/ Count occurrences of each number\n    numbers.forEach(num => {\n        frequency[num] = (frequency[num] || 0) + 1;\n    });\n\n    \/\/ Filter out numbers that occur more than once\n    return numbers.filter(num => frequency[num] === 1);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = remove_duplicates;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);\n  assert.deepEqual(candidate([1, 2, 3, 2, 4, 3, 5]),[1, 4, 5]);\n}\n\ntest();"},{"task_id":"HumanEval_27","nl":"ltg_Latn","pl":"js","prompt":"\/Par nūteiktu stringu, mainuos burtu burtus puorskaiti iz leluos burtu burtu i leluos burtu burtu iz mainuos burtu. \/\/ >>> flip_case(\"Hello\")\n\/\/ \"hELLO\"\nfunction flip_case(string){\n","canonical_solution":"function flip_case(string) {\n    let flippedString = '';\n    for (let i = 0; i < string.length; i++) {\n        const char = string[i];\n        if (char === char.toLowerCase()) {\n            flippedString += char.toUpperCase();\n        } else {\n            flippedString += char.toLowerCase();\n        }\n    }\n    return flippedString;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = flip_case;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"Hello!\"),\"hELLO!\");\n  assert.deepEqual(candidate(\"These violent delights have violent ends\"),\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\");\n}\n\ntest();"},{"task_id":"HumanEval_28","nl":"ltg_Latn","pl":"js","prompt":"\/Konkatenēt snāgtu viersu kūpumu vīnā snāgumā.\/\/ >>> concatenate([])\n\/\/ \"\"\n\/\/ >>> concatenate([\"a\", \"b\", \"c\"])\n\/\/ \"abc\"\nfunction concatenate(strings){\n","canonical_solution":"function concatenate(strings) {\n    return strings.join('');\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = concatenate;\n  assert.deepEqual(candidate([]),\"\");\n  assert.deepEqual(candidate([\"x\", \"y\", \"z\"]),\"xyz\");\n  assert.deepEqual(candidate([\"x\", \"y\", \"z\", \"w\", \"k\"]),\"xyzwk\");\n}\n\ntest();"},{"task_id":"HumanEval_29","nl":"ltg_Latn","pl":"js","prompt":"\/Filtrēt īejis viļņu kuortu viļņu kuortu, kas suocās ar nūteiktu prefiksu. \/\/ >>> filter_by_prefix([], \"a\")\n\/\/ []\n\/\/ >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n\/\/ [\"abc\", \"array\"]\nfunction filter_by_prefix(strings, prefix){\n","canonical_solution":"function filter_by_prefix(strings, prefix) {\n    return strings.filter(str => str.startsWith(prefix));\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = filter_by_prefix;\n  assert.deepEqual(candidate([], \"john\"),[]);\n  assert.deepEqual(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"),[\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\n\ntest();"},{"task_id":"HumanEval_30","nl":"ltg_Latn","pl":"js","prompt":"\/Atdūd tikai pozitivus skaitļus matricā.\/\/ >>> get_positive([-1, 2, -4, 5, 6])\n\/\/ [2, 5, 6]\n\/\/ >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/ [5, 3, 2, 3, 9, 123, 1]\nfunction get_positive(l){\n","canonical_solution":"function get_positive(l) {\n    return l.filter(function(num) {\n        return num > 0;\n    });\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_positive;\n  assert.deepEqual(candidate([-1, -2, 4, 5, 6]),[4, 5, 6]);\n  assert.deepEqual(candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]),[5, 3, 2, 3, 3, 9, 123, 1]);\n  assert.deepEqual(candidate([-1, -2]),[]);\n  assert.deepEqual(candidate([]),[]);\n}\n\ntest();"},{"task_id":"HumanEval_31","nl":"ltg_Latn","pl":"js","prompt":"\/Atguodynoj patīsu, ka nūteikts skaitlis ir pyrmskaitlis, i nā cytaiž.\/\/ >>> is_prime(6)\n\/\/ false\n\/\/ >>> is_prime(101)\n\/\/ true\n\/\/ >>> is_prime(11)\n\/\/ true\n\/\/ >>> is_prime(13441)\n\/\/ true\n\/\/ >>> is_prime(61)\n\/\/ true\n\/\/ >>> is_prime(4)\n\/\/ false\n\/\/ >>> is_prime(1)\n\/\/ false\nfunction is_prime(n){\n","canonical_solution":"function is_prime(n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n  \n    if (n % 2 === 0 || n % 3 === 0) return false;\n  \n    for (let i = 5; i * i <= n; i += 6) {\n        if (n % i === 0 || n % (i + 2) === 0) return false;\n    }\n  \n    return true;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_prime;\n  assert.deepEqual(candidate(6),false);\n  assert.deepEqual(candidate(101),true);\n  assert.deepEqual(candidate(11),true);\n  assert.deepEqual(candidate(13441),true);\n  assert.deepEqual(candidate(61),true);\n  assert.deepEqual(candidate(4),false);\n  assert.deepEqual(candidate(1),false);\n  assert.deepEqual(candidate(5),true);\n  assert.deepEqual(candidate(11),true);\n  assert.deepEqual(candidate(17),true);\n  assert.deepEqual(candidate(85),false);\n  assert.deepEqual(candidate(77),false);\n  assert.deepEqual(candidate(255379),false);\n}\n\ntest();"},{"task_id":"HumanEval_33","nl":"ltg_Latn","pl":"js","prompt":"\/ leidzīņūs indeksu vierteibom, bet sortuojušuos.\/ l' ir identiska ar l indeksūs, kas nav daleigi ar treis, tok tuos vierteibys indeksūs, kas ir daleigi ar treis, ir vīnaidys.\/Itei funkceja pajam array l i atdūd array l', taidu, ka \/\/ >>> sort_third([1, 2, 3])\n\/\/ [1, 2, 3]\n\/\/ >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n\/\/ [2, 6, 3, 4, 8, 9, 5]\nfunction sort_third(l){\n","canonical_solution":"function sort_third(l) {\n    \/\/ Extract the elements at indices divisible by 3\n    const elementsToSort = [];\n    for (let i = 0; i < l.length; i++) {\n        if (i % 3 === 0) {\n            elementsToSort.push(l[i]);\n        }\n    }\n    \n    \/\/ Sort the extracted elements\n    elementsToSort.sort((a, b) => a - b);\n\n    \/\/ Place the sorted elements back into their original positions\n    let sortedIndex = 0;\n    for (let i = 0; i < l.length; i++) {\n        if (i % 3 === 0) {\n            l[i] = elementsToSort[sortedIndex++];\n        }\n    }\n    \n    return l;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_third;\n  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2]),[2, 6, 3, 4, 8, 9, 5]);\n  assert.deepEqual(candidate([5, 8, 3, 4, 6, 9, 2]),[2, 8, 3, 4, 6, 9, 5]);\n  assert.deepEqual(candidate([5, 6, 9, 4, 8, 3, 2]),[2, 6, 9, 4, 8, 3, 5]);\n  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2, 1]),[2, 6, 3, 4, 8, 9, 5, 1]);\n}\n\ntest();"},{"task_id":"HumanEval_34","nl":"ltg_Latn","pl":"js","prompt":"\/Atguodynoj sortuojušūs unikalu elementu kūpumu.\/\/ >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/ [0, 2, 3, 5, 9, 123]\nfunction unique(l){\n","canonical_solution":"function unique(l) {\n    \/\/ Use a Set to remove duplicates and then spread into an array\n    const uniqueElements = [...new Set(l)];\n    \/\/ Sort the array in ascending order\n    uniqueElements.sort((a, b) => a - b);\n    return uniqueElements;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = unique;\n  assert.deepEqual(candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9, 123]);\n}\n\ntest();"},{"task_id":"HumanEval_35","nl":"ltg_Latn","pl":"js","prompt":"\/Atdūd maksimaluo elementa matrica.\/\/ >>> max_element([1, 2, 3])\n\/\/ 3\n\/\/ >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/ 123\nfunction max_element(l){\n","canonical_solution":"function max_element(l) {\n    if (l.length === 0) return undefined; \/\/ Return undefined if the array is empty\n    return Math.max(...l);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_element;\n  assert.deepEqual(candidate([1, 2, 3]),3);\n  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]),124);\n}\n\ntest();"},{"task_id":"HumanEval_36","nl":"ltg_Latn","pl":"js","prompt":"\/Atdūd cipra 7 reižu skaitu, kod tys pasaruoda vītom, kur skaitli ir mozuoki par n i kas ir daleigi ar 11 voi 13. \/\/ >>> fizz_buzz(50)\n\/\/ 0\n\/\/ >>> fizz_buzz(78)\n\/\/ 2\n\/\/ >>> fizz_buzz(79)\n\/\/ 3\nfunction fizz_buzz(n){\n","canonical_solution":"function fizz_buzz(n) {\n    let count = 0;\n    \n    for (let i = 1; i < n; i++) {\n        if (i % 11 === 0 || i % 13 === 0) {\n            let numStr = i.toString();\n            for (let char of numStr) {\n                if (char === '7') {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fizz_buzz;\n  assert.deepEqual(candidate(50),0);\n  assert.deepEqual(candidate(78),2);\n  assert.deepEqual(candidate(79),3);\n  assert.deepEqual(candidate(100),3);\n  assert.deepEqual(candidate(200),6);\n  assert.deepEqual(candidate(4000),192);\n  assert.deepEqual(candidate(10000),639);\n  assert.deepEqual(candidate(100000),8026);\n}\n\ntest();"},{"task_id":"HumanEval_37","nl":"ltg_Latn","pl":"js","prompt":"\/ leidz l pāra indeksu vierteibom, bet sakuortuoti. \/ l' ir identiska ar l najaušajuos indeksūs, tok tuos vierteibys reizis indeksūs ir vīnaidys \/Itei funkceja pajam array l i atdūd array l', taidu, ka \/\/ >>> sort_even([1, 2, 3])\n\/\/ [1, 2, 3]\n\/\/ >>> sort_even([5, 6, 3, 4])\n\/\/ [3, 6, 5, 4]\nfunction sort_even(l){\n","canonical_solution":"function sort_even(l) {\n    \/\/ Extract the elements at even indices\n    let evenElements = [];\n    for (let i = 0; i < l.length; i += 2) {\n        evenElements.push(l[i]);\n    }\n\n    \/\/ Sort the even elements\n    evenElements.sort((a, b) => a - b);\n\n    \/\/ Reconstruct the array with sorted even indices\n    let result = [];\n    let evenIndex = 0;\n    for (let i = 0; i < l.length; i++) {\n        if (i % 2 === 0) {\n            result.push(evenElements[evenIndex]);\n            evenIndex++;\n        } else {\n            result.push(l[i]);\n        }\n    }\n\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_even;\n  assert.deepEqual(candidate([1, 2, 3]),[1, 2, 3]);\n  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n  assert.deepEqual(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n\ntest();"},{"task_id":"HumanEval_39","nl":"ltg_Latn","pl":"js","prompt":"\/prime_fib atdūd n-ū skaitli, kas ir Fibonači skaitlis i tys ir ari pyrmskaitlis.\/\/ >>> prime_fib(1)\n\/\/ 2\n\/\/ >>> prime_fib(2)\n\/\/ 3\n\/\/ >>> prime_fib(3)\n\/\/ 5\n\/\/ >>> prime_fib(4)\n\/\/ 13\n\/\/ >>> prime_fib(5)\n\/\/ 89\nfunction prime_fib(n){\n","canonical_solution":"function prime_fib(n) {\n    function isPrime(num) {\n        if (num < 2) return false;\n        for (let i = 2; i * i <= num; i++) {\n            if (num % i === 0) return false;\n        }\n        return true;\n    }\n    \n    function fibonacci() {\n        let a = 0, b = 1;\n        return function() {\n            const next = a + b;\n            a = b;\n            b = next;\n            return a;\n        };\n    }\n\n    const fib = fibonacci();\n    let count = 0;\n    let primeFibNum;\n\n    while (count < n) {\n        const fibNum = fib();\n        if (isPrime(fibNum)) {\n            count++;\n            primeFibNum = fibNum;\n        }\n    }\n\n    return primeFibNum;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = prime_fib;\n  assert.deepEqual(candidate(1),2);\n  assert.deepEqual(candidate(2),3);\n  assert.deepEqual(candidate(3),5);\n  assert.deepEqual(candidate(4),13);\n  assert.deepEqual(candidate(5),89);\n  assert.deepEqual(candidate(6),233);\n  assert.deepEqual(candidate(7),1597);\n  assert.deepEqual(candidate(8),28657);\n  assert.deepEqual(candidate(9),514229);\n  assert.deepEqual(candidate(10),433494437);\n}\n\ntest();"},{"task_id":"HumanEval_40","nl":"ltg_Latn","pl":"js","prompt":"\/ sums leidz nullei, i cytaiž - nā. \/ tys atvierš patīsu, ka matricā ir treis atškireigi elementi, kas \/triples_sum_to_zero īnese vītni ar vasalūs skaitļu.\/\/ >>> triples_sum_to_zero([1, 3, 5, 0])\n\/\/ false\n\/\/ >>> triples_sum_to_zero([1, 3, -2, 1])\n\/\/ true\n\/\/ >>> triples_sum_to_zero([1, 2, 3, 7])\n\/\/ false\n\/\/ >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n\/\/ true\n\/\/ >>> triples_sum_to_zero([1])\n\/\/ false\nfunction triples_sum_to_zero(l){\n","canonical_solution":"function triples_sum_to_zero(l) {\n    \/\/ Sort the array first\n    l.sort((a, b) => a - b);\n    \/\/ Iterate through each element in the array\n    for (let i = 0; i < l.length - 2; i++) {\n        \/\/ Use two pointers to find the other two elements\n        let left = i + 1;\n        let right = l.length - 1;\n        while (left < right) {\n            const sum = l[i] + l[left] + l[right];\n            if (sum === 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = triples_sum_to_zero;\n  assert.deepEqual(candidate([1, 3, 5, 0]),false);\n  assert.deepEqual(candidate([1, 3, 5, -1]),false);\n  assert.deepEqual(candidate([1, 3, -2, 1]),true);\n  assert.deepEqual(candidate([1, 2, 3, 7]),false);\n  assert.deepEqual(candidate([1, 2, 5, 7]),false);\n  assert.deepEqual(candidate([2, 4, -5, 3, 9, 7]),true);\n  assert.deepEqual(candidate([1]),false);\n  assert.deepEqual(candidate([1, 3, 5, -100]),false);\n  assert.deepEqual(candidate([100, 3, 5, -100]),false);\n}\n\ntest();"},{"task_id":"HumanEval_41","nl":"ltg_Latn","pl":"js","prompt":"\/ Itei funkceja izsoka itaidu sadursmu skaitu. \/ sovā trajektorejā, kai ka jī natyka sasaskuoruse. Tok mašynys ir bezgaleigi styprys i spieceigys, deļtuo tuos turpynoj kusteit.\/ kod mašyna, kas brauc pa kreisi, sadurs ar mašynu, kas brauc pa labi.Vysi mašynys brauc ar vīnu i tū pošu dreizumu.Div mašynu grupys suocās cīši tuoli nu ūtrys pusis.\/n mašynys brauc kreisā iz lobū; reizē cyts n mašynys kūpskaits Īsadūmojit ceļu, kas ir piļneigi taisna bezgaleigi gara.function car_race_collision(n){\n","canonical_solution":"function car_race_collision(n) {\n    \/\/ Each car moving left to right will collide with each car moving right to left exactly once.\n    \/\/ Therefore, the number of collisions is n * n.\n    return n * n;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = car_race_collision;\n  assert.deepEqual(candidate(2),4);\n  assert.deepEqual(candidate(3),9);\n  assert.deepEqual(candidate(4),16);\n  assert.deepEqual(candidate(8),64);\n  assert.deepEqual(candidate(10),100);\n}\n\ntest();"},{"task_id":"HumanEval_42","nl":"ltg_Latn","pl":"js","prompt":"\/Atgriež matrica ar elementim, kas pīaug ar 1. \/\/ >>> incr_list([1, 2, 3])\n\/\/ [2, 3, 4]\n\/\/ >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/ [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunction incr_list(l){\n","canonical_solution":"function incr_list(l) {\n    return l.map(element => element + 1);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = incr_list;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([3, 2, 1]),[4, 3, 2]);\n  assert.deepEqual(candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]),[6, 3, 6, 3, 4, 4, 10, 1, 124]);\n}\n\ntest();"},{"task_id":"HumanEval_43","nl":"ltg_Latn","pl":"js","prompt":"\/ sums leidz nullei, i cytaiž - nā. \/ tys atvierš patīsu, ka matricā ir diveji atškireigi elementi, kas \/pairs_sum_to_zero īnese vītni ar vasalūs skaitļu sakuortu.\/\/ >>> pairs_sum_to_zero([1, 3, 5, 0])\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([1, 3, -2, 1])\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([1, 2, 3, 7])\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n\/\/ true\n\/\/ >>> pairs_sum_to_zero([1])\n\/\/ false\nfunction pairs_sum_to_zero(l){\n","canonical_solution":"function pairs_sum_to_zero(l) {\n    const seen = new Set();\n    \n    for (const num of l) {\n        if (seen.has(-num)) {\n            return true;\n        }\n        seen.add(num);\n    }\n    \n    return false;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pairs_sum_to_zero;\n  assert.deepEqual(candidate([1, 3, 5, 0]),false);\n  assert.deepEqual(candidate([1, 3, -2, 1]),false);\n  assert.deepEqual(candidate([1, 2, 3, 7]),false);\n  assert.deepEqual(candidate([2, 4, -5, 3, 5, 7]),true);\n  assert.deepEqual(candidate([1]),false);\n  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 30]),true);\n  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 31]),true);\n  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 30]),false);\n  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 31]),false);\n}\n\ntest();"},{"task_id":"HumanEval_44","nl":"ltg_Latn","pl":"js","prompt":"\/ bazis skaitli ir mozuoki par 10. \/ atdūd string puorstuovi piec konvertiešonys. \/Maina numeriskū īejis skaitļa x bazis. \/\/ >>> change_base(8, 3)\n\/\/ \"22\"\n\/\/ >>> change_base(8, 2)\n\/\/ \"1000\"\n\/\/ >>> change_base(7, 2)\n\/\/ \"111\"\nfunction change_base(x, base){\n","canonical_solution":"function change_base(x, base) {\n    if (base < 2 || base > 9) {\n        throw new Error(\"Base must be between 2 and 9.\");\n    }\n\n    if (x === 0) {\n        return \"0\";\n    }\n\n    let result = '';\n    while (x > 0) {\n        result = (x % base) + result;\n        x = Math.floor(x \/ base);\n    }\n\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = change_base;\n  assert.deepEqual(candidate(8, 3),\"22\");\n  assert.deepEqual(candidate(9, 3),\"100\");\n  assert.deepEqual(candidate(234, 2),\"11101010\");\n  assert.deepEqual(candidate(16, 2),\"10000\");\n  assert.deepEqual(candidate(8, 2),\"1000\");\n  assert.deepEqual(candidate(7, 2),\"111\");\n  assert.deepEqual(candidate(2, 3),\"2\");\n  assert.deepEqual(candidate(3, 4),\"3\");\n  assert.deepEqual(candidate(4, 5),\"4\");\n  assert.deepEqual(candidate(5, 6),\"5\");\n  assert.deepEqual(candidate(6, 7),\"6\");\n  assert.deepEqual(candidate(7, 8),\"7\");\n}\n\ntest();"},{"task_id":"HumanEval_45","nl":"ltg_Latn","pl":"js","prompt":"\/Dzeivu garums i augstuo atkuortuošonys laukums trejstyura deļ. \/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunction triangle_area(a, h){\n","canonical_solution":"function triangle_area(a, h) {\n    return 0.5 * a * h;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = triangle_area;\n  assert.deepEqual(candidate(5, 3),7.5);\n  assert.deepEqual(candidate(2, 2),2.0);\n  assert.deepEqual(candidate(10, 8),40.0);\n}\n\ntest();"},{"task_id":"HumanEval_46","nl":"ltg_Latn","pl":"js","prompt":"\/ Lūdzu, pīraksteit funkceju, kab efektivi apriekinuotu fib4 skaitļu seceibys n-ū elementu. Naizmontojit rekursiju. \/ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). \/ fib4(3) -> 0 \/ fib4(2) -> 2 \/ fib4(1) -> 0 \/ fib4(0) -> 0 \/Fib4 skaitļu seceiba ir seceiba, kas leidzeiga Fibbonači seceibā, kas ir defināta tai: \/\/ >>> fib4(5)\n\/\/ 4\n\/\/ >>> fib4(6)\n\/\/ 8\n\/\/ >>> fib4(7)\n\/\/ 14\nfunction fib4(n){\n","canonical_solution":"function fib4(n) {\n    if (n === 0) return 0;\n    if (n === 1) return 0;\n    if (n === 2) return 2;\n    if (n === 3) return 0;\n    \n    let fibs = [0, 0, 2, 0];\n    \n    for (let i = 4; i <= n; i++) {\n        let nextFib = fibs[0] + fibs[1] + fibs[2] + fibs[3];\n        fibs.shift(); \/\/ Remove the first element\n        fibs.push(nextFib); \/\/ Add the new element to the end\n    }\n    \n    return fibs[3];\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fib4;\n  assert.deepEqual(candidate(5),4);\n  assert.deepEqual(candidate(8),28);\n  assert.deepEqual(candidate(10),104);\n  assert.deepEqual(candidate(12),386);\n}\n\ntest();"},{"task_id":"HumanEval_47","nl":"ltg_Latn","pl":"js","prompt":"\/Atguodynoju masveida l elementu medianu. \/\/ >>> median([3, 1, 2, 4, 5])\n\/\/ 3\n\/\/ >>> median([-10, 4, 6, 1000, 10, 20])\n\/\/ 15.0\nfunction median(l){\n","canonical_solution":"function median(l) {\n    \/\/ First, sort the array\n    l.sort((a, b) => a - b);\n\n    \/\/ Calculate the middle index\n    const mid = Math.floor(l.length \/ 2);\n\n    \/\/ If array length is odd, return the middle element\n    if (l.length % 2 !== 0) {\n        return l[mid];\n    }\n    \/\/ If array length is even, return the average of the two middle elements\n    else {\n        return (l[mid - 1] + l[mid]) \/ 2;\n    }\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = median;\n  assert.deepEqual(candidate([3, 1, 2, 4, 5]),3);\n  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);\n  assert.deepEqual(candidate([5]),5);\n  assert.deepEqual(candidate([6, 5]),5.5);\n  assert.deepEqual(candidate([8, 1, 3, 9, 9, 2, 7]),7);\n}\n\ntest();"},{"task_id":"HumanEval_48","nl":"ltg_Latn","pl":"js","prompt":"\/Pruovej, voi nūteikta stringis ir palindroms \/\/ >>> is_palindrome(\"\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aba\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aaaaa\")\n\/\/ true\n\/\/ >>> is_palindrome(\"zbcd\")\n\/\/ false\nfunction is_palindrome(text){\n","canonical_solution":"function is_palindrome(text){\n    \/\/ Remove non-alphanumeric characters and convert to lower case\n    const cleanedText = text.replace(\/[^a-zA-Z0-9]\/g, '').toLowerCase();\n    \/\/ Reverse the cleaned text\n    const reversedText = cleanedText.split('').reverse().join('');\n    \/\/ Check if the cleaned text is equal to its reverse\n    return cleanedText === reversedText;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_palindrome;\n  assert.deepEqual(candidate(\"\"),true);\n  assert.deepEqual(candidate(\"aba\"),true);\n  assert.deepEqual(candidate(\"aaaaa\"),true);\n  assert.deepEqual(candidate(\"zbcd\"),false);\n  assert.deepEqual(candidate(\"xywyx\"),true);\n  assert.deepEqual(candidate(\"xywyz\"),false);\n  assert.deepEqual(candidate(\"xywzx\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_49","nl":"ltg_Latn","pl":"js","prompt":"\/Atgriež 2^n modulo p (sajiuti skaitļus).\/\/ >>> modp(3, 5)\n\/\/ 3\n\/\/ >>> modp(1101, 101)\n\/\/ 2\n\/\/ >>> modp(0, 101)\n\/\/ 1\n\/\/ >>> modp(3, 11)\n\/\/ 8\n\/\/ >>> modp(100, 101)\n\/\/ 1\nfunction modp(n, p){\n","canonical_solution":"function modp(n, p) {\n    if (p === 1) return 0; \/\/ Base case when p is 1\n\n    \/\/ Initialize result\n    let result = 1;\n    let base = 2;\n\n    while (n > 0) {\n        \/\/ If n is odd, multiply base with result\n        if (n % 2 === 1) {\n            result = (result * base) % p;\n        }\n\n        \/\/ n must be even now\n        n = Math.floor(n \/ 2);\n        base = (base * base) % p; \n    }\n\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = modp;\n  assert.deepEqual(candidate(3, 5),3);\n  assert.deepEqual(candidate(1101, 101),2);\n  assert.deepEqual(candidate(0, 101),1);\n  assert.deepEqual(candidate(3, 11),8);\n  assert.deepEqual(candidate(100, 101),1);\n  assert.deepEqual(candidate(30, 5),4);\n  assert.deepEqual(candidate(31, 5),3);\n}\n\ntest();"},{"task_id":"HumanEval_51","nl":"ltg_Latn","pl":"js","prompt":"\/remove_vowels ir funkceja, kas pajam string i atdūd string bez vokalom.\/\/ >>> remove_vowels(\"\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"abcdef\")\n\/\/ \"bcdf\"\n\/\/ >>> remove_vowels(\"aaaaa\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"aaBAA\")\n\/\/ \"B\"\n\/\/ >>> remove_vowels(\"zbcd\")\n\/\/ \"zbcd\"\nfunction remove_vowels(text){\n","canonical_solution":"function remove_vowels(text) {\n    return text.replace(\/[aeiouAEIOU]\/g, '');\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = remove_vowels;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"abcdef\nghijklm\"),\"bcdf\nghjklm\");\n  assert.deepEqual(candidate(\"fedcba\"),\"fdcb\");\n  assert.deepEqual(candidate(\"eeeee\"),\"\");\n  assert.deepEqual(candidate(\"acBAA\"),\"cB\");\n  assert.deepEqual(candidate(\"EcBOO\"),\"cB\");\n  assert.deepEqual(candidate(\"ybcd\"),\"ybcd\");\n}\n\ntest();"},{"task_id":"HumanEval_52","nl":"ltg_Latn","pl":"js","prompt":"\/Atguodynoj patīsu, ka vysi skaitli matricā l ir zam kuortys t. \/\/ >>> below_threshold([1, 2, 4, 10], 100)\n\/\/ true\n\/\/ >>> below_threshold([1, 20, 4, 10], 5)\n\/\/ false\nfunction below_threshold(l, t){\n","canonical_solution":"function below_threshold(l, t) {\n    return l.every(num => num < t);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = below_threshold;\n  assert.deepEqual(candidate([1, 2, 4, 10], 100),true);\n  assert.deepEqual(candidate([1, 20, 4, 10], 5),false);\n  assert.deepEqual(candidate([1, 20, 4, 10], 21),true);\n  assert.deepEqual(candidate([1, 20, 4, 10], 22),true);\n  assert.deepEqual(candidate([1, 8, 4, 10], 11),true);\n  assert.deepEqual(candidate([1, 8, 4, 10], 10),false);\n}\n\ntest();"},{"task_id":"HumanEval_53","nl":"ltg_Latn","pl":"js","prompt":"\/Skaiti divejus skaitļus x i y.\/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunction add(x, y){\n","canonical_solution":"function add(x, y) {\n    return x + y;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = add;\n  assert.deepEqual(candidate(0, 1),1);\n  assert.deepEqual(candidate(1, 0),1);\n  assert.deepEqual(candidate(2, 3),5);\n  assert.deepEqual(candidate(5, 7),12);\n  assert.deepEqual(candidate(7, 5),12);\n}\n\ntest();"},{"task_id":"HumanEval_54","nl":"ltg_Latn","pl":"js","prompt":"\/Pruovēt, voi divejim vuordim ir taidi poši rakstīni. \/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"abcd\", \"dddddddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"dddddddabc\", \"abcd\")\n\/\/ true\n\/\/ >>> same_chars(\"eabcd\", \"dddddddabc\")\n\/\/ false\n\/\/ >>> same_chars(\"abcd\", \"dddddddabce\")\n\/\/ false\n\/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n\/\/ false\nfunction same_chars(s0, s1){\n","canonical_solution":"function same_chars(s0, s1) {\n    const charSet0 = new Set(s0);\n    const charSet1 = new Set(s1);\n\n    if (charSet0.size !== charSet1.size) return false;\n\n    for (let char of charSet0) {\n        if (!charSet1.has(char)) return false;\n    }\n\n    return true;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = same_chars;\n  assert.deepEqual(candidate(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"),true);\n  assert.deepEqual(candidate(\"abcd\", \"dddddddabc\"),true);\n  assert.deepEqual(candidate(\"dddddddabc\", \"abcd\"),true);\n  assert.deepEqual(candidate(\"eabcd\", \"dddddddabc\"),false);\n  assert.deepEqual(candidate(\"abcd\", \"dddddddabcf\"),false);\n  assert.deepEqual(candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"),false);\n  assert.deepEqual(candidate(\"aabb\", \"aaccc\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_55","nl":"ltg_Latn","pl":"js","prompt":"\/Atdūd n-ū Fibonači skaitli. \/\/ >>> fib(10)\n\/\/ 55\n\/\/ >>> fib(1)\n\/\/ 1\n\/\/ >>> fib(8)\n\/\/ 21\nfunction fib(n){\n","canonical_solution":"function fib(n) {\n    if (n <= 1) return n;\n    let a = 0, b = 1, result = 1;\n    for (let i = 2; i <= n; i++) {\n        result = a + b;\n        a = b;\n        b = result;\n    }\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fib;\n  assert.deepEqual(candidate(10),55);\n  assert.deepEqual(candidate(1),1);\n  assert.deepEqual(candidate(8),21);\n  assert.deepEqual(candidate(11),89);\n  assert.deepEqual(candidate(12),144);\n}\n\ntest();"},{"task_id":"HumanEval_56","nl":"ltg_Latn","pl":"js","prompt":"\/ atdūd taisneibu, ka kotram atkluošonys korpusam ir atbylstūšs aizlīguma korpuss. \/brackets ir \"<\" i \">\" ryndys.\/\/ >>> correct_bracketing(\"<\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"<>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"<<><>>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"><<>\")\n\/\/ false\nfunction correct_bracketing(brackets){\n","canonical_solution":"function correct_bracketing(brackets) {\n    let balance = 0;\n    for (let char of brackets) {\n        if (char === '<') {\n            balance += 1;\n        } else if (char === '>') {\n            balance -= 1;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance === 0;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = correct_bracketing;\n  assert.deepEqual(candidate(\"<>\"),true);\n  assert.deepEqual(candidate(\"<<><>>\"),true);\n  assert.deepEqual(candidate(\"<><><<><>><>\"),true);\n  assert.deepEqual(candidate(\"<><><<<><><>><>><<><><<>>>\"),true);\n  assert.deepEqual(candidate(\"<<<><>>>>\"),false);\n  assert.deepEqual(candidate(\"><<>\"),false);\n  assert.deepEqual(candidate(\"<\"),false);\n  assert.deepEqual(candidate(\"<<<<\"),false);\n  assert.deepEqual(candidate(\">\"),false);\n  assert.deepEqual(candidate(\"<<>\"),false);\n  assert.deepEqual(candidate(\"<><><<><>><>><<>\"),false);\n  assert.deepEqual(candidate(\"<><><<><>><>>><>\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_57","nl":"ltg_Latn","pl":"js","prompt":"\/Atguodynoju taisneibu, ka viersyunu elementi monotoni pīaug voi samazynoj.\/\/ >>> monotonic([1, 2, 4, 20])\n\/\/ true\n\/\/ >>> monotonic([1, 20, 4, 10])\n\/\/ false\n\/\/ >>> monotonic([4, 1, 0, -10])\n\/\/ true\nfunction monotonic(l){\n","canonical_solution":"function monotonic(l) {\n    if (l.length <= 1) return true;\n    let isIncreasing = true;\n    let isDecreasing = true;\n    \n    for (let i = 1; i < l.length; i++) {\n        if (l[i] > l[i - 1]) {\n            isDecreasing = false;\n        } else if (l[i] < l[i - 1]) {\n            isIncreasing = false;\n        }\n        \n        if (!isIncreasing && !isDecreasing) return false;\n    }\n    \n    return true;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = monotonic;\n  assert.deepEqual(candidate([1, 2, 4, 10]),true);\n  assert.deepEqual(candidate([1, 2, 4, 20]),true);\n  assert.deepEqual(candidate([1, 20, 4, 10]),false);\n  assert.deepEqual(candidate([4, 1, 0, -10]),true);\n  assert.deepEqual(candidate([4, 1, 1, 0]),true);\n  assert.deepEqual(candidate([1, 2, 3, 2, 5, 60]),false);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 60]),true);\n  assert.deepEqual(candidate([9, 9, 9, 9]),true);\n}\n\ntest();"},{"task_id":"HumanEval_58","nl":"ltg_Latn","pl":"js","prompt":"\/Atguodynoj divkuoršu sarokstātu unikalu kūpeigu elementu.\/\/ >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n\/\/ [1, 5, 653]\n\/\/ >>> common([5, 3, 2, 8], [3, 2])\n\/\/ [2, 3]\nfunction common(l1, l2){\n","canonical_solution":"function common(l1, l2) {\n    const set1 = new Set(l1);\n    const set2 = new Set(l2);\n    const result = [...set1].filter(item => set2.has(item));\n    return result.sort((a, b) => a - b);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = common;\n  assert.deepEqual(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);\n  assert.deepEqual(candidate([5, 3, 2, 8], [3, 2]),[2, 3]);\n  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2, 4]),[2, 3, 4]);\n  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);\n}\n\ntest();"},{"task_id":"HumanEval_59","nl":"ltg_Latn","pl":"js","prompt":"\/Atdūd leluokū n pyrmskaitļu faktoru. Dūmojam, ka n > 1 i tys nav pyrmskaitlis. \/\/ >>> largest_prime_factor(13195)\n\/\/ 29\n\/\/ >>> largest_prime_factor(2048)\n\/\/ 2\nfunction largest_prime_factor(n){\n","canonical_solution":"function largest_prime_factor(n) {\n  let largest = -1;\n  while (n % 2 === 0) {\n    largest = 2;\n    n \/= 2;\n  }\n  \n  for (let factor = 3; factor * factor <= n; factor += 2) {\n    while (n % factor === 0) {\n      largest = factor;\n      n \/= factor;\n    }\n  }\n  \n  if (n > 2) {\n    largest = n;\n  }\n  \n  return largest;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = largest_prime_factor;\n  assert.deepEqual(candidate(15),5);\n  assert.deepEqual(candidate(27),3);\n  assert.deepEqual(candidate(63),7);\n  assert.deepEqual(candidate(330),11);\n  assert.deepEqual(candidate(13195),29);\n}\n\ntest();"},{"task_id":"HumanEval_60","nl":"ltg_Latn","pl":"js","prompt":"\/sum_to_n ir funkceja, kas saskaita skaitļus nu 1 leidz n. \/\/ >>> sum_to_n(30)\n\/\/ 465\n\/\/ >>> sum_to_n(100)\n\/\/ 5050\n\/\/ >>> sum_to_n(5)\n\/\/ 15\n\/\/ >>> sum_to_n(10)\n\/\/ 55\n\/\/ >>> sum_to_n(1)\n\/\/ 1\nfunction sum_to_n(n){\n","canonical_solution":"function sum_to_n(n) {\n    return n * (n + 1) \/ 2;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sum_to_n;\n  assert.deepEqual(candidate(1),1);\n  assert.deepEqual(candidate(6),21);\n  assert.deepEqual(candidate(11),66);\n  assert.deepEqual(candidate(30),465);\n  assert.deepEqual(candidate(100),5050);\n}\n\ntest();"},{"task_id":"HumanEval_61","nl":"ltg_Latn","pl":"js","prompt":"\/ atdūd taisneibu, ka kotram atkluošonys korpusam ir atbylstūšs aizlīguma korpuss. \/brackets ir \"(\" i \"\") string.\/\/ >>> correct_bracketing(\"(\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"()\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"(()())\")\n\/\/ true\n\/\/ >>> correct_bracketing(\")(()\")\n\/\/ false\nfunction correct_bracketing(brackets){\n","canonical_solution":"function correct_bracketing(brackets) {\n    let balance = 0;\n    for (let i = 0; i < brackets.length; i++) {\n        if (brackets[i] === '(') {\n            balance++;\n        } else if (brackets[i] === ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance === 0;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = correct_bracketing;\n  assert.deepEqual(candidate(\"()\"),true);\n  assert.deepEqual(candidate(\"(()())\"),true);\n  assert.deepEqual(candidate(\"()()(()())()\"),true);\n  assert.deepEqual(candidate(\"()()((()()())())(()()(()))\"),true);\n  assert.deepEqual(candidate(\"((()())))\"),false);\n  assert.deepEqual(candidate(\")(()\"),false);\n  assert.deepEqual(candidate(\"(\"),false);\n  assert.deepEqual(candidate(\"((((\"),false);\n  assert.deepEqual(candidate(\")\"),false);\n  assert.deepEqual(candidate(\"(()\"),false);\n  assert.deepEqual(candidate(\"()()(()())())(()\"),false);\n  assert.deepEqual(candidate(\"()()(()())()))()\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_62","nl":"ltg_Latn","pl":"js","prompt":"\/ Atvīgloj ituo polinoma atvasynuotuoju taidai poša formā. \/ xs[0] + xs[1] * x + xs[2] * x^2 + .... \/xs ir polinoma koeficienti.\/\/ >>> derivative([3, 1, 2, 4, 5])\n\/\/ [1, 4, 12, 20]\n\/\/ >>> derivative([1, 2, 3])\n\/\/ [2, 6]\nfunction derivative(xs){\n","canonical_solution":"function derivative(xs) {\n    const result = [];\n    for (let i = 1; i < xs.length; i++) {\n        result.push(xs[i] * i);\n    }\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = derivative;\n  assert.deepEqual(candidate([3, 1, 2, 4, 5]),[1, 4, 12, 20]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 6]);\n  assert.deepEqual(candidate([3, 2, 1]),[2, 2]);\n  assert.deepEqual(candidate([3, 2, 1, 0, 4]),[2, 2, 0, 16]);\n  assert.deepEqual(candidate([1]),[]);\n}\n\ntest();"},{"task_id":"HumanEval_63","nl":"ltg_Latn","pl":"js","prompt":"\/ Lūdzu, pīraksteit funkceju, kab efektivi apriekinuotu fibfib skaitļu seceibys n-ū elementu. \/ fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). \/ fib fib ((2) == 1 \/ fibfib(1) == 0 \/ fibfib(0) == 0 \/FibFib skaitļu seceiba ir seceiba, kas leidzeiga Fibbonači seceibā, kas ir defināta tai: \/\/ >>> fibfib(1)\n\/\/ 0\n\/\/ >>> fibfib(5)\n\/\/ 4\n\/\/ >>> fibfib(8)\n\/\/ 24\nfunction fibfib(n){\n","canonical_solution":"function fibfib(n) {\n    if (n === 0 || n === 1) return 0;\n    if (n === 2) return 1;\n    \n    let a = 0, b = 0, c = 1, d;\n\n    for (let i = 3; i <= n; i++) {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    \n    return c;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fibfib;\n  assert.deepEqual(candidate(2),1);\n  assert.deepEqual(candidate(1),0);\n  assert.deepEqual(candidate(5),4);\n  assert.deepEqual(candidate(8),24);\n  assert.deepEqual(candidate(10),81);\n  assert.deepEqual(candidate(12),274);\n  assert.deepEqual(candidate(14),927);\n}\n\ntest();"},{"task_id":"HumanEval_64","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/vokals, bet tikai tod, kod tys ir nūteiktūs vuordu beiguos. \/ Vuordineica itymā gadīnī ir \"a\", \"e\", \"i\", \"o\", \"u\". Ite \"y\" ir ari a \/ vuordu kai īejis i atdūd vuordu seceibys vokalu skaitu. \/Skaiti funkceju vowels_count, kas pījam string, kas apzeimoj \/\/ >>> vowels_count(\"abcde\")\n\/\/ 2\n\/\/ >>> vowels_count(\"ACEDY\")\n\/\/ 3\nfunction vowels_count(s){\n","canonical_solution":"function vowels_count(s) {\n    const vowels = 'aeiou';\n    let count = 0;\n    s = s.toLowerCase();\n    \n    for (let i = 0; i < s.length; i++) {\n        if (vowels.includes(s[i]) || (i === s.length - 1 && s[i] === 'y')) {\n            count++;\n        }\n    }\n\n    return count;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = vowels_count;\n  assert.deepEqual(candidate(\"abcde\"),2);\n  assert.deepEqual(candidate(\"Alone\"),3);\n  assert.deepEqual(candidate(\"key\"),2);\n  assert.deepEqual(candidate(\"bye\"),1);\n  assert.deepEqual(candidate(\"keY\"),2);\n  assert.deepEqual(candidate(\"bYe\"),1);\n  assert.deepEqual(candidate(\"ACEDY\"),3);\n}\n\ntest();"},{"task_id":"HumanEval_65","nl":"ltg_Latn","pl":"js","prompt":"\/ Ka puorslāgums > ciparu skaits, atsagrīž cipari apgrīžami. \/ i atsagrīž rezultats kai string. \/Kruotiski puorviertej vasaluo skaitļa x cyparus, palaiž cyparus pa kreisi.\/\/ >>> circular_shift(12, 1)\n\/\/ \"21\"\n\/\/ >>> circular_shift(12, 2)\n\/\/ \"12\"\nfunction circular_shift(x, shift){\n","canonical_solution":"function circular_shift(x, shift) {\n    let numStr = x.toString();\n    let length = numStr.length;\n\n    if (shift > length) {\n        return numStr.split('').reverse().join('');\n    } else {\n        let endPart = numStr.slice(-shift);\n        let startPart = numStr.slice(0, length - shift);\n        return endPart + startPart;\n    }\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = circular_shift;\n  assert.deepEqual(candidate(100, 2),\"001\");\n  assert.deepEqual(candidate(12, 2),\"12\");\n  assert.deepEqual(candidate(97, 8),\"79\");\n  assert.deepEqual(candidate(12, 1),\"21\");\n  assert.deepEqual(candidate(11, 101),\"11\");\n}\n\ntest();"},{"task_id":"HumanEval_66","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ ASCII kodi. \/ Rakstīt funkceju, kas īnese burtu ciļvīti i atdūd tikai golvuos burtu sumys' \/Iepūdeits \/\/ >>> digitSum(\"\")\n\/\/ 0\n\/\/ >>> digitSum(\"abAB\")\n\/\/ 131\n\/\/ >>> digitSum(\"abcCd\")\n\/\/ 67\n\/\/ >>> digitSum(\"helloE\")\n\/\/ 69\n\/\/ >>> digitSum(\"woArBld\")\n\/\/ 131\n\/\/ >>> digitSum(\"aAaaaXa\")\n\/\/ 153\nfunction digitSum(s){\n","canonical_solution":"function digitSum(s) {\n    let sum = 0;\n    for (let i = 0; i < s.length; i++) {\n        let char = s[i];\n        if (char >= 'A' && char <= 'Z') {\n            sum += char.charCodeAt(0);\n        }\n    }\n    return sum;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = digitSum;\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"abAB\"),131);\n  assert.deepEqual(candidate(\"abcCd\"),67);\n  assert.deepEqual(candidate(\"helloE\"),69);\n  assert.deepEqual(candidate(\"woArBld\"),131);\n  assert.deepEqual(candidate(\"aAaaaXa\"),153);\n  assert.deepEqual(candidate(\" How are yOu?\"),151);\n  assert.deepEqual(candidate(\"You arE Very Smart\"),327);\n}\n\ntest();"},{"task_id":"HumanEval_67","nl":"ltg_Latn","pl":"js","prompt":"\/ par eksambolu: \/ kuorā atsoka mangys augļu skaitu kuorā. \/ apelsini i obuoli i vasals skaitlis, kas apzeimoj augļu kūpejū skaitu \/ obuoli, apelsini i mango augi. Dūdūt ryndys, kas apzeimoj kūpejū \/ kas ir izplateiti vīnā ūlboltā ar auglim, kas ir itymā ūlboltā.Itymā uzdavumā jums tiks pīduovuota rynds, kas apzeimoj vairuokus ūgļus i olūtus.\/\/ >>> fruit_distribution(\"5 apples and 6 oranges\", 19)\n\/\/ 8\n\/\/ >>> fruit_distribution(\"0 apples and 1 oranges\", 3)\n\/\/ 2\n\/\/ >>> fruit_distribution(\"2 apples and 3 oranges\", 100)\n\/\/ 95\n\/\/ >>> fruit_distribution(\"100 apples and 1 oranges\", 120)\n\/\/ 19\nfunction fruit_distribution(s, n){\n","canonical_solution":"function fruit_distribution(s, n) {\n    let apples = 0;\n    let oranges = 0;\n    \n    \/\/ Regular expressions to extract the number of apples and oranges from the string\n    const applesMatch = s.match(\/(\\d+)\\s*apples\/);\n    const orangesMatch = s.match(\/(\\d+)\\s*oranges\/);\n    \n    \/\/ If a match is found, parse the number\n    if (applesMatch) {\n        apples = parseInt(applesMatch[1], 10);\n    }\n    if (orangesMatch) {\n        oranges = parseInt(orangesMatch[1], 10);\n    }\n    \n    \/\/ Calculate the number of mangoes\n    const mangoes = n - (apples + oranges);\n    return mangoes;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fruit_distribution;\n  assert.deepEqual(candidate(\"5 apples and 6 oranges\", 19),8);\n  assert.deepEqual(candidate(\"5 apples and 6 oranges\", 21),10);\n  assert.deepEqual(candidate(\"0 apples and 1 oranges\", 3),2);\n  assert.deepEqual(candidate(\"1 apples and 0 oranges\", 3),2);\n  assert.deepEqual(candidate(\"2 apples and 3 oranges\", 100),95);\n  assert.deepEqual(candidate(\"2 apples and 3 oranges\", 5),0);\n  assert.deepEqual(candidate(\"1 apples and 100 oranges\", 120),19);\n}\n\ntest();"},{"task_id":"HumanEval_68","nl":"ltg_Latn","pl":"js","prompt":"\/ pīmārs 1: \/ Ka nav pat vierteibu voi dāts kuorteiba ir tukša, atsagrīž []. \/ Atsauktū mezglu byutu juoaizvuorej matricā, [ smalest_value, tuo indeksa ], \/ Ka ir atrosts vairuokys molu ar vīnu i tū pošu mozuokū pat vierteibu, atsoka molu ar mozuokū indeksu. \/ Izkuortuotajam meikstam juobyut meikstam ar mozuokū pat vierteibu. Tovs uzdavums ir nūjimt vīnu nu mezglu i atdūt tū atpakaļ.\/\"Dūdūt maisi, kas apzeimoj kūka nūdaļu, kurai ir naenegai vasalu skaitļu molu \/\/ >>> pluck([4, 2, 3])\n\/\/ [2, 1]\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 2:\n\/\/ >>> pluck([1, 2, 3])\n\/\/ [2, 1]\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 3:\n\/\/ >>> pluck([])\n\/\/ []\n\/\/ Example 4:\n\/\/ >>> pluck([5, 0, 3, 0, 4, 2])\n\/\/ [0, 1]\n\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/ so we will choose the first zero, which has the smallest index.\n\/\/ Constraints:\n\/\/ * 1 <= nodes.length <= 10000\n\/\/ * 0 <= node.value\nfunction pluck(arr){\n","canonical_solution":"function pluck(arr) {\n    let smallestEvenValue = Infinity;\n    let smallestEvenIndex = -1;\n\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] % 2 === 0) {\n            if (arr[i] < smallestEvenValue) {\n                smallestEvenValue = arr[i];\n                smallestEvenIndex = i;\n            }\n        }\n    }\n\n    return smallestEvenIndex === -1 ? [] : [smallestEvenValue, smallestEvenIndex];\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7, 9, 7, 1]),[]);\n}\n\ntest();"},{"task_id":"HumanEval_69","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Ka taida vierteiba nav, atsoka -1. Vīna vasaluo skaitļa bīžums ir tys, cik reižu tys pasaruoda matricā.\/ nulle, i bīžums ir leluoks par voi vīnaids ar pošys vasalūs skaitļu vierteibu. Teik dots na tukšs pozitivu vasalūs skaitļu sareiksnis. Atdūd leluokū vasalū skaitli, kas ir leluoks par \/\/ >>> search([4, 1, 2, 2, 3, 1])\n\/\/ 2\n\/\/ >>> search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/ 3\n\/\/ >>> search([5, 5, 4, 4, 4])\n\/\/ -1\nfunction search(lst){\n","canonical_solution":"function search(lst) {\n    const frequencyMap = new Map();\n\n    lst.forEach(num => {\n        frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1);\n    });\n\n    let result = -1;\n\n    frequencyMap.forEach((count, num) => {\n        if (count >= num && num > 0 && num > result) {\n            result = num;\n        }\n    });\n\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = search;\n  assert.deepEqual(candidate([5, 5, 5, 5, 1]),1);\n  assert.deepEqual(candidate([4, 1, 4, 1, 4, 4]),4);\n  assert.deepEqual(candidate([3, 3]),-1);\n  assert.deepEqual(candidate([8, 8, 8, 8, 8, 8, 8, 8]),8);\n  assert.deepEqual(candidate([2, 3, 3, 2, 2]),2);\n  assert.deepEqual(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]),1);\n  assert.deepEqual(candidate([3, 2, 8, 2]),2);\n  assert.deepEqual(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]),1);\n  assert.deepEqual(candidate([8, 8, 3, 6, 5, 6, 4]),-1);\n  assert.deepEqual(candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]),1);\n  assert.deepEqual(candidate([1, 9, 10, 1, 3]),1);\n  assert.deepEqual(candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]),5);\n  assert.deepEqual(candidate([1]),1);\n  assert.deepEqual(candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]),4);\n  assert.deepEqual(candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]),2);\n  assert.deepEqual(candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]),1);\n  assert.deepEqual(candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]),4);\n  assert.deepEqual(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]),4);\n  assert.deepEqual(candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]),2);\n  assert.deepEqual(candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]),-1);\n  assert.deepEqual(candidate([10]),-1);\n  assert.deepEqual(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),2);\n  assert.deepEqual(candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]),1);\n  assert.deepEqual(candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]),1);\n  assert.deepEqual(candidate([3, 10, 10, 9, 2]),-1);\n}\n\ntest();"},{"task_id":"HumanEval_70","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ tod maksimals nu puorejūs vasalūs skaitļu, tod minimals i tai tuoļuok. \/ Dīva sortiešona ir tod, kod suoc ar minimumu, \/Dūdams vasalūs skaitļu sareiku, atsagrīž ariru svešā seceibā.\/\/ >>> strange_sort_list([1, 2, 3, 4])\n\/\/ [1, 4, 2, 3]\n\/\/ >>> strange_sort_list([5, 5, 5, 5])\n\/\/ [5, 5, 5, 5]\n\/\/ >>> strange_sort_list([])\n\/\/ []\nfunction strange_sort_list(lst){\n","canonical_solution":"function strange_sort_list(lst) {\n    let result = [];\n    lst.sort((a, b) => a - b); \/\/ Sort the array in ascending order\n\n    while (lst.length) {\n        result.push(lst.shift()); \/\/ Add the minimum element\n        if (lst.length) {\n            result.push(lst.pop()); \/\/ Add the maximum element\n        }\n    }\n\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = strange_sort_list;\n  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 4, 2, 3]);\n  assert.deepEqual(candidate([5, 6, 7, 8, 9]),[5, 9, 6, 8, 7]);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5]),[1, 5, 2, 4, 3]);\n  assert.deepEqual(candidate([5, 6, 7, 8, 9, 1]),[1, 9, 5, 8, 6, 7]);\n  assert.deepEqual(candidate([5, 5, 5, 5]),[5, 5, 5, 5]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8]),[1, 8, 2, 7, 3, 6, 4, 5]);\n  assert.deepEqual(candidate([0, 2, 2, 2, 5, 5, -5, -5]),[-5, 5, -5, 5, 0, 2, 2, 2]);\n  assert.deepEqual(candidate([111111]),[111111]);\n}\n\ntest();"},{"task_id":"HumanEval_71","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ kai trešuo puse. \/ Treis ryndys veidoj dereigu trikūni, kod sevkurys diveju ryndys summa ir leluoka.\/ Cytaidā gadīnī atsagrīž -1 \/ trejstūšu apgrīzīs iz 2 decimalpunktim, ka treis sānis veidoj dereigu trejstūšu. \/Dūdūt treju trikstūņa lūku garumus, atsoka  laukumu.\/\/ >>> triangle_area(3, 4, 5)\n\/\/ 6.0\n\/\/ >>> triangle_area(1, 2, 10)\n\/\/ -1\nfunction triangle_area(a, b, c){\n","canonical_solution":"function triangle_area(a, b, c) {\n    \/\/ Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        \/\/ Use Heron's formula to calculate the area\n        const s = (a + b + c) \/ 2;\n        const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        \/\/ Return the area rounded to 2 decimal places\n        return Math.round(area * 100) \/ 100;\n    } else {\n        \/\/ Return -1 for an invalid triangle\n        return -1;\n    }\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = triangle_area;\n  assert.deepEqual(candidate(3, 4, 5),6.0);\n  assert.deepEqual(candidate(1, 2, 10),-1);\n  assert.deepEqual(candidate(4, 8, 5),8.18);\n  assert.deepEqual(candidate(2, 2, 2),1.73);\n  assert.deepEqual(candidate(1, 2, 3),-1);\n  assert.deepEqual(candidate(10, 5, 7),16.25);\n  assert.deepEqual(candidate(2, 6, 3),-1);\n  assert.deepEqual(candidate(1, 1, 1),0.43);\n  assert.deepEqual(candidate(2, 2, 10),-1);\n}\n\ntest();"},{"task_id":"HumanEval_72","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ Objekts q liks, ka tys ir balansāts (tys ir palindroms viersyuns) i tuo elementu summa ir mozuoka par voi vīnaida ar maksimaluokū īspiejamū svoru w. \/Skaiti funkceju, kas atdūd patīsu, ka objekts q lidoj, i nalykumeigu cytaiži. \/\/ >>> will_it_fly([1, 2], 5)\n\/\/ false\n\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/ >>> will_it_fly([3, 2, 3], 1)\n\/\/ false\n\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/ >>> will_it_fly([3, 2, 3], 9)\n\/\/ true\n\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/ >>> will_it_fly([3], 5)\n\/\/ true\n\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunction will_it_fly(q, w){\n","canonical_solution":"function will_it_fly(q, w) {\n    \/\/ Check if q is a palindromic array\n    function isPalindromic(arr) {\n        for (let i = 0; i < Math.floor(arr.length \/ 2); i++) {\n            if (arr[i] !== arr[arr.length - 1 - i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \/\/ Calculate the sum of the array\n    function sumArray(arr) {\n        return arr.reduce((acc, val) => acc + val, 0);\n    }\n\n    \/\/ Check if the array is balanced and the sum is within the limit\n    return isPalindromic(q) && sumArray(q) <= w;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = will_it_fly;\n  assert.deepEqual(candidate([3, 2, 3], 9),true);\n  assert.deepEqual(candidate([1, 2], 5),false);\n  assert.deepEqual(candidate([3], 5),true);\n  assert.deepEqual(candidate([3, 2, 3], 1),false);\n  assert.deepEqual(candidate([1, 2, 3], 6),false);\n  assert.deepEqual(candidate([5], 5),true);\n}\n\ntest();"},{"task_id":"HumanEval_73","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ teik skaiteita tai poši iz prīšku i atpakaļ.\/ ir juomaina, kab matrica byutu palindromiska. Palindromiskais matrica ir matrica, kas \/Dūdūt vasalūs skaitļu sareiku arr, atrodi minimumu elementu skaitu, kas \/\/ >>> smallest_change([1, 2, 3, 5, 4, 7, 9, 6])\n\/\/ 4\n\/\/ >>> smallest_change([1, 2, 3, 4, 3, 2, 2])\n\/\/ 1\n\/\/ >>> smallest_change([1, 2, 3, 2, 1])\n\/\/ 0\nfunction smallest_change(arr){\n","canonical_solution":"function smallest_change(arr) {\n    let changes = 0;\n    let left = 0;\n    let right = arr.length - 1;\n\n    while (left < right) {\n        if (arr[left] !== arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = smallest_change;\n  assert.deepEqual(candidate([1, 2, 3, 5, 4, 7, 9, 6]),4);\n  assert.deepEqual(candidate([1, 2, 3, 4, 3, 2, 2]),1);\n  assert.deepEqual(candidate([1, 4, 2]),1);\n  assert.deepEqual(candidate([1, 4, 4, 2]),1);\n  assert.deepEqual(candidate([1, 2, 3, 2, 1]),0);\n  assert.deepEqual(candidate([3, 1, 1, 3]),0);\n  assert.deepEqual(candidate([1]),0);\n  assert.deepEqual(candidate([0, 1]),1);\n}\n\ntest();"},{"task_id":"HumanEval_74","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri \/ ka obejim matricim ir vīnaids skaitlis, atsoka pyrmū matricys.\/ kūpejais burtu skaits vysuos matricys stringūs ir mozuoks par cytu matricys stringim. \/Skaiti funkceju, kas pījam divejus stringim saisteitus matricys i atdūd matricys, kurys ir \/\/ >>> total_match([], [])\n\/\/ []\n\/\/ >>> total_match([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n\/\/ [\"hI\", \"Hi\"]\n\/\/ >>> total_match([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n\/\/ [\"hi\", \"admin\"]\n\/\/ >>> total_match([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n\/\/ [\"hI\", \"hi\", \"hi\"]\n\/\/ >>> total_match([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n\/\/ [\"4\"]\nfunction total_match(lst1, lst2){\n","canonical_solution":"function total_match(lst1, lst2) {\n    \/\/ Helper function to calculate total characters in an array of strings\n    const totalChars = (arr) => arr.reduce((sum, str) => sum + str.length, 0);\n\n    const total1 = totalChars(lst1);\n    const total2 = totalChars(lst2);\n\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = total_match;\n  assert.deepEqual(candidate([], []),[]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hi\", \"hi\"]),[\"hi\", \"hi\"]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]),[\"hi\", \"admin\"]);\n  assert.deepEqual(candidate([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]),[\"4\"]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hI\", \"Hi\"]),[\"hI\", \"Hi\"]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]),[\"hI\", \"hi\", \"hi\"]);\n  assert.deepEqual(candidate([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]),[\"hi\", \"admin\"]);\n  assert.deepEqual(candidate([], [\"this\"]),[]);\n  assert.deepEqual(candidate([\"this\"], []),[]);\n}\n\ntest();"},{"task_id":"HumanEval_75","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ Zynūt, ka a ir mozuoka par 100. \/ i cytaiž - napareizi. \/Skaiti funkceju, kas atdūd patīsu, ka dāts skaitlis ir 3 pyrmskaitļu reizynuojums.\/\/ >>> is_multiply_prime(30)\n\/\/ true\n\/\/ 30 = 2 * 3 * 5\nfunction is_multiply_prime(a){\n","canonical_solution":"function is_prime(n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 === 0 || n % 3 === 0) return false;\n    for (let i = 5; i * i <= n; i += 6) {\n        if (n % i === 0 || n % (i + 2) === 0) return false;\n    }\n    return true;\n}\n\nfunction generate_primes(upper_limit) {\n    const primes = [];\n    for (let num = 2; num < upper_limit; num++) {\n        if (is_prime(num)) {\n            primes.push(num);\n        }\n    }\n    return primes;\n}\n\nfunction is_multiply_prime(a) {\n    if (a < 2) return false;\n    const primes = generate_primes(100);\n    const primesLength = primes.length;\n\n    for (let i = 0; i < primesLength; i++) {\n        for (let j = i; j < primesLength; j++) {\n            for (let k = j; k < primesLength; k++) {\n                if (primes[i] * primes[j] * primes[k] === a) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_multiply_prime;\n  assert.deepEqual(candidate(5),false);\n  assert.deepEqual(candidate(30),true);\n  assert.deepEqual(candidate(8),true);\n  assert.deepEqual(candidate(10),false);\n  assert.deepEqual(candidate(125),true);\n  assert.deepEqual(candidate(105),true);\n  assert.deepEqual(candidate(126),false);\n  assert.deepEqual(candidate(729),false);\n  assert.deepEqual(candidate(891),false);\n  assert.deepEqual(candidate(1001),true);\n}\n\ntest();"},{"task_id":"HumanEval_76","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/x ir vīnkuorša n spāka, ka n**int=x \/ n i cytuos gadīņūs ir īvaiņa. \/Tovs uzdavums ir raksteit funkceju, kas atdūd patīsu, ka skaitlis x ir vīnkuoršs \/\/ >>> is_simple_power(1, 4)\n\/\/ true\n\/\/ >>> is_simple_power(2, 2)\n\/\/ true\n\/\/ >>> is_simple_power(8, 2)\n\/\/ true\n\/\/ >>> is_simple_power(3, 2)\n\/\/ false\n\/\/ >>> is_simple_power(3, 1)\n\/\/ false\n\/\/ >>> is_simple_power(5, 3)\n\/\/ false\nfunction is_simple_power(x, n){\n","canonical_solution":"function is_simple_power(x, n) {\n    if (x === 1) return true;  \/\/ Any number to the power of zero is 1\n    if (n <= 1) return false;  \/\/ n must be greater than 1 to have simple powers other than itself\n\n    let power = n;\n    while (power < x) {\n        power *= n;\n    }\n\n    return power === x;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_simple_power;\n  assert.deepEqual(candidate(16, 2),true);\n  assert.deepEqual(candidate(143214, 16),false);\n  assert.deepEqual(candidate(4, 2),true);\n  assert.deepEqual(candidate(9, 3),true);\n  assert.deepEqual(candidate(16, 4),true);\n  assert.deepEqual(candidate(24, 2),false);\n  assert.deepEqual(candidate(128, 4),false);\n  assert.deepEqual(candidate(12, 6),false);\n  assert.deepEqual(candidate(1, 1),true);\n  assert.deepEqual(candidate(1, 12),true);\n}\n\ntest();"},{"task_id":"HumanEval_77","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Napīmiņu: var pījimt, ka īejis dati vysod ir dereigi. \/ ka itys ingeger ir koč kaida vasaluo skaitļa kubs. \/Skaiti funkceju, kas pajam vasalū skaitli a i atdūd patīsu.\/\/ >>> iscube(1)\n\/\/ true\n\/\/ >>> iscube(2)\n\/\/ false\n\/\/ >>> iscube(-1)\n\/\/ true\n\/\/ >>> iscube(64)\n\/\/ true\n\/\/ >>> iscube(0)\n\/\/ true\n\/\/ >>> iscube(180)\n\/\/ false\nfunction iscube(a){\n","canonical_solution":"function iscube(a) {\n    if (a < 0) a = -a;\n    let cubeRoot = Math.round(Math.pow(a, 1\/3));\n    return cubeRoot * cubeRoot * cubeRoot === a;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = iscube;\n  assert.deepEqual(candidate(1),true);\n  assert.deepEqual(candidate(2),false);\n  assert.deepEqual(candidate(-1),true);\n  assert.deepEqual(candidate(64),true);\n  assert.deepEqual(candidate(180),false);\n  assert.deepEqual(candidate(1000),true);\n  assert.deepEqual(candidate(0),true);\n  assert.deepEqual(candidate(1729),false);\n}\n\ntest();"},{"task_id":"HumanEval_78","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ i simboli A,B,C,D,E,F vysod ir golvonuo burta. \/ Napīmiņu: var pījimt, ka īejis verseja vysod ir pareizā voi tukša,\/ B (= decimals 11), D (= decimals 13). \/ Tai jums ir juodalīk skaitlis nu sekojūšūs cyparu: 2, 3, 5, 7, Prīmeji skaitli ir 2, 3, 5, 7, 11, 13, 17...\/ Heksadecimaluos cyparis ir 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. \/ leluoka par 1, kas nav divu mozuoku naturalu skaitļu reizynuojums).\/ cypars, kas ir pyrmskaitli ( pyrmskaitlis voi pyrmskaitlis ir naturals skaitlis \/ heksadecimalu skaitli kai string i skaita heksadecimalu skaitli Tevi ir īsaisteits rokstūt funkceju, kas sajam \/\/ >>> hex_key(\"AB\")\n\/\/ 1\n\/\/ >>> hex_key(\"1077E\")\n\/\/ 2\n\/\/ >>> hex_key(\"ABED1A33\")\n\/\/ 4\n\/\/ >>> hex_key(\"123456789ABCDEF0\")\n\/\/ 6\n\/\/ >>> hex_key(\"2020\")\n\/\/ 2\nfunction hex_key(num){\n","canonical_solution":"function hex_key(num) {\n    \/\/ Define a set of hexadecimal digits that are prime numbers\n    const primeHexDigits = new Set(['2', '3', '5', '7', 'B', 'D']);\n    \n    \/\/ Initialize a count variable to track the number of prime digits\n    let count = 0;\n    \n    \/\/ Iterate over each character in the input string\n    for (let char of num) {\n        \/\/ Check if the character is in the set of prime hexadecimal digits\n        if (primeHexDigits.has(char)) {\n            \/\/ Increment the count if the character is a prime digit\n            count++;\n        }\n    }\n    \n    \/\/ Return the total count of prime hexadecimal digits\n    return count;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = hex_key;\n  assert.deepEqual(candidate(\"AB\"),1);\n  assert.deepEqual(candidate(\"1077E\"),2);\n  assert.deepEqual(candidate(\"ABED1A33\"),4);\n  assert.deepEqual(candidate(\"2020\"),2);\n  assert.deepEqual(candidate(\"123456789ABCDEF0\"),6);\n  assert.deepEqual(candidate(\"112233445566778899AABBCCDDEEFF00\"),12);\n}\n\ntest();"},{"task_id":"HumanEval_79","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Papyldu rakstīņi ir, kab paleidzātu formata izveidei. \/ Stringa suokumā i beiguos byus puora cytu raksturu \"db\". Kotrs zeimeigais burts byus \"0\" voi \"1\".\/ binarajā formatā. Funkcejai juosaver stringam, kur kotrs raksturs apzeimoj binaru Tevi tiks pīduovuots skaitlis decimalformā, i tev ir juoskaita ar \/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunction decimal_to_binary(decimal){\n","canonical_solution":"function decimal_to_binary(decimal) {\n    \/\/ Convert the decimal number to a binary string\n    let binaryString = decimal.toString(2);\n    \/\/ Add 'db' at the beginning and end of the binary string\n    return 'db' + binaryString + 'db';\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = decimal_to_binary;\n  assert.deepEqual(candidate(0),\"db0db\");\n  assert.deepEqual(candidate(32),\"db100000db\");\n  assert.deepEqual(candidate(103),\"db1100111db\");\n  assert.deepEqual(candidate(15),\"db1111db\");\n}\n\ntest();"},{"task_id":"HumanEval_80","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ Stringa ir laimīga, ka tuos garums ir vysmoz 3 i kotri nu 3 uzastuojušūs burtu ir atškireigi Tova aizdavums ir puorbaudeit, voi strings ir hapjs voi nā.Tevi pīduovoj sīna.\/\/ >>> is_happy(\"a\")\n\/\/ false\n\/\/ >>> is_happy(\"aa\")\n\/\/ false\n\/\/ >>> is_happy(\"abcd\")\n\/\/ true\n\/\/ >>> is_happy(\"aabb\")\n\/\/ false\n\/\/ >>> is_happy(\"adb\")\n\/\/ true\n\/\/ >>> is_happy(\"xyy\")\n\/\/ false\nfunction is_happy(s){\n","canonical_solution":"function is_happy(s) {\n    if (s.length < 3) return false;\n    for (let i = 0; i < s.length - 2; i++) {\n        if (s[i] === s[i + 1] || s[i] === s[i + 2] || s[i + 1] === s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_happy;\n  assert.deepEqual(candidate(\"a\"),false);\n  assert.deepEqual(candidate(\"aa\"),false);\n  assert.deepEqual(candidate(\"abcd\"),true);\n  assert.deepEqual(candidate(\"aabb\"),false);\n  assert.deepEqual(candidate(\"adb\"),true);\n  assert.deepEqual(candidate(\"xyy\"),false);\n  assert.deepEqual(candidate(\"iopaxpoi\"),true);\n  assert.deepEqual(candidate(\"iopaxioi\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_81","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ 0.0 E \/ > 0,0 D-  nuokūtne\/ > 0,7 D  nuokūtne\/ > 1,0 D+ \/ > 1.3 C-  nuokūtne\/ > 1,7 C  nuokūtne\/ > 2.0 C+ \/ > 2.3 B- \/ > 2,7 B  nuokūtne\/ > 3.0 B+ \/ > 3.3 A- \/ > 3.7 A \/ 4.0 A+ \/ GPA. \/ Lītuotuoju aptuoklis.\/ ir funkceja, kas var izpiļdeit burtu pakuopis matricys, izmontojūt itaidu tabulu: Jei tev ir īdevuši dažus stuņžu vidiskūs rezultatus i tu vari raksteit.Vīneiguo problema ir taida, ka jei ir pazaudiejuse kodu, kū izmontuoja, kab nūvierteitu.Školotuojis ir izveiduojuse sovu klasifikacejis algoritmu.Tei ir pādejuo semestra nedeļa, i školuotuojam ir juopīroksta notys.\/\/ >>> grade_equation([4.0, 3, 1.7, 2, 3.5])\n\/\/ [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nfunction numerical_letter_grade(grades){\n","canonical_solution":"function numerical_letter_grade(grades){\n    return grades.map(gpa => {\n        if (gpa === 4.0) return \"A+\";\n        else if (gpa > 3.7) return \"A\";\n        else if (gpa > 3.3) return \"A-\";\n        else if (gpa > 3.0) return \"B+\";\n        else if (gpa > 2.7) return \"B\";\n        else if (gpa > 2.3) return \"B-\";\n        else if (gpa > 2.0) return \"C+\";\n        else if (gpa > 1.7) return \"C\";\n        else if (gpa > 1.3) return \"C-\";\n        else if (gpa > 1.0) return \"D+\";\n        else if (gpa > 0.7) return \"D\";\n        else if (gpa > 0.0) return \"D-\";\n        else return \"E\";\n    });\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = numerical_letter_grade;\n  assert.deepEqual(candidate([4.0, 3, 1.7, 2, 3.5]),[\"A+\", \"B\", \"C-\", \"C\", \"A-\"]);\n  assert.deepEqual(candidate([1.2]),[\"D+\"]);\n  assert.deepEqual(candidate([0.5]),[\"D-\"]);\n  assert.deepEqual(candidate([0.0]),[\"E\"]);\n  assert.deepEqual(candidate([1.0, 0.3, 1.5, 2.8, 3.3]),[\"D\", \"D-\", \"C-\", \"B\", \"B+\"]);\n  assert.deepEqual(candidate([0.0, 0.7]),[\"E\", \"D-\"]);\n}\n\ntest();"},{"task_id":"HumanEval_82","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri \/ garums ir pyrmskaitlis voi cytaiž nav taisneiba \/Skaiti funkceju, kas pajam string i atnese true, ka string \/\/ >>> prime_length(\"Hello\")\n\/\/ true\n\/\/ >>> prime_length(\"abcdcba\")\n\/\/ true\n\/\/ >>> prime_length(\"kittens\")\n\/\/ true\n\/\/ >>> prime_length(\"orange\")\n\/\/ false\nfunction prime_length(string){\n","canonical_solution":"function prime_length(string) {\n    function isPrime(num) {\n        if (num <= 1) return false;\n        if (num <= 3) return true;\n        if (num % 2 === 0 || num % 3 === 0) return false;\n        for (let i = 5; i * i <= num; i += 6) {\n            if (num % i === 0 || num % (i + 2) === 0) return false;\n        }\n        return true;\n    }\n    \n    return isPrime(string.length);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = prime_length;\n  assert.deepEqual(candidate(\"Hello\"),true);\n  assert.deepEqual(candidate(\"abcdcba\"),true);\n  assert.deepEqual(candidate(\"kittens\"),true);\n  assert.deepEqual(candidate(\"orange\"),false);\n  assert.deepEqual(candidate(\"wow\"),true);\n  assert.deepEqual(candidate(\"world\"),true);\n  assert.deepEqual(candidate(\"MadaM\"),true);\n  assert.deepEqual(candidate(\"Wow\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"HI\"),true);\n  assert.deepEqual(candidate(\"go\"),true);\n  assert.deepEqual(candidate(\"gogo\"),false);\n  assert.deepEqual(candidate(\"aaaaaaaaaaaaaaa\"),false);\n  assert.deepEqual(candidate(\"Madam\"),true);\n  assert.deepEqual(candidate(\"M\"),false);\n  assert.deepEqual(candidate(\"0\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_83","nl":"ltg_Latn","pl":"js","prompt":"\/ pozitivi vasalī skaitli, kas suocās voi beidzās ar 1. \/Dūdūt pozitivu vasalu skaitli n, atdūd skaitļu skaitu ar n cyparim function starts_one_ends(n){\n","canonical_solution":"function starts_one_ends(n) {\n    if (n === 1) return 1; \/\/ For n = 1, only number is 1 itself\n\n    \/\/ Calculate the number of n-digit numbers that either start or end with 1\n    \/\/ Total n-digit numbers: 9 * 10^(n-1) (ranging from 10^(n-1) to 10^n - 1)\n\n    let totalCount = 9 * Math.pow(10, n - 1);\n\n    \/\/ Numbers that both start and end with 1: 10^(n-2) (e.g., 101, 111, 121, ..., 191 if n=3)\n    let bothStartAndEndWithOne = Math.pow(10, n - 2);\n\n    \/\/ Numbers that start with 1: 10^(n-1)\n    let startWithOne = Math.pow(10, n - 1);\n\n    \/\/ Numbers that end with 1: 9 * 10^(n-1) \/ 10 = 10^(n-1) (because we're counting 1 - 1, 11, 21, ..., 91)\n    let endWithOne = Math.pow(10, n - 1);\n\n    \/\/ Use inclusion-exclusion principle: number starts with 1 + numbers end with 1 - numbers that both start and end with 1\n    return startWithOne + endWithOne - bothStartAndEndWithOne;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = starts_one_ends;\n  assert.deepEqual(candidate(1),1);\n  assert.deepEqual(candidate(2),18);\n  assert.deepEqual(candidate(3),180);\n  assert.deepEqual(candidate(4),1800);\n  assert.deepEqual(candidate(5),18000);\n}\n\ntest();"},{"task_id":"HumanEval_84","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs \/Dūdūt pozitivu vasalu skaitli N, atdūd juo cyparu kūpejū summu duorga skaitļa formā. \/\/ >>> solve(1000)\n\/\/ \"1\"\n\/\/ >>> solve(150)\n\/\/ \"110\"\n\/\/ >>> solve(147)\n\/\/ \"1100\"\n\/\/ Variables:\n\/\/ @N integer\n\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/ Output:\n\/\/ a string of binary number\nfunction solve(N){\n","canonical_solution":"function solve(N) {\n    \/\/ Convert the number to a string and split into individual characters (digits)\n    let digits = N.toString().split('');\n    \/\/ Calculate the sum of all digits\n    let sum = digits.reduce((acc, digit) => acc + Number(digit), 0);\n    \/\/ Convert the sum to a binary string and return\n    return sum.toString(2);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = solve;\n  assert.deepEqual(candidate(1000),\"1\");\n  assert.deepEqual(candidate(150),\"110\");\n  assert.deepEqual(candidate(147),\"1100\");\n  assert.deepEqual(candidate(333),\"1001\");\n  assert.deepEqual(candidate(963),\"10010\");\n}\n\ntest();"},{"task_id":"HumanEval_85","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/Dūdūt na tukšu vasalūs skaitļu sareikuojumu, pyrmū reizi saskaitiet pat elementus, kas ir najauši indeksūs.. \/\/ >>> add([4, 2, 6, 7])\n\/\/ 2\nfunction add(lst){\n","canonical_solution":"function add(lst) {\n    let sum = 0;\n    for (let i = 1; i < lst.length; i += 2) {\n        if (lst[i] % 2 === 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = add;\n  assert.deepEqual(candidate([4, 88]),88);\n  assert.deepEqual(candidate([4, 5, 6, 7, 2, 122]),122);\n  assert.deepEqual(candidate([4, 0, 6, 7]),0);\n  assert.deepEqual(candidate([4, 4, 6, 8]),12);\n}\n\ntest();"},{"task_id":"HumanEval_86","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ Napīmiņu: Tev juoiztur vuordu kuorteiba i vītys teiklā. \/ augšupīaugšonys seceibā, bolstūtīs iz ASCI vierteibu. \/ teik aizstuoti ar jaunu vuordu, kur vysi burti ir sakuortuoti \/ Nūsaceita string verseja ir string, kur vysi vuordi (atškireigi ar telpu) \/Skaiti funkceju, kas pajam stringu i atdūd tuo sakuortuotu verseju. \/\/ >>> anti_shuffle(\"Hi\")\n\/\/ \"Hi\"\n\/\/ >>> anti_shuffle(\"hello\")\n\/\/ \"ehllo\"\n\/\/ >>> anti_shuffle(\"Hello World!!!\")\n\/\/ \"Hello !!!Wdlor\"\nfunction anti_shuffle(s){\n","canonical_solution":"function anti_shuffle(s) {\n    return s.split(' ').map(word => {\n        return word.split('').sort().join('');\n    }).join(' ');\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = anti_shuffle;\n  assert.deepEqual(candidate(\"Hi\"),\"Hi\");\n  assert.deepEqual(candidate(\"hello\"),\"ehllo\");\n  assert.deepEqual(candidate(\"number\"),\"bemnru\");\n  assert.deepEqual(candidate(\"abcd\"),\"abcd\");\n  assert.deepEqual(candidate(\"Hello World!!!\"),\"Hello !!!Wdlor\");\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"Hi. My name is Mister Robot. How are you?\"),\".Hi My aemn is Meirst .Rboot How aer ?ouy\");\n}\n\ntest();"},{"task_id":"HumanEval_87","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Taipat sortoj rindeņa koordinatis piec kolonu, lejupīluodūt. \/ Suokumā sakuortuot koordinatis piec ryndom augšupīaugšonā. \/ kotrs matracs ir koordinata - (roksta, kolonu), suocūt ar 0. \/ i atsagrīž kūpums kūpumu, [(x1, y1), (x2, y2) ...] tai, ka \/ Dūdūt lst i vasalū skaitli x, atrodi vasalus skaitļus x matricā, \/ kotrā ryndā var byut dažaids ryndkūpu skaits. \/ kas ir leidzeigs matricys, tok atškireigs nu matricom, Teik dūti 2 dimenseju dati kai īkšeiti matricys,\/\/ >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n\/\/ [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\/\/ >>> get_row([], 1)\n\/\/ []\n\/\/ >>> get_row([[], [1], [1, 2, 3]], 3)\n\/\/ [[2, 2]]\nfunction get_row(lst, x){\n","canonical_solution":"function get_row(lst, x) {\n    const result = [];\n\n    for (let i = 0; i < lst.length; i++) {\n        for (let j = 0; j < lst[i].length; j++) {\n            if (lst[i][j] === x) {\n                result.push([i, j]);\n            }\n        }\n    }\n\n    result.sort((a, b) => {\n        if (a[0] === b[0]) {\n            return b[1] - a[1]; \/\/ Sort by columns in descending order for the same row\n        }\n        return a[0] - b[0]; \/\/ Sort by rows in ascending order\n    });\n\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();"},{"task_id":"HumanEval_88","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ * naizmaina nūteiktu viersyunu. \/ Napīmiņu: \/ voi sorgoj tū lejupīluodē, ka summa ((pyrmuo indeksa vierteiba, pādejuo indeksa vierteiba) ir puora. \/ tu sorgoj nūteiktu maisejumu pīaugūšajā kuortā, ka summa (pirmuo indeksa vierteiba, pādejuo indeksa vierteiba) ir najauša, \/Dūdūt navnegativūs vasalūs skaitļu kuormi, piec sortiešonys atsoka nūteiktuo kuorma cojs, \/\/ >>> sort_array([])\n\/\/ []\n\/\/ >>> sort_array([5])\n\/\/ [5]\n\/\/ >>> sort_array([2, 4, 3, 0, 1, 5])\n\/\/ [0, 1, 2, 3, 4, 5]\n\/\/ >>> sort_array([2, 4, 3, 0, 1, 5, 6])\n\/\/ [6, 5, 4, 3, 2, 1, 0]\nfunction sort_array(array){\n","canonical_solution":"function sort_array(array) {\n    if (array.length === 0) return [];\n\n    let firstValue = array[0];\n    let lastValue = array[array.length - 1];\n    let sum = firstValue + lastValue;\n    \n    let sortedArray = [...array]; \/\/ Clone the array to avoid modifying the original\n\n    if (sum % 2 === 0) {\n        \/\/ Even sum: sort in descending order\n        sortedArray.sort((a, b) => b - a);\n    } else {\n        \/\/ Odd sum: sort in ascending order\n        sortedArray.sort((a, b) => a - b);\n    }\n\n    return sortedArray;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_array;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([5]),[5]);\n  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5]),[0, 1, 2, 3, 4, 5]);\n  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5, 6]),[6, 5, 4, 3, 2, 1, 0]);\n  assert.deepEqual(candidate([2, 1]),[1, 2]);\n  assert.deepEqual(candidate([15, 42, 87, 32, 11, 0]),[0, 11, 15, 32, 42, 87]);\n  assert.deepEqual(candidate([21, 14, 23, 11]),[23, 21, 14, 11]);\n}\n\ntest();"},{"task_id":"HumanEval_89","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ nūvierze iz leju ar divejim reizynuojūt iz divejom vītom. \/ Alfabets ir juotaisa tai, lai burti \/ atdūd šifruotu ryndys burtu, kurū apgrīž. \/Dzeivuot funkceju šifru, kas pījam string kūpumā par argumentu i \/\/ >>> encrypt(\"hi\")\n\/\/ \"lm\"\n\/\/ >>> encrypt(\"asdfghjkl\")\n\/\/ \"ewhjklnop\"\n\/\/ >>> encrypt(\"gf\")\n\/\/ \"kj\"\n\/\/ >>> encrypt(\"et\")\n\/\/ \"ix\"\nfunction encrypt(s){\n","canonical_solution":"function encrypt(s) {\n    const shift = 2 * 2; \/\/ shift down by two multiplied by two places\n    let encrypted = '';\n    for (let i = 0; i < s.length; i++) {\n        let charCode = s.charCodeAt(i);\n        let newCharCode = ((charCode - 97 + shift) % 26) + 97; \/\/ wrap around within 'a' to 'z'\n        encrypted += String.fromCharCode(newCharCode);\n    }\n    return encrypted;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = encrypt;\n  assert.deepEqual(candidate(\"hi\"),\"lm\");\n  assert.deepEqual(candidate(\"asdfghjkl\"),\"ewhjklnop\");\n  assert.deepEqual(candidate(\"gf\"),\"kj\");\n  assert.deepEqual(candidate(\"et\"),\"ix\");\n  assert.deepEqual(candidate(\"faewfawefaewg\"),\"jeiajeaijeiak\");\n  assert.deepEqual(candidate(\"hellomyfriend\"),\"lippsqcjvmirh\");\n  assert.deepEqual(candidate(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"),\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n  assert.deepEqual(candidate(\"a\"),\"e\");\n}\n\ntest();"},{"task_id":"HumanEval_90","nl":"ltg_Latn","pl":"js","prompt":"\/ Atdūd nedefinātu, ka itaids elements nav. \/ Skaitit funkceju next_smallest ((), kas atdūd ūtrū mozuokū array elementu. Tevi teik pīškierts vasalūs skaitļu sareiksnis.\/\/ >>> next_smallest([1, 2, 3, 4, 5])\n\/\/ 2\n\/\/ >>> next_smallest([5, 1, 4, 3, 2])\n\/\/ 2\n\/\/ >>> next_smallest([])\n\/\/ undefined\n\/\/ >>> next_smallest([1, 1])\n\/\/ undefined\nfunction next_smallest(lst){\n","canonical_solution":"function next_smallest(lst) {\n    if (lst.length < 2) return undefined;\n    \n    let firstSmallest = Infinity;\n    let secondSmallest = Infinity;\n    \n    for (let num of lst) {\n        if (num < firstSmallest) {\n            secondSmallest = firstSmallest;\n            firstSmallest = num;\n        } else if (num < secondSmallest && num != firstSmallest) {\n            secondSmallest = num;\n        }\n    }\n    \n    return secondSmallest === Infinity ? undefined : secondSmallest;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = next_smallest;\n  assert.deepEqual(candidate([1, 2, 3, 4, 5]),2);\n  assert.deepEqual(candidate([5, 1, 4, 3, 2]),2);\n  assert.deepEqual(candidate([]),undefined);\n  assert.deepEqual(candidate([1, 1]),undefined);\n  assert.deepEqual(candidate([1, 1, 1, 1, 0]),1);\n  assert.deepEqual(candidate([1, 1]),undefined);\n  assert.deepEqual(candidate([-35, 34, 12, -45]),-35);\n}\n\ntest();"},{"task_id":"HumanEval_91","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ Vīnuošonuos teik īrūbežuotys ar \"\", \"?\" voi \"!\"\"Smuode\" ir teikums, kas suocās ar vuordu \"i\".Tev tiks pīduovuota vuordu seja, i tev ir juoskaita skaitlis.\/\/ >>> is_bored(\"Hello world\")\n\/\/ 0\n\/\/ >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n\/\/ 1\nfunction is_bored(S){\n","canonical_solution":"function is_bored(S) {\n    \/\/ Split the string into sentences using '.', '?', and '!' as delimiters\n    const sentences = S.split(\/[.!?]\/);\n    \n    \/\/ Initialize boredom count\n    let boredomCount = 0;\n    \n    \/\/ Iterate over each sentence\n    sentences.forEach(sentence => {\n        \/\/ Trim any whitespace from the beginning of the sentence and check if it starts with \"I\"\n        if (sentence.trim().startsWith(\"I\")) {\n            boredomCount++;\n        }\n    });\n    \n    return boredomCount;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_bored;\n  assert.deepEqual(candidate(\"Hello world\"),0);\n  assert.deepEqual(candidate(\"Is the sky blue?\"),0);\n  assert.deepEqual(candidate(\"I love It !\"),1);\n  assert.deepEqual(candidate(\"bIt\"),0);\n  assert.deepEqual(candidate(\"I feel good today. I will be productive. will kill It\"),2);\n  assert.deepEqual(candidate(\"You and I are going for a walk\"),0);\n}\n\ntest();"},{"task_id":"HumanEval_92","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri \/ Rezultāts ir nalykums vysūs cytuos gadīņūs. \/ Atdūd patīsu, ka vīns nu skaitļu ir vīnaids ar puorejuo diveju summu, i vysi skaitli ir vasalī skaitli. \/Dzeivuot funkceju, kas pījam 3 skaitļus. \/\/ >>> any_int(5, 2, 7)\n\/\/ true\n\/\/ >>> any_int(3, 2, 2)\n\/\/ false\n\/\/ >>> any_int(3, -2, 1)\n\/\/ true\n\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/ false\nfunction any_int(x, y, z){\n","canonical_solution":"function any_int(x, y, z) {\n    \/\/ Check if all numbers are integers\n    if (Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z)) {\n        \/\/ Check if any number is the sum of the other two\n        return x === y + z || y === x + z || z === x + y;\n    }\n    \/\/ Return false if not all numbers are integers\n    return false;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = any_int;\n  assert.deepEqual(candidate(2, 3, 1),true);\n  assert.deepEqual(candidate(2.5, 2, 3),false);\n  assert.deepEqual(candidate(1.5, 5, 3.5),false);\n  assert.deepEqual(candidate(2, 6, 2),false);\n  assert.deepEqual(candidate(4, 2, 2),true);\n  assert.deepEqual(candidate(2.2, 2.2, 2.2),false);\n  assert.deepEqual(candidate(-4, 6, 2),true);\n  assert.deepEqual(candidate(2, 1, 1),true);\n  assert.deepEqual(candidate(3, 4, 7),true);\n  assert.deepEqual(candidate(3.0, 4, 7),false);\n}\n\ntest();"},{"task_id":"HumanEval_93","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Dūmojam, tikai burti.\/vokals angļu alfabetā. \/ viestejums ar burtu , kas radzama 2 vītys tuoļuok \/ tai, ka tys mainuos vysus burtu golvonūs burtus, aizstuov vysus vokalus \/Skaiti funkceju, kas pījam viesti i kodē taišni \/\/ >>> encode(\"test\")\n\/\/ \"TGST\"\n\/\/ >>> encode(\"This is a message\")\n\/\/ \"tHKS KS C MGSSCGG\"\nfunction encode(message){\n","canonical_solution":"function encode(message) {\n    \/\/ Helper function to swap the case of a character\n    function swapCase(char) {\n        if (char === char.toLowerCase()) {\n            return char.toUpperCase();\n        } else {\n            return char.toLowerCase();\n        }\n    }\n\n    \/\/ Vowel mapping\n    const vowelMap = {\n        'a': 'c',\n        'e': 'g',\n        'i': 'k',\n        'o': 'q',\n        'u': 'w',\n        'A': 'C',\n        'E': 'G',\n        'I': 'K',\n        'O': 'Q',\n        'U': 'W'\n    };\n\n    \/\/ Encode the message\n    let encodedMessage = '';\n    \n    for (let char of message) {\n        if (\/[aeiouAEIOU]\/.test(char)) {\n            \/\/ Replace vowel with appropriate letter\n            encodedMessage += vowelMap[char];\n        } else {\n            \/\/ Swap case for non-vowel letters\n            encodedMessage += swapCase(char);\n        }\n    }\n    \n    return encodedMessage;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = encode;\n  assert.deepEqual(candidate(\"TEST\"),\"tgst\");\n  assert.deepEqual(candidate(\"Mudasir\"),\"mWDCSKR\");\n  assert.deepEqual(candidate(\"YES\"),\"ygs\");\n  assert.deepEqual(candidate(\"This is a message\"),\"tHKS KS C MGSSCGG\");\n  assert.deepEqual(candidate(\"I DoNt KnOw WhAt tO WrItE\"),\"k dQnT kNqW wHcT Tq wRkTg\");\n}\n\ntest();"},{"task_id":"HumanEval_94","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Tev ir juodūmoj leluokuo pyrmskaitļa vierteiba i juosaver tuos cyparu summa. Tevi teik pīškierts vasalūs skaitļu sareiksnis.\/\/ >>> skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/ 10\n\/\/ >>> skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/ 25\n\/\/ >>> skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/ 13\n\/\/ >>> skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/ 11\n\/\/ >>> skjkasdkd([0, 81, 12, 3, 1, 21])\n\/\/ 3\n\/\/ >>> skjkasdkd([0, 8, 1, 2, 1, 7])\n\/\/ 7\nfunction skjkasdkd(lst){\n","canonical_solution":"function skjkasdkd(lst) {\n    function isPrime(num) {\n        if (num <= 1) return false;\n        if (num <= 3) return true;\n        if (num % 2 === 0 || num % 3 === 0) return false;\n        for (let i = 5; i * i <= num; i += 6) {\n            if (num % i === 0 || num % (i + 2) === 0) return false;\n        }\n        return true;\n    }\n\n    function sumOfDigits(num) {\n        return num.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);\n    }\n\n    let largestPrime = -1;\n\n    for (let num of lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    \n    return largestPrime !== -1 ? sumOfDigits(largestPrime) : 0;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = skjkasdkd;\n  assert.deepEqual(candidate([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]),10);\n  assert.deepEqual(candidate([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]),25);\n  assert.deepEqual(candidate([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]),13);\n  assert.deepEqual(candidate([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]),11);\n  assert.deepEqual(candidate([0, 81, 12, 3, 1, 21]),3);\n  assert.deepEqual(candidate([0, 8, 1, 2, 1, 7]),7);\n  assert.deepEqual(candidate([8191]),19);\n  assert.deepEqual(candidate([8191, 123456, 127, 7]),19);\n  assert.deepEqual(candidate([127, 97, 8192]),10);\n}\n\ntest();"},{"task_id":"HumanEval_95","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Funkcejai byutu juoaizvuorej false, ka dāts objekts ir tukšs. \/ case voi vysys klaviaturuos ir stīmeļu kuortys ar leluokajim burtim, cytaiž atvierš false. \/Dūdūt objektu, atsoka patīsu, ka vysys klaviaturu stringys ir zamuokajā \/\/ >>> check_dict_case({\"a\": \"apple\", \"b\": \"banana\"})\n\/\/ true\n\/\/ >>> check_dict_case({\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n\/\/ false\n\/\/ >>> check_dict_case({\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n\/\/ false\n\/\/ >>> check_dict_case({\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n\/\/ false\n\/\/ >>> check_dict_case({\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n\/\/ true\nfunction check_dict_case(dict){\n","canonical_solution":"function check_dict_case(dict) {\n    const keys = Object.keys(dict);\n\n    if (keys.length === 0) return false;\n\n    const allLowerCase = keys.every(key => typeof key === 'string' && key === key.toLowerCase());\n    const allUpperCase = keys.every(key => typeof key === 'string' && key === key.toUpperCase());\n\n    return allLowerCase || allUpperCase;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = check_dict_case;\n  assert.deepEqual(candidate({\"p\": \"pineapple\", \"b\": \"banana\"}),true);\n  assert.deepEqual(candidate({\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}),false);\n  assert.deepEqual(candidate({\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}),false);\n  assert.deepEqual(candidate({\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}),false);\n  assert.deepEqual(candidate({\"STATE\": \"NC\", \"ZIP\": \"12345\"}),true);\n  assert.deepEqual(candidate({\"fruit\": \"Orange\", \"taste\": \"Sweet\"}),true);\n  assert.deepEqual(candidate({}),false);\n}\n\ntest();"},{"task_id":"HumanEval_96","nl":"ltg_Latn","pl":"js","prompt":"\/ pīvadumam: \/ vasalī skaitli, kas ir pyrmskaitli i mozuoki par n. \/Īsistūt funkceju, kas pajam naenegai vasalū skaitli i atdūd pyrmuos n viersyunys.\/\/ >>> count_up_to(5)\n\/\/ [2, 3]\n\/\/ >>> count_up_to(11)\n\/\/ [2, 3, 5, 7]\n\/\/ >>> count_up_to(0)\n\/\/ []\n\/\/ >>> count_up_to(20)\n\/\/ [2, 3, 5, 7, 11, 13, 17, 19]\n\/\/ >>> count_up_to(1)\n\/\/ []\n\/\/ >>> count_up_to(18)\n\/\/ [2, 3, 5, 7, 11, 13, 17]\nfunction count_up_to(n){\n","canonical_solution":"function count_up_to(n) {\n    function isPrime(num) {\n        if (num < 2) return false;\n        for (let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++) {\n            if (num % i === 0) return false;\n        }\n        return true;\n    }\n\n    const primes = [];\n    for (let i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            primes.push(i);\n        }\n    }\n    return primes;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = count_up_to;\n  assert.deepEqual(candidate(5),[2, 3]);\n  assert.deepEqual(candidate(6),[2, 3, 5]);\n  assert.deepEqual(candidate(7),[2, 3, 5]);\n  assert.deepEqual(candidate(10),[2, 3, 5, 7]);\n  assert.deepEqual(candidate(0),[]);\n  assert.deepEqual(candidate(22),[2, 3, 5, 7, 11, 13, 17, 19]);\n  assert.deepEqual(candidate(1),[]);\n  assert.deepEqual(candidate(18),[2, 3, 5, 7, 11, 13, 17]);\n  assert.deepEqual(candidate(47),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);\n  assert.deepEqual(candidate(101),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n}\n\ntest();"},{"task_id":"HumanEval_97","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ pījimsim, ka īejis dati vysod ir dereigi. \/ tūs vīneibu cyparu reizynuojums. \/Pasaceit funkceju, kas pajam divejus vasalus skaitļus i atdūd \/\/ >>> multiply(148, 412)\n\/\/ 16\n\/\/ >>> multiply(19, 28)\n\/\/ 72\n\/\/ >>> multiply(2020, 1851)\n\/\/ 0\n\/\/ >>> multiply(14, -15)\n\/\/ 20\nfunction multiply(a, b){\n","canonical_solution":"function multiply(a, b) {\n    \/\/ Get the absolute value of each number\n    a = Math.abs(a);\n    b = Math.abs(b);\n\n    \/\/ Extract the unit digit of each number\n    let unitDigitA = a % 10;\n    let unitDigitB = b % 10;\n\n    \/\/ Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = multiply;\n  assert.deepEqual(candidate(148, 412),16);\n  assert.deepEqual(candidate(19, 28),72);\n  assert.deepEqual(candidate(2020, 1851),0);\n  assert.deepEqual(candidate(14, -15),20);\n  assert.deepEqual(candidate(76, 67),42);\n  assert.deepEqual(candidate(17, 27),49);\n  assert.deepEqual(candidate(0, 1),0);\n  assert.deepEqual(candidate(0, 0),0);\n}\n\ntest();"},{"task_id":"HumanEval_98","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/Dūdūt string s, apriekinu leluos burtu vokalu skaitu atseviškūs indeksuos. \/\/ >>> count_upper(\"aBCdEf\")\n\/\/ 1\n\/\/ >>> count_upper(\"abcdefg\")\n\/\/ 0\n\/\/ >>> count_upper(\"dBBE\")\n\/\/ 0\nfunction count_upper(s){\n","canonical_solution":"function count_upper(s) {\n    const vowels = new Set(['A', 'E', 'I', 'O', 'U']);\n    let count = 0;\n    for (let i = 0; i < s.length; i += 2) {\n        if (vowels.has(s[i])) {\n            count++;\n        }\n    }\n    return count;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = count_upper;\n  assert.deepEqual(candidate(\"aBCdEf\"),1);\n  assert.deepEqual(candidate(\"abcdefg\"),0);\n  assert.deepEqual(candidate(\"dBBE\"),0);\n  assert.deepEqual(candidate(\"B\"),0);\n  assert.deepEqual(candidate(\"U\"),1);\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"EEEE\"),2);\n}\n\ntest();"},{"task_id":"HumanEval_99","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri \/ nu diveju vasalūs skaitļu, apgrīžam nu nullis. \/ i atdūd tyvuokū vasalū skaitli.\/Dzeivuot funkceju, kas pījam vierteibu (saitis), kas apzeimoj skaitli.\/\/ >>> closest_integer(\"10\")\n\/\/ 10\n\/\/ >>> closest_integer(\"15.3\")\n\/\/ 15\n\/\/ Note:\n\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/ from two integers, the one you should return is the one that is the\n\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunction closest_integer(value){\n","canonical_solution":"function closest_integer(value) {\n    let num = parseFloat(value);\n    if (num > 0) {\n        return Math.floor(num + 0.5);\n    } else {\n        return Math.ceil(num - 0.5);\n    }\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = closest_integer;\n  assert.deepEqual(candidate(\"10\"),10);\n  assert.deepEqual(candidate(\"14.5\"),15);\n  assert.deepEqual(candidate(\"-15.5\"),-16);\n  assert.deepEqual(candidate(\"15.3\"),15);\n  assert.deepEqual(candidate(\"0\"),0);\n}\n\ntest();"},{"task_id":"HumanEval_100","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ i apzeimoj akmiņu skaitu leiminī (i+1). \/ Atdūd kotra leimiņa akmiņu skaitu matricā, kur elementam indeksā ir \/ - nuokušais pat skaitlis, ka n ir pat skaitlis. \/ - nuokušais najaušs skaitlis, ka n ir najaušs. \/ Nuokušajā leiminī akmiņu skaits ir: Pyrmajā leiminī ir n akmini.\/Dūdams pozitivu vasalu skaitli n, tev ir juosuoc kūpa ar n leimiņu akmiņim.\/\/ >>> make_a_pile(3)\n\/\/ [3, 5, 7]\nfunction make_a_pile(n){\n","canonical_solution":"function make_a_pile(n) {\n    const pile = [];\n    let currentStones = n;\n    \n    for (let i = 0; i < n; i++) {\n        pile.push(currentStones);\n        currentStones += (currentStones % 2 === 0) ? 2 : 2;\n    }\n\n    return pile;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = make_a_pile;\n  assert.deepEqual(candidate(3),[3, 5, 7]);\n  assert.deepEqual(candidate(4),[4, 6, 8, 10]);\n  assert.deepEqual(candidate(5),[5, 7, 9, 11, 13]);\n  assert.deepEqual(candidate(6),[6, 8, 10, 12, 14, 16]);\n  assert.deepEqual(candidate(8),[8, 10, 12, 14, 16, 18, 20, 22]);\n}\n\ntest();"},{"task_id":"HumanEval_101","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ daleit ryndys vuordūs i atsagrīzt vuordu kruojumu.Tev tiks pīduovuota vuordu seja, kas atškir ar atzeimem voi zeimem.\/\/ >>> words_string(\"Hi, my name is John\")\n\/\/ [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n\/\/ >>> words_string(\"One, two, three, four, five, six\")\n\/\/ [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nfunction words_string(s){\n","canonical_solution":"function words_string(s) {\n    \/\/ Split the string by removing commas and spaces, filter out any empty strings\n    return s.split(\/[\\s,]+\/).filter(Boolean);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = words_string;\n  assert.deepEqual(candidate(\"Hi, my name is John\"),[\"Hi\", \"my\", \"name\", \"is\", \"John\"]);\n  assert.deepEqual(candidate(\"One, two, three, four, five, six\"),[\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]);\n  assert.deepEqual(candidate(\"Hi, my name\"),[\"Hi\", \"my\", \"name\"]);\n  assert.deepEqual(candidate(\"One,, two, three, four, five, six,\"),[\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]);\n  assert.deepEqual(candidate(\"\"),[]);\n  assert.deepEqual(candidate(\"ahmed     , gamal\"),[\"ahmed\", \"gamal\"]);\n}\n\ntest();"},{"task_id":"HumanEval_102","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ nav taida skaitļa, tod funkcejai byutu juosaver -1. \/ leluokais pat skaitlis, kas ir diapazonā [x, y] īkļautā.\/Itei funkceja pajam divejus pozitivus skaitļus x i y i atdūd \/\/ >>> choose_num(12, 15)\n\/\/ 14\n\/\/ >>> choose_num(13, 12)\n\/\/ -1\nfunction choose_num(x, y){\n","canonical_solution":"function choose_num(x, y) {\n    if (x > y) {\n        return -1;\n    }\n    for (let i = y; i >= x; i--) {\n        if (i % 2 === 0) {\n            return i;\n        }\n    }\n    return -1;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = choose_num;\n  assert.deepEqual(candidate(12, 15),14);\n  assert.deepEqual(candidate(13, 12),-1);\n  assert.deepEqual(candidate(33, 12354),12354);\n  assert.deepEqual(candidate(5234, 5233),-1);\n  assert.deepEqual(candidate(6, 29),28);\n  assert.deepEqual(candidate(27, 10),-1);\n  assert.deepEqual(candidate(7, 7),-1);\n  assert.deepEqual(candidate(546, 546),546);\n}\n\ntest();"},{"task_id":"HumanEval_103","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ Ka n ir leluoks par m, atsoka -1. \/ Apsavierīni atbiļdi iz tyvuokū vasalū skaitli i puorvierīni tū par binarū skaitli. \/ vasalūs skaitļu n leidz m (tymā skaitā n i m) videjais skaitlis. Tevi teik pīškierti div pozitivi vasalī skaitli n i m, i tev ir juopīmiņ izskaiteit \/\/ >>> rounded_avg(1, 5)\n\/\/ \"0b11\"\n\/\/ >>> rounded_avg(7, 5)\n\/\/ -1\n\/\/ >>> rounded_avg(10, 20)\n\/\/ \"0b1111\"\n\/\/ >>> rounded_avg(20, 33)\n\/\/ \"0b11010\"\nfunction rounded_avg(n, m){\n","canonical_solution":"function rounded_avg(n, m) {\n    if (n > m) {\n        return -1;\n    }\n    \n    let sum = 0;\n    let count = 0;\n    \n    for (let i = n; i <= m; i++) {\n        sum += i;\n        count++;\n    }\n    \n    let average = sum \/ count;\n    let roundedAverage = Math.round(average);\n    return \"0b\" + roundedAverage.toString(2);\n}\n\n\/\/ Example Usage\nconsole.log(rounded_avg(1, 5));   \/\/ \"0b11\"\nconsole.log(rounded_avg(7, 5));   \/\/ -1\nconsole.log(rounded_avg(10, 20)); \/\/ \"0b1111\"\nconsole.log(rounded_avg(20, 33)); \/\/ \"0b11010\"","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = rounded_avg;\n  assert.deepEqual(candidate(1, 5),\"0b11\");\n  assert.deepEqual(candidate(7, 13),\"0b1010\");\n  assert.deepEqual(candidate(964, 977),\"0b1111001010\");\n  assert.deepEqual(candidate(996, 997),\"0b1111100100\");\n  assert.deepEqual(candidate(560, 851),\"0b1011000010\");\n  assert.deepEqual(candidate(185, 546),\"0b101101110\");\n  assert.deepEqual(candidate(362, 496),\"0b110101101\");\n  assert.deepEqual(candidate(350, 902),\"0b1001110010\");\n  assert.deepEqual(candidate(197, 233),\"0b11010111\");\n  assert.deepEqual(candidate(7, 5),-1);\n  assert.deepEqual(candidate(5, 1),-1);\n  assert.deepEqual(candidate(5, 5),\"0b101\");\n}\n\ntest();"},{"task_id":"HumanEval_104","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ Napīmiņu: atvārtūšuo kuorteiba ir juosaškir pīaugūša kuorteibā. \/ elementim, kurim nav pat ciparu. \/Dūdams pozitivu vasalūs skaitļu sareikuojumu x. atsagrīž sakuortuots vysūs \/\/ >>> unique_digits([15, 33, 1422, 1])\n\/\/ [1, 15, 33]\n\/\/ >>> unique_digits([152, 323, 1422, 10])\n\/\/ []\nfunction unique_digits(x){\n","canonical_solution":"function unique_digits(x) {\n    return x.filter(num => {\n        return !num.toString().split('').some(digit => digit % 2 === 0);\n    }).sort((a, b) => a - b);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = unique_digits;\n  assert.deepEqual(candidate([15, 33, 1422, 1]),[1, 15, 33]);\n  assert.deepEqual(candidate([152, 323, 1422, 10]),[]);\n  assert.deepEqual(candidate([12345, 2033, 111, 151]),[111, 151]);\n  assert.deepEqual(candidate([135, 103, 31]),[31, 135]);\n}\n\ntest();"},{"task_id":"HumanEval_105","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ \"Vīns\", \"Divi\", \"Treši\", \"Cytur\", \"Pytumi\", \"Seši\", \"Septumi\", \"Osmumi\", \"Nausi\". \/ apgrīž rezultata kūpumu i tod aizstuoj kotru cyparu ar atbylstūšū nūsaukumu nu \/Dūdūt vasalūs skaitļu sareikuojumu, sortoj vasalūs skaitļus, kas ir nu 1 leidz 9 (ieskaitot), \/\/ >>> by_length([2, 1, 1, 4, 5, 8, 2, 3])\n\/\/ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\/\/ If the array is empty, return an empty array:\n\/\/ >>> by_length([])\n\/\/ []\n\/\/ If the array has any strange number ignore it:\n\/\/ >>> by_length([1, -1, 55])\n\/\/ [\"One\"]\nfunction by_length(arr){\n","canonical_solution":"function by_length(arr) {\n  const numberNames = [\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\",\n    \"Six\", \"Seven\", \"Eight\", \"Nine\"\n  ];\n\n  return arr.filter(num => num >= 1 && num <= 9)\n            .sort((a, b) => a - b)\n            .reverse()\n            .map(num => numberNames[num - 1]);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = by_length;\n  assert.deepEqual(candidate([2, 1, 1, 4, 5, 8, 2, 3]),[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, -1, 55]),[\"One\"]);\n  assert.deepEqual(candidate([1, -1, 3, 2]),[\"Three\", \"Two\", \"One\"]);\n  assert.deepEqual(candidate([9, 4, 8]),[\"Nine\", \"Eight\", \"Four\"]);\n}\n\ntest();"},{"task_id":"HumanEval_106","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ i faktorials ir skaitļu reizynuošona nu 1 leidz i (1 * 2 * ... * i).\/i suocās nu 1. \/ voi cytaiž skaitļu summa nu 1 leidz i. \/ i atdūd lelumu n matricys, taidu, ka elementu vierteiba indeksā i ir i faktorials, ka i ir puors.\/Īsnīgt funkceju f, kas pījam n par parametru, \/\/ >>> f(5)\n\/\/ [1, 2, 6, 24, 15]\nfunction f(n){\n","canonical_solution":"function f(n) {\n    function factorial(num) {\n        let result = 1;\n        for (let i = 2; i <= num; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    function sumUpTo(num) {\n        return (num * (num + 1)) \/ 2; \/\/ Sum of first num natural numbers\n    }\n\n    let result = [];\n    for (let i = 1; i <= n; i++) {\n        if (i % 2 === 0) {\n            result.push(factorial(i));\n        } else {\n            result.push(sumUpTo(i));\n        }\n    }\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = f;\n  assert.deepEqual(candidate(5),[1, 2, 6, 24, 15]);\n  assert.deepEqual(candidate(7),[1, 2, 6, 24, 15, 720, 28]);\n  assert.deepEqual(candidate(1),[1]);\n  assert.deepEqual(candidate(3),[1, 2, 6]);\n}\n\ntest();"},{"task_id":"HumanEval_107","nl":"ltg_Latn","pl":"js","prompt":"\/ pīmārs 1: \/ vasalī palindromi, kas atsarūn diapazonā (n), īkļaunūt. \/Dūdams pozitivu vasalu skaitli n, atsagrīž matricā, kurā ir pat i napatīsu skaitļu skaits.\/\/ >>> even_odd_palindrome(3)\n\/\/ [1, 2]\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/ Example 2:\n\/\/ >>> even_odd_palindrome(12)\n\/\/ [4, 6]\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/ Note:\n\/\/ 1. 1 <= n <= 10^3\n\/\/ 2. returned array has the number of even and odd integer palindromes respectively.\nfunction even_odd_palindrome(n){\n","canonical_solution":"function even_odd_palindrome(n) {\n    function isPalindrome(num) {\n        let str = num.toString();\n        return str === str.split('').reverse().join('');\n    }\n\n    let evenCount = 0;\n    let oddCount = 0;\n\n    for (let i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 === 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return [evenCount, oddCount];\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = even_odd_palindrome;\n  assert.deepEqual(candidate(123),[8, 13]);\n  assert.deepEqual(candidate(12),[4, 6]);\n  assert.deepEqual(candidate(3),[1, 2]);\n  assert.deepEqual(candidate(63),[6, 8]);\n  assert.deepEqual(candidate(25),[5, 6]);\n  assert.deepEqual(candidate(19),[4, 6]);\n  assert.deepEqual(candidate(9),[4, 5]);\n  assert.deepEqual(candidate(1),[0, 1]);\n}\n\ntest();"},{"task_id":"HumanEval_108","nl":"ltg_Latn","pl":"js","prompt":"\/ pīvadumam, -123 ir pīraksteiti cypari -1, 2 i 3. \/ Ka skaitlis ir nagativs, tod pyrmais pīrakstieits cypars byus nagativs: \/ elementu skaits, kur skaitļu summa ir > 0. \/Skaiti funkceju count_nums, kas pajam vasalūs skaitļu sareiku i atdūd \/\/ >>> count_nums([])\n\/\/ 0\n\/\/ >>> count_nums([-1, 11, -11])\n\/\/ 1\n\/\/ >>> count_nums([1, 1, 2])\n\/\/ 3\nfunction count_nums(arr){\n","canonical_solution":"function count_nums(arr) {\n    return arr.reduce((count, num) => {\n        let str = num.toString();\n        let sum = 0;\n        for (let i = 0; i < str.length; i++) {\n            if (i === 0 && str[i] === '-') {\n                continue;\n            }\n            sum += parseInt(str[i]);\n        }\n        if (num < 0) {\n            sum += 2 * parseInt(str[1]); \/\/ Adjust for the negative signed digit\n        }\n        return sum > 0 ? count + 1 : count;\n    }, 0);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = count_nums;\n  assert.deepEqual(candidate([]),0);\n  assert.deepEqual(candidate([-1, -2, 0]),0);\n  assert.deepEqual(candidate([1, 1, 2, -2, 3, 4, 5]),6);\n  assert.deepEqual(candidate([1, 6, 9, -6, 0, 1, 5]),5);\n  assert.deepEqual(candidate([1, 100, 98, -7, 1, -1]),4);\n  assert.deepEqual(candidate([12, 23, 34, -45, -56, 0]),5);\n  assert.deepEqual(candidate([0, 1]),1);\n  assert.deepEqual(candidate([1]),1);\n}\n\ntest();"},{"task_id":"HumanEval_109","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ Napīmiņu: Dāts matracs garantāti ir ar unikalu elementu. \/ Ka nūteiktais kuorteiba ir tukša, tod atsagrīž patīsa.\/ tod atsagrīž patīsai, cytaiž atsagrīž napareizi.\/ Ka ir īspiejams dabuot sortuojušū tauteibu, veicūt augšupījimtū darbeibu \/ suokuma poziceja matricā, tys ir, 0. indekss. \/ poziceja pareizajā vierzīnī. Pādejais array elementu puornosuots iz \/ Vīna lobā nūviertiejuma darbeiba nūzeimoj, ka vysi matrica elementi teik nūviertieiti par vīnu .Tev ir atļauts veikt lobā nūvierzis darbeibu sevkurā laikā.\/ itaida darbeiba ar nūteiktu viersyunu: \/ ir īspiejams dabuot matricys sortiešonu na mozuokā kuortā, dareidams \/ skaitli matricā tiks najauši sakuortuoti. Tovs uzdavums ir nūsaceit, voi \/Mums ir matrica \"arr\" ar N vasalūs skaitļu arr[1], arr[2], ..., arr[N].\/\/ >>> move_one_ball([3, 4, 5, 1, 2])\n\/\/ true\n\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/ be achieved for the given array.\n\/\/ >>> move_one_ball([3, 5, 4, 1, 2])\n\/\/ false\n\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/ array by performing any number of right shift operations.\nfunction move_one_ball(arr){\n","canonical_solution":"function move_one_ball(arr) {\n    \/\/ If the array is empty, it's trivially sorted\n    if (arr.length === 0) return true;\n\n    \/\/ Count the number of positions where the next element is smaller than the current one\n    let dropCount = 0;\n    let n = arr.length;\n\n    for (let i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            dropCount++;\n        }\n    }\n\n    \/\/ If the drop count is more than 1, it means more than one drop is there\n    \/\/ and thus we cannot sort it with right shifts\n    return dropCount <= 1;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = move_one_ball;\n  assert.deepEqual(candidate([3, 4, 5, 1, 2]),true);\n  assert.deepEqual(candidate([3, 5, 10, 1, 2]),true);\n  assert.deepEqual(candidate([4, 3, 1, 2]),false);\n  assert.deepEqual(candidate([3, 5, 4, 1, 2]),false);\n  assert.deepEqual(candidate([]),true);\n}\n\ntest();"},{"task_id":"HumanEval_110","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ Cytaidā gadīnī atsyuti \"NE\". \/ vysus lst1 elementus, lai tī byutu pat, atsoka \"YES\". \/ Ka ir īspieja apmaineit elementus storp lst1 i lst2 , kab izveiduotu \/ Nav īrūbežuojuma dažaidim elementsim, kas teik apmaineiti storp lst1 i lst2. \/ storp jim, kab LST1 padareitu tikai puora skaitļu sakuortu.\/ i nūsoka , voi ir īspiejams veikt elementu apmaiņu \/Itamā problemā tu īvārojsi funkceju, kas pījam divejus skaitļu sareikus, \/\/ >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])\n\/\/ \"YES\"\n\/\/ >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n\/\/ \"NO\"\n\/\/ It is assumed that the input arrays will be non-empty.\nfunction exchange(lst1, lst2){\n","canonical_solution":"function exchange(lst1, lst2) {\n    \/\/ Check if lst1 already consists of only even numbers\n    let allEvenLst1 = lst1.every(num => num % 2 === 0);\n    if (allEvenLst1) return \"YES\";\n    \n    \/\/ Check if there's at least one even number in lst2\n    let hasEvenInLst2 = lst2.some(num => num % 2 === 0);\n    \n    \/\/ If there is at least one even number in lst2, it's possible to perform an exchange\n    \/\/ to make all elements in lst1 even\n    if (hasEvenInLst2) return \"YES\";\n    \n    \/\/ If no conditions above are met, it's not possible to make lst1 all even\n    return \"NO\";\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = exchange;\n  assert.deepEqual(candidate([1, 2, 3, 4], [1, 2, 3, 4]),\"YES\");\n  assert.deepEqual(candidate([1, 2, 3, 4], [1, 5, 3, 4]),\"NO\");\n  assert.deepEqual(candidate([1, 2, 3, 4], [2, 1, 4, 3]),\"YES\");\n  assert.deepEqual(candidate([5, 7, 3], [2, 6, 4]),\"YES\");\n  assert.deepEqual(candidate([5, 7, 3], [2, 6, 3]),\"NO\");\n  assert.deepEqual(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]),\"NO\");\n  assert.deepEqual(candidate([100, 200], [200, 200]),\"YES\");\n}\n\ntest();"},{"task_id":"HumanEval_111","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: Ka vairuokūs burtu ir vīna i tei poša līta, atsyuti vysus.\/ burta, kas ir vairuokys reižu atkuortuots i satur atbylstūšu skaitli. \/Dūdūt string, kas attāluos zeimūgi atškireigus mozuos burtu, atsagrīž objekts \/\/ >>> histogram(\"a b c\")\n\/\/ {\"a\": 1, \"b\": 1, \"c\": 1}\n\/\/ >>> histogram(\"a b b a\")\n\/\/ {\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"a b c a b\")\n\/\/ {\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"b b b b a\")\n\/\/ {\"b\": 4}\n\/\/ >>> histogram(\"\")\n\/\/ {}\nfunction histogram(test){\n","canonical_solution":"function histogram(test) {\n  if (!test) return {};\n  \n  const letters = test.split(' ');\n  const letterCount = {};\n  \n  for (let letter of letters) {\n    if (letterCount[letter]) {\n      letterCount[letter]++;\n    } else {\n      letterCount[letter] = 1;\n    }\n  }\n  \n  let maxCount = 0;\n  for (let count of Object.values(letterCount)) {\n    if (count > maxCount) {\n      maxCount = count;\n    }\n  }\n  \n  const result = {};\n  for (let [letter, count] of Object.entries(letterCount)) {\n    if (count === maxCount) {\n      result[letter] = count;\n    }\n  }\n  \n  return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = histogram;\n  assert.deepEqual(candidate(\"a b b a\"),{\"a\": 2, \"b\": 2});\n  assert.deepEqual(candidate(\"a b c a b\"),{\"a\": 2, \"b\": 2});\n  assert.deepEqual(candidate(\"a b c d g\"),{\"a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"r t g\"),{\"r\": 1, \"t\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"b b b b a\"),{\"b\": 4});\n  assert.deepEqual(candidate(\"r t g\"),{\"r\": 1, \"t\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"\"),{});\n  assert.deepEqual(candidate(\"a\"),{\"a\": 1});\n}\n\ntest();"},{"task_id":"HumanEval_112","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs \/ Tev juopuorsyut matrica, kas satur rezultata ryndys i puorbaudei ir patīsa\/nepaga. \/ Strīņom sauc palindromu, ka tuos skaiteita taipoš aizmugurē kai prīškā. \/ tod puorbaudi, voi rezultata kuorta ir palindroms. \/ Mums ir dūmuotys divejis ryndys s i c, tev ir juosuoc vysi s burti, kas ir vīnaidi ar sevkuru c burtu.\/Iepūdeits \/\/ >>> reverse_delete(\"abcde\", \"ae\")\n\/\/ [\"bcd\", false]\n\/\/ >>> reverse_delete(\"abcdef\", \"b\")\n\/\/ [\"acdef\", false]\n\/\/ >>> reverse_delete(\"abcdedcba\", \"ab\")\n\/\/ [\"cdedc\", true]\nfunction reverse_delete(s, c){\n","canonical_solution":"function reverse_delete(s, c) {\n    let result = '';\n    \/\/ Create a set of characters to be deleted\n    const deleteChars = new Set(c);\n    \n    \/\/ Construct the result string excluding the characters in c\n    for (let char of s) {\n        if (!deleteChars.has(char)) {\n            result += char;\n        }\n    }\n    \n    \/\/ Check if the result string is a palindrome\n    const isPalindrome = result === result.split('').reverse().join('');\n    \n    return [result, isPalindrome];\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = reverse_delete;\n  assert.deepEqual(candidate(\"abcde\", \"ae\"),[\"bcd\", false]);\n  assert.deepEqual(candidate(\"abcdef\", \"b\"),[\"acdef\", false]);\n  assert.deepEqual(candidate(\"abcdedcba\", \"ab\"),[\"cdedc\", true]);\n  assert.deepEqual(candidate(\"dwik\", \"w\"),[\"dik\", false]);\n  assert.deepEqual(candidate(\"a\", \"a\"),[\"\", true]);\n  assert.deepEqual(candidate(\"abcdedcba\", \"\"),[\"abcdedcba\", true]);\n  assert.deepEqual(candidate(\"abcdedcba\", \"v\"),[\"abcdedcba\", true]);\n  assert.deepEqual(candidate(\"vabba\", \"v\"),[\"abba\", true]);\n  assert.deepEqual(candidate(\"mamma\", \"mia\"),[\"\", true]);\n}\n\ntest();"},{"task_id":"HumanEval_113","nl":"ltg_Latn","pl":"js","prompt":"\/ najaušu cyparu skaits i'tajā īejis ryndā. \/ i īejis burta. \" kur vysus i juomaina ar skaitli \/ Kotram izvaduma elementam i juobyut \"najaušu elementu skaitam \/Dūdūt stringim, kur kotra stringis sastuov nu vīneigajim ciparim, atsagrīž array.\/\/ >>> odd_count([\"1234567\"])\n\/\/ [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\/\/ >>> odd_count([\"3\", \"11111111\"])\n\/\/ [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nfunction odd_count(lst){\n","canonical_solution":"function odd_count(lst) {\n    return lst.map(str => {\n        const oddCount = Array.from(str).filter(ch => parseInt(ch) % 2 !== 0).length;\n        let sentence = \"the number of odd elements in the string i of the input.\";\n        return sentence.replace(\/i\/g, oddCount.toString());\n    });\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = odd_count;\n  assert.deepEqual(candidate([\"1234567\"]),[\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]);\n  assert.deepEqual(candidate([\"3\", \"11111111\"]),[\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]);\n  assert.deepEqual(candidate([\"271\", \"137\", \"314\"]),[\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"]);\n}\n\ntest();"},{"task_id":"HumanEval_114","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs \/ nu skaitļu. \/Dūdūt vasalūs skaitļu sareiku, atrodi sevkurys na tukšys apakškareibys minimumu \/\/ >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n\/\/ 1\n\/\/ >>> minSubArraySum([-1, -2, -3])\n\/\/ -6\nfunction minSubArraySum(nums){\n","canonical_solution":"function minSubArraySum(nums) {\n    let minSum = nums[0];\n    let currentSum = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (currentSum > 0) {\n            currentSum = nums[i];\n        } else {\n            currentSum += nums[i];\n        }\n        minSum = Math.min(minSum, currentSum);\n    }\n    \n    return minSum;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = minSubArraySum;\n  assert.deepEqual(candidate([2, 3, 4, 1, 2, 4]),1);\n  assert.deepEqual(candidate([-1, -2, -3]),-6);\n  assert.deepEqual(candidate([-1, -2, -3, 2, -10]),-14);\n  assert.deepEqual(candidate([-9999999999999999]),-9999999999999999);\n  assert.deepEqual(candidate([0, 10, 20, 1000000]),0);\n  assert.deepEqual(candidate([-1, -2, -3, 10, -5]),-6);\n  assert.deepEqual(candidate([100, -1, -2, -3, 10, -5]),-6);\n  assert.deepEqual(candidate([10, 11, 13, 8, 3, 4]),3);\n  assert.deepEqual(candidate([100, -33, 32, -1, 0, -2]),-33);\n  assert.deepEqual(candidate([-10]),-10);\n  assert.deepEqual(candidate([7]),7);\n  assert.deepEqual(candidate([1, -1]),-1);\n}\n\ntest();"},{"task_id":"HumanEval_115","nl":"ltg_Latn","pl":"js","prompt":"\/ pīmārs 1: \/ Izsaceit skaitu, cik reižu vajag pazemynuot tūrņus. Tovi aizdavumi ir izmontuot tova īspieja iztukšynuot olūtus.\/ i vysim tūrnim ir vīnaida kapacitate. \/ Kotram olūtam ir atbylstūšs eiksts, kū var izmontuot, kab nu tuo atgiutu iudini, \/ i kotrs 1 ryndā apzeimoj vīnu i tū pošu iudiņa vīneibu. Teik dūta taisnstūrveida olūtūs teikla, kotra rynds apzeimoj vīnu olūtu.\/\/ >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n\/\/ 6\n\/\/ Example 2:\n\/\/ >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n\/\/ 5\n\/\/ Example 3:\n\/\/ >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n\/\/ 0\n\/\/ Constraints:\n\/\/ * all wells have the same length\n\/\/ * 1 <= grid.length <= 10^2\n\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/ * grid[i][j] -> 0 | 1\n\/\/ * 1 <= capacity <= 10\nfunction max_fill(grid, capacity){\n","canonical_solution":"function max_fill(grid, capacity) {\n    let totalWater = 0;\n    \n    for (let row of grid) {\n        for (let cell of row) {\n            totalWater += cell;\n        }\n    }\n    \n    return Math.ceil(totalWater \/ capacity);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();"},{"task_id":"HumanEval_116","nl":"ltg_Latn","pl":"js","prompt":"\/ Tū juodora tai: \/ Leidz leidzeiga skaitļa \"vīni\" veiduošonā, rūsynojūt piec decimalvierteibys. \/ skaitļu skaits tūs binarūs attāluojumā augšupīaugšūs kuortā. \/Itamā kata, tev ir juosaškir navnegativūs vasalūs skaitļu sareiks piec \/\/ >>> sort_array([1, 5, 2, 3, 4])\n\/\/ [1, 2, 3, 4, 5]\n\/\/ >>> sort_array([-2, -3, -4, -5, -6])\n\/\/ [-6, -5, -4, -3, -2]\n\/\/ >>> sort_array([1, 0, 2, 3, 4])\n\/\/ [0, 1, 2, 3, 4]\nfunction sort_array(arr){\n","canonical_solution":"function sort_array(arr) {\n    return arr.slice().sort((a, b) => {\n        const countOnes = num => num.toString(2).split('0').join('').length;\n        const onesA = countOnes(a);\n        const onesB = countOnes(b);\n        if (onesA === onesB) {\n            return a - b;\n        }\n        return onesA - onesB;\n    });\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sort_array;\n  assert.deepEqual(candidate([1, 5, 2, 3, 4]),[1, 2, 4, 3, 5]);\n  assert.deepEqual(candidate([-2, -3, -4, -5, -6]),[-4, -2, -6, -5, -3]);\n  assert.deepEqual(candidate([1, 0, 2, 3, 4]),[0, 1, 2, 4, 3]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]),[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n  assert.deepEqual(candidate([3, 6, 44, 12, 32, 5]),[32, 3, 5, 6, 12, 44]);\n  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);\n  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);\n}\n\ntest();"},{"task_id":"HumanEval_117","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Napīmiņu: var pījimt, ka īejis stringā ir tikai burti i atstarpi. \/ Ka string s ir tukšs, tod funkcejai juosauce tukšs array. \/n kūdulīki, tai, ka itī vuordi pasaruoda s ryndā. \/ ir funkceja, kas atdūd vysu vuordu viersu s, kas satur precizi \/Dūdūt string s i naturalu skaitli n, tev ir pīduovuots īvāruot \/\/ >>> select_words(\"Mary had a little lamb\", 4)\n\/\/ [\"little\"]\n\/\/ >>> select_words(\"Mary had a little lamb\", 3)\n\/\/ [\"Mary\", \"lamb\"]\n\/\/ >>> select_words(\"simple white space\", 2)\n\/\/ []\n\/\/ >>> select_words(\"Hello world\", 4)\n\/\/ [\"world\"]\n\/\/ >>> select_words(\"Uncle sam\", 3)\n\/\/ [\"Uncle\"]\nfunction select_words(s, n){\n","canonical_solution":"function select_words(s, n) {\n    const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);\n    const words = s.split(' ');\n    const result = [];\n\n    for (let word of words) {\n        let consonantCount = 0;\n        \n        for (let char of word) {\n            if (!vowels.has(char)) {\n                consonantCount += 1;\n            }\n        }\n\n        if (consonantCount === n) {\n            result.push(word);\n        }\n    }\n\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = select_words;\n  assert.deepEqual(candidate(\"Mary had a little lamb\", 4),[\"little\"]);\n  assert.deepEqual(candidate(\"Mary had a little lamb\", 3),[\"Mary\", \"lamb\"]);\n  assert.deepEqual(candidate(\"simple white space\", 2),[]);\n  assert.deepEqual(candidate(\"Hello world\", 4),[\"world\"]);\n  assert.deepEqual(candidate(\"Uncle sam\", 3),[\"Uncle\"]);\n  assert.deepEqual(candidate(\"\", 4),[]);\n  assert.deepEqual(candidate(\"a b c d e f\", 1),[\"b\", \"c\", \"d\", \"f\"]);\n}\n\ntest();"},{"task_id":"HumanEval_118","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ Var pījēst, ka dūtajā ryndā ir tikai angļu burts. \/ atroduot kaidu klāvū, kas sasnēdz augšupījimus prasejumus. \/ Vuordineica suokumā i beiguos nateik skaiteita. atsagrīž tukša string, ja nav.\/ div kūpšvuordi nu vuorda lobys pusis (mainuos burtu). Tev ir vuords, i tev ir juoatrūn tyvuokuo vokala, kas atsarūn storp juo i vokalu.\/\/ >>> get_closest_vowel(\"yogurt\")\n\/\/ \"u\"\n\/\/ >>> get_closest_vowel(\"FULL\")\n\/\/ \"U\"\n\/\/ >>> get_closest_vowel(\"quick\")\n\/\/ \"\"\n\/\/ >>> get_closest_vowel(\"ab\")\n\/\/ \"\"\nfunction get_closest_vowel(word){\n","canonical_solution":"function get_closest_vowel(word) {\n    const vowels = \"aeiouAEIOU\";\n\n    for (let i = word.length - 2; i > 0; i--) {\n        if (vowels.includes(word[i]) && \n            !vowels.includes(word[i - 1]) && \n            !vowels.includes(word[i + 1])) {\n            return word[i];\n        }\n    }\n\n    return \"\";\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_closest_vowel;\n  assert.deepEqual(candidate(\"yogurt\"),\"u\");\n  assert.deepEqual(candidate(\"full\"),\"u\");\n  assert.deepEqual(candidate(\"easy\"),\"\");\n  assert.deepEqual(candidate(\"eAsy\"),\"\");\n  assert.deepEqual(candidate(\"ali\"),\"\");\n  assert.deepEqual(candidate(\"bad\"),\"a\");\n  assert.deepEqual(candidate(\"most\"),\"o\");\n  assert.deepEqual(candidate(\"ab\"),\"\");\n  assert.deepEqual(candidate(\"ba\"),\"\");\n  assert.deepEqual(candidate(\"quick\"),\"\");\n  assert.deepEqual(candidate(\"anime\"),\"i\");\n  assert.deepEqual(candidate(\"Asia\"),\"\");\n  assert.deepEqual(candidate(\"Above\"),\"o\");\n}\n\ntest();"},{"task_id":"HumanEval_119","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Atdūd \"jā\", ka ir veids, kai izveiduot lobu seceibu, i cytureiz atdūd \"nē\". \/ \"()) \" nav.\/ ir balansātys. Par pīmāru: string \"(()))) \" ir lobs, bet string \/ Strīde S teik skaiteita par lobu, ka i tikai ka vysys aizmuguris S \/ kaids kuortys, ka rezultata kuorta byus loba.Tovs dorbs ir puorbaudeit, voi ir īspiejams sasavīnuot obejis stringis.\/ tikai storpkōrūs \" ((\") voi tyvōkūs storpkōrūs \") \". Te jums ir dūts diveju stīmu array, obejis stīmis sastuov nu atvārtu.\/\/ >>> match_parens([\"()(\", \")\"])\n\/\/ \"Yes\"\n\/\/ >>> match_parens([\")\", \")\"])\n\/\/ \"No\"\nfunction match_parens(lst){\n","canonical_solution":"function match_parens(lst) {\n    function isBalanced(str) {\n        let balance = 0;\n        for (let char of str) {\n            if (char === '(') {\n                balance++;\n            } else {\n                balance--;\n            }\n            if (balance < 0) return false;\n        }\n        return balance === 0;\n    }\n\n    const [s1, s2] = lst;\n    if (isBalanced(s1 + s2) || isBalanced(s2 + s1)) {\n        return 'Yes';\n    }\n    return 'No';\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\");\n  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"(()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\")(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"},{"task_id":"HumanEval_120","nl":"ltg_Latn","pl":"js","prompt":"\/ pīmārs 1: \/ garuma k ar maksimalu k skaitļu arr. \/Dūdūt pylnvierteigūs skaitļu sakuortuotu vierteibu arr i pozitivu vasalu skaitli k, atsagrīž sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots vierteibys sakuortuots\/\/ >>> maximum([-3, -4, 5], 3)\n\/\/ [-4, -3, 5]\n\/\/ Example 2:\n\/\/ >>> maximum([4, -4, 4], 2)\n\/\/ [4, 4]\n\/\/ Example 3:\n\/\/ >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n\/\/ [2]\n\/\/ Note:\n\/\/ 1. The length of the array will be in the range of [1, 1000].\n\/\/ 2. The elements in the array will be in the range of [-1000, 1000].\n\/\/ 3. 0 <= k <= len(arr)\nfunction maximum(arr, k){\n","canonical_solution":"function maximum(arr, k) {\n    return arr.sort((a, b) => b - a).slice(0, k).sort((a, b) => a - b);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maximum;\n  assert.deepEqual(candidate([-3, -4, 5], 3),[-4, -3, 5]);\n  assert.deepEqual(candidate([4, -4, 4], 2),[4, 4]);\n  assert.deepEqual(candidate([-3, 2, 1, 2, -1, -2, 1], 1),[2]);\n  assert.deepEqual(candidate([123, -123, 20, 0, 1, 2, -3], 3),[2, 20, 123]);\n  assert.deepEqual(candidate([-123, 20, 0, 1, 2, -3], 4),[0, 1, 2, 20]);\n  assert.deepEqual(candidate([5, 15, 0, 3, -13, -8, 0], 7),[-13, -8, 0, 0, 3, 5, 15]);\n  assert.deepEqual(candidate([-1, 0, 2, 5, 3, -10], 2),[3, 5]);\n  assert.deepEqual(candidate([1, 0, 5, -7], 1),[5]);\n  assert.deepEqual(candidate([4, -4], 2),[-4, 4]);\n  assert.deepEqual(candidate([-10, 10], 2),[-10, 10]);\n  assert.deepEqual(candidate([1, 2, 3, -23, 243, -400, 0], 0),[]);\n}\n\ntest();"},{"task_id":"HumanEval_121","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri \/Dūdūt na tukšu vasalūs skaitļu sareiku, atsoka vysūs najaušajuos elementu summu, kas ir pat pozicejuos. \/\/ >>> solution([5, 8, 7, 1])\n\/\/ 12\n\/\/ >>> solution([3, 3, 3, 3, 3])\n\/\/ 9\n\/\/ >>> solution([30, 13, 24, 321])\n\/\/ 0\nfunction solution(lst){\n","canonical_solution":"function solution(lst) {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i += 2) {\n        if (lst[i] % 2 !== 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = solution;\n  assert.deepEqual(candidate([5, 8, 7, 1]),12);\n  assert.deepEqual(candidate([3, 3, 3, 3, 3]),9);\n  assert.deepEqual(candidate([30, 13, 24, 321]),0);\n  assert.deepEqual(candidate([5, 9]),5);\n  assert.deepEqual(candidate([2, 4, 8]),0);\n  assert.deepEqual(candidate([30, 13, 23, 32]),23);\n  assert.deepEqual(candidate([3, 13, 2, 9]),3);\n}\n\ntest();"},{"task_id":"HumanEval_122","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ elementu summa, kam ir vysmoz diveji cypari nu pyrmūs k arr elementu. \/Dūdūt na tukšu vasalūs skaitļu sareiku arr i vasalū skaitli k, atsagrīž \/\/ >>> add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n\/\/ 24\n\/\/ Constraints:\n\/\/ 1. 1 <= len(arr) <= 100\n\/\/ 2. 1 <= k <= len(arr)\nfunction add_elements(arr, k){\n","canonical_solution":"function add_elements(arr, k) {\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        if (Math.abs(arr[i]) < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = add_elements;\n  assert.deepEqual(candidate([1, -2, -3, 41, 57, 76, 87, 88, 99], 3),-4);\n  assert.deepEqual(candidate([111, 121, 3, 4000, 5, 6], 2),0);\n  assert.deepEqual(candidate([11, 21, 3, 90, 5, 6, 7, 8, 9], 4),125);\n  assert.deepEqual(candidate([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4),24);\n  assert.deepEqual(candidate([1], 1),1);\n}\n\ntest();"},{"task_id":"HumanEval_123","nl":"ltg_Latn","pl":"js","prompt":"\/ get_odd_collatz(5) atdūd [1, 5] # Kollataču seceiba par 5 ir [5, 16, 8, 4, 2, 1], tai ka najauši skaitli ir tikai 1 i 5. \/ Par pīmāru: \/ 2. atvīnuotais viersroksts sakuortuots pīaugūšajā kuortā. \/ 1. Collatz(1) ir [1]. \/ Napīmiņu: \/ termins plus 1. Piec īdūmom, lai kaida ari byutu n vierteiba, seceiba vysod sasnāgs 1.Ka pyrmais terminu skaits ir najaušs, nuokušais ir 3 reizis pyrmais.\/ īprīškejū terminu kai: ka īprīškejū terminu ir puors, nuokušais terminu ir puse nu \/ taipoš: suoc ar sevkuru pozitivu vasalu skaitli n. Tod kotru terminu sajam nu \/ Kolca hipoteze ir hipoteze matematikā, kas saisteita ar definātu seceibu \/Dūdūt pozitivu vasalu skaitli n, atsagrīž sakuortuotais viersroksts, kurā ir najauši skaitli kollacis seceibā. \/\/ >>> get_odd_collatz(5)\n\/\/ [1, 5]\nfunction get_odd_collatz(n){\n","canonical_solution":"function get_odd_collatz(n) {\n    let collatzSequence = [];\n    while (n !== 1) {\n        if (n % 2 !== 0) {\n            collatzSequence.push(n);\n        }\n        n = n % 2 === 0 ? n \/ 2 : 3 * n + 1;\n    }\n    collatzSequence.push(1); \/\/ Include 1 as it's part of the sequence and is odd\n    return collatzSequence.sort((a, b) => a - b);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_odd_collatz;\n  assert.deepEqual(candidate(14),[1, 5, 7, 11, 13, 17]);\n  assert.deepEqual(candidate(5),[1, 5]);\n  assert.deepEqual(candidate(12),[1, 3, 5]);\n  assert.deepEqual(candidate(1),[1]);\n}\n\ntest();"},{"task_id":"HumanEval_124","nl":"ltg_Latn","pl":"js","prompt":"\/ 4. Datums juonūdrūsynoj itaidā formā: mm-dd-yyyy Mienešu skaits na mozuoks par 1 i na leluoks par 12.\/ 2. Mieneša 1,3,5,7,8,10,12 dīnrokstu skaits nav mozuoks par 1 voi leluoks par 31 dīnrokstu, mieneša 4,6,9,11 dīnrokstu skaits nav mozuoks par 1 voi leluoks par 30 dīnrokstu, mieneša 2 dīnrokstu skaits nav mozuoks par 1 voi leluoks par 29 dīnrokstu.\/ 1. Datums nav tukšs. \/ Datums ir dereigs, ka ir pījimti vysi itaidi nūsacejumi: \/ atdūd patīsu, ka data ir dereiga, cytaiž - nā. \/Jusim ir juopīrakstej funkceja, kas aplīcynoj nūteiktu datumu seikumu i \/\/ >>> valid_date(\"03-11-2000\")\n\/\/ true\n\/\/ >>> valid_date(\"15-01-2012\")\n\/\/ false\n\/\/ >>> valid_date(\"04-0-2040\")\n\/\/ false\n\/\/ >>> valid_date(\"06-04-2020\")\n\/\/ true\n\/\/ >>> valid_date(\"06\/04\/2020\")\n\/\/ false\nfunction valid_date(date){\n","canonical_solution":"function valid_date(date) {\n    if (!date) return false;\n    \n    \/\/ Regular expression to match the date pattern mm-dd-yyyy\n    const datePattern = \/^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-\\d{4}$\/;\n    if (!datePattern.test(date)) return false;\n\n    \/\/ Split the date into parts\n    const [month, day, year] = date.split('-').map(Number);\n\n    \/\/ Check the valid number of days per month\n    if (month === 2) {\n        \/\/ Check for February, normally 28 max days, 29 if leap year\n        const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n        if (day > 29 || (day === 29 && !isLeapYear)) return false;\n    } else if ([4, 6, 9, 11].includes(month)) {\n        \/\/ April, June, September, November have 30 max days\n        if (day > 30) return false;\n    } else {\n        \/\/ Other months have 31 max days\n        if (day > 31) return false;\n    }\n\n    return true;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = valid_date;\n  assert.deepEqual(candidate(\"03-11-2000\"),true);\n  assert.deepEqual(candidate(\"15-01-2012\"),false);\n  assert.deepEqual(candidate(\"04-0-2040\"),false);\n  assert.deepEqual(candidate(\"06-04-2020\"),true);\n  assert.deepEqual(candidate(\"01-01-2007\"),true);\n  assert.deepEqual(candidate(\"03-32-2011\"),false);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"04-31-3000\"),false);\n  assert.deepEqual(candidate(\"06-06-2005\"),true);\n  assert.deepEqual(candidate(\"21-31-2000\"),false);\n  assert.deepEqual(candidate(\"04-12-2003\"),true);\n  assert.deepEqual(candidate(\"04122003\"),false);\n  assert.deepEqual(candidate(\"20030412\"),false);\n  assert.deepEqual(candidate(\"2003-04\"),false);\n  assert.deepEqual(candidate(\"2003-04-12\"),false);\n  assert.deepEqual(candidate(\"04-2003\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_125","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri \/ alfabets, ord (a) = 0, ord (b) = 1, ... ord (z) = 25 \/ byutu juopadaleja ar atzeimem ',' ja atzeimem nav, tod juoatsoka mozuokuos burtu skaits \/Dūdūt vuordu seceibu, atsoka vuordu kūpumu, kas sadaleits iz vītom, ka tekstā nav vītom, kuru gribit nūruodeit.\/\/ >>> split_words(\"Hello world!\")\n\/\/ [\"Hello\", \"world!\"]\n\/\/ >>> split_words(\"Hello,world!\")\n\/\/ [\"Hello\", \"world!\"]\n\/\/ >>> split_words(\"abcdef\")\n\/\/ 3\nfunction split_words(txt){\n","canonical_solution":"function split_words(txt) {\n    if (\/\\s\/.test(txt)) {\n        \/\/ Split on whitespace if it exists\n        return txt.split(\/\\s+\/);\n    } else if (\/,\/.test(txt)) {\n        \/\/ Split on commas if no whitespace exists\n        return txt.split(',');\n    } else {\n        \/\/ Return count of lowercase letters with odd order in the alphabet\n        let oddOrderCount = 0;\n        for (let i = 0; i < txt.length; i++) {\n            let char = txt[i];\n            if (char >= 'a' && char <= 'z') {\n                let order = char.charCodeAt(0) - 'a'.charCodeAt(0);\n                if (order % 2 !== 0) {\n                    oddOrderCount++;\n                }\n            }\n        }\n        return oddOrderCount;\n    }\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = split_words;\n  assert.deepEqual(candidate(\"Hello world!\"),[\"Hello\", \"world!\"]);\n  assert.deepEqual(candidate(\"Hello,world!\"),[\"Hello\", \"world!\"]);\n  assert.deepEqual(candidate(\"Hello world,!\"),[\"Hello\", \"world,!\"]);\n  assert.deepEqual(candidate(\"Hello,Hello,world !\"),[\"Hello,Hello,world\", \"!\"]);\n  assert.deepEqual(candidate(\"abcdef\"),3);\n  assert.deepEqual(candidate(\"aaabb\"),2);\n  assert.deepEqual(candidate(\"aaaBb\"),1);\n  assert.deepEqual(candidate(\"\"),0);\n}\n\ntest();"},{"task_id":"HumanEval_126","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri \/ skaitlis, atsoka false. pījam, ka nav nagativūs skaitļu i tikai vasalūs skaitļu.\/ pīaugūša kuortā. Ka kuortā ir vaira kai 1 vīnaida dublikata, \/Dūdūt skaitļu sareiku, atsoka, voi tī ir saroksti voi nā.\/\/ >>> is_sorted([5])\n\/\/ true\n\/\/ >>> is_sorted([1, 2, 3, 4, 5])\n\/\/ true\n\/\/ >>> is_sorted([1, 3, 2, 4, 5])\n\/\/ false\n\/\/ >>> is_sorted([1, 2, 3, 4, 5, 6])\n\/\/ true\n\/\/ >>> is_sorted([1, 2, 3, 4, 5, 6, 7])\n\/\/ true\n\/\/ >>> is_sorted([1, 3, 2, 4, 5, 6, 7])\n\/\/ false\n\/\/ >>> is_sorted([1, 2, 2, 3, 3, 4])\n\/\/ true\n\/\/ >>> is_sorted([1, 2, 2, 2, 3, 4])\n\/\/ false\nfunction is_sorted(lst){\n","canonical_solution":"function is_sorted(lst) {\n    if (lst.length <= 1) return true;\n\n    for (let i = 0; i < lst.length - 1; i++) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n        if (lst[i] === lst[i + 1]) {\n            \/\/ Check if more than 1 duplicate by looking two steps ahead\n            if (i + 2 < lst.length && lst[i] === lst[i + 2]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_sorted;\n  assert.deepEqual(candidate([5]),true);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5]),true);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5]),false);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6]),true);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7]),true);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, 7]),false);\n  assert.deepEqual(candidate([]),true);\n  assert.deepEqual(candidate([1]),true);\n  assert.deepEqual(candidate([3, 2, 1]),false);\n  assert.deepEqual(candidate([1, 2, 2, 2, 3, 4]),false);\n  assert.deepEqual(candidate([1, 2, 3, 3, 3, 4]),false);\n  assert.deepEqual(candidate([1, 2, 2, 3, 3, 4]),true);\n  assert.deepEqual(candidate([1, 2, 3, 4]),true);\n}\n\ntest();"},{"task_id":"HumanEval_127","nl":"ltg_Latn","pl":"js","prompt":"\/ [īejis\/izejis] paraugi: \/ Ka diveji intervali nasaškērš, atsyuti \"NE\". \/ cytaiž atsoka \"NE\". \/ Ka krystpunkta garums ir pyrmskaitlis, atsoka \"YES\", \/ kuru garums ir 1, kas nav pyrmskaitlis. \/ Pīmārs, intervala (1, 3), (2, 4) krystpunkts ir (2, 3) \/ intervali ir pyrmskaitlis. Tovs uzdavums ir nūsaceit, voi tūs diveju krystpunkta garums ir\/ Kotram nūteiktam intervalam teik pījāmts, ka juo suokums ir mozuoks voi vīnaids ar beigom. \/ īkļaun gon suokumu, gon beigu. \/ Dūti intervali ir slāgti, kas nūzeimoj, ka intervals (suokums, beigas) \/ kur kotrs intervāls ir vasals skaitlis. Par pīmāru, intervāls = (suokums, beigas) = (1, 2).Tev ir divi intervali.\/\/ >>> intersection([1, 2], [2, 3])\n\/\/ \"NO\"\n\/\/ >>> intersection([-1, 1], [0, 4])\n\/\/ \"NO\"\n\/\/ >>> intersection([-3, -1], [-5, 5])\n\/\/ \"YES\"\nfunction intersection(interval1, interval2){\n","canonical_solution":"function intersection(interval1, interval2) {\n    const [start1, end1] = interval1;\n    const [start2, end2] = interval2;\n\n    \/\/ Determine the start and end of the intersection\n    const startIntersection = Math.max(start1, start2);\n    const endIntersection = Math.min(end1, end2);\n\n    \/\/ Calculate the length of the intersection\n    const intersectionLength = endIntersection - startIntersection;\n\n    \/\/ Helper function to check if a number is prime\n    function isPrime(num) {\n        if (num <= 1) return false;\n        if (num <= 3) return true;\n        if (num % 2 === 0 || num % 3 === 0) return false;\n        for (let i = 5; i * i <= num; i += 6) {\n            if (num % i === 0 || num % (i + 2) === 0) return false;\n        }\n        return true;\n    }\n\n    \/\/ Check if the length of the intersection is a prime number\n    return intersectionLength > 0 && isPrime(intersectionLength) ? \"YES\" : \"NO\";\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = intersection;\n  assert.deepEqual(candidate([1, 2], [2, 3]),\"NO\");\n  assert.deepEqual(candidate([-1, 1], [0, 4]),\"NO\");\n  assert.deepEqual(candidate([-3, -1], [-5, 5]),\"YES\");\n  assert.deepEqual(candidate([-2, 2], [-4, 0]),\"YES\");\n  assert.deepEqual(candidate([-11, 2], [-1, -1]),\"NO\");\n  assert.deepEqual(candidate([1, 2], [3, 5]),\"NO\");\n  assert.deepEqual(candidate([1, 2], [1, 2]),\"NO\");\n  assert.deepEqual(candidate([-2, -2], [-3, -2]),\"NO\");\n}\n\ntest();"},{"task_id":"HumanEval_128","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ Napīmiņu: atvīglynuots atdeve ar tukšom arom. \/ kotra skaitļa matricā, kas ir 1, -1 voi 0. \/ vasalu skaitļu leluma summa reizynuota ar vysūs zeimu reizynuojumu Tevi teik pīduovuots vasals skaitļu maiss, i tev vajag atsagrīzt.\/\/ >>> prod_signs([1, 2, 2, -4])\n\/\/ 9\n\/\/ >>> prod_signs([0, 1])\n\/\/ 0\n\/\/ >>> prod_signs([])\n\/\/ undefined\nfunction prod_signs(arr){\n","canonical_solution":"function prod_signs(arr) {\n    if (arr.length === 0) return undefined;\n\n    let sumOfMagnitudes = 0;\n    let productOfSigns = 1;\n\n    for (let num of arr) {\n        sumOfMagnitudes += Math.abs(num);\n        productOfSigns *= (num === 0 ? 0 : Math.sign(num));\n    }\n\n    return sumOfMagnitudes * productOfSigns;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = prod_signs;\n  assert.deepEqual(candidate([1, 2, 2, -4]),-9);\n  assert.deepEqual(candidate([0, 1]),0);\n  assert.deepEqual(candidate([1, 1, 1, 2, 3, -1, 1]),-10);\n  assert.deepEqual(candidate([]),undefined);\n  assert.deepEqual(candidate([2, 4, 1, 2, -1, -1, 9]),20);\n  assert.deepEqual(candidate([-1, 1, -1, 1]),4);\n  assert.deepEqual(candidate([-1, 1, 1, 1]),-4);\n  assert.deepEqual(candidate([-1, 1, 1, 0]),0);\n}\n\ntest();"},{"task_id":"HumanEval_129","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Atdūd nūlyktu vierteibu maisiņu vītā, kuru puorbrauc minimaluo ceļa. \/ Tys ir garantāts, ka atbiļde ir unikala. \/ lst_A[j] = lst_B[j]. \/ taids, ka lst_A[i] < lst_B[i] i kotram j (1 <= j < i) mums ir \/ nakai lst_B, cytim vuordim, ir vasals skaitlis indeksa i (1 <= i <= k) \/ caur (saucim tūs par lst_A i lst_B), lst_A ir leksikografeji mozuok \/ piec nūlykta vierteibu sakuortuotuo viersyunu veiduošonys šyunuos, kurys A i B \/ Ceļs A (garuma k) teik skaiteits par mozuokū par ceļu B (garuma k), ka \/ Tu navar aizīt uorpus teikla.\/ na obligati atškireigi). \/ Lyudzu, ņemu vārā, ka ceļuojums ar garumu k nūzeimoj, ka tiks pieteiti tīši k škieri (na \/ pūlejis. Cytim vuordim, tu vari īt iz šyunom, kurys ir vīnaiduos ar tevi.nu sevkurys šyunys, i kotrā sūlī tu vari puorsaceļt iz sevkuru nu kaimiņu šyunom,Tev ir juodūmoj, kas ir minimaluo garuma ceļš k teiklā.\/ inclusivs pasaruoda tīseibys šyunuos tīpat vīnu reizi.\/ kotrā teikla šyunuos ir vierteiba. Kotrs vasals skaitlis diapazonā [1, N * N] \/Dūdūt grīdu ar N ryndom i N kolom (N >= 2) i pozitivu vasalu skaitli k, \/\/ >>> minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n\/\/ [1, 2, 1]\n\/\/ >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n\/\/ [1]\nfunction minPath(grid, k){\n","canonical_solution":"function minPath(grid, k) {\n    const N = grid.length;\n    const directions = [\n        [0, 1], \/\/ right\n        [1, 0], \/\/ down\n        [0, -1], \/\/ left\n        [-1, 0]  \/\/ up\n    ];\n    \n    let minPathResult = Array(k).fill(Infinity);\n\n    function dfs(x, y, path) {\n        if (path.length === k) {\n            \/\/ Check if the current path is lexicographically smaller\n            if (comparePaths(path, minPathResult)) {\n                minPathResult = [...path];\n            }\n            return;\n        }\n\n        for (const [dx, dy] of directions) {\n            const nx = x + dx;\n            const ny = y + dy;\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                path.push(grid[nx][ny]);\n                dfs(nx, ny, path);\n                path.pop();\n            }\n        }\n    }\n    \n    function comparePaths(pathA, pathB) {\n        for (let i = 0; i < pathA.length; i++) {\n            if (pathA[i] < pathB[i]) return true;\n            if (pathA[i] > pathB[i]) return false;\n        }\n        return false;\n    }\n\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            dfs(i, j, [grid[i][j]]);\n        }\n    }\n\n    return minPathResult;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = minPath;\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1),[1]);\n  assert.deepEqual(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10, 1, 10, 1]);\n  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1, 6, 1, 6, 1]);\n  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1, 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1, 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"},{"task_id":"HumanEval_130","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ pyrmī n + 1 Tribonačis seceibys skaitli. \/ Tev ir nūteikts naenegai vasals skaitlis n, tev ir juosauce matrica ar \/ = 2 + 3 + 3 = 8 \/ tri(3) = tri(2) + tri(1) + tri(4) \/ tri(4) = 3 \/ tri(2) = 1 + (2 \/ 2) = 2 \/ Par pīmāru: \/ tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ka n ir najaušs. \/ tri (n) = 1 + n \/ 2, ka n ir puors. \/ tri(1) = 3 \/ Tribonači seceiba ir defināta ar rekursi: Tok cylvāki nazyn, kas ir Tribonači seceiba.Vysi zyna Fibonači seceibu, tū dzili pieteja matematiki 1929. godā.\/\/ >>> tri(3)\n\/\/ [1, 3, 2, 8]\nfunction tri(n){\n","canonical_solution":"function tri(n) {\n    if (n < 0) return [];\n    \n    let tribonacci = new Array(n + 1);\n\n    for (let i = 0; i <= n; i++) {\n        if (i === 1) {\n            tribonacci[i] = 3;\n        } else if (i % 2 === 0) {\n            tribonacci[i] = 1 + i \/ 2;\n        } else {\n            tribonacci[i] = \n                (tribonacci[i - 1] !== undefined ? tribonacci[i - 1] : 0) + \n                (tribonacci[i - 2] !== undefined ? tribonacci[i - 2] : 0) + \n                (tribonacci[i + 1] !== undefined ? tribonacci[i + 1] : 0);\n        }\n    }\n\n    return tribonacci;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = tri;\n  assert.deepEqual(candidate(3),[1, 3, 2, 8]);\n  assert.deepEqual(candidate(4),[1, 3, 2, 8, 3]);\n  assert.deepEqual(candidate(5),[1, 3, 2, 8, 3, 15]);\n  assert.deepEqual(candidate(6),[1, 3, 2, 8, 3, 15, 4]);\n  assert.deepEqual(candidate(7),[1, 3, 2, 8, 3, 15, 4, 24]);\n  assert.deepEqual(candidate(8),[1, 3, 2, 8, 3, 15, 4, 24, 5]);\n  assert.deepEqual(candidate(9),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);\n  assert.deepEqual(candidate(20),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);\n  assert.deepEqual(candidate(0),[1]);\n  assert.deepEqual(candidate(1),[1, 3]);\n}\n\ntest();"},{"task_id":"HumanEval_131","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ Atdūd 0, ka vysi cyparī cipari ir puori. \/Dūdūt pozitivu vasalu skaitli n, atsoka najaušu cyparu reizynuojumu. \/\/ >>> digits(1)\n\/\/ 1\n\/\/ >>> digits(4)\n\/\/ 0\n\/\/ >>> digits(235)\n\/\/ 15\nfunction digits(n){\n","canonical_solution":"function digits(n) {\n    let product = 1;\n    let hasOdd = false;\n\n    while (n > 0) {\n        let digit = n % 10;\n        if (digit % 2 !== 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n = Math.floor(n \/ 10);\n    }\n\n    return hasOdd ? product : 0;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = digits;\n  assert.deepEqual(candidate(5),5);\n  assert.deepEqual(candidate(54),5);\n  assert.deepEqual(candidate(120),1);\n  assert.deepEqual(candidate(5014),5);\n  assert.deepEqual(candidate(98765),315);\n  assert.deepEqual(candidate(5576543),2625);\n  assert.deepEqual(candidate(2468),0);\n}\n\ntest();"},{"task_id":"HumanEval_132","nl":"ltg_Latn","pl":"js","prompt":"\/ kur vysmoz vīna aizsorgojuma daļa ir īkļauta. \/ Funkcejai juobyut patīsai, ka i tikai ka ir dereiga aizviņkuortuojuma kuorteiba \/Dzeivuot funkceju, kas īejis vuordim pījam stringu, kas satur tikai kvadratsvorus. \/\/ >>> is_nested(\"[[]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[]]]]]]][[[[[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[][]\")\n\/\/ false\n\/\/ >>> is_nested(\"[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[[][]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[[]][[\")\n\/\/ true\nfunction is_nested(string){\n","canonical_solution":"function is_nested(string) {\n    let openCount = 0;\n    let nested = false;\n\n    for (let char of string) {\n        if (char === '[') {\n            if (openCount > 0) {\n                nested = true;\n            }\n            openCount++;\n        } else if (char === ']') {\n            if (openCount > 0) {\n                openCount--;\n            }\n        }\n    }\n    \n    return nested && openCount === 0;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_133","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ nuokamreiz apgrīž kotru elementu masā leidz augšākajam int ((Ceiling)).\/ Tev ir juopuorsyun skaitļu kvadrāta summa nūteiktā matricā, Tevi teik pīškierts skaitļu viersuoks.\/\/ >>> lst([1.0, 2.0, 3.0])\n\/\/ 14\n\/\/ >>> lst([1.0, 4.0, 9.0])\n\/\/ 98\n\/\/ >>> lst([1.0, 3.0, 5.0, 7.0])\n\/\/ 84\n\/\/ >>> lst([1.4, 4.2, 0.0])\n\/\/ 29\n\/\/ >>> lst([-2.4, 1.0, 1.0])\n\/\/ 6\nfunction sum_squares(lst){\n","canonical_solution":"function sum_squares(lst) {\n    return lst.map(Math.ceil).reduce((sum, num) => sum + num * num, 0);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sum_squares;\n  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);\n  assert.deepEqual(candidate([1.0, 3.0, 5.0, 7.0]),84);\n  assert.deepEqual(candidate([1.4, 4.2, 0.0]),29);\n  assert.deepEqual(candidate([-2.4, 1.0, 1.0]),6);\n  assert.deepEqual(candidate([100.0, 1.0, 15.0, 2.0]),10230);\n  assert.deepEqual(candidate([10000.0, 10000.0]),200000000);\n  assert.deepEqual(candidate([-1.4, 4.6, 6.3]),75);\n  assert.deepEqual(candidate([-1.4, 17.9, 18.9, 19.9]),1086);\n  assert.deepEqual(candidate([0.0]),0);\n  assert.deepEqual(candidate([-1.0]),1);\n  assert.deepEqual(candidate([-1.0, 1.0, 0.0]),2);\n}\n\ntest();"},{"task_id":"HumanEval_134","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Napīmiņu: \"vārds\" ir burtu grupa, kū atškir breivuo laika zeimi. \/ vuorda daļa, i cytaiž - napareizi. \/ nu nūteiktuos stringys ir alfabeta raksturs i nav \/Dzeivuot funkceju, kas atdūd patīsu, ka pādejais raksturs ir \/\/ >>> check_if_last_char_is_a_letter(\"apple pie\")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e\")\n\/\/ true\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e \")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"\")\n\/\/ false\nfunction check_if_last_char_is_a_letter(txt){\n","canonical_solution":"function check_if_last_char_is_a_letter(txt) {\n    if (txt.length === 0) return false;\n    \n    txt = txt.trim();\n    if (txt.length === 0) return false;\n    \n    let parts = txt.split(' ');\n    let lastWord = parts[parts.length - 1];\n    \n    if (lastWord.length === 0) return false;\n    \n    let lastChar = lastWord[lastWord.length - 1];\n    return \/^[a-zA-Z]$\/.test(lastChar);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = check_if_last_char_is_a_letter;\n  assert.deepEqual(candidate(\"apple\"),false);\n  assert.deepEqual(candidate(\"apple pi e\"),true);\n  assert.deepEqual(candidate(\"eeeee\"),false);\n  assert.deepEqual(candidate(\"A\"),true);\n  assert.deepEqual(candidate(\"Pumpkin pie \"),false);\n  assert.deepEqual(candidate(\"Pumpkin pie 1\"),false);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"eeeee e \"),false);\n  assert.deepEqual(candidate(\"apple pie\"),false);\n  assert.deepEqual(candidate(\"apple pi e \"),false);\n}\n\ntest();"},{"task_id":"HumanEval_135","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ dublikatu vierteibys. \/ nav taidu elementu, tod atsagrīž -1. Dāts kuorteibuos nabyus \/ nav leluoka par voi vīnaida ar tūlaik pyrmajam elementam.\/Dzeivuot funkceju, kas atdūd leluokū elementu indeksu, kas \/\/ >>> can_arrange([1, 2, 4, 3, 5])\n\/\/ 3\n\/\/ >>> can_arrange([1, 2, 3])\n\/\/ -1\nfunction can_arrange(arr){\n","canonical_solution":"function can_arrange(arr) {\n    for (let i = arr.length - 1; i > 0; i--) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = can_arrange;\n  assert.deepEqual(candidate([1, 2, 4, 3, 5]),3);\n  assert.deepEqual(candidate([1, 2, 4, 5]),-1);\n  assert.deepEqual(candidate([1, 4, 2, 5, 6, 7, 8, 9, 10]),2);\n  assert.deepEqual(candidate([4, 8, 5, 7, 3]),4);\n  assert.deepEqual(candidate([]),-1);\n}\n\ntest();"},{"task_id":"HumanEval_136","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Ka nav negativu voi pozitivu vasalūs skaitļu, tod atdūd tūs kai nedefinētus.\/ pozitivu vasalu skaitļu kūpumā. \/ ir leluokais nu nagativūs vasalūs skaitļu, bet \"b\" ir mozuokais \/Dzeivuot funkceju, kas atdūd kūpumu (a, b), kur 'a' ir \/\/ >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n\/\/ [undefined, 1]\n\/\/ >>> largest_smallest_integers([])\n\/\/ [undefined, undefined]\n\/\/ >>> largest_smallest_integers([0])\n\/\/ [undefined, undefined]\nfunction largest_smallest_integers(lst){\n","canonical_solution":"function largest_smallest_integers(lst) {\n    let largestNegative = undefined;\n    let smallestPositive = undefined;\n    \n    lst.forEach(num => {\n        if (num < 0 && (largestNegative === undefined || num > largestNegative)) {\n            largestNegative = num;\n        }\n        if (num > 0 && (smallestPositive === undefined || num < smallestPositive)) {\n            smallestPositive = num;\n        }\n    });\n    \n    return [largestNegative, smallestPositive];\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = largest_smallest_integers;\n  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7]),[undefined, 1]);\n  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7, 0]),[undefined, 1]);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2, 1]);\n  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);\n  assert.deepEqual(candidate([7, 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);\n  assert.deepEqual(candidate([]),[undefined, undefined]);\n  assert.deepEqual(candidate([0]),[undefined, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6]),[-1, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6, 0]),[-1, undefined]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3, 1]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);\n}\n\ntest();"},{"task_id":"HumanEval_137","nl":"ltg_Latn","pl":"js","prompt":"\/ Napīmiņu: Ka reals skaitlis teik attāluots kai ryndys, svorūšais punkts var byut . voi , \/ Atdūd nedefinātu, ka vierteibys ir vīnaidys. \/ realu skaitļu i atdūd leluokū maineigū īdūtuos maineigūs tipa. \/Dzeivuot funkceju, kas pījam vasalus skaitļus, floatus voi ryndys, kas apzeimoj \/\/ >>> compare_one(1, 2.5)\n\/\/ 2.5\n\/\/ >>> compare_one(1, \"2,3\")\n\/\/ \"2,3\"\n\/\/ >>> compare_one(\"5,1\", \"6\")\n\/\/ \"6\"\n\/\/ >>> compare_one(\"1\", 1)\n\/\/ undefined\nfunction compare_one(a, b){\n","canonical_solution":"function compare_one(a, b) {\n    \/\/ Function to parse the input into a real number.\n    const parseNum = (val) => {\n        if (typeof val === 'number') return val;\n        if (typeof val === 'string') {\n            \/\/ Replace comma with dot for parsing\n            let parsed = parseFloat(val.replace(',', '.'));\n            \/\/ If parsing fails, return NaN\n            if (isNaN(parsed)) return NaN;\n            return parsed;\n        }\n        return NaN;\n    };\n\n    \/\/ Get parsed numerical values\n    const numA = parseNum(a);\n    const numB = parseNum(b);\n\n    \/\/ Compare the inputs to determine which is greater\n    if (numA > numB) return a;\n    if (numB > numA) return b;\n\n    \/\/ If values are equal return undefined\n    return undefined;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = compare_one;\n  assert.deepEqual(candidate(1, 2),2);\n  assert.deepEqual(candidate(1, 2.5),2.5);\n  assert.deepEqual(candidate(2, 3),3);\n  assert.deepEqual(candidate(5, 6),6);\n  assert.deepEqual(candidate(1, \"2,3\"),\"2,3\");\n  assert.deepEqual(candidate(\"5,1\", \"6\"),\"6\");\n  assert.deepEqual(candidate(\"1\", \"2\"),\"2\");\n  assert.deepEqual(candidate(\"1\", 1),undefined);\n}\n\ntest();"},{"task_id":"HumanEval_138","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs \/Nūvērtēt, voi nūteiktu skaitli n var pīraksteit kai 4 pozitivu puora skaitļu summu.\/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunction is_equal_to_sum_even(n){\n","canonical_solution":"function is_equal_to_sum_even(n) {\n    \/\/ A number can be expressed as the sum of 4 positive even numbers\n    \/\/ if it is greater than or equal to 8 and is even.\n\n    if (n >= 8 && n % 2 === 0) {\n        return true;\n    }\n    return false;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_equal_to_sum_even;\n  assert.deepEqual(candidate(4),false);\n  assert.deepEqual(candidate(6),false);\n  assert.deepEqual(candidate(8),true);\n  assert.deepEqual(candidate(10),true);\n  assert.deepEqual(candidate(11),false);\n  assert.deepEqual(candidate(12),true);\n  assert.deepEqual(candidate(13),false);\n  assert.deepEqual(candidate(16),true);\n}\n\ntest();"},{"task_id":"HumanEval_139","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ kur n > 0 \/ brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! \/Braziliys faktorials ir defināts kai: \/\/ >>> special_factorial(4)\n\/\/ 288\n\/\/ The function will receive an integer as input and should return the special\n\/\/ factorial of this integer.\nfunction special_factorial(n){\n","canonical_solution":"function factorial(num) {\n    if (num <= 1) return 1;\n    return num * factorial(num - 1);\n}\n\nfunction special_factorial(n) {\n    let result = 1;\n    for (let i = n; i > 0; i--) {\n        result *= factorial(i);\n    }\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = special_factorial;\n  assert.deepEqual(candidate(4),288);\n  assert.deepEqual(candidate(5),34560);\n  assert.deepEqual(candidate(7),125411328000);\n  assert.deepEqual(candidate(1),1);\n}\n\ntest();"},{"task_id":"HumanEval_140","nl":"ltg_Latn","pl":"js","prompt":"\/ tod vysus uzastuojušūs vītys aizvītuot ar - \/ i ka stringā ir vaira kai 2 uzastuojušuos vītys, \/Dūdūt teksta kuortu, aizstuovi vysus telpu ar zamkruosu, \/\/ >>> fix_spaces(\" Example\")\n\/\/ \"Example\"\n\/\/ >>> fix_spaces(\" Example 1\")\n\/\/ \"Example_1\"\n\/\/ >>> fix_spaces(\" Example 2\")\n\/\/ \"_Example_2\"\n\/\/ >>> fix_spaces(\" Example 3\")\n\/\/ \"_Example-3\"\nfunction fix_spaces(text){\n","canonical_solution":"function fix_spaces(text) {\n    return text.trim().replace(\/\\s{2,}\/g, '-').replace(\/\\s\/g, '_');\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = fix_spaces;\n  assert.deepEqual(candidate(\"Example\"),\"Example\");\n  assert.deepEqual(candidate(\"Mudasir Hanif \"),\"Mudasir_Hanif_\");\n  assert.deepEqual(candidate(\"Yellow Yellow  Dirty  Fellow\"),\"Yellow_Yellow__Dirty__Fellow\");\n  assert.deepEqual(candidate(\"Exa   mple\"),\"Exa-mple\");\n  assert.deepEqual(candidate(\"   Exa 1 2 2 mple\"),\"-Exa_1_2_2_mple\");\n}\n\ntest();"},{"task_id":"HumanEval_141","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ - Pīroksta stringam piec punkta juobyut vīnam nu itūs: ['txt', 'exe', 'dll'] \/ latvīšu alfabets (\"a\" - \"z\" i \"A\" - \"Z\"). \/ - apakšreikstei pyrma punkta nabyut tukšam, i tys suocās ar burtu nu \/ - Faila nūsaukumā ir taids pat punkts '.' \/ - Datu īroksta nūsaukumā nav vaira kai treis cyparus ('0'-'9'). \/ ir pījimti: \/ Datu faila nūsaukums teik skaiteits par dereigu, ka i tikai ka vysys zamuok minātys īspiejis ir sasnāgtas \/ \"Jau\" ja faila nūsaukums ir dereigs, i atsoka \"Na\" cytaiž. \/Dzeivuot funkceju, kas pījam failu nūsaukumu, kas ir string, i atdūd \/\/ >>> file_name_check(\"example.txt\")\n\/\/ \"Yes\"\n\/\/ >>> file_name_check(\"1example.dll\")\n\/\/ \"No\"\nfunction file_name_check(file_name){\n","canonical_solution":"function file_name_check(file_name) {\n    const validExtensions = ['txt', 'exe', 'dll'];\n    const parts = file_name.split('.');\n\n    if (parts.length !== 2) {\n        return 'No';\n    }\n\n    const [namePart, extensionPart] = parts;\n\n    \/\/ Check that the name part is not empty, starts with a letter, and has at most 3 digits\n    if (namePart.length === 0 || !\/^[a-zA-Z]\/.test(namePart)) {\n        return 'No';\n    }\n\n    const digitCount = (namePart.match(\/\\d\/g) || []).length;\n    if (digitCount > 3) {\n        return 'No';\n    }\n\n    \/\/ Check if the extension is one of the valid ones\n    if (!validExtensions.includes(extensionPart)) {\n        return 'No';\n    }\n\n    return 'Yes';\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = file_name_check;\n  assert.deepEqual(candidate(\"example.txt\"),\"Yes\");\n  assert.deepEqual(candidate(\"1example.dll\"),\"No\");\n  assert.deepEqual(candidate(\"s1sdf3.asd\"),\"No\");\n  assert.deepEqual(candidate(\"K.dll\"),\"Yes\");\n  assert.deepEqual(candidate(\"MY16FILE3.exe\"),\"Yes\");\n  assert.deepEqual(candidate(\"His12FILE94.exe\"),\"No\");\n  assert.deepEqual(candidate(\"_Y.txt\"),\"No\");\n  assert.deepEqual(candidate(\"?aREYA.exe\"),\"No\");\n  assert.deepEqual(candidate(\"\/this_is_valid.dll\"),\"No\");\n  assert.deepEqual(candidate(\"this_is_valid.wow\"),\"No\");\n  assert.deepEqual(candidate(\"this_is_valid.txt\"),\"Yes\");\n  assert.deepEqual(candidate(\"this_is_valid.txtexe\"),\"No\");\n  assert.deepEqual(candidate(\"#this2_i4s_5valid.ten\"),\"No\");\n  assert.deepEqual(candidate(\"@this1_is6_valid.exe\"),\"No\");\n  assert.deepEqual(candidate(\"this_is_12valid.6exe4.txt\"),\"No\");\n  assert.deepEqual(candidate(\"all.exe.txt\"),\"No\");\n  assert.deepEqual(candidate(\"I563_No.exe\"),\"Yes\");\n  assert.deepEqual(candidate(\"Is3youfault.txt\"),\"Yes\");\n  assert.deepEqual(candidate(\"no_one#knows.dll\"),\"Yes\");\n  assert.deepEqual(candidate(\"1I563_Yes3.exe\"),\"No\");\n  assert.deepEqual(candidate(\"I563_Yes3.txtt\"),\"No\");\n  assert.deepEqual(candidate(\"final..txt\"),\"No\");\n  assert.deepEqual(candidate(\"final132\"),\"No\");\n  assert.deepEqual(candidate(\"_f4indsartal132.\"),\"No\");\n  assert.deepEqual(candidate(\".txt\"),\"No\");\n  assert.deepEqual(candidate(\"s.\"),\"No\");\n}\n\ntest();"},{"task_id":"HumanEval_142","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ maineit īrokstus matricā, kuru indeksi nav 3 voi 4 reizynuojumi.\/ reizynuojums ar 3 i īkļaus vasalu skaitli, ka tuo indekss ir reizynuojums ar 4 i nav reizynuojums ar 3.\/ Itei funkceja pījims vasalūs skaitļu sareiku. Vysim īrokstim sareikā funkceja kvadratej vasalū īrokstu, ka tuo indekss ir \/\"  nuokūtne\/\/ >>> lst\n\/\/ [1, 2, 3]\n\/\/ >>> lst\n\/\/ []\n\/\/ >>> lst\n\/\/ [-1, -5, 2, -1, -5]\nfunction sum_squares(lst){\n","canonical_solution":"function sum_squares(lst) {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (i % 3 === 0) {\n            sum += Math.pow(lst[i], 2);\n        } else if (i % 4 === 0) {\n            sum += Math.pow(lst[i], 3);\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sum_squares;\n  assert.deepEqual(candidate([1, 2, 3]),6);\n  assert.deepEqual(candidate([1, 4, 9]),14);\n  assert.deepEqual(candidate([]),0);\n  assert.deepEqual(candidate([1, 1, 1, 1, 1, 1, 1, 1, 1]),9);\n  assert.deepEqual(candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1]),-3);\n  assert.deepEqual(candidate([0]),0);\n  assert.deepEqual(candidate([-1, -5, 2, -1, -5]),-126);\n  assert.deepEqual(candidate([-56, -99, 1, 0, -2]),3030);\n  assert.deepEqual(candidate([-1, 0, 0, 0, 0, 0, 0, 0, -1]),0);\n  assert.deepEqual(candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]),-14196);\n  assert.deepEqual(candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]),-1448);\n}\n\ntest();"},{"task_id":"HumanEval_143","nl":"ltg_Latn","pl":"js","prompt":"\/ pīmārs 1: \/ vuordu seceibai jaunā ryndā ir juobyut taišni tai kai suokūtnejā ryndā. \/ kuru garumi ir pyrmskaitli, \/ i tev ir juopuorsyun stringam, kas satur vuordus nu suokūtnejuos teikuma, \/ teikumā ir vuordi, kurus atškir atstarpe, Tevi teik pīduovuota rynds, kas apzeimoj teikumu.\/\/ >>> words_in_sentence(\"This is a test\")\n\/\/ \"is\"\n\/\/ Example 2:\n\/\/ >>> words_in_sentence(\"lets go for swimming\")\n\/\/ \"go for\"\n\/\/ Constraints:\n\/\/ * 1 <= len(sentence) <= 100\n\/\/ * sentence contains only letters\nfunction words_in_sentence(sentence){\n","canonical_solution":"function words_in_sentence(sentence) {\n    function isPrime(num) {\n        if (num <= 1) return false;\n        if (num <= 3) return true;\n        if (num % 2 === 0 || num % 3 === 0) return false;\n        for (let i = 5; i * i <= num; i += 6) {\n            if (num % i === 0 || num % (i + 2) === 0) return false;\n        }\n        return true;\n    }\n\n    return sentence.split(' ')\n                   .filter(word => isPrime(word.length))\n                   .join(' ');\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = words_in_sentence;\n  assert.deepEqual(candidate(\"This is a test\"),\"is\");\n  assert.deepEqual(candidate(\"lets go for swimming\"),\"go for\");\n  assert.deepEqual(candidate(\"there is no place available here\"),\"there is no place\");\n  assert.deepEqual(candidate(\"Hi I am Hussein\"),\"Hi am Hussein\");\n  assert.deepEqual(candidate(\"go for it\"),\"go for it\");\n  assert.deepEqual(candidate(\"here\"),\"\");\n  assert.deepEqual(candidate(\"here is\"),\"is\");\n}\n\ntest();"},{"task_id":"HumanEval_144","nl":"ltg_Latn","pl":"js","prompt":"\/ Var pījimt, ka x i n ir dereigys lūkainuos, i, ka jūs saiminīkam nav nulle. \/ <skaiteituojs>\/<skaiteituojs>, kur gon skaiteituojs, gon skaiteituojs ir pozitivi vasalys skaitlis.Obeji x i n ir frakcejis ryndkūpu puorstuovi, i jim ir itaids formats:\/ x * n. Funkceja atjam patīsu, ka x * n ir vasals skaitlis i īvaiņa \/Tovs uzdavums ir īvīst funkceju, kas vīnkuoršuos izteiksmi.\/\/ >>> simplify(\"1\/5\", \"5\/1\")\n\/\/ true\n\/\/ >>> simplify(\"1\/6\", \"2\/1\")\n\/\/ false\n\/\/ >>> simplify(\"7\/10\", \"10\/2\")\n\/\/ false\nfunction simplify(x, n){\n","canonical_solution":"function simplify(x, n) {\n    const parseFraction = (fraction) => {\n        const [numerator, denominator] = fraction.split('\/').map(Number);\n        return { numerator, denominator };\n    };\n\n    const xFraction = parseFraction(x);\n    const nFraction = parseFraction(n);\n\n    const resultNumerator = xFraction.numerator * nFraction.numerator;\n    const resultDenominator = xFraction.denominator * nFraction.denominator;\n\n    return resultNumerator % resultDenominator === 0;\n}\n\n\/\/ Example usage\nconsole.log(simplify(\"1\/5\", \"5\/1\")); \/\/ true\nconsole.log(simplify(\"1\/6\", \"2\/1\")); \/\/ false\nconsole.log(simplify(\"7\/10\", \"10\/2\")); \/\/ false","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = simplify;\n  assert.deepEqual(candidate(\"1\/5\", \"5\/1\"),true);\n  assert.deepEqual(candidate(\"1\/6\", \"2\/1\"),false);\n  assert.deepEqual(candidate(\"5\/1\", \"3\/1\"),true);\n  assert.deepEqual(candidate(\"7\/10\", \"10\/2\"),false);\n  assert.deepEqual(candidate(\"2\/10\", \"50\/10\"),true);\n  assert.deepEqual(candidate(\"7\/2\", \"4\/2\"),true);\n  assert.deepEqual(candidate(\"11\/6\", \"6\/1\"),true);\n  assert.deepEqual(candidate(\"2\/3\", \"5\/2\"),false);\n  assert.deepEqual(candidate(\"5\/2\", \"3\/5\"),false);\n  assert.deepEqual(candidate(\"2\/4\", \"8\/4\"),true);\n  assert.deepEqual(candidate(\"2\/4\", \"4\/2\"),true);\n  assert.deepEqual(candidate(\"1\/5\", \"5\/1\"),true);\n  assert.deepEqual(candidate(\"1\/5\", \"1\/5\"),false);\n}\n\ntest();"},{"task_id":"HumanEval_145","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ sakuortuotys piec tūs indeksa iz suokūtnejuo kuorteiba. \/ Piezīme: ja ir vairuoki elementi ar leidzeigu cyparu summu, \/ pīaugūšajā kuortā piec cyparu summu. \/Skaiti funkceju, kas sorgoj nūteiktu vasalūs skaitļu sakuortu \/\/ >>> order_by_points([1, 11, -1, -11, -12])\n\/\/ [-1, -11, 1, -12, 11]\n\/\/ >>> order_by_points([])\n\/\/ []\nfunction order_by_points(nums){\n","canonical_solution":"function order_by_points(nums) {\n    function sumOfDigits(n) {\n        \/\/ Absolute value to ensure digits are summed correctly for negative numbers\n        return Math.abs(n).toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);\n    }\n\n    nums.sort((a, b) => {\n        const sumA = sumOfDigits(a);\n        const sumB = sumOfDigits(b);\n        if (sumA === sumB) {\n            return 0; \/\/ Maintain original order\n        }\n        return sumA - sumB;\n    });\n\n    return nums;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = order_by_points;\n  assert.deepEqual(candidate([1, 11, -1, -11, -12]),[-1, -11, 1, -12, 11]);\n  assert.deepEqual(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1, -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98, -11, 1, 2, 43, 54]);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n  assert.deepEqual(candidate([0, 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6]);\n}\n\ntest();"},{"task_id":"HumanEval_146","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ skaitļa pyrmais i pādejais cypars ir najaušs (1, 3, 5, 7, 9). \/ elementu skaits matricā, kas ir leluoki par 10 i obeji \/Skaiti funkceju, kas īnese i atdūd skaitļu kuortu.\/\/ >>> specialFilter([15, -73, 14, -15])\n\/\/ 1\n\/\/ >>> specialFilter([33, -2, -3, 45, 21, 109])\n\/\/ 2\nfunction specialFilter(nums){\n","canonical_solution":"function specialFilter(nums) {\n    return nums.reduce((count, num) => {\n        if (Math.abs(num) > 10) {\n            const numStr = Math.abs(num).toString();\n            const firstDigit = parseInt(numStr[0]);\n            const lastDigit = parseInt(numStr[numStr.length - 1]);\n            if ([1, 3, 5, 7, 9].includes(firstDigit) && [1, 3, 5, 7, 9].includes(lastDigit)) {\n                return count + 1;\n            }\n        }\n        return count;\n    }, 0);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = specialFilter;\n  assert.deepEqual(candidate([5, -2, 1, -5]),0);\n  assert.deepEqual(candidate([15, -73, 14, -15]),1);\n  assert.deepEqual(candidate([33, -2, -3, 45, 21, 109]),2);\n  assert.deepEqual(candidate([43, -12, 93, 125, 121, 109]),4);\n  assert.deepEqual(candidate([71, -2, -33, 75, 21, 19]),3);\n  assert.deepEqual(candidate([1]),0);\n  assert.deepEqual(candidate([]),0);\n}\n\ntest();"},{"task_id":"HumanEval_147","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ i a[i] + a[j] + a[k] ir 3 reizynuojums. \/ Atdūd a treis reizis skaitu (a[i], a[j], a[k]) kur i < j < k, \/ Kotram i (1 ≤ i ≤ n) a[i] vierteiba ir i * i - i + 1. Tevi teik pīškierts pozitivs vasals skaitlis n. Tev ir juoaizveidoj vasals skaitlis array ar garumu n.\/\/ >>> get_max_triples(5)\n\/\/ 1\n\/\/ Explanation: \n\/\/ a = [1, 3, 7, 13, 21]\n\/\/ The only valid triple is (1, 7, 13).\nfunction get_max_triples(n){\n","canonical_solution":"function get_max_triples(n) {\n    \/\/ Step 1: Create the integer array 'a'\n    let a = new Array(n);\n    for (let i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    \/\/ Step 2: Count the triples\n    let count = 0;\n    for (let i = 0; i < n - 2; i++) {\n        for (let j = i + 1; j < n - 1; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 === 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_max_triples;\n  assert.deepEqual(candidate(5),1);\n  assert.deepEqual(candidate(6),4);\n  assert.deepEqual(candidate(10),36);\n  assert.deepEqual(candidate(100),53361);\n}\n\ntest();"},{"task_id":"HumanEval_148","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri \/ nav pareizi planetu nūsaukumi.\/ Funkcejai juopuorsyun tukša kuorteiba, ka ir planet1 voi planet2 \/ tyvums saulis. \/ atsarūn storp planetys 1 orbitom i planetys 2 orbitom, sakuortuoti piec \/ Funkcejai byutu juoaizdūd array, kurā ir vysys planetys, kuru orbitys ir \/ Rakstit funkceju, kas pījam divejis planetu nūsaukumus kai stringus planets1 i planet2. \/ Urans, Neptuns.\/ ir Merkurs, nuokušais ir Venera, tod Zeme, Marss, Jupiters, Saturns, Solys sistemā ir ostoņis planetys, kas ir tyvuok Saulis.\/\/ >>> bf(\"Jupiter\", \"Neptune\")\n\/\/ [\"Saturn\", \"Uranus\"]\n\/\/ >>> bf(\"Earth\", \"Mercury\")\n\/\/ \"Venus\"\n\/\/ >>> bf(\"Mercury\", \"Uranus\")\n\/\/ [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nfunction bf(planet1, planet2){\n","canonical_solution":"function bf(planet1, planet2) {\n    const planets = [\n        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\n    ];\n\n    const index1 = planets.indexOf(planet1);\n    const index2 = planets.indexOf(planet2);\n\n    if (index1 === -1 || index2 === -1) {\n        return [];\n    }\n\n    const start = Math.min(index1, index2) + 1;\n    const end = Math.max(index1, index2);\n\n    return planets.slice(start, end);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = bf;\n  assert.deepEqual(candidate(\"Jupiter\", \"Neptune\"),[\"Saturn\", \"Uranus\"]);\n  assert.deepEqual(candidate(\"Earth\", \"Mercury\"),[\"Venus\"]);\n  assert.deepEqual(candidate(\"Mercury\", \"Uranus\"),[\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]);\n  assert.deepEqual(candidate(\"Neptune\", \"Venus\"),[\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"]);\n  assert.deepEqual(candidate(\"Earth\", \"Earth\"),[]);\n  assert.deepEqual(candidate(\"Mars\", \"Earth\"),[]);\n  assert.deepEqual(candidate(\"Jupiter\", \"Makemake\"),[]);\n}\n\ntest();"},{"task_id":"HumanEval_149","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: Varātu dūmuot, ka vysi vuordi byus vīnaidi garī.\/ Funkcejai juopuorsyun vierteibys vierteibys sarokstā. \/ Ka divejim vuordim ir vīnaids garums, sorgoj matricys alfabetiski. \/ juopuorsyut vuordu kruojums, kas sakuortuots piec itaida nūsacejuma. \/ Arīnis kuorteiba juonūaug piec kotra vuorda garuma, i tu \/ i tys var saturēt dublikatus. \/ Arīņs vysod ir stringņu arrays i nikod nav skaitļu arrays, \/ i atdūd rezultata kūpumu ar sakuortuotu kuortu, \/ nūvierš stringys, kuru garums ir najaušs, \/Skaiti funkceju, kas par parametru pījam stringim saītu, \/\/ >>> list_sort([\"aa\", \"a\", \"aaa\"])\n\/\/ [\"aa\"]\n\/\/ >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n\/\/ [\"ab\", \"cd\"]\nfunction sorted_list_sum(lst){\n","canonical_solution":"function sorted_list_sum(lst) {\n    return lst\n        .filter(word => word.length % 2 === 0)\n        .sort((a, b) => {\n            if (a.length === b.length) {\n                return a.localeCompare(b);\n            }\n            return a.length - b.length;\n        });\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = sorted_list_sum;\n  assert.deepEqual(candidate([\"aa\", \"a\", \"aaa\"]),[\"aa\"]);\n  assert.deepEqual(candidate([\"school\", \"AI\", \"asdf\", \"b\"]),[\"AI\", \"asdf\", \"school\"]);\n  assert.deepEqual(candidate([\"d\", \"b\", \"c\", \"a\"]),[]);\n  assert.deepEqual(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]),[\"abcd\", \"dcba\"]);\n  assert.deepEqual(candidate([\"AI\", \"ai\", \"au\"]),[\"AI\", \"ai\", \"au\"]);\n  assert.deepEqual(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]),[]);\n  assert.deepEqual(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]),[\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\n\ntest();"},{"task_id":"HumanEval_150","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ ir pyrmskaitlis i cytaiž juoatsoka y vierteiba. \/Vīnkuorša programa, kas atdūd x vierteibu, ka n ir \/\/ >>> x_or_y(7, 34, 12)\n\/\/ 34\n\/\/ >>> x_or_y(15, 8, 5)\n\/\/ 5\nfunction x_or_y(n, x, y){\n","canonical_solution":"function isPrime(num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n\n    if (num % 2 === 0 || num % 3 === 0) return false;\n\n    for (let i = 5; i * i <= num; i += 6) {\n        if (num % i === 0 || num % (i + 2) === 0) return false;\n    }\n\n    return true;\n}\n\nfunction x_or_y(n, x, y) {\n    return isPrime(n) ? x : y;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = x_or_y;\n  assert.deepEqual(candidate(7, 34, 12),34);\n  assert.deepEqual(candidate(15, 8, 5),5);\n  assert.deepEqual(candidate(3, 33, 5212),33);\n  assert.deepEqual(candidate(1259, 3, 52),3);\n  assert.deepEqual(candidate(7919, -1, 12),-1);\n  assert.deepEqual(candidate(3609, 1245, 583),583);\n  assert.deepEqual(candidate(91, 56, 129),129);\n  assert.deepEqual(candidate(6, 34, 1234),1234);\n  assert.deepEqual(candidate(1, 2, 0),0);\n  assert.deepEqual(candidate(2, 2, 0),2);\n}\n\ntest();"},{"task_id":"HumanEval_151","nl":"ltg_Latn","pl":"js","prompt":"\/ matricā, kas ir najauši.  Ignorej skaitļus, kas ir nagativi voi nav vasalī skaitli.\/Dūdūt skaitļu sareiku, atsoka skaitļu kvadratu summu.\/\/ >>> double_the_difference([1, 3, 2, 0])\n\/\/ 10\n\/\/ >>> double_the_difference([-1, -2, 0])\n\/\/ 0\n\/\/ >>> double_the_difference([9, -2])\n\/\/ 81\n\/\/ >>> double_the_difference([0])\n\/\/ 0\n\/\/ If the input array is empty, return 0.\nfunction double_the_difference(lst){\n","canonical_solution":"function double_the_difference(lst) {\n    return lst.reduce((sum, num) => {\n        if (Number.isInteger(num) && num > 0 && num % 2 !== 0) {\n            return sum + num * num;\n        }\n        return sum;\n    }, 0);\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = double_the_difference;\n  assert.deepEqual(candidate([]),0);\n  assert.deepEqual(candidate([5.0, 4.0]),25);\n  assert.deepEqual(candidate([0.1, 0.2, 0.3]),0);\n  assert.deepEqual(candidate([-10.0, -20.0, -30.0]),0);\n  assert.deepEqual(candidate([-1.0, -2.0, 8.0]),0);\n  assert.deepEqual(candidate([0.2, 3.0, 5.0]),34);\n  assert.deepEqual(candidate([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]),165);\n}\n\ntest();"},{"task_id":"HumanEval_152","nl":"ltg_Latn","pl":"js","prompt":"\/ pīmārs: \/ vierteiba ir 0, i ka nā, tod vierteiba ir absolutuo atškireiba storp pījāmumu i rezultatu. \/ Atdūd taidu pošu garuma matricys, kas apzeimoj, cik tuoli nu kotra nūruodejuma beja.\/ Tev teik pīduovuotys divejis vīnaida garuma punktu i pījāmumu sareikuotys, kur kotrs indekss paruoda atbiļdi. Tova aizdavums ir nūsaceit, voi persona pareizi nūruodeja vairuoku spēļu rezultatu.\/ vyspuor ir juosaprūt i juosaleidzynoj. Tys, kū jius jiutat i dūmojot itymā šaļtī, irEs dūmoju, ka mes vysi atguodojam tū sajūtu, kod nu kaida ilguok gaideitais rezultats\/\/ >>> compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n\/\/ [0, 0, 0, 0, 3, 3]\n\/\/ >>> compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n\/\/ [4, 4, 1, 0, 0, 6]\nfunction compare(game, guess){\n","canonical_solution":"function compare(game, guess) {\n    return game.map((score, index) => Math.abs(score - guess[index]));\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = compare;\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]),[0, 0, 0, 0, 3, 3]);\n  assert.deepEqual(candidate([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]),[0, 0, 0, 0, 0, 0]);\n  assert.deepEqual(candidate([1, 2, 3], [-1, -2, -3]),[2, 4, 6]);\n  assert.deepEqual(candidate([1, 2, 3, 5], [-1, 2, 3, 4]),[2, 0, 0, 1]);\n}\n\ntest();"},{"task_id":"HumanEval_153","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ (tova spiece ir -1). \/ atsoka \"Slices.SErviNGSliCes\", partū ka \"SErviNGSliCes\" ir stypruokais paplašynuojums \/ paplašynuojumi: ['SErviNGSliCes', 'Cheese', 'StuFfed'], tod jums byutu juopīmiņ\/ Par pīmāru, ja jums teik dūts \"Slices\" kai klase i array nu \/ izavielej tū, kas pyrmais teik īlykts sarokstā. Ka ir diveji voi vairuoki papyldynuojumi ar vīnu i tū pošu spāku, tev juopīmiņ, ka tu vari izlikt tū pošu papyldynuojumu.\/ format: ClassName.StrongestExtensionName. Tev juodūmoj par vysstyprūkuokū paplašynuojumu i juopuorsyut stringam itymā .\/ paplašynuojuma nūsaukumā spīdīņs teik daškierts ar frakceju CAP - SM. \/ burti paplašynuojuma nūsaukumā, SM ir mozuoku burtu skaits \/ paplašynuošonys spieja ir itaida: lai CAP byutu leluo burta skaitlis \/ Paplašynuojumi teik izmontuoti, kab īluodeitu klasei papyldu klasis.\/Tev tiks pīduovuots klašu nūsaukums (kuortys rynds) i paplašynuojumu kuorteiba.\/\/ >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n\/\/ \"my_class.AA\"\nfunction Strongest_Extension(class_name, extensions){\n","canonical_solution":"function Strongest_Extension(class_name, extensions) {\n    let strongestExtension = '';\n    let maxStrength = -Infinity;\n\n    extensions.forEach(extension => {\n        let capCount = 0;\n        let smCount = 0;\n\n        for (let char of extension) {\n            if (char >= 'A' && char <= 'Z') {\n                capCount++;\n            } else if (char >= 'a' && char <= 'z') {\n                smCount++;\n            }\n        }\n\n        let strength = capCount - smCount;\n\n        if (strength > maxStrength) {\n            maxStrength = strength;\n            strongestExtension = extension;\n        }\n    });\n\n    return `${class_name}.${strongestExtension}`;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = Strongest_Extension;\n  assert.deepEqual(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]),\"Watashi.eIGHt8OKe\");\n  assert.deepEqual(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]),\"Boku123.YEs.WeCaNe\");\n  assert.deepEqual(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]),\"__YESIMHERE.NuLl__\");\n  assert.deepEqual(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]),\"K.TAR\");\n  assert.deepEqual(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]),\"__HAHA.123\");\n  assert.deepEqual(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]),\"YameRore.okIWILL123\");\n  assert.deepEqual(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]),\"finNNalLLly.WoW\");\n  assert.deepEqual(candidate(\"_\", [\"Bb\", \"91245\"]),\"_.Bb\");\n  assert.deepEqual(candidate(\"Sp\", [\"671235\", \"Bb\"]),\"Sp.671235\");\n}\n\ntest();"},{"task_id":"HumanEval_154","nl":"ltg_Latn","pl":"js","prompt":"Tevi teik pīduovuoti div vuordi. Tev ir juosaver patīsai, ka ūtrais vuords voi kaids nu tuo apgrīzīņu ir pyrmuo vuorda apakšgrīze.\/\/ >>> cycpattern_check(\"abcd\", \"abd\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"hello\", \"ell\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"whassup\", \"psus\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"abab\", \"baa\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"efef\", \"eeff\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"himenss\", \"simen\")\n\/\/ true\nfunction cycpattern_check(a, b){\n","canonical_solution":"function cycpattern_check(a, b) {\n    if (b.length > a.length) return false;\n    \n    let currentRotation = b;\n    for (let i = 0; i < b.length; i++) {\n        if (a.includes(currentRotation)) {\n            return true;\n        }\n        currentRotation = currentRotation.slice(1) + currentRotation[0];\n    }\n    \n    return false;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = cycpattern_check;\n  assert.deepEqual(candidate(\"xyzw\", \"xyw\"),false);\n  assert.deepEqual(candidate(\"yello\", \"ell\"),true);\n  assert.deepEqual(candidate(\"whattup\", \"ptut\"),false);\n  assert.deepEqual(candidate(\"efef\", \"fee\"),true);\n  assert.deepEqual(candidate(\"abab\", \"aabb\"),false);\n  assert.deepEqual(candidate(\"winemtt\", \"tinem\"),true);\n}\n\ntest();"},{"task_id":"HumanEval_155","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/Dūdams vasalū skaitli. atdūd tauteibu, kurā ir attīceigi pat i napat skaitļu skaits. \/\/ >>> even_odd_count(-12)\n\/\/ [1, 1]\n\/\/ >>> even_odd_count(123)\n\/\/ [1, 2]\nfunction even_odd_count(num){\n","canonical_solution":"function even_odd_count(num) {\n    \/\/ Convert the number to a string and take the absolute value for negative numbers\n    const numStr = Math.abs(num).toString();\n    let evenCount = 0;\n    let oddCount = 0;\n\n    \/\/ Loop through each digit in the string\n    for (let char of numStr) {\n        \/\/ Convert the character back to a number\n        let digit = parseInt(char, 10);\n        \/\/ Check if the digit is even or odd\n        if (digit % 2 === 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n    return [evenCount, oddCount];\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = even_odd_count;\n  assert.deepEqual(candidate(7),[0, 1]);\n  assert.deepEqual(candidate(-78),[1, 1]);\n  assert.deepEqual(candidate(3452),[2, 2]);\n  assert.deepEqual(candidate(346211),[3, 3]);\n  assert.deepEqual(candidate(-345821),[3, 3]);\n  assert.deepEqual(candidate(-2),[1, 0]);\n  assert.deepEqual(candidate(-45347),[2, 3]);\n  assert.deepEqual(candidate(0),[1, 0]);\n}\n\ntest();"},{"task_id":"HumanEval_156","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri: \/ Apribojumi: 1 <= num <= 1000 \/ i atsyuti tū mozuos burtēs. \/Dūdūt pozitivu vasalu skaitli, īgiut tuos rūmīšu skaitļu ekvivalentu kai ryndys, \/\/ >>> int_to_mini_roman(19)\n\/\/ \"xix\"\n\/\/ >>> int_to_mini_roman(152)\n\/\/ \"clii\"\n\/\/ >>> int_to_mini_roman(426)\n\/\/ \"cdxxvi\"\nfunction int_to_mini_roman(number){\n","canonical_solution":"function int_to_mini_roman(number) {\n    const romanNumerals = [\n        { value: 1000, numeral: 'm' },\n        { value: 900, numeral: 'cm' },\n        { value: 500, numeral: 'd' },\n        { value: 400, numeral: 'cd' },\n        { value: 100, numeral: 'c' },\n        { value: 90, numeral: 'xc' },\n        { value: 50, numeral: 'l' },\n        { value: 40, numeral: 'xl' },\n        { value: 10, numeral: 'x' },\n        { value: 9, numeral: 'ix' },\n        { value: 5, numeral: 'v' },\n        { value: 4, numeral: 'iv' },\n        { value: 1, numeral: 'i' }\n    ];\n    \n    let result = '';\n    for (const { value, numeral } of romanNumerals) {\n        while (number >= value) {\n            result += numeral;\n            number -= value;\n        }\n    }\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = int_to_mini_roman;\n  assert.deepEqual(candidate(19),\"xix\");\n  assert.deepEqual(candidate(152),\"clii\");\n  assert.deepEqual(candidate(251),\"ccli\");\n  assert.deepEqual(candidate(426),\"cdxxvi\");\n  assert.deepEqual(candidate(500),\"d\");\n  assert.deepEqual(candidate(1),\"i\");\n  assert.deepEqual(candidate(4),\"iv\");\n  assert.deepEqual(candidate(43),\"xliii\");\n  assert.deepEqual(candidate(90),\"xc\");\n  assert.deepEqual(candidate(94),\"xciv\");\n  assert.deepEqual(candidate(532),\"dxxxii\");\n  assert.deepEqual(candidate(900),\"cm\");\n  assert.deepEqual(candidate(994),\"cmxciv\");\n  assert.deepEqual(candidate(1000),\"m\");\n}\n\ntest();"},{"task_id":"HumanEval_157","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ 90 grādim. \/ Dreizstyura trikots ir trikots, kurā vīns leņkis ir taisns leņks voi \/ pusis veidoj taisnstūrveida trejstūni, cytaiž nav pareizi. Atvieršona ir patīsa, ja treis lūcekli ir vīnaidi.\/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/ true\n\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/ false\nfunction right_angle_triangle(a, b, c){\n","canonical_solution":"function right_angle_triangle(a, b, c) {\n    \/\/ Sort the sides to ensure the largest side is at the end (potential hypotenuse)\n    let sides = [a, b, c].sort((x, y) => x - y);\n    \n    \/\/ Check the Pythagorean theorem to determine if it's a right-angled triangle\n    return sides[0]**2 + sides[1]**2 === sides[2]**2;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = right_angle_triangle;\n  assert.deepEqual(candidate(3, 4, 5),true);\n  assert.deepEqual(candidate(1, 2, 3),false);\n  assert.deepEqual(candidate(10, 6, 8),true);\n  assert.deepEqual(candidate(2, 2, 2),false);\n  assert.deepEqual(candidate(7, 24, 25),true);\n  assert.deepEqual(candidate(10, 5, 7),false);\n  assert.deepEqual(candidate(5, 12, 13),true);\n  assert.deepEqual(candidate(15, 8, 17),true);\n  assert.deepEqual(candidate(48, 55, 73),true);\n  assert.deepEqual(candidate(1, 1, 1),false);\n  assert.deepEqual(candidate(2, 2, 10),false);\n}\n\ntest();"},{"task_id":"HumanEval_158","nl":"ltg_Latn","pl":"js","prompt":"\/ rakstīņus, atsoka tū, kas ir pyrmais leksikografiskajā seceibā. \/ unikala rakstura. Ka vairuokim stringim ir maksimals unikalu raksturu skaits \/ Arī ir dažaidi vuordi. Atdūd vuordu ar maksimaluo skaita \/Skaiti funkceju, kas pījam stringim veļteitū matricys viersu.\/\/ >>> find_max([\"name\", \"of\", \"string\"])\n\/\/ \"string\"\n\/\/ >>> find_max([\"name\", \"enam\", \"game\"])\n\/\/ \"enam\"\n\/\/ >>> find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n\/\/ \"aaaaaaa\"\nfunction find_max(words){\n","canonical_solution":"function find_max(words) {\n    function uniqueCharacterCount(word) {\n        const uniqueChars = new Set(word);\n        return uniqueChars.size;\n    }\n\n    let maxUniqueCount = -1;\n    let result = \"\";\n\n    words.forEach(word => {\n        const currentUniqueCount = uniqueCharacterCount(word);\n        if (currentUniqueCount > maxUniqueCount || \n            (currentUniqueCount === maxUniqueCount && word < result)) {\n            maxUniqueCount = currentUniqueCount;\n            result = word;\n        }\n    });\n\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = find_max;\n  assert.deepEqual(candidate([\"name\", \"of\", \"string\"]),\"string\");\n  assert.deepEqual(candidate([\"name\", \"enam\", \"game\"]),\"enam\");\n  assert.deepEqual(candidate([\"aaaaaaa\", \"bb\", \"cc\"]),\"aaaaaaa\");\n  assert.deepEqual(candidate([\"abc\", \"cba\"]),\"abc\");\n  assert.deepEqual(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]),\"footbott\");\n  assert.deepEqual(candidate([\"we\", \"are\", \"gonna\", \"rock\"]),\"gonna\");\n  assert.deepEqual(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]),\"nation\");\n  assert.deepEqual(candidate([\"this\", \"is\", \"a\", \"prrk\"]),\"this\");\n  assert.deepEqual(candidate([\"b\"]),\"b\");\n  assert.deepEqual(candidate([\"play\", \"play\", \"play\"]),\"play\");\n}\n\ntest();"},{"task_id":"HumanEval_159","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmārs: \/ ka nav pīteikūši daudz atlyktu morku, tu ēdsi vysys atlyktuos morkus, bet vys vēļ byus izalūbe. \/ cik daudz pūra paliks piec ēdīņa ] \/ tev byus juopuordūd [ kūpejais ēdynuotu morku skaits piec ēdīņu, \/ bet tagad tev vajag ēst vaira morkdu, kab pabeigtu dīnys vakariņu.Tu esi izalūcis truops, i tu jau esi izēdiejs nūsaceitu skaitu morkdu,\/\/ >>> eat(5, 6, 10)\n\/\/ [11, 4]\n\/\/ >>> eat(4, 8, 9)\n\/\/ [12, 1]\n\/\/ >>> eat(1, 10, 10)\n\/\/ [11, 0]\n\/\/ >>> eat(2, 11, 5)\n\/\/ [7, 0]\n\/\/ Variables:\n\/\/ @number : integer\n\/\/ the number of carrots that you have eaten.\n\/\/ @need : integer\n\/\/ the number of carrots that you need to eat.\n\/\/ @remaining : integer\n\/\/ the number of remaining carrots thet exist in stock\n\/\/ Constrain:\n\/\/ * 0 <= number <= 1000\n\/\/ * 0 <= need <= 1000\n\/\/ * 0 <= remaining <= 1000\n\/\/ Have fun :)\nfunction eat(number, need, remaining){\n","canonical_solution":"function eat(number, need, remaining) {\n    const carrotsToEat = Math.min(need, remaining);\n    const totalEaten = number + carrotsToEat;\n    const carrotsLeft = remaining - carrotsToEat;\n    return [totalEaten, carrotsLeft];\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = eat;\n  assert.deepEqual(candidate(5, 6, 10),[11, 4]);\n  assert.deepEqual(candidate(4, 8, 9),[12, 1]);\n  assert.deepEqual(candidate(1, 10, 10),[11, 0]);\n  assert.deepEqual(candidate(2, 11, 5),[7, 0]);\n  assert.deepEqual(candidate(4, 5, 7),[9, 2]);\n  assert.deepEqual(candidate(4, 5, 1),[5, 0]);\n}\n\ntest();"},{"task_id":"HumanEval_160","nl":"ltg_Latn","pl":"js","prompt":"\/ Operatora sareibai ir vysmoz vīns operators, bet operanda sareibai ir vysmoz div operandi. \/ Operands ir nazeimeigu vasalu skaitļu sareiksnis. \/ Operatora viļņa garums ir vīnaids ar operanda viļņa garumu minus vīnu. \/ Napīmiņu: \/ => rezultats = 9 \/ rezultats = 2 + 3 * 4 - 5 \/ array = [2, 3, 4, 5] \/ operatoru['+', '*', '-'] \/ Pīmārs: \/ Eksponentizaceja (**) \/ Zamu sadaleišona ( \/\/ ) \/ Vairuošonuos (*) \/ Atjimšona ( - ) \/ Papyldynuojums (+) \/ Bazneicys algebriskuos darbeibuos: \/ izteiksmis i atsoka ituo izteiksmis vierzīni. \/ ūtrais viersroksts ir vasalūs skaitļu viersroksts. izmontojūt divejus nūteiktus viersrokstus, kab izveiduotu algebru.\/Dūdūt divejus kuortu operatorus i operandus. Pyrmajā kuortā ir pamata algebrys darbeibu i function do_algebra(operator, operand){\n","canonical_solution":"function do_algebra(operator, operand) {\n    let expression = operand[0].toString();\n    \n    for (let i = 0; i < operator.length; i++) {\n        let op = operator[i];\n        let currentOperand = operand[i + 1];\n        \n        \/\/ Replace floor division symbol '\/\/' with actual JavaScript behavior\n        if (op === '\/\/') {\n            expression += `Math.floor(${currentOperand})`;\n        } else {\n            expression += ` ${op} ${currentOperand}`;\n        }\n    }\n    \n    \/\/ Evaluate the resulting expression\n    let result = eval(expression);\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = do_algebra;\n  assert.deepEqual(candidate([\"**\", \"*\", \"+\"], [2, 3, 4, 5]),37);\n  assert.deepEqual(candidate([\"+\", \"*\", \"-\"], [2, 3, 4, 5]),9);\n  assert.deepEqual(candidate([\"\/\/\", \"*\"], [7, 3, 4]),8);\n}\n\ntest();"},{"task_id":"HumanEval_161","nl":"ltg_Latn","pl":"js","prompt":"\/ Pīmāri \/ Funkcejai juoaizvuorej rezultata strings. \/ Ka stringā nav burtu, puorskaiti stringu.\/ cytaiž turit tū, kai ir. \/ ka s[i] ir burts, atsakuortoj juo burts nu zamuokys iz augšuokū voi ūtraiži, Tevi pīduovoj sīna.\/\/ >>> solve(\"1234\")\n\/\/ \"4321\"\n\/\/ >>> solve(\"ab\")\n\/\/ \"AB\"\n\/\/ >>> solve(\"#a@C\")\n\/\/ \"#A@c\"\nfunction solve(s){\n","canonical_solution":"function solve(s) {\n    let hasLetter = false;\n    let result = '';\n\n    for (let i = 0; i < s.length; i++) {\n        let char = s[i];\n        if (\/[a-zA-Z]\/.test(char)) {\n            hasLetter = true;\n            if (char === char.toLowerCase()) {\n                result += char.toUpperCase();\n            } else {\n                result += char.toLowerCase();\n            }\n        } else {\n            result += char;\n        }\n    }\n\n    if (!hasLetter) {\n        return result.split('').reverse().join('');\n    }\n\n    return result;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = solve;\n  assert.deepEqual(candidate(\"AsDf\"),\"aSdF\");\n  assert.deepEqual(candidate(\"1234\"),\"4321\");\n  assert.deepEqual(candidate(\"ab\"),\"AB\");\n  assert.deepEqual(candidate(\"#a@C\"),\"#A@c\");\n  assert.deepEqual(candidate(\"#AsdfW^45\"),\"#aSDFw^45\");\n  assert.deepEqual(candidate(\"#6@2\"),\"2@6#\");\n  assert.deepEqual(candidate(\"#$a^D\"),\"#$A^d\");\n  assert.deepEqual(candidate(\"#ccc\"),\"#CCC\");\n}\n\ntest();"},{"task_id":"HumanEval_162","nl":"ltg_Latn","pl":"js","prompt":"\/ Ka 'teksts' ir tukša ryndkopa, atsagrīž nedefināts. \/Dūdūt ryndys 'teksts', atsyuti tuos md5 haša ekvivalenta ryndys. \/\/ >>> string_to_md5(\"Hello world\")\n\/\/ \"3e25960a79dbc69b674cd4ec67a72c62\"\nfunction string_to_md5(text){\n","canonical_solution":"const crypto = require('crypto');\n\nfunction string_to_md5(text) {\n    if (text === \"\") {\n        return undefined;\n    }\n    return crypto.createHash('md5').update(text).digest('hex');\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = string_to_md5;\n  assert.deepEqual(candidate(\"Hello world\"),\"3e25960a79dbc69b674cd4ec67a72c62\");\n  assert.deepEqual(candidate(\"\"),undefined);\n  assert.deepEqual(candidate(\"A B C\"),\"0ef78513b0cb8cef12743f5aeb35f888\");\n  assert.deepEqual(candidate(\"password\"),\"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n\ntest();"},{"task_id":"HumanEval_163","nl":"ltg_Latn","pl":"js","prompt":"\/ Par pīmāru: \/ i b, pīaugūša kuortuos. \/Dūdūt divejim pozitivim vasalūs skaitlim a i b, atsoka pat ciparus storp a \/\/ >>> generate_integers(2, 8)\n\/\/ [2, 4, 6, 8]\n\/\/ >>> generate_integers(8, 2)\n\/\/ [2, 4, 6, 8]\n\/\/ >>> generate_integers(10, 14)\n\/\/ []\nfunction generate_integers(a, b){\n","canonical_solution":"function generate_integers(a, b) {\n    let start = Math.min(a, b);\n    let end = Math.max(a, b);\n    let evenDigits = [];\n\n    for (let i = start; i <= end; i++) {\n        if (i % 2 === 0) {\n            evenDigits.push(i);\n        }\n    }\n\n    return evenDigits;\n}","tests":"const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = generate_integers;\n  assert.deepEqual(candidate(2, 10),[2, 4, 6, 8]);\n  assert.deepEqual(candidate(10, 2),[2, 4, 6, 8]);\n  assert.deepEqual(candidate(132, 2),[2, 4, 6, 8]);\n  assert.deepEqual(candidate(17, 89),[]);\n}\n\ntest();"}]