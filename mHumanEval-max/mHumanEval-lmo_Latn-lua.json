[{"task_id":"HumanEval_0","nl":"lmo_Latn","pl":"lua","prompt":"- dato soglia. - Verifichè se in la tabèla di nùmer, gh'è du nùmer piö 'nsèma che -- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\n-- false\n-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n-- true\nlocal function has_close_elements(numbers, threshold)\n","canonical_solution":"local function has_close_elements(numbers, threshold)\n    for i = 1, #numbers do\n        for j = i + 1, #numbers do\n            if math.abs(numbers[i] - numbers[j]) < threshold then\n                return true\n            end\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = has_close_elements\n    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), true)\n    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), false)\n    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), true)\n    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), false)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), true)\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), true)\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_1","nl":"lmo_Latn","pl":"lua","prompt":"- Ignorà i spazi in la stringa d'ingressi.- I grup separàcc i è bilanciàcc (ogn'artigliàcc apert l'è bèin serràcc) e i è minga insèmma l'un de l'àutr.- separà quei grup in strings separà e restituì la tabella di quei.- L'input de sta funziun l'è una stringa cont i grup de parentesi innestaa.-- >>> separate_paren_groups('( ) (( )) (( )( ))')\n-- {'()', '(())', '(()())'}\nlocal function separate_paren_groups(paren_string)\n","canonical_solution":"local function separate_paren_groups(paren_string)\n    local result = {}\n    local balance = 0\n    local current_group = {}\n\n    for i = 1, #paren_string do\n        local char = paren_string:sub(i, i)\n        \n        if char == '(' then\n            balance = balance + 1\n        elseif char == ')' then\n            balance = balance - 1\n        end\n\n        if char ~= ' ' then\n            table.insert(current_group, char)\n        end\n        \n        if balance == 0 and #current_group > 0 then\n            table.insert(result, table.concat(current_group))\n            current_group = {}\n        end\n    end\n\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = separate_paren_groups\n    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {'(()())', '((()))', '()', '((())()())'})\n    lu.assertEquals(candidate('() (()) ((())) (((())))'), {'()', '(())', '((()))', '(((())))'})\n    lu.assertEquals(candidate('(()(())((())))'), {'(()(())((())))'})\n    lu.assertEquals(candidate('( ) (( )) (( )( ))'), {'()', '(())', '(()())'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_2","nl":"lmo_Latn","pl":"lua","prompt":"- Render la part decimal del numer.- (la part restanta l'è semper püssee picia de 1).- e part de intèr (intèr piö gròs piö püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè püsè- Dàt un nùmer a pont flùs positiv, al pò vèss scompòst in -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n","canonical_solution":"local function truncate_number(number)\n    local integer_part = math.floor(number)\n    local decimal_part = number - integer_part\n    return decimal_part\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_3","nl":"lmo_Latn","pl":"lua","prompt":"- in quel punt la funziun la dovariss tornà true. altrimenti la dovariss tornà false.- saldo zero. al tò compit l'è de scovà se a un quai punt el saldo del conto el cala sòtta a zero, e - Te gh'è una tabella di operazion de depòsit e de ritirada in d'un cont bancari che la scomincia con -- >>> below_zero({1, 2, 3})\n-- false\n-- >>> below_zero({1, 2, -4, 5})\n-- true\nlocal function below_zero(operations)\n","canonical_solution":"local function below_zero(operations)\n    local balance = 0\n    for _, operation in ipairs(operations) do\n        balance = balance + operation\n        if balance < 0 then\n            return true\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = below_zero\n    lu.assertEquals(candidate({}), false)\n    lu.assertEquals(candidate({1, 2, -3, 1, 2, -3}), false)\n    lu.assertEquals(candidate({1, 2, -4, 5, 6}), true)\n    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -4}), false)\n    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -5}), true)\n    lu.assertEquals(candidate({1, -2, 2, -2, 5, -5, 4, -4}), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_4","nl":"lmo_Latn","pl":"lua","prompt":"- MAD = AVERAGE. x - x_mean.- element e un punt de centru (meana in chest cas): - La deviazion assoluta media l'è la differenza assoluta media tra ogni - intorna a la media de 'sto dataset.- Per una tabella data di numeri d'ingresso, calcola la deviazion assoluta media -- >>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n-- 1.0\nlocal function mean_absolute_deviation(numbers)\n","canonical_solution":"local function mean_absolute_deviation(numbers)\n    local sum = 0\n    local count = #numbers\n    \n    -- Calculate the mean\n    for _, number in ipairs(numbers) do\n        sum = sum + number\n    end\n    local mean = sum \/ count\n    \n    -- Calculate the mean absolute deviation\n    local total_deviation = 0\n    for _, number in ipairs(numbers) do\n        total_deviation = total_deviation + math.abs(number - mean)\n    end\n    \n    return total_deviation \/ count\nend\n\n-- Example usage\n-- print(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})) -- Output: 1.0","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = mean_absolute_deviation\n    lu.assertEquals(candidate({1.0, 2.0}), 0.5)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0}), 1.0)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}), 1.2)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_5","nl":"lmo_Latn","pl":"lua","prompt":"- Insert a numer \"delimeter\" between every two consecutive elements of input table ∀numbers\" -- >>> intersperse({}, 4)\n-- {}\n-- >>> intersperse({1, 2, 3}, 4)\n-- {1, 4, 2, 4, 3}\nlocal function intersperse(numbers, delimeter)\n","canonical_solution":"local function intersperse(numbers, delimeter)\n    local result = {}\n    for i = 1, #numbers do\n        table.insert(result, numbers[i])\n        if i < #numbers then\n            table.insert(result, delimeter)\n        end\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersperse\n    lu.assertEquals(candidate({}, 7), {})\n    lu.assertEquals(candidate({5, 6, 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})\n    lu.assertEquals(candidate({2, 2, 2}, 2), {2, 2, 2, 2, 2})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_6","nl":"lmo_Latn","pl":"lua","prompt":"- p.e. (() (()) ha maxim 2 livelli di nidificazione mentre ((())) ha 3 .- Per ognidün del grup, fà la sortida del livel piö profond de l'incrustasiù de parentesi.- Input a sta funziun l'è una stringa rapreentada de grup plü per parentesi imbastìda separada de spazi.-- >>> parse_nested_parens('(()()) ((())) () ((())()())')\n-- {2, 3, 1, 3}\nlocal function parse_nested_parens(paren_string)\n","canonical_solution":"local function parse_nested_parens(paren_string)\n    local results = {}\n    for group in paren_string:gmatch(\"%S+\") do\n        local max_depth = 0\n        local current_depth = 0\n        for char in group:gmatch(\".\") do\n            if char == '(' then\n                current_depth = current_depth + 1\n                if current_depth > max_depth then\n                    max_depth = current_depth\n                end\n            elseif char == ')' then\n                current_depth = current_depth - 1\n            end\n        end\n        table.insert(results, max_depth)\n    end\n    return results\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = parse_nested_parens\n    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {2, 3, 1, 3})\n    lu.assertEquals(candidate('() (()) ((())) (((())))'), {1, 2, 3, 4})\n    lu.assertEquals(candidate('(()(())((())))'), {4})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_7","nl":"lmo_Latn","pl":"lua","prompt":"- Filter una tabella di input di string solo per quelle che contengono data substring -- >>> filter_by_substring({}, 'a')\n-- {}\n-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')\n-- {'abc', 'bacd', 'array'}\nlocal function filter_by_substring(strings, substring)\n","canonical_solution":"local function filter_by_substring(strings, substring)\n    local result = {}\n    for _, str in ipairs(strings) do\n        if string.find(str, substring) then\n            table.insert(result, str)\n        end\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_by_substring\n    lu.assertEquals(candidate({}, 'john'), {})\n    lu.assertEquals(candidate({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})\n    lu.assertEquals(candidate({'xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'}, 'xx'), {'xxx', 'aaaxxy', 'xxxAAA', 'xxx'})\n    lu.assertEquals(candidate({'grunt', 'trumpet', 'prune', 'gruesome'}, 'run'), {'grunt', 'prune'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_8","nl":"lmo_Latn","pl":"lua","prompt":"- La soma de la part vaga la dev vess uguala a 0 e el prodot de la part vaga l dev vess uguala a 1.- Per una tabella di interi, restituisci una tabella che consiste in una somma e in un prodotto di tutti i numeri interi in una tabella.-- >>> sum_product({})\n-- {0, 1}\n-- >>> sum_product({1, 2, 3, 4})\n-- {10, 24}\nlocal function sum_product(numbers)\n","canonical_solution":"local function sum_product(numbers)\n    local sum = 0\n    local product = 1\n\n    for _, number in ipairs(numbers) do\n        sum = sum + number\n        product = product * number\n    end\n\n    return {sum, product}\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_product\n    lu.assertEquals(candidate({}), {0, 1})\n    lu.assertEquals(candidate({1, 1, 1}), {3, 1})\n    lu.assertEquals(candidate({100, 0}), {100, 0})\n    lu.assertEquals(candidate({3, 5, 7}), {15, 105})\n    lu.assertEquals(candidate({10}), {10, 10})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_9","nl":"lmo_Latn","pl":"lua","prompt":"- in sequenza.- Da na tabela de entiers, genera na tabela de element maxim de rodament trovà fin a un moment dat.-- >>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n-- {1, 2, 3, 3, 3, 4, 4}\nlocal function rolling_max(numbers)\n","canonical_solution":"local function rolling_max(numbers)\n    local result = {}\n    local max_so_far = numbers[1]\n    \n    for i = 1, #numbers do\n        if numbers[i] > max_so_far then\n            max_so_far = numbers[i]\n        end\n        table.insert(result, max_so_far)\n    end\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rolling_max\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 2, 3, 4})\n    lu.assertEquals(candidate({4, 3, 2, 1}), {4, 4, 4, 4})\n    lu.assertEquals(candidate({3, 2, 3, 100, 3}), {3, 3, 3, 100, 100})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_10","nl":"lmo_Latn","pl":"lua","prompt":"- - Aggiungi a la fin de la stringa inversa de un prefiss de stringa che vegn prima del sufissi palindrom.- - Trova el postfix piö longh de la stringa fornida che l'è on palindrom. - L'idea de l'algoritm l'è semplice:- Trova el palindrom piö curto che 'l cumincia con una stringa fornida.-- >>> make_palindrome('')\n-- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n-- 'catac'\nlocal function make_palindrome(string)\n","canonical_solution":"local function make_palindrome(s)\n    -- Function to check if a given string is a palindrome\n    local function is_palindrome(str)\n        local len = #str\n        for i = 1, len \/\/ 2 do\n            if str:sub(i, i) ~= str:sub(len - i + 1, len - i + 1) then\n                return false\n            end\n        end\n        return true\n    end\n\n    local len = #s\n    -- Find the longest postfix of the string that is a palindrome\n    for i = len, 1, -1 do\n        if is_palindrome(s:sub(i)) then\n            local prefix = s:sub(1, i - 1)\n            -- Reverse the prefix and append to the original string\n            return s .. prefix:reverse()\n        end\n    end\n\n    -- If the string is empty or no palindrome is found (shouldn't happen as \n    -- an empty or single character string is a palindrome), return the string itself\n    return s\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_11","nl":"lmo_Latn","pl":"lua","prompt":"- Esegui XOR binari su questi input e restituisci anche come stringa.- Input i è du string a e b che i è cumpost de 1 e 0-- >>> string_xor('010', '110')\n-- '100'\nlocal function string_xor(a, b)\n","canonical_solution":"local function string_xor(a, b)\n    local result = {}\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            table.insert(result, '0')\n        else\n            table.insert(result, '1')\n        end\n    end\n    return table.concat(result)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_12","nl":"lmo_Latn","pl":"lua","prompt":"- strings de la stessa lunghesa.- Da la tabèla de le stringhe, rend la più longa. Rend la prima in cas de plü-- >>> longest({})\n-- None\n-- >>> longest({'a', 'b', 'c'})\n-- 'a'\n-- >>> longest({'a', 'bb', 'ccc'})\n-- 'ccc'\nlocal function longest(strings)\n","canonical_solution":"local function longest(strings)\n    if #strings == 0 then\n        return nil\n    end\n\n    local max_len = 0\n    local longest_str = nil\n\n    for _, str in ipairs(strings) do\n        if #str > max_len then\n            max_len = #str\n            longest_str = str\n        end\n    end\n\n    return longest_str\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = longest\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({'x', 'y', 'z'}), 'x')\n    lu.assertEquals(candidate({'x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc'}), 'zzzz')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_13","nl":"lmo_Latn","pl":"lua","prompt":"- Render a greatest common divisor of two integers a e b -- >>> greatest_common_divisor(3, 5)\n-- 1\n-- >>> greatest_common_divisor(25, 15)\n-- 5\nlocal function greatest_common_divisor(a, b)\n","canonical_solution":"local function greatest_common_divisor(a, b)\n    while b ~= 0 do\n        local temp = b\n        b = a % b\n        a = temp\n    end\n    return a\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = greatest_common_divisor\n    lu.assertEquals(candidate(3, 7), 1)\n    lu.assertEquals(candidate(10, 15), 5)\n    lu.assertEquals(candidate(49, 14), 7)\n    lu.assertEquals(candidate(144, 60), 12)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_14","nl":"lmo_Latn","pl":"lua","prompt":"- Ritorna tabella di tutti i prefissi dal più curto al più lungo della stringa di input -- >>> all_prefixes('abc')\n-- {'a', 'ab', 'abc'}\nlocal function all_prefixes(string)\n","canonical_solution":"local function all_prefixes(string)\n    local prefixes = {}\n    for i = 1, #string do\n        table.insert(prefixes, string:sub(1, i))\n    end\n    return prefixes\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = all_prefixes\n    lu.assertEquals(candidate(''), {})\n    lu.assertEquals(candidate('asdfgh'), {'a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'})\n    lu.assertEquals(candidate('WWW'), {'W', 'WW', 'WWW'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_15","nl":"lmo_Latn","pl":"lua","prompt":"- Render una stringa cont i numer delimitaa in spazziu che la partiss da 0 fin a n.-- >>> string_sequence(0)\n-- '0'\n-- >>> string_sequence(5)\n-- '0 1 2 3 4 5'\nlocal function string_sequence(n)\n","canonical_solution":"local function string_sequence(n)\n    local result = {}\n    for i = 0, n do\n        table.insert(result, tostring(i))\n    end\n    return table.concat(result, \" \")\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_sequence\n    lu.assertEquals(candidate(0), '0')\n    lu.assertEquals(candidate(3), '0 1 2 3')\n    lu.assertEquals(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_16","nl":"lmo_Latn","pl":"lua","prompt":"- Given a string, find out how many distinct characters (regardless of case) does it consist of -- >>> count_distinct_characters('xyzXYZ')\n-- 3\n-- >>> count_distinct_characters('Jerry')\n-- 4\nlocal function count_distinct_characters(string)\n","canonical_solution":"local function count_distinct_characters(string)\n    local char_set = {}\n    local lower_string = string:lower()\n    for i = 1, #lower_string do\n        local char = lower_string:sub(i, i)\n        char_set[char] = true\n    end\n    local count = 0\n    for _ in pairs(char_set) do\n        count = count + 1\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_distinct_characters\n    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('abcde'), 5)\n    lu.assertEquals(candidate('abcdecadeCADE'), 5)\n    lu.assertEquals(candidate('aaaaAAAAaaaa'), 1)\n    lu.assertEquals(candidate('Jerry jERRY JeRRRY'), 5)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_17","nl":"lmo_Latn","pl":"lua","prompt":"- \"Sì, sì, sì\" - \"Quater note, dura un batt\"- \"O saccà\" - mezza nota, dura due batt.- \"O\" - Totta la nota, dura quatt batt - Chesta è na leggenda:- no ultim.- Al tò compit a l'é de analizé sta cadena e d'arreturné na tàula d'intèr ch'a corispond a quanta batùdes a fa ognidun - L'input de sta funziun l'è una stringa che la rappresenta i nòcc musicali in un format special ASCII.-- >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n-- {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nlocal function parse_music(music_string)\n","canonical_solution":"local function parse_music(music_string)\n    local beats = {}\n    for note in music_string:gmatch(\"%S+\") do\n        if note == 'o' then\n            table.insert(beats, 4)\n        elseif note == 'o|' then\n            table.insert(beats, 2)\n        elseif note == '.|' then\n            table.insert(beats, 1)\n        end\n    end\n    return beats\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = parse_music\n    lu.assertEquals(candidate(''), {})\n    lu.assertEquals(candidate('o o o o'), {4, 4, 4, 4})\n    lu.assertEquals(candidate('.| .| .| .|'), {1, 1, 1, 1})\n    lu.assertEquals(candidate('o| o| .| .| o o o o'), {2, 2, 1, 1, 4, 4, 4, 4})\n    lu.assertEquals(candidate('o| .| o| .| o o| o o|'), {2, 1, 2, 1, 4, 2, 4, 2})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_18","nl":"lmo_Latn","pl":"lua","prompt":"- Trova quante volte una data sottostringa la se pò trovà in la stringa originaria.-- >>> how_many_times('', 'a')\n-- 0\n-- >>> how_many_times('aaa', 'a')\n-- 3\n-- >>> how_many_times('aaaa', 'aa')\n-- 3\nlocal function how_many_times(string, substring)\n","canonical_solution":"local function how_many_times(string, substring)\n    if substring == '' then return 0 end\n    local count = 0\n    local start = 1\n\n    while true do\n        local found = string:find(substring, start, true)\n        if not found then\n            break\n        end\n        count = count + 1\n        start = found + 1\n    end\n\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = how_many_times\n    lu.assertEquals(candidate('', 'x'), 0)\n    lu.assertEquals(candidate('xyxyxyx', 'x'), 4)\n    lu.assertEquals(candidate('cacacacac', 'cac'), 4)\n    lu.assertEquals(candidate('john doe', 'john'), 1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_19","nl":"lmo_Latn","pl":"lua","prompt":"- Rend la stringa con i numm ordinad da piö picen a piö grand - I scelte valide hinn \"zero\", \"uno\", \"due\", \"tre\", \"quattro\", \"cinque\", \"sei\", \"sette\", \"otto\" e \"nove\". - L'input l'è una sequenza de numeral de \"zero\" a \"nove\" delimitaa in spazzi.-- >>> sort_numbers('three one five')\n-- 'one three five'\nlocal function sort_numbers(numbers)\n","canonical_solution":"local function sort_numbers(numbers)\n    local number_map = {\n        zero = 0,\n        one = 1,\n        two = 2,\n        three = 3,\n        four = 4,\n        five = 5,\n        six = 6,\n        seven = 7,\n        eight = 8,\n        nine = 9\n    }\n\n    local number_names = {\n        [0] = 'zero',\n        [1] = 'one',\n        [2] = 'two',\n        [3] = 'three',\n        [4] = 'four',\n        [5] = 'five',\n        [6] = 'six',\n        [7] = 'seven',\n        [8] = 'eight',\n        [9] = 'nine'\n    }\n\n    local words = {}\n    for word in numbers:gmatch(\"%S+\") do\n        table.insert(words, word)\n    end\n\n    table.sort(words, function(a, b)\n        return number_map[a] < number_map[b]\n    end)\n\n    local sorted_numbers = {}\n    for _, word in ipairs(words) do\n        table.insert(sorted_numbers, number_names[number_map[word]])\n    end\n\n    return table.concat(sorted_numbers, \" \")\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_numbers\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('three'), 'three')\n    lu.assertEquals(candidate('three five nine'), 'three five nine')\n    lu.assertEquals(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')\n    lu.assertEquals(candidate('six five four three two one zero'), 'zero one two three four five six')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_20","nl":"lmo_Latn","pl":"lua","prompt":"- altri e li restituisci in ordine (meno numerosi, più numerosi).- Da na tabela de numeres (de longhessa almanco de doi) seleghe e torna doi che é i plu apress a ogni -- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n-- {2.0, 2.2}\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n-- {2.0, 2.0}\nlocal function find_closest_elements(numbers)\n","canonical_solution":"local function find_closest_elements(numbers)\n    table.sort(numbers)\n    local min_diff = math.huge\n    local result = {}\n\n    for i = 1, #numbers - 1 do\n        local diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff then\n            min_diff = diff\n            result = {numbers[i], numbers[i + 1]}\n        end\n    end\n\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_closest_elements\n    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), {3.9, 4.0})\n    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}), {5.0, 5.9})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), {2.0, 2.2})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), {2.0, 2.0})\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}), {2.2, 3.1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_21","nl":"lmo_Latn","pl":"lua","prompt":"- inscì che el nümer püsee piscinin el diventi 0 e el püsee grand el diventi 1 - Given table of numbers (of at least two elements), apply a linear transform to that table, -- >>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n-- {0.0, 0.25, 0.5, 0.75, 1.0}\nlocal function rescale_to_unit(numbers)\n","canonical_solution":"local function rescale_to_unit(numbers)\n    local min_val = math.huge\n    local max_val = -math.huge\n\n    -- Find the min and max values in the table\n    for _, num in ipairs(numbers) do\n        if num < min_val then\n            min_val = num\n        end\n        if num > max_val then\n            max_val = num\n        end\n    end\n\n    local scale = max_val - min_val\n\n    -- Apply the transformation\n    local transformed = {}\n    for i, num in ipairs(numbers) do\n        transformed[i] = (num - min_val) \/ scale\n    end\n\n    return transformed\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rescale_to_unit\n    lu.assertEquals(candidate({2.0, 49.9}), {0.0, 1.0})\n    lu.assertEquals(candidate({100.0, 49.9}), {1.0, 0.0})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}), {0.0, 0.25, 0.5, 0.75, 1.0})\n    lu.assertEquals(candidate({2.0, 1.0, 5.0, 3.0, 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\n    lu.assertEquals(candidate({12.0, 11.0, 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_22","nl":"lmo_Latn","pl":"lua","prompt":"- Filter given table of any xaldon values only for integers -- >>> filter_integers({'a', 3.14, 5})\n-- {5}\n-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})\n-- {1, 2, 3}\nlocal function filter_integers(values)\n","canonical_solution":"local function filter_integers(values)\n    local result = {}\n    for _, value in ipairs(values) do\n        if type(value) == \"number\" and math.type(value) == \"integer\" then\n            table.insert(result, value)\n        end\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_integers\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({4, {}, {}, 23.2, 9, 'adasd'}), {4, 9})\n    lu.assertEquals(candidate({3, 'c', 3, 3, 'a', 'b'}), {3, 3, 3})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_23","nl":"lmo_Latn","pl":"lua","prompt":"- Ritorna lunghesa de la stringa data -- >>> strlen('')\n-- 0\n-- >>> strlen('abc')\n-- 3\nlocal function strlen(string)\n","canonical_solution":"local function strlen(string)\n    return #string\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = strlen\n    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('x'), 1)\n    lu.assertEquals(candidate('asdasnakj'), 9)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_24","nl":"lmo_Latn","pl":"lua","prompt":"- Per un dato nùmer n, trova el nùmer piö gràn che divid n in manera ugualitàla, piö picìn de n -- >>> largest_divisor(15)\n-- 5\nlocal function largest_divisor(n)\n","canonical_solution":"local function largest_divisor(n)\n    for i = n - 1, 1, -1 do\n        if n % i == 0 then\n            return i\n        end\n    end\n    return nil -- In case no divisor is found, though this will not happen for n > 1\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_divisor\n    lu.assertEquals(candidate(3), 1)\n    lu.assertEquals(candidate(7), 1)\n    lu.assertEquals(candidate(10), 5)\n    lu.assertEquals(candidate(100), 50)\n    lu.assertEquals(candidate(49), 7)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_25","nl":"lmo_Latn","pl":"lua","prompt":"- L'input numer al dovarès èser uguaai al prodot de tücc i fattur.- Ogni fattur al va metüü in tabela al numer de volt che al corispond a quante volt che al vegn metüü in la fatorizazion.- Ritorna tabella dei fattori primi di dato inter in ordine dal più piccol al più grande.-- >>> factorize(8)\n-- {2, 2, 2}\n-- >>> factorize(25)\n-- {5, 5}\n-- >>> factorize(70)\n-- {2, 5, 7}\nlocal function factorize(n)\n","canonical_solution":"local function factorize(n)\n    local factors = {}\n    local divisor = 2\n    while n > 1 do\n        while n % divisor == 0 do\n            table.insert(factors, divisor)\n            n = n \/ divisor\n        end\n        divisor = divisor + 1\n    end\n    return factors\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = factorize\n    lu.assertEquals(candidate(2), {2})\n    lu.assertEquals(candidate(4), {2, 2})\n    lu.assertEquals(candidate(8), {2, 2, 2})\n    lu.assertEquals(candidate(57), {3, 19})\n    lu.assertEquals(candidate(3249), {3, 3, 19, 19})\n    lu.assertEquals(candidate(185193), {3, 3, 3, 19, 19, 19})\n    lu.assertEquals(candidate(20577), {3, 19, 19, 19})\n    lu.assertEquals(candidate(18), {2, 3, 3})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_26","nl":"lmo_Latn","pl":"lua","prompt":"- Mantenì l'ordin di element lassaa uguale a quell de l'input.- Da na tàula di intèr, sbarazè tüti i elemènt che i se tróa piö de na vòlta.-- >>> remove_duplicates({1, 2, 3, 2, 4})\n-- {1, 3, 4}\nlocal function remove_duplicates(numbers)\n","canonical_solution":"local function remove_duplicates(numbers)\n    local counts = {}\n    -- Count occurrences of each element\n    for _, num in ipairs(numbers) do\n        counts[num] = (counts[num] or 0) + 1\n    end\n    -- Collect elements that occur exactly once\n    local result = {}\n    for _, num in ipairs(numbers) do\n        if counts[num] == 1 then\n            table.insert(result, num)\n        end\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = remove_duplicates\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 2, 3, 4})\n    lu.assertEquals(candidate({1, 2, 3, 2, 4, 3, 5}), {1, 4, 5})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_27","nl":"lmo_Latn","pl":"lua","prompt":"- Per una data stringa, girà i caratteri minuscol a maiuscol e maiuscol a minuscol.-- >>> flip_case('Hello')\n-- 'hELLO'\nlocal function flip_case(string)\n","canonical_solution":"local function flip_case(str)\n    return (str:gsub(\"%a\", function(c)\n        if c:lower() == c then\n            return c:upper()\n        else\n            return c:lower()\n        end\n    end))\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = flip_case\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('Hello!'), 'hELLO!')\n    lu.assertEquals(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_28","nl":"lmo_Latn","pl":"lua","prompt":"- Concatenate tabella di string in una singola string -- >>> concatenate({})\n-- ''\n-- >>> concatenate({'a', 'b', 'c'})\n-- 'abc'\nlocal function concatenate(strings)\n","canonical_solution":"local function concatenate(strings)\n    return table.concat(strings, \"\")\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = concatenate\n    lu.assertEquals(candidate({}), '')\n    lu.assertEquals(candidate({'x', 'y', 'z'}), 'xyz')\n    lu.assertEquals(candidate({'x', 'y', 'z', 'w', 'k'}), 'xyzwk')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_29","nl":"lmo_Latn","pl":"lua","prompt":"- Filter una tabella di input di string solo per quelle che cominciano con un prefisso dato.-- >>> filter_by_prefix({}, 'a')\n-- {}\n-- >>> filter_by_prefix({'abc', 'bcd', 'cde', 'array'}, 'a')\n-- {'abc', 'array'}\nlocal function filter_by_prefix(strings, prefix)\n","canonical_solution":"local function filter_by_prefix(strings, prefix)\n    local result = {}\n    for _, str in ipairs(strings) do\n        if str:sub(1, #prefix) == prefix then\n            table.insert(result, str)\n        end\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_by_prefix\n    lu.assertEquals(candidate({}, 'john'), {})\n    lu.assertEquals(candidate({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_30","nl":"lmo_Latn","pl":"lua","prompt":"- Rendì sö i nümar pusìf in la tàula.-- >>> get_positive({-1, 2, -4, 5, 6})\n-- {2, 5, 6}\n-- >>> get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n-- {5, 3, 2, 3, 9, 123, 1}\nlocal function get_positive(l)\n","canonical_solution":"local function get_positive(l)\n    local positives = {}\n    for _, v in ipairs(l) do\n        if v > 0 then\n            table.insert(positives, v)\n        end\n    end\n    return positives\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_positive\n    lu.assertEquals(candidate({-1, -2, 4, 5, 6}), {4, 5, 6})\n    lu.assertEquals(candidate({5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), {5, 3, 2, 3, 3, 9, 123, 1})\n    lu.assertEquals(candidate({-1, -2}), {})\n    lu.assertEquals(candidate({}), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_31","nl":"lmo_Latn","pl":"lua","prompt":"- Render true se un dato nùmer l'è prim, e false altrimenti.-- >>> is_prime(6)\n-- false\n-- >>> is_prime(101)\n-- true\n-- >>> is_prime(11)\n-- true\n-- >>> is_prime(13441)\n-- true\n-- >>> is_prime(61)\n-- true\n-- >>> is_prime(4)\n-- false\n-- >>> is_prime(1)\n-- false\nlocal function is_prime(n)\n","canonical_solution":"local function is_prime(n)\n    if n <= 1 then\n        return false\n    end\n    if n <= 3 then\n        return true\n    end\n    if n % 2 == 0 or n % 3 == 0 then\n        return false\n    end\n    local i = 5\n    while i * i <= n do\n        if n % i == 0 or n % (i + 2) == 0 then\n            return false\n        end\n        i = i + 6\n    end\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_prime\n    lu.assertEquals(candidate(6), false)\n    lu.assertEquals(candidate(101), true)\n    lu.assertEquals(candidate(11), true)\n    lu.assertEquals(candidate(13441), true)\n    lu.assertEquals(candidate(61), true)\n    lu.assertEquals(candidate(4), false)\n    lu.assertEquals(candidate(1), false)\n    lu.assertEquals(candidate(5), true)\n    lu.assertEquals(candidate(11), true)\n    lu.assertEquals(candidate(17), true)\n    lu.assertEquals(candidate(85), false)\n    lu.assertEquals(candidate(77), false)\n    lu.assertEquals(candidate(255379), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_33","nl":"lmo_Latn","pl":"lua","prompt":"- ai valurs di indici corispondent de l, ma ordinà.- l' l' è idèntica a l in di indici che i è minga divisìbil per trè, menter i sò valùr in di indici che i è divisìbil per trè i è uguali - Questa funzione prende una tabella l e restituisce una tabella l' tale che -- >>> sort_third({1, 2, 3})\n-- {1, 2, 3}\n-- >>> sort_third({5, 6, 3, 4, 8, 9, 2})\n-- {2, 6, 3, 4, 8, 9, 5}\nlocal function sort_third(l)\n","canonical_solution":"local function sort_third(l)\n    local divisible_by_three = {}\n    \n    -- Collect elements at indices divisible by three\n    for i = 3, #l, 3 do\n        table.insert(divisible_by_three, l[i])\n    end\n\n    -- Sort collected elements\n    table.sort(divisible_by_three)\n    \n    -- Create a copy of the original table\n    local l_prime = {}\n    for i = 1, #l do\n        l_prime[i] = l[i]\n    end\n\n    -- Replace elements at indices divisible by three with sorted elements\n    local sorted_index = 1\n    for i = 3, #l, 3 do\n        l_prime[i] = divisible_by_three[sorted_index]\n        sorted_index = sorted_index + 1\n    end\n\n    return l_prime\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_third\n    lu.assertEquals(candidate({5, 6, 3, 4, 8, 9, 2}), {2, 6, 3, 4, 8, 9, 5})\n    lu.assertEquals(candidate({5, 8, 3, 4, 6, 9, 2}), {2, 8, 3, 4, 6, 9, 5})\n    lu.assertEquals(candidate({5, 6, 9, 4, 8, 3, 2}), {2, 6, 9, 4, 8, 3, 5})\n    lu.assertEquals(candidate({5, 6, 3, 4, 8, 9, 2, 1}), {2, 6, 3, 4, 8, 9, 5, 1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_34","nl":"lmo_Latn","pl":"lua","prompt":"- Render sorted unique elements in a table -- >>> unique({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {0, 2, 3, 5, 9, 123}\nlocal function unique(l)\n","canonical_solution":"local function unique(l)\n    local seen = {}\n    local result = {}\n    \n    for _, value in ipairs(l) do\n        if not seen[value] then\n            table.insert(result, value)\n            seen[value] = true\n        end\n    end\n    \n    table.sort(result)\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = unique\n    lu.assertEquals(candidate({5, 3, 5, 2, 3, 3, 9, 0, 123}), {0, 2, 3, 5, 9, 123})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_35","nl":"lmo_Latn","pl":"lua","prompt":"- Render l'element maxim in la tabella.-- >>> max_element({1, 2, 3})\n-- 3\n-- >>> max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n-- 123\nlocal function max_element(l)\n","canonical_solution":"local function max_element(l)\n    local max = l[1]\n    for i = 2, #l do\n        if l[i] > max then\n            max = l[i]\n        end\n    end\n    return max\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_element\n    lu.assertEquals(candidate({1, 2, 3}), 3)\n    lu.assertEquals(candidate({5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), 124)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_36","nl":"lmo_Latn","pl":"lua","prompt":"- Rendi el numer de volt che la cifra 7 la se troeuva in di intger men de n che hinn divisibil per 11 o 13. -- >>> fizz_buzz(50)\n-- 0\n-- >>> fizz_buzz(78)\n-- 2\n-- >>> fizz_buzz(79)\n-- 3\nlocal function fizz_buzz(n)\n","canonical_solution":"local function fizz_buzz(n)\n    local count = 0\n    for i = 1, n - 1 do\n        if i % 11 == 0 or i % 13 == 0 then\n            local str_i = tostring(i)\n            if str_i:find(\"7\") then\n                count = count + 1\n            end\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fizz_buzz\n    lu.assertEquals(candidate(50), 0)\n    lu.assertEquals(candidate(78), 2)\n    lu.assertEquals(candidate(79), 3)\n    lu.assertEquals(candidate(100), 3)\n    lu.assertEquals(candidate(200), 6)\n    lu.assertEquals(candidate(4000), 192)\n    lu.assertEquals(candidate(10000), 639)\n    lu.assertEquals(candidate(100000), 8026)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_37","nl":"lmo_Latn","pl":"lua","prompt":"- ai valùr dei indici pari de l, ma ordinàcc.- l' l' è idèntica a l in di indici dispari, menter i sò valùr in di indici pari i è uguali - Questa funzione prende una tabella l e restituisce una tabella l' tale che -- >>> sort_even({1, 2, 3})\n-- {1, 2, 3}\n-- >>> sort_even({5, 6, 3, 4})\n-- {3, 6, 5, 4}\nlocal function sort_even(l)\n","canonical_solution":"local function sort_even(l)\n    -- Extract the even indexed elements\n    local even_elements = {}\n    for i = 2, #l, 2 do\n        table.insert(even_elements, l[i])\n    end\n\n    -- Sort the extracted even elements\n    table.sort(even_elements)\n\n    -- Create a new table for the result and fill it with the appropriate elements\n    local result = {}\n    local even_index = 1\n    for i = 1, #l do\n        if i % 2 == 0 then\n            result[i] = even_elements[even_index]\n            even_index = even_index + 1\n        else\n            result[i] = l[i]\n        end\n    end\n\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_even\n    lu.assertEquals(candidate({1, 2, 3}), {1, 2, 3})\n    lu.assertEquals(candidate({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123})\n    lu.assertEquals(candidate({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_39","nl":"lmo_Latn","pl":"lua","prompt":"- prime_fib restituisce n-esimo numero che è un numero di Fibonacci e che è pure primo. -- >>> prime_fib(1)\n-- 2\n-- >>> prime_fib(2)\n-- 3\n-- >>> prime_fib(3)\n-- 5\n-- >>> prime_fib(4)\n-- 13\n-- >>> prime_fib(5)\n-- 89\nlocal function prime_fib(n)\n","canonical_solution":"local function is_prime(num)\n    if num <= 1 then return false end\n    if num <= 3 then return true end\n    if num % 2 == 0 or num % 3 == 0 then return false end\n    local i = 5\n    while i * i <= num do\n        if num % i == 0 or num % (i + 2) == 0 then\n            return false\n        end\n        i = i + 6\n    end\n    return true\nend\n\nlocal function fibonacci()\n    local a, b = 0, 1\n    return function()\n        local temp = a\n        a, b = b, a + b\n        return temp\n    end\nend\n\nlocal function prime_fib(n)\n    local count = 0\n    local fib_gen = fibonacci()\n    while true do\n        local fib_num = fib_gen()\n        if is_prime(fib_num) then\n            count = count + 1\n            if count == n then\n                return fib_num\n            end\n        end\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = prime_fib\n    lu.assertEquals(candidate(1), 2)\n    lu.assertEquals(candidate(2), 3)\n    lu.assertEquals(candidate(3), 5)\n    lu.assertEquals(candidate(4), 13)\n    lu.assertEquals(candidate(5), 89)\n    lu.assertEquals(candidate(6), 233)\n    lu.assertEquals(candidate(7), 1597)\n    lu.assertEquals(candidate(8), 28657)\n    lu.assertEquals(candidate(9), 514229)\n    lu.assertEquals(candidate(10), 433494437)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_40","nl":"lmo_Latn","pl":"lua","prompt":"- Summa a zero, e falsa altrimenti.- al torna true se gh'è trii element distint in la tabela che - triples_sum_to_zero al fà 'na tabèla di intèrn come input.-- >>> triples_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> triples_sum_to_zero({1, 3, -2, 1})\n-- true\n-- >>> triples_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})\n-- true\n-- >>> triples_sum_to_zero({1})\n-- false\nlocal function triples_sum_to_zero(l)\n","canonical_solution":"local function triples_sum_to_zero(l)\n    table.sort(l)\n    for i = 1, #l - 2 do\n        local a = l[i]\n        local left = i + 1\n        local right = #l\n        while left < right do\n            local b = l[left]\n            local c = l[right]\n            local sum = a + b + c\n            if sum == 0 then\n                return true\n            elseif sum < 0 then\n                left = left + 1\n            else\n                right = right - 1\n            end\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = triples_sum_to_zero\n    lu.assertEquals(candidate({1, 3, 5, 0}), false)\n    lu.assertEquals(candidate({1, 3, 5, -1}), false)\n    lu.assertEquals(candidate({1, 3, -2, 1}), true)\n    lu.assertEquals(candidate({1, 2, 3, 7}), false)\n    lu.assertEquals(candidate({1, 2, 5, 7}), false)\n    lu.assertEquals(candidate({2, 4, -5, 3, 9, 7}), true)\n    lu.assertEquals(candidate({1}), false)\n    lu.assertEquals(candidate({1, 3, 5, -100}), false)\n    lu.assertEquals(candidate({100, 3, 5, -100}), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_41","nl":"lmo_Latn","pl":"lua","prompt":"- Questa funziun la dà el numer de 'sti collisiù.- in la so trajetüra come se no i s'aversass.- Ma i vagon i è infinitament robus e forti; per quèst, i se cuntinua a spostàss.- quand 'na màchina che la và da mancià a drèta la s'ciàpa 'na màchina che la và da drèta a mancià.- tücc i car i se moven a la stesa velocità.- i và da drèta a sinistra. i dù séri d'auto i partèn da 'n pòch de distànsa da 'n pòch de distànsa.- n autòur i và da sinistra a drita; simultanément, un'altra serie de n autòur - Imagina na stràda che l'è na linia perfètamènt drèta e infinìtamènt longa.local function car_race_collision(n)\n","canonical_solution":"local function car_race_collision(n)\n    -- Since each car from the left to right collides with each car from the right to left,\n    -- the number of collisions will be n*n.\n    return n * n\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = car_race_collision\n    lu.assertEquals(candidate(2), 4)\n    lu.assertEquals(candidate(3), 9)\n    lu.assertEquals(candidate(4), 16)\n    lu.assertEquals(candidate(8), 64)\n    lu.assertEquals(candidate(10), 100)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_42","nl":"lmo_Latn","pl":"lua","prompt":"- Tabella di ritorno con elementi incrementati di 1.-- >>> incr_list({1, 2, 3})\n-- {2, 3, 4}\n-- >>> incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {6, 4, 6, 3, 4, 4, 10, 1, 124}\nlocal function incr_list(l)\n","canonical_solution":"local function incr_list(l)\n    local result = {}\n    for i = 1, #l do\n        result[i] = l[i] + 1\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = incr_list\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({3, 2, 1}), {4, 3, 2})\n    lu.assertEquals(candidate({5, 2, 5, 2, 3, 3, 9, 0, 123}), {6, 3, 6, 3, 4, 4, 10, 1, 124})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_43","nl":"lmo_Latn","pl":"lua","prompt":"- Summa a zero, e falsa altrimenti.- al torna true se gh'è du element distint in la tabela che - pairs_sum_to_zero al fà 'n tabèla di intèrn come input.-- >>> pairs_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> pairs_sum_to_zero({1, 3, -2, 1})\n-- false\n-- >>> pairs_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})\n-- true\n-- >>> pairs_sum_to_zero({1})\n-- false\nlocal function pairs_sum_to_zero(l)\n","canonical_solution":"local function pairs_sum_to_zero(l)\n    local seen = {}\n    for _, value in ipairs(l) do\n        if seen[-value] then\n            return true\n        end\n        seen[value] = true\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = pairs_sum_to_zero\n    lu.assertEquals(candidate({1, 3, 5, 0}), false)\n    lu.assertEquals(candidate({1, 3, -2, 1}), false)\n    lu.assertEquals(candidate({1, 2, 3, 7}), false)\n    lu.assertEquals(candidate({2, 4, -5, 3, 5, 7}), true)\n    lu.assertEquals(candidate({1}), false)\n    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 30}), true)\n    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 31}), true)\n    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 30}), false)\n    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 31}), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_44","nl":"lmo_Latn","pl":"lua","prompt":"- i numm de base hinn men de 10.- return string representation after the conversion.                  - Cambia la base numerica del numeral de input x a base.-- >>> change_base(8, 3)\n-- '22'\n-- >>> change_base(8, 2)\n-- '1000'\n-- >>> change_base(7, 2)\n-- '111'\nlocal function change_base(x, base)\n","canonical_solution":"local function change_base(x, base)\n    if base < 2 or base > 9 then\n        error(\"Base must be between 2 and 9\")\n    end\n\n    if x == 0 then\n        return \"0\"\n    end\n\n    local result = \"\"\n    while x > 0 do\n        local remainder = x % base\n        result = tostring(remainder) .. result\n        x = math.floor(x \/ base)\n    end\n\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = change_base\n    lu.assertEquals(candidate(8, 3), '22')\n    lu.assertEquals(candidate(9, 3), '100')\n    lu.assertEquals(candidate(234, 2), '11101010')\n    lu.assertEquals(candidate(16, 2), '10000')\n    lu.assertEquals(candidate(8, 2), '1000')\n    lu.assertEquals(candidate(7, 2), '111')\n    lu.assertEquals(candidate(2, 3), '2')\n    lu.assertEquals(candidate(3, 4), '3')\n    lu.assertEquals(candidate(4, 5), '4')\n    lu.assertEquals(candidate(5, 6), '5')\n    lu.assertEquals(candidate(6, 7), '6')\n    lu.assertEquals(candidate(7, 8), '7')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_45","nl":"lmo_Latn","pl":"lua","prompt":"- Data la lunghesa d'un fianch e l'area de ritorno alta per un triangol.-- >>> triangle_area(5, 3)\n-- 7.5\nlocal function triangle_area(a, h)\n","canonical_solution":"local function triangle_area(a, h)\n    return 0.5 * a * h\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = triangle_area\n    lu.assertEquals(candidate(5, 3), 7.5)\n    lu.assertEquals(candidate(2, 2), 2.0)\n    lu.assertEquals(candidate(10, 8), 40.0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_46","nl":"lmo_Latn","pl":"lua","prompt":"- Scriv una funziun per calculà in manera efetiva l'element n-es de la sequenza numerica fib4.- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).- fib4(3) -> 0 - fib4 ((2) -> 2 - fib4{}1) -> 0 - fib4 ((0) -> 0 - La sequenza numerica Fib4 l'è una sequenza simile a quella de Fibbonacci che l'è definida inscì: -- >>> fib4(5)\n-- 4\n-- >>> fib4(6)\n-- 8\n-- >>> fib4(7)\n-- 14\nlocal function fib4(n)\n","canonical_solution":"local function fib4(n)\n    if n == 0 then return 0 end\n    if n == 1 then return 0 end\n    if n == 2 then return 2 end\n    if n == 3 then return 0 end\n\n    local a, b, c, d = 0, 0, 2, 0\n\n    for i = 4, n do\n        local temp = a + b + c + d\n        a, b, c, d = b, c, d, temp\n    end\n\n    return d\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fib4\n    lu.assertEquals(candidate(5), 4)\n    lu.assertEquals(candidate(8), 28)\n    lu.assertEquals(candidate(10), 104)\n    lu.assertEquals(candidate(12), 386)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_47","nl":"lmo_Latn","pl":"lua","prompt":"- Ritorna mediana di elementi in tabella l. -- >>> median({3, 1, 2, 4, 5})\n-- 3\n-- >>> median({-10, 4, 6, 1000, 10, 20})\n-- 15.0\nlocal function median(l)\n","canonical_solution":"local function median(l)\n    table.sort(l)\n    local n = #l\n    if n % 2 == 1 then\n        return l[(n + 1) \/ 2]\n    else\n        local mid1 = n \/ 2\n        local mid2 = mid1 + 1\n        return (l[mid1] + l[mid2]) \/ 2\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = median\n    lu.assertEquals(candidate({3, 1, 2, 4, 5}), 3)\n    lu.assertEquals(candidate({-10, 4, 6, 1000, 10, 20}), 8.0)\n    lu.assertEquals(candidate({5}), 5)\n    lu.assertEquals(candidate({6, 5}), 5.5)\n    lu.assertEquals(candidate({8, 1, 3, 9, 9, 2, 7}), 7)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_48","nl":"lmo_Latn","pl":"lua","prompt":"- Controlla se la stringa data l'è un palindrom-- >>> is_palindrome('')\n-- true\n-- >>> is_palindrome('aba')\n-- true\n-- >>> is_palindrome('aaaaa')\n-- true\n-- >>> is_palindrome('zbcd')\n-- false\nlocal function is_palindrome(text)\n","canonical_solution":"local function is_palindrome(text)\n    return text == string.reverse(text)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_palindrome\n    lu.assertEquals(candidate(''), true)\n    lu.assertEquals(candidate('aba'), true)\n    lu.assertEquals(candidate('aaaaa'), true)\n    lu.assertEquals(candidate('zbcd'), false)\n    lu.assertEquals(candidate('xywyx'), true)\n    lu.assertEquals(candidate('xywyz'), false)\n    lu.assertEquals(candidate('xywzx'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_49","nl":"lmo_Latn","pl":"lua","prompt":"- Ritorna 2^n modulo p (sottoscriv i numer).-- >>> modp(3, 5)\n-- 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n-- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n","canonical_solution":"local function modp(n, p)\n    return (2^n) % p\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_51","nl":"lmo_Latn","pl":"lua","prompt":"- remove_vowels l'è 'na funziun che la ciappa la stringa e la restituiss stringa senza vocale. -- >>> remove_vowels('')\n-- ''\n-- >>> remove_vowels('abcdef')\n-- 'bcdf'\n-- >>> remove_vowels('aaaaa')\n-- ''\n-- >>> remove_vowels('aaBAA')\n-- 'B'\n-- >>> remove_vowels('zbcd')\n-- 'zbcd'\nlocal function remove_vowels(text)\n","canonical_solution":"local function remove_vowels(text)\n    return text:gsub(\"[aeiouAEIOU]\", \"\")\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = remove_vowels\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('abcdef\\nghijklm'), 'bcdf\\nghjklm')\n    lu.assertEquals(candidate('fedcba'), 'fdcb')\n    lu.assertEquals(candidate('eeeee'), '')\n    lu.assertEquals(candidate('acBAA'), 'cB')\n    lu.assertEquals(candidate('EcBOO'), 'cB')\n    lu.assertEquals(candidate('ybcd'), 'ybcd')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_52","nl":"lmo_Latn","pl":"lua","prompt":"- Render true se tutti i numeri in la tabella l sono al di sotto del valore t.-- >>> below_threshold({1, 2, 4, 10}, 100)\n-- true\n-- >>> below_threshold({1, 20, 4, 10}, 5)\n-- false\nlocal function below_threshold(l, t)\n","canonical_solution":"local function below_threshold(l, t)\n    for _, number in ipairs(l) do\n        if number >= t then\n            return false\n        end\n    end\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = below_threshold\n    lu.assertEquals(candidate({1, 2, 4, 10}, 100), true)\n    lu.assertEquals(candidate({1, 20, 4, 10}, 5), false)\n    lu.assertEquals(candidate({1, 20, 4, 10}, 21), true)\n    lu.assertEquals(candidate({1, 20, 4, 10}, 22), true)\n    lu.assertEquals(candidate({1, 8, 4, 10}, 11), true)\n    lu.assertEquals(candidate({1, 8, 4, 10}, 10), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_53","nl":"lmo_Latn","pl":"lua","prompt":"- S'a-scriv dü numar x e y.-- >>> add(2, 3)\n-- 5\n-- >>> add(5, 7)\n-- 12\nlocal function add(x, y)\n","canonical_solution":"local function add(x, y)\n    return x + y\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = add\n    lu.assertEquals(candidate(0, 1), 1)\n    lu.assertEquals(candidate(1, 0), 1)\n    lu.assertEquals(candidate(2, 3), 5)\n    lu.assertEquals(candidate(5, 7), 12)\n    lu.assertEquals(candidate(7, 5), 12)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_54","nl":"lmo_Latn","pl":"lua","prompt":"- Verifich se dü parol i gh'hann i stess personagg.-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n-- true\n-- >>> same_chars('abcd', 'dddddddabc')\n-- true\n-- >>> same_chars('dddddddabc', 'abcd')\n-- true\n-- >>> same_chars('eabcd', 'dddddddabc')\n-- false\n-- >>> same_chars('abcd', 'dddddddabce')\n-- false\n-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n-- false\nlocal function same_chars(s0, s1)\n","canonical_solution":"local function same_chars(s0, s1)\n    local function char_set(str)\n        local set = {}\n        for c in str:gmatch(\".\") do\n            set[c] = true\n        end\n        return set\n    end\n\n    local set0 = char_set(s0)\n    local set1 = char_set(s1)\n\n    for c in pairs(set0) do\n        if not set1[c] then\n            return false\n        end\n    end\n\n    for c in pairs(set1) do\n        if not set0[c] then\n            return false\n        end\n    end\n\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = same_chars\n    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), true)\n    lu.assertEquals(candidate('abcd', 'dddddddabc'), true)\n    lu.assertEquals(candidate('dddddddabc', 'abcd'), true)\n    lu.assertEquals(candidate('eabcd', 'dddddddabc'), false)\n    lu.assertEquals(candidate('abcd', 'dddddddabcf'), false)\n    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), false)\n    lu.assertEquals(candidate('aabb', 'aaccc'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_55","nl":"lmo_Latn","pl":"lua","prompt":"- Render n-th Fibonacci Number.-- >>> fib(10)\n-- 55\n-- >>> fib(1)\n-- 1\n-- >>> fib(8)\n-- 21\nlocal function fib(n)\n","canonical_solution":"local function fib(n)\n    if n <= 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n    else\n        local a, b = 0, 1\n        for i = 2, n do\n            a, b = b, a + b\n        end\n        return b\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fib\n    lu.assertEquals(candidate(10), 55)\n    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(8), 21)\n    lu.assertEquals(candidate(11), 89)\n    lu.assertEquals(candidate(12), 144)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_56","nl":"lmo_Latn","pl":"lua","prompt":"- return true if each opening bracket has a corresponding closing bracket.                                                                 - i parentesi i è na stringa de \"<\" e \">\". -- >>> correct_bracketing('<')\n-- false\n-- >>> correct_bracketing('<>')\n-- true\n-- >>> correct_bracketing('<<><>>')\n-- true\n-- >>> correct_bracketing('><<>')\n-- false\nlocal function correct_bracketing(brackets)\n","canonical_solution":"local function correct_bracketing(brackets)\n    local balance = 0\n    \n    for i = 1, #brackets do\n        local char = brackets:sub(i, i)\n        if char == '<' then\n            balance = balance + 1\n        elseif char == '>' then\n            balance = balance - 1\n        end\n        \n        if balance < 0 then\n            return false\n        end\n    end\n    \n    return balance == 0\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = correct_bracketing\n    lu.assertEquals(candidate('<>'), true)\n    lu.assertEquals(candidate('<<><>>'), true)\n    lu.assertEquals(candidate('<><><<><>><>'), true)\n    lu.assertEquals(candidate('<><><<<><><>><>><<><><<>>>'), true)\n    lu.assertEquals(candidate('<<<><>>>>'), false)\n    lu.assertEquals(candidate('><<>'), false)\n    lu.assertEquals(candidate('<'), false)\n    lu.assertEquals(candidate('<<<<'), false)\n    lu.assertEquals(candidate('>'), false)\n    lu.assertEquals(candidate('<<>'), false)\n    lu.assertEquals(candidate('<><><<><>><>><<>'), false)\n    lu.assertEquals(candidate('<><><<><>><>>><>'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_57","nl":"lmo_Latn","pl":"lua","prompt":"- Return true is table elements are monotonically increasing or decreasing.                                                                                                                  -- >>> monotonic({1, 2, 4, 20})\n-- true\n-- >>> monotonic({1, 20, 4, 10})\n-- false\n-- >>> monotonic({4, 1, 0, -10})\n-- true\nlocal function monotonic(l)\n","canonical_solution":"local function monotonic(l)\n    if #l < 2 then\n        return true\n    end\n\n    local increasing = true\n    local decreasing = true\n\n    for i = 2, #l do\n        if l[i] > l[i - 1] then\n            decreasing = false\n        elseif l[i] < l[i - 1] then\n            increasing = false\n        end\n    end\n\n    return increasing or decreasing\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = monotonic\n    lu.assertEquals(candidate({1, 2, 4, 10}), true)\n    lu.assertEquals(candidate({1, 2, 4, 20}), true)\n    lu.assertEquals(candidate({1, 20, 4, 10}), false)\n    lu.assertEquals(candidate({4, 1, 0, -10}), true)\n    lu.assertEquals(candidate({4, 1, 1, 0}), true)\n    lu.assertEquals(candidate({1, 2, 3, 2, 5, 60}), false)\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 60}), true)\n    lu.assertEquals(candidate({9, 9, 9, 9}), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_58","nl":"lmo_Latn","pl":"lua","prompt":"- Ritorna elemënc uniches comuns ordinè per do tables.-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})\n-- {1, 5, 653}\n-- >>> common({5, 3, 2, 8}, {3, 2})\n-- {2, 3}\nlocal function common(l1, l2)\n","canonical_solution":"local function common(l1, l2)\n    local set1 = {}\n    local set2 = {}\n    local result = {}\n\n    -- Create a set for the first list\n    for _, value in ipairs(l1) do\n        set1[value] = true\n    end\n\n    -- Create a set for the second list, noting only common elements\n    for _, value in ipairs(l2) do\n        if set1[value] then\n            set2[value] = true\n        end\n    end\n\n    -- Collect the keys from the set into a results table\n    for key in pairs(set2) do\n        table.insert(result, key)\n    end\n\n    -- Sort the results table\n    table.sort(result)\n\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = common\n    lu.assertEquals(candidate({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}), {1, 5, 653})\n    lu.assertEquals(candidate({5, 3, 2, 8}, {3, 2}), {2, 3})\n    lu.assertEquals(candidate({4, 3, 2, 8}, {3, 2, 4}), {2, 3, 4})\n    lu.assertEquals(candidate({4, 3, 2, 8}, {}), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_59","nl":"lmo_Latn","pl":"lua","prompt":"- Render el più grand fattur prim de n. Assumì che n > 1 e l'è minga un prim. -- >>> largest_prime_factor(13195)\n-- 29\n-- >>> largest_prime_factor(2048)\n-- 2\nlocal function largest_prime_factor(n)\n","canonical_solution":"local function largest_prime_factor(n)\n    local factor = 2\n    while n > 1 do\n        if n % factor == 0 then\n            n = n \/ factor\n        else\n            factor = factor + 1\n        end\n    end\n    return factor\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_prime_factor\n    lu.assertEquals(candidate(15), 5)\n    lu.assertEquals(candidate(27), 3)\n    lu.assertEquals(candidate(63), 7)\n    lu.assertEquals(candidate(330), 11)\n    lu.assertEquals(candidate(13195), 29)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_60","nl":"lmo_Latn","pl":"lua","prompt":"- sum_to_n l'è 'na funziun che la soma i nümar da 1 a n. -- >>> sum_to_n(30)\n-- 465\n-- >>> sum_to_n(100)\n-- 5050\n-- >>> sum_to_n(5)\n-- 15\n-- >>> sum_to_n(10)\n-- 55\n-- >>> sum_to_n(1)\n-- 1\nlocal function sum_to_n(n)\n","canonical_solution":"local function sum_to_n(n)\n    return n * (n + 1) \/\/ 2\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_to_n\n    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(6), 21)\n    lu.assertEquals(candidate(11), 66)\n    lu.assertEquals(candidate(30), 465)\n    lu.assertEquals(candidate(100), 5050)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_61","nl":"lmo_Latn","pl":"lua","prompt":"- return true if each opening bracket has a corresponding closing bracket.                                                                 - i parentesi i è na stringa de \"(\" e \")\". -- >>> correct_bracketing('(')\n-- false\n-- >>> correct_bracketing('()')\n-- true\n-- >>> correct_bracketing('(()())')\n-- true\n-- >>> correct_bracketing(')(()')\n-- false\nlocal function correct_bracketing(brackets)\n","canonical_solution":"local function correct_bracketing(brackets)\n    local balance = 0\n    for i = 1, #brackets do\n        local char = brackets:sub(i, i)\n        if char == \"(\" then\n            balance = balance + 1\n        elseif char == \")\" then\n            balance = balance - 1\n        end\n        if balance < 0 then\n            return false\n        end\n    end\n    return balance == 0\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = correct_bracketing\n    lu.assertEquals(candidate('()'), true)\n    lu.assertEquals(candidate('(()())'), true)\n    lu.assertEquals(candidate('()()(()())()'), true)\n    lu.assertEquals(candidate('()()((()()())())(()()(()))'), true)\n    lu.assertEquals(candidate('((()())))'), false)\n    lu.assertEquals(candidate(')(()'), false)\n    lu.assertEquals(candidate('('), false)\n    lu.assertEquals(candidate('(((('), false)\n    lu.assertEquals(candidate(')'), false)\n    lu.assertEquals(candidate('(()'), false)\n    lu.assertEquals(candidate('()()(()())())(()'), false)\n    lu.assertEquals(candidate('()()(()())()))()'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_62","nl":"lmo_Latn","pl":"lua","prompt":"- Rend la derivada de 'sto polinomi in la stessa forma.- xs[0] + xs[1] * x + xs[2] * x^2 + .... - xs rapreśenta i coeficièncc d'un polinòmi.-- >>> derivative({3, 1, 2, 4, 5})\n-- {1, 4, 12, 20}\n-- >>> derivative({1, 2, 3})\n-- {2, 6}\nlocal function derivative(xs)\n","canonical_solution":"local function derivative(xs)\n    local result = {}\n    for i = 2, #xs do\n        result[i - 1] = xs[i] * (i - 1)\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = derivative\n    lu.assertEquals(candidate({3, 1, 2, 4, 5}), {1, 4, 12, 20})\n    lu.assertEquals(candidate({1, 2, 3}), {2, 6})\n    lu.assertEquals(candidate({3, 2, 1}), {2, 2})\n    lu.assertEquals(candidate({3, 2, 1, 0, 4}), {2, 2, 0, 16})\n    lu.assertEquals(candidate({1}), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_63","nl":"lmo_Latn","pl":"lua","prompt":"- Scriv una funziun per calculà in manera efetiva l'element n-es de la sequenza numerica fibfib. - fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3). - fib fib ((2) == 1 - fib fib ((1) == 0 - fib fib ((0) == 0 La sequenza numerica FibFib l'è una sequenza simile a la sequenza de Fibbonacci che l'è definida inscì:-- >>> fibfib(1)\n-- 0\n-- >>> fibfib(5)\n-- 4\n-- >>> fibfib(8)\n-- 24\nlocal function fibfib(n)\n","canonical_solution":"local function fibfib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 0\n    elseif n == 2 then\n        return 1\n    else\n        local a, b, c = 0, 0, 1\n        for i = 3, n do\n            local next_fibfib = a + b + c\n            a, b, c = b, c, next_fibfib\n        end\n        return c\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fibfib\n    lu.assertEquals(candidate(2), 1)\n    lu.assertEquals(candidate(1), 0)\n    lu.assertEquals(candidate(5), 4)\n    lu.assertEquals(candidate(8), 24)\n    lu.assertEquals(candidate(10), 81)\n    lu.assertEquals(candidate(12), 274)\n    lu.assertEquals(candidate(14), 927)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_64","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - vocale, ma domà quand l'è a la fin de la parolla.- Vocali in chèsto cazo i è \"a\", \"e\", \"i\", \"o\", \"u\". In chèsto cazo, \"y\" l'è anca \"a\"- una parola come input e restituisce il numero di vocali in la stringa.- Scriv una funziun vowels_count che la gh'ha ona stringa che la rappresenta -- >>> vowels_count('abcde')\n-- 2\n-- >>> vowels_count('ACEDY')\n-- 3\nlocal function vowels_count(s)\n","canonical_solution":"local function vowels_count(s)\n    local count = 0\n    local vowels = {a = true, e = true, i = true, o = true, u = true, \n                    A = true, E = true, I = true, O = true, U = true}\n                    \n    for i = 1, #s do\n        local char = s:sub(i, i)\n        if vowels[char] or (char == 'y' or char == 'Y') and i == #s then\n            count = count + 1\n        end\n    end\n    \n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = vowels_count\n    lu.assertEquals(candidate('abcde'), 2)\n    lu.assertEquals(candidate('Alone'), 3)\n    lu.assertEquals(candidate('key'), 2)\n    lu.assertEquals(candidate('bye'), 1)\n    lu.assertEquals(candidate('keY'), 2)\n    lu.assertEquals(candidate('bYe'), 1)\n    lu.assertEquals(candidate('ACEDY'), 3)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_65","nl":"lmo_Latn","pl":"lua","prompt":"- Se shift > numm de cifre, cifre de ritorno inverse.- e rend el risultà come una stringa.- Circular mudà i ciàfer de l'entèr x, mudà i ciàfer a destra per mudà -- >>> circular_shift(12, 1)\n-- '21'\n-- >>> circular_shift(12, 2)\n-- '12'\nlocal function circular_shift(x, shift)\n","canonical_solution":"local function circular_shift(x, shift)\n    local num_str = tostring(x)\n    local num_digits = #num_str\n    if shift > num_digits then\n        return num_str:reverse()\n    else\n        local shift_pos = num_digits - (shift % num_digits)\n        return num_str:sub(shift_pos + 1) .. num_str:sub(1, shift_pos)\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = circular_shift\n    lu.assertEquals(candidate(100, 2), '001')\n    lu.assertEquals(candidate(12, 2), '12')\n    lu.assertEquals(candidate(97, 8), '79')\n    lu.assertEquals(candidate(12, 1), '21')\n    lu.assertEquals(candidate(11, 101), '11')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_66","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - ASCII codes. - Scriv una funziun che la piglia una stringa come input e la restituiss la soma dei caràter superiur domà' - Tasca -- >>> digitSum('')\n-- 0\n-- >>> digitSum('abAB')\n-- 131\n-- >>> digitSum('abcCd')\n-- 67\n-- >>> digitSum('helloE')\n-- 69\n-- >>> digitSum('woArBld')\n-- 131\n-- >>> digitSum('aAaaaXa')\n-- 153\nlocal function digitSum(s)\n","canonical_solution":"local function digitSum(s)\n    local sum = 0\n    for i = 1, #s do\n        local char = s:sub(i, i)\n        if char:match(\"%u\") then\n            sum = sum + string.byte(char)\n        end\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = digitSum\n    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('abAB'), 131)\n    lu.assertEquals(candidate('abcCd'), 67)\n    lu.assertEquals(candidate('helloE'), 69)\n    lu.assertEquals(candidate('woArBld'), 131)\n    lu.assertEquals(candidate('aAaaaXa'), 153)\n    lu.assertEquals(candidate(' How are yOu?'), 151)\n    lu.assertEquals(candidate('You arE Very Smart'), 327)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_67","nl":"lmo_Latn","pl":"lua","prompt":"- per l'esamble: - in the basket return the number of mango fruits in the basket.  - le arance e le mele e n numer intèr che rapresenta l numer total di früt - mele, arance e mango. data la stringa che rappresenta el numeral total de - che i è distribuìcc in d'un càsch de früt che 'l càsch el cuntègn- In questa missione, ti sarà dà una stringa che rappresenta un numm de mele e arance.-- >>> fruit_distribution('5 apples and 6 oranges', 19)\n-- 8\n-- >>> fruit_distribution('0 apples and 1 oranges', 3)\n-- 2\n-- >>> fruit_distribution('2 apples and 3 oranges', 100)\n-- 95\n-- >>> fruit_distribution('100 apples and 1 oranges', 120)\n-- 19\nlocal function fruit_distribution(s, n)\n","canonical_solution":"local function fruit_distribution(s, n)\n    local apples, oranges = s:match(\"(%d+)%s*apples%s*and%s*(%d+)%s*oranges\")\n    apples = tonumber(apples)\n    oranges = tonumber(oranges)\n    local mangoes = n - (apples + oranges)\n    return mangoes\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fruit_distribution\n    lu.assertEquals(candidate('5 apples and 6 oranges', 19), 8)\n    lu.assertEquals(candidate('5 apples and 6 oranges', 21), 10)\n    lu.assertEquals(candidate('0 apples and 1 oranges', 3), 2)\n    lu.assertEquals(candidate('1 apples and 0 oranges', 3), 2)\n    lu.assertEquals(candidate('2 apples and 3 oranges', 100), 95)\n    lu.assertEquals(candidate('2 apples and 3 oranges', 5), 0)\n    lu.assertEquals(candidate('1 apples and 100 oranges', 120), 19)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_68","nl":"lmo_Latn","pl":"lua","prompt":"- Esempio 1: - Se no gh'è valuri pari o la tabela data l'è vuda, torna [].- L'acuch de nodu el va restituì in una tabela, [smallest_value, el sò indice], - Se i noeud a hinn di piö picin con l'istess valur pari, torna el noeud che gh'ha l'indice piö picin.- L'acuch de la s'è dovuu fà el noeud con el valor pari piö picin.- al tò compit l'è de strapà un di nód e de rendérla.- \"Dada una tabela che la rappresenta on ram de on arbol che el gh'ha noeud de intere no-negativ -- >>> pluck({4, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 2:\n-- >>> pluck({1, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 3:\n-- >>> pluck({})\n-- {}\n-- Example 4:\n-- >>> pluck({5, 0, 3, 0, 4, 2})\n-- {0, 1}\n-- Explanation: 0 is the smallest value, but  there are two zeros,\n--              so we will choose the first zero, which has the smallest index.\n-- Constraints:\n--     * 1 <= nodes.length <= 10000\n--     * 0 <= node.value\nlocal function pluck(arr)\n","canonical_solution":"local function pluck(arr)\n    local smallest_even_value = nil\n    local smallest_index = nil\n\n    for index, value in ipairs(arr) do\n        if value % 2 == 0 then\n            if smallest_even_value == nil or value < smallest_even_value then\n                smallest_even_value = value\n                smallest_index = index\n            end\n        end\n    end\n\n    if smallest_even_value == nil then\n        return {}\n    else\n        return {smallest_even_value, smallest_index}\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = pluck\n    lu.assertEquals(candidate({4, 2, 3}), {2, 1})\n    lu.assertEquals(candidate({1, 2, 3}), {2, 1})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({5, 0, 3, 0, 4, 2}), {0, 1})\n    lu.assertEquals(candidate({1, 2, 3, 0, 5, 3}), {0, 3})\n    lu.assertEquals(candidate({5, 4, 8, 4, 8}), {4, 1})\n    lu.assertEquals(candidate({7, 6, 7, 1}), {6, 1})\n    lu.assertEquals(candidate({7, 9, 7, 1}), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_69","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - If no such a value exists, return -1.                                                                                                                         - La frequenza de un nümer intèr l'è el nümer de vultà che 'l vegn in la tabela.- zero, e l'ha una frequenza püssee granda o uguale al valor del nümer intèrn propi.- Te gh'è una tabella de intreg pusitiv che l'è minga vuda.-- >>> search({4, 1, 2, 2, 3, 1})\n-- 2\n-- >>> search({1, 2, 2, 3, 3, 3, 4, 4, 4})\n-- 3\n-- >>> search({5, 5, 4, 4, 4})\n-- -1\nlocal function search(lst)\n","canonical_solution":"local function search(lst)\n    local frequency = {}\n    \n    -- Calculate the frequency of each number in the list\n    for _, num in ipairs(lst) do\n        frequency[num] = (frequency[num] or 0) + 1\n    end\n\n    local result = -1\n    \n    -- Determine the maximum valid integer with the criteria\n    for num, freq in pairs(frequency) do\n        if num > 0 and freq >= num and num > result then\n            result = num\n        end\n    end\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = search\n    lu.assertEquals(candidate({5, 5, 5, 5, 1}), 1)\n    lu.assertEquals(candidate({4, 1, 4, 1, 4, 4}), 4)\n    lu.assertEquals(candidate({3, 3}), -1)\n    lu.assertEquals(candidate({8, 8, 8, 8, 8, 8, 8, 8}), 8)\n    lu.assertEquals(candidate({2, 3, 3, 2, 2}), 2)\n    lu.assertEquals(candidate({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), 1)\n    lu.assertEquals(candidate({3, 2, 8, 2}), 2)\n    lu.assertEquals(candidate({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), 1)\n    lu.assertEquals(candidate({8, 8, 3, 6, 5, 6, 4}), -1)\n    lu.assertEquals(candidate({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), 1)\n    lu.assertEquals(candidate({1, 9, 10, 1, 3}), 1)\n    lu.assertEquals(candidate({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), 5)\n    lu.assertEquals(candidate({1}), 1)\n    lu.assertEquals(candidate({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), 4)\n    lu.assertEquals(candidate({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), 2)\n    lu.assertEquals(candidate({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), 1)\n    lu.assertEquals(candidate({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), 4)\n    lu.assertEquals(candidate({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), 4)\n    lu.assertEquals(candidate({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), 2)\n    lu.assertEquals(candidate({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), -1)\n    lu.assertEquals(candidate({10}), -1)\n    lu.assertEquals(candidate({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), 2)\n    lu.assertEquals(candidate({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), 1)\n    lu.assertEquals(candidate({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), 1)\n    lu.assertEquals(candidate({3, 10, 10, 9, 2}), -1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_70","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - al màssim di nùmer intèrn restànt, al mínim e via.- Strange sorting, l'è quand che te scumenci con el valor minimo, - Given table of integers, return table in odd order.-- >>> strange_sort_list({1, 2, 3, 4})\n-- {1, 4, 2, 3}\n-- >>> strange_sort_list({5, 5, 5, 5})\n-- {5, 5, 5, 5}\n-- >>> strange_sort_list({})\n-- {}\nlocal function strange_sort_list(lst)\n","canonical_solution":"local function strange_sort_list(lst)\n    table.sort(lst) -- Sort the list\n    local result = {}\n    local i, j = 1, #lst\n    \n    while i <= j do\n        table.insert(result, lst[i])\n        if i ~= j then\n            table.insert(result, lst[j])\n        end\n        i = i + 1\n        j = j - 1\n    end\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = strange_sort_list\n    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})\n    lu.assertEquals(candidate({5, 6, 7, 8, 9}), {5, 9, 6, 8, 7})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}), {1, 5, 2, 4, 3})\n    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5, 8, 6, 7})\n    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3, 6, 4, 5})\n    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5, -5, 5, 0, 2, 2, 2})\n    lu.assertEquals(candidate({111111}), {111111})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_71","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - che la terza part.- Trè lader i fà un triàngol validu quand la soma di du lader l'è püssee granda.- Altrimenti torna - 1 - el triangol arrotondà a 2 punti decimaj se i trii lati i forma on triangol valid. - Dàt i lunghi dei trè lati d'un triàngol, fà l'area de -- >>> triangle_area(3, 4, 5)\n-- 6.0\n-- >>> triangle_area(1, 2, 10)\n-- -1\nlocal function triangle_area(a, b, c)\n","canonical_solution":"local function triangle_area(a, b, c)\n    -- Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a then\n        -- Calculate the semi-perimeter\n        local s = (a + b + c) \/ 2\n        -- Calculate the area using Heron's formula\n        local area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        -- Return the area rounded to 2 decimal points\n        return math.floor(area * 100 + 0.5) \/ 100\n    else\n        -- Return -1 if not a valid triangle\n        return -1\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = triangle_area\n    lu.assertEquals(candidate(3, 4, 5), 6.0)\n    lu.assertEquals(candidate(1, 2, 10), -1)\n    lu.assertEquals(candidate(4, 8, 5), 8.18)\n    lu.assertEquals(candidate(2, 2, 2), 1.73)\n    lu.assertEquals(candidate(1, 2, 3), -1)\n    lu.assertEquals(candidate(10, 5, 7), 16.25)\n    lu.assertEquals(candidate(2, 6, 3), -1)\n    lu.assertEquals(candidate(1, 1, 1), 0.43)\n    lu.assertEquals(candidate(2, 2, 10), -1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_72","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - L'oget q volarà se l'è bilancià (l'è una tàula palindroma) e la soma di sò element l'è men de o uguale al mass mass massìm pusìbil w.- Scriv una funziun che la restituiss vera se l'ogett q el voeur voeuj, e falsa altrimenti.-- >>> will_it_fly({1, 2}, 5)\n-- false\n-- # 1+2 is less than the maximum possible weight, but it's unbalanced.\n-- >>> will_it_fly({3, 2, 3}, 1)\n-- false\n-- # it's balanced, but 3+2+3 is more than the maximum possible weight.\n-- >>> will_it_fly({3, 2, 3}, 9)\n-- true\n-- # 3+2+3 is less than the maximum possible weight, and it's balanced.\n-- >>> will_it_fly({3}, 5)\n-- true\n-- # 3 is less than the maximum possible weight, and it's balanced.\nlocal function will_it_fly(q, w)\n","canonical_solution":"local function will_it_fly(q, w)\n    local function is_palindrome(tbl)\n        local len = #tbl\n        for i = 1, math.floor(len \/ 2) do\n            if tbl[i] ~= tbl[len - i + 1] then\n                return false\n            end\n        end\n        return true\n    end\n\n    local function sum_elements(tbl)\n        local sum = 0\n        for _, value in ipairs(tbl) do\n            sum = sum + value\n        end\n        return sum\n    end\n\n    if not is_palindrome(q) then\n        return false\n    end\n\n    local total_weight = sum_elements(q)\n    return total_weight <= w\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = will_it_fly\n    lu.assertEquals(candidate({3, 2, 3}, 9), true)\n    lu.assertEquals(candidate({1, 2}, 5), false)\n    lu.assertEquals(candidate({3}, 5), true)\n    lu.assertEquals(candidate({3, 2, 3}, 1), false)\n    lu.assertEquals(candidate({1, 2, 3}, 6), false)\n    lu.assertEquals(candidate({5}, 5), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_73","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - l'è lee istess in avanti e in indree.In d'on cambiament, te pudet cambià on element a on alter element.- l'è necessari cambià per fà la tabela palindroma.- Given a table arr of integers, find the minimum number of elements that                                                                                             -- >>> smallest_change({1, 2, 3, 5, 4, 7, 9, 6})\n-- 4\n-- >>> smallest_change({1, 2, 3, 4, 3, 2, 2})\n-- 1\n-- >>> smallest_change({1, 2, 3, 2, 1})\n-- 0\nlocal function smallest_change(arr)\n","canonical_solution":"local function smallest_change(arr)\n    local n = #arr\n    local changes = 0\n    \n    for i = 1, math.floor(n \/ 2) do\n        if arr[i] ~= arr[n - i + 1] then\n            changes = changes + 1\n        end\n    end\n    \n    return changes\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = smallest_change\n    lu.assertEquals(candidate({1, 2, 3, 5, 4, 7, 9, 6}), 4)\n    lu.assertEquals(candidate({1, 2, 3, 4, 3, 2, 2}), 1)\n    lu.assertEquals(candidate({1, 4, 2}), 1)\n    lu.assertEquals(candidate({1, 4, 4, 2}), 1)\n    lu.assertEquals(candidate({1, 2, 3, 2, 1}), 0)\n    lu.assertEquals(candidate({3, 1, 1, 3}), 0)\n    lu.assertEquals(candidate({1}), 0)\n    lu.assertEquals(candidate({0, 1}), 1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_74","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi - se i duu tabell gh'hann el stess numm de car, rend la prima tabella.- n° de caros in tüt i strin de la tabela l'è men de quell de l'altra tabela.- Scriv una funziun che accetta du tabelle de string e la restituiss la tabella che la gh'ha -- >>> total_match({}, {})\n-- {}\n-- >>> total_match({'hi', 'admin'}, {'hI', 'Hi'})\n-- {'hI', 'Hi'}\n-- >>> total_match({'hi', 'admin'}, {'hi', 'hi', 'admin', 'project'})\n-- {'hi', 'admin'}\n-- >>> total_match({'hi', 'admin'}, {'hI', 'hi', 'hi'})\n-- {'hI', 'hi', 'hi'}\n-- >>> total_match({'4'}, {'1', '2', '3', '4', '5'})\n-- {'4'}\nlocal function total_match(lst1, lst2)\n","canonical_solution":"local function total_match(lst1, lst2)\n    local function total_chars(lst)\n        local count = 0\n        for _, str in ipairs(lst) do\n            count = count + #str\n        end\n        return count\n    end\n\n    local chars_lst1 = total_chars(lst1)\n    local chars_lst2 = total_chars(lst2)\n\n    if chars_lst1 < chars_lst2 then\n        return lst1\n    elseif chars_lst2 < chars_lst1 then\n        return lst2\n    else\n        return lst1\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = total_match\n    lu.assertEquals(candidate({}, {}), {})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hi', 'hi'}), {'hi', 'hi'})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hi', 'hi', 'admin', 'project'}), {'hi', 'admin'})\n    lu.assertEquals(candidate({'4'}, {'1', '2', '3', '4', '5'}), {'4'})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hI', 'Hi'}), {'hI', 'Hi'})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hI', 'hi', 'hi'}), {'hI', 'hi', 'hi'})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hI', 'hi', 'hii'}), {'hi', 'admin'})\n    lu.assertEquals(candidate({}, {'this'}), {})\n    lu.assertEquals(candidate({'this'}, {}), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_75","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Sapend che (a) l'è men de 100.- e fals se no.- Scriv una funziun che la restituiss vera se el numer dat l'è la moltiplicazion de 3 numer prim -- >>> is_multiply_prime(30)\n-- true\n-- 30 = 2 * 3 * 5\nlocal function is_multiply_prime(a)\n","canonical_solution":"local function is_prime(n)\n    if n <= 1 then return false end\n    if n <= 3 then return true end\n    if n % 2 == 0 or n % 3 == 0 then return false end\n    local i = 5\n    while (i * i) <= n do\n        if n % i == 0 or n % (i + 2) == 0 then\n            return false\n        end\n        i = i + 6\n    end\n    return true\nend\n\nlocal function generate_primes(limit)\n    local primes = {}\n    for i = 2, limit do\n        if is_prime(i) then\n            table.insert(primes, i)\n        end\n    end\n    return primes\nend\n\nlocal function is_multiply_prime(a)\n    local primes = generate_primes(100)\n    local count = #primes\n    for i = 1, count do\n        for j = i + 1, count do\n            for k = j + 1, count do\n                if primes[i] * primes[j] * primes[k] == a then\n                    return true\n                end\n            end\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_multiply_prime\n    lu.assertEquals(candidate(5), false)\n    lu.assertEquals(candidate(30), true)\n    lu.assertEquals(candidate(8), true)\n    lu.assertEquals(candidate(10), false)\n    lu.assertEquals(candidate(125), true)\n    lu.assertEquals(candidate(105), true)\n    lu.assertEquals(candidate(126), false)\n    lu.assertEquals(candidate(729), false)\n    lu.assertEquals(candidate(891), false)\n    lu.assertEquals(candidate(1001), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_76","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - x l'è una potenza de n se n**int=x - potenza di n e false in altri casi.- La tò tarega l'è de scriv una funziun che la torna vera se un nümer x l'è un nümer simpü -- >>> is_simple_power(1, 4)\n-- true\n-- >>> is_simple_power(2, 2)\n-- true\n-- >>> is_simple_power(8, 2)\n-- true\n-- >>> is_simple_power(3, 2)\n-- false\n-- >>> is_simple_power(3, 1)\n-- false\n-- >>> is_simple_power(5, 3)\n-- false\nlocal function is_simple_power(x, n)\n","canonical_solution":"local function is_simple_power(x, n)\n    if x == 1 then\n        return true\n    end\n    if n <= 0 or x <= 0 then\n        return false\n    end\n    local current_power = 1\n    while current_power < x do\n        current_power = current_power * n\n    end\n    return current_power == x\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_simple_power\n    lu.assertEquals(candidate(16, 2), true)\n    lu.assertEquals(candidate(143214, 16), false)\n    lu.assertEquals(candidate(4, 2), true)\n    lu.assertEquals(candidate(9, 3), true)\n    lu.assertEquals(candidate(16, 4), true)\n    lu.assertEquals(candidate(24, 2), false)\n    lu.assertEquals(candidate(128, 4), false)\n    lu.assertEquals(candidate(12, 6), false)\n    lu.assertEquals(candidate(1, 1), true)\n    lu.assertEquals(candidate(1, 12), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_77","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Nota: te pöl assumì che l'input l'è semper valid.- se 'sto ingeger l'è 'n cubo de 'n quaj numm inter.- Scriv una funziun che la piglia un intèr a e la torna true-- >>> iscube(1)\n-- true\n-- >>> iscube(2)\n-- false\n-- >>> iscube(-1)\n-- true\n-- >>> iscube(64)\n-- true\n-- >>> iscube(0)\n-- true\n-- >>> iscube(180)\n-- false\nlocal function iscube(a)\n","canonical_solution":"local function iscube(a)\n    if a < 0 then\n        a = -a\n    end\n    local cbrt = math.floor(a ^ (1\/3) + 0.5)\n    return cbrt * cbrt * cbrt == a\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = iscube\n    lu.assertEquals(candidate(1), true)\n    lu.assertEquals(candidate(2), false)\n    lu.assertEquals(candidate(-1), true)\n    lu.assertEquals(candidate(64), true)\n    lu.assertEquals(candidate(180), false)\n    lu.assertEquals(candidate(1000), true)\n    lu.assertEquals(candidate(0), true)\n    lu.assertEquals(candidate(1729), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_78","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - e i simbul A,B,C,D,E,F hinn semper in maiuscul.- Nota: te pöl assumì che l'input l'è semper giust o stringa vuda,- B (= decimal 11), D (= decimal 13). - Alura al gh'à da determinà un nùmer di segónd díg: 2, 3, 5, 7, - I nùmer prim i è 2, 3, 5, 7, 11, 13, 17...- I cifre esadecimale hinn 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.- piö grann de 1 che l'è minga 'l prodot de duu numer natural püssee piscinin).- i dígiti che i è prim (un nùmer prim, o un nùmer prim, l'è un nùmer naturèl)- un numeral esadecimale come stringa e conta el numeral de numeral esadecimale - Te gh'è staa dicc de scriv una funzion che la riceve-- >>> hex_key('AB')\n-- 1\n-- >>> hex_key('1077E')\n-- 2\n-- >>> hex_key('ABED1A33')\n-- 4\n-- >>> hex_key('123456789ABCDEF0')\n-- 6\n-- >>> hex_key('2020')\n-- 2\nlocal function hex_key(num)\n","canonical_solution":"local function hex_key(num)\n    local prime_digits = {['2'] = true, ['3'] = true, ['5'] = true, ['7'] = true, ['B'] = true, ['D'] = true}\n    local count = 0\n    for digit in num:gmatch('.') do\n        if prime_digits[digit] then\n            count = count + 1\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = hex_key\n    lu.assertEquals(candidate('AB'), 1)\n    lu.assertEquals(candidate('1077E'), 2)\n    lu.assertEquals(candidate('ABED1A33'), 4)\n    lu.assertEquals(candidate('2020'), 2)\n    lu.assertEquals(candidate('123456789ABCDEF0'), 6)\n    lu.assertEquals(candidate('112233445566778899AABBCCDDEEFF00'), 12)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_79","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - I carater extra i è lì per aiutà col format.- A gh'è un par de carater \"db\" in di piö in del principi e in de la fin de la stringa.Ogni caràter in la stringa sarà \"0\" o \"1\".- format binari. La funziun la dovariss rend una stringa, con ogni carater che la rapreentiss un binari - Te vegnarà dà un nümer in forma de decimal e el tò compit l'è de convertìl in -- >>> decimal_to_binary(15)\n-- 'db1111db'\n-- >>> decimal_to_binary(32)\n-- 'db100000db'\nlocal function decimal_to_binary(decimal)\n","canonical_solution":"local function decimal_to_binary(decimal)\n    -- Convert the decimal number to binary and remove the '0b' prefix using string.sub\n    local binary = string.sub(string.format(\"%b\", decimal), 0)\n    -- Concatenate 'db' at the start and end of the binary string\n    return 'db' .. binary .. 'db'\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = decimal_to_binary\n    lu.assertEquals(candidate(0), 'db0db')\n    lu.assertEquals(candidate(32), 'db100000db')\n    lu.assertEquals(candidate(103), 'db1100111db')\n    lu.assertEquals(candidate(15), 'db1111db')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_80","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - Una stringa l'è haplua se la sò longhesa l'è al men de 3 e ogni 3 letere consecutive l'è diferènte - La tò ròba l'è de verificà se la stringa l'è haplua o nò.- Te gh'è 'na stringa de s.-- >>> is_happy('a')\n-- false\n-- >>> is_happy('aa')\n-- false\n-- >>> is_happy('abcd')\n-- true\n-- >>> is_happy('aabb')\n-- false\n-- >>> is_happy('adb')\n-- true\n-- >>> is_happy('xyy')\n-- false\nlocal function is_happy(s)\n","canonical_solution":"local function is_happy(s)\n    -- Check if the string length is less than 3\n    if #s < 3 then\n        return false\n    end\n\n    -- Iterate through the string and check every 3 consecutive characters\n    for i = 1, #s - 2 do\n        local a, b, c = s:sub(i, i), s:sub(i + 1, i + 1), s:sub(i + 2, i + 2)\n        if a == b or b == c or a == c then\n            return false\n        end\n    end\n\n    -- If no 3 consecutive characters are the same, return true\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_happy\n    lu.assertEquals(candidate('a'), false)\n    lu.assertEquals(candidate('aa'), false)\n    lu.assertEquals(candidate('abcd'), true)\n    lu.assertEquals(candidate('aabb'), false)\n    lu.assertEquals(candidate('adb'), true)\n    lu.assertEquals(candidate('xyy'), false)\n    lu.assertEquals(candidate('iopaxpoi'), true)\n    lu.assertEquals(candidate('iopaxioi'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_81","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - 0.0 E - > 0.0 D- - > 0,7 D - > 1,0 D+ - > 1.3 C- - > 1,7 C - > 2.0 C+ - > 2.3 B- - > 2.7 B - > 3.0 B+ - > 3.3 A- - > 3,7 A - 4.0 A+ - GPA. Letter grade.- una funziun che la pò fà saltà una tabela di grad de letere doperaa la tabela chì: - Te l'ha dàa 'na tàula di GPA per quai student e te gh' hai de scrivì .- L'unic problema l'è che l'ha perdüü el codegh che l'ha druvaa per la valutazion.- a i studënc. La maestra à fat sü süa pròpria algoritma per la notaziun.- L'è l'ultima setimana del semestre e l'insegnant l'ha de dà i not.-- >>> grade_equation({4.0, 3, 1.7, 2, 3.5})\n-- {'A+', 'B', 'C-', 'C', 'A-'}\nlocal function numerical_letter_grade(grades)\n","canonical_solution":"local function numerical_letter_grade(grades)\n    local letter_grades = {}\n    for _, gpa in ipairs(grades) do\n        local letter\n        if gpa == 4.0 then\n            letter = \"A+\"\n        elseif gpa > 3.7 then\n            letter = \"A\"\n        elseif gpa > 3.3 then\n            letter = \"A-\"\n        elseif gpa > 3.0 then\n            letter = \"B+\"\n        elseif gpa > 2.7 then\n            letter = \"B\"\n        elseif gpa > 2.3 then\n            letter = \"B-\"\n        elseif gpa > 2.0 then\n            letter = \"C+\"\n        elseif gpa > 1.7 then\n            letter = \"C\"\n        elseif gpa > 1.3 then\n            letter = \"C-\"\n        elseif gpa > 1.0 then\n            letter = \"D+\"\n        elseif gpa > 0.7 then\n            letter = \"D\"\n        elseif gpa > 0.0 then\n            letter = \"D-\"\n        else\n            letter = \"E\"\n        end\n        table.insert(letter_grades, letter)\n    end\n    return letter_grades\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = numerical_letter_grade\n    lu.assertEquals(candidate({4.0, 3, 1.7, 2, 3.5}), {'A+', 'B', 'C-', 'C', 'A-'})\n    lu.assertEquals(candidate({1.2}), {'D+'})\n    lu.assertEquals(candidate({0.5}), {'D-'})\n    lu.assertEquals(candidate({0.0}), {'E'})\n    lu.assertEquals(candidate({1.0, 0.3, 1.5, 2.8, 3.3}), {'D', 'D-', 'C-', 'B', 'B+'})\n    lu.assertEquals(candidate({0.0, 0.7}), {'E', 'D-'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_82","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi - longhess a l'è un nümer prim o fals altrimenti - Scriv una funziun che la piglia una stringa e la torna vera se la stringa -- >>> prime_length('Hello')\n-- true\n-- >>> prime_length('abcdcba')\n-- true\n-- >>> prime_length('kittens')\n-- true\n-- >>> prime_length('orange')\n-- false\nlocal function prime_length(string)\n","canonical_solution":"local function is_prime(n)\n    if n <= 1 then return false end\n    if n <= 3 then return true end\n    if n % 2 == 0 or n % 3 == 0 then return false end\n    local i = 5\n    while i * i <= n do\n        if n % i == 0 or n % (i + 2) == 0 then return false end\n        i = i + 6\n    end\n    return true\nend\n\nlocal function prime_length(str)\n    local length = #str\n    return is_prime(length)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = prime_length\n    lu.assertEquals(candidate('Hello'), true)\n    lu.assertEquals(candidate('abcdcba'), true)\n    lu.assertEquals(candidate('kittens'), true)\n    lu.assertEquals(candidate('orange'), false)\n    lu.assertEquals(candidate('wow'), true)\n    lu.assertEquals(candidate('world'), true)\n    lu.assertEquals(candidate('MadaM'), true)\n    lu.assertEquals(candidate('Wow'), true)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('HI'), true)\n    lu.assertEquals(candidate('go'), true)\n    lu.assertEquals(candidate('gogo'), false)\n    lu.assertEquals(candidate('aaaaaaaaaaaaaaa'), false)\n    lu.assertEquals(candidate('Madam'), true)\n    lu.assertEquals(candidate('M'), false)\n    lu.assertEquals(candidate('0'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_83","nl":"lmo_Latn","pl":"lua","prompt":"- intèr positiv che scumència o finìs cun 1. - Dàt un nùmer intèrn pusìv n, riturnè al cuntadù di nùmer de n-ciàgra local function starts_one_ends(n)\n","canonical_solution":"local function starts_one_ends(n)\n    if n == 1 then\n        return 1 -- The single-digit numbers starting or ending with 1 is just 1 itself.\n    end\n    -- Calculate the count of n-digit numbers starting with 1 and ending with 1.\n    local count_start_with_1 = 10 ^ (n - 1) -- All numbers from 100... to 199...\n    local count_end_with_1 = 9 * (10 ^ (n - 1)) -- All numbers from 1, 11, 21,... excluding those starting with 1.\n    \n    -- A number starting and ending with 1 like 101 has been counted twice, correct for that.\n    return count_start_with_1 + count_end_with_1 - 10 ^ (n - 2)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = starts_one_ends\n    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(2), 18)\n    lu.assertEquals(candidate(3), 180)\n    lu.assertEquals(candidate(4), 1800)\n    lu.assertEquals(candidate(5), 18000)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_84","nl":"lmo_Latn","pl":"lua","prompt":"- Esempiu - Given a positive integer N, return the total sum of its digits in binary. -- >>> solve(1000)\n-- '1'\n-- >>> solve(150)\n-- '110'\n-- >>> solve(147)\n-- '1100'\n-- Variables:\n--     @N integer\n--          Constraints: 0 ≤ N ≤ 10000.\n-- Output:\n--      a string of binary number\nlocal function solve(N)\n","canonical_solution":"local function solve(N)\n    local sum = 0\n    while N > 0 do\n        sum = sum + (N % 10)\n        N = math.floor(N \/ 10)\n    end\n    return string.format(\"%b\", sum)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = solve\n    lu.assertEquals(candidate(1000), '1')\n    lu.assertEquals(candidate(150), '110')\n    lu.assertEquals(candidate(147), '1100')\n    lu.assertEquals(candidate(333), '1001')\n    lu.assertEquals(candidate(963), '10010')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_85","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Given a non-empty table of integers lst. add the even elements that are at odd indices.. -- >>> add({4, 2, 6, 7})\n-- 2\nlocal function add(lst)\n","canonical_solution":"local function add(lst)\n    local sum = 0\n    for i = 2, #lst, 2 do\n        if lst[i] % 2 == 0 then\n            sum = sum + lst[i]\n        end\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = add\n    lu.assertEquals(candidate({4, 88}), 88)\n    lu.assertEquals(candidate({4, 5, 6, 7, 2, 122}), 122)\n    lu.assertEquals(candidate({4, 0, 6, 7}), 0)\n    lu.assertEquals(candidate({4, 4, 6, 8}), 12)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_86","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - Nota: Te dovariss tegnì l'ordin de le paròle e i spazi in bianca in de la frase.- ordini ascendenti basati sul valore ASCII.- i è sostituìcc de na paròla növa indöe i caràter i è stacc in - Versiù ordinàda de stringa, l'è una stringa indova tüte le paròle (separàde de spazi)- Scriv una funziun che la piglia una stringa e la restituiss una version ordenaa de la stringa.-- >>> anti_shuffle('Hi')\n-- 'Hi'\n-- >>> anti_shuffle('hello')\n-- 'ehllo'\n-- >>> anti_shuffle('Hello World!!!')\n-- 'Hello !!!Wdlor'\nlocal function anti_shuffle(s)\n","canonical_solution":"local function anti_shuffle(s)\n    local function sort_word(word)\n        local chars = {}\n        for char in word:gmatch(\".\") do\n            table.insert(chars, char)\n        end\n        table.sort(chars)\n        return table.concat(chars)\n    end\n\n    return (s:gsub(\"%S+\", sort_word))\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = anti_shuffle\n    lu.assertEquals(candidate('Hi'), 'Hi')\n    lu.assertEquals(candidate('hello'), 'ehllo')\n    lu.assertEquals(candidate('number'), 'bemnru')\n    lu.assertEquals(candidate('abcd'), 'abcd')\n    lu.assertEquals(candidate('Hello World!!!'), 'Hello !!!Wdlor')\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_87","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Anca, ordinè i coordinà de la fila per colonne in ordine decrescent.- Sortì i coordinà in primma per righe in ordine ascendente.- ogni tabella l'è una coordinada - (riga, colonne), che la scomincia con 0.- e torna tabella di tabelle, [(x1, y1), (x2, y2) ...] cossì che - Dàt lst, e intèr x, tróa i intèr x in dla tàula, - ogni riga la pò avègh un numer diferent de colonne.- che l'è compagn de la matris, però, a differenza di matris,- Te gh'è dàa 'na data bidimensiunale, come 'na tabela anidada, -- >>> get_row({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}}, 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n","canonical_solution":"local function get_row(lst, x)\n    local coordinates = {}\n    for row_index, row in ipairs(lst) do\n        for col_index = #row, 1, -1 do\n            if row[col_index] == x then\n                table.insert(coordinates, {row_index - 1, col_index - 1})\n            end\n        end\n    end\n    table.sort(coordinates, function(a, b)\n        if a[1] == b[1] then\n            return a[2] > b[2]\n        else\n            return a[1] < b[1]\n        end\n    end)\n    return coordinates\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_88","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - * don't change the given table. - Nota: - o ordinàla in ordini discendenti se la soma ((primo valore indice, ultimo valore indice) l'è pari. - ti ti ordinarè la tabela data in ordini ascendent se la soma (il primm valor de l'indice, l'ultim valor de l'indice) l'è dispari,- Given a table of non-negative integers, return a colua of the given table after sorting, -- >>> sort_array({})\n-- {}\n-- >>> sort_array({5})\n-- {5}\n-- >>> sort_array({2, 4, 3, 0, 1, 5})\n-- {0, 1, 2, 3, 4, 5}\n-- >>> sort_array({2, 4, 3, 0, 1, 5, 6})\n-- {6, 5, 4, 3, 2, 1, 0}\nlocal function sort_array(array)\n","canonical_solution":"local function sort_array(array)\n    -- Create a copy of the given table\n    local sorted_array = {}\n    for i = 1, #array do\n        sorted_array[i] = array[i]\n    end\n\n    -- If the table is not empty\n    if #sorted_array > 0 then\n        local first = sorted_array[1]\n        local last = sorted_array[#sorted_array]\n        local sum = first + last\n        \n        -- Sort in ascending or descending order based on the sum\n        if sum % 2 == 0 then\n            table.sort(sorted_array, function(a, b) return a > b end)\n        else\n            table.sort(sorted_array, function(a, b) return a < b end)\n        end\n    end\n\n    return sorted_array\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_array\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({5}), {5})\n    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5}), {0, 1, 2, 3, 4, 5})\n    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5, 6}), {6, 5, 4, 3, 2, 1, 0})\n    lu.assertEquals(candidate({2, 1}), {1, 2})\n    lu.assertEquals(candidate({15, 42, 87, 32, 11, 0}), {0, 11, 15, 32, 42, 87})\n    lu.assertEquals(candidate({21, 14, 23, 11}), {23, 21, 14, 11})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_89","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - sposta giù per due moltiplicato per due posti.- L'alfabet al dovariss vesser girad in manera che i leter - rend una stringa crittografada con l'alfabet che l'è girad.- Creà 'na funsiù crittografàda che la piglia 'na strìnga come argumènt e -- >>> encrypt('hi')\n-- 'lm'\n-- >>> encrypt('asdfghjkl')\n-- 'ewhjklnop'\n-- >>> encrypt('gf')\n-- 'kj'\n-- >>> encrypt('et')\n-- 'ix'\nlocal function encrypt(s)\n","canonical_solution":"local function encrypt(s)\n    local result = {}\n    local shift = 2 * 2\n    for i = 1, #s do\n        local char = s:sub(i,i)\n        if char:match(\"%a\") then\n            local ascii_offset = char:match(\"%l\") and string.byte('a') or string.byte('A')\n            local new_char = string.char(((string.byte(char) - ascii_offset + shift) % 26) + ascii_offset)\n            table.insert(result, new_char)\n        else\n            table.insert(result, char)\n        end\n    end\n    return table.concat(result)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encrypt\n    lu.assertEquals(candidate('hi'), 'lm')\n    lu.assertEquals(candidate('asdfghjkl'), 'ewhjklnop')\n    lu.assertEquals(candidate('gf'), 'kj')\n    lu.assertEquals(candidate('et'), 'ix')\n    lu.assertEquals(candidate('faewfawefaewg'), 'jeiajeaijeiak')\n    lu.assertEquals(candidate('hellomyfriend'), 'lippsqcjvmirh')\n    lu.assertEquals(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')\n    lu.assertEquals(candidate('a'), 'e')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_90","nl":"lmo_Latn","pl":"lua","prompt":"- Return nil if there's no such element. - Scriv una funziun next_smallest (() che la restituiss el segond element püssee piscinin de la tabela. - Te gh'è una tabella di intreg.-- >>> next_smallest({1, 2, 3, 4, 5})\n-- 2\n-- >>> next_smallest({5, 1, 4, 3, 2})\n-- 2\n-- >>> next_smallest({})\n-- None\n-- >>> next_smallest({1, 1})\n-- None\nlocal function next_smallest(lst)\n","canonical_solution":"local function next_smallest(lst)\n    if #lst < 2 then\n        return nil\n    end\n\n    table.sort(lst)\n\n    local first = lst[1]\n    for i = 2, #lst do\n        if lst[i] > first then\n            return lst[i]\n        end\n    end\n\n    return nil\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = next_smallest\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)\n    lu.assertEquals(candidate({5, 1, 4, 3, 2}), 2)\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({1, 1}), None)\n    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)\n    lu.assertEquals(candidate({1, 1}), None)\n    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_91","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - La fras l'è delimitaa con \"\", \"?\" o \"!\"- de la noia. \"Na noia\" l'è na frasi che la scumìcia con la paròla \"I\".- Te vegnarà dà una sequenza de parolle, e el tò compit l'è de contà el numer.-- >>> is_bored('Hello world')\n-- 0\n-- >>> is_bored('The sky is blue. The sun is shining. I love this weather')\n-- 1\nlocal function is_bored(S)\n","canonical_solution":"local function is_bored(S)\n    local count = 0\n    -- Split the string into sentences using patterns\n    for sentence in S:gmatch(\"[^%.!?]+\") do\n        -- Trim leading whitespace from the sentence\n        sentence = sentence:gsub(\"^%s+\", \"\")\n        -- Check if the sentence starts with \"I\"\n        if sentence:sub(1, 1) == \"I\" then\n            count = count + 1\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_bored\n    lu.assertEquals(candidate('Hello world'), 0)\n    lu.assertEquals(candidate('Is the sky blue?'), 0)\n    lu.assertEquals(candidate('I love It !'), 1)\n    lu.assertEquals(candidate('bIt'), 0)\n    lu.assertEquals(candidate('I feel good today. I will be productive. will kill It'), 2)\n    lu.assertEquals(candidate('You and I are going for a walk'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_92","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi - Render false in any other cases. - Rende true se un di numer l'è ugua a la soma di alter duu, e tutt i numer hinn intger.- Creà na funsiun che à 3 numer.-- >>> any_int(5, 2, 7)\n-- true\n-- >>> any_int(3, 2, 2)\n-- false\n-- >>> any_int(3, -2, 1)\n-- true\n-- >>> any_int(3.6, -2.2, 2)\n-- false\nlocal function any_int(x, y, z)\n","canonical_solution":"local function any_int(x, y, z)\n    if math.floor(x) == x and math.floor(y) == y and math.floor(z) == z then\n        if x == y + z or y == x + z or z == x + y then\n            return true\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = any_int\n    lu.assertEquals(candidate(2, 3, 1), true)\n    lu.assertEquals(candidate(2.5, 2, 3), false)\n    lu.assertEquals(candidate(1.5, 5, 3.5), false)\n    lu.assertEquals(candidate(2, 6, 2), false)\n    lu.assertEquals(candidate(4, 2, 2), true)\n    lu.assertEquals(candidate(2.2, 2.2, 2.2), false)\n    lu.assertEquals(candidate(-4, 6, 2), true)\n    lu.assertEquals(candidate(2, 1, 1), true)\n    lu.assertEquals(candidate(3, 4, 7), true)\n    lu.assertEquals(candidate(3.0, 4, 7), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_93","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - S'a-i vëddo che a-i é mach letere.- Vocale in l'alfabet ingles.- al messagg con la lettera che la vegn 2 post prima de quella - manera che la cambia cas de tüte le lèttere, la sostituiss tüte le vocale in - Scriv una funziun che la piglia un messagg, e la la codifica in tal manera che-- >>> encode('test')\n-- 'TGST'\n-- >>> encode('This is a message')\n-- 'tHKS KS C MGSSCGG'\nlocal function encode(message)\n","canonical_solution":"local function encode(message)\n    local vowels = { a = 'c', e = 'g', i = 'k', o = 'q', u = 'w', A = 'C', E = 'G', I = 'K', O = 'Q', U = 'W' }\n    local encodedMessage = {}\n    \n    for i = 1, #message do\n        local char = message:sub(i, i)\n        \n        -- Swap case\n        if char:match('%l') then\n            char = char:upper()\n        else\n            char = char:lower()\n        end\n        \n        -- Replace vowels\n        if vowels[char] then\n            char = vowels[char]\n        end\n        \n        table.insert(encodedMessage, char)\n    end\n    \n    return table.concat(encodedMessage)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encode\n    lu.assertEquals(candidate('TEST'), 'tgst')\n    lu.assertEquals(candidate('Mudasir'), 'mWDCSKR')\n    lu.assertEquals(candidate('YES'), 'ygs')\n    lu.assertEquals(candidate('This is a message'), 'tHKS KS C MGSSCGG')\n    lu.assertEquals(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_94","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Te gh'è de trovà el valor prim piö gròss e de rend la soma di sò cifre.- Te gh'è una tabella di intreg.-- >>> skjkasdkd({0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n-- 10\n-- >>> skjkasdkd({1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n-- 25\n-- >>> skjkasdkd({1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n-- 13\n-- >>> skjkasdkd({0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n-- 11\n-- >>> skjkasdkd({0, 81, 12, 3, 1, 21})\n-- 3\n-- >>> skjkasdkd({0, 8, 1, 2, 1, 7})\n-- 7\nlocal function skjkasdkd(lst)\n","canonical_solution":"local function is_prime(n)\n    if n <= 1 then return false end\n    if n <= 3 then return true end\n    if n % 2 == 0 or n % 3 == 0 then return false end\n    for i = 5, math.sqrt(n), 6 do\n        if n % i == 0 or n % (i + 2) == 0 then return false end\n    end\n    return true\nend\n\nlocal function sum_of_digits(n)\n    local sum = 0\n    while n > 0 do\n        sum = sum + n % 10\n        n = math.floor(n \/ 10)\n    end\n    return sum\nend\n\nlocal function skjkasdkd(lst)\n    local largest_prime = -1\n    for _, v in ipairs(lst) do\n        if is_prime(v) and v > largest_prime then\n            largest_prime = v\n        end\n    end\n    if largest_prime == -1 then return 0 end\n    return sum_of_digits(largest_prime)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = skjkasdkd\n    lu.assertEquals(candidate({0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}), 10)\n    lu.assertEquals(candidate({1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), 25)\n    lu.assertEquals(candidate({1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), 13)\n    lu.assertEquals(candidate({0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), 11)\n    lu.assertEquals(candidate({0, 81, 12, 3, 1, 21}), 3)\n    lu.assertEquals(candidate({0, 8, 1, 2, 1, 7}), 7)\n    lu.assertEquals(candidate({8191}), 19)\n    lu.assertEquals(candidate({8191, 123456, 127, 7}), 19)\n    lu.assertEquals(candidate({127, 97, 8192}), 10)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_95","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - La funziun la dovariss rendì fals se la tabella data l'è vuda.- case or all keys are strings in upper case, else return false. - Given a table, return true if all keys are strings in lower -- >>> check_dict_case({['a'] = 'apple', ['b'] = 'banana'})\n-- true\n-- >>> check_dict_case({['a'] = 'apple', ['A'] = 'banana', ['B'] = 'banana'})\n-- false\n-- >>> check_dict_case({['a'] = 'apple', [8] = 'banana', ['a'] = 'apple'})\n-- false\n-- >>> check_dict_case({['Name'] = 'John', ['Age'] = '36', ['City'] = 'Houston'})\n-- false\n-- >>> check_dict_case({['STATE'] = 'NC', ['ZIP'] = '12345'})\n-- true\nlocal function check_dict_case(dict)\n","canonical_solution":"local function is_lowercase(s)\n    return s:lower() == s\nend\n\nlocal function is_uppercase(s)\n    return s:upper() == s\nend\n\nlocal function check_dict_case(dict)\n    if next(dict) == nil then\n        return false\n    end\n\n    local lower_case = nil\n    for key, _ in pairs(dict) do\n        if type(key) ~= 'string' then\n            return false\n        end\n        \n        if lower_case == nil then\n            lower_case = is_lowercase(key)\n        elseif lower_case ~= is_lowercase(key) then\n            return false\n        end\n    end\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = check_dict_case\n    lu.assertEquals(candidate({['p'] = 'pineapple', ['b'] = 'banana'}), true)\n    lu.assertEquals(candidate({['p'] = 'pineapple', ['A'] = 'banana', ['B'] = 'banana'}), false)\n    lu.assertEquals(candidate({['p'] = 'pineapple', ['5'] = 'banana', ['a'] = 'apple'}), false)\n    lu.assertEquals(candidate({['Name'] = 'John', ['Age'] = '36', ['City'] = 'Houston'}), false)\n    lu.assertEquals(candidate({['STATE'] = 'NC', ['ZIP'] = '12345'}), true)\n    lu.assertEquals(candidate({['fruit'] = 'Orange', ['taste'] = 'Sweet'}), true)\n    lu.assertEquals(candidate({}), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_96","nl":"lmo_Latn","pl":"lua","prompt":"- per esempi: - intèr che i è nùmer prim e minùr de n. - Implementè na funziun che piglia n intere no-negativ e la torna na tabela de la prima n -- >>> count_up_to(5)\n-- {2, 3}\n-- >>> count_up_to(11)\n-- {2, 3, 5, 7}\n-- >>> count_up_to(0)\n-- {}\n-- >>> count_up_to(20)\n-- {2, 3, 5, 7, 11, 13, 17, 19}\n-- >>> count_up_to(1)\n-- {}\n-- >>> count_up_to(18)\n-- {2, 3, 5, 7, 11, 13, 17}\nlocal function count_up_to(n)\n","canonical_solution":"local function is_prime(num)\n    if num <= 1 then return false end\n    if num <= 3 then return true end\n    if num % 2 == 0 or num % 3 == 0 then return false end\n    local i = 5\n    while i * i <= num do\n        if num % i == 0 or num % (i + 2) == 0 then return false end\n        i = i + 6\n    end\n    return true\nend\n\nlocal function count_up_to(n)\n    local primes = {}\n    for i = 2, n - 1 do\n        if is_prime(i) then\n            table.insert(primes, i)\n        end\n    end\n    return primes\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_up_to\n    lu.assertEquals(candidate(5), {2, 3})\n    lu.assertEquals(candidate(6), {2, 3, 5})\n    lu.assertEquals(candidate(7), {2, 3, 5})\n    lu.assertEquals(candidate(10), {2, 3, 5, 7})\n    lu.assertEquals(candidate(0), {})\n    lu.assertEquals(candidate(22), {2, 3, 5, 7, 11, 13, 17, 19})\n    lu.assertEquals(candidate(1), {})\n    lu.assertEquals(candidate(18), {2, 3, 5, 7, 11, 13, 17})\n    lu.assertEquals(candidate(47), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43})\n    lu.assertEquals(candidate(101), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_97","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Supponi che l'input l'è semper valid.- el prodot de i sò cifre unitari. - Completà la funzzion che la piglia du intreg e la torna -- >>> multiply(148, 412)\n-- 16\n-- >>> multiply(19, 28)\n-- 72\n-- >>> multiply(2020, 1851)\n-- 0\n-- >>> multiply(14, -15)\n-- 20\nlocal function multiply(a, b)\n","canonical_solution":"local function multiply(a, b)\n    local unitDigitA = math.abs(a) % 10\n    local unitDigitB = math.abs(b) % 10\n    return unitDigitA * unitDigitB\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = multiply\n    lu.assertEquals(candidate(148, 412), 16)\n    lu.assertEquals(candidate(19, 28), 72)\n    lu.assertEquals(candidate(2020, 1851), 0)\n    lu.assertEquals(candidate(14, -15), 20)\n    lu.assertEquals(candidate(76, 67), 42)\n    lu.assertEquals(candidate(17, 27), 49)\n    lu.assertEquals(candidate(0, 1), 0)\n    lu.assertEquals(candidate(0, 0), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_98","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - Dàt una stringa s, contà el nümer de vocale maiuscole in indici pari.-- >>> count_upper('aBCdEf')\n-- 1\n-- >>> count_upper('abcdefg')\n-- 0\n-- >>> count_upper('dBBE')\n-- 0\nlocal function count_upper(s)\n","canonical_solution":"local function count_upper(s)\n    local count = 0\n    local vowels = { A = true, E = true, I = true, O = true, U = true }\n    for i = 1, #s, 2 do\n        local char = s:sub(i, i)\n        if vowels[char] then\n            count = count + 1\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_upper\n    lu.assertEquals(candidate('aBCdEf'), 1)\n    lu.assertEquals(candidate('abcdefg'), 0)\n    lu.assertEquals(candidate('dBBE'), 0)\n    lu.assertEquals(candidate('B'), 0)\n    lu.assertEquals(candidate('U'), 1)\n    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('EEEE'), 2)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_99","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi - de duu intèrn, arrotondàa via da zero.- e torna l'intèr piö vicin a lü.- Creà una funziun che la piglia un valor (string) che la rappresenta un nümer -- >>> closest_integer('10')\n-- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n","canonical_solution":"local function closest_integer(value)\n    local number = tonumber(value)\n    if not number then\n        error(\"Invalid number\")\n    end\n    if number > 0 then\n        return math.floor(number + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_100","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - i rappresenta el numer de piere in del livel (i+1).- Rend el numer de piere in ogni livel in una tabela, indova l'element in l'indice - - al pròssim nùmer pari se n l'è pari.- - l'ùrtim nùmer dispàr se n l'è dispàr.- El nümer de piö de piö in del livel prosüm a l'è: - Al prim livel al gh'ha n pié.- Given a positive integer n, you have to make a pile of n levels of stones. -- >>> make_a_pile(3)\n-- {3, 5, 7}\nlocal function make_a_pile(n)\n","canonical_solution":"local function make_a_pile(n)\n    local pile = {}\n    local current_stones = n\n    for i = 1, n do\n        table.insert(pile, current_stones)\n        if n % 2 == 0 then\n            current_stones = current_stones + 2\n        else\n            current_stones = current_stones + 2\n        end\n    end\n    return pile\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_a_pile\n    lu.assertEquals(candidate(3), {3, 5, 7})\n    lu.assertEquals(candidate(4), {4, 6, 8, 10})\n    lu.assertEquals(candidate(5), {5, 7, 9, 11, 13})\n    lu.assertEquals(candidate(6), {6, 8, 10, 12, 14, 16})\n    lu.assertEquals(candidate(8), {8, 10, 12, 14, 16, 18, 20, 22})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_101","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - per divider la stringa in parolle e rendere una tabella di parole.- Te vegnarà dada una sequenza de paroll separada de virgola o de spazzi.-- >>> words_string('Hi, my name is John')\n-- {'Hi', 'my', 'name', 'is', 'John'}\n-- >>> words_string('One, two, three, four, five, six')\n-- {'One', 'two', 'three', 'four', 'five', 'six'}\nlocal function words_string(s)\n","canonical_solution":"local function words_string(s)\n    local words = {}\n    for word in s:gmatch(\"[^,%s]+\") do\n        table.insert(words, word)\n    end\n    return words\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = words_string\n    lu.assertEquals(candidate('Hi, my name is John'), {'Hi', 'my', 'name', 'is', 'John'})\n    lu.assertEquals(candidate('One, two, three, four, five, six'), {'One', 'two', 'three', 'four', 'five', 'six'})\n    lu.assertEquals(candidate('Hi, my name'), {'Hi', 'my', 'name'})\n    lu.assertEquals(candidate('One,, two, three, four, five, six,'), {'One', 'two', 'three', 'four', 'five', 'six'})\n    lu.assertEquals(candidate(''), {})\n    lu.assertEquals(candidate('ahmed     , gamal'), {'ahmed', 'gamal'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_102","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - no gh'è minga quell numer, alura la funziun la dovaria rend -1.- l'è el piö grand nümer intèrn pari che l'è in del interval [x, y] inclusif.- Chesta funziun la piglia duu numer pusitif x e y e la restituiss el -- >>> choose_num(12, 15)\n-- 14\n-- >>> choose_num(13, 12)\n-- -1\nlocal function choose_num(x, y)\n","canonical_solution":"local function choose_num(x, y)\n    -- Ensure x is the smaller and y is the larger\n    if x > y then\n        x, y = y, x\n    end\n    \n    -- Start from y and work backwards\n    for i = y, x, -1 do\n        if i % 2 == 0 then\n            return i\n        end\n    end\n    \n    -- If no even number is found\n    return -1\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = choose_num\n    lu.assertEquals(candidate(12, 15), 14)\n    lu.assertEquals(candidate(13, 12), -1)\n    lu.assertEquals(candidate(33, 12354), 12354)\n    lu.assertEquals(candidate(5234, 5233), -1)\n    lu.assertEquals(candidate(6, 29), 28)\n    lu.assertEquals(candidate(27, 10), -1)\n    lu.assertEquals(candidate(7, 7), -1)\n    lu.assertEquals(candidate(546, 546), 546)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_103","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Se n l'è piö gràn de m, torna -1.- Rondì la risposta al nùmer intèrn piö pròssim e cunvertìla in binàri.- media dei numeri interi da n a m (compresi n e m).- Te gh'è dàd duu intèrn pusìv n e m, e el tò compit l'è de calcolà l'è.-- >>> rounded_avg(1, 5)\n-- '0b11'\n-- >>> rounded_avg(7, 5)\n-- -1\n-- >>> rounded_avg(10, 20)\n-- '0b1111'\n-- >>> rounded_avg(20, 33)\n-- '0b11010'\nlocal function rounded_avg(n, m)\n","canonical_solution":"local function rounded_avg(n, m)\n    if n > m then\n        return -1\n    end\n    \n    local sum = 0\n    local count = 0\n\n    for i = n, m do\n        sum = sum + i\n        count = count + 1\n    end\n\n    local average = sum \/ count\n    local rounded_avg = math.floor(average + 0.5)\n\n    return string.format(\"0b%d\", tonumber(string.format(\"%o\", rounded_avg), 8))\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rounded_avg\n    lu.assertEquals(candidate(1, 5), '0b11')\n    lu.assertEquals(candidate(7, 13), '0b1010')\n    lu.assertEquals(candidate(964, 977), '0b1111001010')\n    lu.assertEquals(candidate(996, 997), '0b1111100100')\n    lu.assertEquals(candidate(560, 851), '0b1011000010')\n    lu.assertEquals(candidate(185, 546), '0b101101110')\n    lu.assertEquals(candidate(362, 496), '0b110101101')\n    lu.assertEquals(candidate(350, 902), '0b1001110010')\n    lu.assertEquals(candidate(197, 233), '0b11010111')\n    lu.assertEquals(candidate(7, 5), -1)\n    lu.assertEquals(candidate(5, 1), -1)\n    lu.assertEquals(candidate(5, 5), '0b101')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_104","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - Nota: La tabela riturnada la va ordinada in ordine crescente.- elemèncc che gh'hann minga di dígett pari.- Given a table of positive integers x. return a sorted table of all -- >>> unique_digits({15, 33, 1422, 1})\n-- {1, 15, 33}\n-- >>> unique_digits({152, 323, 1422, 10})\n-- {}\nlocal function unique_digits(x)\n","canonical_solution":"local function has_even_digit(num)\n    while num > 0 do\n        local digit = num % 10\n        if digit % 2 == 0 then\n            return true\n        end\n        num = math.floor(num \/ 10)\n    end\n    return false\nend\n\nlocal function unique_digits(x)\n    local result = {}\n    for _, num in ipairs(x) do\n        if not has_even_digit(num) then\n            table.insert(result, num)\n        end\n    end\n    table.sort(result)\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = unique_digits\n    lu.assertEquals(candidate({15, 33, 1422, 1}), {1, 15, 33})\n    lu.assertEquals(candidate({152, 323, 1422, 10}), {})\n    lu.assertEquals(candidate({12345, 2033, 111, 151}), {111, 151})\n    lu.assertEquals(candidate({135, 103, 31}), {31, 135})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_105","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - \"Unu\", \"Due\", \"Trè\", \"Quattrè\", \"Cinque\", \"Sèis\", \"Sèt\", \"Otto\", \"Nove\".- inversa la tabela che risulta, e pò sostituì ogni cifre col sò nomm corrispondent de - Given a table of integers, sort the integers that are between 1 and 9 inclusive, -- >>> by_length({2, 1, 1, 4, 5, 8, 2, 3})\n-- {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'}\n--   If the table is empty, return an empty table:\n-- >>> by_length({})\n-- {}\n--   If the table has any strange number ignore it:\n-- >>> by_length({1, -1, 55})\n-- {'One'}\nlocal function by_length(arr)\n","canonical_solution":"local function by_length(arr)\n    local digits_names = {\n        [1] = \"One\", [2] = \"Two\", [3] = \"Three\", [4] = \"Four\", [5] = \"Five\",\n        [6] = \"Six\", [7] = \"Seven\", [8] = \"Eight\", [9] = \"Nine\"\n    }\n\n    local filtered = {}\n    for _, num in ipairs(arr) do\n        if num >= 1 and num <= 9 then\n            table.insert(filtered, num)\n        end\n    end\n\n    table.sort(filtered, function(a, b) return a > b end)\n\n    for i, num in ipairs(filtered) do\n        filtered[i] = digits_names[num]\n    end\n\n    return filtered\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = by_length\n    lu.assertEquals(candidate({2, 1, 1, 4, 5, 8, 2, 3}), {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, -1, 55}), {'One'})\n    lu.assertEquals(candidate({1, -1, 3, 2}), {'Three', 'Two', 'One'})\n    lu.assertEquals(candidate({9, 4, 8}), {'Nine', 'Eight', 'Four'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_106","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - l'efet de i l'è la moltiplicazion di numer de 1 a i (1 * 2 * ... * i).- I cumincia da 1.- o la soma di nùmer dal 1 al i altrimenti.- e la torna una tabella de dimensiun n, tal che el valor de l'element in l'indice i l'è el fatorial de i se i l'è pari - Implementè la funziun f che la piglia n come parameter, -- >>> f(5)\n-- {1, 2, 6, 24, 15}\nlocal function f(n)\n","canonical_solution":"local function factorial(x)\n    if x == 0 then\n        return 1\n    else\n        local result = 1\n        for i = 2, x do\n            result = result * i\n        end\n        return result\n    end\nend\n\nlocal function sum_to_i(x)\n    return (x * (x + 1)) \/\/ 2\nend\n\nlocal function f(n)\n    local result = {}\n    for i = 1, n do\n        if i % 2 == 0 then\n            result[i] = factorial(i)\n        else\n            result[i] = sum_to_i(i)\n        end\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = f\n    lu.assertEquals(candidate(5), {1, 2, 6, 24, 15})\n    lu.assertEquals(candidate(7), {1, 2, 6, 24, 15, 720, 28})\n    lu.assertEquals(candidate(1), {1})\n    lu.assertEquals(candidate(3), {1, 2, 6})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_107","nl":"lmo_Latn","pl":"lua","prompt":"- Esempio 1: - palindrom intreg che i se troeuva in del interval ((1, n), inclusif. - Given a positive integer n, return a table that has the number of even and odd -- >>> even_odd_palindrome(3)\n-- {1, 2}\n--     Explanation:\n--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n-- Example 2:\n-- >>> even_odd_palindrome(12)\n-- {4, 6}\n--     Explanation:\n--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n-- Note:\n--     1. 1 <= n <= 10^3\n--     2. returned table has the number of even and odd integer palindromes respectively.\nlocal function even_odd_palindrome(n)\n","canonical_solution":"local function is_palindrome(num)\n    local str = tostring(num)\n    return str == string.reverse(str)\nend\n\nlocal function even_odd_palindrome(n)\n    local even_count = 0\n    local odd_count = 0\n\n    for i = 1, n do\n        if is_palindrome(i) then\n            if i % 2 == 0 then\n                even_count = even_count + 1\n            else\n                odd_count = odd_count + 1\n            end\n        end\n    end\n\n    return {even_count, odd_count}\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = even_odd_palindrome\n    lu.assertEquals(candidate(123), {8, 13})\n    lu.assertEquals(candidate(12), {4, 6})\n    lu.assertEquals(candidate(3), {1, 2})\n    lu.assertEquals(candidate(63), {6, 8})\n    lu.assertEquals(candidate(25), {5, 6})\n    lu.assertEquals(candidate(19), {4, 6})\n    lu.assertEquals(candidate(9), {4, 5})\n    lu.assertEquals(candidate(1), {0, 1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_108","nl":"lmo_Latn","pl":"lua","prompt":"- per esempi -123 l'ha la firma di cifre -1, 2 e 3. - Se un numer a l'è negativ, alura la sò prima cifara segnàda la sarà negativa: - el numer di element che gh'ha la soma di cifre > 0. - Scriv una funziun count_nums che la piglia una tabela di intèr e la torna -- >>> count_nums({})\n-- 0\n-- >>> count_nums({-1, 11, -11})\n-- 1\n-- >>> count_nums({1, 1, 2})\n-- 3\nlocal function count_nums(arr)\n","canonical_solution":"local function count_nums(arr)\n    local function sum_of_digits(num)\n        local sum = 0\n        local is_negative = num < 0\n        num = math.abs(num)\n        while num > 0 do\n            sum = sum + (num % 10)\n            num = math.floor(num \/ 10)\n        end\n        if is_negative then\n            sum = sum - 2 * (math.floor(math.abs(arr[index]) \/ 10 ^ (math.floor(math.log10(math.abs(arr[index]))))))\n        end\n        return sum\n    end\n\n    local count = 0\n    for _, num in ipairs(arr) do\n        local digit_sum = sum_of_digits(num)\n        if digit_sum > 0 then\n            count = count + 1\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_nums\n    lu.assertEquals(candidate({}), 0)\n    lu.assertEquals(candidate({-1, -2, 0}), 0)\n    lu.assertEquals(candidate({1, 1, 2, -2, 3, 4, 5}), 6)\n    lu.assertEquals(candidate({1, 6, 9, -6, 0, 1, 5}), 5)\n    lu.assertEquals(candidate({1, 100, 98, -7, 1, -1}), 4)\n    lu.assertEquals(candidate({12, 23, 34, -45, -56, 0}), 5)\n    lu.assertEquals(candidate({0, 1}), 1)\n    lu.assertEquals(candidate({1}), 1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_109","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - Nota: La tabela data la gh'ha garantìd di element unic.- Se la tabela data l'è vuda, torna ver.- then return true else return false. - Se l'è possibil de ottene la tabela ordinada per fà l'operazion de sora - la posizion de partenza in la tabela, cioè l'indice 0- posizion in la direzion giusta. L'ultim element de la tabela el vegnarà spostà a - Una operazion de spostament a destra la vol dì spostà tutt i element de la tabela de un.- Te ghè permès de fà l'operaziun de spostament a destra tant volt che te voeuret.- l'operazion seguenta in la tabela indicada: - l'è possibil de fà ordinà una tabela in ordine no decrescente per fà - i numm in de la tabela i vegn ordinad a la casualità.- gh'è 'na tàula 'arr' de N intèrn arr[1], arr[2], ..., arr[N].-- >>> move_one_ball({3, 4, 5, 1, 2})\n-- true\n-- Explanation: By performin 2 right shift operations, non-decreasing order can\n--              be achieved for the given table.\n-- >>> move_one_ball({3, 5, 4, 1, 2})\n-- false\n-- Explanation:It is not possible to get non-decreasing order for the given\n--             table by performing any number of right shift operations.\nlocal function move_one_ball(arr)\n","canonical_solution":"local function move_one_ball(arr)\n    local n = #arr\n    if n == 0 then\n        return true\n    end\n\n    local count_descending_pairs = 0\n\n    for i = 1, n do\n        if arr[i] > arr[(i % n) + 1] then\n            count_descending_pairs = count_descending_pairs + 1\n        end\n        if count_descending_pairs > 1 then\n            return false\n        end\n    end\n\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = move_one_ball\n    lu.assertEquals(candidate({3, 4, 5, 1, 2}), true)\n    lu.assertEquals(candidate({3, 5, 10, 1, 2}), true)\n    lu.assertEquals(candidate({4, 3, 1, 2}), false)\n    lu.assertEquals(candidate({3, 5, 4, 1, 2}), false)\n    lu.assertEquals(candidate({}), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_110","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - Altrimenti, torna \"NO\".- tüt i elemènt de lst1 a hinn pari, torna \"Sì\".- Se l'è possibil scambià di element tra lst1 e lst2 per fà - No gh'è minga un limit al nümer di element scambià tra lst1 e lst2.- tra di lor per fà lst1 una tabella di numeri pari.- e determina se l'è pusibil fà un scambi d'elementi - In chèsto problema, ti te metarè in vün una funziun che la gh'ha dò tabelle de numere, -- >>> exchange({1, 2, 3, 4}, {1, 2, 3, 4})\n-- 'YES'\n-- >>> exchange({1, 2, 3, 4}, {1, 5, 3, 4})\n-- 'NO'\n-- It is assumed that the input tables will be non-empty.\nlocal function exchange(lst1, lst2)\n","canonical_solution":"local function exchange(lst1, lst2)\n    local is_all_even = true\n    local odd_count_lst1 = 0\n    local even_count_lst2 = 0\n\n    -- Check lst1 for odd numbers\n    for _, num in ipairs(lst1) do\n        if num % 2 ~= 0 then\n            odd_count_lst1 = odd_count_lst1 + 1\n        end\n    end\n\n    -- Check lst2 for even numbers\n    for _, num in ipairs(lst2) do\n        if num % 2 == 0 then\n            even_count_lst2 = even_count_lst2 + 1\n        end\n    end\n\n    -- It is possible to make lst1 all even if the number of odd elements\n    -- in lst1 can be swapped with the number of even elements in lst2\n    if odd_count_lst1 <= even_count_lst2 then\n        return \"YES\"\n    else\n        return \"NO\"\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = exchange\n    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 2, 3, 4}), 'YES')\n    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 5, 3, 4}), 'NO')\n    lu.assertEquals(candidate({1, 2, 3, 4}, {2, 1, 4, 3}), 'YES')\n    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 4}), 'YES')\n    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 3}), 'NO')\n    lu.assertEquals(candidate({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}), 'NO')\n    lu.assertEquals(candidate({100, 200}, {200, 200}), 'YES')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_111","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Se plü leteres á la medema ocaziun, reverda düć.- de la lettera con la maggior quantità di ripetizioni e che conteneva il conteggio corrispondente.- Given a string representing a space separated lowercase letters, return a table -- >>> histogram('a b c')\n-- {['a'] = 1, ['b'] = 1, ['c'] = 1}\n-- >>> histogram('a b b a')\n-- {['a'] = 2, ['b'] = 2}\n-- >>> histogram('a b c a b')\n-- {['a'] = 2, ['b'] = 2}\n-- >>> histogram('b b b b a')\n-- {['b'] = 4}\n-- >>> histogram('')\n-- {}\nlocal function histogram(test)\n","canonical_solution":"local function histogram(test)\n    if test == \"\" then return {} end\n    \n    local words = {}\n    for word in test:gmatch(\"%S\") do\n        words[word] = (words[word] or 0) + 1\n    end\n    \n    local max_count = 0\n    local result = {}\n    for letter, count in pairs(words) do\n        if count > max_count then\n            max_count = count\n            result = {[letter] = count}\n        elseif count == max_count then\n            result[letter] = count\n        end\n    end\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = histogram\n    lu.assertEquals(candidate('a b b a'), {['a'] = 2, ['b'] = 2})\n    lu.assertEquals(candidate('a b c a b'), {['a'] = 2, ['b'] = 2})\n    lu.assertEquals(candidate('a b c d g'), {['a'] = 1, ['b'] = 1, ['c'] = 1, ['d'] = 1, ['g'] = 1})\n    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})\n    lu.assertEquals(candidate('b b b b a'), {['b'] = 4})\n    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})\n    lu.assertEquals(candidate(''), {})\n    lu.assertEquals(candidate('a'), {['a'] = 1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_112","nl":"lmo_Latn","pl":"lua","prompt":"- Esempiu - Te dovariss rend una tabella cont la stringa de resultat e true\/false per el control.- Una stringa l'è ciamada palindrom se la lèze la stesa manera in del divan che in del divan.- alura verificà se la stringa de risultà l'è palindrom. - A gh'è dü strìn s e c, gh'è da scartà tüti i caràter in s che i è uguali a quäl che i è in c.- Tasca -- >>> reverse_delete('abcde', 'ae')\n-- {'bcd', false}\n-- >>> reverse_delete('abcdef', 'b')\n-- {'acdef', false}\n-- >>> reverse_delete('abcdedcba', 'ab')\n-- {'cdedc', true}\nlocal function reverse_delete(s, c)\n","canonical_solution":"local function reverse_delete(s, c)\n    -- Create a set for characters to delete\n    local delete_set = {}\n    for i = 1, #c do\n        delete_set[c:sub(i, i)] = true\n    end\n    \n    -- Create the result string by filtering out characters in delete_set\n    local result = {}\n    for i = 1, #s do\n        local char = s:sub(i, i)\n        if not delete_set[char] then\n            table.insert(result, char)\n        end\n    end\n    \n    -- Convert result table to string\n    local result_str = table.concat(result)\n    \n    -- Check if the result string is a palindrome\n    local is_palindrome = true\n    local len = #result_str\n    for i = 1, math.floor(len \/ 2) do\n        if result_str:sub(i, i) ~= result_str:sub(len - i + 1, len - i + 1) then\n            is_palindrome = false\n            break\n        end\n    end\n    \n    -- Return the result string and palindrome check as a table\n    return {result_str, is_palindrome}\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = reverse_delete\n    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})\n    lu.assertEquals(candidate('abcdef', 'b'), {'acdef', false})\n    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc', true})\n    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})\n    lu.assertEquals(candidate('a', 'a'), {'', true})\n    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba', true})\n    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})\n    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})\n    lu.assertEquals(candidate('mamma', 'mia'), {'', true})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_113","nl":"lmo_Latn","pl":"lua","prompt":"- di cifre dispari in la stringa i'th de l'input. - stringa i de l'input. \" indove che tücc i i's i devenn vess sostituìcc del numer - Ogni element i de la sortida el dovariss ess el numer de element dispari in la - Given a table of strings, where each string consists of only digits, return a table. -- >>> odd_count({'1234567'})\n-- {'the number of odd elements 4n the str4ng 4 of the 4nput.'}\n-- >>> odd_count({'3', '11111111'})\n-- {'the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'}\nlocal function odd_count(lst)\n","canonical_solution":"local function odd_count(lst)\n    local result = {}\n    for _, str in ipairs(lst) do\n        local odd_count = 0\n        for i = 1, #str do\n            local digit = tonumber(str:sub(i, i))\n            if digit % 2 == 1 then\n                odd_count = odd_count + 1\n            end\n        end\n        local element = string.format(\"the number of odd elements %dn the str%1dng %d of the %d\", odd_count, odd_count, odd_count, odd_count)\n        result[#result + 1] = element\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = odd_count\n    lu.assertEquals(candidate({'1234567'}), {'the number of odd elements 4n the str4ng 4 of the 4nput.'})\n    lu.assertEquals(candidate({'3', '11111111'}), {'the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'})\n    lu.assertEquals(candidate({'271', '137', '314'}), {'the number of odd elements 2n the str2ng 2 of the 2nput.', 'the number of odd elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng 2 of the 2nput.'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_114","nl":"lmo_Latn","pl":"lua","prompt":"- Esempiu - de numm. - Dàt una tàula di intèrn numàri, tróa la summa mìnima de quàlche sot-tàula nòta-vaga -- >>> minSubArraySum({2, 3, 4, 1, 2, 4})\n-- 1\n-- >>> minSubArraySum({-1, -2, -3})\n-- -6\nlocal function minSubArraySum(nums)\n","canonical_solution":"local function minSubArraySum(nums)\n    local min_sum = nums[1]\n    local current_sum = nums[1]\n\n    for i = 2, #nums do\n        current_sum = math.min(nums[i], current_sum + nums[i])\n        min_sum = math.min(min_sum, current_sum)\n    end\n\n    return min_sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = minSubArraySum\n    lu.assertEquals(candidate({2, 3, 4, 1, 2, 4}), 1)\n    lu.assertEquals(candidate({-1, -2, -3}), -6)\n    lu.assertEquals(candidate({-1, -2, -3, 2, -10}), -14)\n    lu.assertEquals(candidate({-9999999999999999}), -9999999999999999)\n    lu.assertEquals(candidate({0, 10, 20, 1000000}), 0)\n    lu.assertEquals(candidate({-1, -2, -3, 10, -5}), -6)\n    lu.assertEquals(candidate({100, -1, -2, -3, 10, -5}), -6)\n    lu.assertEquals(candidate({10, 11, 13, 8, 3, 4}), 3)\n    lu.assertEquals(candidate({100, -33, 32, -1, 0, -2}), -33)\n    lu.assertEquals(candidate({-10}), -10)\n    lu.assertEquals(candidate({7}), 7)\n    lu.assertEquals(candidate({1, -1}), -1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_115","nl":"lmo_Latn","pl":"lua","prompt":"- Esempio 1: - Input el numer de volt che te gh'hee de scüss i secch.- Al tò compit l'è de usà i secch per svuotà i pozzi.- e tüti i secch i gh'hann la stessa capacità.- Ogni pozzo ha un secchio corrispondente che pu usà per estrar l'acqua da lu,- e ogni 1 in fila rappresenta ona unità d'acqua.- Te gh'è una griglia rettangolare de pozzi, ogni fila la rappresenta un pozzo singol,-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n-- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}}, 5)\n-- 0\n-- Constraints:\n--     * all wells have the same length\n--     * 1 <= grid.length <= 10^2\n--     * 1 <= grid[:,1].length <= 10^2\n--     * grid[i][j] -> 0 | 1\n--     * 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n","canonical_solution":"local function max_fill(grid, capacity)\n    local total_units = 0\n\n    -- Traverse each well in the grid\n    for i = 1, #grid do\n        for j = 1, #grid[i] do\n            total_units = total_units + grid[i][j]\n        end\n    end\n\n    -- Calculate the number of times the bucket needs to be lowered\n    local num_lowerings = math.ceil(total_units \/ capacity)\n\n    return num_lowerings\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_116","nl":"lmo_Latn","pl":"lua","prompt":"- L'è de fàa inscì:- Per un numer simil de 1 se fa el sort basand su di valur decimal.- numm de i un in la so raprejentazion binaria in ordine ascendent.- In chèsta kata, te gh'è de ordinà 'na tàula de intèrn no-negatìv segónt a -- >>> sort_array({1, 5, 2, 3, 4})\n-- {1, 2, 3, 4, 5}\n-- >>> sort_array({-2, -3, -4, -5, -6})\n-- {-6, -5, -4, -3, -2}\n-- >>> sort_array({1, 0, 2, 3, 4})\n-- {0, 1, 2, 3, 4}\nlocal function sort_array(arr)\n","canonical_solution":"local function count_ones(n)\n    local count = 0\n    while n > 0 do\n        count = count + (n % 2)\n        n = math.floor(n \/ 2)\n    end\n    return count\nend\n\nlocal function sort_array(arr)\n    table.sort(arr, function(a, b)\n        local ones_a = count_ones(math.abs(a))\n        local ones_b = count_ones(math.abs(b))\n        if ones_a == ones_b then\n            return a < b\n        else\n            return ones_a < ones_b\n        end\n    end)\n    return arr\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_array\n    lu.assertEquals(candidate({1, 5, 2, 3, 4}), {1, 2, 4, 3, 5})\n    lu.assertEquals(candidate({-2, -3, -4, -5, -6}), {-4, -2, -6, -5, -3})\n    lu.assertEquals(candidate({1, 0, 2, 3, 4}), {0, 1, 2, 4, 3})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77})\n    lu.assertEquals(candidate({3, 6, 44, 12, 32, 5}), {32, 3, 5, 6, 12, 44})\n    lu.assertEquals(candidate({2, 4, 8, 16, 32}), {2, 4, 8, 16, 32})\n    lu.assertEquals(candidate({2, 4, 8, 16, 32}), {2, 4, 8, 16, 32})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_117","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Nota: se pò pensà che la stringa d'intrada la gh'ha domà letere e spazi.- Se la stringa s l'è vuda, la funziun la dovariss tornà una tabela vuda.- n consonànte, in ordè che ste paròle i vegn in la stringa s. - una funziun che la restituiss una tabella de tucc i paroll de la stringa s che contenn pròpe - Given a string s and a natural number n, you've been tasked to implement -- >>> select_words('Mary had a little lamb', 4)\n-- {'little'}\n-- >>> select_words('Mary had a little lamb', 3)\n-- {'Mary', 'lamb'}\n-- >>> select_words('simple white space', 2)\n-- {}\n-- >>> select_words('Hello world', 4)\n-- {'world'}\n-- >>> select_words('Uncle sam', 3)\n-- {'Uncle'}\nlocal function select_words(s, n)\n","canonical_solution":"local function select_words(s, n)\n    local vowels = { a = true, e = true, i = true, o = true, u = true,\n                     A = true, E = true, I = true, O = true, U = true }\n    local result = {}\n    \n    for word in s:gmatch(\"%S+\") do\n        local consonant_count = 0\n        for char in word:gmatch(\"%a\") do\n            if not vowels[char] then\n                consonant_count = consonant_count + 1\n            end\n        end\n        if consonant_count == n then\n            table.insert(result, word)\n        end\n    end\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = select_words\n    lu.assertEquals(candidate('Mary had a little lamb', 4), {'little'})\n    lu.assertEquals(candidate('Mary had a little lamb', 3), {'Mary', 'lamb'})\n    lu.assertEquals(candidate('simple white space', 2), {})\n    lu.assertEquals(candidate('Hello world', 4), {'world'})\n    lu.assertEquals(candidate('Uncle sam', 3), {'Uncle'})\n    lu.assertEquals(candidate('', 4), {})\n    lu.assertEquals(candidate('a b c d e f', 1), {'b', 'c', 'd', 'f'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_118","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Te pòdet pensà che la stringa data la gh'ha domà la lettera inglesa.- tröva 'na vocala che la cumplich la cundizion de chì de sora.- Vocali al cuminciamèncc e a la finimèncc i n'èṅ minga contàcc.- düc i consonanć da la drita dla paròla (sensibil a la cassa). - Te gh'è una parola, e te gh'è de trovà la vocale che la se troeuva tra-- >>> get_closest_vowel('yogurt')\n-- 'u'\n-- >>> get_closest_vowel('FULL')\n-- 'U'\n-- >>> get_closest_vowel('quick')\n-- ''\n-- >>> get_closest_vowel('ab')\n-- ''\nlocal function get_closest_vowel(word)\n","canonical_solution":"local function get_closest_vowel(word)\n    local vowels = \"AEIOUaeiou\"\n    local found_vowel = false\n    local last_consonant = false\n\n    for i = #word - 1, 2, -1 do\n        local char = word:sub(i, i)\n        if vowels:find(char) then\n            if last_consonant then\n                return char\n            end\n            found_vowel = true\n        else\n            if found_vowel then\n                return ''\n            end\n            last_consonant = true\n        end\n    end\n\n    return ''\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_closest_vowel\n    lu.assertEquals(candidate('yogurt'), 'u')\n    lu.assertEquals(candidate('full'), 'u')\n    lu.assertEquals(candidate('easy'), '')\n    lu.assertEquals(candidate('eAsy'), '')\n    lu.assertEquals(candidate('ali'), '')\n    lu.assertEquals(candidate('bad'), 'a')\n    lu.assertEquals(candidate('most'), 'o')\n    lu.assertEquals(candidate('ab'), '')\n    lu.assertEquals(candidate('ba'), '')\n    lu.assertEquals(candidate('quick'), '')\n    lu.assertEquals(candidate('anime'), 'i')\n    lu.assertEquals(candidate('Asia'), '')\n    lu.assertEquals(candidate('Above'), 'o')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_119","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Rend \"Sì\" se gh'è un manera de fà una bona stringa, e rend \"No\" altrimenti.- \"()) \" l'è minga.- i è bilanciàcc. Per esempi: la stringa \"(((() \" l'è bèla, menter la stringa - Una stringa S l'è cunsiderada bona se e domà se tücc i parentesi in S - qualch ordin, che la stringa resultant la sarà bona.- La tò òpera l'è de véder se l'è pusìbil catenà i dò string in - SOLO LE PARANTEZZE \" (\"... o LE PARANTEZZE \") \".- Te gh'è una tabela de duu string, tutt duu string i è de \"open\"-- >>> match_parens({'()(', ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n","canonical_solution":"local function match_parens(lst)\n    local function is_balanced(s)\n        local balance = 0\n        for i = 1, #s do\n            if s:sub(i,i) == '(' then\n                balance = balance + 1\n            else\n                balance = balance - 1\n            end\n\n            if balance < 0 then\n                return false\n            end\n        end\n        return balance == 0\n    end\n\n    local s1, s2 = lst[1], lst[2]\n    return (is_balanced(s1 .. s2) or is_balanced(s2 .. s1)) and 'Yes' or 'No'\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_120","nl":"lmo_Latn","pl":"lua","prompt":"- Esempio 1: - de lunghezza k con i numm massimi k in arr.- Given a table arr of integers and a positive integer k, return a sorted table -- >>> maximum({-3, -4, 5}, 3)\n-- {-4, -3, 5}\n-- Example 2:\n-- >>> maximum({4, -4, 4}, 2)\n-- {4, 4}\n-- Example 3:\n-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)\n-- {2}\n-- Note:\n--     1. The length of the table will be in the range of [1, 1000].\n--     2. The elements in the table will be in the range of [-1000, 1000].\n--     3. 0 <= k <= len(arr)\nlocal function maximum(arr, k)\n","canonical_solution":"local function maximum(arr, k)\n    table.sort(arr, function(a, b) return a > b end)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, arr[i])\n    end\n    table.sort(result)\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = maximum\n    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})\n    lu.assertEquals(candidate({4, -4, 4}, 2), {4, 4})\n    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1), {2})\n    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123})\n    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})\n    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15})\n    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})\n    lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})\n    lu.assertEquals(candidate({4, -4}, 2), {-4, 4})\n    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})\n    lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_121","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi - Given a non-empty table of integers, return the sum of all of the odd elements that are in even positions. -- >>> solution({5, 8, 7, 1})\n-- 12\n-- >>> solution({3, 3, 3, 3, 3})\n-- 9\n-- >>> solution({30, 13, 24, 321})\n-- 0\nlocal function solution(lst)\n","canonical_solution":"local function solution(lst)\n    local sum = 0\n    for i = 2, #lst, 2 do\n        if lst[i] % 2 == 1 then\n            sum = sum + lst[i]\n        end\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = solution\n    lu.assertEquals(candidate({5, 8, 7, 1}), 12)\n    lu.assertEquals(candidate({3, 3, 3, 3, 3}), 9)\n    lu.assertEquals(candidate({30, 13, 24, 321}), 0)\n    lu.assertEquals(candidate({5, 9}), 5)\n    lu.assertEquals(candidate({2, 4, 8}), 0)\n    lu.assertEquals(candidate({30, 13, 23, 32}), 23)\n    lu.assertEquals(candidate({3, 13, 2, 9}), 3)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_122","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - la soma di elementi con al massimo due cifre dai primi k elementi di arr.- Given a non-empty table of integer arr and an integer k, return -- >>> add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n-- 24\n-- Constraints:\n--     1. 1 <= len(arr) <= 100\n--     2. 1 <= k <= len(arr)\nlocal function add_elements(arr, k)\n","canonical_solution":"local function add_elements(arr, k)\n    local sum = 0\n    for i = 1, k do\n        local element = arr[i]\n        if element >= -99 and element <= 99 then\n            sum = sum + element\n        end\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = add_elements\n    lu.assertEquals(candidate({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), -4)\n    lu.assertEquals(candidate({111, 121, 3, 4000, 5, 6}, 2), 0)\n    lu.assertEquals(candidate({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), 125)\n    lu.assertEquals(candidate({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), 24)\n    lu.assertEquals(candidate({1}, 1), 1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_123","nl":"lmo_Latn","pl":"lua","prompt":"- get_odd_collatz(5) rend [1, 5] # La sequenza collatz per 5 l'è [5, 16, 8, 4, 2, 1], donca i numer dispari hinn domà 1, e 5. - Per esempi: - 2. tabella restituita ordinata in ordine crescente.- 1. Collatz ((1) è [1]. - Nota: - tèrm + 1. l'è conjetùr che, indipendènt dal valōr de n, la sèquènsa la rivarà sèmper a 1.- l'è 'l tèrm prìma. se l'è 'l tèrm prìma l'è dispari, l'è 'l tèrm pròssim 3 volt del tèrm prìma.- tèrmin précedènti cuma chi: se al tèrmin précedènti l'è pari, al tèrmin proscimo l'è la metà de - come segue: cumincià cun un intreg pusitiv n. Alura ogni tèrm l'è ottenguu de la - La conjetüra de Collatz l'è una conjetüra in matemàtica che la riguarda una sequenza definida - Dàt un intèrn pusìv n, turnè una tàula ordinàda che la gh'à i nùmer dispari in sequènsa collatz.-- >>> get_odd_collatz(5)\n-- {1, 5}\nlocal function get_odd_collatz(n)\n","canonical_solution":"local function get_odd_collatz(n)\n    local collatz_sequence = {}\n    while n ~= 1 do\n        if n % 2 == 1 then\n            table.insert(collatz_sequence, n)\n        end\n        if n % 2 == 0 then\n            n = n \/ 2\n        else\n            n = 3 * n + 1\n        end\n    end\n    table.insert(collatz_sequence, 1)  -- Always add 1 as the sequence ends with 1\n    \n    -- Remove duplicates and sort the table\n    local unique_odds = {}\n    for _, num in ipairs(collatz_sequence) do\n        unique_odds[num] = true\n    end\n\n    local sorted_odds = {}\n    for num, _ in pairs(unique_odds) do\n        table.insert(sorted_odds, num)\n    end\n    table.sort(sorted_odds)\n\n    return sorted_odds\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_odd_collatz\n    lu.assertEquals(candidate(14), {1, 5, 7, 11, 13, 17})\n    lu.assertEquals(candidate(5), {1, 5})\n    lu.assertEquals(candidate(12), {1, 3, 5})\n    lu.assertEquals(candidate(1), {1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_124","nl":"lmo_Latn","pl":"lua","prompt":"- 4. la data la dev eser in del formatt: mm-dd-aaaa - 3. I mes a dovren minga vess meno de 1 o piö de 12.- 2. al nùmer di dé al n è minga méntar de 1 o piö de 31 dé per i méś 1,3,5,7,8,10,12. e al nùmer di dé al n è minga méntar de 1 o piö de 30 dé per i méś 4,6,9,11. e al nùmer di dé al n è minga méntar de 1 o piö de 29 dé per el méś 2.- 1. La stringa de data a l'è minga vuda.- La data é valida sce al é gnüdes cumplides düć i regolamënć: - return true if valid otherwise false. - Te gh'è de scriv una funziun che la valida una data data data e -- >>> valid_date('03-11-2000')\n-- true\n-- >>> valid_date('15-01-2012')\n-- false\n-- >>> valid_date('04-0-2040')\n-- false\n-- >>> valid_date('06-04-2020')\n-- true\n-- >>> valid_date('06\/04\/2020')\n-- false\nlocal function valid_date(date)\n","canonical_solution":"local function valid_date(date)\n    if date == \"\" then\n        return false\n    end\n    \n    local month, day, year = date:match(\"^(%d%d)%-(%d%d)%-(%d%d%d%d)$\")\n    \n    if not month or not day or not year then\n        return false\n    end\n    \n    month = tonumber(month)\n    day = tonumber(day)\n    year = tonumber(year)\n    \n    if month < 1 or month > 12 then\n        return false\n    end\n    \n    local days_in_month = {\n        [1] = 31,\n        [2] = 29, -- Leap year check not required for this problem\n        [3] = 31,\n        [4] = 30,\n        [5] = 31,\n        [6] = 30,\n        [7] = 31,\n        [8] = 31,\n        [9] = 30,\n        [10] = 31,\n        [11] = 30,\n        [12] = 31\n    }\n    \n    if day < 1 or day > days_in_month[month] then\n        return false\n    end\n    \n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = valid_date\n    lu.assertEquals(candidate('03-11-2000'), true)\n    lu.assertEquals(candidate('15-01-2012'), false)\n    lu.assertEquals(candidate('04-0-2040'), false)\n    lu.assertEquals(candidate('06-04-2020'), true)\n    lu.assertEquals(candidate('01-01-2007'), true)\n    lu.assertEquals(candidate('03-32-2011'), false)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('04-31-3000'), false)\n    lu.assertEquals(candidate('06-06-2005'), true)\n    lu.assertEquals(candidate('21-31-2000'), false)\n    lu.assertEquals(candidate('04-12-2003'), true)\n    lu.assertEquals(candidate('04122003'), false)\n    lu.assertEquals(candidate('20030412'), false)\n    lu.assertEquals(candidate('2003-04'), false)\n    lu.assertEquals(candidate('2003-04-12'), false)\n    lu.assertEquals(candidate('04-2003'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_125","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi - alfabet, ord a' = 0, ord b' = 1, ... ord z' = 25- dev'èss spartìcc in cummà ',' se no gh'è cummà dovarès rend el nümer de letere minuscole con ordini dispari in del - Given a string of words, return a table of words split on whitespace, if no whitespaces exists in the text you -- >>> split_words('Hello world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('Hello,world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('abcdef')\n-- 3\nlocal function split_words(txt)\n","canonical_solution":"local function split_words(txt)\n    -- Check if there is any whitespace to split on\n    if txt:find(\"%s\") then\n        local words = {}\n        for word in txt:gmatch(\"%S+\") do\n            table.insert(words, word)\n        end\n        return words\n    end\n\n    -- Check if there are commas to split on\n    if txt:find(\",\") then\n        local words = {}\n        for word in txt:gmatch(\"([^,]+)\") do\n            table.insert(words, word)\n        end\n        return words\n    end\n\n    -- Otherwise, count the number of lowercase letters with odd order\n    local count = 0\n    for i = 1, #txt do\n        local char = txt:sub(i, i)\n        local ord = char:byte() - string.byte('a')\n        if ord >= 0 and ord <= 25 and ord % 2 == 1 then\n            count = count + 1\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = split_words\n    lu.assertEquals(candidate('Hello world!'), {'Hello', 'world!'})\n    lu.assertEquals(candidate('Hello,world!'), {'Hello', 'world!'})\n    lu.assertEquals(candidate('Hello world,!'), {'Hello', 'world,!'})\n    lu.assertEquals(candidate('Hello,Hello,world !'), {'Hello,Hello,world', '!'})\n    lu.assertEquals(candidate('abcdef'), 3)\n    lu.assertEquals(candidate('aaabb'), 2)\n    lu.assertEquals(candidate('aaaBb'), 1)\n    lu.assertEquals(candidate(''), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_126","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi - numm, torna false. Assum minga numm negatif e domà intreg.- in ordinn ascendent. se la tabela la gh'ha de piö de 1 duplicat de la stessa- Given a table of numbers, return whether or not they are sorted -- >>> is_sorted({5})\n-- true\n-- >>> is_sorted({1, 2, 3, 4, 5})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5})\n-- false\n-- >>> is_sorted({1, 2, 3, 4, 5, 6})\n-- true\n-- >>> is_sorted({1, 2, 3, 4, 5, 6, 7})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5, 6, 7})\n-- false\n-- >>> is_sorted({1, 2, 2, 3, 3, 4})\n-- true\n-- >>> is_sorted({1, 2, 2, 2, 3, 4})\n-- false\nlocal function is_sorted(lst)\n","canonical_solution":"local function is_sorted(lst)\n    local seen = {}\n    for i = 1, #lst - 1 do\n        if lst[i] > lst[i + 1] then\n            return false\n        end\n    end\n\n    for _, num in ipairs(lst) do\n        if seen[num] then\n            seen[num] = seen[num] + 1\n            if seen[num] > 2 then\n                return false\n            end\n        else\n            seen[num] = 1\n        end\n    end\n\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_sorted\n    lu.assertEquals(candidate({5}), true)\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}), true)\n    lu.assertEquals(candidate({1, 3, 2, 4, 5}), false)\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6}), true)\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7}), true)\n    lu.assertEquals(candidate({1, 3, 2, 4, 5, 6, 7}), false)\n    lu.assertEquals(candidate({}), true)\n    lu.assertEquals(candidate({1}), true)\n    lu.assertEquals(candidate({3, 2, 1}), false)\n    lu.assertEquals(candidate({1, 2, 2, 2, 3, 4}), false)\n    lu.assertEquals(candidate({1, 2, 3, 3, 3, 4}), false)\n    lu.assertEquals(candidate({1, 2, 2, 3, 3, 4}), true)\n    lu.assertEquals(candidate({1, 2, 3, 4}), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_127","nl":"lmo_Latn","pl":"lua","prompt":"- [input\/output] samples: - Se i duu interval no se incrocia, torna \"NO\".- altrimenti, torna \"NO\".- Se la lunghesa de l'intersezion l'è un nümer prim, torna \"SÌ\", - che la sò longhesa l'è 1, che l'è minga un nümer prim.- Esempi, l'intersezion di interval (1, 3), (2, 4) l'è (2, 3) - intervall a l'è un nümer prim.- La tò compit a l'é 'd determiné se la longhìa d'intersecassion ëd sti doi - Per ogni interval, se pensa che el sò principi el sia men o uguale al sò fin.- include start and end. - I interval dat hinn chiusuu, cioè l'interval (comenzar, finir)- indova ogni interval a l'è una per de intèr. Per esempi, interval = (comenzar, finì) = (1, 2).- Te gh'è dàd dù interval, -- >>> intersection({1, 2}, {2, 3})\n-- 'NO'\n-- >>> intersection({-1, 1}, {0, 4})\n-- 'NO'\n-- >>> intersection({-3, -1}, {-5, 5})\n-- 'YES'\nlocal function intersection(interval1, interval2)\n","canonical_solution":"local function is_prime(num)\n    if num <= 1 then\n        return false\n    end\n    if num <= 3 then\n        return true\n    end\n    if num % 2 == 0 or num % 3 == 0 then\n        return false\n    end\n    for i = 5, math.sqrt(num), 6 do\n        if num % i == 0 or num % (i + 2) == 0 then\n            return false\n        end\n    end\n    return true\nend\n\nlocal function intersection(interval1, interval2)\n    local start1, end1 = interval1[1], interval1[2]\n    local start2, end2 = interval2[1], interval2[2]\n    \n    local intersection_start = math.max(start1, start2)\n    local intersection_end = math.min(end1, end2)\n    \n    if intersection_start > intersection_end then\n        return 'NO'\n    end\n    \n    local intersection_length = intersection_end - intersection_start + 1\n    \n    if is_prime(intersection_length) then\n        return 'YES'\n    else\n        return 'NO'\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersection\n    lu.assertEquals(candidate({1, 2}, {2, 3}), 'NO')\n    lu.assertEquals(candidate({-1, 1}, {0, 4}), 'NO')\n    lu.assertEquals(candidate({-3, -1}, {-5, 5}), 'YES')\n    lu.assertEquals(candidate({-2, 2}, {-4, 0}), 'YES')\n    lu.assertEquals(candidate({-11, 2}, {-1, -1}), 'NO')\n    lu.assertEquals(candidate({1, 2}, {3, 5}), 'NO')\n    lu.assertEquals(candidate({1, 2}, {1, 2}), 'NO')\n    lu.assertEquals(candidate({-2, -2}, {-3, -2}), 'NO')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_128","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Nota: rend null per arr vuoti.- de ogni numer de la tabela, rapresentà da 1, -1 o 0.- Summa de magnitud de i numer intreg moltiplicada per el prodot de tutt i segn- Te gh'è una tabella de intreg e te gh'è de tornà indree.-- >>> prod_signs({1, 2, 2, -4})\n-- 9\n-- >>> prod_signs({0, 1})\n-- 0\n-- >>> prod_signs({})\n-- None\nlocal function prod_signs(arr)\n","canonical_solution":"local function prod_signs(arr)\n    if #arr == 0 then\n        return nil\n    end\n\n    local sum_magnitudes = 0\n    local product_signs = 1\n\n    for _, num in ipairs(arr) do\n        sum_magnitudes = sum_magnitudes + math.abs(num)\n        if num > 0 then\n            product_signs = product_signs * 1\n        elseif num < 0 then\n            product_signs = product_signs * -1\n        else\n            product_signs = 0\n            break\n        end\n    end\n\n    return sum_magnitudes * product_signs\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = prod_signs\n    lu.assertEquals(candidate({1, 2, 2, -4}), -9)\n    lu.assertEquals(candidate({0, 1}), 0)\n    lu.assertEquals(candidate({1, 1, 1, 2, 3, -1, 1}), -10)\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({2, 4, 1, 2, -1, -1, 9}), 20)\n    lu.assertEquals(candidate({-1, 1, -1, 1}), 4)\n    lu.assertEquals(candidate({-1, 1, 1, 1}), -4)\n    lu.assertEquals(candidate({-1, 1, 1, 0}), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_129","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Rend una tabela ordenaa di valur de la cellula che la percorr la strada minima.- L'è garantì che la risposta l'è unica.- lst_A[j] = lst_B[j].- tal che lst_A[i] < lst_B[i] e per ogni j (1 <= j < i) gh'emm - che lst_B, in altre parolle, gh'è un indice intger i (1 <= i <= k) - tra (chiamémosle lst_A e lst_B), lst_A l'è lexischograficament meno - dopo aver fà i tavolin ordinà di valùr de la cellula che A e B và - Un percorso A (di lunghezza k) è considerato minore di un percorso B (di lunghezza k) se - Te pöl minga andà via dal gril.- necessariamente distint).- Per piacè notè che un percorso de lunghezza k significa visità esattamente k cellule (non - cellulare.- in alter parol, te pöl andà a celul che g'ha 'n canton con la tò corrent.- da ogni cellula, e in ogni pas pò andà a qualunque cellula vicina,- Te gh'è de trovà el percors minim de lunghessa k in de la griglia.- inclusif el vegn aparaa ona volta giust in di celul de la griglia. - ogni cellula de la griglia contègn un valor.- Given a grid with N rows and N columns (N >= 2) and a positive integer k, -- >>> minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3)\n-- {1, 2, 1}\n-- >>> minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1)\n-- {1}\nlocal function minPath(grid, k)\n","canonical_solution":"local function minPath(grid, k)\n    local N = #grid\n    local directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n\n    -- Check if a position is within the grid boundaries\n    local function inBounds(x, y)\n        return x >= 1 and x <= N and y >= 1 and y <= N\n    end\n\n    -- DFS to find the minimum path of length k\n    local function dfs(x, y, path, visited, result)\n        -- Append current cell's value to path\n        table.insert(path, grid[x][y])\n\n        if #path == k then\n            -- Check if we have a new minimum lexicographical path\n            if not result.min or table.concat(path) < table.concat(result.min) then\n                result.min = {table.unpack(path)}\n            end\n        else\n            for _, dir in ipairs(directions) do\n                local nx, ny = x + dir[1], y + dir[2]\n                if inBounds(nx, ny) then\n                    dfs(nx, ny, path, visited, result)\n                end\n            end\n        end\n\n        -- Backtrack\n        table.remove(path)\n    end\n\n    local result = {min = nil}\n\n    -- Start DFS from each cell\n    for i = 1, N do\n        for j = 1, N do\n            dfs(i, j, {}, {}, result)\n        end\n    end\n\n    return result.min\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = minPath\n    lu.assertEquals(candidate({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3), {1, 2, 1})\n    lu.assertEquals(candidate({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1), {1})\n    lu.assertEquals(candidate({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4), {1, 2, 1, 2})\n    lu.assertEquals(candidate({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7), {1, 10, 1, 10, 1, 10, 1})\n    lu.assertEquals(candidate({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5), {1, 7, 1, 7, 1})\n    lu.assertEquals(candidate({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9), {1, 6, 1, 6, 1, 6, 1, 6, 1})\n    lu.assertEquals(candidate({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12), {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6})\n    lu.assertEquals(candidate({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8), {1, 3, 1, 3, 1, 3, 1, 3})\n    lu.assertEquals(candidate({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8), {1, 5, 1, 5, 1, 5, 1, 5})\n    lu.assertEquals(candidate({{1, 2}, {3, 4}}, 10), {1, 2, 1, 2, 1, 2, 1, 2, 1, 2})\n    lu.assertEquals(candidate({{1, 3}, {3, 2}}, 10), {1, 3, 1, 3, 1, 3, 1, 3, 1, 3})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_130","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - primm n + 1 numm de la sequenza de Tribonacci.- Te g'è dat un nümer intèr no-negatìf n, te gh'è de tornà a una tàula de - = 2 + 3 + 3 = 8 - tri(3) = tri(2) + tri(1) + tri(4) - tri(4) = 3 - tri(2) = 1 + (2 \/ 2) = 2 - Per esempi: - tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), se n l'è dispari. - tri (n) = 1 + n \/ 2, se n l'è pari.- tri(1) = 3 - La sequenza de Tribonacci l'è definida de la recidiva:Però, quel che la gent la sa minga l'è la sequenza de Tribonacci.- Tüt i sa la sequenza de Fibonacci, l'è stada studada in profondità di matemàtich in -- >>> tri(3)\n-- {1, 3, 2, 8}\nlocal function tri(n)\n","canonical_solution":"local function tri(n)\n    local sequence = {}\n    \n    -- Handle the first element separately\n    sequence[1] = 3\n\n    for i = 2, n + 1 do\n        if i % 2 == 0 then\n            sequence[i] = 1 + i \/ 2\n        else\n            sequence[i] = (i - 1 <= 0 and 0 or sequence[i - 1]) +\n                          (i - 2 <= 0 and 0 or sequence[i - 2]) +\n                          (i + 1 > n + 1 and 0 or sequence[i + 1])\n        end\n    end\n    \n    return sequence\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = tri\n    lu.assertEquals(candidate(3), {1, 3, 2, 8})\n    lu.assertEquals(candidate(4), {1, 3, 2, 8, 3})\n    lu.assertEquals(candidate(5), {1, 3, 2, 8, 3, 15})\n    lu.assertEquals(candidate(6), {1, 3, 2, 8, 3, 15, 4})\n    lu.assertEquals(candidate(7), {1, 3, 2, 8, 3, 15, 4, 24})\n    lu.assertEquals(candidate(8), {1, 3, 2, 8, 3, 15, 4, 24, 5})\n    lu.assertEquals(candidate(9), {1, 3, 2, 8, 3, 15, 4, 24, 5, 35})\n    lu.assertEquals(candidate(20), {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11})\n    lu.assertEquals(candidate(0), {1})\n    lu.assertEquals(candidate(1), {1, 3})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_131","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - Render 0 se tüte le cifre hinn pari. - Dàt un intèrn pusìv n, rend el prudót di dígeti dispari. -- >>> digits(1)\n-- 1\n-- >>> digits(4)\n-- 0\n-- >>> digits(235)\n-- 15\nlocal function digits(n)\n","canonical_solution":"local function digits(n)\n    local product = 1\n    local hasOdd = false\n    \n    while n > 0 do\n        local digit = n % 10\n        if digit % 2 == 1 then\n            product = product * digit\n            hasOdd = true\n        end\n        n = math.floor(n \/ 10)\n    end\n    \n    return hasOdd and product or 0\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = digits\n    lu.assertEquals(candidate(5), 5)\n    lu.assertEquals(candidate(54), 5)\n    lu.assertEquals(candidate(120), 1)\n    lu.assertEquals(candidate(5014), 5)\n    lu.assertEquals(candidate(98765), 315)\n    lu.assertEquals(candidate(5576543), 2625)\n    lu.assertEquals(candidate(2468), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_132","nl":"lmo_Latn","pl":"lua","prompt":"- indova almenu una parentesi in la sottoseguenza l'è anidada.- La funziun la dovariss rendèr true se e domà se gh'è una sottoscuenza valida de parentesi - Creà una funziun che la piglia una stringa come input che la gh'ha domà i parentesi quadrati.-- >>> is_nested('[[]]')\n-- true\n-- >>> is_nested('[]]]]]]][[[[[]')\n-- false\n-- >>> is_nested('[][]')\n-- false\n-- >>> is_nested('[]')\n-- false\n-- >>> is_nested('[[][]]')\n-- true\n-- >>> is_nested('[[]][[')\n-- true\nlocal function is_nested(string)\n","canonical_solution":"local function is_nested(brackets)\n    local stack = {}\n    for i = 1, #brackets do\n        local char = brackets:sub(i, i)\n        if char == '[' then\n            table.insert(stack, char)\n        elseif char == ']' then\n            if #stack > 0 and stack[#stack] == '[' then\n                table.remove(stack)\n                if #stack > 0 then\n                    -- Found at least one nested bracket\n                    return true\n                end\n            else\n                -- Mismatched bracket\n                return false\n            end\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_nested\n    lu.assertEquals(candidate('[[]]'), true)\n    lu.assertEquals(candidate('[]]]]]]][[[[[]'), false)\n    lu.assertEquals(candidate('[][]'), false)\n    lu.assertEquals(candidate('[]'), false)\n    lu.assertEquals(candidate('[[[[]]]]'), true)\n    lu.assertEquals(candidate('[]]]]]]]]]]'), false)\n    lu.assertEquals(candidate('[][][[]]'), true)\n    lu.assertEquals(candidate('[[]'), false)\n    lu.assertEquals(candidate('[]]'), false)\n    lu.assertEquals(candidate('[[]][['), true)\n    lu.assertEquals(candidate('[[][]]'), true)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('[[[[[[[['), false)\n    lu.assertEquals(candidate(']]]]]]]]'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_133","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - arrondì ogni element in la tabela al int superior (sopra) prima.- Te gh'è de rend la soma di squadrat di numer in la tabela data, - Te gh'è ona tabella de numeri.-- >>> lst({1.0, 2.0, 3.0})\n-- 14\n-- >>> lst({1.0, 4.0, 9.0})\n-- 98\n-- >>> lst({1.0, 3.0, 5.0, 7.0})\n-- 84\n-- >>> lst({1.4, 4.2, 0.0})\n-- 29\n-- >>> lst({-2.4, 1.0, 1.0})\n-- 6\nlocal function sum_squares(lst)\n","canonical_solution":"local function sum_squares(lst)\n    local sum = 0\n    for _, num in ipairs(lst) do\n        local ceil_num = math.ceil(num)\n        sum = sum + (ceil_num * ceil_num)\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_squares\n    lu.assertEquals(candidate({1.0, 2.0, 3.0}), 14)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0}), 14)\n    lu.assertEquals(candidate({1.0, 3.0, 5.0, 7.0}), 84)\n    lu.assertEquals(candidate({1.4, 4.2, 0.0}), 29)\n    lu.assertEquals(candidate({-2.4, 1.0, 1.0}), 6)\n    lu.assertEquals(candidate({100.0, 1.0, 15.0, 2.0}), 10230)\n    lu.assertEquals(candidate({10000.0, 10000.0}), 200000000)\n    lu.assertEquals(candidate({-1.4, 4.6, 6.3}), 75)\n    lu.assertEquals(candidate({-1.4, 17.9, 18.9, 19.9}), 1086)\n    lu.assertEquals(candidate({0.0}), 0)\n    lu.assertEquals(candidate({-1.0}), 1)\n    lu.assertEquals(candidate({-1.0, 1.0, 0.0}), 2)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_134","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Nota: \"parola\" l'è un grupp de caratere separàa de spazzi.- una part de una parolla, e falsa altrimenti.- de na data stringa l'è un carater alfabetegh e l'è minga - Creà 'na funsiù che la dà 'n valor de true se l'ùrtim carater -- >>> check_if_last_char_is_a_letter('apple pie')\n-- false\n-- >>> check_if_last_char_is_a_letter('apple pi e')\n-- true\n-- >>> check_if_last_char_is_a_letter('apple pi e ')\n-- false\n-- >>> check_if_last_char_is_a_letter('')\n-- false\nlocal function check_if_last_char_is_a_letter(txt)\n","canonical_solution":"local function check_if_last_char_is_a_letter(txt)\n    -- Remove trailing spaces\n    txt = txt:match(\"^(.-)%s*$\")\n    -- Check if the string is empty after trimming spaces\n    if #txt == 0 then\n        return false\n    end\n    -- Get the last character of the string\n    local lastChar = txt:sub(-1)\n    -- Check if the last character is an alphabet and not part of a word\n    return lastChar:match(\"%a\") and not txt:match(\"%s%a*$\")\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = check_if_last_char_is_a_letter\n    lu.assertEquals(candidate('apple'), false)\n    lu.assertEquals(candidate('apple pi e'), true)\n    lu.assertEquals(candidate('eeeee'), false)\n    lu.assertEquals(candidate('A'), true)\n    lu.assertEquals(candidate('Pumpkin pie '), false)\n    lu.assertEquals(candidate('Pumpkin pie 1'), false)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('eeeee e '), false)\n    lu.assertEquals(candidate('apple pie'), false)\n    lu.assertEquals(candidate('apple pi e '), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_135","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - duplicate values. - no such element exists then return -1. La tabela dada la conterà minga - l'è minga püssee gròs o uguaai a l'element immediatament precedent.- Creà una funziun che la restituiss l'indici piö gròss de un element che -- >>> can_arrange({1, 2, 4, 3, 5})\n-- 3\n-- >>> can_arrange({1, 2, 3})\n-- -1\nlocal function can_arrange(arr)\n","canonical_solution":"local function can_arrange(arr)\n    for i = #arr, 2, -1 do\n        if arr[i] < arr[i - 1] then\n            return i\n        end\n    end\n    return -1\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = can_arrange\n    lu.assertEquals(candidate({1, 2, 4, 3, 5}), 3)\n    lu.assertEquals(candidate({1, 2, 4, 5}), -1)\n    lu.assertEquals(candidate({1, 4, 2, 5, 6, 7, 8, 9, 10}), 2)\n    lu.assertEquals(candidate({4, 8, 5, 7, 3}), 4)\n    lu.assertEquals(candidate({}), -1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_136","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Se no gh'è nè entier negativ nè positiv, restituì i nil.- di intreg pusìf in una tàula.- l'è el piö gròss de i intèrn negatif, e \"b\" l'è el piö pisè picin - Creà una funziun che la restituiss una tabela (a, b), indova \"a\" l'è -- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})\n-- {None, 1}\n-- >>> largest_smallest_integers({})\n-- {None, None}\n-- >>> largest_smallest_integers({0})\n-- {None, None}\nlocal function largest_smallest_integers(lst)\n","canonical_solution":"local function largest_smallest_integers(lst)\n    local max_negative = nil\n    local min_positive = nil\n\n    for _, num in ipairs(lst) do\n        if num < 0 then\n            if max_negative == nil or num > max_negative then\n                max_negative = num\n            end\n        elseif num > 0 then\n            if min_positive == nil or num < min_positive then\n                min_positive = num\n            end\n        end\n    end\n\n    return {max_negative, min_positive}\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_smallest_integers\n    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})\n    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7, 0}), {None, 1})\n    lu.assertEquals(candidate({1, 3, 2, 4, 5, 6, -2}), {-2, 1})\n    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7, 2})\n    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})\n    lu.assertEquals(candidate({}), {None, None})\n    lu.assertEquals(candidate({0}), {None, None})\n    lu.assertEquals(candidate({-1, -3, -5, -6}), {-1, None})\n    lu.assertEquals(candidate({-1, -3, -5, -6, 0}), {-1, None})\n    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})\n    lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_137","nl":"lmo_Latn","pl":"lua","prompt":"- Nota: Se un nümer reàl l'è raprezentàcc cuma 'na stringa, la virgola flüsa la pöl vèss . o , - Return nil if values are equal. - nummri reàl, e el torna la variabil püssee granda del sò tip de variabil. - Creà una funziun che la ciappa i intèr, i float o i string che i rapreśenta -- >>> compare_one(1, 2.5)\n-- 2.5\n-- >>> compare_one(1, '2,3')\n-- '2,3'\n-- >>> compare_one('5,1', '6')\n-- '6'\n-- >>> compare_one('1', 1)\n-- None\nlocal function compare_one(a, b)\n","canonical_solution":"local function to_real_number(val)\n    if type(val) == \"string\" then\n        val = val:gsub(\",\", \".\")\n        return tonumber(val)\n    end\n    return val\nend\n\nlocal function compare_one(a, b)\n    local a_type = type(a)\n    local b_type = type(b)\n    \n    if a_type == b_type then\n        if a == b then\n            return nil\n        end\n        return a > b and a or b\n    else\n        local a_real = to_real_number(a)\n        local b_real = to_real_number(b)\n        \n        if a_real == b_real then\n            return nil\n        end\n        return a_real > b_real and a or b\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = compare_one\n    lu.assertEquals(candidate(1, 2), 2)\n    lu.assertEquals(candidate(1, 2.5), 2.5)\n    lu.assertEquals(candidate(2, 3), 3)\n    lu.assertEquals(candidate(5, 6), 6)\n    lu.assertEquals(candidate(1, '2,3'), '2,3')\n    lu.assertEquals(candidate('5,1', '6'), '6')\n    lu.assertEquals(candidate('1', '2'), '2')\n    lu.assertEquals(candidate('1', 1), None)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_138","nl":"lmo_Latn","pl":"lua","prompt":"- Esempiu - Valutà se el numer n el pò vess scrivüü come la soma de 4 numer pari pusitiiv.-- >>> is_equal_to_sum_even(4)\n-- false\n-- >>> is_equal_to_sum_even(6)\n-- false\n-- >>> is_equal_to_sum_even(8)\n-- true\nlocal function is_equal_to_sum_even(n)\n","canonical_solution":"local function is_equal_to_sum_even(n)\n    -- Check if n can be expressed as the sum of 4 positive even numbers\n    -- which means n should at least be 8 (2 + 2 + 2 + 2) and n should be even.\n    if n >= 8 and n % 2 == 0 then\n        return true\n    else\n        return false\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_equal_to_sum_even\n    lu.assertEquals(candidate(4), false)\n    lu.assertEquals(candidate(6), false)\n    lu.assertEquals(candidate(8), true)\n    lu.assertEquals(candidate(10), true)\n    lu.assertEquals(candidate(11), false)\n    lu.assertEquals(candidate(12), true)\n    lu.assertEquals(candidate(13), false)\n    lu.assertEquals(candidate(16), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_139","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - indove n > 0 - brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! - L'efet brasilian l'è definìcc cuma: -- >>> special_factorial(4)\n-- 288\n-- The function will receive an integer as input and should return the special\n-- factorial of this integer.\nlocal function special_factorial(n)\n","canonical_solution":"local function factorial(m)\n    if m == 0 then\n        return 1\n    else\n        return m * factorial(m - 1)\n    end\nend\n\nlocal function special_factorial(n)\n    local result = 1\n    for i = 1, n do\n        result = result * factorial(i)\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = special_factorial\n    lu.assertEquals(candidate(4), 288)\n    lu.assertEquals(candidate(5), 34560)\n    lu.assertEquals(candidate(7), 125411328000)\n    lu.assertEquals(candidate(1), 1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_140","nl":"lmo_Latn","pl":"lua","prompt":"- alora sostituì tücc i spazi consecutiv cun - - e se una stringa l'ha piö de 2 spazi consecutiv, - Given a string text, replace all spaces in it with underscores, -- >>> fix_spaces(' Example')\n-- 'Example'\n-- >>> fix_spaces(' Example 1')\n-- 'Example_1'\n-- >>> fix_spaces(' Example 2')\n-- '_Example_2'\n-- >>> fix_spaces(' Example 3')\n-- '_Example-3'\nlocal function fix_spaces(text)\n","canonical_solution":"local function fix_spaces(text)\n    -- Trim leading and trailing spaces\n    text = text:match(\"^%s*(.-)%s*$\")\n    \n    -- Replace more than 2 consecutive spaces with '-'\n    text = text:gsub(\"%s%s%s+\", \"-\")\n    \n    -- Replace single spaces and double spaces with underscores\n    text = text:gsub(\"%s\", \"_\")\n    \n    return text\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fix_spaces\n    lu.assertEquals(candidate('Example'), 'Example')\n    lu.assertEquals(candidate('Mudasir Hanif '), 'Mudasir_Hanif_')\n    lu.assertEquals(candidate('Yellow Yellow  Dirty  Fellow'), 'Yellow_Yellow__Dirty__Fellow')\n    lu.assertEquals(candidate('Exa   mple'), 'Exa-mple')\n    lu.assertEquals(candidate('   Exa 1 2 2 mple'), '-Exa_1_2_2_mple')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_141","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - - La sotstringa dòpo del punt el dovaria vess vun de questi: ['txt', 'exe', 'dll'] - l'alfabet latin (\"a\" - \"z\" e \"A\" - \"Z\"). - - La sotstringa prima del puntin la dev minga vess vu, e la scomincia con una lettera de - - El nòm del file el gh'ha pròpe on puntin '.'- - L'intendiment del file el dovariss minga vèss de più de trii cifre (\"0\" - \"9\"). - i'è cumpàgn: - Un nòm de file a l'è cunsiderà valid se e domà se tücc i cundizion chì sot - \"Sì\" se l'è valid el nom del file, e torna \"No\" se l'è minga valid.- Creà una funziun che la piglia una stringa che la raprejenta el nom de un file e la torna -- >>> file_name_check('example.txt')\n-- 'Yes'\n-- >>> file_name_check('1example.dll')\n-- 'No'\nlocal function file_name_check(file_name)\n","canonical_solution":"local function file_name_check(file_name)\n    -- Check exactly one dot in the file name\n    local dot_pos = file_name:find(\"%.\")\n    if not dot_pos or dot_pos ~= file_name:find(\"%.\", dot_pos + 1) then\n        return 'No'\n    end\n    \n    -- Split the name into prefix and suffix\n    local prefix = file_name:sub(1, dot_pos - 1)\n    local suffix = file_name:sub(dot_pos + 1)\n\n    -- Check if suffix is valid\n    local valid_suffixes = { txt = true, exe = true, dll = true }\n    if not valid_suffixes[suffix] then\n        return 'No'\n    end\n\n    -- Check prefix is not empty and starts with a letter\n    if #prefix == 0 or not prefix:match(\"^[a-zA-Z]\") then\n        return 'No'\n    end\n\n    -- Check that prefix has no more than 3 digits\n    local digit_count = 0\n    for i = 1, #prefix do\n        if prefix:sub(i, i):match(\"%d\") then\n            digit_count = digit_count + 1\n            if digit_count > 3 then\n                return 'No'\n            end\n        end\n    end\n\n    return 'Yes'\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = file_name_check\n    lu.assertEquals(candidate('example.txt'), 'Yes')\n    lu.assertEquals(candidate('1example.dll'), 'No')\n    lu.assertEquals(candidate('s1sdf3.asd'), 'No')\n    lu.assertEquals(candidate('K.dll'), 'Yes')\n    lu.assertEquals(candidate('MY16FILE3.exe'), 'Yes')\n    lu.assertEquals(candidate('His12FILE94.exe'), 'No')\n    lu.assertEquals(candidate('_Y.txt'), 'No')\n    lu.assertEquals(candidate('?aREYA.exe'), 'No')\n    lu.assertEquals(candidate('\/this_is_valid.dll'), 'No')\n    lu.assertEquals(candidate('this_is_valid.wow'), 'No')\n    lu.assertEquals(candidate('this_is_valid.txt'), 'Yes')\n    lu.assertEquals(candidate('this_is_valid.txtexe'), 'No')\n    lu.assertEquals(candidate('#this2_i4s_5valid.ten'), 'No')\n    lu.assertEquals(candidate('@this1_is6_valid.exe'), 'No')\n    lu.assertEquals(candidate('this_is_12valid.6exe4.txt'), 'No')\n    lu.assertEquals(candidate('all.exe.txt'), 'No')\n    lu.assertEquals(candidate('I563_No.exe'), 'Yes')\n    lu.assertEquals(candidate('Is3youfault.txt'), 'Yes')\n    lu.assertEquals(candidate('no_one#knows.dll'), 'Yes')\n    lu.assertEquals(candidate('1I563_Yes3.exe'), 'No')\n    lu.assertEquals(candidate('I563_Yes3.txtt'), 'No')\n    lu.assertEquals(candidate('final..txt'), 'No')\n    lu.assertEquals(candidate('final132'), 'No')\n    lu.assertEquals(candidate('_f4indsartal132.'), 'No')\n    lu.assertEquals(candidate('.txt'), 'No')\n    lu.assertEquals(candidate('s.'), 'No')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_142","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - cambià i entries in la tabela i cui indici hinn minga un multiplich de 3 o 4. La funzion la restituiss la somma de tucc i entries.- multiplo de 3 e el farà el cubo de l'entrera se l'indice l'è un multiplo de 4 e minga un multiplo de 3. La funzion la farà minga - Chësta funziun vëgnel metü a desposiziun na tabela de entiers.- \" -- >>> lst\n-- {1, 2, 3}\n-- >>> lst\n-- {}\n-- >>> lst\n-- {-1, -5, 2, -1, -5}\nlocal function sum_squares(lst)\n","canonical_solution":"local function sum_squares(lst)\n    local sum = 0\n    for i, v in ipairs(lst) do\n        if i % 3 == 0 then\n            sum = sum + v^2\n        elseif i % 4 == 0 then\n            sum = sum + v^3\n        else\n            sum = sum + v\n        end\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_squares\n    lu.assertEquals(candidate({1, 2, 3}), 6)\n    lu.assertEquals(candidate({1, 4, 9}), 14)\n    lu.assertEquals(candidate({}), 0)\n    lu.assertEquals(candidate({1, 1, 1, 1, 1, 1, 1, 1, 1}), 9)\n    lu.assertEquals(candidate({-1, -1, -1, -1, -1, -1, -1, -1, -1}), -3)\n    lu.assertEquals(candidate({0}), 0)\n    lu.assertEquals(candidate({-1, -5, 2, -1, -5}), -126)\n    lu.assertEquals(candidate({-56, -99, 1, 0, -2}), 3030)\n    lu.assertEquals(candidate({-1, 0, 0, 0, 0, 0, 0, 0, -1}), 0)\n    lu.assertEquals(candidate({-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}), -14196)\n    lu.assertEquals(candidate({-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}), -1448)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_143","nl":"lmo_Latn","pl":"lua","prompt":"- Esempio 1: - l'ordin di paroll in de la stringa növa el dovariss vess istess de quell originaal.- la cui lunghezza l'è di numer prim, - e te gh'è de rend una stringa che la gh'ha i paroll de la frase originaria, - la frase la gh'ha di paroll separàa de un spazzio, - Te gh'è una stringa che la rappresenta una frase,-- >>> words_in_sentence('This is a test')\n-- 'is'\n-- Example 2:\n-- >>> words_in_sentence('lets go for swimming')\n-- 'go for'\n-- Constraints:\n--     * 1 <= len(sentence) <= 100\n--     * sentence contains only letters\nlocal function words_in_sentence(sentence)\n","canonical_solution":"local function is_prime(n)\n    if n <= 1 then return false end\n    if n <= 3 then return true end\n    if n % 2 == 0 or n % 3 == 0 then return false end\n    for i = 5, math.floor(math.sqrt(n)), 6 do\n        if n % i == 0 or n % (i + 2) == 0 then\n            return false\n        end\n    end\n    return true\nend\n\nlocal function words_in_sentence(sentence)\n    local words = {}\n    for word in sentence:gmatch(\"%S+\") do\n        table.insert(words, word)\n    end\n    \n    local result = {}\n    for _, word in ipairs(words) do\n        if is_prime(#word) then\n            table.insert(result, word)\n        end\n    end\n    \n    return table.concat(result, \" \")\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = words_in_sentence\n    lu.assertEquals(candidate('This is a test'), 'is')\n    lu.assertEquals(candidate('lets go for swimming'), 'go for')\n    lu.assertEquals(candidate('there is no place available here'), 'there is no place')\n    lu.assertEquals(candidate('Hi I am Hussein'), 'Hi am Hussein')\n    lu.assertEquals(candidate('go for it'), 'go for it')\n    lu.assertEquals(candidate('here'), '')\n    lu.assertEquals(candidate('here is'), 'is')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_144","nl":"lmo_Latn","pl":"lua","prompt":"- Te pöl assumì che x, e n i è frazziun valid, e i gh'ha minga zéro come denominator.- <numerator>\/<denominator> indova sia numerator che denominator hinn di nümer intèrn pusìv.- altrimenti, sia x che n, i è na raprexentasiù stringa de na frazziù, e i gh'ha el format chì:- x * n. La funziun la torna véra se x * n la valüra a un nümer intèrn e fals - La tò compit l'è de implementà una funziun che la simplificherà l'espressiù -- >>> simplify('1\/5', '5\/1')\n-- true\n-- >>> simplify('1\/6', '2\/1')\n-- false\n-- >>> simplify('7\/10', '10\/2')\n-- false\nlocal function simplify(x, n)\n","canonical_solution":"local function simplify(x, n)\n    local function parseFraction(frac)\n        local num, denom = frac:match(\"(%d+)\/(%d+)\")\n        return tonumber(num), tonumber(denom)\n    end\n\n    local xn, xd = parseFraction(x)\n    local nn, nd = parseFraction(n)\n\n    local resultNumerator = xn * nn\n    local resultDenominator = xd * nd\n\n    return resultNumerator % resultDenominator == 0\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = simplify\n    lu.assertEquals(candidate('1\/5', '5\/1'), true)\n    lu.assertEquals(candidate('1\/6', '2\/1'), false)\n    lu.assertEquals(candidate('5\/1', '3\/1'), true)\n    lu.assertEquals(candidate('7\/10', '10\/2'), false)\n    lu.assertEquals(candidate('2\/10', '50\/10'), true)\n    lu.assertEquals(candidate('7\/2', '4\/2'), true)\n    lu.assertEquals(candidate('11\/6', '6\/1'), true)\n    lu.assertEquals(candidate('2\/3', '5\/2'), false)\n    lu.assertEquals(candidate('5\/2', '3\/5'), false)\n    lu.assertEquals(candidate('2\/4', '8\/4'), true)\n    lu.assertEquals(candidate('2\/4', '4\/2'), true)\n    lu.assertEquals(candidate('1\/5', '5\/1'), true)\n    lu.assertEquals(candidate('1\/5', '1\/5'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_145","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - ordenali in base al loro indice in tabela originale.- Nota: se gh'è di post con la summa di sò cifre uguale, - in ordinn ascendent in base a la somma di sò cifre. - Scriv una funziun che la ordena la tabela di intreg -- >>> order_by_points({1, 11, -1, -11, -12})\n-- {-1, -11, 1, -12, 11}\n-- >>> order_by_points({})\n-- {}\nlocal function order_by_points(nums)\n","canonical_solution":"local function order_by_points(nums)\n    local function digit_sum(num)\n        local sum = 0\n        num = math.abs(num)\n        while num > 0 do\n            sum = sum + (num % 10)\n            num = math.floor(num \/ 10)\n        end\n        return sum\n    end\n\n    table.sort(nums, function(a, b)\n        local sum_a = digit_sum(a)\n        local sum_b = digit_sum(b)\n        if sum_a == sum_b then\n            -- Preserve original order if digit sums are equal\n            return false\n        else\n            return sum_a < sum_b\n        end\n    end)\n\n    return nums\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = order_by_points\n    lu.assertEquals(candidate({1, 11, -1, -11, -12}), {-1, -11, 1, -12, 11})\n    lu.assertEquals(candidate({1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, -11, -32, 43, 54, -98, 2, -3}), {-3, -32, -98, -11, 1, 2, 43, 54})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9})\n    lu.assertEquals(candidate({0, 6, 6, -76, -21, 23, 4}), {-76, -21, 0, 4, 23, 6, 6})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_146","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - la prima e l'ultima cifre de un numer hinn dispari (1, 3, 5, 7, 9).- el numer di element de la tabela che hinn püsee de 10 e tutt e duu - Scriv una funziun che la piglia una tabela di numer come input e la torna -- >>> specialFilter({15, -73, 14, -15})\n-- 1\n-- >>> specialFilter({33, -2, -3, 45, 21, 109})\n-- 2\nlocal function specialFilter(nums)\n","canonical_solution":"local function isOddDigit(num)\n    local digit = num % 10\n    return digit % 2 == 1\nend\n\nlocal function specialFilter(nums)\n    local count = 0\n    for _, num in ipairs(nums) do\n        local absNum = math.abs(num)\n        if absNum > 10 then\n            local firstDigit = tonumber(tostring(absNum):sub(1, 1))\n            local lastDigit = absNum % 10\n            if isOddDigit(firstDigit) and isOddDigit(lastDigit) then\n                count = count + 1\n            end\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = specialFilter\n    lu.assertEquals(candidate({5, -2, 1, -5}), 0)\n    lu.assertEquals(candidate({15, -73, 14, -15}), 1)\n    lu.assertEquals(candidate({33, -2, -3, 45, 21, 109}), 2)\n    lu.assertEquals(candidate({43, -12, 93, 125, 121, 109}), 4)\n    lu.assertEquals(candidate({71, -2, -33, 75, 21, 19}), 3)\n    lu.assertEquals(candidate({1}), 0)\n    lu.assertEquals(candidate({}), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_147","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi:- e a[i] + a[j] + a[k] l'è un multiplo de 3. - Ritorna el numer de triplet (a[i], a[j], a[k]) de a indove i < j < k, - per ogni i (1 ≤ i ≤ n), el valor de a[i] = i * i - i + 1. - Te gh'è un intèr positif n. Te gh'è de creà ona tabèla de intèr a de longhesa n.--     >>> get_max_triples(5)\n--     1\n-- Explanation: \n-- a = [1, 3, 7, 13, 21]\n-- The only valid triple is (1, 7, 13).\nlocal function get_max_triples(n)\n","canonical_solution":"local function get_max_triples(n)\n    local a = {}\n    for i = 1, n do\n        a[i] = i * i - i + 1\n    end\n\n    local count = 0\n    for i = 1, n - 2 do\n        for j = i + 1, n - 1 do\n            for k = j + 1, n do\n                if (a[i] + a[j] + a[k]) % 3 == 0 then\n                    count = count + 1\n                end\n            end\n        end\n    end\n\n    return count\nend\n\n-- Example Usage:\n-- print(get_max_triples(5)) -- Output: 1","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_max_triples\n    lu.assertEquals(candidate(5), 1)\n    lu.assertEquals(candidate(6), 4)\n    lu.assertEquals(candidate(10), 36)\n    lu.assertEquals(candidate(100), 53361)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_148","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi - i nòm dei pianèti i è minga giust.- La funziun la dovariss rend una tàula vuda se planet1 o planet2 - la vicinanza al sol.- situà tra l'orbita del pianeta 1 e l'orbita del pianeta 2, ordinà per - La funziun la dovariss rend una tabela cont i pianètt che i sò orbita i è - Scriv una funziun che la piglia i nom de duu pianeta come stringa planet1 e planet2. - Urano, Nettuno.- l'è Mercurio, l'altra l'è Vènere, po' la Tèra, Marte, Giove, Saturno,- A gh'è otto pianètt in del nòst sistema solar: i piö vicin al Sol.-- >>> bf('Jupiter', 'Neptune')\n-- {'Saturn', 'Uranus'}\n-- >>> bf('Earth', 'Mercury')\n-- 'Venus'\n-- >>> bf('Mercury', 'Uranus')\n-- {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'}\nlocal function bf(planet1, planet2)\n","canonical_solution":"local function bf(planet1, planet2)\n    local planets = {\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    }\n    \n    local planet_index = {}\n    for i, planet in ipairs(planets) do\n        planet_index[planet] = i\n    end\n    \n    local index1 = planet_index[planet1]\n    local index2 = planet_index[planet2]\n    \n    if not index1 or not index2 then\n        return {}\n    end\n    \n    local start_index = math.min(index1, index2) + 1\n    local end_index = math.max(index1, index2) - 1\n    \n    local result = {}\n    for i = start_index, end_index do\n        table.insert(result, planets[i])\n    end\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter', 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_149","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - Te pòdet pensà che tüte le paròle i gh'avarà la stesa longhesa.- La funziun la dovariss rend una tabella de strings in ordin ordinad.- Se dü parol i gh'han la stesa lunghesa, ordinè la tabela in ordine alfabetico.- dovrà rendere la tabella ordinata secondo la regola.- L'òrdine de la tàula al dovrà ascendè per longhè de ogni paròla, e tu...- e pò cuntènn duplicàt.- La tàula l'è sèmper 'na tàula de strìnghe e mai 'na tàula de nùmer,- e restituisce la tabella risultante con un ordine ordinato, - scartà i string che gh'hann longhess dispari, - Scriv una funziun che accetta una tabella de string come parameter, -- >>> list_sort({'aa', 'a', 'aaa'})\n-- {'aa'}\n-- >>> list_sort({'ab', 'a', 'aaa', 'cd'})\n-- {'ab', 'cd'}\nlocal function sorted_list_sum(lst)\n","canonical_solution":"local function list_sort(tbl)\n    local function is_even_length(s)\n        return #s % 2 == 0\n    end\n\n    local function compare_strings(a, b)\n        if #a == #b then\n            return a < b\n        else\n            return #a < #b\n        end\n    end\n\n    local result = {}\n    for _, v in ipairs(tbl) do\n        if is_even_length(v) then\n            table.insert(result, v)\n        end\n    end\n\n    table.sort(result, compare_strings)\n\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_150","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - un nùmer prim e al dovrà rendèr al valōr di y altrimenti. - Un programm simpl che el dovariss rend el valor de x se n l'è -- >>> x_or_y(7, 34, 12)\n-- 34\n-- >>> x_or_y(15, 8, 5)\n-- 5\nlocal function x_or_y(n, x, y)\n","canonical_solution":"local function is_prime(num)\n    if num <= 1 then\n        return false\n    end\n    for i = 2, math.sqrt(num) do\n        if num % i == 0 then\n            return false\n        end\n    end\n    return true\nend\n\nlocal function x_or_y(n, x, y)\n    if is_prime(n) then\n        return x\n    else\n        return y\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = x_or_y\n    lu.assertEquals(candidate(7, 34, 12), 34)\n    lu.assertEquals(candidate(15, 8, 5), 5)\n    lu.assertEquals(candidate(3, 33, 5212), 33)\n    lu.assertEquals(candidate(1259, 3, 52), 3)\n    lu.assertEquals(candidate(7919, -1, 12), -1)\n    lu.assertEquals(candidate(3609, 1245, 583), 583)\n    lu.assertEquals(candidate(91, 56, 129), 129)\n    lu.assertEquals(candidate(6, 34, 1234), 1234)\n    lu.assertEquals(candidate(1, 2, 0), 0)\n    lu.assertEquals(candidate(2, 2, 0), 2)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_151","nl":"lmo_Latn","pl":"lua","prompt":"- in la tabela che i è dispari. Ignorè i numer che i è negativ o che i è minga intger.- Dàt una tàula di nùmer, riturnà la soma di quadrà di nùmer -- >>> double_the_difference({1, 3, 2, 0})\n-- 10\n-- >>> double_the_difference({-1, -2, 0})\n-- 0\n-- >>> double_the_difference({9, -2})\n-- 81\n-- >>> double_the_difference({0})\n-- 0\n-- If the input table is empty, return 0.\nlocal function double_the_difference(lst)\n","canonical_solution":"local function double_the_difference(lst)\n    local sum = 0\n    for _, num in ipairs(lst) do\n        if type(num) == \"number\" and num >= 0 and num % 1 == 0 and num % 2 == 1 then\n            sum = sum + num * num\n        end\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = double_the_difference\n    lu.assertEquals(candidate({}), 0)\n    lu.assertEquals(candidate({5.0, 4.0}), 25)\n    lu.assertEquals(candidate({0.1, 0.2, 0.3}), 0)\n    lu.assertEquals(candidate({-10.0, -20.0, -30.0}), 0)\n    lu.assertEquals(candidate({-1.0, -2.0, 8.0}), 0)\n    lu.assertEquals(candidate({0.2, 3.0, 5.0}), 34)\n    lu.assertEquals(candidate({-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0}), 165)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_152","nl":"lmo_Latn","pl":"lua","prompt":"- esempi: - el valur l'è 0, e se no, el valur l'è la diferenza assoluta tra la scomessa e la puntaa.- Rend una tabela de la stessa lunghesa che indica quant'è lontana ogni indovinazion.- Te se dà dò tabèl de puntegh e de indovin de longhessa eguale, indova ogni indici el mostra una partita.- Al tò compit a l'é 'd determiné se na persona a l'ha giustà ij risultà ëd na serie de partìe.- val sicurament la pena de notà e de confrontà.- l'event l'è finalmente cognossuu.- I pens che i se ricordàss tütt de quell' sensazion quand el risultà de qualch tant aspetàa-- >>> compare({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2})\n-- {0, 0, 0, 0, 3, 3}\n-- >>> compare({0, 5, 0, 0, 0, 4}, {4, 1, 1, 0, 0, -2})\n-- {4, 4, 1, 0, 0, 6}\nlocal function compare(game, guess)\n","canonical_solution":"local function compare(game, guess)\n    local differences = {}\n    for i = 1, #game do\n        if game[i] == guess[i] then\n            differences[i] = 0\n        else\n            differences[i] = math.abs(game[i] - guess[i])\n        end\n    end\n    return differences\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = compare\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2}), {0, 0, 0, 0, 3, 3})\n    lu.assertEquals(candidate({0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}), {0, 0, 0, 0, 0, 0})\n    lu.assertEquals(candidate({1, 2, 3}, {-1, -2, -3}), {2, 4, 6})\n    lu.assertEquals(candidate({1, 2, 3, 5}, {-1, 2, 3, 4}), {2, 0, 0, 1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_153","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - (la sò forza l'è -1).- return \"Slices.SERVINGSliCes\" since \"SERVINGSliCes\" is the strongest extension - estensiù: ['SErviNGSliCes', 'Cheese', 'StuFfed'] alura te dovarès - Per esempi, se te se dà \"Slices\" come la classe e una tabella del - scelgi quella che la vegn prima in tabela.- Se gh' è du o piö estensiù de la stesa forza, te dovarès- format: ClassName.StrongestExtensionName. - Te dovarès trovà l' estension piö fòrta e rendì una stringa in questa .- in del nomm de l'estensiun, la forza l'è dada de la frazion CAP - SM. - lettere nel nome dell'estensione, e SM sia il numero di lettere minuscole - la forza de l'estensiun l'è la seguente: CAP l'è el numer de la majuscula - L'estensiun la va doprada per carghè le class adisiunari a la class.- Te vegnarà dà el nom de una classe (una stringa) e una tabela de estension.-- >>> Strongest_Extension('my_class', {'AA', 'Be', 'CC'})\n-- 'my_class.AA'\nlocal function Strongest_Extension(class_name, extensions)\n","canonical_solution":"local function Strongest_Extension(class_name, extensions)\n    local strongest_extension = nil\n    local max_strength = nil\n\n    for _, extension in ipairs(extensions) do\n        local cap = 0\n        local sm = 0\n        for i = 1, #extension do\n            local char = extension:sub(i, i)\n            if char:match(\"%u\") then\n                cap = cap + 1\n            elseif char:match(\"%l\") then\n                sm = sm + 1\n            end\n        end\n        local strength = cap - sm\n        if max_strength == nil or strength > max_strength then\n            max_strength = strength\n            strongest_extension = extension\n        end\n    end\n\n    return class_name .. \".\" .. strongest_extension\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = Strongest_Extension\n    lu.assertEquals(candidate('Watashi', {'tEN', 'niNE', 'eIGHt8OKe'}), 'Watashi.eIGHt8OKe')\n    lu.assertEquals(candidate('Boku123', {'nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg'}), 'Boku123.YEs.WeCaNe')\n    lu.assertEquals(candidate('__YESIMHERE', {'t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321'}), '__YESIMHERE.NuLl__')\n    lu.assertEquals(candidate('K', {'Ta', 'TAR', 't234An', 'cosSo'}), 'K.TAR')\n    lu.assertEquals(candidate('__HAHA', {'Tab', '123', '781345', '-_-'}), '__HAHA.123')\n    lu.assertEquals(candidate('YameRore', {'HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-'}), 'YameRore.okIWILL123')\n    lu.assertEquals(candidate('finNNalLLly', {'Die', 'NowW', 'Wow', 'WoW'}), 'finNNalLLly.WoW')\n    lu.assertEquals(candidate('_', {'Bb', '91245'}), '_.Bb')\n    lu.assertEquals(candidate('Sp', {'671235', 'Bb'}), 'Sp.671235')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_154","nl":"lmo_Latn","pl":"lua","prompt":"- Te gh'è dàd 2 paròle. Te gh'è da rendèr true se la segonda paròla o qualunque de i sò rotazion l'è una sotstringa de la prima paròla.-- >>> cycpattern_check('abcd', 'abd')\n-- false\n-- >>> cycpattern_check('hello', 'ell')\n-- true\n-- >>> cycpattern_check('whassup', 'psus')\n-- false\n-- >>> cycpattern_check('abab', 'baa')\n-- true\n-- >>> cycpattern_check('efef', 'eeff')\n-- false\n-- >>> cycpattern_check('himenss', 'simen')\n-- true\nlocal function cycpattern_check(a, b)\n","canonical_solution":"local function is_rotation(s1, s2)\n    return #s1 == #s2 and (s1 .. s1):find(s2) ~= nil\nend\n\nlocal function generate_rotations(s)\n    local rotations = {}\n    for i = 1, #s do\n        local rotation = s:sub(i) .. s:sub(1, i-1)\n        table.insert(rotations, rotation)\n    end\n    return rotations\nend\n\nlocal function cycpattern_check(a, b)\n    local rotations = generate_rotations(b)\n    for _, rotation in ipairs(rotations) do\n        if a:find(rotation) then\n            return true\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = cycpattern_check\n    lu.assertEquals(candidate('xyzw', 'xyw'), false)\n    lu.assertEquals(candidate('yello', 'ell'), true)\n    lu.assertEquals(candidate('whattup', 'ptut'), false)\n    lu.assertEquals(candidate('efef', 'fee'), true)\n    lu.assertEquals(candidate('abab', 'aabb'), false)\n    lu.assertEquals(candidate('winemtt', 'tinem'), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_155","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Given an integer. return a table that has the number of even and odd digits respectively. --     >>> even_odd_count(-12)\n--     {1, 1}\n--     >>> even_odd_count(123)\n--     {1, 2}\nlocal function even_odd_count(num)\n","canonical_solution":"local function even_odd_count(num)\n    local even_count, odd_count = 0, 0\n    num = math.abs(num)  -- remove the sign of the number\n    while num > 0 do\n        local digit = num % 10\n        if digit % 2 == 0 then\n            even_count = even_count + 1\n        else\n            odd_count = odd_count + 1\n        end\n        num = math.floor(num \/ 10)\n    end\n    return {even_count, odd_count}\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = even_odd_count\n    lu.assertEquals(candidate(7), {0, 1})\n    lu.assertEquals(candidate(-78), {1, 1})\n    lu.assertEquals(candidate(3452), {2, 2})\n    lu.assertEquals(candidate(346211), {3, 3})\n    lu.assertEquals(candidate(-345821), {3, 3})\n    lu.assertEquals(candidate(-2), {1, 0})\n    lu.assertEquals(candidate(-45347), {2, 3})\n    lu.assertEquals(candidate(0), {1, 0})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_156","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - Restrizion: 1 <= num <= 1000- e la torna in minuscol.- Dàt un nùmer intèrn pusìv, otèint l'equivalènt numèrich romàṅ in na strìnga, -- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n-- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n","canonical_solution":"local function int_to_mini_roman(number)\n    local roman_numerals = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n    \n    local result = {}\n    for _, value_pair in ipairs(roman_numerals) do\n        local value, symbol = unpack(value_pair)\n        while number >= value do\n            number = number - value\n            table.insert(result, symbol)\n        end\n    end\n    \n    return table.concat(result)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_157","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - 90°. - Oh, oh, oh, oh.- Un triàngol a vènt drèta l'è un triàngol indóe un vènt l'è vènt drèta o- i lati forman un triangol rettangol, altrimenti è fals.- DATE LE LUNGE DI TRE LATI DI UN TRIGLANGOLO.-- >>> right_angle_triangle(3, 4, 5)\n-- true\n-- >>> right_angle_triangle(1, 2, 3)\n-- false\nlocal function right_angle_triangle(a, b, c)\n","canonical_solution":"local function right_angle_triangle(a, b, c)\n    -- Sort the sides to make sure we always compare the largest with the sum of squares of the other two\n    local sides = {a, b, c}\n    table.sort(sides)\n\n    -- Check the Pythagorean theorem\n    return sides[1]^2 + sides[2]^2 == sides[3]^2\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = right_angle_triangle\n    lu.assertEquals(candidate(3, 4, 5), true)\n    lu.assertEquals(candidate(1, 2, 3), false)\n    lu.assertEquals(candidate(10, 6, 8), true)\n    lu.assertEquals(candidate(2, 2, 2), false)\n    lu.assertEquals(candidate(7, 24, 25), true)\n    lu.assertEquals(candidate(10, 5, 7), false)\n    lu.assertEquals(candidate(5, 12, 13), true)\n    lu.assertEquals(candidate(15, 8, 17), true)\n    lu.assertEquals(candidate(48, 55, 73), true)\n    lu.assertEquals(candidate(1, 1, 1), false)\n    lu.assertEquals(candidate(2, 2, 10), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_158","nl":"lmo_Latn","pl":"lua","prompt":"- i caratteri, torna quell che l'è primm in ordinanza lessicografica. - di caratteri unici. Se strings plurali gh'hann el numm massim de caratteri unici - La tabella la gh'ha di paroll diferent, rend la parola con el numeral massim.- Scriv una funziun che accetta una tabela de string.-- >>> find_max({'name', 'of', 'string'})\n-- 'string'\n-- >>> find_max({'name', 'enam', 'game'})\n-- 'enam'\n-- >>> find_max({'aaaaaaa', 'bb', 'cc'})\n-- 'aaaaaaa'\nlocal function find_max(words)\n","canonical_solution":"local function find_max(words)\n    local function unique_characters_count(word)\n        local char_set = {}\n        for char in word:gmatch('.') do\n            char_set[char] = true\n        end\n        local count = 0\n        for _ in pairs(char_set) do\n            count = count + 1\n        end\n        return count\n    end\n\n    local max_word = ''\n    local max_unique_count = 0\n\n    for _, word in ipairs(words) do\n        local unique_count = unique_characters_count(word)\n        if unique_count > max_unique_count or (unique_count == max_unique_count and word < max_word) then\n            max_word = word\n            max_unique_count = unique_count\n        end\n    end\n\n    return max_word\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_max\n    lu.assertEquals(candidate({'name', 'of', 'string'}), 'string')\n    lu.assertEquals(candidate({'name', 'enam', 'game'}), 'enam')\n    lu.assertEquals(candidate({'aaaaaaa', 'bb', 'cc'}), 'aaaaaaa')\n    lu.assertEquals(candidate({'abc', 'cba'}), 'abc')\n    lu.assertEquals(candidate({'play', 'this', 'game', 'of', 'footbott'}), 'footbott')\n    lu.assertEquals(candidate({'we', 'are', 'gonna', 'rock'}), 'gonna')\n    lu.assertEquals(candidate({'we', 'are', 'a', 'mad', 'nation'}), 'nation')\n    lu.assertEquals(candidate({'this', 'is', 'a', 'prrk'}), 'this')\n    lu.assertEquals(candidate({'b'}), 'b')\n    lu.assertEquals(candidate({'play', 'play', 'play'}), 'play')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_159","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi: - se no gh'è abbastanza carote restante, te mangerai tüte le carote restante, ma te gh'avarè semper fame.- la quantità de carote che t'è restada dòpo i mangià] - ti devi rendì una tabella di [ numero totale di carote mangiate dopo i pasti, - ma adess te gh'hee de mangià de pù de carote per completà i mangià del dì.- Te sì un cunìll famùs, e te sì già mangiàt un cert nùmer de carote,-- >>> eat(5, 6, 10)\n-- {11, 4}\n-- >>> eat(4, 8, 9)\n-- {12, 1}\n-- >>> eat(1, 10, 10)\n-- {11, 0}\n-- >>> eat(2, 11, 5)\n-- {7, 0}\n-- Variables:\n-- @number : integer\n--     the number of carrots that you have eaten.\n-- @need : integer\n--     the number of carrots that you need to eat.\n-- @remaining : integer\n--     the number of remaining carrots thet exist in stock\n-- Constrain:\n-- * 0 <= number <= 1000\n-- * 0 <= need <= 1000\n-- * 0 <= remaining <= 1000\n-- Have fun :)\nlocal function eat(number, need, remaining)\n","canonical_solution":"local function eat(number, need, remaining)\n    local totalEaten\n    local leftOver\n    \n    if remaining >= need then\n        totalEaten = number + need\n        leftOver = remaining - need\n    else\n        totalEaten = number + remaining\n        leftOver = 0\n    end\n    \n    return {totalEaten, leftOver}\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = eat\n    lu.assertEquals(candidate(5, 6, 10), {11, 4})\n    lu.assertEquals(candidate(4, 8, 9), {12, 1})\n    lu.assertEquals(candidate(1, 10, 10), {11, 0})\n    lu.assertEquals(candidate(2, 11, 5), {7, 0})\n    lu.assertEquals(candidate(4, 5, 7), {9, 2})\n    lu.assertEquals(candidate(4, 5, 1), {5, 0})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_160","nl":"lmo_Latn","pl":"lua","prompt":"- La tàula de l'operadùr la gh'ha almanch un operadùr, e la tàula de l'operand la gh'ha almanch du operand.- L'operand a l'è una tabella de de intèrn no-negativ.- La lunghesa de la tabela de l'operador l'è uguala a la lunghesa de la tabela de l'operand meno un.- Nota: - => result = 9 - result = 2 + 3 * 4 - 5 - tabella = [2, 3, 4, 5] - operador['+', '*', '-'] - Esempi: - Esponenziament (**) - Divisiù del pavimènt ( \/\/) - Multiplicazion (*) - Sottrazion ( - ) - Addizion (+) - L'operaziù de base de l'algebra:- espressione e restituisce la valutazion de questa espressione.- la segonda tabella l'è una tabella di intreg.- Dàt dò tabèl operadùr e operand.local function do_algebra(operator, operand)\n","canonical_solution":"local function do_algebra(operator, operand)\n    local expression = tostring(operand[1])\n    \n    for i = 1, #operator do\n        expression = expression .. \" \" .. operator[i] .. \" \" .. operand[i+1]\n    end\n    \n    return load(\"return \" .. expression)()\nend\n\n-- Example usage:\n-- local operator = {'+', '*', '-'}\n-- local operand = {2, 3, 4, 5}\n-- local result = do_algebra(operator, operand)\n-- print(result) -- Output: 9","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = do_algebra\n    lu.assertEquals(candidate({'**', '*', '+'}, {2, 3, 4, 5}), 37)\n    lu.assertEquals(candidate({'+', '*', '-'}, {2, 3, 4, 5}), 9)\n    lu.assertEquals(candidate({'\/\/', '*'}, {7, 3, 4}), 8)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_161","nl":"lmo_Latn","pl":"lua","prompt":"- Esempi - La funziun la dovariss rend la stringa resultant.- Se la stringa la gh'ha minga de letere, inversa la stringa.- se no la lassa restà come l'è.- se s[i] l'è una lètera, inversa la sò cassa da bas a su o viceversa,- Te gh'è 'na stringa de s.-- >>> solve('1234')\n-- '4321'\n-- >>> solve('ab')\n-- 'AB'\n-- >>> solve('#a@C')\n-- '#A@c'\nlocal function solve(s)\n","canonical_solution":"local function solve(s)\n  local has_letters = false\n  local result = {}\n  \n  for i = 1, #s do\n    local char = s:sub(i, i)\n    if char:match(\"%a\") then\n      has_letters = true\n      if char:lower() == char then\n        table.insert(result, char:upper())\n      else\n        table.insert(result, char:lower())\n      end\n    else\n      table.insert(result, char)\n    end\n  end\n  \n  if has_letters then\n    return table.concat(result)\n  else\n    return s:reverse()\n  end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = solve\n    lu.assertEquals(candidate('AsDf'), 'aSdF')\n    lu.assertEquals(candidate('1234'), '4321')\n    lu.assertEquals(candidate('ab'), 'AB')\n    lu.assertEquals(candidate('#a@C'), '#A@c')\n    lu.assertEquals(candidate('#AsdfW^45'), '#aSDFw^45')\n    lu.assertEquals(candidate('#6@2'), '2@6#')\n    lu.assertEquals(candidate('#$a^D'), '#$A^d')\n    lu.assertEquals(candidate('#ccc'), '#CCC')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_162","nl":"lmo_Latn","pl":"lua","prompt":"- Se 'text' l'è ona stringa vuda, torna nil. - Given a string 'text', return its md5 hash equivalent string. -- >>> string_to_md5('Hello world')\n-- '3e25960a79dbc69b674cd4ec67a72c62'\nlocal function string_to_md5(text)\n","canonical_solution":"local md5 = require(\"md5\")\n\nlocal function string_to_md5(text)\n    if text == \"\" then\n        return nil\n    end\n    return md5.sumhexa(text)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_to_md5\n    lu.assertEquals(candidate('Hello world'), '3e25960a79dbc69b674cd4ec67a72c62')\n    lu.assertEquals(candidate(''), None)\n    lu.assertEquals(candidate('A B C'), '0ef78513b0cb8cef12743f5aeb35f888')\n    lu.assertEquals(candidate('password'), '5f4dcc3b5aa765d61d8327deb882cf99')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_163","nl":"lmo_Latn","pl":"lua","prompt":"- Per esempi: - e b, in ordine ascendente.- Dàt dò intèrn pusìb a e b, rend i díg de pari tra a e b.-- >>> generate_integers(2, 8)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(8, 2)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(10, 14)\n-- {}\nlocal function generate_integers(a, b)\n","canonical_solution":"local function generate_integers(a, b)\n    local evens = {}\n    local start, finish = math.min(a, b), math.max(a, b)\n    \n    for i = start, finish do\n        if i % 2 == 0 then\n            table.insert(evens, i)\n        end\n    end\n    \n    return evens\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = generate_integers\n    lu.assertEquals(candidate(2, 10), {2, 4, 6, 8})\n    lu.assertEquals(candidate(10, 2), {2, 4, 6, 8})\n    lu.assertEquals(candidate(132, 2), {2, 4, 6, 8})\n    lu.assertEquals(candidate(17, 89), {})\nend\n\nos.exit(lu.LuaUnit.run())"}]