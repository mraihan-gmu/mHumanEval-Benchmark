task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,kbp_Latn,rb,"Pɩtɛ kɩlɛmʋʋ yɔɔ.Pɩsa nɛ ɖɩtɩlɩ se ɖɩkpaɣ ɛzɩ mayaɣ ŋga yɔ, ɖɩnaɣ se mayaɣ ŋga kɛwɛna ndɩ nɛ mayaɣ ŋga.# >>> has_close_elements.call([1.0, 2.0, 3.0], 0.5)
# false
# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
# true
def has_close_elements(numbers, threshold)
","def has_close_elements(numbers, threshold)
  numbers.combination(2).any? { |a, b| (a - b).abs < threshold }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_has_close_elements
    candidate = method(:has_close_elements)
    assert_equal(true, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))
    assert_equal(false, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))
    assert_equal(true, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95))
    assert_equal(false, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8))
    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1))
    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0))
    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))
  end
end
"
HumanEval_1,kbp_Latn,rb,"Taawɛɛna kɩ-tɛ matʋ natʋyʋ.Kpɛndɩɣna ɖama nɛ pɩfɛyɩna ɖama taa nɛ pɩfɛyɩna ɖama taa nɛ pɩfɛyɩna ɖama taa.Pɩtɛ lɛ, ŋpɩzɩɣ ŋlɩzɩ tɔmpiye nɖɩ nɛ ŋyele nɛ ɖɩpɩsɩ tɔmpiye nɖɩ ɖɩ-tɛ matʋ.Tʊma ana a-tɛ pɩlɩna ɛyʊ kʊyʊmʊm tɛ kʊyʊmʊm tɛ kʊyʊmʊm tɛ kʊyʊmʊm tɛ kʊyʊmʊm tɛ kʊyʊmʊm tɛ kʊyʊmʊm tɛ kʊyʊmʊm.# >>> separate_paren_groups.call(""( ) (( )) (( )( ))"")
# [""()"", ""(())"", ""(()())""]
def separate_paren_groups(paren_string)
","def separate_paren_groups(paren_string)
  # Remove spaces from the string
  paren_string = paren_string.gsub("" "", """")
  
  result = []
  current_group = """"
  balance = 0

  paren_string.each_char do |char|
    current_group += char
    balance += 1 if char == '('
    balance -= 1 if char == ')'

    if balance == 0 && !current_group.empty?
      result << current_group
      current_group = """"
    end
  end

  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_separate_paren_groups
    candidate = method(:separate_paren_groups)
    assert_equal([""(()())"", ""((()))"", ""()"", ""((())()())""], candidate.call(""(()()) ((())) () ((())()())""))
    assert_equal([""()"", ""(())"", ""((()))"", ""(((())))""], candidate.call(""() (()) ((())) (((())))""))
    assert_equal([""(()(())((())))""], candidate.call(""(()(())((())))""))
    assert_equal([""()"", ""(())"", ""(()())""], candidate.call(""( ) (( )) (( )( ))""))
  end
end
"
HumanEval_2,kbp_Latn,rb,"Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ: (C.1)(Paa ɛzɩmtaa lɛ, pɩkazɩ hɔɔlʋʋ ŋgʋ kɩkɩlɩɣ 1 yɔ).nɛ ɛyʊ hɔɔlʊʊ (ɛyʊ kɩlɩm hɔɔlʊʊ ŋgʊ kɩ-taa ɛfɛyɩ yɔ) nɛ decimals Ye ɖɩkpaɣ nɛ ɖɩkpaɣ floatɩyɔm nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ.# >>> truncate_number.call(3.5)
# 0.5
def truncate_number(number)
","def truncate_number(number)
  number - number.to_i
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_truncate_number
    candidate = method(:truncate_number)
    assert_equal(0.5, candidate.call(3.5))
    assert_equal(0.25, candidate.call(1.25))
    assert_equal(0.0, candidate.call(123.0))
  end
end
"
HumanEval_3,kbp_Latn,rb,"Pɩtɛ lɛ, pɩpɩsɩɣ false.Pɩwɛɛ se ŋtɩlɩ mbʋ pɩ-yɔɔ ŋtɩŋna nɛ ŋla tʋmɩyɛ nɖɩ yɔ.Pʊtɔbʊʊ se ŋha-ŋ liidiye nɛ ŋhɛyɩ-ɖɩ liidiye nɖɩ ŋwɛna yɔ ɖɩ-taa.# >>> below_zero.call([1, 2, 3])
# false
# >>> below_zero.call([1, 2, -4, 5])
# true
def below_zero(operations)
","def below_zero(operations)
  balance = 0
  operations.each do |operation|
    balance += operation
    return true if balance < 0
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_below_zero
    candidate = method(:below_zero)
    assert_equal(false, candidate.call([]))
    assert_equal(false, candidate.call([1, 2, -3, 1, 2, -3]))
    assert_equal(true, candidate.call([1, 2, -4, 5, 6]))
    assert_equal(false, candidate.call([1, -1, 2, -2, 5, -5, 4, -4]))
    assert_equal(true, candidate.call([1, -1, 2, -2, 5, -5, 4, -5]))
    assert_equal(true, candidate.call([1, -2, 2, -2, 5, -5, 4, -4]))
  end
end
"
HumanEval_4,kbp_Latn,rb,"MAD = average. x - x_mean. Ɛyʊ nɛ ɛ-tɛ cɛcɛsɩ (ɛzɩma pɩwɛ yɔ, pɩkɛna ɛ-tɛ cɛcɛsɩ): Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.Pɩtɛ tɔmpiye nɖɩ ɖɩ-taa pama tɔmpiye nɖɩ yɔ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa pama tɔmpiye nɖɩ yɔ.Pɩcɔ nɛ ŋpɩzɩ ŋlɩzɩ kɩ-tɛ lɛɣzʋʋ lɛ, ŋpɩzɩɣ ŋlɩzɩ kɩ-tɛ lɛɣzʋʋ kɩ-tɛ lɛɣzʋʋ.# >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])
# 1.0
def mean_absolute_deviation(numbers)
","def mean_absolute_deviation(numbers)
  mean = numbers.sum.to_f / numbers.size
  deviations = numbers.map { |num| (num - mean).abs }
  deviations.sum / numbers.size
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_mean_absolute_deviation
    candidate = method(:mean_absolute_deviation)
    assert_equal(0.5, candidate.call([1.0, 2.0]))
    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))
    assert_equal(1.2, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))
  end
end
"
HumanEval_5,kbp_Latn,rb,"Pɩsɩ takayɩhayʋʋ ""Tɔm ndʋ tɩ-taa paayɔɔdɩ tɔmpiye nɖɩ yɔ"" ñɩŋgʋ yɔɔ.# >>> intersperse.call([], 4)
# []
# >>> intersperse.call([1, 2, 3], 4)
# [1, 4, 2, 4, 3]
def intersperse(numbers, delimeter)
","def intersperse(numbers, delimeter)
  return numbers if numbers.empty?
  result = []
  numbers.each_with_index do |num, index|
    result << num
    result << delimeter unless index == numbers.size - 1
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_intersperse
    candidate = method(:intersperse)
    assert_equal([], candidate.call([], 7))
    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))
    assert_equal([2, 2, 2, 2, 2], candidate.call([2, 2, 2], 2))
  end
end
"
HumanEval_6,kbp_Latn,rb,"Ɖɩkpaɣ ɛzɩ (() (()) yɔ, pɩtalɩɣ nabʊlɛ nɛ pɩtalɩ nabʊlɛ nɛ ((())) lɛ, nabʊlɛ.Paa samaɣ ŋga lɛ, ka-taa lɛ, ŋlɩzɩ ka-taa tɔm kɩcɛyɩtʋ ndʋ tɩ-taa ŋpɩzɩɣ nɛ ŋla yɔ.Tʊma ana a-tɛ pɩlɩna ɛyʊ kʊyʊmʊm yɔɔ nɛ ɛ-tɛ kʊyʊmʊm tɛ kʊyʊmʊm yɔɔ.# >>> parse_nested_parens.call(""(()()) ((())) () ((())()())"")
# [2, 3, 1, 3]
def parse_nested_parens(paren_string)
","def parse_nested_parens(paren_string)
  paren_string.split.map do |group|
    max_depth = current_depth = 0
    group.chars.each do |char|
      if char == '('
        current_depth += 1
        max_depth = [max_depth, current_depth].max
      elsif char == ')'
        current_depth -= 1
      end
    end
    max_depth
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_parse_nested_parens
    candidate = method(:parse_nested_parens)
    assert_equal([2, 3, 1, 3], candidate.call(""(()()) ((())) () ((())()())""))
    assert_equal([1, 2, 3, 4], candidate.call(""() (()) ((())) (((())))""))
    assert_equal([4], candidate.call(""(()(())((())))""))
  end
end
"
HumanEval_7,kbp_Latn,rb,"Pɩsɩ takayɩhayʋʋ kɩsɛsɛtʊ ñɩŋgʋ yɔɔ .# >>> filter_by_substring.call([], ""a"")
# []
# >>> filter_by_substring.call([""abc"", ""bacd"", ""cde"", ""array""], ""a"")
# [""abc"", ""bacd"", ""array""]
def filter_by_substring(strings, substring)
","def filter_by_substring(strings, substring)
  strings.select { |string| string.include?(substring) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_by_substring
    candidate = method(:filter_by_substring)
    assert_equal([], candidate.call([], ""john""))
    assert_equal([""xxx"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""))
    assert_equal([""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xx""))
    assert_equal([""grunt"", ""prune""], candidate.call([""grunt"", ""trumpet"", ""prune"", ""gruesome""], ""run""))
  end
end
"
HumanEval_8,kbp_Latn,rb,"Pɩwɛɛ se pɛtɛyɩ kɩ-taa kɩ-tɩ yɔɔ nɛ kɩ-taa kɩ-tɩ yɔɔ nɛ kɩ-taa kɩ-tɩ yɔɔ nɛ kɩ-taa kɩ-tɩ yɔɔ nɛ kɩ-taa kɩ-tɩ yɔɔ.Pɩtɛ lɛ, ɖɩkpaɣ ɛyʊ weyi ɛ-tɛ ɛyʊ wɛtʊ tɩŋa yɔ nɛ ɖɩpɩsɩ ɛyʊ weyi ɛ-tɛ ɛyʊ wɛtʊ tɩŋa yɔ.# >>> sum_product.call([])
# [0, 1]
# >>> sum_product.call([1, 2, 3, 4])
# [10, 24]
def sum_product(numbers)
","def sum_product(numbers)
  sum = numbers.reduce(0, :+)
  product = numbers.reduce(1, :*)
  [sum, product]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_product
    candidate = method(:sum_product)
    assert_equal([0, 1], candidate.call([]))
    assert_equal([3, 1], candidate.call([1, 1, 1]))
    assert_equal([100, 0], candidate.call([100, 0]))
    assert_equal([15, 105], candidate.call([3, 5, 7]))
    assert_equal([10, 10], candidate.call([10]))
  end
end
"
HumanEval_9,kbp_Latn,rb,"Pɩtɩmʋna se ŋla mbʋ.Pɩlɩna ɛyʊ kʊyʊmʊʊ yɔɔ lɛ, ɛyʊ kʊyʊmʊ ŋgʊ kɩlɩna kʊyʊmʊʊ ŋgʊ kɩ-tɛ alɩwaatʊ taa yɔ.# >>> rolling_max.call([1, 2, 3, 2, 3, 4, 2])
# [1, 2, 3, 3, 3, 4, 4]
def rolling_max(numbers)
","def rolling_max(numbers)
  max_so_far = numbers.first
  numbers.map do |num|
    max_so_far = [max_so_far, num].max
  end
end

# Example usage:
# puts rolling_max([1, 2, 3, 2, 3, 4, 2]).inspect","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rolling_max
    candidate = method(:rolling_max)
    assert_equal([], candidate.call([]))
    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))
    assert_equal([4, 4, 4, 4], candidate.call([4, 3, 2, 1]))
    assert_equal([3, 3, 3, 100, 100], candidate.call([3, 2, 3, 100, 3]))
  end
end
"
HumanEval_10,kbp_Latn,rb,"- Tɩŋgaɣ nɛ ŋtɛzɩna tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye.- Wɩlɩ ɛzɩma ŋpɩzɩɣ ŋla nɛ ŋtɛzɩna tɔmpiye nɖɩ ɖɩ-taa ŋtɩŋna yɔ.Pɩtɛ lɛ, ɛyʊ ɛ-tɛ tɔm kpɛlɛkʊʊ tʊmɩyɛ kɛlɛ:Ñɩnɩ palindrome kɩpɩɣlʋʋ ŋgʋ kɩpaɣzɩɣna tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ.# >>> make_palindrome.call("""")
# """"
# >>> make_palindrome.call(""cat"")
# ""catac""
# >>> make_palindrome.call(""cata"")
# ""catac""
def make_palindrome(string)
","def make_palindrome(string)
  return string if string.empty?

  def is_palindrome?(s)
    s == s.reverse
  end

  (0...string.length).reverse_each do |i|
    if is_palindrome?(string[i..-1])
      return string + string[0...i].reverse
    end
  end

  string
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_make_palindrome
    candidate = method(:make_palindrome)
    assert_equal("""", candidate.call(""""))
    assert_equal(""x"", candidate.call(""x""))
    assert_equal(""xyzyx"", candidate.call(""xyz""))
    assert_equal(""xyx"", candidate.call(""xyx""))
    assert_equal(""jerryrrej"", candidate.call(""jerry""))
  end
end
"
HumanEval_11,kbp_Latn,rb,"Palakɩ XOR binary tɔm nɛ pɩpɩsɩɣ ɖɔɖɔ pɩ-tɛ lɩmaɣzɩyɛ ɛzɩ tɔmpiye yɔ.Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.# >>> string_xor.call(""010"", ""110"")
# ""100""
def string_xor(a, b)
","def string_xor(a, b)
  result = """"
  a.length.times do |i|
    result << (a[i] == b[i] ? ""0"" : ""1"")
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_xor
    candidate = method(:string_xor)
    assert_equal(""010010"", candidate.call(""111000"", ""101010""))
    assert_equal(""0"", candidate.call(""1"", ""1""))
    assert_equal(""0101"", candidate.call(""0101"", ""0000""))
  end
end
"
HumanEval_12,kbp_Latn,rb,"Pɩtɛ lɛ, pɩpɩsɩɣ nil yee pɩtɛkɛ mayaɣ nakɛyɛ wɛna yɔ.Pɩtɛ pɩlɩʋ taa lɛ, pɩpɩsɩɣ kɩ-kɩɖaɣlɩm.# >>> longest.call([])
# nil
# >>> longest.call([""a"", ""b"", ""c""])
# ""a""
# >>> longest.call([""a"", ""bb"", ""ccc""])
# ""ccc""
def longest(strings)
","def longest(strings)
  return nil if strings.empty?
  strings.max_by(&:length)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_longest
    candidate = method(:longest)
    assert_equal(nil, candidate.call([]))
    assert_equal(""x"", candidate.call([""x"", ""y"", ""z""]))
    assert_equal(""zzzz"", candidate.call([""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]))
  end
end
"
HumanEval_13,kbp_Latn,rb,"Pɩsɩ nɛ ŋna-ɩ kɩlɛlʋʋ# >>> greatest_common_divisor.call(3, 5)
# 1
# >>> greatest_common_divisor.call(25, 15)
# 5
def greatest_common_divisor(a, b)
","def greatest_common_divisor(a, b)
  while b != 0
    a, b = b, a % b
  end
  a
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_greatest_common_divisor
    candidate = method(:greatest_common_divisor)
    assert_equal(1, candidate.call(3, 7))
    assert_equal(5, candidate.call(10, 15))
    assert_equal(7, candidate.call(49, 14))
    assert_equal(12, candidate.call(144, 60))
  end
end
"
HumanEval_14,kbp_Latn,rb,"Pɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye kɩsɛyɛ nɛ ɖɩ-tɛ tɔmpiye kɩsɛyɛ yɔ.# >>> all_prefixes.call(""abc"")
# [""a"", ""ab"", ""abc""]
def all_prefixes(string)
","def all_prefixes(string)
  (1..string.length).map { |i| string[0, i] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_all_prefixes
    candidate = method(:all_prefixes)
    assert_equal([], candidate.call(""""))
    assert_equal([""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""], candidate.call(""asdfgh""))
    assert_equal([""W"", ""WW"", ""WWW""], candidate.call(""WWW""))
  end
end
"
HumanEval_15,kbp_Latn,rb,"Pɩpɩsɩɣ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ.# >>> string_sequence.call(0)
# ""0""
# >>> string_sequence.call(5)
# ""0 1 2 3 4 5""
def string_sequence(n)
","def string_sequence(n)
  (0..n).to_a.join(' ')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_sequence
    candidate = method(:string_sequence)
    assert_equal(""0"", candidate.call(0))
    assert_equal(""0 1 2 3"", candidate.call(3))
    assert_equal(""0 1 2 3 4 5 6 7 8 9 10"", candidate.call(10))
  end
end
"
HumanEval_16,kbp_Latn,rb,"Ye ŋha-ɖʋ tɔm piye naɖɩyɛ lɛ, ɖɩpɔzɩ-ŋ se ɛzɩma ɖɩ-taa wɛ tɔm pee ndɩ ndɩ yɔ.# >>> count_distinct_characters.call(""xyzXYZ"")
# 3
# >>> count_distinct_characters.call(""Jerry"")
# 4
def count_distinct_characters(string)
","def count_distinct_characters(string)
  string.downcase.chars.uniq.count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_distinct_characters
    candidate = method(:count_distinct_characters)
    assert_equal(0, candidate.call(""""))
    assert_equal(5, candidate.call(""abcde""))
    assert_equal(5, candidate.call(""abcdecadeCADE""))
    assert_equal(1, candidate.call(""aaaaAAAAaaaa""))
    assert_equal(5, candidate.call(""Jerry jERRY JeRRRY""))
  end
end
"
HumanEval_17,kbp_Latn,rb,"'Nɔɔ kʋɖʋmaɣ' - Nɔɔ kʋɖʋmaɣ ŋga kɛwɛ hɔɔlɩŋ naanza taa yɔ, kɛwɛ tam kʋɖʋm.'O sa' - hɔɔlɩŋ naalɛ, pɩlakɩ tam naalɛ.'O' - hendu tɩŋa, pɩlakɩ tam naanza Kɩɖaʋ kʋnɛ kɩ-tɔm pɔyɔɔdʋʋ:Pɩtɩkɛ kɛdɛzaɣ ñɩŋga.Ña-tʋmɩyɛ lɛ se ŋtazɩ tɔmpiye ɖɩnɛ nɛ ŋpɩsɩna nimero waa mba pa-taa paa weyi ɛ-tɛ ɛ-tɛ tɔmpiye nɖɩ ɖɩ-taa yɔ.Tʊma ana a-taa lɛ, pɔcɔna nɛ pana se a-taa lɛ, minziiki wondu wɛna nɛ tɩwɛɛna ASCII.# >>> parse_music.call(""o o| .| o| o| .| .| .| .| o o"")
# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
def parse_music(music_string)
","def parse_music(music_string)
  # Split the input string into individual notes.
  notes = music_string.split

  # Map each note to its corresponding number of beats.
  notes.map do |note|
    case note
    when 'o'
      4
    when 'o|'
      2
    when '.|'
      1
    else
      0
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_parse_music
    candidate = method(:parse_music)
    assert_equal([], candidate.call(""""))
    assert_equal([4, 4, 4, 4], candidate.call(""o o o o""))
    assert_equal([1, 1, 1, 1], candidate.call("".| .| .| .|""))
    assert_equal([2, 2, 1, 1, 4, 4, 4, 4], candidate.call(""o| o| .| .| o o o o""))
    assert_equal([2, 1, 2, 1, 4, 2, 4, 2], candidate.call(""o| .| o| .| o o| o o|""))
  end
end
"
HumanEval_18,kbp_Latn,rb,"Ñɩnɩ tam ɛzɩma pɩpɩzɩɣ nɛ pana tɔmpiye naɖɩyɛ kajalaɣ tɔmpiye taa yɔ.# >>> how_many_times.call("""", ""a"")
# 0
# >>> how_many_times.call(""aaa"", ""a"")
# 3
# >>> how_many_times.call(""aaaa"", ""aa"")
# 3
def how_many_times(string, substring)
","def how_many_times(string, substring)
  return 0 if substring.empty?
  count = 0
  i = 0
  while i <= string.length - substring.length
    if string[i, substring.length] == substring
      count += 1
    end
    i += 1
  end
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_how_many_times
    candidate = method(:how_many_times)
    assert_equal(0, candidate.call("""", ""x""))
    assert_equal(4, candidate.call(""xyxyxyx"", ""x""))
    assert_equal(4, candidate.call(""cacacacac"", ""cac""))
    assert_equal(1, candidate.call(""john doe"", ""john""))
  end
end
"
HumanEval_19,kbp_Latn,rb,"Pɩsɩ takayɩhayʋʋ kɩgbanzɩ ñɩŋgʋ yɔɔ .Pɩpɩzɩɣ nɛ pɩla se ŋlɩzɩ ""zéro"", ""un"", ""deux"", ""trois"", ""quatre"", ""cinq"", ""six"", ""sept"", ""huit"" nɛ ""neuf"".Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.# >>> sort_numbers.call(""three one five"")
# ""one three five""
def sort_numbers(numbers)
","def sort_numbers(numbers)
  numeral_map = {
    'zero' => 0,
    'one' => 1,
    'two' => 2,
    'three' => 3,
    'four' => 4,
    'five' => 5,
    'six' => 6,
    'seven' => 7,
    'eight' => 8,
    'nine' => 9
  }

  number_words = numbers.split
  sorted_numbers = number_words.sort_by { |word| numeral_map[word] }
  sorted_numbers.join(' ')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_numbers
    candidate = method(:sort_numbers)
    assert_equal("""", candidate.call(""""))
    assert_equal(""three"", candidate.call(""three""))
    assert_equal(""three five nine"", candidate.call(""three five nine""))
    assert_equal(""zero four five seven eight nine"", candidate.call(""five zero four seven nine eight""))
    assert_equal(""zero one two three four five six"", candidate.call(""six five four three two one zero""))
  end
end
"
HumanEval_20,kbp_Latn,rb,"Pɩtɛ lɛ, ŋpɩzɩɣ nɛ ŋlɩzɩ-wɛ nɛ ŋyele nɛ patɩŋnɩ pa-taa paa weyi ɛ-yɔɔ.Pɩtɛ matʋ (pɩtalɩɣ naalɛ) taa lɛ, ŋlɩzɩ nɛ ŋyele naalɛ nɛ ɩpɩsɩ kɩ-taa.# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
# [2.0, 2.2]
# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
# [2.0, 2.0]
def find_closest_elements(numbers)
","def find_closest_elements(numbers)
  sorted_numbers = numbers.sort
  closest_pair = [sorted_numbers[0], sorted_numbers[1]]
  min_difference = (sorted_numbers[1] - sorted_numbers[0]).abs

  (1...(sorted_numbers.length - 1)).each do |i|
    current_difference = (sorted_numbers[i + 1] - sorted_numbers[i]).abs
    if current_difference < min_difference
      min_difference = current_difference
      closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]
    end
  end

  closest_pair
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_find_closest_elements
    candidate = method(:find_closest_elements)
    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))
    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))
    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))
    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))
    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))
  end
end
"
HumanEval_21,kbp_Latn,rb,"mbʊ pʊyɔɔ yɔ, pʊtʊ weyi ɛkɩlɩ tɔyʊʊ yɔ ɛkaɣ pɩsʋʋ 0 nɛ weyi ɛkɩlɩ tɔyʊʊ yɔ ɛkaɣ pɩsʋʋ 1 .Pɩkɛna nimero waa (ɛzɩma pɩfɛyɩ kɔyɔ, pɩtalɩɣ naalɛ), pʊcɔ nɛ papɩzɩ patɩlɩ se nimero waa mba pɛwɛna kɩmaŋ kɔyɔ, pʊwɛɛ se patɩlɩ se nimero waa mba pɛwɛna kɩmaŋ.# >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])
# [0.0, 0.25, 0.5, 0.75, 1.0]
def rescale_to_unit(numbers)
","def rescale_to_unit(numbers)
  min = numbers.min
  max = numbers.max
  range = max - min
  return numbers.map { |num| (num - min) / range.to_f }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rescale_to_unit
    candidate = method(:rescale_to_unit)
    assert_equal([0.0, 1.0], candidate.call([2.0, 49.9]))
    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))
    assert_equal([0.0, 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))
    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))
    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))
  end
end
"
HumanEval_22,kbp_Latn,rb,"Pɩlɩʋ kɩlɛlʋʋ ŋgʋ kɩ-taa, kɩ-taa wɛ tɔmpiye rbthon nɛ kɩ-taa lɛ, kɩ-taa wɛ tɔmpiye intɛrɩyɔm ɖeke.# >>> filter_integers.call([""a"", 3.14, 5])
# [5]
# >>> filter_integers.call([1, 2, 3, ""abc"", {}, []])
# [1, 2, 3]
def filter_integers(values)
","def filter_integers(values)
  values.select { |value| value.is_a?(Integer) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_integers
    candidate = method(:filter_integers)
    assert_equal([], candidate.call([]))
    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, ""adasd""]))
    assert_equal([3, 3, 3], candidate.call([3, ""c"", 3, 3, ""a"", ""b""]))
  end
end
"
HumanEval_23,kbp_Latn,rb,"Pɩsɩ takayɩhayʋʋ Kpɩtaʋ ŋgʋ kɩ-taa ŋnaɣ-kʋ yɔ kɩ-tɛɛ# >>> strlen.call("""")
# 0
# >>> strlen.call(""abc"")
# 3
def strlen(string)
","strlen = lambda do |string|
  string.length
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_strlen
    candidate = method(:strlen)
    assert_equal(0, candidate.call(""""))
    assert_equal(1, candidate.call(""x""))
    assert_equal(9, candidate.call(""asdasnakj""))
  end
end
"
HumanEval_24,kbp_Latn,rb,"Pɩcɔ nɛ ŋtɩlɩ n mayaɣ kɔyɔ, ŋñɩnɩɣ mayaɣ ŋga kɛwɛna n yɔɔ yɔ, ŋga kakɩlɩ n yɔɔ yɔ.# >>> largest_divisor.call(15)
# 5
def largest_divisor(n)
","def largest_divisor(n)
  (n - 1).downto(1) do |i|
    return i if n % i == 0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_divisor
    candidate = method(:largest_divisor)
    assert_equal(1, candidate.call(3))
    assert_equal(1, candidate.call(7))
    assert_equal(5, candidate.call(10))
    assert_equal(50, candidate.call(100))
    assert_equal(7, candidate.call(49))
  end
end
"
HumanEval_25,kbp_Latn,rb,"Pɩwɛɛ se ɖɩkpaɣ kɩ-tɛ tɔmpiye nɛ ɖɩkpaɣ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ.Pɩwɛɛ se pamaɣ paa tɔmpiye nɖɩ lɛ ɖɩ-tɛ tam ndɩ ndɩ nɛ pɩwɩlɩɣ tam ɛzɩma ɖɩ-tɛ tɔmpiye nɖɩ ɖɩlɩna tɔmpiye ndɩ ɖɩ-taa yɔ.Ɛpɩsɩɣ ɛ-tɛ kajalaɣ hɔɔlɩŋ weyi ɛ-taa ɛ-tɛ hɔɔlɩŋ sɔsɔŋ wɛɛ yɔ, kpaɣ nɛ hɔɔlɩŋ cikpeŋ nɛ ŋwolo hɔɔlɩŋ sɔsɔŋ taa.# >>> factorize.call(8)
# [2, 2, 2]
# >>> factorize.call(25)
# [5, 5]
# >>> factorize.call(70)
# [2, 5, 7]
def factorize(n)
","def factorize(n)
  factors = []
  divisor = 2
  while n > 1
    while n % divisor == 0
      factors << divisor
      n /= divisor
    end
    divisor += 1
  end
  factors
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_factorize
    candidate = method(:factorize)
    assert_equal([2], candidate.call(2))
    assert_equal([2, 2], candidate.call(4))
    assert_equal([2, 2, 2], candidate.call(8))
    assert_equal([3, 19], candidate.call(57))
    assert_equal([3, 3, 19, 19], candidate.call(3249))
    assert_equal([3, 3, 3, 19, 19, 19], candidate.call(185193))
    assert_equal([3, 19, 19, 19], candidate.call(20577))
    assert_equal([2, 3, 3], candidate.call(18))
  end
end
"
HumanEval_26,kbp_Latn,rb,"Pɩwɛɛ se ɖɩɖɔkɩ mbʋ ɖɩɖʋwa yɔ, mbʋ ɖɔɖɔ ɖɩɖʋwa yɔ.Pɩtɛ lɛ, ɖɩkpaɣ kɩlɛmɩŋ weyi ɩwɛna tam nabʊyʊ yɔ nɛ ɖɩlɩzɩ kɩlɛmɩŋ weyi ɩwɛna tam nabʊyʊ yɔ.# >>> remove_duplicates.call([1, 2, 3, 2, 4])
# [1, 3, 4]
def remove_duplicates(numbers)
","def remove_duplicates(numbers)
  numbers.select { |num| numbers.count(num) == 1 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_remove_duplicates
    candidate = method(:remove_duplicates)
    assert_equal([], candidate.call([]))
    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))
    assert_equal([1, 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))
  end
end
"
HumanEval_27,kbp_Latn,rb,"Pɩtɛ matʋ ndʋ tɩ-taa, ŋlɛɣzɩ matʋ cikpetu nɛ ŋlɛɣzɩ matʋ sɔsɔtʋ nɛ ŋlɛɣzɩ matʋ sɔsɔtʋ nɛ ŋlɛɣzɩ matʋ cikpetu.# >>> flip_case.call(""Hello"")
# ""hELLO""
def flip_case(string)
","def flip_case(string)
  string.swapcase
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_flip_case
    candidate = method(:flip_case)
    assert_equal("""", candidate.call(""""))
    assert_equal(""hELLO!"", candidate.call(""Hello!""))
    assert_equal(""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"", candidate.call(""These violent delights have violent ends""))
  end
end
"
HumanEval_28,kbp_Latn,rb,"Kpaɣna hɔɔlɩŋ ndɩ ndɩ nɛ ŋpɩsɩ-ɩ hɔɔlɩŋ kʋɖʋmʋʋ.# >>> concatenate.call([])
# """"
# >>> concatenate.call([""a"", ""b"", ""c""])
# ""abc""
def concatenate(strings)
","def concatenate(strings)
  strings.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_concatenate
    candidate = method(:concatenate)
    assert_equal("""", candidate.call([]))
    assert_equal(""xyz"", candidate.call([""x"", ""y"", ""z""]))
    assert_equal(""xyzwk"", candidate.call([""x"", ""y"", ""z"", ""w"", ""k""]))
  end
end
"
HumanEval_29,kbp_Latn,rb,"Pɩtɛ tɔmpiye naɖɩyɛ taa tɔmpiye nɖɩ ɖɩpaɣzɩɣna tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye yɔ.# >>> filter_by_prefix.call([], ""a"")
# []
# >>> filter_by_prefix.call([""abc"", ""bcd"", ""cde"", ""array""], ""a"")
# [""abc"", ""array""]
def filter_by_prefix(strings, prefix)
","def filter_by_prefix(strings, prefix)
  strings.select { |string| string.start_with?(prefix) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_by_prefix
    candidate = method(:filter_by_prefix)
    assert_equal([], candidate.call([], ""john""))
    assert_equal([""xxx"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""))
  end
end
"
HumanEval_30,kbp_Latn,rb,"Ɛpɩsɩɣ ɛ-tɛ ɛyʊ kɩlɩm mbʊ yɔ.# >>> get_positive.call([-1, 2, -4, 5, 6])
# [2, 5, 6]
# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
# [5, 3, 2, 3, 9, 123, 1]
def get_positive(l)
","get_positive = lambda do |l|
  l.select { |num| num > 0 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_positive
    candidate = method(:get_positive)
    assert_equal([4, 5, 6], candidate.call([-1, -2, 4, 5, 6]))
    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))
    assert_equal([], candidate.call([-1, -2]))
    assert_equal([], candidate.call([]))
  end
end
"
HumanEval_31,kbp_Latn,rb,"Ye nimero waa nabɛyɛ ɩkɛ kajalaɣ mba yɔ, pɩpɩsɩɣ toovenim nɛ ye pɩtɛkɛ mbʋ yɔ, pɩkɛ cɛtɩm.# >>> is_prime.call(6)
# false
# >>> is_prime.call(101)
# true
# >>> is_prime.call(11)
# true
# >>> is_prime.call(13441)
# true
# >>> is_prime.call(61)
# true
# >>> is_prime.call(4)
# false
# >>> is_prime.call(1)
# false
def is_prime(n)
","is_prime = lambda do |n|
  return false if n <= 1
  return true if n == 2
  return false if n.even?

  max_divisor = Math.sqrt(n).to_i
  (3..max_divisor).step(2).each do |i|
    return false if n % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_prime
    candidate = method(:is_prime)
    assert_equal(false, candidate.call(6))
    assert_equal(true, candidate.call(101))
    assert_equal(true, candidate.call(11))
    assert_equal(true, candidate.call(13441))
    assert_equal(true, candidate.call(61))
    assert_equal(false, candidate.call(4))
    assert_equal(false, candidate.call(1))
    assert_equal(true, candidate.call(5))
    assert_equal(true, candidate.call(11))
    assert_equal(true, candidate.call(17))
    assert_equal(false, candidate.call(85))
    assert_equal(false, candidate.call(77))
    assert_equal(false, candidate.call(255379))
  end
end
"
HumanEval_33,kbp_Latn,rb,"Pɩtɛ lɛ, pɛtɛyɩ-ɩ nɛ ɛ-tɛ lɛɣtʋ kɩfatʋ.l' wɛ ɛzɩ l yɔ, yee ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛTʋma ana a-taa lɛ, pakpaɣ matrice l nɛ papɩsɩna matrice l' nɖɩ ɖɩ-taa # >>> sort_third.call([1, 2, 3])
# [1, 2, 3]
# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])
# [2, 6, 3, 4, 8, 9, 5]
def sort_third(l)
","def sort_third(l)
  divisible_by_three = l.each_with_index.select { |_, idx| idx % 3 == 0 }.map(&:first).sort
  l.each_with_index.map { |val, idx| idx % 3 == 0 ? divisible_by_three.shift : val }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_third
    candidate = method(:sort_third)
    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5, 6, 3, 4, 8, 9, 2]))
    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5, 8, 3, 4, 6, 9, 2]))
    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5, 6, 9, 4, 8, 3, 2]))
    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5, 6, 3, 4, 8, 9, 2, 1]))
  end
end
"
HumanEval_34,kbp_Latn,rb,"Pɩsɩ takayɩhayʋʋ Ñɔɔzɩtʋ kɩfatʋ ñɩŋgʋ yɔɔ .# >>> unique.call([5, 3, 5, 2, 3, 3, 9, 0, 123])
# [0, 2, 3, 5, 9, 123]
def unique(l)
","def unique(l)
  l.uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_unique
    candidate = method(:unique)
    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5, 3, 5, 2, 3, 3, 9, 0, 123]))
  end
end
"
HumanEval_35,kbp_Latn,rb,"Ɛpɩsɩɣ ɛ-tɛ kɩlɩm pɩyʊ ɛ-tɛ matriki taa.# >>> max_element.call([1, 2, 3])
# 3
# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
# 123
def max_element(l)
","def max_element(l)
  l.max
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_max_element
    candidate = method(:max_element)
    assert_equal(3, candidate.call([1, 2, 3]))
    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]))
  end
end
"
HumanEval_36,kbp_Latn,rb,"Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ:# >>> fizz_buzz.call(50)
# 0
# >>> fizz_buzz.call(78)
# 2
# >>> fizz_buzz.call(79)
# 3
def fizz_buzz(n)
","def fizz_buzz(n)
  count = 0
  (1...n).each do |i|
    if i % 11 == 0 || i % 13 == 0
      count += i.to_s.count('7')
    end
  end
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fizz_buzz
    candidate = method(:fizz_buzz)
    assert_equal(0, candidate.call(50))
    assert_equal(2, candidate.call(78))
    assert_equal(3, candidate.call(79))
    assert_equal(3, candidate.call(100))
    assert_equal(6, candidate.call(200))
    assert_equal(192, candidate.call(4000))
    assert_equal(639, candidate.call(10000))
    assert_equal(8026, candidate.call(100000))
  end
end
"
HumanEval_37,kbp_Latn,rb,"Pɩtɛ lɛ, pɛtɛzɩ-ɩ kpaɣʋ nɛ pɛtɛzɩ-ɩ kpaɣʋ nɛ pɛtɛzɩɣ-ɩ kpaɣʋ nɛ pɛtɛzɩɣ-ɩ kpaɣʋ nɛ pɛtɛzɩɣ-ɩ kpaɣʋ.l' wɛ ɛzɩ l yɔ, ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛ-tɛ ɛyʊ ɛyʊ ɛ-tɛ ɛyʊ ɛyʊ ɛ-tɛ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊ ɛyʊTʋma ana a-taa lɛ, pakpaɣ matrice l nɛ papɩsɩna matrice l' nɖɩ ɖɩ-taa # >>> sort_even.call([1, 2, 3])
# [1, 2, 3]
# >>> sort_even.call([5, 6, 3, 4])
# [3, 6, 5, 4]
def sort_even(l)
","def sort_even(l)
  even_indices = l.each_index.select { |i| i.even? }
  even_values = even_indices.map { |i| l[i] }.sort
  
  even_index = 0
  l.each_with_index.map do |value, index|
    if index.even?
      even_values[even_index].tap { even_index += 1 }
    else
      value
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_even
    candidate = method(:sort_even)
    assert_equal([1, 2, 3], candidate.call([1, 2, 3]))
    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert_equal([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
  end
end
"
HumanEval_39,kbp_Latn,rb,"prime_fib pɩlɩɣna n-tɛ n̄ɩnɖɛ nɖɩ ɖɩkɛ Fibonacci n̄ɩnɖɛ nɛ ɖɩkɛ ɖɔɖɔ kajalaɣ n̄ɩnɖɛ yɔ.# >>> prime_fib.call(1)
# 2
# >>> prime_fib.call(2)
# 3
# >>> prime_fib.call(3)
# 5
# >>> prime_fib.call(4)
# 13
# >>> prime_fib.call(5)
# 89
def prime_fib(n)
","def prime_fib(n)
  require 'prime'
  
  fibs = Enumerator.new do |y|
    a, b = 0, 1
    loop do
      a, b = b, a + b
      y << b
    end
  end
  
  prime_fibs = fibs.lazy.select { |fib| Prime.prime?(fib) }
  prime_fibs.first(n).last
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prime_fib
    candidate = method(:prime_fib)
    assert_equal(2, candidate.call(1))
    assert_equal(3, candidate.call(2))
    assert_equal(5, candidate.call(3))
    assert_equal(13, candidate.call(4))
    assert_equal(89, candidate.call(5))
    assert_equal(233, candidate.call(6))
    assert_equal(1597, candidate.call(7))
    assert_equal(28657, candidate.call(8))
    assert_equal(514229, candidate.call(9))
    assert_equal(433494437, candidate.call(10))
  end
end
"
HumanEval_40,kbp_Latn,rb,"Pɩtɛ lɛ, kɩ-tɛ tɔm kɛ cɛtɩm.Pɩpɩsɩɣ tɔmpiye true yee ɛyʊ ɛ-tɛ matʊ taa ɛ-tɛ tɔmpiye triple_sum_to_zero kpaɣ ɛyʊ kʊyʊmʊʊ ɛzɩ ɛ-tɛ tɔm yɔ.# >>> triples_sum_to_zero.call([1, 3, 5, 0])
# false
# >>> triples_sum_to_zero.call([1, 3, -2, 1])
# true
# >>> triples_sum_to_zero.call([1, 2, 3, 7])
# false
# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])
# true
# >>> triples_sum_to_zero.call([1])
# false
def triples_sum_to_zero(l)
","def triples_sum_to_zero(l)
  n = l.length
  (0...n-2).each do |i|
    ((i+1)...n-1).each do |j|
      ((j+1)...n).each do |k|
        return true if l[i] + l[j] + l[k] == 0
      end
    end
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triples_sum_to_zero
    candidate = method(:triples_sum_to_zero)
    assert_equal(false, candidate.call([1, 3, 5, 0]))
    assert_equal(false, candidate.call([1, 3, 5, -1]))
    assert_equal(true, candidate.call([1, 3, -2, 1]))
    assert_equal(false, candidate.call([1, 2, 3, 7]))
    assert_equal(false, candidate.call([1, 2, 5, 7]))
    assert_equal(true, candidate.call([2, 4, -5, 3, 9, 7]))
    assert_equal(false, candidate.call([1]))
    assert_equal(false, candidate.call([1, 3, 5, -100]))
    assert_equal(false, candidate.call([100, 3, 5, -100]))
  end
end
"
HumanEval_41,kbp_Latn,rb,"Kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ.Pɩwɛ ɛzɩ patɩkatɩ ɖama yɔ.Ɛlɛ, lɔɔɖa ana awɛ ɖoŋ nɛ awɛ ɖɔɖɔ kpɩzɩŋ nɛ pʋyɔɔ lɛ, awɛɛ nɛ awɛɛ nɛ awɛɛ.Alɩwaatʋ ndʋ lɔɔɖɩyɛ nɖɩ ɖɩɖɛɣ nɛ ɖɩlɩɣ nɛ ɖɩɖɛɣ nɛ ɖɩɖɛɣ nɛ ɖɩɖɛɣ nɛ ɖɩkɔŋʋʋ lɔɔɖɩyɛ nɖɩ ɖɩɖɛɣ nɛ ɖɩɖɛɣ nɛ ɖɩɖɛɣ nɛ ɖɩɖɛɣ yɔ.Pɩkɛna mbʋ se, yee ɖɩkpaɣ se ɖɩcaɣ ɖɩ-tɩ yɔɔ kɔyɔ, ɖɩnaɣ se ɖɩtɩŋɩɣna nɛ ɖɩlakɩ mbʋ.Kpɛndɩɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna nɛ pɩɖɛɣna.lɔɔɖa n wɛɛ nɛ pɔɖɔŋ nɛ pɛɖɛɣna n-nɩmɩyɛ nɛ n-nɩmɩyɛ.Maɣzɩ se ŋwɛ habɩyɛ nɖɩ ɖɩtɩŋʋʋ camɩyɛ yɔ ɖɩ-yɔɔ.def car_race_collision(n)
","def car_race_collision(n)
  n
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_car_race_collision
    candidate = method(:car_race_collision)
    assert_equal(4, candidate.call(2))
    assert_equal(9, candidate.call(3))
    assert_equal(16, candidate.call(4))
    assert_equal(64, candidate.call(8))
    assert_equal(100, candidate.call(10))
  end
end
"
HumanEval_42,kbp_Latn,rb,"Ɛpɩsɩɣ ɛ-tɛ matriki nɛ ɛ-tɛ matriki kɩpanzɩ.# >>> incr_list.call([1, 2, 3])
# [2, 3, 4]
# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])
# [6, 4, 6, 3, 4, 4, 10, 1, 124]
def incr_list(l)
","def incr_list(l)
  l.map { |x| x + 1 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_incr_list
    candidate = method(:incr_list)
    assert_equal([], candidate.call([]))
    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))
    assert_equal([6, 3, 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))
  end
end
"
HumanEval_43,kbp_Latn,rb,"Pɩtɛ lɛ, kɩ-tɛ tɔm kɛ cɛtɩm.Pɩpɩsɩɣ tɔmpiye true yee ɛyʊ ɛ-tɛ tɔmpiye nɖɩ ɖɩ-taa ɛ-tɛ tɔmpiye pairs_sum_to_zero kpaɣ ɛyʊ kʊyʊmʊʊ ɛzɩ ɛ-tɛ tɔm yɔ.# >>> pairs_sum_to_zero.call([1, 3, 5, 0])
# false
# >>> pairs_sum_to_zero.call([1, 3, -2, 1])
# false
# >>> pairs_sum_to_zero.call([1, 2, 3, 7])
# false
# >>> pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])
# true
# >>> pairs_sum_to_zero.call([1])
# false
def pairs_sum_to_zero(l)
","def pairs_sum_to_zero(l)
  num_set = l.to_set
  l.each do |num|
    return true if num != 0 && num_set.include?(-num)
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_pairs_sum_to_zero
    candidate = method(:pairs_sum_to_zero)
    assert_equal(false, candidate.call([1, 3, 5, 0]))
    assert_equal(false, candidate.call([1, 3, -2, 1]))
    assert_equal(false, candidate.call([1, 2, 3, 7]))
    assert_equal(true, candidate.call([2, 4, -5, 3, 5, 7]))
    assert_equal(false, candidate.call([1]))
    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 30]))
    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 31]))
    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))
    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))
  end
end
"
HumanEval_44,kbp_Latn,rb,"Kɩ-tɛ kɩlɛmɩŋ wɛ ɛzɩ 10 yɔ.Pɩpɩsɩɣna tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye lɛɣzʋʋ.Pɩsɩ takayɩhayʋʋ kɩsɔzɩtʋ taa.# >>> change_base.call(8, 3)
# ""22""
# >>> change_base.call(8, 2)
# ""1000""
# >>> change_base.call(7, 2)
# ""111""
def change_base(x, base)
","def change_base(x, base)
  return '0' if x == 0
  digits = []
  while x > 0
    digits << (x % base).to_s
    x /= base
  end
  digits.reverse.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_change_base
    candidate = method(:change_base)
    assert_equal(""22"", candidate.call(8, 3))
    assert_equal(""100"", candidate.call(9, 3))
    assert_equal(""11101010"", candidate.call(234, 2))
    assert_equal(""10000"", candidate.call(16, 2))
    assert_equal(""1000"", candidate.call(8, 2))
    assert_equal(""111"", candidate.call(7, 2))
    assert_equal(""2"", candidate.call(2, 3))
    assert_equal(""3"", candidate.call(3, 4))
    assert_equal(""4"", candidate.call(4, 5))
    assert_equal(""5"", candidate.call(5, 6))
    assert_equal(""6"", candidate.call(6, 7))
    assert_equal(""7"", candidate.call(7, 8))
  end
end
"
HumanEval_45,kbp_Latn,rb,"Pɩkɛna hɔɔlɩŋ weyi ɛ-taa pʊcɔ nɛ pʊcɔ nɛ pʊcɔ nɛ pʊcɔ nɛ pʊcɔ nɛ pʊcɔ yɔ.# >>> triangle_area.call(5, 3)
# 7.5
def triangle_area(a, h)
","def triangle_area(a, h)
  (a * h) / 2.0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triangle_area
    candidate = method(:triangle_area)
    assert_equal(7.5, candidate.call(5, 3))
    assert_equal(2.0, candidate.call(2, 2))
    assert_equal(40.0, candidate.call(10, 8))
  end
end
"
HumanEval_46,kbp_Latn,rb,"Pɩsa nɛ ŋpɩzɩ ŋla tʋmɩyɛ nɛ ŋla akɔnta camɩyɛ nɛ ŋtɩlɩ fib4 tɛ n̄ɩŋgʋ. Taawɛɛkɩɣ kɩ-tɩ yɔɔ.Fɛyɩtʊ ndʊ tɩ-taa lɛ, pʊtɔbʊʊ se fɩdɩyɔm wɛna fɩdɩyɔm tɛtʊ ndʊ tɩ-taa nɛ fɩdɩyɔm tɛtʊ ndʊ tɩ-taa nɛ fɩdɩyɔm tɛtʊ ndʊ tɩ-taa nɛ fɩdɩyɔm tɛtʊ ndʊ tɩ-taa.(Cɔnɩ tayʋʋ 4)(Cɔnɩ tayʋʋ 2) -> 2 (Cɔnɩ tayʋʋ 1) -> 0 (Cɔnɩ tayʋʋ 4)Fib4 tɛ kʊyʊmʊʊ kʊyʊmʊʊ wɛ ɛzɩ Fibbonacci kʊyʊmʊʊ yɔ nɛ pama-kʊ nɛ pɩ-tɛ tɔmʊʊ:# >>> fib4.call(5)
# 4
# >>> fib4.call(6)
# 8
# >>> fib4.call(7)
# 14
def fib4(n)
","def fib4(n)
  return 0 if n == 0 || n == 1 || n == 3
  return 2 if n == 2

  fib4_seq = [0, 0, 2, 0]
  (4..n).each do |i|
    fib4_seq[i] = fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]
  end
  fib4_seq[n]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fib4
    candidate = method(:fib4)
    assert_equal(4, candidate.call(5))
    assert_equal(28, candidate.call(8))
    assert_equal(104, candidate.call(10))
    assert_equal(386, candidate.call(12))
  end
end
"
HumanEval_47,kbp_Latn,rb,"Pɩpɩsɩɣ kɩ-tɛ hɔɔlɩŋ sɔsɔŋ taa.# >>> median.call([3, 1, 2, 4, 5])
# 3
# >>> median.call([-10, 4, 6, 1000, 10, 20])
# 15.0
def median(l)
","def median(l)
  sorted = l.sort
  len = sorted.length
  if len.odd?
    sorted[len / 2]
  else
    (sorted[len / 2 - 1] + sorted[len / 2]) / 2.0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_median
    candidate = method(:median)
    assert_equal(3, candidate.call([3, 1, 2, 4, 5]))
    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))
    assert_equal(5, candidate.call([5]))
    assert_equal(5.5, candidate.call([6, 5]))
    assert_equal(7, candidate.call([8, 1, 3, 9, 9, 2, 7]))
  end
end
"
HumanEval_48,kbp_Latn,rb,"Pɩcɔ nɛ pana se tɔmpiye nɖɩ ɖɩ-taa pama tɔm yɔ, ɖɩkɛ palindrome yaa we ?# >>> is_palindrome.call("""")
# true
# >>> is_palindrome.call(""aba"")
# true
# >>> is_palindrome.call(""aaaaa"")
# true
# >>> is_palindrome.call(""zbcd"")
# false
def is_palindrome(text)
","is_palindrome = lambda do |text|
  text == text.reverse
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_palindrome
    candidate = method(:is_palindrome)
    assert_equal(true, candidate.call(""""))
    assert_equal(true, candidate.call(""aba""))
    assert_equal(true, candidate.call(""aaaaa""))
    assert_equal(false, candidate.call(""zbcd""))
    assert_equal(true, candidate.call(""xywyx""))
    assert_equal(false, candidate.call(""xywyz""))
    assert_equal(false, candidate.call(""xywzx""))
  end
end
"
HumanEval_49,kbp_Latn,rb,"Pɩpɩsɩɣ 2^n modulo p (ɩtɩlɩɣ nimerikɩwaa).# >>> modp.call(3, 5)
# 3
# >>> modp.call(1101, 101)
# 2
# >>> modp.call(0, 101)
# 1
# >>> modp.call(3, 11)
# 8
# >>> modp.call(100, 101)
# 1
def modp(n, p)
","def modp(n, p)
  return 1 if p == 1
  2.pow(n, p)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_modp
    candidate = method(:modp)
    assert_equal(3, candidate.call(3, 5))
    assert_equal(2, candidate.call(1101, 101))
    assert_equal(1, candidate.call(0, 101))
    assert_equal(8, candidate.call(3, 11))
    assert_equal(1, candidate.call(100, 101))
    assert_equal(4, candidate.call(30, 5))
    assert_equal(3, candidate.call(31, 5))
  end
end
"
HumanEval_51,kbp_Latn,rb,"remove_vowels kɛna tʋmɩyɛ nɖɩ ɖɩkpaɣ tɔmpiye nɛ ɖɩpɩsɩ tɔmpiye nɖɩ ɖɩfɛyɩna tɔmpiye yɔ.# >>> remove_vowels.call("""")
# """"
# >>> remove_vowels.call(""abcdef"")
# ""bcdf""
# >>> remove_vowels.call(""aaaaa"")
# """"
# >>> remove_vowels.call(""aaBAA"")
# ""B""
# >>> remove_vowels.call(""zbcd"")
# ""zbcd""
def remove_vowels(text)
","def remove_vowels(text)
  text.delete('aeiouAEIOU')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_remove_vowels
    candidate = method(:remove_vowels)
    assert_equal("""", candidate.call(""""))
    assert_equal(""bcdf
ghjklm"", candidate.call(""abcdef
ghijklm""))
    assert_equal(""fdcb"", candidate.call(""fedcba""))
    assert_equal("""", candidate.call(""eeeee""))
    assert_equal(""cB"", candidate.call(""acBAA""))
    assert_equal(""cB"", candidate.call(""EcBOO""))
    assert_equal(""ybcd"", candidate.call(""ybcd""))
  end
end
"
HumanEval_52,kbp_Latn,rb,"Pɩpɩsɩɣ true yee nimero waa tɩŋa ɩwɛ pʊtʊ l taa nɛ pɩtaatalɩ t.# >>> below_threshold.call([1, 2, 4, 10], 100)
# true
# >>> below_threshold.call([1, 20, 4, 10], 5)
# false
def below_threshold(l, t)
","def below_threshold(l, t)
  l.all? { |num| num < t }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_below_threshold
    candidate = method(:below_threshold)
    assert_equal(true, candidate.call([1, 2, 4, 10], 100))
    assert_equal(false, candidate.call([1, 20, 4, 10], 5))
    assert_equal(true, candidate.call([1, 20, 4, 10], 21))
    assert_equal(true, candidate.call([1, 20, 4, 10], 22))
    assert_equal(true, candidate.call([1, 8, 4, 10], 11))
    assert_equal(false, candidate.call([1, 8, 4, 10], 10))
  end
end
"
HumanEval_53,kbp_Latn,rb,"Ɖɩkpaɣ x nɛ y pa-naalɛ nɛ ɖɩkpɛndɩna.# >>> add.call(2, 3)
# 5
# >>> add.call(5, 7)
# 12
def add(x, y)
","add = ->(x, y) { x + y }","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add
    candidate = method(:add)
    assert_equal(1, candidate.call(0, 1))
    assert_equal(1, candidate.call(1, 0))
    assert_equal(5, candidate.call(2, 3))
    assert_equal(12, candidate.call(5, 7))
    assert_equal(12, candidate.call(7, 5))
  end
end
"
HumanEval_54,kbp_Latn,rb,"Ñɩnɩ tɔm pee wena awɛ kɩmaŋ yɔ.# >>> same_chars.call(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")
# true
# >>> same_chars.call(""abcd"", ""dddddddabc"")
# true
# >>> same_chars.call(""dddddddabc"", ""abcd"")
# true
# >>> same_chars.call(""eabcd"", ""dddddddabc"")
# false
# >>> same_chars.call(""abcd"", ""dddddddabce"")
# false
# >>> same_chars.call(""eabcdzzzz"", ""dddzzzzzzzddddabc"")
# false
def same_chars(s0, s1)
","def same_chars(s0, s1)
  s0.chars.uniq.all? { |char| s1.include?(char) } &&
  s1.chars.uniq.all? { |char| s0.include?(char) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_same_chars
    candidate = method(:same_chars)
    assert_equal(true, candidate.call(""eabcdzzzz"", ""dddzzzzzzzddeddabc""))
    assert_equal(true, candidate.call(""abcd"", ""dddddddabc""))
    assert_equal(true, candidate.call(""dddddddabc"", ""abcd""))
    assert_equal(false, candidate.call(""eabcd"", ""dddddddabc""))
    assert_equal(false, candidate.call(""abcd"", ""dddddddabcf""))
    assert_equal(false, candidate.call(""eabcdzzzz"", ""dddzzzzzzzddddabc""))
    assert_equal(false, candidate.call(""aabb"", ""aaccc""))
  end
end
"
HumanEval_55,kbp_Latn,rb,"Pɩsɩ nɛ ŋna-ɩ tɔm pɔzʋʋ:# >>> fib.call(10)
# 55
# >>> fib.call(1)
# 1
# >>> fib.call(8)
# 21
def fib(n)
","def fib(n)
  return n if n <= 1
  fib(n - 1) + fib(n - 2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fib
    candidate = method(:fib)
    assert_equal(55, candidate.call(10))
    assert_equal(1, candidate.call(1))
    assert_equal(21, candidate.call(8))
    assert_equal(89, candidate.call(11))
    assert_equal(144, candidate.call(12))
  end
end
"
HumanEval_56,kbp_Latn,rb,"Pɩsɩɣna nɛ ŋtɩlɩ se paa tɔmpiye nɖɩ lɛ, ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ.""parenthes"" kɛna ""<"" nɛ "">"" pa-taa mayaɣ.# >>> correct_bracketing.call(""<"")
# false
# >>> correct_bracketing.call(""<>"")
# true
# >>> correct_bracketing.call(""<<><>>"")
# true
# >>> correct_bracketing.call(""><<>"")
# false
def correct_bracketing(brackets)
","def correct_bracketing(brackets)
  balance = 0
  brackets.chars.each do |char|
    if char == '<'
      balance += 1
    elsif char == '>'
      balance -= 1
    end
    return false if balance < 0
  end
  balance == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_correct_bracketing
    candidate = method(:correct_bracketing)
    assert_equal(true, candidate.call(""<>""))
    assert_equal(true, candidate.call(""<<><>>""))
    assert_equal(true, candidate.call(""<><><<><>><>""))
    assert_equal(true, candidate.call(""<><><<<><><>><>><<><><<>>>""))
    assert_equal(false, candidate.call(""<<<><>>>>""))
    assert_equal(false, candidate.call(""><<>""))
    assert_equal(false, candidate.call(""<""))
    assert_equal(false, candidate.call(""<<<<""))
    assert_equal(false, candidate.call("">""))
    assert_equal(false, candidate.call(""<<>""))
    assert_equal(false, candidate.call(""<><><<><>><>><<>""))
    assert_equal(false, candidate.call(""<><><<><>><>>><>""))
  end
end
"
HumanEval_57,kbp_Latn,rb,"Pɩpɩsɩɣ toovenim kɔyɔ, pɩwɩlɩɣ se ɛyʊ wɛna ɛ-tɩ yɔɔ wɛʊ yaa ɛ-tɩ yɔɔ wɛʊ.# >>> monotonic.call([1, 2, 4, 20])
# true
# >>> monotonic.call([1, 20, 4, 10])
# false
# >>> monotonic.call([4, 1, 0, -10])
# true
def monotonic(l)
","def monotonic(l)
  increasing = true
  decreasing = true

  (0...l.length - 1).each do |i|
    if l[i] < l[i + 1]
      decreasing = false
    elsif l[i] > l[i + 1]
      increasing = false
    end
  end

  increasing || decreasing
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_monotonic
    candidate = method(:monotonic)
    assert_equal(true, candidate.call([1, 2, 4, 10]))
    assert_equal(true, candidate.call([1, 2, 4, 20]))
    assert_equal(false, candidate.call([1, 20, 4, 10]))
    assert_equal(true, candidate.call([4, 1, 0, -10]))
    assert_equal(true, candidate.call([4, 1, 1, 0]))
    assert_equal(false, candidate.call([1, 2, 3, 2, 5, 60]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 60]))
    assert_equal(true, candidate.call([9, 9, 9, 9]))
  end
end
"
HumanEval_58,kbp_Latn,rb,"Ɛpɩsɩɣ ɛ-tɛ ɛyʊ weyi ɛ-tɛ ɛyʊ wɛʊ yɔ ɛ-tɛ ɛyʊ kɩfalʊ.# >>> common.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
# [1, 5, 653]
# >>> common.call([5, 3, 2, 8], [3, 2])
# [2, 3]
def common(l1, l2)
","def common(l1, l2)
  (l1 & l2).uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_common
    candidate = method(:common)
    assert_equal([1, 5, 653], candidate.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))
    assert_equal([2, 3], candidate.call([5, 3, 2, 8], [3, 2]))
    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3, 2, 4]))
    assert_equal([], candidate.call([4, 3, 2, 8], []))
  end
end
"
HumanEval_59,kbp_Latn,rb,"Pɩsɩ nɛ ŋna-ɩ kɩlɛlʋʋ.# >>> largest_prime_factor.call(13195)
# 29
# >>> largest_prime_factor.call(2048)
# 2
def largest_prime_factor(n)
","def largest_prime_factor(n)
  factor = 2
  while factor * factor <= n
    if n % factor == 0
      n /= factor
    else
      factor += 1
    end
  end
  n
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_prime_factor
    candidate = method(:largest_prime_factor)
    assert_equal(5, candidate.call(15))
    assert_equal(3, candidate.call(27))
    assert_equal(7, candidate.call(63))
    assert_equal(11, candidate.call(330))
    assert_equal(29, candidate.call(13195))
  end
end
"
HumanEval_60,kbp_Latn,rb,"sum_to_n kɛna tʋmɩyɛ nɖɩ ɖɩtɔyɩɣ 1 nɛ puwolo n yɔ.# >>> sum_to_n.call(30)
# 465
# >>> sum_to_n.call(100)
# 5050
# >>> sum_to_n.call(5)
# 15
# >>> sum_to_n.call(10)
# 55
# >>> sum_to_n.call(1)
# 1
def sum_to_n(n)
","def sum_to_n(n)
  (1..n).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_to_n
    candidate = method(:sum_to_n)
    assert_equal(1, candidate.call(1))
    assert_equal(21, candidate.call(6))
    assert_equal(66, candidate.call(11))
    assert_equal(465, candidate.call(30))
    assert_equal(5050, candidate.call(100))
  end
end
"
HumanEval_61,kbp_Latn,rb,"Pɩsɩɣna nɛ ŋtɩlɩ se paa tɔmpiye nɖɩ lɛ, ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ.'parenthes' kɛna ""("" nɛ """") pa-taa tɔm.# >>> correct_bracketing.call(""("")
# false
# >>> correct_bracketing.call(""()"")
# true
# >>> correct_bracketing.call(""(()())"")
# true
# >>> correct_bracketing.call("")(()"")
# false
def correct_bracketing(brackets)
","def correct_bracketing(brackets)
  balance = 0
  brackets.each_char do |char|
    if char == '('
      balance += 1
    elsif char == ')'
      balance -= 1
    end
    return false if balance < 0
  end
  balance == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_correct_bracketing
    candidate = method(:correct_bracketing)
    assert_equal(true, candidate.call(""()""))
    assert_equal(true, candidate.call(""(()())""))
    assert_equal(true, candidate.call(""()()(()())()""))
    assert_equal(true, candidate.call(""()()((()()())())(()()(()))""))
    assert_equal(false, candidate.call(""((()())))""))
    assert_equal(false, candidate.call("")(()""))
    assert_equal(false, candidate.call(""(""))
    assert_equal(false, candidate.call(""((((""))
    assert_equal(false, candidate.call("")""))
    assert_equal(false, candidate.call(""(()""))
    assert_equal(false, candidate.call(""()()(()())())(()""))
    assert_equal(false, candidate.call(""()()(()())()))()""))
  end
end
"
HumanEval_62,kbp_Latn,rb,"Pɩpɩsɩ polinomiye ɖɩnɛ ɖɩ-tɛ derivative nɛ ɖɩ-wɛtʋ kɩlɩna ɖama.xs[0] + xs[1] * x + xs[2] * x^2 + .... xs kɛna polinomiye naɖɩyɛ tɛ coefficient waa.# >>> derivative.call([3, 1, 2, 4, 5])
# [1, 4, 12, 20]
# >>> derivative.call([1, 2, 3])
# [2, 6]
def derivative(xs)
","def derivative(xs)
  return [] if xs.length < 2
  xs.each_with_index.map { |coef, index| coef * index }[1..-1]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_derivative
    candidate = method(:derivative)
    assert_equal([1, 4, 12, 20], candidate.call([3, 1, 2, 4, 5]))
    assert_equal([2, 6], candidate.call([1, 2, 3]))
    assert_equal([2, 2], candidate.call([3, 2, 1]))
    assert_equal([2, 2, 0, 16], candidate.call([3, 2, 1, 0, 4]))
    assert_equal([], candidate.call([1]))
  end
end
"
HumanEval_63,kbp_Latn,rb,"Pɩsa nɛ ŋtɩlɩ ɛzɩma ŋpɩzɩɣ ŋla nɛ ŋlɩzɩ ɛ-tɛ n-tɛ hɔɔlɩŋ weyi ɛ-taa ɛ-tɛ hɔɔlɩŋ wɛɛ yɔ.Fibɔrɩyɔm (n) == Fibɔrɩyɔm (n-1) + Fibɔrɩyɔm (n-2) + Fibɔrɩyɔm (n-3). (Cɔnɩ tayʋʋ 1)(Cɔnɩ tayʋʋ 1)fɩfɩfɩ ((0) == 0 FibFib n̄ɩnʋʋ n̄ɩnʋʋ kɛ n̄ɩnʋʋ ŋgʋ kɩwɛ ɛzɩ Fibbonacci n̄ɩnʋʋ yɔ nɛ kɩ-tɔm n̄ɩnʋʋ kɔyɔ:# >>> fibfib.call(1)
# 0
# >>> fibfib.call(5)
# 4
# >>> fibfib.call(8)
# 24
def fibfib(n)
","def fibfib(n)
  return 0 if n == 0 || n == 1
  return 1 if n == 2

  a, b, c = 0, 0, 1
  (3..n).each do
    a, b, c = b, c, a + b + c
  end
  c
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fibfib
    candidate = method(:fibfib)
    assert_equal(1, candidate.call(2))
    assert_equal(0, candidate.call(1))
    assert_equal(4, candidate.call(5))
    assert_equal(24, candidate.call(8))
    assert_equal(81, candidate.call(10))
    assert_equal(274, candidate.call(12))
    assert_equal(927, candidate.call(14))
  end
end
"
HumanEval_64,kbp_Latn,rb,"Kɩɖaʋ: Tɔm piye nɖɩ ɖɩ-tɛ matʋ kɔyɔ:Tɔmpiye nɖɩ ɖɩ-taa pamaɣna tɔmpiye nɖɩ yɔ, ɖɩ-taa lɛ, ""a"", ""e"", ""i"", ""o"", ""u"".Ɛ-tɛ tɔm piye nɖɩ ɖɩ-tɛ tɔm pee kɩkpɛdɩŋ yɔ, ɖɩ-tɛ tɔm pee kɩkpɛdɩŋ nɛ ɖɩ-tɛ tɔm pee kɩkpɛdɩŋ.Maʋ tʋmɩyɛ nɖɩ payaɣ se vowels_count yɔ ɖɩ-taa tɔmpiye nɖɩ ɖɩwɩlɩɣ se # >>> vowels_count.call(""abcde"")
# 2
# >>> vowels_count.call(""ACEDY"")
# 3
def vowels_count(s)
","def vowels_count(s)
  vowels = ['a', 'e', 'i', 'o', 'u']
  count = 0
  
  s.chars.each_with_index do |char, index|
    if vowels.include?(char.downcase)
      count += 1
    elsif char.downcase == 'y' && index == s.length - 1
      count += 1
    end
  end
  
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_vowels_count
    candidate = method(:vowels_count)
    assert_equal(2, candidate.call(""abcde""))
    assert_equal(3, candidate.call(""Alone""))
    assert_equal(2, candidate.call(""key""))
    assert_equal(1, candidate.call(""bye""))
    assert_equal(2, candidate.call(""keY""))
    assert_equal(1, candidate.call(""bYe""))
    assert_equal(3, candidate.call(""ACEDY""))
  end
end
"
HumanEval_65,kbp_Latn,rb,"Ye shift > nimero waa yɔ, pɩpɩsɩɣ nimero waa mba pɛlɛɣzɩ-wɛ yɔ.nɛ pɩpɩsɩɣ pɩ-tɛ lɩmaɣzɩyɛ ɛzɩ tɔmpiye yɔ. Pɩcɔ nɛ ɖɩna kɔyɔ, ɖɩnaɣ se x kɛ ɛyʊ ɛyʊ, ɛyʊ ɛyʊ ɛyʊ, ɛyʊ ɛyʊ ɛyʊ.# >>> circular_shift.call(12, 1)
# ""21""
# >>> circular_shift.call(12, 2)
# ""12""
def circular_shift(x, shift)
","def circular_shift(x, shift)
  digits = x.to_s.chars
  num_digits = digits.length

  if shift > num_digits
    return digits.reverse.join
  else
    shift = shift % num_digits
    shifted_digits = digits.rotate(-shift)
    return shifted_digits.join
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_circular_shift
    candidate = method(:circular_shift)
    assert_equal(""001"", candidate.call(100, 2))
    assert_equal(""12"", candidate.call(12, 2))
    assert_equal(""79"", candidate.call(97, 8))
    assert_equal(""21"", candidate.call(12, 1))
    assert_equal(""11"", candidate.call(11, 101))
  end
end
"
HumanEval_66,kbp_Latn,rb,"Kɩɖaŋ: ASCII mayaɣ.Ma tʋmɩyɛ naɖɩyɛ nɛ ɖɩkpaɣ tɔmpiye naɖɩyɛ nɛ ɖɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-taa tɔm pee kɩkpaɖaa yɔ, ɖɩ-ñɔɔzʋʋ yem.'Tʋmɩyɛ # >>> digitSum.call("""")
# 0
# >>> digitSum.call(""abAB"")
# 131
# >>> digitSum.call(""abcCd"")
# 67
# >>> digitSum.call(""helloE"")
# 69
# >>> digitSum.call(""woArBld"")
# 131
# >>> digitSum.call(""aAaaaXa"")
# 153
def digitSum(s)
","def digitSum(s)
  s.chars.select { |char| char =~ /[A-Z]/ }.map(&:ord).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_digitSum
    candidate = method(:digitSum)
    assert_equal(0, candidate.call(""""))
    assert_equal(131, candidate.call(""abAB""))
    assert_equal(67, candidate.call(""abcCd""))
    assert_equal(69, candidate.call(""helloE""))
    assert_equal(131, candidate.call(""woArBld""))
    assert_equal(153, candidate.call(""aAaaaXa""))
    assert_equal(151, candidate.call("" How are yOu?""))
    assert_equal(327, candidate.call(""You arE Very Smart""))
  end
end
"
HumanEval_67,kbp_Latn,rb,"Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ: Mango pee wena awɛ kaɖaɣ taa yɔ, a-taa lɛ, ŋpɩzɩɣ ŋlɩzɩ a-taa pee wena awɛ kaɖaɣ taa yɔ.Lɛɛlɛyɔ, pɔmbɔɔ nɛ pɔmbɔɔ nɛ pɩtasɩna nimero entier ŋgʋ kɩwɩlɩɣ pee tɩŋa yɔ Ɖɩkpaɣ ɛzɩ pɔpɔtʋ yɔ, nɛ ɖɩkpaɣ ɛzɩ pɔpɔtʋ yɔ, nɛ ɖɩkpaɣ ɛzɩ pɔpɔtʋ yɔ, nɛ ɖɩkpaɣ ɛzɩ pɔpɔtʋ yɔ, nɛ ɖɩkpaɣ ɛzɩ pɔpɔtʋ yɔ, nɛ ɖɩkpaɣ ɛzɩ pɔpɔtʋ yɔ.Pɩkɛna tɩŋ pee wena awɛ ɖɔmbɛɛ taa yɔ.Pɩtɛ tʋmɩyɛ ɖɩnɛ ɖɩ-taa, pakaɣ-ŋ haʋ tɔmpiye nɖɩ ɖɩwɩlɩɣ pɔpɔtʋ nɛ pombowaa yɔ.# >>> fruit_distribution.call(""5 apples and 6 oranges"", 19)
# 8
# >>> fruit_distribution.call(""0 apples and 1 oranges"", 3)
# 2
# >>> fruit_distribution.call(""2 apples and 3 oranges"", 100)
# 95
# >>> fruit_distribution.call(""100 apples and 1 oranges"", 120)
# 19
def fruit_distribution(s, n)
","def fruit_distribution(s, n)
  numbers = s.scan(/\d+/).map(&:to_i)
  apples = numbers[0]
  oranges = numbers[1]
  total_fruits = n
  mangos = total_fruits - (apples + oranges)
  mangos
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fruit_distribution
    candidate = method(:fruit_distribution)
    assert_equal(8, candidate.call(""5 apples and 6 oranges"", 19))
    assert_equal(10, candidate.call(""5 apples and 6 oranges"", 21))
    assert_equal(2, candidate.call(""0 apples and 1 oranges"", 3))
    assert_equal(2, candidate.call(""1 apples and 0 oranges"", 3))
    assert_equal(95, candidate.call(""2 apples and 3 oranges"", 100))
    assert_equal(0, candidate.call(""2 apples and 3 oranges"", 5))
    assert_equal(19, candidate.call(""1 apples and 100 oranges"", 120))
  end
end
"
HumanEval_68,kbp_Latn,rb,"Kɩɖaʋ 1:Yee ɛyʊ ɛfɛyɩna ɛ-tɛ kɩlabʊ yaa ɛ-tɛ kɩlabʊ kɔyɔ, ɛpɩsɩɣ [].Pɩwɛɛ se patasɩ lɩzʋʋ tɔmpiye nɖɩ ɖɩ-taa paɖʊ-ɖɩ yɔ, [smallest_value, its index] taa, Yee panaa nɩŋgbaŋgʊʊ ndɩ ndɩ nɛ kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna kɩwɛna.Pɩwɛɛ se pʊtʊ weyi ɛ-taa ɛ-tɛ ɛyʊ wɛ yɔ, ɛ-tɛ ɛyʊ wɛʊ yɔ, ɛwɛna ɛyʊ kɩkpɛdʊ.Pɩwɛɛ se ŋlɩzɩ-kɛ nɛ ŋyele-kɛ nɛ ŋpɩsɩ-kɛ.""Ɛzɩma pamaɣna tɩʋ nakʋyʋ piliŋa ŋga kɛfɛyɩna hɔɔlɩŋ kɩtatʋʋzɩŋ yɔ, # >>> pluck.call([4, 2, 3])
# [2, 1]
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 2:
# >>> pluck.call([1, 2, 3])
# [2, 1]
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 3:
# >>> pluck.call([])
# []
# Example 4:
# >>> pluck.call([5, 0, 3, 0, 4, 2])
# [0, 1]
# Explanation: 0 is the smallest value, but  there are two zeros,
# so we will choose the first zero, which has the smallest index.
# Constraints:
# * 1 <= nodes.length <= 10000
# * 0 <= node.value
def pluck(arr)
","def pluck(arr)
  smallest_even = nil
  smallest_index = nil
  
  arr.each_with_index do |value, index|
    if value.even?
      if smallest_even.nil? || value < smallest_even
        smallest_even = value
        smallest_index = index
      end
    end
  end

  smallest_even.nil? ? [] : [smallest_even, smallest_index]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_pluck
    candidate = method(:pluck)
    assert_equal([2, 1], candidate.call([4, 2, 3]))
    assert_equal([2, 1], candidate.call([1, 2, 3]))
    assert_equal([], candidate.call([]))
    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))
    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))
    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))
    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))
    assert_equal([], candidate.call([7, 9, 7, 1]))
  end
end
"
HumanEval_69,kbp_Latn,rb,"Kɩɖaŋ: Yee pɩfɛyɩ kɔyɔ, pɩpɩsɩɣ -1.Ɛyʊ kʊyʊm kpɛlɛkʊʊ taa lɛ, ɛ-tɛ kʊyʊm kpɛlɛkʊʊ taa lɛ, pɩkɛ tam ɛzɩma ɛ-tɛ kʊyʊm kpɛlɛkʊʊ taa wɛʊ yɔ.Pɩtɛ lɛ, ɛyʊ wɛna ɛ-tɩ yɔɔ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ.Pɩtɛ lɛ, ŋnaɣ ɛyʊ weyi ɛ-tɛ ɛyʊ kɩlɩna ɖɔʊ yɔ nɛ ɛ-tɛ ɛyʊ kɩlɩna ɖɔʊ yɔ.# >>> search.call([4, 1, 2, 2, 3, 1])
# 2
# >>> search.call([1, 2, 2, 3, 3, 3, 4, 4, 4])
# 3
# >>> search.call([5, 5, 4, 4, 4])
# -1
def search(lst)
","def search(lst)
  freq_hash = lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }
  valid_numbers = freq_hash.select { |num, freq| freq >= num }.keys
  valid_numbers.empty? ? -1 : valid_numbers.max
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_search
    candidate = method(:search)
    assert_equal(1, candidate.call([5, 5, 5, 5, 1]))
    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))
    assert_equal(-1, candidate.call([3, 3]))
    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8, 8, 8]))
    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))
    assert_equal(1, candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]))
    assert_equal(2, candidate.call([3, 2, 8, 2]))
    assert_equal(1, candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))
    assert_equal(-1, candidate.call([8, 8, 3, 6, 5, 6, 4]))
    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))
    assert_equal(1, candidate.call([1, 9, 10, 1, 3]))
    assert_equal(5, candidate.call([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))
    assert_equal(1, candidate.call([1]))
    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))
    assert_equal(2, candidate.call([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))
    assert_equal(1, candidate.call([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))
    assert_equal(4, candidate.call([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]))
    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))
    assert_equal(2, candidate.call([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))
    assert_equal(-1, candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]))
    assert_equal(-1, candidate.call([10]))
    assert_equal(2, candidate.call([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))
    assert_equal(1, candidate.call([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))
    assert_equal(1, candidate.call([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))
    assert_equal(-1, candidate.call([3, 10, 10, 9, 2]))
  end
end
"
HumanEval_70,kbp_Latn,rb,"Kɩɖaŋ: Pɩtɛ lɛ, ɛtɛyɩɣ ɛ-tɛ kɩlɩm nɛ ɛtɛyɩɣ ɛ-tɛ kɩlɩm nɛ pɩtɛ lɛ, ɛtɛyɩɣ ɛ-tɛ kɩlɩm nɛ pɩtɛ lɛ, ɛtɛyɩɣ ɛ-tɛ kɩlɩm.Pɩwɛ ɛzɩ ŋpaɣzɩɣnɩ kɩjɛyʊʊ yɔ, Ye ŋha-ɩ hɔɔlɩŋ weyi ɩ-taa ɛ-taa wɛ tɔm hɔɔlɩŋ tɩŋa yɔ, ɛkaɣ-ɩ pɩsʋʋ hɔɔlɩŋ weyi ɩ-taa ɛfɛyɩ yɔ.# >>> strange_sort_list.call([1, 2, 3, 4])
# [1, 4, 2, 3]
# >>> strange_sort_list.call([5, 5, 5, 5])
# [5, 5, 5, 5]
# >>> strange_sort_list.call([])
# []
def strange_sort_list(lst)
","def strange_sort_list(lst)
  result = []
  lst.sort!
  until lst.empty?
    result << lst.shift
    result << lst.pop unless lst.empty?
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_strange_sort_list
    candidate = method(:strange_sort_list)
    assert_equal([1, 4, 2, 3], candidate.call([1, 2, 3, 4]))
    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))
    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))
    assert_equal([1, 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))
    assert_equal([5, 5, 5, 5], candidate.call([5, 5, 5, 5]))
    assert_equal([], candidate.call([]))
    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7, 8]))
    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2, 5, 5, -5, -5]))
    assert_equal([111111], candidate.call([111111]))
  end
end
"
HumanEval_71,kbp_Latn,rb,"Kɩɖaʋ: Ɛlɛ, hɔɔlʋʋ naadozo ñɩŋgʋ taa lɛ, pɩcɛzɩ mbʋ.Hɔɔlɩŋ naadozo wɛna tam nabudozo taa yee ɛ-hɔɔlɩŋ naalɛ ɩ-taa ɛ-tɛ ɖɔʊ ɛkɩlɩ kɔyɔ.Pɩtɛkɛ mbʋ yɔ, pɩpɩsɩɣ -1 Pɩtɛ tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa.Ye ɖɩkpaɣ ɛzɩ pʊtʊnaa mba pɛtɛyɩɣ ɖama yɔ, ɖɩkpaɣ pʊtʊnaa mba pɛtɛyɩɣ ɖama yɔ nɛ ɖɩpɩsɩ pʊtʊnaa mba pɛtɛyɩɣ ɖama yɔ.# >>> triangle_area.call(3, 4, 5)
# 6.0
# >>> triangle_area.call(1, 2, 10)
# -1
def triangle_area(a, b, c)
","def triangle_area(a, b, c)
  # Check for valid triangle
  if a + b > c && a + c > b && b + c > a
    # Calculate the semi-perimeter
    s = (a + b + c) / 2.0
    # Calculate the area using Heron's formula
    area = Math.sqrt(s * (s - a) * (s - b) * (s - c))
    # Round to 2 decimal points
    return area.round(2)
  else
    return -1
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triangle_area
    candidate = method(:triangle_area)
    assert_equal(6.0, candidate.call(3, 4, 5))
    assert_equal(-1, candidate.call(1, 2, 10))
    assert_equal(8.18, candidate.call(4, 8, 5))
    assert_equal(1.73, candidate.call(2, 2, 2))
    assert_equal(-1, candidate.call(1, 2, 3))
    assert_equal(16.25, candidate.call(10, 5, 7))
    assert_equal(-1, candidate.call(2, 6, 3))
    assert_equal(0.43, candidate.call(1, 1, 1))
    assert_equal(-1, candidate.call(2, 2, 10))
  end
end
"
HumanEval_72,kbp_Latn,rb,"Kɩɖaʋ: Pɩkɛ palindromie matrice nɛ ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrice taa ɛ-tɛ matrix taa ɛ-tɛ matrix taa ɛ-tɛ matrix taa ɛ-tɛ matrix taa ɛ-tɛ matrix taaMa tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔm ndʋ tɩkɛ toovenim yɔ, ye tɔm ndʋ tɩ-taa tɔm kɩlɩʋ ɛlɩwa yɔ, tɩkɛ toovenim nɛ ye tɩtɩkɛ toovenim yɔ, tɩkɛ cɛtɩm.# >>> will_it_fly.call([1, 2], 5)
# false
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly.call([3, 2, 3], 1)
# false
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly.call([3, 2, 3], 9)
# true
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly.call([3], 5)
# true
# # 3 is less than the maximum possible weight, and it's balanced.
def will_it_fly(q, w)
","def will_it_fly(q, w)
  is_palindrome = q == q.reverse
  total_weight = q.sum
  is_balanced_and_under_weight = is_palindrome && total_weight <= w
  is_balanced_and_under_weight
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_will_it_fly
    candidate = method(:will_it_fly)
    assert_equal(true, candidate.call([3, 2, 3], 9))
    assert_equal(false, candidate.call([1, 2], 5))
    assert_equal(true, candidate.call([3], 5))
    assert_equal(false, candidate.call([3, 2, 3], 1))
    assert_equal(false, candidate.call([1, 2, 3], 6))
    assert_equal(true, candidate.call([5], 5))
  end
end
"
HumanEval_73,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Ŋpɩzɩɣ nɛ ŋlɛɣzɩ hɔɔlʋʋ nakʋyʋ nɛ ŋla lɛɛbʋ.Pɩwɛɛ se pɛlɛɣzɩ-ɩ se pɩsa nɛ ɛ-tɛ matriki wɛɛ camɩyɛ. Matriki ŋgʋ kɩwɛ camɩyɛ yɔ, kɩwɛna matriki ŋgʋ kɩ-taa Ye ŋha-ɩ nimero waa tɩŋa nɛ pʊcɔ ŋtɛzɩ-ɩ yɔ, ŋñɩnɩ ɛyʊ weyi ɛ-ñʊʊ mayaɣ kɔyɔ # >>> smallest_change.call([1, 2, 3, 5, 4, 7, 9, 6])
# 4
# >>> smallest_change.call([1, 2, 3, 4, 3, 2, 2])
# 1
# >>> smallest_change.call([1, 2, 3, 2, 1])
# 0
def smallest_change(arr)
","def smallest_change(arr)
  changes = 0
  left = 0
  right = arr.length - 1

  while left < right
    if arr[left] != arr[right]
      changes += 1
    end
    left += 1
    right -= 1
  end

  changes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_smallest_change
    candidate = method(:smallest_change)
    assert_equal(4, candidate.call([1, 2, 3, 5, 4, 7, 9, 6]))
    assert_equal(1, candidate.call([1, 2, 3, 4, 3, 2, 2]))
    assert_equal(1, candidate.call([1, 4, 2]))
    assert_equal(1, candidate.call([1, 4, 4, 2]))
    assert_equal(0, candidate.call([1, 2, 3, 2, 1]))
    assert_equal(0, candidate.call([3, 1, 1, 3]))
    assert_equal(0, candidate.call([1]))
    assert_equal(1, candidate.call([0, 1]))
  end
end
"
HumanEval_74,kbp_Latn,rb,"Kɩɖaŋ Yee matriki naalɛ ɩwɛna matriki kɩkpɛdʊʊ kɔyɔ, pɩpɩsɩɣ kajalaɣ matriki.Kajalaɣ ñɩŋga lɛ se, paa ɛyʊ weyi lɛ, ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛMaʋ tʋmɩyɛ nɖɩ ɖɩmʋna matʋ naalɛ nɛ ɖɩpɩsɩ matʋ ndʋ tɩ-taa wɛ tɔmpiye  yɔ.# >>> total_match.call([], [])
# []
# >>> total_match.call([""hi"", ""admin""], [""hI"", ""Hi""])
# [""hI"", ""Hi""]
# >>> total_match.call([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""])
# [""hi"", ""admin""]
# >>> total_match.call([""hi"", ""admin""], [""hI"", ""hi"", ""hi""])
# [""hI"", ""hi"", ""hi""]
# >>> total_match.call([""4""], [""1"", ""2"", ""3"", ""4"", ""5""])
# [""4""]
def total_match(lst1, lst2)
","def total_match(lst1, lst2)
  total_chars1 = lst1.map(&:length).sum
  total_chars2 = lst2.map(&:length).sum

  if total_chars1 < total_chars2
    lst1
  elsif total_chars2 < total_chars1
    lst2
  else
    lst1
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_total_match
    candidate = method(:total_match)
    assert_equal([], candidate.call([], []))
    assert_equal([""hi"", ""hi""], candidate.call([""hi"", ""admin""], [""hi"", ""hi""]))
    assert_equal([""hi"", ""admin""], candidate.call([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""]))
    assert_equal([""4""], candidate.call([""4""], [""1"", ""2"", ""3"", ""4"", ""5""]))
    assert_equal([""hI"", ""Hi""], candidate.call([""hi"", ""admin""], [""hI"", ""Hi""]))
    assert_equal([""hI"", ""hi"", ""hi""], candidate.call([""hi"", ""admin""], [""hI"", ""hi"", ""hi""]))
    assert_equal([""hi"", ""admin""], candidate.call([""hi"", ""admin""], [""hI"", ""hi"", ""hii""]))
    assert_equal([], candidate.call([], [""this""]))
    assert_equal([], candidate.call([""this""], []))
  end
end
"
HumanEval_75,kbp_Latn,rb,"Kɩɖaʋ: Ɖɩtɩlɩɣ se a) kɛ 100 ɛlɛ pɩtaatalɩ 100.Pɩtasɩ lɛ, tɔm ndʋ tɩtɩkɛ toovenim.Maɣna se ɛyʊ ɛpɩzɩ ɛlɩzɩ ɛ-tɛ ɛyʊ tɔm kɔyɔ, ɛ-tɛ ɛyʊ tɔm kɛ 3 taa ɛyʊ tɔm.# >>> is_multiply_prime.call(30)
# true
# 30 = 2 * 3 * 5
def is_multiply_prime(a)
","require 'prime'

def is_multiply_prime(a)
  return false if a >= 100
  prime_factors = a.prime_division
  return true if prime_factors.size == 3 && prime_factors.all? { |_, exponent| exponent == 1 }
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_multiply_prime
    candidate = method(:is_multiply_prime)
    assert_equal(false, candidate.call(5))
    assert_equal(true, candidate.call(30))
    assert_equal(true, candidate.call(8))
    assert_equal(false, candidate.call(10))
    assert_equal(true, candidate.call(125))
    assert_equal(true, candidate.call(105))
    assert_equal(false, candidate.call(126))
    assert_equal(false, candidate.call(729))
    assert_equal(false, candidate.call(891))
    assert_equal(true, candidate.call(1001))
  end
end
"
HumanEval_76,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: x kɛ n tɛ ɖoŋ mbʊ pʊyɔɔ yɔ n**int=x Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.Pɩwɛɛ se ŋma function ŋgʋ kɩpɩsɩɣ true yee x kɛ ɛyʊ yem yɔ.# >>> is_simple_power.call(1, 4)
# true
# >>> is_simple_power.call(2, 2)
# true
# >>> is_simple_power.call(8, 2)
# true
# >>> is_simple_power.call(3, 2)
# false
# >>> is_simple_power.call(3, 1)
# false
# >>> is_simple_power.call(5, 3)
# false
def is_simple_power(x, n)
","def is_simple_power(x, n)
  return false if x <= 0 || n <= 1
  return true if x == 1

  power = n
  while power <= x
    return true if power == x
    power *= n
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_simple_power
    candidate = method(:is_simple_power)
    assert_equal(true, candidate.call(16, 2))
    assert_equal(false, candidate.call(143214, 16))
    assert_equal(true, candidate.call(4, 2))
    assert_equal(true, candidate.call(9, 3))
    assert_equal(true, candidate.call(16, 4))
    assert_equal(false, candidate.call(24, 2))
    assert_equal(false, candidate.call(128, 4))
    assert_equal(false, candidate.call(12, 6))
    assert_equal(true, candidate.call(1, 1))
    assert_equal(true, candidate.call(1, 12))
  end
end
"
HumanEval_77,kbp_Latn,rb,"Kɩɖaŋ: Tɔzɩ se ŋpɩzɩɣ nɛ ŋmaɣzɩ se tɔm ndʋ ŋma yɔ tɩkɛ toovenim paa ɛzɩmtaa.Yee ɛyʊ ɛnɛ ɛkɛ ɛyʊ ɛyʊ tɛ kʊyʊm yɔ.Maɣna tʋmɩyɛ nɖɩ ɖɩkpaɣɣ ɛyʊ hɔɔlɩŋ tɩŋa taa a nɛ ɖɩpɩsɩɣ ɛ-tɛ tɔm yɔ .# >>> iscube.call(1)
# true
# >>> iscube.call(2)
# false
# >>> iscube.call(-1)
# true
# >>> iscube.call(64)
# true
# >>> iscube.call(0)
# true
# >>> iscube.call(180)
# false
def iscube(a)
","def iscube(a)
  cube_root = a.abs**(1.0/3)
  cube_root.round**3 == a
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_iscube
    candidate = method(:iscube)
    assert_equal(true, candidate.call(1))
    assert_equal(false, candidate.call(2))
    assert_equal(true, candidate.call(-1))
    assert_equal(true, candidate.call(64))
    assert_equal(false, candidate.call(180))
    assert_equal(true, candidate.call(1000))
    assert_equal(true, candidate.call(0))
    assert_equal(false, candidate.call(1729))
  end
end
"
HumanEval_78,kbp_Latn,rb,"Kɩɖaŋ: nɛ matʋ A,B,C,D,E,F wɛ ɖoŋ ɖoŋ.Pɩsɩ nɛ ŋna-ɩ tɔm kɩcɛyɩtʋ: Ŋpɩzɩɣ ŋmaɣzɩ se tɔm ndʋ ŋɖʋwa yɔ tɩkɛ toovenim yaa tɩkɛ cɛjɛsɩ.B (= decimal 11), D (= decimal 13) Pʋ-tɔbʋʋ se ŋñɩnɩɣ se ŋtɩlɩ hɔɔlɩŋ weyi ɩ-taa lɛ, 2, 3, 5, 7, Kɩ-tɛ kajalaɣ hɔɔlɩŋ kɔyɔ: 2, 3, 5, 7, 11, 13, 17...Hexadecimal waa kɔyɔ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.Kɩ-tɛ lɛɣtʊ takayaɣ taa lɛ, pamaɣ se pɩlɩna ɛyʊ yɔɔ lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ.Ɛkɛ hexadecimalɩ mayaɣ ŋga kɛwɛ ɛzɩ ɛyʊ yɔ nɛ ɛmakɩ ɛ-tɛ hexadecimalɩ mayaɣ Payaɣ-mɩ se ŋma tʋmɩyɛ nɖɩ ɖɩmʋyaa yɔ.# >>> hex_key.call(""AB"")
# 1
# >>> hex_key.call(""1077E"")
# 2
# >>> hex_key.call(""ABED1A33"")
# 4
# >>> hex_key.call(""123456789ABCDEF0"")
# 6
# >>> hex_key.call(""2020"")
# 2
def hex_key(num)
","def hex_key(num)
  prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']
  num.chars.count { |digit| prime_hex_digits.include?(digit) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_hex_key
    candidate = method(:hex_key)
    assert_equal(1, candidate.call(""AB""))
    assert_equal(2, candidate.call(""1077E""))
    assert_equal(4, candidate.call(""ABED1A33""))
    assert_equal(2, candidate.call(""2020""))
    assert_equal(6, candidate.call(""123456789ABCDEF0""))
    assert_equal(12, candidate.call(""112233445566778899AABBCCDDEEFF00""))
  end
end
"
HumanEval_79,kbp_Latn,rb,"Kɩɖaŋ: Pɩwɛɛ se pama tɔm pee ana nɛ pɩkpaɖɩ mbʋ pamaɣ yɔ.Pɩkaɣ kɛʋna tɔmpiye 'db' pazɩyɛ nɛ ɖɩtɛ lɛɣtʋ ñɩnɩyaa.Paa mayaɣ ŋga lɛ, kɛwɛɣ "" 0 "" yaa "" 1 "".Pɩwɛɛ se tʊmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔmpiye, nɛ paa mayaɣ ŋga lɛ kɛwɛna binɛɛrɩ tɔmpiye Pʊtɔbʊʊ se ŋwɛna ŋñɩɩtʊ nɛ ŋñɩɩtʊ nɛ ŋñɩɩtʊ nɛ ŋñɩɩtʊ nɛ ŋñɩɩtʊ nɛ ŋñɩɩtʊ nɛ ŋñɩɩtʊ nɛ ŋñɩɩtʊ.# >>> decimal_to_binary.call(15)
# ""db1111db""
# >>> decimal_to_binary.call(32)
# ""db100000db""
def decimal_to_binary(decimal)
","def decimal_to_binary(decimal)
  ""db"" + decimal.to_s(2) + ""db""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_decimal_to_binary
    candidate = method(:decimal_to_binary)
    assert_equal(""db0db"", candidate.call(0))
    assert_equal(""db100000db"", candidate.call(32))
    assert_equal(""db1100111db"", candidate.call(103))
    assert_equal(""db1111db"", candidate.call(15))
  end
end
"
HumanEval_80,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Kɩ-tɛ tɔmpiye wɛʊ lɛ, yee kɩ-tɛ tɔmpiye ɛfɛyɩna 3 nɛ paa tɔmpiye nɖɩ lɛ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩfɛyɩna 3 yɔ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-tɔmpiye nɖɩ ɖɩ-tɔmpiye nɖɩ ɖɩ-tɔmpiye nɖɩ ɖɩ-taa.Pɩwɛɛ se ŋtazɩ nɛ ŋna se tɔm ndʋ tɩ-taa ŋwɛɛ yɔ, tɩkɛ toovenim yaa tɩkɛ toovenim.Pʊtɔbʊʊ se ŋwɛna ñʊʊ mayaɣ kʊyʊmʊ.# >>> is_happy.call(""a"")
# false
# >>> is_happy.call(""aa"")
# false
# >>> is_happy.call(""abcd"")
# true
# >>> is_happy.call(""aabb"")
# false
# >>> is_happy.call(""adb"")
# true
# >>> is_happy.call(""xyy"")
# false
def is_happy(s)
","def is_happy(s)
  return false if s.length < 3
  
  (0..s.length - 3).each do |i|
    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]
  end
  
  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_happy
    candidate = method(:is_happy)
    assert_equal(false, candidate.call(""a""))
    assert_equal(false, candidate.call(""aa""))
    assert_equal(true, candidate.call(""abcd""))
    assert_equal(false, candidate.call(""aabb""))
    assert_equal(true, candidate.call(""adb""))
    assert_equal(false, candidate.call(""xyy""))
    assert_equal(true, candidate.call(""iopaxpoi""))
    assert_equal(false, candidate.call(""iopaxioi""))
  end
end
"
HumanEval_81,kbp_Latn,rb,"Kɩɖaʋ: 0.0 E > 0.0 D- > 0.7 D > 1.0 D+ > 1.3 C- > 1.7 C > 2.0 C+ > 2.3 B- > 2.7 B > 3.0 B+ > 3.3 A- > 3.7 A 4.0 A+ Kpɛlɩ kpɛlɛkʋʋ.tʊmɩyɛ nɖɩ papɩzɩɣ nɛ palɩzɩ ɖɩ-tɛ tɔmpiye ndɩ ɖɩ-tɛ tɔmpiye ndɩ ɖɩ-tɛ tɔmpiye nɛ pɩlɩɩna takayɩhatʋ ndʋ tɩwɛ pɩ-tɛɛ yɔ tɩ-yɔɔ: Ɛha-ŋ takayɩsɩ ndɩ ndɩ nɛ pɩpɔzʋʋ se ŋma-sɩ .Ɛlɛ, ɛ-tɛ lɛɣtʋ ñɩnʋʋ mbʋ pɩ-yɔɔ ɛlɩwa yɔ, pɩfɛyɩ ɛ-cɔlɔ.Tɔm wɩlɩyʋ ɛnʋ ɛ-maɣmaɣ ɛlɩzaa nɛ ɛlabɩnɩ ɛ-tɩ takayɩsɩ nzɩ sɩ-taa ɛmaɣzɩɣ se ɛ-tɔm ɛkpɛlɩkɩɣ yɔ.Pɩkɛ fenasɩ kʊɖʊmɖɩyɛ tɛ kpɩtaʊ kɛtɛzaɣ taa nɛ wɩlɩyʊ wɛɛ nɛ ɛwɩlɩɣ ɛ-takayɩsɩ taa.# >>> grade_equation.call([4.0, 3, 1.7, 2, 3.5])
# [""A+"", ""B"", ""C-"", ""C"", ""A-""]
def numerical_letter_grade(grades)
","def numerical_letter_grade(grades)
  grades.map do |gpa|
    case 
    when gpa == 4.0
      ""A+""
    when gpa > 3.7
      ""A""
    when gpa > 3.3
      ""A-""
    when gpa > 3.0
      ""B+""
    when gpa > 2.7
      ""B""
    when gpa > 2.3
      ""B-""
    when gpa > 2.0
      ""C+""
    when gpa > 1.7
      ""C""
    when gpa > 1.3
      ""C-""
    when gpa > 1.0
      ""D+""
    when gpa > 0.7
      ""D""
    when gpa > 0.0
      ""D-""
    else
      ""E""
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_numerical_letter_grade
    candidate = method(:numerical_letter_grade)
    assert_equal([""A+"", ""B"", ""C-"", ""C"", ""A-""], candidate.call([4.0, 3, 1.7, 2, 3.5]))
    assert_equal([""D+""], candidate.call([1.2]))
    assert_equal([""D-""], candidate.call([0.5]))
    assert_equal([""E""], candidate.call([0.0]))
    assert_equal([""D"", ""D-"", ""C-"", ""B"", ""B+""], candidate.call([1.0, 0.3, 1.5, 2.8, 3.3]))
    assert_equal([""E"", ""D-""], candidate.call([0.0, 0.7]))
  end
end
"
HumanEval_82,kbp_Latn,rb,"Kɩɖaŋ Pɩtɛ lɛ, kɩ-kɩɖaʋ kɛna kɩjɛyʊʊ yaa kɩfɛyɩ ɖeu.Maʋ tʋmɩyɛ nɖɩ ɖɩkpaɣ tɔmpiye naɖɩyɛ nɛ ɖɩpɩsɩ tɔmpiye nɖɩ ɖɩkɛ toovenim yɔ, ye tɔmpiye nɖɩ ɖɩkɛ toovenim yɔ.# >>> prime_length.call(""Hello"")
# true
# >>> prime_length.call(""abcdcba"")
# true
# >>> prime_length.call(""kittens"")
# true
# >>> prime_length.call(""orange"")
# false
def prime_length(string)
","def prime_length(string)
  length = string.length
  return false if length < 2

  (2..Math.sqrt(length)).each do |i|
    return false if length % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prime_length
    candidate = method(:prime_length)
    assert_equal(true, candidate.call(""Hello""))
    assert_equal(true, candidate.call(""abcdcba""))
    assert_equal(true, candidate.call(""kittens""))
    assert_equal(false, candidate.call(""orange""))
    assert_equal(true, candidate.call(""wow""))
    assert_equal(true, candidate.call(""world""))
    assert_equal(true, candidate.call(""MadaM""))
    assert_equal(true, candidate.call(""Wow""))
    assert_equal(false, candidate.call(""""))
    assert_equal(true, candidate.call(""HI""))
    assert_equal(true, candidate.call(""go""))
    assert_equal(false, candidate.call(""gogo""))
    assert_equal(false, candidate.call(""aaaaaaaaaaaaaaa""))
    assert_equal(true, candidate.call(""Madam""))
    assert_equal(false, candidate.call(""M""))
    assert_equal(false, candidate.call(""0""))
  end
end
"
HumanEval_83,kbp_Latn,rb,"Kɩwɛna nimasɩ kɩbana sakɩyɛ nɛ sɩpaɣzɩɣ yaa sɩtɛzɩɣna 1.Ye paha-ɖʋ nimero intérieur positif n yɔ, ɖitiyini-i nimero intérieur n waa mba pa-taa lɛ, ɖɩkpaɣ nimero intérieur waa mba pa-taa lɛ, ɖɩkpaɣ nimero intérieur waa mba pa-taa lɛ, ɖɩkpaɣ nimero intérieur waa mba.def starts_one_ends(n)
","def starts_one_ends(n)
  return 0 if n <= 0

  # Count numbers starting with 1
  start_with_1 = 9 ** (n - 1)

  # Count numbers ending with 1
  end_with_1 = 9 ** (n - 1)

  # Adjust for double counting the number that both starts and ends with 1
  both_start_and_end_with_1 = 9 ** (n - 2) if n > 1
  
  start_with_1 + end_with_1 - (both_start_and_end_with_1 || 0)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_starts_one_ends
    candidate = method(:starts_one_ends)
    assert_equal(1, candidate.call(1))
    assert_equal(18, candidate.call(2))
    assert_equal(180, candidate.call(3))
    assert_equal(1800, candidate.call(4))
    assert_equal(18000, candidate.call(5))
  end
end
"
HumanEval_84,kbp_Latn,rb,"Kɩɖaʋ Pɩkɛna ɛyʊ kʊyʊm N, ɛ-tɛ kʊyʊm kʊyʊm tɔmpiye taa lɛ, pɩpɩsɩ ɛ-tɛ kʊyʊm kʊyʊm tɔmpiye taa.# >>> solve.call(1000)
# ""1""
# >>> solve.call(150)
# ""110""
# >>> solve.call(147)
# ""1100""
# Variables:
# @N integer
# Constraints: 0 ≤ N ≤ 10000.
# Output:
# a string of binary number
def solve(n)
","def solve(n)
  sum_of_digits = n.to_s.chars.map(&:to_i).sum
  sum_of_digits.to_s(2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solve
    candidate = method(:solve)
    assert_equal(""1"", candidate.call(1000))
    assert_equal(""110"", candidate.call(150))
    assert_equal(""1100"", candidate.call(147))
    assert_equal(""1001"", candidate.call(333))
    assert_equal(""10010"", candidate.call(963))
  end
end
"
HumanEval_85,kbp_Latn,rb,"Kɩɖaŋ: Pɩtɛ lɛ, ɖɩkpaɣ ɛyʊ weyi ɛfɛyɩna ɛ-tɩ yɔɔ yɔ nɛ ɖɩkpaɣ ɛ-tɛ ɛyʊ weyi ɛfɛyɩna ɛ-tɩ yɔɔ yɔ nɛ ɖɩkpaɣ ɛ-tɛ ɛyʊ weyi ɛfɛyɩna ɛ-tɩ yɔɔ yɔ nɛ ɖɩkpaɣ ɛ-tɛ ɛyʊ weyi ɛfɛyɩna ɛ-tɩ yɔɔ yɔ nɛ ɖɩkpaɣ ɛ-tɛ ɛyʊ weyi ɛfɛyɩna ɛ-tɩ yɔɔ yɔ.# >>> add.call([4, 2, 6, 7])
# 2
def add(lst)
","def add(lst)
  lst.each_with_index.select { |num, index| index.odd? && num.even? }.map(&:first).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add
    candidate = method(:add)
    assert_equal(88, candidate.call([4, 88]))
    assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))
    assert_equal(0, candidate.call([4, 0, 6, 7]))
    assert_equal(12, candidate.call([4, 4, 6, 8]))
  end
end
"
HumanEval_86,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Tɔzɩ se: Pɩwɛɛ se ŋɖɔ tɔm pee nɛ hɔɔlɩŋ weyi ɩ-taa ŋtɩŋ yɔ ɩ-yɔɔ.Pɩtɛ kɩlɛmʋʋ yɔɔ lɛ, ŋnaɣ mbʋ payaɣ se "" ascii value "" yɔ.Pɩsɩ nɛ ŋna-ɩ tɔm kɩfatʋ:Tɔmpiye nɖɩ ɖɩ-taa tɔm pee tɩŋa (pɩlɩna tɔm pee ndɩ ndɩ yɔɔ)Ma tʋmɩyɛ naɖɩyɛ nɛ ɖɩkpaɣ tɔmpiye naɖɩyɛ nɛ ɖɩpɩsɩ-ɖɩ nɛ ɖɩ-tɛ tɔmpiye nɖɩ ɖɩ-taa tɔmpiye naɖɩyɛ wɛɛ yɔ.# >>> anti_shuffle.call(""Hi"")
# ""Hi""
# >>> anti_shuffle.call(""hello"")
# ""ehllo""
# >>> anti_shuffle.call(""Hello World!!!"")
# ""Hello !!!Wdlor""
def anti_shuffle(s)
","def anti_shuffle(s)
  s.split(/(\s+)/).map { |word| word.chars.sort.join }.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_anti_shuffle
    candidate = method(:anti_shuffle)
    assert_equal(""Hi"", candidate.call(""Hi""))
    assert_equal(""ehllo"", candidate.call(""hello""))
    assert_equal(""bemnru"", candidate.call(""number""))
    assert_equal(""abcd"", candidate.call(""abcd""))
    assert_equal(""Hello !!!Wdlor"", candidate.call(""Hello World!!!""))
    assert_equal("""", candidate.call(""""))
    assert_equal("".Hi My aemn is Meirst .Rboot How aer ?ouy"", candidate.call(""Hi. My name is Mister Robot. How are you?""))
  end
end
"
HumanEval_87,kbp_Latn,rb,"Kɩɖaŋ: Pɩtasɩ lɛ, ŋpɩzɩɣ nɛ ŋlɩzɩ tɔm ndʋ tɩ-taa ŋcaɣ yɔ nɛ ŋyele nɛ tɩ-taa tɔm pee wɛɛ ndɩ ndɩ.Pɩwɛɛ se pacalɩ ñɔɔzʋʋ coordonnées waa nɛ pɩkpazɩɣ-sɩ.paa matrice nɖɩ ɖɩ-taa lɛ, ɖɩ-taa wɛ coordonnées (sɩɩ, pilinzi), sɩpaɣzɩɣna 0.nɛ pɩpɩsɩɣ matrice waa matrice, [(x1, y1), (x2, y2) ...] pɩlɩna se Ɖɩcɔna lst nɛ x lɛ, ɖɩnaɣ ɛyʊ ɛ-tɛ intɛrɩjɛrɩ x, paa n̄ɩŋgʋ ŋgʋ kɩ-taa lɛ, pɩpɩzɩɣ nɛ pɩla se pilinzi ndɩ ndɩ wɛɛ kɩ-taa.Pɩwɛ ɛzɩ matrix yɔ, ɛlɛ pɩtɛkɛ ɛzɩ matrix yɔ, Pʊtɔbʊʊ se ŋwɛna 2 dimension waa, ɛzɩ matrice waa, # >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)
# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]
# >>> get_row.call([], 1)
# []
# >>> get_row.call([[], [1], [1, 2, 3]], 3)
# [[2, 2]]
def get_row(lst, x)
","def get_row(lst, x)
  result = []

  lst.each_with_index do |row, i|
    row.each_with_index do |value, j|
      result << [i, j] if value == x
    end
  end

  result.sort_by { |coord| [coord[0], -coord[1]] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_row
    candidate = method(:get_row)
    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))
    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))
    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))
    assert_equal([], candidate.call([], 1))
    assert_equal([], candidate.call([[1]], 2))
    assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))
  end
end
"
HumanEval_88,kbp_Latn,rb,"Kɩɖaŋ: * Taapɩsɩna matʋ ndʋ tɩ-taa pama-tʋ yɔ.Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ:Yaa ɛ-tɛ tɔlɩm tɛ lɛ, ɛ-tɛ tɔlɩm tɛ lɛ, ɛ-tɛ tɔlɩm tɛ lɛ, ɛ-tɛ tɔlɩm tɛ lɛ, ɛ-tɛ tɔlɩm tɛ lɛ.Ŋkaɣ ñɔɔzʋʋ matriki ŋgʋ kɩ-taa ŋnaɣ yɔ, nɛ ŋpaɣzɩ-kʋ ɖɔm nɛ pɩkpazɩɣ-kʋ ɖoŋ, ye kɩ-taa ɛ-kajalaɣ kɩlɩm nɛ ɛ-wayɩ ñɩŋgʋ pɛkpɛndɩna yɔ, pɩfɛyɩ kɩmaŋ, Pɩtɛ matʊ ndʊ tɩtɩkɛ kɩjɛyʊʊ yɔ, pɩpɩsɩɣ matʊ ndʊ tɩ-taa lɛ, pɩtɛ lɛ, pɩpɩsɩɣ ɛyʊ weyi ɛ-tɛ matʊ ndʊ tɩtɩkɛ kɩjɛyʊʊ yɔ.# >>> sort_array.call([])
# []
# >>> sort_array.call([5])
# [5]
# >>> sort_array.call([2, 4, 3, 0, 1, 5])
# [0, 1, 2, 3, 4, 5]
# >>> sort_array.call([2, 4, 3, 0, 1, 5, 6])
# [6, 5, 4, 3, 2, 1, 0]
def sort_array(array)
","def sort_array(array)
  return array if array.empty? || array.size == 1

  if (array.first + array.last).odd?
    array.sort
  else
    array.sort.reverse
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_array
    candidate = method(:sort_array)
    assert_equal([], candidate.call([]))
    assert_equal([5], candidate.call([5]))
    assert_equal([0, 1, 2, 3, 4, 5], candidate.call([2, 4, 3, 0, 1, 5]))
    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2, 4, 3, 0, 1, 5, 6]))
    assert_equal([1, 2], candidate.call([2, 1]))
    assert_equal([0, 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))
    assert_equal([23, 21, 14, 11], candidate.call([21, 14, 23, 11]))
  end
end
"
HumanEval_89,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Pɩtɛ lɛ, ɖɩkpaɣ ɛzɩ ɛyaa naalɛ yɔ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ nɛ ɖɩkpaɣ lona naalɛ.Pɩwɛɛ se pɛlɛɣzɩ alfabbɛɛtɩ ŋgʋ nɛ pama-kʋ nɛ pamaɣna se pɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-tɛ alɩbɛɛtɩ wɛʊ yɔ.Kpaɣ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye nɛ # >>> encrypt.call(""hi"")
# ""lm""
# >>> encrypt.call(""asdfghjkl"")
# ""ewhjklnop""
# >>> encrypt.call(""gf"")
# ""kj""
# >>> encrypt.call(""et"")
# ""ix""
def encrypt(s)
","def encrypt(s)
  s.chars.map do |char|
    if char =~ /[a-z]/
      ((char.ord - 'a'.ord + 4) % 26 + 'a'.ord).chr
    elsif char =~ /[A-Z]/
      ((char.ord - 'A'.ord + 4) % 26 + 'A'.ord).chr
    else
      char
    end
  end.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_encrypt
    candidate = method(:encrypt)
    assert_equal(""lm"", candidate.call(""hi""))
    assert_equal(""ewhjklnop"", candidate.call(""asdfghjkl""))
    assert_equal(""kj"", candidate.call(""gf""))
    assert_equal(""ix"", candidate.call(""et""))
    assert_equal(""jeiajeaijeiak"", candidate.call(""faewfawefaewg""))
    assert_equal(""lippsqcjvmirh"", candidate.call(""hellomyfriend""))
    assert_equal(""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"", candidate.call(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh""))
    assert_equal(""e"", candidate.call(""a""))
  end
end
"
HumanEval_90,kbp_Latn,rb,"Ye pɩfɛyɩ mbʋ yɔ, pɩsɩɣnɩ null.Maʋ tʋmɩyɛ nɖɩ payaɣ se next_smallest (ŋgbɛzɛŋ) yɔ nɛ ɖɩpɩsɩɣ mbʋ payaɣ se 2nd smallest yɔ.Pʊtɔbʊʊ se ŋwɛna nimero waa sakɩyɛ.# >>> next_smallest.call([1, 2, 3, 4, 5])
# 2
# >>> next_smallest.call([5, 1, 4, 3, 2])
# 2
# >>> next_smallest.call([])
# nil
# >>> next_smallest.call([1, 1])
# nil
def next_smallest(lst)
","def next_smallest(lst)
  unique_sorted = lst.uniq.sort
  unique_sorted.length >= 2 ? unique_sorted[1] : nil
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_next_smallest
    candidate = method(:next_smallest)
    assert_equal(2, candidate.call([1, 2, 3, 4, 5]))
    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))
    assert_equal(nil, candidate.call([]))
    assert_equal(nil, candidate.call([1, 1]))
    assert_equal(1, candidate.call([1, 1, 1, 1, 0]))
    assert_equal(nil, candidate.call([1, 1]))
    assert_equal(-35, candidate.call([-35, 34, 12, -45]))
  end
end
"
HumanEval_91,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Tɔm hɔɔlɩŋ taa lɛ, pamaɣna-ɩ nɛ mayaɣ '.', '?' yaa '!'.Tɔm piye ""m"" ɖɩlɩna tɔm piye ""m"" taa.Pɔkɔŋ-ŋ haʋ tɔm pee sakɩyɛ nɛ ña-tʋmɩyɛ lɛ se ŋkalɩ-yɛ.# >>> is_bored.call(""Hello world"")
# 0
# >>> is_bored.call(""The sky is blue. The sun is shining. I love this weather"")
# 1
def is_bored(s)
","def is_bored(s)
  sentences = s.split(/(?<=[.?!])/)
  sentences.count { |sentence| sentence.strip.start_with?('I') }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_bored
    candidate = method(:is_bored)
    assert_equal(0, candidate.call(""Hello world""))
    assert_equal(0, candidate.call(""Is the sky blue?""))
    assert_equal(1, candidate.call(""I love It !""))
    assert_equal(0, candidate.call(""bIt""))
    assert_equal(2, candidate.call(""I feel good today. I will be productive. will kill It""))
    assert_equal(0, candidate.call(""You and I are going for a walk""))
  end
end
"
HumanEval_92,kbp_Latn,rb,"Kɩɖaŋ Pɩpɩsɩɣ false paa ɛzɩmtaa.Ɛpɩsɩɣ tɔmpiye nɖɩ ɖɩ-taa lɛ, yee tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ.Lɩzɩ tʋmɩyɛ nɖɩ ɖɩmʋɣna nimbrɩwaa naadozo yɔ.# >>> any_int.call(5, 2, 7)
# true
# >>> any_int.call(3, 2, 2)
# false
# >>> any_int.call(3, -2, 1)
# true
# >>> any_int.call(3.6, -2.2, 2)
# false
def any_int(x, y, z)
","def any_int(x, y, z)
  if [x, y, z].all? { |n| n.is_a?(Integer) }
    x == y + z || y == x + z || z == x + y
  else
    false
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_any_int
    candidate = method(:any_int)
    assert_equal(true, candidate.call(2, 3, 1))
    assert_equal(false, candidate.call(2.5, 2, 3))
    assert_equal(false, candidate.call(1.5, 5, 3.5))
    assert_equal(false, candidate.call(2, 6, 2))
    assert_equal(true, candidate.call(4, 2, 2))
    assert_equal(false, candidate.call(2.2, 2.2, 2.2))
    assert_equal(true, candidate.call(-4, 6, 2))
    assert_equal(true, candidate.call(2, 1, 1))
    assert_equal(true, candidate.call(3, 4, 7))
    assert_equal(false, candidate.call(3.0, 4, 7))
  end
end
"
HumanEval_93,kbp_Latn,rb,"Kɩɖaŋ: Maɣzɩ se masɩ ɖeke tɔm.Tɔm piye nɖɩ ɖɩlɩnɩ tɔm piye nɖɩ ɖɩ-taa?Tɔm ndʋ tɩ-taa lɛ , pama takayaɣ ŋga ka-taa pama tɔm pee naalɛ yɔ .Ɛlɛɣzɩna matʋ tɩŋa nɛ ɛtɛzɩna matʋ ndʋ tɩ-taa paayɔɔdɩ yɔ.Maʋ tʋmɩyɛ nɖɩ ɖɩmʋɣ tɔm natʋyʋ nɛ ɖɩɖʋ-tʋ takayaɣ nakɛyɛ taa yɔ.# >>> encode.call(""test"")
# ""TGST""
# >>> encode.call(""This is a message"")
# ""tHKS KS C MGSSCGG""
def encode(message)
","def encode(message)
  vowels = 'aeiou'
  swap_vowels = {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w'}
  
  encoded_message = message.chars.map do |char|
    if vowels.include?(char.downcase)
      new_char = swap_vowels[char.downcase]
      char == char.upcase ? new_char.upcase : new_char.downcase
    else
      char == char.upcase ? char.downcase : char.upcase
    end
  end

  encoded_message.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_encode
    candidate = method(:encode)
    assert_equal(""tgst"", candidate.call(""TEST""))
    assert_equal(""mWDCSKR"", candidate.call(""Mudasir""))
    assert_equal(""ygs"", candidate.call(""YES""))
    assert_equal(""tHKS KS C MGSSCGG"", candidate.call(""This is a message""))
    assert_equal(""k dQnT kNqW wHcT Tq wRkTg"", candidate.call(""I DoNt KnOw WhAt tO WrItE""))
  end
end
"
HumanEval_94,kbp_Latn,rb,"Kɩɖaŋ: Pɩwɛɛ se ɖɩñɩnɩ mayaɣ ŋga kɛwɛ ñɩm siŋŋ yɔ nɛ ɖɩpɩsɩ ka-taa mayaɣ ŋga kɛwɛ ñɩm siŋŋ yɔ.Pʊtɔbʊʊ se ŋwɛna nimero waa sakɩyɛ.# >>> skjkasdkd.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
# 10
# >>> skjkasdkd.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
# 25
# >>> skjkasdkd.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
# 13
# >>> skjkasdkd.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
# 11
# >>> skjkasdkd.call([0, 81, 12, 3, 1, 21])
# 3
# >>> skjkasdkd.call([0, 8, 1, 2, 1, 7])
# 7
def skjkasdkd(lst)
","def skjkasdkd(lst)
  require 'prime'

  # Find the largest prime number in the array
  largest_prime = lst.select { |num| Prime.prime?(num) }.max
  
  # Return 0 if no prime number is found
  return 0 if largest_prime.nil?

  # Calculate the sum of digits of the largest prime number
  largest_prime.to_s.chars.map(&:to_i).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_skjkasdkd
    candidate = method(:skjkasdkd)
    assert_equal(10, candidate.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))
    assert_equal(25, candidate.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))
    assert_equal(13, candidate.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))
    assert_equal(11, candidate.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))
    assert_equal(3, candidate.call([0, 81, 12, 3, 1, 21]))
    assert_equal(7, candidate.call([0, 8, 1, 2, 1, 7]))
    assert_equal(19, candidate.call([8191]))
    assert_equal(19, candidate.call([8191, 123456, 127, 7]))
    assert_equal(10, candidate.call([127, 97, 8192]))
  end
end
"
HumanEval_95,kbp_Latn,rb,"Kɩɖaŋ: Pɩwɛɛ se tʋmɩyɛ nɖɩ ɖɩpɩsɩ false yee hash kɩ-taa nabʋyʋ fɛyɩ yɔ.Pɩtɛkɛ mbʋ yɔ, pɩpɩsɩɣ false.Ye ɖɩha-ɩ hash yɔ, pɩpɩsɩɣ true ye kɩ-taa tɔm tɩŋa ɩkɛ lower  taa tɔmpiye yɔ.# >>> check_dict_case.call({""a"" => ""apple"", ""b"" => ""banana""})
# true
# >>> check_dict_case.call({""a"" => ""apple"", ""A"" => ""banana"", ""B"" => ""banana""})
# false
# >>> check_dict_case.call({""a"" => ""apple"", 8 => ""banana"", ""a"" => ""apple""})
# false
# >>> check_dict_case.call({""Name"" => ""John"", ""Age"" => ""36"", ""City"" => ""Houston""})
# false
# >>> check_dict_case.call({""STATE"" => ""NC"", ""ZIP"" => ""12345""})
# true
def check_dict_case(dict)
","def check_dict_case(dict)
  return false if dict.empty?

  lowercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.downcase }
  uppercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.upcase }

  lowercase_keys || uppercase_keys
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_check_dict_case
    candidate = method(:check_dict_case)
    assert_equal(true, candidate.call({""p"" => ""pineapple"", ""b"" => ""banana""}))
    assert_equal(false, candidate.call({""p"" => ""pineapple"", ""A"" => ""banana"", ""B"" => ""banana""}))
    assert_equal(false, candidate.call({""p"" => ""pineapple"", ""5"" => ""banana"", ""a"" => ""apple""}))
    assert_equal(false, candidate.call({""Name"" => ""John"", ""Age"" => ""36"", ""City"" => ""Houston""}))
    assert_equal(true, candidate.call({""STATE"" => ""NC"", ""ZIP"" => ""12345""}))
    assert_equal(true, candidate.call({""fruit"" => ""Orange"", ""taste"" => ""Sweet""}))
    assert_equal(false, candidate.call({}))
  end
end
"
HumanEval_96,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Ɛyʊ ɛ-tɛ ɛyʊtʊ ndʊ tɩ-tɛ ɛyʊtʊ ndʊ tɩkɩlɩɣ yɔ.Palakɩ tʊmɩyɛ nɖɩ ɖɩkpaɣɣ ɛyʊ kʊyʊm nɛ ɖɩpɩsɩɣ kajalaɣ n ñɩŋʊ yɔ.# >>> count_up_to.call(5)
# [2, 3]
# >>> count_up_to.call(11)
# [2, 3, 5, 7]
# >>> count_up_to.call(0)
# []
# >>> count_up_to.call(20)
# [2, 3, 5, 7, 11, 13, 17, 19]
# >>> count_up_to.call(1)
# []
# >>> count_up_to.call(18)
# [2, 3, 5, 7, 11, 13, 17]
def count_up_to(n)
","def count_up_to(n)
  return [] if n <= 2
  primes = []
  (2...n).each do |num|
    is_prime = true
    (2..Math.sqrt(num)).each do |i|
      if num % i == 0
        is_prime = false
        break
      end
    end
    primes << num if is_prime
  end
  primes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_up_to
    candidate = method(:count_up_to)
    assert_equal([2, 3], candidate.call(5))
    assert_equal([2, 3, 5], candidate.call(6))
    assert_equal([2, 3, 5], candidate.call(7))
    assert_equal([2, 3, 5, 7], candidate.call(10))
    assert_equal([], candidate.call(0))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))
    assert_equal([], candidate.call(1))
    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))
  end
end
"
HumanEval_97,kbp_Latn,rb,"Kɩɖaŋ: Pɩwɛɛ se ɖɩmaɣzɩ se tɔm ndʋ ɖɩyɔɔdaa yɔ, tɩkɛ toovenim paa ɛzɩmtaa.Kɩ-tɛ n̄ɩɣyʋʋ kɛ ɛ-tɛ n̄ɩɣyʋʋ mayaɣ.Kpaɣ kɩ-tɛ ɛyʊ nɛ ɛɖaɣnɩ pɩsʋʋ ɛ-tɛ ɛyʊ.# >>> multiply.call(148, 412)
# 16
# >>> multiply.call(19, 28)
# 72
# >>> multiply.call(2020, 1851)
# 0
# >>> multiply.call(14, -15)
# 20
def multiply(a, b)
","def multiply(a, b)
  a_unit_digit = a.abs % 10
  b_unit_digit = b.abs % 10
  a_unit_digit * b_unit_digit
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_multiply
    candidate = method(:multiply)
    assert_equal(16, candidate.call(148, 412))
    assert_equal(72, candidate.call(19, 28))
    assert_equal(0, candidate.call(2020, 1851))
    assert_equal(20, candidate.call(14, -15))
    assert_equal(42, candidate.call(76, 67))
    assert_equal(49, candidate.call(17, 27))
    assert_equal(0, candidate.call(0, 1))
    assert_equal(0, candidate.call(0, 0))
  end
end
"
HumanEval_98,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Ye ŋwɛna masɩ nzɩ sɩ-taa pama hɩla kɩsɛsɛna yɔ, kalɩ masɩ nzɩ sɩ-taa pama hɩla kɩsɛna yɔ.# >>> count_upper.call(""aBCdEf"")
# 1
# >>> count_upper.call(""abcdefg"")
# 0
# >>> count_upper.call(""dBBE"")
# 0
def count_upper(s)
","def count_upper(s)
  vowels = ['A', 'E', 'I', 'O', 'U']
  count = 0

  s.chars.each_with_index do |char, index|
    if index.even? && vowels.include?(char)
      count += 1
    end
  end

  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_upper
    candidate = method(:count_upper)
    assert_equal(1, candidate.call(""aBCdEf""))
    assert_equal(0, candidate.call(""abcdefg""))
    assert_equal(0, candidate.call(""dBBE""))
    assert_equal(0, candidate.call(""B""))
    assert_equal(1, candidate.call(""U""))
    assert_equal(0, candidate.call(""""))
    assert_equal(2, candidate.call(""EEEE""))
  end
end
"
HumanEval_99,kbp_Latn,rb,"Kɩɖaŋ Ɛlɩna ɛyʊ ɛ-tɛ ɛyʊtʊ naalɛ yɔɔ, ɛ-tɛ ɛyʊtʊ ɛ-tɛ ɛyʊtʊ ɛ-tɛ ɛyʊtʊ ɛ-tɛ ɛyʊtʊ ɛ-tɛ ɛyʊtʊ.Ɛtɛyɩɣ ɛ-tɛ ɛyʊ kɩfalʊ nɛ ɛ-tɛ ɛyʊ kɩfalʊ.Lɩzɩ tʊmɩyɛ nɖɩ ɖɩkpaɣɣ kɩjɛyɩɣ (ŋgbɛyɛ) nɛ ɖɩwɩlɩɣ mayaɣ nakɛyɛ yɔ # >>> closest_integer.call(""10"")
# 10
# >>> closest_integer.call(""15.3"")
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer(""14.5"") should
# return 15 and closest_integer(""-14.5"") should return -15.
def closest_integer(value)
","def closest_integer(value)
  number = value.to_f
  if number > 0
    (number + 0.5).floor
  else
    (number - 0.5).ceil
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_closest_integer
    candidate = method(:closest_integer)
    assert_equal(10, candidate.call(""10""))
    assert_equal(15, candidate.call(""14.5""))
    assert_equal(-16, candidate.call(""-15.5""))
    assert_equal(15, candidate.call(""15.3""))
    assert_equal(0, candidate.call(""0""))
  end
end
"
HumanEval_100,kbp_Latn,rb,"Kɩɖaŋ: i kɛna pɩyɛ ndɩ ɖɩ-tɛ wɛtʊ (i+1).Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ:- ɛtɛyɩɣ ɛtɛyɩɣ lɛ, ɛtɛyɩɣ ɖɔɖɔ. - ɛtɛyɩɣ nabʊyʊ taa yee n ɛtɛyɩɣ kɔyɔ. Pɩtɛ pɩyɛ nɖɩ ɖɩ-taa pɩcɩɩcɩɩ yɔ, ɖɩ-taa:Kajalaɣ n̄ɩɣyʋʋ taa lɛ, n̄ɩɣlɩm n̄ɩmbʋ.Ye ŋha-ɖʋ ɛyʊ kʊyʊmʊm n kɔyɔ, pɩwɛɛ se ŋñɔɔzɩ ɛ-tɩ nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa nɛ ɛ-taa.# >>> make_a_pile.call(3)
# [3, 5, 7]
def make_a_pile(n)
","def make_a_pile(n)
  result = []
  current_stones = n
  n.times do
    result << current_stones
    current_stones += 2
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_make_a_pile
    candidate = method(:make_a_pile)
    assert_equal([3, 5, 7], candidate.call(3))
    assert_equal([4, 6, 8, 10], candidate.call(4))
    assert_equal([5, 7, 9, 11, 13], candidate.call(5))
    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))
    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))
  end
end
"
HumanEval_101,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Pɩsɩ nɛ ŋna-ɩ kɩlɛlʋʋ:Ŋkaɣ wɛnʋʋ tɔm pee sakɩyɛ nɛ ŋtayɩ-yɛ nɛ hɩlaɣ yaa tɩyɛ.# >>> words_string.call(""Hi, my name is John"")
# [""Hi"", ""my"", ""name"", ""is"", ""John""]
# >>> words_string.call(""One, two, three, four, five, six"")
# [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
def words_string(s)
","def words_string(s)
  s.split(/[\s,]+/)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_words_string
    candidate = method(:words_string)
    assert_equal([""Hi"", ""my"", ""name"", ""is"", ""John""], candidate.call(""Hi, my name is John""))
    assert_equal([""One"", ""two"", ""three"", ""four"", ""five"", ""six""], candidate.call(""One, two, three, four, five, six""))
    assert_equal([""Hi"", ""my"", ""name""], candidate.call(""Hi, my name""))
    assert_equal([""One"", ""two"", ""three"", ""four"", ""five"", ""six""], candidate.call(""One,, two, three, four, five, six,""))
    assert_equal([], candidate.call(""""))
    assert_equal([""ahmed"", ""gamal""], candidate.call(""ahmed     , gamal""))
  end
end
"
HumanEval_102,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Ye pɩfɛyɩ kɔyɔ, pɩpɔzʋʋ se ɖɩpɩsɩɣ -1.Ɛjaɖɛ nɖɩ ɖɩ-taa lɛ, ɛyaa mba pɛtɛyɩɣ ɖama yɔ, pa-taa lɛ, mba kɩlɩna ɖɔʊ.Tʊmɩyɛ ɖɩnɛ ɖɩkpaɣ ɛyʊ kʊdɔŋ naalɛ x nɛ y nɛ ɖɩpɩsɩ ɛyʊ kʊdɔŋ # >>> choose_num.call(12, 15)
# 14
# >>> choose_num.call(13, 12)
# -1
def choose_num(x, y)
","def choose_num(x, y)
  return -1 if x > y
  # Start looking from the largest number
  max_even = y.even? ? y : y - 1
  # Iterate downwards to find the biggest even number
  max_even.downto(x) do |n|
    return n if n.even?
  end
  -1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_choose_num
    candidate = method(:choose_num)
    assert_equal(14, candidate.call(12, 15))
    assert_equal(-1, candidate.call(13, 12))
    assert_equal(12354, candidate.call(33, 12354))
    assert_equal(-1, candidate.call(5234, 5233))
    assert_equal(28, candidate.call(6, 29))
    assert_equal(-1, candidate.call(27, 10))
    assert_equal(-1, candidate.call(7, 7))
    assert_equal(546, candidate.call(546, 546))
  end
end
"
HumanEval_103,kbp_Latn,rb,"Kɩɖaʋ: Yee n ɛkɩlɩ m kɔyɔ, pɩpɩsɩɣ -1.Pɩtɛ lɛ, ŋtɛzɩ pɩsʋʋ nabʋlɛ ñɩmbʋ.Kɩ-tɛ lɛɣtʊ kpɛlɛkʊʊ tʊmɩyɛ (CPC)Pʊtɔbʊʊ se ŋwɛna ñʊʊ taa ɛyʊ naalɛ nɛ pʊtɔbʊʊ se ñʊʊ taa ɛyʊ naalɛ nɛ pʊtɔbʊʊ se ñʊʊ taa ɛyʊ naalɛ.# >>> rounded_avg.call(1, 5)
# ""0b11""
# >>> rounded_avg.call(7, 5)
# -1
# >>> rounded_avg.call(10, 20)
# ""0b1111""
# >>> rounded_avg.call(20, 33)
# ""0b11010""
def rounded_avg(n, m)
","def rounded_avg(n, m)
  return -1 if n > m

  sum = (n..m).reduce(:+)
  count = m - n + 1
  average = (sum.to_f / count).round
  ""0b"" + average.to_i.to_s(2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rounded_avg
    candidate = method(:rounded_avg)
    assert_equal(""0b11"", candidate.call(1, 5))
    assert_equal(""0b1010"", candidate.call(7, 13))
    assert_equal(""0b1111001010"", candidate.call(964, 977))
    assert_equal(""0b1111100100"", candidate.call(996, 997))
    assert_equal(""0b1011000010"", candidate.call(560, 851))
    assert_equal(""0b101101110"", candidate.call(185, 546))
    assert_equal(""0b110101101"", candidate.call(362, 496))
    assert_equal(""0b1001110010"", candidate.call(350, 902))
    assert_equal(""0b11010111"", candidate.call(197, 233))
    assert_equal(-1, candidate.call(7, 5))
    assert_equal(-1, candidate.call(5, 1))
    assert_equal(""0b101"", candidate.call(5, 5))
  end
end
"
HumanEval_104,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Pɩwɛɛ se patɩlɩ ɛzɩma palɩzɩ tɔm pee kɩbana yɔ.Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.Ye ŋha-ɩ kɩ-tɛ intɛrɩjɛrɩ waa kɩbam x yɔ, pɩsɩna nɛ ɛlɩzɩ kɩ-tɛ intɛrɩjɛrɩ waa tɩŋa.# >>> unique_digits.call([15, 33, 1422, 1])
# [1, 15, 33]
# >>> unique_digits.call([152, 323, 1422, 10])
# []
def unique_digits(x)
","def unique_digits(x)
  x.select { |num| num.to_s.chars.none? { |digit| digit.to_i.even? } }.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_unique_digits
    candidate = method(:unique_digits)
    assert_equal([1, 15, 33], candidate.call([15, 33, 1422, 1]))
    assert_equal([], candidate.call([152, 323, 1422, 10]))
    assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))
    assert_equal([31, 135], candidate.call([135, 103, 31]))
  end
end
"
HumanEval_105,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: ""Kʋyʋm"", ""Ɛyaa naalɛ"", ""Naadozo"", ""Naanza"", ""Lima"", ""Lamamɩŋ"", ""Lazɩm"", ""Lamɩŋ lutozo"", ""Lamɩŋ lutozo"", ""Lamɩŋ nakʋ"".Pɩtɛ lɛ, ɖɩlɛɣzɩna paa mayaɣ ŋga nɛ ka-hɩɖɛ.Ye ŋha-ɖʋ intɛrɩ waa sakɩyɛ yɔ, kpaɣ intɛrɩ waa mba pɛwɛ 1 nɛ 9 pɛ-hɛkʊ taa yɔ, # >>> by_length.call([2, 1, 1, 4, 5, 8, 2, 3])
# [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
# If the array is empty, return an empty array:
# >>> by_length.call([])
# []
# If the array has any strange number ignore it:
# >>> by_length.call([1, -1, 55])
# [""One""]
def by_length(arr)
","def by_length(arr)
  number_names = {
    1 => ""One"",
    2 => ""Two"",
    3 => ""Three"",
    4 => ""Four"",
    5 => ""Five"",
    6 => ""Six"",
    7 => ""Seven"",
    8 => ""Eight"",
    9 => ""Nine""
  }

  filtered_sorted_reversed = arr.select { |x| x.between?(1, 9) }.sort.reverse
  filtered_sorted_reversed.map { |num| number_names[num] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_by_length
    candidate = method(:by_length)
    assert_equal([""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], candidate.call([2, 1, 1, 4, 5, 8, 2, 3]))
    assert_equal([], candidate.call([]))
    assert_equal([""One""], candidate.call([1, -1, 55]))
    assert_equal([""Three"", ""Two"", ""One""], candidate.call([1, -1, 3, 2]))
    assert_equal([""Nine"", ""Eight"", ""Four""], candidate.call([9, 4, 8]))
  end
end
"
HumanEval_106,kbp_Latn,rb,"Kɩɖaʋ: Kɩ-tɛ tɔmpiye i kɛna 1 nɛ i pɛ-tɛ tɔmpiye (1 * 2 * ... * i).Maɣzɩnɩ 1 yɔɔ.yaa lɛɛna taa lɛ, pɩlɩɣna 1 nɛ piwolo i pɛ-hɛkʊ taa.Ɛpɩsɩɣ ɛ-tɛ matriki sɔsɔʊ n, nɛ pɩsa nɛ ɛ-tɛ ɛyʊ weyi ɛwɛ ɛ-tɛtʊ taa yɔ, ɛ-tɛ ɛyʊ lɛlʊ kɔyɔ, ɛ-tɛ ɛyʊ lɛlʊ kɔyɔ, ɛ-tɛ ɛyʊ lɛlʊ kɔyɔ.Ɖɩkpaɣ f kɛ ɛ-tɛ lɛɣtʊ tʊmɩyɛ, # >>> f.call(5)
# [1, 2, 6, 24, 15]
def f(n)
","def f(n)
  (1..n).map do |i|
    if i.even?
      (1..i).inject(:*) || 1
    else
      (1..i).inject(:+)
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_f
    candidate = method(:f)
    assert_equal([1, 2, 6, 24, 15], candidate.call(5))
    assert_equal([1, 2, 6, 24, 15, 720, 28], candidate.call(7))
    assert_equal([1], candidate.call(1))
    assert_equal([1, 2, 6], candidate.call(3))
  end
end
"
HumanEval_107,kbp_Latn,rb,"Kɩɖaʋ 1:Palindromes waa mba pɛwɛ hɔɔlɩŋ weyi ɩ-taa yɔ, mba payaɣ se ((1, n), nɛ pɩkpɛndɩnɩ.Ye ŋha-ɩ nimero intérieur positif n, pɩsɩna nɛ ŋha-ɩ nimero waa mba pɛtɛyɩɣ nɛ mba pɛtɛyɩɣ yɔ.# >>> even_odd_palindrome.call(3)
# [1, 2]
# Explanation:
# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
# Example 2:
# >>> even_odd_palindrome.call(12)
# [4, 6]
# Explanation:
# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
# Note:
# 1. 1 <= n <= 10^3
# 2. returned array has the number of even and odd integer palindromes respectively.
def even_odd_palindrome(n)
","def even_odd_palindrome(n)
  even_count = 0
  odd_count = 0

  (1..n).each do |num|
    if num.to_s == num.to_s.reverse
      if num.even?
        even_count += 1
      else
        odd_count += 1
      end
    end
  end

  [even_count, odd_count]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_even_odd_palindrome
    candidate = method(:even_odd_palindrome)
    assert_equal([8, 13], candidate.call(123))
    assert_equal([4, 6], candidate.call(12))
    assert_equal([1, 2], candidate.call(3))
    assert_equal([6, 8], candidate.call(63))
    assert_equal([5, 6], candidate.call(25))
    assert_equal([4, 6], candidate.call(19))
    assert_equal([4, 5], candidate.call(9))
    assert_equal([0, 1], candidate.call(1))
  end
end
"
HumanEval_108,kbp_Latn,rb,"Ɖɩkpaɣ ɛzɩ -123 lɛ, ɛ-tɛ mayaɣ kɔyɔ -1, 2 nɛ 3.Yee nimero nakʋyʋ ɛwɛ kɩjɛyʊʊ kɔyɔ, ɛ-tɛ kajalaɣ nimero kɩjɛyʊʊ kɔyɔ: Takayɩhatʋ ndʋ tɩtamsɩna \\ 0 \\ yɔMa tʋmɩyɛ nɖɩ payaɣ se count_nums yɔ nɛ ɖɩkpaɣ hɔɔlɩŋ weyi ɩ-taa pamaɣ hɔɔlɩŋ ɛnɩ yɔ nɛ ɖɩpɩsɩɣ # >>> count_nums.call([])
# 0
# >>> count_nums.call([-1, 11, -11])
# 1
# >>> count_nums.call([1, 1, 2])
# 3
def count_nums(arr)
","def count_nums(arr)
  arr.count do |num|
    num.to_s.chars.map(&:to_i).sum > 0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_nums
    candidate = method(:count_nums)
    assert_equal(0, candidate.call([]))
    assert_equal(0, candidate.call([-1, -2, 0]))
    assert_equal(6, candidate.call([1, 1, 2, -2, 3, 4, 5]))
    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))
    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))
    assert_equal(5, candidate.call([12, 23, 34, -45, -56, 0]))
    assert_equal(1, candidate.call([0, 1]))
    assert_equal(1, candidate.call([1]))
  end
end
"
HumanEval_109,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Pɩkɛna kɩjɛyʊʊ se ɛyʊ ɛ-tɛ wondu ndʊ tɩfɛyɩ ndɩ nɛ lɛɛzɩtʊ ndʊ tɩ-taa.Yee matʊ ndʊ tɩ-taa ɛyʊ fɛyɩ kɔyɔ, pɩpɩsɩɣ tɔm kɩmamatʊ.Pɩtɛ lɛ, pɩpɩsɩɣ true yaa false.Yee pɩsaŋ kɔyɔ, ŋpɩzɩɣ ŋla tʊmɩyɛ nɖɩ ɖɩ-yɔɔ nɛ ŋhiɣ matriki ŋgʊ kɩ-taa paɖʊ-kʊ yɔ.Pɩtɛ lɛ, ŋnaɣ ɖenɖe pacalɩ kpaɣʋ yɔ, pʋ-tɔbʋʋ se 0 ñɩŋgʋ.Pɩtɛ lɛ, ɖɩtɛzɩɣna-ɖɩ nɛ ɖɩ-tɛ lɛɣtʋ kɩfatʋ.Ɖɩcɔna kɔyɔ, ɖɩnaɣ se ɛyʊ ɛpɩzɩ nɛ ɛtɛzɩ ɛ-tɩ yɔɔ wɛʊ nɛ ɛ-ɛjaɖɛ taa.Ŋpɩzɩɣ ŋla tʋmɩyɛ nɖɩ tam sakɩyɛ ɛzɩ ŋsɔɔlʋʋ yɔ.Kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛ kɩ-tɛpapɩzɩɣ pakpaɣ matrice nɛ palɩzɩ-ɩ nɛ pɩtaakɩlɩ ɖɔʋ nɛ pɩɖɛɛna ɛsɩndaa pɩtɩŋna ɛzɩma palaba yɔ.Ŋkaɣ naʋ se paa pɔcɔna nɛ pana se ŋwɛ toovenim na yɔ, ŋpɩzɩɣ nɛ ŋlɩzɩ mbʋ pɩ-yɔɔ ŋtisiɣ yɔ.Ɖɩwɛna 'arr' matʊ N intɛrɩjɛrɩ waa arr[1], arr[2], ..., arr[N].# >>> move_one_ball.call([3, 4, 5, 1, 2])
# true
# Explanation: By performin 2 right shift operations, non-decreasing order can
# be achieved for the given array.
# >>> move_one_ball.call([3, 5, 4, 1, 2])
# false
# Explanation:It is not possible to get non-decreasing order for the given
# array by performing any number of right shift operations.
def move_one_ball(arr)
","def move_one_ball(arr)
  return true if arr.empty?

  n = arr.size
  count_rotation_point = 0
  rotation_index = -1

  (0...n).each do |i|
    next_index = (i + 1) % n
    if arr[i] > arr[next_index]
      count_rotation_point += 1
      rotation_index = next_index
    end
  end

  count_rotation_point <= 1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_move_one_ball
    candidate = method(:move_one_ball)
    assert_equal(true, candidate.call([3, 4, 5, 1, 2]))
    assert_equal(true, candidate.call([3, 5, 10, 1, 2]))
    assert_equal(false, candidate.call([4, 3, 1, 2]))
    assert_equal(false, candidate.call([3, 5, 4, 1, 2]))
    assert_equal(true, candidate.call([]))
  end
end
"
HumanEval_110,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Ye pɩtɛkɛ mbʋ yɔ, ŋpɩsɩɣ ""Aayɩ"".Pɩwɛɛ se lst1 tɛ wondu tɩŋa ɩwɛɛ kɩmaŋ, pɩpɩsɩ ""ƐƐƐ"".Yee pɩsaŋ se pɛlɛɣzɩ wondu lst1 nɛ lst2 pɛ-hɛkʋ taa nɛ pɩsaŋ nɛ pala Pɩfɛyɩ se pakpaɣ kɩmaŋ weyi ɛ-tɛ lst1 nɛ lst2 pɛ-hɛkʋ taa yɔ.Pɩwɛɛ se ɖɩkpaɣ lst1 nɛ ɖɩpɩsɩ-ɖɩ lɛɣtʋ ndɩ ndɩ.Nɛ kɩwɩlɩɣ se papɩzɩɣ nɛ pɛlɛɣzɩ wondu natʋyʋ yaa paapɩzɩɣ .Tɔmpiye ɖɩnɛ ɖɩ-taa, ɖɩ-taa lɛ, ŋkaɣ labʊ tʊmɩyɛ nɖɩ ɖɩkpaɣɣ nabʊlɛ yɔ, # >>> exchange.call([1, 2, 3, 4], [1, 2, 3, 4])
# ""YES""
# >>> exchange.call([1, 2, 3, 4], [1, 5, 3, 4])
# ""NO""
# It is assumed that the input arrays will be non-empty.
def exchange(lst1, lst2)
","def exchange(lst1, lst2)
  # Check if lst1 already consists solely of even numbers
  return ""YES"" if lst1.all?(&:even?)

  # Check if there are at least as many even numbers in lst2
  # as there are odd numbers in lst1
  odd_count_lst1 = lst1.count(&:odd?)
  even_count_lst2 = lst2.count(&:even?)

  odd_count_lst1 <= even_count_lst2 ? ""YES"" : ""NO""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_exchange
    candidate = method(:exchange)
    assert_equal(""YES"", candidate.call([1, 2, 3, 4], [1, 2, 3, 4]))
    assert_equal(""NO"", candidate.call([1, 2, 3, 4], [1, 5, 3, 4]))
    assert_equal(""YES"", candidate.call([1, 2, 3, 4], [2, 1, 4, 3]))
    assert_equal(""YES"", candidate.call([5, 7, 3], [2, 6, 4]))
    assert_equal(""NO"", candidate.call([5, 7, 3], [2, 6, 3]))
    assert_equal(""NO"", candidate.call([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))
    assert_equal(""YES"", candidate.call([100, 200], [200, 200]))
  end
end
"
HumanEval_111,kbp_Latn,rb,"Kɩɖaʋ: Ye tɔm pee naayɛ ɛkpɛndɩ yɔ, pɩpɔzʋʋ se papɩsɩna-yɛ tɩŋa.Takayaɣ ŋga ka-taa pama tɔm pee sakɩyɛ nɛ pama-yɛ ɖɔɖɔ sakɩyɛ yɔ.Ye ŋwɛna tɔmpiye nɖɩ ɖɩwɩlɩɣ mayaɣ cikpelaɣ ŋga kɛwɛna mayaɣ cikpelaɣ yɔ, pɩsɩna nɛ ŋlɩzɩ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye.# >>> histogram.call(""a b c"")
# {""a"" => 1, ""b"" => 1, ""c"" => 1}
# >>> histogram.call(""a b b a"")
# {""a"" => 2, ""b"" => 2}
# >>> histogram.call(""a b c a b"")
# {""a"" => 2, ""b"" => 2}
# >>> histogram.call(""b b b b a"")
# {""b"" => 4}
# >>> histogram.call("""")
# {}
def histogram(test)
","def histogram(test)
  return {} if test.empty?

  count = Hash.new(0)

  test.split.each do |char|
    count[char] += 1
  end

  max_count = count.values.max
  count.select { |_, value| value == max_count }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_histogram
    candidate = method(:histogram)
    assert_equal({""a"" => 2, ""b"" => 2}, candidate.call(""a b b a""))
    assert_equal({""a"" => 2, ""b"" => 2}, candidate.call(""a b c a b""))
    assert_equal({""a"" => 1, ""b"" => 1, ""c"" => 1, ""d"" => 1, ""g"" => 1}, candidate.call(""a b c d g""))
    assert_equal({""r"" => 1, ""t"" => 1, ""g"" => 1}, candidate.call(""r t g""))
    assert_equal({""b"" => 4}, candidate.call(""b b b b a""))
    assert_equal({""r"" => 1, ""t"" => 1, ""g"" => 1}, candidate.call(""r t g""))
    assert_equal({}, candidate.call(""""))
    assert_equal({""a"" => 1}, candidate.call(""a""))
  end
end
"
HumanEval_112,kbp_Latn,rb,"Kɩɖaʋ Pɩwɛɛ se ŋyele nɛ pɩpɩsɩ matriki ŋgʋ kɩ-taa wɛ pɩlɩʋ tɔm nɛ true/false yɔ.Ɛyʋ pɩzɩɣ nɛ ɛyɔɔdɩ se ɛ-tɔm kɛ palindrome, ye ɛ-tɔm ɛkalɩɣ ɛzɩ ɛkalɩɣ ɛ-tɔm nɛ pɩɖɛɛ yɔ.Pɩtɛ lɛ, ŋcɔna se pɩlɩna mbʊ yɔ palindrome.Pʊtɔbʊʊ se ɖɩkpaɣ tɔmpiye s nɛ c nɛ ɖɩɖɩzɩ tɔmpiye s nɛ ɖɩɖɩzɩ tɔmpiye c.Tʋmɩyɛ # >>> reverse_delete.call(""abcde"", ""ae"")
# [""bcd"", false]
# >>> reverse_delete.call(""abcdef"", ""b"")
# [""acdef"", false]
# >>> reverse_delete.call(""abcdedcba"", ""ab"")
# [""cdedc"", true]
def reverse_delete(s, c)
","def reverse_delete(s, c)
  # Remove all characters in c from s
  filtered_string = s.delete(c)
  
  # Check if the filtered string is a palindrome
  is_palindrome = filtered_string == filtered_string.reverse
  
  # Return the result array
  [filtered_string, is_palindrome]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_reverse_delete
    candidate = method(:reverse_delete)
    assert_equal([""bcd"", false], candidate.call(""abcde"", ""ae""))
    assert_equal([""acdef"", false], candidate.call(""abcdef"", ""b""))
    assert_equal([""cdedc"", true], candidate.call(""abcdedcba"", ""ab""))
    assert_equal([""dik"", false], candidate.call(""dwik"", ""w""))
    assert_equal(["""", true], candidate.call(""a"", ""a""))
    assert_equal([""abcdedcba"", true], candidate.call(""abcdedcba"", """"))
    assert_equal([""abcdedcba"", true], candidate.call(""abcdedcba"", ""v""))
    assert_equal([""abba"", true], candidate.call(""vabba"", ""v""))
    assert_equal(["""", true], candidate.call(""mamma"", ""mia""))
  end
end
"
HumanEval_113,kbp_Latn,rb,"Ɛ-tɛ matʊ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ matʊ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ matʊ tɔm ndʊ tɩ-taa lɛ, ɛ-tɛ matʊ tɔm ndʊ tɩ-taa lɛ.Pɩwɛɛ se pɛlɛɣzɩ i waa tɩŋa nɛ Paa wonuu ŋgʋ kɩ-taa lɛ, pɩwɛɛ se kɩwɛɛ ɛzɩ kɩ-tɛ wondu ndɩ ndɩ ndɩ ndʋ tɩwɛ kɩ-taa yɔ.Ye ŋwɛna matrice taa tɔmɩŋ, paa weyi lɛ ɛ-taa kɔyɔ nimero waa, pɩsɩna matrice.# >>> odd_count.call([""1234567""])
# [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
# >>> odd_count.call([""3"", ""11111111""])
# [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
def odd_count(lst)
","def odd_count(lst)
  lst.map do |num_str|
    count = num_str.count('13579')
    ""the number of odd elements #{count}n the str#{count}ng #{count} of the #{count}nput.""
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_odd_count
    candidate = method(:odd_count)
    assert_equal([""the number of odd elements 4n the str4ng 4 of the 4nput.""], candidate.call([""1234567""]))
    assert_equal([""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], candidate.call([""3"", ""11111111""]))
    assert_equal([""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""], candidate.call([""271"", ""137"", ""314""]))
  end
end
"
HumanEval_114,kbp_Latn,rb,"Kɩɖaʋ Takayɩsɩ nzɩ sɩ-taa tɔm pee wɛ ndɩ ndɩ yɔYe ŋha-ɖʋ intɛrɩjɛrɩ waa nɩŋgbanzɩ yɔ, ɖɩnaɣ pʊtʊ weyi ɛfɛyɩ kɩ-taa yɔ ɛ-tɛ pʊtʊnaa kɩkpɛdʊʊ # >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])
# 1
# >>> minSubArraySum.call([-1, -2, -3])
# -6
def minSubArraySum(nums)
","def minSubArraySum(nums)
  min_sum = nums[0]
  current_sum = 0
  nums.each do |num|
    if current_sum > 0
      current_sum = num
    else
      current_sum += num
    end
    min_sum = [min_sum, current_sum].min
  end
  min_sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_minSubArraySum
    candidate = method(:minSubArraySum)
    assert_equal(1, candidate.call([2, 3, 4, 1, 2, 4]))
    assert_equal(-6, candidate.call([-1, -2, -3]))
    assert_equal(-14, candidate.call([-1, -2, -3, 2, -10]))
    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))
    assert_equal(0, candidate.call([0, 10, 20, 1000000]))
    assert_equal(-6, candidate.call([-1, -2, -3, 10, -5]))
    assert_equal(-6, candidate.call([100, -1, -2, -3, 10, -5]))
    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))
    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))
    assert_equal(-10, candidate.call([-10]))
    assert_equal(7, candidate.call([7]))
    assert_equal(-1, candidate.call([1, -1]))
  end
end
"
HumanEval_115,kbp_Latn,rb,"Kɩɖaʋ 1:Wɩlɩ tam ɛzɩma ŋpɩzɩɣ nɛ ŋlabɩnɩ-yɛ tʋmɩyɛ yɔ.Ña-tʋmɩyɛ lɛ se ŋlabɩnɩ tʋmɩyɛ pɔŋ nɛ ŋhɛzɩ pɔŋ taa.Nɛ pɔpɔŋ tɩŋa taa lɛ, lɩm ɖɔŋ kʋɖʋm.Paa lɔkɔ ŋgʋ lɛ, kɩ-taa nɛ kaɖaɣ ŋga papɩzɩɣ nɛ palɩzɩ lɩm kɩ-taa yɔ.Nɛ paa 1 ŋgʊ lɛ kɩkɛ lɩm pʊtʊ kʋɖʋm.Paha-ŋ lɔkɔnaa mba pa-taa paa weyi lɛ ɛwɛ ɛzɩ ɛ-tɩ yɔ.# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)
# 6
# Example 2:
# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)
# 5
# Example 3:
# >>> max_fill.call([[0, 0, 0], [0, 0, 0]], 5)
# 0
# Constraints:
# * all wells have the same length
# * 1 <= grid.length <= 10^2
# * 1 <= grid[:,1].length <= 10^2
# * grid[i][j] -> 0 | 1
# * 1 <= capacity <= 10
def max_fill(grid, capacity)
","def max_fill(grid, capacity)
  total_water_units = grid.flatten.sum
  (total_water_units.to_f / capacity).ceil
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_max_fill
    candidate = method(:max_fill)
    assert_equal(6, candidate.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))
    assert_equal(5, candidate.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))
    assert_equal(0, candidate.call([[0, 0, 0], [0, 0, 0]], 5))
    assert_equal(4, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 2))
    assert_equal(2, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 9))
  end
end
"
HumanEval_116,kbp_Latn,rb,"Pɩwɛɛ se pala-ɖɩ nɛ ɖɩwɛɛ ɛzɩ ɖɩyɔɔdʋʋ yɔ:Ye ɛyʊ ɛfɛyɩna ɛ-ñʊʊ taa kɔyɔ, ɛ-tɛ ɛyʊtʊ wɛʊ lɛ, ɛ-tɛ ɛyʊtʊ wɛʊ lɛ, ɛ-tɛ ɛyʊtʊ wɛʊ lɛ.Pɩtɛ lɛ, ɛyʊ ɛ-tɛ ɛyʊtʊmɩyɛ taa lɛ, ɛ-tɛ ɛyʊtʊmɩyɛ taa lɛ, ɛ-tɛ ɛyʊtʊmɩyɛ taa lɛ, ɛ-tɛ ɛyʊtʊmɩyɛ taa.Pɩtɛ kataɣ kanɛ ka-taa, pɩwɛɛ se ŋñɔɔzɩ hɔɔlɩŋ weyi ɩ-taa lɛ, ŋnaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ŋnaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ŋnaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ŋnaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ŋnaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ŋnaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ŋnaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ŋnaɣ hɔɔlɩŋ weyi ɩ-taa lɛ, ŋnaɣ hɔɔlɩŋ weyi ɩ-taa lɛ.# >>> sort_array.call([1, 5, 2, 3, 4])
# [1, 2, 3, 4, 5]
# >>> sort_array.call([-2, -3, -4, -5, -6])
# [-6, -5, -4, -3, -2]
# >>> sort_array.call([1, 0, 2, 3, 4])
# [0, 1, 2, 3, 4]
def sort_array(arr)
","def sort_array(arr)
  arr.sort_by { |n| [n.to_s(2).count('1'), n] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_array
    candidate = method(:sort_array)
    assert_equal([1, 2, 4, 3, 5], candidate.call([1, 5, 2, 3, 4]))
    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3, -4, -5, -6]))
    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))
    assert_equal([], candidate.call([]))
    assert_equal([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))
    assert_equal([32, 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))
    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))
    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))
  end
end
"
HumanEval_117,kbp_Latn,rb,"Kɩɖaŋ: Pɩsɩ nɛ ŋna-ɩ tɔm kɩcɛyɩtʋ: Ŋpɩzɩɣ nɛ ŋmaɣzɩ se tɔm ndʋ ŋtiyaa yɔ, tɩ-taa lɛ, masɩ nɛ tɔm hɔɔlɩŋ ɖeke wɛna.Yee ɛ-tɛ matʊ ɛfɛyɩ kɔyɔ, pɩpɔzʋʋ se ɛ-tɛ matʊ ɛtasɩ wɛʋ.n tɔmpiye, nɛ tɔm pee ana awɛɛ nɛ awɛɣ tɔmpiye s taa. tʊmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔm pee kpeekpe kpou taa nɛ pɩ-taa wɛ tɔm pee Ye ŋha-ɖʋ tɔmpiye s nɛ natʊyʊ n kɔyɔ, paɖʊ-ŋ tʋmɩyɛ se ŋlabɩnɩ tʊmɩyɛ # >>> select_words.call(""Mary had a little lamb"", 4)
# [""little""]
# >>> select_words.call(""Mary had a little lamb"", 3)
# [""Mary"", ""lamb""]
# >>> select_words.call(""simple white space"", 2)
# []
# >>> select_words.call(""Hello world"", 4)
# [""world""]
# >>> select_words.call(""Uncle sam"", 3)
# [""Uncle""]
def select_words(s, n)
","def select_words(s, n)
  vowels = ""aeiouAEIOU""
  words = s.split
  words.select do |word|
    consonant_count = word.chars.count { |char| !vowels.include?(char) }
    consonant_count == n
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_select_words
    candidate = method(:select_words)
    assert_equal([""little""], candidate.call(""Mary had a little lamb"", 4))
    assert_equal([""Mary"", ""lamb""], candidate.call(""Mary had a little lamb"", 3))
    assert_equal([], candidate.call(""simple white space"", 2))
    assert_equal([""world""], candidate.call(""Hello world"", 4))
    assert_equal([""Uncle""], candidate.call(""Uncle sam"", 3))
    assert_equal([], candidate.call("""", 4))
    assert_equal([""b"", ""c"", ""d"", ""f""], candidate.call(""a b c d e f"", 1))
  end
end
"
HumanEval_118,kbp_Latn,rb,"Kɩɖaʋ: Ŋpɩzɩɣ nɛ ŋmaɣzɩ se tɔmpiye nɖɩ ɖɩ-taa ŋnaɣ-ɩ yɔ, ɖɩ-taa wɛ aŋglɛɛ kʋnʋŋ taa masɩ ɖeke.Pɩwɛɛ se pamaɣna nɛ pana se tɔmpiye nɖɩ ɖɩ-taa pama tɔmpiye nɖɩ ɖɩ-taa pama tɔmpiye nɖɩ ɖɩ-taa pama tɔmpiye nɖɩ yɔ.Ye ŋtɩtasɩ mayaɣ nakɛyɛ yɔ, yele nɛ ɖɩpɩsɩ mayaɣ ŋga ka-taa ŋtɩyɔɔdɩ natʋyʋ yɔ.Tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ.Payaɣ-mɩ se tɔm piye nɛ ɩñɩnɩ tɔm piye nɖɩ ɖɩñɔtɩnɩ-mɩ nɛ pɩkɩlɩ yɔ.# >>> get_closest_vowel.call(""yogurt"")
# ""u""
# >>> get_closest_vowel.call(""FULL"")
# ""U""
# >>> get_closest_vowel.call(""quick"")
# """"
# >>> get_closest_vowel.call(""ab"")
# """"
def get_closest_vowel(word)
","def get_closest_vowel(word)
  vowels = ""aeiouAEIOU""
  (1...word.length - 1).reverse_each do |i|
    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])
      return word[i]
    end
  end
  return """"
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_closest_vowel
    candidate = method(:get_closest_vowel)
    assert_equal(""u"", candidate.call(""yogurt""))
    assert_equal(""u"", candidate.call(""full""))
    assert_equal("""", candidate.call(""easy""))
    assert_equal("""", candidate.call(""eAsy""))
    assert_equal("""", candidate.call(""ali""))
    assert_equal(""a"", candidate.call(""bad""))
    assert_equal(""o"", candidate.call(""most""))
    assert_equal("""", candidate.call(""ab""))
    assert_equal("""", candidate.call(""ba""))
    assert_equal("""", candidate.call(""quick""))
    assert_equal(""i"", candidate.call(""anime""))
    assert_equal("""", candidate.call(""Asia""))
    assert_equal(""o"", candidate.call(""Above""))
  end
end
"
HumanEval_119,kbp_Latn,rb,"Kɩɖaŋ: Ye pɩsaŋ se ɖɩlɩzɩ tɔmpiye nɖɩ ɖɩ-taa tɔm kɩlɩ ɖeu yɔ, ɖɩpɩsɩɣ tɔm piye ""ɛɛɛ"" nɛ ye pɩsaŋ se ɖɩlɩzɩ tɔm kɩlɩ ɖeu yɔ, ɖɩpɩsɩɣ tɔm piye ""ɛɛɛ"".^ "" ()) "" pɩtɩkɛ mbʋ.Ɖɩkpaɣ ɛzɩ: tɔmpiye '(())))' wɛ ɖeu, ɛlɛ tɔmpiye Pɩkɛna tɔmpiye S nɛ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa lɛ, yee pɩ-taa tɔmpiye S  ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye S  ɖɩ-taa lɛ, tɔmpiye S  ɖɩ-taa lɛ, tɔmpiye S  ɖɩ-taa lɛ.Pɩwɛɛ se ɖɩtɩlɩ se paa ɖɩtɩla mbʋ yɔ, pɩkaɣ yebu nɛ ɖɩpɩzɩ nɛ ɖɩlɩzɩ tɔm pee kɩbana.Ña-tʋmɩyɛ lɛ se ŋtazɩ nɛ ŋna se ŋpɩzɩɣ nɛ ŋkpɛndɩ tɔm pee wena awɛ kɩ-taa yɔ nɛ ŋla-yɛ nɛ ɩwɛɛ nɔɔ kʋɖʋmaɣ taa yaa we.Pɩsɩ takayɩhayʋʋ ""[[Special:UserLogin_Special:UserLogin]]"" ñɩŋgʋ yɔɔ.Paha-ŋ matrice waa naalɛ, matrice waa panɛ pa-naalɛ pa-taa lɛ, ŋnaɣ se:# >>> match_parens.call([""()("", "")""])
# ""Yes""
# >>> match_parens.call(["")"", "")""])
# ""No""
def match_parens(lst)
","def match_parens(lst)
  a, b = lst

  # Define a helper method to check if a string is balanced
  def balanced?(s)
    count = 0
    s.each_char do |c|
      count += 1 if c == '('
      count -= 1 if c == ')'
      return false if count < 0
    end
    count == 0
  end

  # Check if either concatenation forms a good string
  if balanced?(a + b) || balanced?(b + a)
    ""Yes""
  else
    ""No""
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_match_parens
    candidate = method(:match_parens)
    assert_equal(""Yes"", candidate.call([""()("", "")""]))
    assert_equal(""No"", candidate.call(["")"", "")""]))
    assert_equal(""No"", candidate.call([""(()(())"", ""())())""]))
    assert_equal(""Yes"", candidate.call(["")())"", ""(()()(""]))
    assert_equal(""Yes"", candidate.call([""(())))"", ""(()())((""]))
    assert_equal(""No"", candidate.call([""()"", ""())""]))
    assert_equal(""Yes"", candidate.call([""(()("", ""()))()""]))
    assert_equal(""No"", candidate.call([""(((("", ""((())""]))
    assert_equal(""No"", candidate.call(["")(()"", ""(()(""]))
    assert_equal(""No"", candidate.call(["")("", "")(""]))
    assert_equal(""Yes"", candidate.call([""("", "")""]))
    assert_equal(""Yes"", candidate.call(["")"", ""(""]))
  end
end
"
HumanEval_120,kbp_Latn,rb,"Kɩɖaʋ 1:Kʋ-ɖaɣlɩkɩŋ k nɛ kɩ-tɛ kʊnʊŋ taa lɛ, kɩkɩlɩɣ ɖɔʊ.Ɛyʊ ɛ-tɛ ɛyʊ kʊyʊm arɩ nɛ ɛ-tɛ ɛyʊ kʊyʊm kʊyʊm kʊyʊm kʊyʊm kʊyʊm, ɛpɩsa ɛyʊ ɛ-tɛ ɛyʊ kʊyʊm # >>> maximum.call([-3, -4, 5], 3)
# [-4, -3, 5]
# Example 2:
# >>> maximum.call([4, -4, 4], 2)
# [4, 4]
# Example 3:
# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1], 1)
# [2]
# Note:
# 1. The length of the array will be in the range of [1, 1000].
# 2. The elements in the array will be in the range of [-1000, 1000].
# 3. 0 <= k <= len(arr)
def maximum(arr, k)
","def maximum(arr, k)
  arr.sort.last(k).sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_maximum
    candidate = method(:maximum)
    assert_equal([-4, -3, 5], candidate.call([-3, -4, 5], 3))
    assert_equal([4, 4], candidate.call([4, -4, 4], 2))
    assert_equal([2], candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))
    assert_equal([2, 20, 123], candidate.call([123, -123, 20, 0, 1, 2, -3], 3))
    assert_equal([0, 1, 2, 20], candidate.call([-123, 20, 0, 1, 2, -3], 4))
    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5, 15, 0, 3, -13, -8, 0], 7))
    assert_equal([3, 5], candidate.call([-1, 0, 2, 5, 3, -10], 2))
    assert_equal([5], candidate.call([1, 0, 5, -7], 1))
    assert_equal([-4, 4], candidate.call([4, -4], 2))
    assert_equal([-10, 10], candidate.call([-10, 10], 2))
    assert_equal([], candidate.call([1, 2, 3, -23, 243, -400, 0], 0))
  end
end
"
HumanEval_121,kbp_Latn,rb,"Kɩɖaŋ Ye ŋha-ɖʋ intɛrɩjɛrɩ waa mba pɛfɛyɩ kɩ-tɩ yɔɔ yɔ, pɩsɩna nɛ ɖɩna mbʋ payɩ pɩwɛ kɩ-tɩ yɔɔ yɔ, pɩ-tɛ kɩmaŋ.# >>> solution.call([5, 8, 7, 1])
# 12
# >>> solution.call([3, 3, 3, 3, 3])
# 9
# >>> solution.call([30, 13, 24, 321])
# 0
def solution(lst)
","def solution(lst)
  lst.each_with_index.reduce(0) do |sum, (val, idx)|
    (idx.even? && val.odd?) ? sum + val : sum
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solution
    candidate = method(:solution)
    assert_equal(12, candidate.call([5, 8, 7, 1]))
    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))
    assert_equal(0, candidate.call([30, 13, 24, 321]))
    assert_equal(5, candidate.call([5, 9]))
    assert_equal(0, candidate.call([2, 4, 8]))
    assert_equal(23, candidate.call([30, 13, 23, 32]))
    assert_equal(3, candidate.call([3, 13, 2, 9]))
  end
end
"
HumanEval_122,kbp_Latn,rb,"Kɩɖaʋ: Kɩ-tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋ kpɛlɛkʋʋ tɛ lɛɣtʋ kɩfatʋPɩtɛ lɛ, ɖɩkpaɣ ɛyʊ weyi ɛfɛyɩna ɛ-tɩ yɔɔ yɔ nɛ ɖɩkpaɣ ɛ-tɛ ɛyʊ kʊyʊm yɔ nɛ ɖɩpɩsɩ ɛ-tɛ ɛyʊ kʊyʊm yɔ.# >>> add_elements.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
# 24
# Constraints:
# 1. 1 <= len(arr) <= 100
# 2. 1 <= k <= len(arr)
def add_elements(arr, k)
","def add_elements(arr, k)
  arr.first(k).select { |num| num.abs.to_s.length <= 2 }.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add_elements
    candidate = method(:add_elements)
    assert_equal(-4, candidate.call([1, -2, -3, 41, 57, 76, 87, 88, 99], 3))
    assert_equal(0, candidate.call([111, 121, 3, 4000, 5, 6], 2))
    assert_equal(125, candidate.call([11, 21, 3, 90, 5, 6, 7, 8, 9], 4))
    assert_equal(24, candidate.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))
    assert_equal(1, candidate.call([1], 1))
  end
end
"
HumanEval_123,kbp_Latn,rb,"get_odd_collatz(5) pɩsɩna [1, 5] # Kollatz tɛtʊ taa lɛ 5 kɛ [5, 16, 8, 4, 2, 1], mbʊ pʊyɔɔ yɔ, ɛyʊ ɛ-ñʊʊ mayaɣ kɔyɔ 1 nɛ 5. Kɩɖaʋ nakʋyʋ yɔ: 2. ɛpɩsɩnɩ ɛ-tɛ matriki nɛ ɛñɔɔzɩ-ɩ nɛ ɛkpa ɖoŋ.1. Collatz(1) kɛna [1].Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ:Tɔmpiye nɖɩ ɖɩ-taa lɛ, paa n ɛ-tɛ wazaɣ ŋga lɛ, tɔmpiye nɖɩ ɖɩ-tɛ wɛtʊ kaɣ talʋʋ 1.Yee tɔmpiye nɖɩ ɖɩ-taa ɖɩwɛɛ yɔ ɖɩkɛ tɔmpiye nɖɩ ɖɩ-taa ɖɩwɛɛ yɔ, tɔmpiye nɖɩ ɖɩ-wayɩ yɔ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3 nɛ ɖɩ-ñʊʊ mayaɣ kɔyɔ 3Ɖooo lɛ, yee tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye.Pɩtɛ lɛ, paa tɔmpiye nɖɩ lɛ, ɖɩlɩɣ  cɔlɔ.Collatz tɛ maɣzɩm kɛ maɣzɩm pɩlɩna matʋ taa nɛ pɩlɩna tɔmpiye nɖɩ ɖɩ-taa pama-ɖɩ yɔ.Ye ŋha-ɩ nimero waa kɩmaŋ n yɔ, pɩpɩsɩɣ ɛ-tɛ matrice nɖɩ ɖɩ-taa nimero waa mba pɛfɛyɩ kɩmaŋ yɔ, pɛwɛɛ yɔ.# >>> get_odd_collatz.call(5)
# [1, 5]
def get_odd_collatz(n)
","def get_odd_collatz(n)
  collatz_sequence = []
  while n != 1
    collatz_sequence << n if n.odd?
    if n.even?
      n = n / 2
    else
      n = 3 * n + 1
    end
  end
  collatz_sequence << 1 if n == 1

  collatz_sequence.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_odd_collatz
    candidate = method(:get_odd_collatz)
    assert_equal([1, 5, 7, 11, 13, 17], candidate.call(14))
    assert_equal([1, 5], candidate.call(5))
    assert_equal([1, 3, 5], candidate.call(12))
    assert_equal([1], candidate.call(1))
  end
end
"
HumanEval_124,kbp_Latn,rb,"4. Pɩwɛɛ se pama kɩyakʋ ŋgʋ nɛ kɩwɛɛ ɛzɩ: f-y-y-y-y.Pɩfɛyɩ se fenasɩ nzɩ sɩtɛŋ fenaɣ kʋɖʋmaɣ yaa sɩtɛzɩ fenasɩ hiu nɛ naalɛ.Pɩtasɩ lɛ, kɩyakɩŋ weyi ɩwɛ fenaɣ 1, 3, 5, 7, 8, 10, 12 taa yɔ, ɩ-taa lɛ, kɩyakɩŋ weyi ɩ-taa kɩyakɩŋ talɩɣ yɔ, ɩfɛyɩ 1 yaa ɩkɩlɩ 31 nɛ fenaɣ 4, 6, 9, 11 taa lɛ, ɩfɛyɩ 1 yaa ɩkɩlɩ 30 nɛ fenaɣ 2 taa lɛ, ɩfɛyɩ 1 yaa ɩkɩlɩ 29.1. Pɩtɩkɛ kɩyakʋ ŋgʋ kɩ-taa palɩzɩ-kʋ yɔ, kɩ-taa tɔm.Kɩyakʋ ŋgʋ kɩ-taa lɛ, paa paɣtʋ ndʋ tɩ-tɩŋa payɩ tɩwɛɛ yɔ, tɩ-taa natʋyʋ fɛyɩ: Pɩsɩɣnɩ-ŋ nɛ ŋtɩlɩ mbʋ pɩ-yɔɔ ŋpɩzɩɣ nɛ ŋtɩŋnɩ nɛ ŋla ɖʋtʋ ndʋ yɔ.Pɩwɛɛ se ŋma tʋmɩyɛ nɖɩ ɖɩñɔɔzʋʋ kɩyakʋ nakʋyʋ yɔ nɛ # >>> valid_date.call(""03-11-2000"")
# true
# >>> valid_date.call(""15-01-2012"")
# false
# >>> valid_date.call(""04-0-2040"")
# false
# >>> valid_date.call(""06-04-2020"")
# true
# >>> valid_date.call(""06/04/2020"")
# false
def valid_date(date)
","def valid_date(date)
  return false if date.nil? || date.empty?
  
  # Check if the date format is correct
  match = date.match(/^(\d{2})-(\d{2})-(\d{4})$/)
  return false unless match
  
  month, day, year = match.captures.map(&:to_i)
  
  # Check if month is valid
  return false if month < 1 || month > 12
  
  # Check if day is valid according to the month
  case month
  when 1, 3, 5, 7, 8, 10, 12
    return day >= 1 && day <= 31
  when 4, 6, 9, 11
    return day >= 1 && day <= 30
  when 2
    return day >= 1 && day <= 29
  else
    return false
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_valid_date
    candidate = method(:valid_date)
    assert_equal(true, candidate.call(""03-11-2000""))
    assert_equal(false, candidate.call(""15-01-2012""))
    assert_equal(false, candidate.call(""04-0-2040""))
    assert_equal(true, candidate.call(""06-04-2020""))
    assert_equal(true, candidate.call(""01-01-2007""))
    assert_equal(false, candidate.call(""03-32-2011""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""04-31-3000""))
    assert_equal(true, candidate.call(""06-06-2005""))
    assert_equal(false, candidate.call(""21-31-2000""))
    assert_equal(true, candidate.call(""04-12-2003""))
    assert_equal(false, candidate.call(""04122003""))
    assert_equal(false, candidate.call(""20030412""))
    assert_equal(false, candidate.call(""2003-04""))
    assert_equal(false, candidate.call(""2003-04-12""))
    assert_equal(false, candidate.call(""04-2003""))
  end
end
"
HumanEval_125,kbp_Latn,rb,"Kɩɖaŋ Takayɩhatʋ ndʋ tɩtamsɩna \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\ takayɩhatʋ \\Pɩwɛɛ se pɛtɛyɩ-ɩ nɛ ',' yee pɩfɛyɩna yɔ, pɩwɛɛ se ŋyele nɛ pama matʋ cikpetu ndʋ tɩ-taa pama-tʋ nɛ tɩ-taa lɛ, pama-tʋ nɛ tɩ-taa lɛ, pama-tʋ nɛ tɩ-taa lɛ, pama-tʋ nɛ tɩ-taa lɛ, pama-tʋ nɛ tɩ-taa lɛ, pama-tʋ nɛ tɩ-taa lɛ.Ye ŋwɛna tɔm pee kɩmaŋ yɔ, ŋpɩzɩɣ ŋlɩzɩ tɔm pee wena awɛ hɔɔlʋʋ kʋɖʋmʋʋ taa yɔ, nɛ ŋyele nɛ tɔm pee kɩmaŋ weyi awɛ hɔɔlʋʋ kʋɖʋmʋʋ taa yɔ, ɩpɩsɩ.# >>> split_words.call(""Hello world!"")
# [""Hello"", ""world!""]
# >>> split_words.call(""Hello,world!"")
# [""Hello"", ""world!""]
# >>> split_words.call(""abcdef"")
# 3
def split_words(txt)
","def split_words(txt)
  if txt.include?(' ')
    return txt.split(' ')
  elsif txt.include?(',')
    return txt.split(',')
  else
    odd_count = txt.chars.count { |char| ('a'..'z').include?(char) && (char.ord - 'a'.ord).odd? }
    return odd_count
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_split_words
    candidate = method(:split_words)
    assert_equal([""Hello"", ""world!""], candidate.call(""Hello world!""))
    assert_equal([""Hello"", ""world!""], candidate.call(""Hello,world!""))
    assert_equal([""Hello"", ""world,!""], candidate.call(""Hello world,!""))
    assert_equal([""Hello,Hello,world"", ""!""], candidate.call(""Hello,Hello,world !""))
    assert_equal(3, candidate.call(""abcdef""))
    assert_equal(2, candidate.call(""aaabb""))
    assert_equal(1, candidate.call(""aaaBb""))
    assert_equal(0, candidate.call(""""))
  end
end
"
HumanEval_126,kbp_Latn,rb,"Kɩɖaŋ Ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛyʊ ɛfɛyɩna ɛ-tɩ yɔɔ wɛʊ nɛ ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ, ɛ-tɛ lɛɣtʊ takayaɣ taa lɛ.Yee ɛyʊ ɛ-tɛ ɛ-tɛ kɩlabʊ ɛkɩlɩɣ kɔyɔ, ɛ-tɛ kɩlabʊ kɩlɛyɩɣ kɔyɔ, ɛ-tɛ kɩlabʊ kɩlɛyɩɣ kɔyɔ, ɛ-tɛ kɩlabʊ kɩlɛyɩɣ kɔyɔ.Ye ŋha-ɩ nimero waa sakɩyɛ yɔ, ɛkaɣ-wɛ pɩsʋʋ paa patɩlɩ-wɛ yaa pataana-wɛ yɔ.# >>> is_sorted.call([5])
# true
# >>> is_sorted.call([1, 2, 3, 4, 5])
# true
# >>> is_sorted.call([1, 3, 2, 4, 5])
# false
# >>> is_sorted.call([1, 2, 3, 4, 5, 6])
# true
# >>> is_sorted.call([1, 2, 3, 4, 5, 6, 7])
# true
# >>> is_sorted.call([1, 3, 2, 4, 5, 6, 7])
# false
# >>> is_sorted.call([1, 2, 2, 3, 3, 4])
# true
# >>> is_sorted.call([1, 2, 2, 2, 3, 4])
# false
def is_sorted(lst)
","def is_sorted(lst)
  lst.each_cons(2).with_index do |(a, b), index|
    return false if a > b
    return false if index < lst.length - 2 && a == b && lst[index + 2] == b
  end
  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_sorted
    candidate = method(:is_sorted)
    assert_equal(true, candidate.call([5]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))
    assert_equal(false, candidate.call([1, 3, 2, 4, 5]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))
    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))
    assert_equal(true, candidate.call([]))
    assert_equal(true, candidate.call([1]))
    assert_equal(false, candidate.call([3, 2, 1]))
    assert_equal(false, candidate.call([1, 2, 2, 2, 3, 4]))
    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))
    assert_equal(true, candidate.call([1, 2, 2, 3, 3, 4]))
    assert_equal(true, candidate.call([1, 2, 3, 4]))
  end
end
"
HumanEval_127,kbp_Latn,rb,"[Input/output] kɩɖaŋ: Ye tɔm naalɛ ɩtɩkpɛndɩ yɔ, pɩpɩsɩɣ ""Aayɩ"".Ye pɩtɛkɛ mbʋ yɔ, ŋpɩsɩɣ ""Aayɩ"".Yee kɩ-tɛ matʊ kɔyɔ, pɩtɛzɩna ""YES""Ɛ-hɛkʊ taa lɛ, ɛyʊ ɛ-hɛkʊ taa lɛ, ɛ-tɛ hɛkʊ taa lɛ, ɛ-tɛ hɛkʊ taa lɛ, ɛ-tɛ hɛkʊ taa lɛ.Kɩɖaʋ lɛ, hɔɔlɩŋ weyi ɩ-taa (1, 3), (2, 4) nɛ (2, 3) pɛtɛyɩɣ ɖama yɔ.Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.Ña-tʋmɩyɛ lɛ se ŋtɩlɩ se ɛzɩmtaa pɩtɛŋna nɛ pɩtalɩna-ŋ.Paa alɩwaatʊ ndʊ tɩ-taa lɛ, pamaɣzɩɣ se tɩ-paɣtʊ wɛna kɩmaŋ yaa tɩ-tɛ.Pɩ-taa lɛ, pamaɣzɩɣ kɩ-paɣzʋʋ nɛ kɩ-tɛtʋ.Pɩtɛ alɩwaatʊ taa lɛ, alɩwaatʊ ndʊ tɩ-taa (paɣzɩ, tɩtɛ)paa alɩwaatʊ ndʊ lɛ, tɩ-taa lɛ, kɩkɛna ɛyʊ kʊyʊm. Ɖɩkpaɣ ɛzɩ alɩwaatʊ ndʊ tɩ-taa lɛ, alɩwaatʊ ndʊ tɩ-taa lɛ, (kpazɩyɛ, tɛm) = (1, 2).Paha-ŋ alɩwaatʋ naalɛ.# >>> intersection.call([1, 2], [2, 3])
# ""NO""
# >>> intersection.call([-1, 1], [0, 4])
# ""NO""
# >>> intersection.call([-3, -1], [-5, 5])
# ""YES""
def intersection(interval1, interval2)
","def intersection(interval1, interval2)
  start1, end1 = interval1
  start2, end2 = interval2

  intersection_start = [start1, start2].max
  intersection_end = [end1, end2].min

  if intersection_start > intersection_end
    return ""NO""
  end

  intersection_length = intersection_end - intersection_start + 1

  return ""YES"" if prime?(intersection_length)

  ""NO""
end

def prime?(n)
  return false if n <= 1
  return true if n == 2 || n == 3

  (2..Math.sqrt(n).to_i).each do |i|
    return false if n % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_intersection
    candidate = method(:intersection)
    assert_equal(""NO"", candidate.call([1, 2], [2, 3]))
    assert_equal(""NO"", candidate.call([-1, 1], [0, 4]))
    assert_equal(""YES"", candidate.call([-3, -1], [-5, 5]))
    assert_equal(""YES"", candidate.call([-2, 2], [-4, 0]))
    assert_equal(""NO"", candidate.call([-11, 2], [-1, -1]))
    assert_equal(""NO"", candidate.call([1, 2], [3, 5]))
    assert_equal(""NO"", candidate.call([1, 2], [1, 2]))
    assert_equal(""NO"", candidate.call([-2, -2], [-3, -2]))
  end
end
"
HumanEval_128,kbp_Latn,rb,"Kɩɖaʋ: Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ:Paa mayaɣ ŋga lɛ, ka-taa mayaɣ ŋga lɛ 1, -1 yaa 0.Ɛyʊ ɛ-tʊmɩyɛ lɛ se ɛlɩzɩ ɛ-tɛ tɔm nɛ ɛlɩzɩ-tʊ nɛ ɛ-tɛ tɔm ndʊ tɩ-taa.Pʊtɔbʊʊ se ŋwɛna ñʊʊ taa ɛyʊ nɛ pɩpɔzʋʋ se ŋpɩsɩ ɛyʊ.# >>> prod_signs.call([1, 2, 2, -4])
# 9
# >>> prod_signs.call([0, 1])
# 0
# >>> prod_signs.call([])
# nil
def prod_signs(arr)
","def prod_signs(arr)
  return nil if arr.empty?
  
  product_signs = arr.reduce(1) { |prod, num| prod * num <=> 0 }
  sum_magnitudes = arr.map(&:abs).sum
  
  product_signs * sum_magnitudes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prod_signs
    candidate = method(:prod_signs)
    assert_equal(-9, candidate.call([1, 2, 2, -4]))
    assert_equal(0, candidate.call([0, 1]))
    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))
    assert_equal(nil, candidate.call([]))
    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))
    assert_equal(4, candidate.call([-1, 1, -1, 1]))
    assert_equal(-4, candidate.call([-1, 1, 1, 1]))
    assert_equal(0, candidate.call([-1, 1, 1, 0]))
  end
end
"
HumanEval_129,kbp_Latn,rb,"Kɩɖaŋ: Ɛpɩsɩɣ ɛ-tɛ kɩlɛmɩŋ weyi ɛ-tɛ kɩlɛmɩŋ kɩlɩna wɛʊ yɔ.Pɩtʋʋ fɛyɩ se tɔm ndʋ tɩ-yɔɔ cosuu wɛ ndɩ.Lɩmaɣzɩyɛ nɖɩ ɖɩ-taa lɛ, ɛyʊ wɛna ɛ-tɩ yɔɔ wɛʊ nɛ ɛ-tɛ ɛyʊ wɛʊ yɔ.Ɖɩkpaɣ ɛzɩ lst_A[i] < lst_B[i] nɛ j (1 <= j < i) kɔyɔ ɖɩnaɣ sePɩtɛ lɛ, ɛyʊ ɛnʊ ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛ, ɛ-tɛ ɛyʊ lɛlʊ taa lɛlʊ taa lɛlʊ.Pɩtɛ lɛ, ɖɩkpaɣ se ɖɩyaɣ-wɛ se lst_A nɛ lst_B.Ɖɩcɔna kɔyɔ, ɖɩnaɣ se, ɖɩkpaɣ kɩlɛmʋʋ ŋgʋ kɩwɛna hɔɔlɩŋ weyi ɩ-taa A nɛ B pɛwɛɛ yɔ nɛ ɖɩkpaɣ kɩ-tɛ hɔɔlɩŋ lɛɛŋ nɛ ɖɩkpaɣ kɩ-tɛ hɔɔlɩŋ lɛɛŋ nɛ ɖɩkpaɣ kɩ-tɛ hɔɔlɩŋ lɛɛŋ nɛ ɖɩkpaɣ kɩ-tɛ hɔɔlɩŋ lɛɛŋ.Kɩɖaʋ kʋnɛ kɩ-taa lɛ, pɩwɩlɩɣ se ɛyʊ ɛ-tɩ yɔɔ wɛʊ yɔ, pɩfɛyɩ ɖeu se ɛ-tɩ yɔɔ wɛʊ ɛɖʊ nɔɔyʊ yɔɔ.ŊYƐƐƐ se ŋtaatasɩ naʋ nɔɔyʋ.Pɩtɩcɛyɩ se patɩlɩ-wɛ).Ɖɩcɔna kɔyɔ, ɖɩnaɣ se nʋmɔʋ ŋgʋ kɩwɛna k yɔ, kɩ-taa lɛ, ɖɩnaɣ se ɖɩcɔna k pilinzi ɖeyi ɖeyi (ɛtɛkɛ Pɩsɩ nɛ ŋna-ɩ tɔm kɩcɛyɩtʋPʋ-tɔbʋʋ se ŋpɩzɩɣ ŋwolo lone nɖɩ ɖɩ-taa ŋwɛna yɔ nɛ ŋwolo lone nɖɩ ɖɩ-taa ŋwɛna yɔ.paa lone nɖɩ ɖɩ-taa nɛ paa nʋmɔʋ ŋgʋ kɩ-taa lɛ, ŋpɩzɩɣ ŋwolo lone nɖɩ ɖɩ-taa ŋwɛɛ yɔ.Pɩwɛɛ se ŋñɩnɩ n̄ɩɣyʋʋ cikpeluu ŋgʋ kɩwɛna n̄ɩɣyʋʋ k yɔ, nɛ ŋpaɣzɩna.Pɩtɛ tɔmpiye inclusive lɩzɩɣna tam kʋɖʋmʋʋ kɛ matʊ hɔɔlʊʊ taa.paa ɛyʊ weyi lɛ ɛ-tɛ ɛyʊ kɩlaʊ taa.Ye ɖɩkpaɣ ɛyʊ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ ɛ-tɛ# >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)
# [1, 2, 1]
# >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)
# [1]
def minPath(grid, k)
","def minPath(grid, k)
  n = grid.size
  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  min_path = nil

  n.times do |i|
    n.times do |j|
      queue = [[[i, j], [grid[i][j]]]]
      until queue.empty?
        position, path = queue.shift
        if path.size == k
          min_path = path if min_path.nil? || path < min_path
          next
        end
        directions.each do |dx, dy|
          x, y = position[0] + dx, position[1] + dy
          if x.between?(0, n-1) && y.between?(0, n-1)
            queue.push([[x, y], path + [grid[x][y]]])
          end
        end
      end
    end
  end
  min_path
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_minPath
    candidate = method(:minPath)
    assert_equal([1, 2, 1], candidate.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))
    assert_equal([1], candidate.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))
    assert_equal([1, 2, 1, 2], candidate.call([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))
    assert_equal([1, 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7))
    assert_equal([1, 7, 1, 7, 1], candidate.call([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))
    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9))
    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12))
    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8))
    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8))
    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], candidate.call([[1, 2], [3, 4]], 10))
    assert_equal([1, 3, 1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))
  end
end
"
HumanEval_130,kbp_Latn,rb,"Kɩɖaŋ: Nɔɔɖɛyaa Ɛgbɛyɛ taa ɛzʋtʋyaa mba pa-taa nabɛyɛ lɛ:Pʊtɔbʊʊ se ŋwɛna ɛyʊ kʊyʊmʊm nɛ ɛfɛyɩ kʊyʊmʊm, nɛ pɩwɛɛ se ŋpɩsɩ ɛyʊ kʊyʊmʊm = 2 + 3 + 3 = 8 3 = 3 + 3 + 43 = 4 (Tri) = 1 + (2 / 2) = 2 Kɩɖaʋ nakʋyʋ yɔ: (n) = (n - 1) + (n - 2) + (n + 1) ye n ɛfɛyɩ ndɩ yɔ.tri (n) = 1 + n / 2, yee n ɛtɛyɩ yɔ.(Tɩnaɣ kɩlɛmʋʋ yɔɔ tɔm kɩkpɛlɩkɩtʋ 3)Tribonacci tɛ kʊyʊmʊʊ wɛna tɔbʊʊ se: Ɛlɛ, ɛyaa ɩɩsɩŋ Tribonacci tɔm piye nɖɩ.Paa anɩ ɛsɩm Fibonacci tɛ n̄ɩɣyʋʋ, pama-kʋ nɛ pɔcɔna siŋŋ kɛ maɣzɩm takayasɩ taa n̄ɩma cɔlɔ pɩnaɣ 1854 taa.# >>> tri.call(3)
# [1, 3, 2, 8]
def tri(n)
","def tri(n)
  sequence = [1, 3]
  
  (2..n).each do |i|
    if i.even?
      sequence[i] = 1 + i / 2
    else
      sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1] rescue 0
    end
  end
  
  sequence[0..n]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_tri
    candidate = method(:tri)
    assert_equal([1, 3, 2, 8], candidate.call(3))
    assert_equal([1, 3, 2, 8, 3], candidate.call(4))
    assert_equal([1, 3, 2, 8, 3, 15], candidate.call(5))
    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35], candidate.call(9))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))
    assert_equal([1], candidate.call(0))
    assert_equal([1, 3], candidate.call(1))
  end
end
"
HumanEval_131,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Ye nimasɩ tɩŋa ɩkɛ kɩkpɛndɩna yɔ, pɩsɩɣnɩ-ɩ nɛ ɛkɔɔ nɛ ɛkɔɔ lɛ, ɛkɔɔ nɛ 0.Ye paha-ɖʋ nimero intérieur positif n yɔ, ɖɩpɩsɩɣ tɔmpiye nɖɩ ɖɩlɩna nimero waa mba pa-taa pa-taa pa-taa pa-taa yɔ.# >>> digits.call(1)
# 1
# >>> digits.call(4)
# 0
# >>> digits.call(235)
# 15
def digits(n)
","def digits(n)
  odd_digits = n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }
  return 0 if odd_digits.empty?
  odd_digits.reduce(:*)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_digits
    candidate = method(:digits)
    assert_equal(5, candidate.call(5))
    assert_equal(5, candidate.call(54))
    assert_equal(1, candidate.call(120))
    assert_equal(5, candidate.call(5014))
    assert_equal(315, candidate.call(98765))
    assert_equal(2625, candidate.call(5576543))
    assert_equal(0, candidate.call(2468))
  end
end
"
HumanEval_132,kbp_Latn,rb,"Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.Pɩwɛɛ se tʊmɩyɛ nɖɩ ɖɩpɩsɩ tɔmpiye true yee nɛ yee pɛtɛyɩ-ɖɩ nɛ tɔmpiye kʊɖʊmɖɩyɛ yɔ.Lɩzɩ tʋmɩyɛ nɖɩ ɖɩkpaɣna tɔmpiye naɖɩyɛ nɛ ɖɩ-taa wɛ tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa wɛ tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa lɛ.# >>> is_nested.call(""[[]]"")
# true
# >>> is_nested.call(""[]]]]]]][[[[[]"")
# false
# >>> is_nested.call(""[][]"")
# false
# >>> is_nested.call(""[]"")
# false
# >>> is_nested.call(""[[][]]"")
# true
# >>> is_nested.call(""[[]][["")
# true
def is_nested(string)
","def is_nested(string)
  stack = []
  has_nested = false

  string.each_char do |char|
    if char == '['
      stack.push(char)
    elsif char == ']'
      if stack.empty?
        return false
      end
      stack.pop
      has_nested = true if stack.any?
    end
  end

  has_nested
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_nested
    candidate = method(:is_nested)
    assert_equal(true, candidate.call(""[[]]""))
    assert_equal(false, candidate.call(""[]]]]]]][[[[[]""))
    assert_equal(false, candidate.call(""[][]""))
    assert_equal(false, candidate.call(""[]""))
    assert_equal(true, candidate.call(""[[[[]]]]""))
    assert_equal(false, candidate.call(""[]]]]]]]]]]""))
    assert_equal(true, candidate.call(""[][][[]]""))
    assert_equal(false, candidate.call(""[[]""))
    assert_equal(false, candidate.call(""[]]""))
    assert_equal(true, candidate.call(""[[]][[""))
    assert_equal(true, candidate.call(""[[][]]""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""[[[[[[[[""))
    assert_equal(false, candidate.call(""]]]]]]]]""))
  end
end
"
HumanEval_133,kbp_Latn,rb,"Kɩɖaŋ: Pɩtɛ lɛ, ŋcalɩɣna nɛ ŋcɔna nɛ ŋna se ŋwɛna ŋñɩɩ yaa ŋfɛyɩna ŋñɩɩ.Pɩwɛɛ se ŋyele nɛ ɖɩna se tɔmpiye nɖɩ ɖɩ-taa ŋtɩŋna yɔ, ɖɩ-taa lɛ, ŋpɩzɩɣ ŋlɩzɩ tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye.Pɩɩha-ŋ nimbrɩwaa sakɩyɛ.# >>> lst.call([1.0, 2.0, 3.0])
# 14
# >>> lst.call([1.0, 4.0, 9.0])
# 98
# >>> lst.call([1.0, 3.0, 5.0, 7.0])
# 84
# >>> lst.call([1.4, 4.2, 0.0])
# 29
# >>> lst.call([-2.4, 1.0, 1.0])
# 6
def sum_squares(lst)
","def sum_squares(lst)
  lst.map { |num| (num.ceil)**2 }.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_squares
    candidate = method(:sum_squares)
    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))
    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))
    assert_equal(84, candidate.call([1.0, 3.0, 5.0, 7.0]))
    assert_equal(29, candidate.call([1.4, 4.2, 0.0]))
    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))
    assert_equal(10230, candidate.call([100.0, 1.0, 15.0, 2.0]))
    assert_equal(200000000, candidate.call([10000.0, 10000.0]))
    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))
    assert_equal(1086, candidate.call([-1.4, 17.9, 18.9, 19.9]))
    assert_equal(0, candidate.call([0.0]))
    assert_equal(1, candidate.call([-1.0]))
    assert_equal(2, candidate.call([-1.0, 1.0, 0.0]))
  end
end
"
HumanEval_134,kbp_Latn,rb,"Kɩɖaŋ: Pɩsɩ nɛ ŋna-ɩ tɔm kɩsɔzɩtʋ: ""tɔm"" kɛna matʋ cabɩ kpou nakʋyʋ.Tɔm piye naɖɩyɛ hɔɔlʋʋ taa, nɛ lɛɛtʋ taa lɛ, pɩkɛ cɛtɩm tɔm.Pɩtɛ alɩwaatʊ taa lɛ, tɔmpiye nɖɩ ɖɩkɛ alɩbɛɛtɩ tɔmpiye nɛ ɖɩfɛyɩ ɛzɩ  yɔ.Lɩzɩ tʊmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔmpiye true yee tɔmpiye kɛdɛzaɣ ñɩnɖɛ kɔyɔ .# >>> check_if_last_char_is_a_letter.call(""apple pie"")
# false
# >>> check_if_last_char_is_a_letter.call(""apple pi e"")
# true
# >>> check_if_last_char_is_a_letter.call(""apple pi e "")
# false
# >>> check_if_last_char_is_a_letter.call("""")
# false
def check_if_last_char_is_a_letter(txt)
","check_if_last_char_is_a_letter = ->(txt) {
  return false if txt.strip.empty?
  words = txt.strip.split(' ')
  last_word = words.last
  return false if last_word.empty?
  last_char = last_word[-1]

  last_char =~ /[a-zA-Z]/ && (words.size == 1 || txt[txt.rindex(last_char) - 1] == ' ')
}","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_check_if_last_char_is_a_letter
    candidate = method(:check_if_last_char_is_a_letter)
    assert_equal(false, candidate.call(""apple""))
    assert_equal(true, candidate.call(""apple pi e""))
    assert_equal(false, candidate.call(""eeeee""))
    assert_equal(true, candidate.call(""A""))
    assert_equal(false, candidate.call(""Pumpkin pie ""))
    assert_equal(false, candidate.call(""Pumpkin pie 1""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""eeeee e ""))
    assert_equal(false, candidate.call(""apple pie""))
    assert_equal(false, candidate.call(""apple pi e ""))
  end
end
"
HumanEval_135,kbp_Latn,rb,"Kɩɖaŋ: Kɩ-taa wɛ tɔm kɩfatʋ.yee pɩfɛyɩ kɔyɔ, pɩpɩsɩɣ -1.Pɩfɛyɩ pɩdɩɩfɛyɩ yaa pɩfɛyɩ ɖɔɖɔ ɛzɩ pɩdɩɩfɛyɩ yɔ.Lɩzɩ tʊmɩyɛ nɖɩ ɖɩpɩsɩɣ ɛyʊ kʊyʊmʊm sɔsɔm yɔ nɛ ɖɩ-tɛ lɛɣtʊ ndʊ tɩ-taa # >>> can_arrange.call([1, 2, 4, 3, 5])
# 3
# >>> can_arrange.call([1, 2, 3])
# -1
def can_arrange(arr)
","def can_arrange(arr)
  (1...arr.length).reverse_each do |i|
    return i if arr[i] < arr[i - 1]
  end
  -1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_can_arrange
    candidate = method(:can_arrange)
    assert_equal(3, candidate.call([1, 2, 4, 3, 5]))
    assert_equal(-1, candidate.call([1, 2, 4, 5]))
    assert_equal(2, candidate.call([1, 4, 2, 5, 6, 7, 8, 9, 10]))
    assert_equal(4, candidate.call([4, 8, 5, 7, 3]))
    assert_equal(-1, candidate.call([]))
  end
end
"
HumanEval_136,kbp_Latn,rb,"Kɩɖaŋ: Yee ɛyʊ ɛfɛyɩna ɛyʊ kʊyʊm yaa ɛyʊ kɩlɛyʊ kɔyɔ, pɩpɩsɩɣ ɛyʊ kʊyʊm.Ɛyʊ ɛ-tʊmɩyɛ lɛ se ɛlɩzɩ ɛ-tɛ ɛyʊtʊmɩyɛ nɖɩ ɖɩ-tɛ ɛyʊtʊmɩyɛ.Ɛyʊ ɛ-ñʊʊ taa lɛ, pʊtɔbʊʊ se ɛ-ñʊʊ taa lɛ, pʊtɔbʊʊ se ɛ-ñʊʊ taa lɛ, pʊtɔbʊʊ se ɛ-ñʊʊ taa lɛ.Lɩzɩ tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ (a, b) yɔ, ɖenɖe a kɛ  yɔ.# >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])
# [nil, 1]
# >>> largest_smallest_integers.call([])
# [nil, nil]
# >>> largest_smallest_integers.call([0])
# [nil, nil]
def largest_smallest_integers(lst)
","def largest_smallest_integers(lst)
  largest_negative = nil
  smallest_positive = nil
  
  lst.each do |num|
    if num < 0
      largest_negative = num if largest_negative.nil? || num > largest_negative
    elsif num > 0
      smallest_positive = num if smallest_positive.nil? || num < smallest_positive
    end
  end
  
  [largest_negative, smallest_positive]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_smallest_integers
    candidate = method(:largest_smallest_integers)
    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7]))
    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7, 0]))
    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5, 6, -2]))
    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))
    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))
    assert_equal([nil, nil], candidate.call([]))
    assert_equal([nil, nil], candidate.call([0]))
    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))
    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6, 0]))
    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, 1]))
    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100, 1]))
  end
end
"
HumanEval_137,kbp_Latn,rb,"Pɩsɩ nɛ ŋna-ɩ: Ye pamaɣ mayaɣ nakɛyɛ nɛ pamaɣzɩna-kɛ ɛzɩ tɔmpiye yɔ, tɔmpiye nɖɩ ɖɩ-taa pamaɣna-kɛ yɔ, ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa pamaɣna-kɛ yɔ, ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa pamaɣna-kɛ yɔ, ɖɩ-taa lɛ, tɔmpiye nɖɩ ɖɩ-taa pamaɣna-kɛ yɔ.Ye kɩ-kɩcɛyɩm ɩnɩ ɩ-tɩŋa ɩnɩ ɩ-taa nabʋyʋ ɛfɛyɩ yɔ, pɩsɩɣnɩ-ɩ.Ɛ-tɛ lɛɣtʊ tʊmɩyɛ labʊ nɛ ɛ-tɛ lɛɣtʊ tʊmɩyɛ labʊ nɛ ɛ-tɛ lɛɣtʊ tʊmɩyɛ labʊ.Lɩzɩ tʋmɩyɛ nɖɩ ɖɩmʋɣ intɛrɩjɛrɩwaa, float waa yaa strings waa mba pasɩŋna # >>> compare_one.call(1, 2.5)
# 2.5
# >>> compare_one.call(1, ""2,3"")
# ""2,3""
# >>> compare_one.call(""5,1"", ""6"")
# ""6""
# >>> compare_one.call(""1"", 1)
# nil
def compare_one(a, b)
","def compare_one(a, b)
  a = a.to_s.tr(',', '.').to_f if a.is_a?(String) && a.include?(',')
  b = b.to_s.tr(',', '.').to_f if b.is_a?(String) && b.include?(',')

  if a.is_a?(String) && b.is_a?(String)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(Float)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(Integer)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(Float)
    a = a.to_f
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(Integer)
    b = b.to_f
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(String) && b.is_a?(Float)
    b = b.to_s # Only supporting variable type comparison, retain original types
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(String)
    a = a.to_s # Only supporting variable type comparison, retain original types
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(String) && b.is_a?(Integer)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(String)
    return nil if a == b
    return a > b ? a : b
  else
    return nil
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_compare_one
    candidate = method(:compare_one)
    assert_equal(2, candidate.call(1, 2))
    assert_equal(2.5, candidate.call(1, 2.5))
    assert_equal(3, candidate.call(2, 3))
    assert_equal(6, candidate.call(5, 6))
    assert_equal(""2,3"", candidate.call(1, ""2,3""))
    assert_equal(""6"", candidate.call(""5,1"", ""6""))
    assert_equal(""2"", candidate.call(""1"", ""2""))
    assert_equal(nil, candidate.call(""1"", 1))
  end
end
"
HumanEval_138,kbp_Latn,rb,"Kɩɖaʋ Pɩwɛɛ se ɖɩtɩlɩ se paa mayaɣ ŋga lɛ, kɛwɛna hɔɔlɩŋ naanza nɛ hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa lɛ, hɔɔlɩŋ ɛnɩ ɩ-taa.# >>> is_equal_to_sum_even.call(4)
# false
# >>> is_equal_to_sum_even.call(6)
# false
# >>> is_equal_to_sum_even.call(8)
# true
def is_equal_to_sum_even(n)
","def is_equal_to_sum_even(n)
  return false if n < 8
  n.even?
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_equal_to_sum_even
    candidate = method(:is_equal_to_sum_even)
    assert_equal(false, candidate.call(4))
    assert_equal(false, candidate.call(6))
    assert_equal(true, candidate.call(8))
    assert_equal(true, candidate.call(10))
    assert_equal(false, candidate.call(11))
    assert_equal(true, candidate.call(12))
    assert_equal(false, candidate.call(13))
    assert_equal(true, candidate.call(16))
  end
end
"
HumanEval_139,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: le n > 0 brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! Payaɣ Brasiiili ɛjaɖɛ taa tɔmpiye nɖɩ se: # >>> special_factorial.call(4)
# 288
# The function will receive an integer as input and should return the special
# factorial of this integer.
def special_factorial(n)
","def special_factorial(n)
  return 1 if n <= 1
  (1..n).inject(1) { |product, i| product * factorial(i) }
end

def factorial(num)
  return 1 if num <= 1
  (2..num).inject(1, :*)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_special_factorial
    candidate = method(:special_factorial)
    assert_equal(288, candidate.call(4))
    assert_equal(34560, candidate.call(5))
    assert_equal(125411328000, candidate.call(7))
    assert_equal(1, candidate.call(1))
  end
end
"
HumanEval_140,kbp_Latn,rb,"Pɩtɛ lɛ, pɛlɛɣzɩ matʋ ndʋ tɩ-tɩŋa nɛ - nɛ yee pɩcɛzɩ nabʊlɛ mbʊ yɔ, Ye ŋwɛna tɔm pee kɩmanzɩ yɔ, kpaɣ-yɛ nɛ ŋlɛɣzɩna ɖenɖe pɩfɛyɩ yɔ nɛ pɩ-tɛɛ mayaɣ, # >>> fix_spaces.call("" Example"")
# ""Example""
# >>> fix_spaces.call("" Example 1"")
# ""Example_1""
# >>> fix_spaces.call("" Example 2"")
# ""_Example_2""
# >>> fix_spaces.call("" Example 3"")
# ""_Example-3""
def fix_spaces(text)
","def fix_spaces(text)
  text.strip.gsub(/\s{3,}/, '-').gsub(' ', '_')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fix_spaces
    candidate = method(:fix_spaces)
    assert_equal(""Example"", candidate.call(""Example""))
    assert_equal(""Mudasir_Hanif_"", candidate.call(""Mudasir Hanif ""))
    assert_equal(""Yellow_Yellow__Dirty__Fellow"", candidate.call(""Yellow Yellow  Dirty  Fellow""))
    assert_equal(""Exa-mple"", candidate.call(""Exa   mple""))
    assert_equal(""-Exa_1_2_2_mple"", candidate.call(""   Exa 1 2 2 mple""))
  end
end
"
HumanEval_141,kbp_Latn,rb,"Kɩɖaŋ: - Pɩwɛɛ se tɔmpiye nɖɩ ɖɩtɩŋɩɣ tɩʋ yɔɔ yɔ ɖɩkɛ tɔmpiye nɖɩ ɖɩ-taa: ['txt', 'exe', 'dll'] Latɛŋ masɩ taa lɛ, payaɣ se ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""a"" nɛ ""- Kajalaɣ ñɩŋgʋ lɛ, pɩfɛyɩ se ŋyele nɛ tɔm pee wena awɛ tɩ-yɔɔ yɔ, awɛɛ falaa, nɛ kacalaɣ ñɩŋgʋ lɛ - Takayaɣ ŋga ka-hɩɖɛ wɛna tɩʋ kʋɖʋmʋʋ ɖeyi ɖeyi.- Takayaɣ ŋga ka-hɩɖɛ taa lɛ, ka-taa mayaɣ ɛfɛyɩna tam nabudozo nɛ pɩkɩlɩ ('0' - '9'). pɔ-tɔm taa: Payaɣ takayaɣ nakɛyɛ hɩɖɛ se takayaɣ kɩkalaɣ ye ka-taa tɔm tʋnɛ tɩ-tɩŋa tɩwɛɛ yɔ.Yee tɔmpiye nɖɩ ɖɩ-hɩɖɛ ɛwɛ camɩyɛ yɔ, ɖɩ-taa lɛ, pamaɣ se ""Ɛɛɛ"" nɛ yee pɩtɛkɛ mbʋ yɔ, pamaɣ se ""Aayɩ"".Lɩzɩ tʋmɩyɛ nɖɩ ɖɩkpaɣna tɔmpiye nɖɩ ɖɩkɛ takayaɣ nakɛyɛ hɩɖɛ yɔ nɛ ɖɩpɩsɩ # >>> file_name_check.call(""example.txt"")
# ""Yes""
# >>> file_name_check.call(""1example.dll"")
# ""No""
def file_name_check(file_name)
","def file_name_check(file_name)
  # Check if there's exactly one dot in the filename
  return 'No' unless file_name.count('.') == 1
  
  # Split the filename into the name and extension
  name, extension = file_name.split('.')
  
  # Check if the name part starts with a letter
  return 'No' if name.empty? || !name[0].match?(/[a-zA-Z]/)
  
  # Check if the extension is valid
  return 'No' unless ['txt', 'exe', 'dll'].include?(extension)
  
  # Count digits in the file name
  digit_count = file_name.count(""0-9"")
  
  # Check if digits are more than three
  return 'No' if digit_count > 3
  
  'Yes'
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_file_name_check
    candidate = method(:file_name_check)
    assert_equal(""Yes"", candidate.call(""example.txt""))
    assert_equal(""No"", candidate.call(""1example.dll""))
    assert_equal(""No"", candidate.call(""s1sdf3.asd""))
    assert_equal(""Yes"", candidate.call(""K.dll""))
    assert_equal(""Yes"", candidate.call(""MY16FILE3.exe""))
    assert_equal(""No"", candidate.call(""His12FILE94.exe""))
    assert_equal(""No"", candidate.call(""_Y.txt""))
    assert_equal(""No"", candidate.call(""?aREYA.exe""))
    assert_equal(""No"", candidate.call(""/this_is_valid.dll""))
    assert_equal(""No"", candidate.call(""this_is_valid.wow""))
    assert_equal(""Yes"", candidate.call(""this_is_valid.txt""))
    assert_equal(""No"", candidate.call(""this_is_valid.txtexe""))
    assert_equal(""No"", candidate.call(""#this2_i4s_5valid.ten""))
    assert_equal(""No"", candidate.call(""@this1_is6_valid.exe""))
    assert_equal(""No"", candidate.call(""this_is_12valid.6exe4.txt""))
    assert_equal(""No"", candidate.call(""all.exe.txt""))
    assert_equal(""Yes"", candidate.call(""I563_No.exe""))
    assert_equal(""Yes"", candidate.call(""Is3youfault.txt""))
    assert_equal(""Yes"", candidate.call(""no_one#knows.dll""))
    assert_equal(""No"", candidate.call(""1I563_Yes3.exe""))
    assert_equal(""No"", candidate.call(""I563_Yes3.txtt""))
    assert_equal(""No"", candidate.call(""final..txt""))
    assert_equal(""No"", candidate.call(""final132""))
    assert_equal(""No"", candidate.call(""_f4indsartal132.""))
    assert_equal(""No"", candidate.call("".txt""))
    assert_equal(""No"", candidate.call(""s.""))
  end
end
"
HumanEval_142,kbp_Latn,rb,"Kɩɖaŋ: Pɩtɛ lɛ, tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔm pee wena awɛ matriki taa yɔ a-tɩŋa.Pɩtɛ ɛyʊ ɛ-tɛ ɛyʊ kʊyʊm 3 nɛ ɛkaɣ ɛ-tɛ ɛyʊ kʊyʊm ɛ-tɛ ɛyʊ kʊyʊm 4 nɛ ɛ-tɛ ɛyʊ kʊyʊm 3 yɔ.Tʊmɩyɛ ɖɩnɛ ɖɩkaɣ kpaɣʊ ɛyʊ kʊyʊm hɔɔlʊʊ taa. Pɩ-tɛ hɔɔlʊʊ taa ɛyʊ kʊyʊm hɔɔlʊʊ taa lɛ, tʊmɩyɛ nɖɩ ɖɩkaɣ kpaɣʊ ɛyʊ kʊyʊm hɔɔlʊʊ taa ɛyʊ kʊyʊm hɔɔlʊʊ taa yee ɛ-tɛ kʊyʊm hɔɔlʊʊ taa ɛyʊ kʊyʊm hɔɔlʊʊ taa lɛ, pɩkɛ "" # >>> lst
# [1, 2, 3]
# >>> lst
# []
# >>> lst
# [-1, -5, 2, -1, -5]
def sum_squares(lst)
","def sum_squares(lst)
  lst.map.with_index do |num, index|
    if index % 3 == 0
      num ** 2
    elsif index % 4 == 0
      num ** 3
    else
      num
    end
  end.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_squares
    candidate = method(:sum_squares)
    assert_equal(6, candidate.call([1, 2, 3]))
    assert_equal(14, candidate.call([1, 4, 9]))
    assert_equal(0, candidate.call([]))
    assert_equal(9, candidate.call([1, 1, 1, 1, 1, 1, 1, 1, 1]))
    assert_equal(-3, candidate.call([-1, -1, -1, -1, -1, -1, -1, -1, -1]))
    assert_equal(0, candidate.call([0]))
    assert_equal(-126, candidate.call([-1, -5, 2, -1, -5]))
    assert_equal(3030, candidate.call([-56, -99, 1, 0, -2]))
    assert_equal(0, candidate.call([-1, 0, 0, 0, 0, 0, 0, 0, -1]))
    assert_equal(-14196, candidate.call([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]))
    assert_equal(-1448, candidate.call([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]))
  end
end
"
HumanEval_143,kbp_Latn,rb,"Kɩɖaʋ 1:Pɩwɛɛ se tɔm pee wena awɛ tɔm pee kɩfana taa yɔ, aɖɔ ɛzɩ a-tɛ kajalaɣ tɔm pee yɔ.nɛ ɛ-kɩɖaʊ kɛ ɛyʊ kɩlɩm, Nɛ pɩwɛɛ se ŋyele nɛ tɔm pee wena awɛ kajalaɣ tɔm piye taa yɔ, tɔm pee naayɛ wɛ tɔm hʊyaa taa nɛ pɔhɔkɩ ɖama nɛ kʊɖʊmɩŋ, Pɩɩha-ŋ tɔm pee wena awɛ ɛzɩ tɔm loyaɣ yɔ.# >>> words_in_sentence.call(""This is a test"")
# ""is""
# Example 2:
# >>> words_in_sentence.call(""lets go for swimming"")
# ""go for""
# Constraints:
# * 1 <= len(sentence) <= 100
# * sentence contains only letters
def words_in_sentence(sentence)
","def words_in_sentence(sentence)
  def is_prime?(num)
    return false if num <= 1
    (2..Math.sqrt(num)).none? { |i| num % i == 0 }
  end
  
  words = sentence.split("" "")
  prime_length_words = words.select { |word| is_prime?(word.length) }
  prime_length_words.join("" "")
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_words_in_sentence
    candidate = method(:words_in_sentence)
    assert_equal(""is"", candidate.call(""This is a test""))
    assert_equal(""go for"", candidate.call(""lets go for swimming""))
    assert_equal(""there is no place"", candidate.call(""there is no place available here""))
    assert_equal(""Hi am Hussein"", candidate.call(""Hi I am Hussein""))
    assert_equal(""go for it"", candidate.call(""go for it""))
    assert_equal("""", candidate.call(""here""))
    assert_equal(""is"", candidate.call(""here is""))
  end
end
"
HumanEval_144,kbp_Latn,rb,"Ŋpɩzɩɣ ŋmaɣzɩ se x nɛ n pɛkɛ hɔɔlɩŋ weyi ɩwɛ ɖeu yɔ, nɛ pɛfɛyɩnɩ zéro ɛzɩ pɛ-hɩɖɛ yɔ.Ɛyʊ kʊyʊm nɛ ɛ-tɛ kʊyʊm pɛkpɛnda ɛ-tɛ kʊyʊm nɛ ɛ-tɛ kʊyʊm pɛkpɛnda ɛ-tɛ kʊyʊm.Pɩtasɩna mbʋ yɔ, x nɛ n, pɛtɛyɩɣ tɔmpiye nɖɩ nɛ tɔmpiye nɖɩ ɖɩ-tɛ lɛɣtʊ, nɛ ɖɩ-tɛ lɛɣtʊ wɛ ɛzɩ mbʊ yɔ:x * n. Kɩ-tɛ lɛɣtʊ tʊmɩyɛ pɩsɩɣna toovenim yee x * n ɛ-tɛ lɛɣtʊ tʊmɩyɛ ɛtɛ lɛɣtʊ tʊmɩyɛ kɔyɔ nɛ false Ña-tʋmɩyɛ lɛ se ŋlabɩnɩ tʋmɩyɛ tʋmɩyɛ nɖɩ ɖɩkaɣ kɛlɛʋ pɩ-yɔɔ yɔ .# >>> simplify.call(""1/5"", ""5/1"")
# true
# >>> simplify.call(""1/6"", ""2/1"")
# false
# >>> simplify.call(""7/10"", ""10/2"")
# false
def simplify(x, n)
","def simplify(x, n)
  # Convert x and n to numerators and denominators
  num_x, den_x = x.split('/').map(&:to_i)
  num_n, den_n = n.split('/').map(&:to_i)

  # Multiply fractions: (num_x * num_n) / (den_x * den_n)
  numerator = num_x * num_n
  denominator = den_x * den_n

  # Check if the result is a whole number
  numerator % denominator == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_simplify
    candidate = method(:simplify)
    assert_equal(true, candidate.call(""1/5"", ""5/1""))
    assert_equal(false, candidate.call(""1/6"", ""2/1""))
    assert_equal(true, candidate.call(""5/1"", ""3/1""))
    assert_equal(false, candidate.call(""7/10"", ""10/2""))
    assert_equal(true, candidate.call(""2/10"", ""50/10""))
    assert_equal(true, candidate.call(""7/2"", ""4/2""))
    assert_equal(true, candidate.call(""11/6"", ""6/1""))
    assert_equal(false, candidate.call(""2/3"", ""5/2""))
    assert_equal(false, candidate.call(""5/2"", ""3/5""))
    assert_equal(true, candidate.call(""2/4"", ""8/4""))
    assert_equal(true, candidate.call(""2/4"", ""4/2""))
    assert_equal(true, candidate.call(""1/5"", ""5/1""))
    assert_equal(false, candidate.call(""1/5"", ""1/5""))
  end
end
"
HumanEval_145,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Pɔɖɔɔnɩ-wɛ nɛ pa-lɩmaɣza kpaɣna pa-lɩmaɣza kɩbana yɔɔ.Pɩsɩ nɛ ŋna-ɩ tɔm kɩcɛyɩtʋ: ye wondu ndɩ ndɩ ɩwɛna ɖama yɔɔ mayaɣ kʋɖʋmaɣ yɔ, Pɩlɩʋ ŋgʋ kɩ-taa pamaɣna tɔm pee ana yɔ, kɩ-taa lɛ, pamaɣna-yɛ nɛ sɩ-hɩla.Maɣzɩ nɛ ŋna ɛzɩma papɩzɩɣ nɛ pama tɔm pee wena awɛ tɔm pee ndɩ ndɩ taa yɔ .# >>> order_by_points.call([1, 11, -1, -11, -12])
# [-1, -11, 1, -12, 11]
# >>> order_by_points.call([])
# []
def order_by_points(nums)
","def order_by_points(nums)
  nums.sort_by.with_index do |num, index|
    [num.to_s.chars.map(&:to_i).sum.abs, index]
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_order_by_points
    candidate = method(:order_by_points)
    assert_equal([-1, -11, 1, -12, 11], candidate.call([1, 11, -1, -11, -12]))
    assert_equal([0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))
    assert_equal([], candidate.call([]))
    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32, 43, 54, -98, 2, -3]))
    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))
    assert_equal([-76, -21, 0, 4, 23, 6, 6], candidate.call([0, 6, 6, -76, -21, 23, 4]))
  end
end
"
HumanEval_146,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Kajalaɣ nɛ kɛtɛzaɣ mayaɣ kɛna ɛyʊ kʊyʊm (1, 3, 5, 7, 9).Kɩ-tɛ lɛɣtʊ natʊyʊ taa lɛ, pɩcɛzɩ 10 nɛ pɩtasɩna naalɛ Maɣna se pamaɣna kɩ-tɛ matʋ nɛ kɩpɩsɩɣ-kʋ nɛ kɩ-tɛ matʋ.# >>> specialFilter.call([15, -73, 14, -15])
# 1
# >>> specialFilter.call([33, -2, -3, 45, 21, 109])
# 2
def specialFilter(nums)
","def specialFilter(nums)
  nums.count do |num|
    num > 10 && num.to_s[0].to_i.odd? && num.to_s[-1].to_i.odd?
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_specialFilter
    candidate = method(:specialFilter)
    assert_equal(0, candidate.call([5, -2, 1, -5]))
    assert_equal(1, candidate.call([15, -73, 14, -15]))
    assert_equal(2, candidate.call([33, -2, -3, 45, 21, 109]))
    assert_equal(4, candidate.call([43, -12, 93, 125, 121, 109]))
    assert_equal(3, candidate.call([71, -2, -33, 75, 21, 19]))
    assert_equal(0, candidate.call([1]))
    assert_equal(0, candidate.call([]))
  end
end
"
HumanEval_147,kbp_Latn,rb,"Kɩɖaʋ:nɛ a[i] + a[j] + a[k] kɛ 3 tam nabʊyʊ. Pɩsɩ nɛ ŋna-ɩ kɩlɛlʋʋ:Paa i (1 ≤ i ≤ n) lɛ, a[i] = i * i - i + 1 wɛna wazaɣ.Pʊtɔbʊʊ se ŋwɛna ɛyʊ kʊyʊmʊm n. Pɩwɛɛ se ŋñɔɔzɩ ɛyʊ kʊyʊmʊm a weyi ɛ-ɖaɣlɩkɩŋ talɩɣ ɛzɩ n yɔ.# >>> get_max_triples.call(5)
# 1
# Explanation: 
# a = [1, 3, 7, 13, 21]
# The only valid triple is (1, 7, 13).
def get_max_triples(n)
","def get_max_triples(n)
  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }
  count = 0
  
  (0...n).each do |i|
    (i+1...n).each do |j|
      (j+1...n).each do |k|
        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0
      end
    end
  end
  
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_max_triples
    candidate = method(:get_max_triples)
    assert_equal(1, candidate.call(5))
    assert_equal(4, candidate.call(6))
    assert_equal(36, candidate.call(10))
    assert_equal(53361, candidate.call(100))
  end
end
"
HumanEval_148,kbp_Latn,rb,"Kɩɖaŋ Pɩtɩkɛ tɛtʋ wandamm hɩla.Pɩwɛɛ se tʊmɩyɛ nɖɩ ɖɩpɩsɩ matriki kɩmɩŋ weyi ɛfɛyɩ yɔ yee pɩkɛ planet1 yaa planet2 yɔ.Pɩtɩkɛ wɩsɩ cɔlɔ pɩlɩnaa.Pɩkɛna tɛtʊ ndʊ tɩ-taa tɛtʊ cɔŋna nɛ tɩ-taa tɛtʊ cɔŋna nɛ tɩ-taa tɛtʊ cɔŋna nɛ tɩ-taa tɛtʊ cɔŋna nɛ tɩ-taa tɛtʊ cɔŋna.Pɩwɛɛ se tʊmɩyɛ nɖɩ ɖɩpɩsɩ ɛyʊ tɛ pʊtʊnaa mba pa-tɩŋa pa-tɛ pʊtʊnaa wɛna Ma tʋmɩyɛ nɖɩ ɖɩkpaɣ kpɩnɛ naalɛ hɩla ɛzɩ kpɩnɛ 1 nɛ kpɩnɛ 2 yɔ.Uranɩ nɛ Neptuni.Pɩtɛ lɛ, ɖɩnaɣ tɛtʋ, Maarɩsɩ, Jupitɛɛrɩ, Saturn, nɛ pɩtɛ lɛ, Vénus.Wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ, wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ, wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ, wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ, wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ, wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ, wɩsɩ cɔɔʊ taa wɛ kedeŋa kpeekpe yɔɔ lɛ.# >>> bf.call(""Jupiter"", ""Neptune"")
# [""Saturn"", ""Uranus""]
# >>> bf.call(""Earth"", ""Mercury"")
# ""Venus""
# >>> bf.call(""Mercury"", ""Uranus"")
# [""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""]
def bf(planet1, planet2)
","def bf(planet1, planet2)
  planets = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""]
  
  idx1 = planets.index(planet1)
  idx2 = planets.index(planet2)
  
  return [] if idx1.nil? || idx2.nil?

  start_idx, end_idx = [idx1, idx2].sort
  
  planets[(start_idx + 1)...end_idx]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_bf
    candidate = method(:bf)
    assert_equal([""Saturn"", ""Uranus""], candidate.call(""Jupiter"", ""Neptune""))
    assert_equal([""Venus""], candidate.call(""Earth"", ""Mercury""))
    assert_equal([""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""], candidate.call(""Mercury"", ""Uranus""))
    assert_equal([""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""], candidate.call(""Neptune"", ""Venus""))
    assert_equal([], candidate.call(""Earth"", ""Earth""))
    assert_equal([], candidate.call(""Mars"", ""Earth""))
    assert_equal([], candidate.call(""Jupiter"", ""Makemake""))
  end
end
"
HumanEval_149,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: Ŋpɩzɩɣ nɛ ŋmaɣzɩ se tɔm pee tɩŋa wɛna kɩmaŋ.Pɩwɛɛ se tʊmɩyɛ nɖɩ ɖɩpɩsɩ ɛyʊ yɔɔ tɔmpiye ndɩ ndɩ nɛ ɖɩ-tɛ paɣtʊ.Ye tɔm pee naalɛ ɩwɛna kɩmaŋ kʋɖʋmʋʋ yɔ, paɖʋʋ-yɛ alphabetiki taa.Pɩwɛɛ se ɛpɩsɩnɩ matriki ŋgʊ kɩ-tɛ paɣtʊ yɔɔ.Pɩwɛɛ se tɔm pee wena awɛ yɔ, a-ɖaɣlɩkɩŋ ɛpaɣlɩ, nɛ ŋpɩzɩɣ ŋmaɣzɩnɩ-yɛ.Pɩpɩzɩɣ nɛ pɩla se kɩ-taa tɔm kɩlɛlʋʋ wɛɛ.Ɛyʊ wɛʊ yɔ, pɩtɛ lɛ pɩkɛ ɛyʊ wɛʊ nɛ ɛfɛyɩna ɛyʊ nɛ ɛ-hɩɖɛ.nɛ pɩpɩsɩɣ ɛ-tɛ matriki nɛ ɛ-tɛ matriki kɩlɛlʋʋ, ɛtɛzɩɣ kɩ-taa tɔmpiye nɖɩ ɖɩ-tɛ kɩɖaɣlɩm fɛyɩ yɔ, Maʋ tʋmɩyɛ nɖɩ ɖɩmʋɣ tɔmpiye ndɩ ndɩ yɔ, # >>> list_sort.call([""aa"", ""a"", ""aaa""])
# [""aa""]
# >>> list_sort.call([""ab"", ""a"", ""aaa"", ""cd""])
# [""ab"", ""cd""]
def sorted_list_sum(lst)
","def list_sort(arr)
  arr.select { |s| s.length.even? }
     .sort_by { |s| [s.length, s] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sorted_list_sum
    candidate = method(:sorted_list_sum)
    assert_equal([""aa""], candidate.call([""aa"", ""a"", ""aaa""]))
    assert_equal([""AI"", ""asdf"", ""school""], candidate.call([""school"", ""AI"", ""asdf"", ""b""]))
    assert_equal([], candidate.call([""d"", ""b"", ""c"", ""a""]))
    assert_equal([""abcd"", ""dcba""], candidate.call([""d"", ""dcba"", ""abcd"", ""a""]))
    assert_equal([""AI"", ""ai"", ""au""], candidate.call([""AI"", ""ai"", ""au""]))
    assert_equal([], candidate.call([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]))
    assert_equal([""cc"", ""dd"", ""aaaa"", ""bbbb""], candidate.call([""aaaa"", ""bbbb"", ""dd"", ""cc""]))
  end
end
"
HumanEval_150,kbp_Latn,rb,"Kɩɖaŋ: Pɩwɛɛ se ɛpɩzɩ nɛ ɛlɩzɩ y tɛ mayaɣ ŋga ka-taa ɛyʊ wɛɛ yɔ.Pɩkɛna kɩlɛmʋʋ kɩlɛmʋʋ kɩlɛmʋʋ ŋgʋ kɩ-taa papɩzɩɣ nɛ patɩlɩ x yee n ɛ-tɛ lɛlʊ kɔyɔ.# >>> x_or_y.call(7, 34, 12)
# 34
# >>> x_or_y.call(15, 8, 5)
# 5
def x_or_y(n, x, y)
","def x_or_y(n, x, y)
  require 'prime'
  n.prime? ? x : y
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_x_or_y
    candidate = method(:x_or_y)
    assert_equal(34, candidate.call(7, 34, 12))
    assert_equal(5, candidate.call(15, 8, 5))
    assert_equal(33, candidate.call(3, 33, 5212))
    assert_equal(3, candidate.call(1259, 3, 52))
    assert_equal(-1, candidate.call(7919, -1, 12))
    assert_equal(583, candidate.call(3609, 1245, 583))
    assert_equal(129, candidate.call(91, 56, 129))
    assert_equal(1234, candidate.call(6, 34, 1234))
    assert_equal(0, candidate.call(1, 2, 0))
    assert_equal(2, candidate.call(2, 2, 0))
  end
end
"
HumanEval_151,kbp_Latn,rb,"Ɖɩcɔna kɔyɔ, ɖɩnaɣ se, yee mayaɣ ŋga kɛfɛyɩ ññɩɩ kɔyɔ, ɖɩnaɣ se mayaɣ ŋga kɛfɛyɩ ññɩɩ.Ye ŋha-ɖʋ nimbrɩ waa sakɩyɛ yɔ, ɖɩpɩsɩɣ-ŋ nimbrɩ waa mba pa-naalɛ pa-kɩɖaʋ taa yɔ, pa-tɩŋa pa-ñɩm.# >>> double_the_difference.call([1, 3, 2, 0])
# 10
# >>> double_the_difference.call([-1, -2, 0])
# 0
# >>> double_the_difference.call([9, -2])
# 81
# >>> double_the_difference.call([0])
# 0
# If the input array is empty, return 0.
def double_the_difference(lst)
","def double_the_difference(lst)
  lst.select { |n| n.is_a?(Integer) && n.odd? && n >= 0 }
     .map { |n| n ** 2 }
     .sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_double_the_difference
    candidate = method(:double_the_difference)
    assert_equal(0, candidate.call([]))
    assert_equal(25, candidate.call([5.0, 4.0]))
    assert_equal(0, candidate.call([0.1, 0.2, 0.3]))
    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))
    assert_equal(0, candidate.call([-1.0, -2.0, 8.0]))
    assert_equal(34, candidate.call([0.2, 3.0, 5.0]))
    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]))
  end
end
"
HumanEval_152,kbp_Latn,rb,"Kɩɖaʋ: Pɩtɛ lɛ, kɩ-tɛ wɛtʊ lɛɣzʊʊ lɛɣzʊʊ nɛ kɩ-tɛ wɛtʊ lɛɣzʊʊ lɛɣzʊʊ.Pɩpɩsɩɣ matriki ŋgʋ kɩwɛna kɩ-ɖaɣlɩkɩŋ kʋɖʋmʋʋ yɔ nɛ kɩwɩlɩɣ ɛzɩma paa tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-taa tɔmpiye nɖɩ ɖɩ-tɔmpiye nɖɩ ɖɩ-tɔmpiye nɖɩ ɖɩ-tɔmpiye nɖɩ ɖɩ-tɔmpiye nɖɩ ɖɩ-tɔmpiye nɖɩ ɖɩ-tɔmpiye nɖɩ ɖɩ-tɔmpiye nɖɩ ɖɩ-tɔmpiye nɖɩ ɖɩ-yɔɔ.Pʊtɔbʊʊ se ŋwɛna ñʊʊ naalɛ nɛ pa-taa lɛ, paa weyi ɛ-ñʊʊ mayaɣ nɛ ɛ-tɛ tɔm.Pɩwɛɛ se ŋtɩlɩ se ɛyʋ nɔɔyʋ maɣzaɣ se ɛ-tɔm kɛ toovenim.Pɩwɛɣ ɖeu se ɖɩmaɣzɩ nɛ ɖɩna.Pɩtasɩ lɛ, ye ŋcaɣ se ŋtɩlɩ mbʋ pɩ-taa ŋwɛɛ yɔ, ŋpɩzɩɣ nɛ ŋmaɣzɩ mbʋ pɩ-taa ŋwɛɛ yɔ pɩ-yɔɔ.Maɣzɩ se ɖa-tɩŋa ɖɩtɔzʋʋ ɛzɩma pɩlakaɣ ɛyʋ alɩwaatʋ ndʋ ɛ-taa lakɩ leleŋ nɛ ɛ-kɩcɛyɩm yɔ pɩ-yɔɔ.# >>> compare.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])
# [0, 0, 0, 0, 3, 3]
# >>> compare.call([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])
# [4, 4, 1, 0, 0, 6]
def compare(game, guess)
","def compare(game, guess)
  game.zip(guess).map { |score, prediction| (score - prediction).abs }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_compare
    candidate = method(:compare)
    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))
    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))
    assert_equal([2, 4, 6], candidate.call([1, 2, 3], [-1, -2, -3]))
    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3, 5], [-1, 2, 3, 4]))
  end
end
"
HumanEval_153,kbp_Latn,rb,"Kɩɖaʋ: (Ɛ-tɛ ɖoŋ wɛ -1).return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension Pɩtɛ lɛ, ŋpɩzɩɣ nɛ ŋpɔzɩ-ɩ se:Ɖɩkpaɣ ɛzɩ, ye paha-ɖʋ ""Slices"" ɛzɩ class nɛ array yɔ yɔ, Lɩzɩ mbʋ pɩlɩɣ kajalaɣ lone taa yɔ.Ye ŋwɛnɩ kɩɖaɣlʋʋ naalɛ yaa kɩɖaɣlʋʋ sakɩyɛ nɛ ɩwɛ ɖoŋ kʋɖʋmʋʋ yɔ, pɩwɛɛ se ŋñɔɔzɩ- ɩ nɛ ŋlabɩnɩ tʋmɩyɛ.Pɩsɩ takayɩhayʋʋ: ClassName.StrongestExtensionName ñɩŋgʋ yɔɔ. Pɩwɛɛ se ŋñɩnɩ kɩwalʊʊ ŋgʊ kɩkɩlɩ ɖoŋ yɔ nɛ ŋpɩsɩ ɛ-tɛ tɔmpiye naɖɩyɛ.Pɩtɛ lɛ, pɛtɛzɩɣ-ɩ yaʋ se CAP - SM.Takayɩhatʋ ndʋ tɩtamsɩna \\ Ɛntɛrnɛtɩ \\ yɔPɩtɛ ɖoŋ tɔmpiye nɖɩ ɖɩ-taa lɛ: CAP kɛna mayaɣ sɔsɔɣa ŋga pama-kɛ yɔ.Pɩtɛ kɩwalʊʊ ŋgʊ kɩ-taa papɩzɩɣ patasɩ kpaɣʊ takayasɩ lɛɛsɩ.Pʊtɔbʊʊ se ŋwɛna ŋgbɛyɛ naɖɩyɛ nɛ ɖɩ-hɩɖɛ nɛ ɖɩ-tɛ kɩwalʊʊ.# >>> Strongest_Extension.call(""my_class"", [""AA"", ""Be"", ""CC""])
# ""my_class.AA""
def Strongest_Extension(class_name, extensions)
","def Strongest_Extension(class_name, extensions)
  strongest_extension = extensions.max_by do |extension|
    cap_count = extension.count('A-Z')
    sm_count = extension.count('a-z')
    cap_count - sm_count
  end
  ""#{class_name}.#{strongest_extension}""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_Strongest_Extension
    candidate = method(:Strongest_Extension)
    assert_equal(""Watashi.eIGHt8OKe"", candidate.call(""Watashi"", [""tEN"", ""niNE"", ""eIGHt8OKe""]))
    assert_equal(""Boku123.YEs.WeCaNe"", candidate.call(""Boku123"", [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]))
    assert_equal(""__YESIMHERE.NuLl__"", candidate.call(""__YESIMHERE"", [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]))
    assert_equal(""K.TAR"", candidate.call(""K"", [""Ta"", ""TAR"", ""t234An"", ""cosSo""]))
    assert_equal(""__HAHA.123"", candidate.call(""__HAHA"", [""Tab"", ""123"", ""781345"", ""-_-""]))
    assert_equal(""YameRore.okIWILL123"", candidate.call(""YameRore"", [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]))
    assert_equal(""finNNalLLly.WoW"", candidate.call(""finNNalLLly"", [""Die"", ""NowW"", ""Wow"", ""WoW""]))
    assert_equal(""_.Bb"", candidate.call(""_"", [""Bb"", ""91245""]))
    assert_equal(""Sp.671235"", candidate.call(""Sp"", [""671235"", ""Bb""]))
  end
end
"
HumanEval_154,kbp_Latn,rb,"Ŋwɛna tɔm naalɛ nɛ pɩwɛɛ se ŋpɩsɩ tɔm ndʋ tɩkɛ toovenim yɔ, ye tɔm naalɛ ñɩndʋ yaa tɩ-tɛ lɛɛtʋ tɩkɛ kajalaɣ tɔm piye taa tɔm piye cikpeɖe yɔ.# >>> cycpattern_check.call(""abcd"", ""abd"")
# false
# >>> cycpattern_check.call(""hello"", ""ell"")
# true
# >>> cycpattern_check.call(""whassup"", ""psus"")
# false
# >>> cycpattern_check.call(""abab"", ""baa"")
# true
# >>> cycpattern_check.call(""efef"", ""eeff"")
# false
# >>> cycpattern_check.call(""himenss"", ""simen"")
# true
def cycpattern_check(a, b)
","def cycpattern_check(a, b)
  (0...b.length).each do |i|
    rotated_b = b[i..-1] + b[0...i]
    return true if a.include?(rotated_b)
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_cycpattern_check
    candidate = method(:cycpattern_check)
    assert_equal(false, candidate.call(""xyzw"", ""xyw""))
    assert_equal(true, candidate.call(""yello"", ""ell""))
    assert_equal(false, candidate.call(""whattup"", ""ptut""))
    assert_equal(true, candidate.call(""efef"", ""fee""))
    assert_equal(false, candidate.call(""abab"", ""aabb""))
    assert_equal(true, candidate.call(""winemtt"", ""tinem""))
  end
end
"
HumanEval_155,kbp_Latn,rb,"Kɩɖaʋ: Ye ɖɩha-ɩ nimero waa tɩŋa yɔ, ɛpɩsʋʋna matrice nɖɩ ɖɩ-taa nimero waa mba pɛwɛ paa nɛ mba pɛfɛyɩ paa nɛ pa-taa yɔ.# >>> even_odd_count.call(-12)
# [1, 1]
# >>> even_odd_count.call(123)
# [1, 2]
def even_odd_count(num)
","def even_odd_count(num)
  num.to_s.chars.map(&:to_i).select { |digit| digit != 0 }.partition(&:even?).map(&:count)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_even_odd_count
    candidate = method(:even_odd_count)
    assert_equal([0, 1], candidate.call(7))
    assert_equal([1, 1], candidate.call(-78))
    assert_equal([2, 2], candidate.call(3452))
    assert_equal([3, 3], candidate.call(346211))
    assert_equal([3, 3], candidate.call(-345821))
    assert_equal([1, 0], candidate.call(-2))
    assert_equal([2, 3], candidate.call(-45347))
    assert_equal([1, 0], candidate.call(0))
  end
end
"
HumanEval_156,kbp_Latn,rb,"Kɩɖaŋ: Pɩtɛ kɩlɛmɩŋ: 1 <= num <= 1000 Nɛ ŋyele nɛ pama-kʋ nɛ tɔm pee cikpeŋ.Ye paha-ɖʋ kɩmaŋ mayaɣ kɔyɔ, ɖɩkpaɣ kɩmaŋ mayaɣ ŋga nɛ ɖɩkpaɣ Roma n̄ɩnzɩ taa yɔ nɛ ɖɩlɩzɩ-kɛ nɛ ɖɩlabɩnɩ tʋmɩyɛ.# >>> int_to_mini_roman.call(19)
# ""xix""
# >>> int_to_mini_roman.call(152)
# ""clii""
# >>> int_to_mini_roman.call(426)
# ""cdxxvi""
def int_to_mini_roman(number)
","def int_to_mini_roman(number)
  values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
  numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']

  result = ''
  values.each_with_index do |value, index|
    while number >= value
      number -= value
      result += numerals[index]
    end
  end

  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_int_to_mini_roman
    candidate = method(:int_to_mini_roman)
    assert_equal(""xix"", candidate.call(19))
    assert_equal(""clii"", candidate.call(152))
    assert_equal(""ccli"", candidate.call(251))
    assert_equal(""cdxxvi"", candidate.call(426))
    assert_equal(""d"", candidate.call(500))
    assert_equal(""i"", candidate.call(1))
    assert_equal(""iv"", candidate.call(4))
    assert_equal(""xliii"", candidate.call(43))
    assert_equal(""xc"", candidate.call(90))
    assert_equal(""xciv"", candidate.call(94))
    assert_equal(""dxxxii"", candidate.call(532))
    assert_equal(""cm"", candidate.call(900))
    assert_equal(""cmxciv"", candidate.call(994))
    assert_equal(""m"", candidate.call(1000))
  end
end
"
HumanEval_157,kbp_Latn,rb,"Kɩɖaʋ: Pɩcɛzɩ ɛzɩ 90 mbʋ yɔ.Hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, kɩ-taa lɛ, hɔɔlʊʊ ŋgʊ kɩ-taa lɛ, kɩ-taa lɛ, kɩ-taa lɛ, kɩ-taa lɛ, kɩ-taa lɛ, kɩ-taa lɛ.Pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ, pɩtɛ lɛ.Ye ɖɩkpaɣ tɔmpiye nɖɩ ɖɩ-tɛ hɔɔlɩŋ naadozo yɔ, ɖɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-tɛ toovenim tɔm kɔyɔ, tɔmpiye nɖɩ ɖɩ-tɛ hɔɔlɩŋ naadozo yɔ, ɖɩpɩsɩɣ tɔmpiye nɖɩ ɖɩ-tɛ toovenim tɔm yɔ.# >>> right_angle_triangle.call(3, 4, 5)
# true
# >>> right_angle_triangle.call(1, 2, 3)
# false
def right_angle_triangle(a, b, c)
","def right_angle_triangle(a, b, c)
  sides = [a, b, c].sort
  sides[0]**2 + sides[1]**2 == sides[2]**2
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_right_angle_triangle
    candidate = method(:right_angle_triangle)
    assert_equal(true, candidate.call(3, 4, 5))
    assert_equal(false, candidate.call(1, 2, 3))
    assert_equal(true, candidate.call(10, 6, 8))
    assert_equal(false, candidate.call(2, 2, 2))
    assert_equal(true, candidate.call(7, 24, 25))
    assert_equal(false, candidate.call(10, 5, 7))
    assert_equal(true, candidate.call(5, 12, 13))
    assert_equal(true, candidate.call(15, 8, 17))
    assert_equal(true, candidate.call(48, 55, 73))
    assert_equal(false, candidate.call(1, 1, 1))
    assert_equal(false, candidate.call(2, 2, 10))
  end
end
"
HumanEval_158,kbp_Latn,rb,"Takayɩhatʋ ndʋ tɩtamsɩna \\ Takayɩhatʋ ndʋ tɩtɩkɛ takayaɣ nakɛyɛ yɔ \\ yɔYee tɔm pee kɩkpɛdɩŋ ɛɖɔwa kɔyɔ, tɔm pee kɩkpɛdɩŋ sakɩyɛ wɛna.Tɔmpiye nɖɩ ɖɩ-taa tɔm pee ndɩ ndɩ wɛɛ yɔ, ɖɩpɩsɩɣ tɔm pee wena a-taa tɔm pee kɩlɩna ɖɔʋ yɔ.Ma tʋmɩyɛ nɖɩ ɖɩmʋna yɔ, ɖɩ-taa tɔmpiye ndɩ ndɩ.# >>> find_max.call([""name"", ""of"", ""string""])
# ""string""
# >>> find_max.call([""name"", ""enam"", ""game""])
# ""enam""
# >>> find_max.call([""aaaaaaa"", ""bb"", ""cc""])
# ""aaaaaaa""
def find_max(words)
","def find_max(words)
  # Helper function to count unique characters
  def unique_char_count(word)
    word.chars.uniq.size
  end

  words.max_by { |word| [unique_char_count(word), -word] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_find_max
    candidate = method(:find_max)
    assert_equal(""string"", candidate.call([""name"", ""of"", ""string""]))
    assert_equal(""enam"", candidate.call([""name"", ""enam"", ""game""]))
    assert_equal(""aaaaaaa"", candidate.call([""aaaaaaa"", ""bb"", ""cc""]))
    assert_equal(""abc"", candidate.call([""abc"", ""cba""]))
    assert_equal(""footbott"", candidate.call([""play"", ""this"", ""game"", ""of"", ""footbott""]))
    assert_equal(""gonna"", candidate.call([""we"", ""are"", ""gonna"", ""rock""]))
    assert_equal(""nation"", candidate.call([""we"", ""are"", ""a"", ""mad"", ""nation""]))
    assert_equal(""this"", candidate.call([""this"", ""is"", ""a"", ""prrk""]))
    assert_equal(""b"", candidate.call([""b""]))
    assert_equal(""play"", candidate.call([""play"", ""play"", ""play""]))
  end
end
"
HumanEval_159,kbp_Latn,rb,"Kɩɖaʋ: Ye ŋfɛyɩnɩ kaarooti sakɩyɛ yɔ, ŋkaɣ tɔɔʋ kaarooti tɩŋa, ɛlɛ ñɔɔsɩ kaɣ-ŋ kpaʋ.[Yele nɛ paɖʋ video ŋgʋ kɩ-tɛɛ tɔm pɔzʋʋ.]Pɩwɛɛ se ŋpɩsɩ [ tɔɔnasɩ nzɩ ŋtɔɔ yɔ sɩ-kpɩtɩŋ tɩŋa, Ɛlɛ lɛɛlɛɛyɔ lɛ, pɩwɛɛ se ŋtɔɔ karɩbɔɔnɩ nɛ pɩsa nɛ ŋtɛ ña-kɩyakʋ taa tɔɔnaɣ.Ŋkɛ kpɩnɛ nɖɩ ɖɩwɛnɩ ñɔɔsɩ yɔ, nɛ ŋtɛm tɔɔʋ kaarooti sakɩyɛ.# >>> eat.call(5, 6, 10)
# [11, 4]
# >>> eat.call(4, 8, 9)
# [12, 1]
# >>> eat.call(1, 10, 10)
# [11, 0]
# >>> eat.call(2, 11, 5)
# [7, 0]
# Variables:
# @number : integer
# the number of carrots that you have eaten.
# @need : integer
# the number of carrots that you need to eat.
# @remaining : integer
# the number of remaining carrots thet exist in stock
# Constrain:
# * 0 <= number <= 1000
# * 0 <= need <= 1000
# * 0 <= remaining <= 1000
# Have fun :)
def eat(number, need, remaining)
","def eat(number, need, remaining)
  total_eaten = number + [need, remaining].min
  carrots_left = [remaining - need, 0].max
  [total_eaten, carrots_left]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_eat
    candidate = method(:eat)
    assert_equal([11, 4], candidate.call(5, 6, 10))
    assert_equal([12, 1], candidate.call(4, 8, 9))
    assert_equal([11, 0], candidate.call(1, 10, 10))
    assert_equal([7, 0], candidate.call(2, 11, 5))
    assert_equal([9, 2], candidate.call(4, 5, 7))
    assert_equal([5, 0], candidate.call(4, 5, 1))
  end
end
"
HumanEval_160,kbp_Latn,rb,"Tʊmɩyɛ laɖʊ wɛna tʊmɩyɛ laɖʊ kʋɖʋm, nɛ tʊmɩyɛ laɖʊ wɛna tʊmɩyɛ laɖʊ naalɛ.Ɛ-tɛ operandɩ kɛna nimero waa kɩmaŋ weyi ɛfɛyɩ kɩmaŋ yɔ.Tʊma wena palakɩna tʊma sɔsɔna yɔ, a-ɖaɣlɩkɩŋ wɛ ɛzɩ tʊma wena palakɩna tʊma sɔsɔna yɔ, a-ɖaɣlɩkɩŋ lɛɛkʋ.Pɩsɩ nɛ ŋna-ɩ tɔm kɩkpɛlɩkɩtʋ:=> Kɩ-tɛ lɩmaɣzɩyɛ = 9 Pɩwɩlɩɣ se 2 + 3 * 4 - 5 .Ɛ-tɛ matʊ wɛ ɛzɩ [2, 3, 4, 5] yɔ.ɛyʊ weyi ɛ-tɛ tɔm wɛ ndɩ yɔ['+', '*', '-'] Kɩɖaʋ: Kpɛlɩ kpɛlɛkʋʋ (**) Tɛtʊ tʊma ( //) Kɩwalʋʋ (*) Kpaɣtʋ ( - ) Pɩtɛ (+) Algebra taa tʋma kɩbana: Ɛ-tɔm pee nɛ ɛɖaɣnɩ pɩsʋʋ tɔm pee ana a-tɔm pee.Ɛ-tɛ alɩbɛɛrɩ tɔmpiye nɖɩ ɖɩ-taa lɛ, ɖɩ-taa lɛ, ɛ-tɛ alɩbɛɛrɩ tɔmpiye nɖɩ ɖɩ-taa lɛ, ɛ-tɛ alɩbɛɛrɩ tɔmpiye nɖɩ ɖɩ-taa lɛ, ɛ-tɛ alɩbɛɛrɩ tɔmpiye nɖɩ ɖɩ-taa lɛ, ɛ-tɛ alɩbɛɛrɩ tɔmpiye nɖɩ ɖɩ-taa lɛ, ɛ-tɛ alɩbɛɛrɩ tɔmpiye nɖɩ ɖɩ-taa lɛ, ɛ-tɛ alɩbɛɛrɩ tɔmpiye nɖɩ ɖɩ-taa lɛ, ɛ-tɛ alɩbɛɛrɩ tɔmpiye nɖɩ ɖɩ-taa lɛ, ɛ-tɛ alɩbɛɛrɩ tɔmpiye nɖɩ ɖɩ-taa lɛ, ɛ-tɛ alɩbɛɛrɩ tɔmpiye nɖɩ ɖɩ-taa.Ɖɩkpaɣ ɛzɩ matrice waa naalɛ yɔ, kajalaɣ matrice taa lɛ, algebra tʋmɩyɛ wɛna, nɛ def do_algebra(operator, operand)
","def do_algebra(operator, operand)
  expression = operand[0].to_s
  operator.each_with_index do |op, index|
    if op == '//'
      expression += ' / ' + operand[index + 1].to_s
    else
      expression += ' ' + op + ' ' + operand[index + 1].to_s
    end
  end
  eval(expression)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_do_algebra
    candidate = method(:do_algebra)
    assert_equal(37, candidate.call([""**"", ""*"", ""+""], [2, 3, 4, 5]))
    assert_equal(9, candidate.call([""+"", ""*"", ""-""], [2, 3, 4, 5]))
    assert_equal(8, candidate.call([""//"", ""*""], [7, 3, 4]))
  end
end
"
HumanEval_161,kbp_Latn,rb,"Kɩɖaŋ Pɩwɛɛ se tʋmɩyɛ nɖɩ ɖɩpɩsɩɣ tɔm pee wena awɛ pɩ-taa yɔ.Ye tɔmpiye nɖɩ ɖɩfɛyɩna masɩ nasɩyɛ kɔyɔ, pɛlɛɣzɩ-ɖɩ nɛ ɖɩpɩsɩ.Ye pɩtɛkɛ mbʋ yɔ, yele-kʋ nɛ kɩwɛɛ mbʋ.Yee s[i] ɛkɛ mayaɣ kɔyɔ, ɛ-tɛ tɔmpiye ɛlɩɣna pɩ-tɛɛ nɛ pɩkɔɔ pɩtalɩ pɩ-yɔɔ yaa pɩ-tɛɛ nɛ pɩ-yɔɔ.Pʊtɔbʊʊ se ŋwɛna ñʊʊ mayaɣ kʊyʊmʊ.# >>> solve.call(""1234"")
# ""4321""
# >>> solve.call(""ab"")
# ""AB""
# >>> solve.call(""#a@C"")
# ""#A@c""
def solve(s)
","def solve(s)
  if s =~ /[a-zA-Z]/
    s.chars.map { |char| char =~ /[a-zA-Z]/ ? char.swapcase : char }.join
  else
    s.reverse
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solve
    candidate = method(:solve)
    assert_equal(""aSdF"", candidate.call(""AsDf""))
    assert_equal(""4321"", candidate.call(""1234""))
    assert_equal(""AB"", candidate.call(""ab""))
    assert_equal(""#A@c"", candidate.call(""#a@C""))
    assert_equal(""#aSDFw^45"", candidate.call(""#AsdfW^45""))
    assert_equal(""2@6#"", candidate.call(""#6@2""))
    assert_equal(""#$A^d"", candidate.call(""#$a^D""))
    assert_equal(""#CCC"", candidate.call(""#ccc""))
  end
end
"
HumanEval_162,kbp_Latn,rb,"Yee 'text' pɩkɛ matʋ kɩmamatʋ natʋyʋ yɔ, pɩpɩsɩɣ nil.Ye ŋha-ɩ tɔmpiye 'text' kɔyɔ, ŋpɩsɩɣ-ɖɩ nɛ md5 tɔmpiye nɖɩ ɖɩ-tɛ tɔmpiye.# >>> string_to_md5.call(""Hello world"")
# ""3e25960a79dbc69b674cd4ec67a72c62""
def string_to_md5(text)
","require 'digest'

def string_to_md5(text)
  return nil if text.empty?
  Digest::MD5.hexdigest(text)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_to_md5
    candidate = method(:string_to_md5)
    assert_equal(""3e25960a79dbc69b674cd4ec67a72c62"", candidate.call(""Hello world""))
    assert_equal(nil, candidate.call(""""))
    assert_equal(""0ef78513b0cb8cef12743f5aeb35f888"", candidate.call(""A B C""))
    assert_equal(""5f4dcc3b5aa765d61d8327deb882cf99"", candidate.call(""password""))
  end
end
"
HumanEval_163,kbp_Latn,rb,"Kɩɖaʋ nakʋyʋ yɔ: nɛ b, pɩlɩɣna ɛzɩma pɩpaɣlɩɣ yɔ.Ye ŋha-ɖʋ ɛtɛyɩŋ naalɛ a nɛ b, ɖitiyele nɛ ɖɩna hɔɔlɩŋ weyi ɩ-taa a nɛ b pɛtɛyɩɣ ɖama yɔ.# >>> generate_integers.call(2, 8)
# [2, 4, 6, 8]
# >>> generate_integers.call(8, 2)
# [2, 4, 6, 8]
# >>> generate_integers.call(10, 14)
# []
def generate_integers(a, b)
","def generate_integers(a, b)
  (a..b).to_a.concat((b..a).to_a).select { |num| num.even? }.uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_generate_integers
    candidate = method(:generate_integers)
    assert_equal([2, 4, 6, 8], candidate.call(2, 10))
    assert_equal([2, 4, 6, 8], candidate.call(10, 2))
    assert_equal([2, 4, 6, 8], candidate.call(132, 2))
    assert_equal([], candidate.call(17, 89))
  end
end
"
