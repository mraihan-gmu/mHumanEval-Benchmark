task_id,nl,pl,prompt,canonical_solutions,test
HumanEval/0,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// چیک کرِو اگر دِنہٕ آمتین نمبرن ہند ویکٹر منز، کنٛہہ تہٕ دۄن نمبرن ہند اکھ ایکِس بییس سٕتۍ دِنہٕ آمٕتۍ حد کھوتہٕ زیادٕہ قریب چِھ ۔ >>> has_close_elements{""{""{""{""{""{""{""{""{""{""{""{""{""{""{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}{""}}{""}{""}}{""}{""}}{""}{""}{""}}{""}}{""}}{""}{""}}{""}}{""}}{""}{""}}}{""}}}{""}}{""}}{""}}}{""}}}{""}}}{""}}{""}}}{""}}""}""}""}""}""}""}""}""}""}""{""}""}""}""}""}""{""}""}""}""}""}""}""{""}""}""}""}""}""{""}""}""}""}""}""}""{""}""}""}""}""{""}""}""}""}""}""{""}""}""}""}""{""}""}""}""}""}""{""}""}""}""{""}""}""}""}""}""}""{""}""}""}""{""}""}""}""}""}""{""}""}""
bool has_close_elements(std::vector<float> numbers, float threshold) {
","bool has_close_elements(std::vector<float> numbers, float threshold) {
    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order
    for (size_t i = 1; i < numbers.size(); i++) {
        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = has_close_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));
}
"
HumanEval/1,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// یہٕ فنکشن چُھ اکھ سٹرنگ ان پٹ ییتھ منٛز نیسٹڈ پیرنٹسس ہنٛد متعدد گروپ چِھ آسان۔ توہیہٕ چِھ یمن گروپن الگ الگ سٹرنگن منٛز الگ کرنہٕ تہٕ یمن ہیند ویکٹر واپس کرن۔ الگ الگ گروپ چِھ متوازن (ہر کھلہٕ بریکٹ چُھ صحیح پأٹھۍ بند) تہٕ اکھ اکس منٛز چِھ نہٕ نیسٹڈ ان پٹ سٹرنگس منٛز کنہہ خلا نظر انداز کران۔ >>> separate_paren_groups(""( ) (() (( ) ))))) (std::vector<std::string>({(std::string) "")"", ((((())"", (std::string) ""((()))))
std::vector<std::string> separate_paren_groups(std::string paren_string) {
","std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> groups;
    std::string current_group;
    int balance = 0;

    for (char ch : paren_string) {
        if (ch == ' ') continue;  // Ignore spaces

        current_group += ch;
        if (ch == '(') {
            balance++;
        } else if (ch == ')') {
            balance--;
            if (balance == 0) {  // Found a balanced group
                groups.push_back(current_group);
                current_group.clear();
            }
        }
    }

    return groups;
}","}
int main() {
    auto candidate = separate_paren_groups;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<std::string>({(std::string)""(()())"", (std::string)""((()))"", (std::string)""()"", (std::string)""((())()())""})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""((()))"", (std::string)""(((())))""})));
    assert(candidate((""(()(())((())))"")) == (std::vector<std::string>({(std::string)""(()(())((())))""})));
    assert(candidate((""( ) (( )) (( )( ))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""(()())""})));
}
"
HumanEval/2,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// مثبت فلوٹنگ پوائنٹ نمبر دنہٕ آمت، یہ ہیکو انٹیجر حصہٕ (بڑین نمبرن ہندسہٕ کھوتہٕ لوکٹ) تہٕ اعشاریہ (باقی حصہٕ ہمیشہ 1 کھوتہٕ لوکٹ) منٛز تقسیم کٔرتھ۔ نمبر کس اعشاریہ کس حصس واپس ییہٕ دنہٕ۔ >>> truncate_number((3.5f)) (0.5f)
float truncate_number(float number) {
","float truncate_number(float number) {
    return number - std::floor(number);
}","}
int main() {
    auto candidate = truncate_number;
    assert(candidate((3.5f)) == (0.5f));
    assert(candidate((1.25f)) == (0.25f));
    assert(candidate((123.0f)) == (0.0f));
}
"
HumanEval/3,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چھِ بینک اکاونٹس پیٹھ جمع تہٕ واپسی ہنز کارروائیہٕ ہند اکھ ویکٹر دِنہٕ آمُت یوس صفرٕ کھوتہٕ ہیو شروع گژھان۔ توہیہٕ سُند کٲم چھُ یہٕ پتہ لگاون کہ اگر کنہٕ وقتہٕ کھاتہٕ ہند بیلنس صفرٕ کھوتہٕ کم چُھ گژھان تہٕ اتھ وقتس پیٹھ گژھہٕ فنکشن درست واپس گژھُن۔ بصورت دیگر یہٕ گژھہٕ غلط واپس گژھُن۔ >>> below_zero((std::vector<long>({long) 1، (long) 2، (long) 3}))) (false) >>> below_zero(std::vector<long>({long) 1، (long) 2، (long) 4، (long) 5}))) (true)
bool below_zero(std::vector<long> operations) {
","bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for (long op : operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = below_zero;
    assert(candidate((std::vector<long>())) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));
}
"
HumanEval/4,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ان پٹ نمبرن ہندِس اکس ویکٹرٕ خٲطرٕہ، ایم ڈی اے ڈی ایس ڈی ایم چُھ ڈیٹاسیٹ کہِ اوسط کہِ ارد گرد اوسطُک حساب لگاونہٕ یوان۔ ایم ڈی اے ڈی چُھ ہر عنصر تہٕ مرکز کہِ نقطہ کہِ درمیان اوسط مطلق فرق (یمہِ صورتہِ منز اوسط): ایم اے ڈی = اوسط ۔ ایکس - ایکس_میئن ۔ >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) (1.0f)
float mean_absolute_deviation(std::vector<float> numbers) {
","float mean_absolute_deviation(std::vector<float> numbers) {
    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();
    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, 
                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) 
                / numbers.size();
    return mad;
}","}
int main() {
    auto candidate = mean_absolute_deviation;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));
}
"
HumanEval/5,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ان پٹ ویکٹر کہ ہر دو مسلسل عناصرن درمیان چُھ اکھ نمبر 'ڈیلی میٹر' داخل یوان کرنہٕ۔ `numbers' >>> intersperse{}{}{}{}{}}{}}{}}{}{}{}{}}{}{}{}{}{}{}{}}{}{}{}{}}{}{}}{}{}}{}{}{}}{}{}}{}{}{}{}{}{}{}{}{}}{}{}}{}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}{}}{}}{}{}{}}{}{}}{}}{}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}}{}}}{}}{}}{}}}{}}}{}}}{}}}{}}}{}}}{}}}}{}}}{}}}}{}}}{}}}}{}}}}{}}}}}{}}}{}}}}{}}}}}{}}}}{}}}}}{}}}}}}{}}}}}}{}}}}}{}}}}}{}}}}}}{}}}}}}{}}}}{}}}}}}}}{}}}}}{}}}}}}}{}}}}}}}}}}{}}}}}}}}}{}}}}}}}{}}}}}}}}{}}}}}}}}}{}}}}}}}}{}}}}}}}}{}}}}}}}}}}}{}}}}}}}}}}{}}}}}}}}}}}}}{}}}}}}}}}}}{}}}}
std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
","std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    if (numbers.empty()) return numbers;

    std::vector<long> result;
    for (size_t i = 0; i < numbers.size(); i++) {
        result.push_back(numbers[i]);
        if (i < numbers.size() - 1) {
            result.push_back(delimeter);
        }
    }
    return result;
}","}
int main() {
    auto candidate = intersperse;
    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));
    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));
}
"
HumanEval/6,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// یہٕ فنکشن چُھ اکھ سٹرنگ یس نیسٹڈ پیرنٹس خٲطرٕ چِھ واریاہ گروپن ہنز نمائندگی کران یُس اسپیسس سۭتۍ الگ چُھ گژھان۔ گروپ کس ہر اکہٕ خٲطرٕ، پیرنٹسچ نیسٹنگچ گہری سطح چُھ آؤٹ پٹ کران۔ مثلن (())) چِھ زیادہ کھوتہٕ زیادٕ دوٛن نیسٹنگ لیولن ہنز ضرورت ییلہٕ زن ((())) چِھ تریہ۔ >>> parse_nested_parens((""((()) ((())) () ((()))))))) (std::vector<long>({(long) 2، (long) 3، (long) 1، (long) 3}))
std::vector<long> parse_nested_parens(std::string paren_string) {
","std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> depths;
    long current_depth = 0, max_depth = 0;

    for (char ch : paren_string) {
        if (ch == ' ') {
            if (max_depth > 0) {
                depths.push_back(max_depth);
                max_depth = 0;
            }
            current_depth = 0;
        } else if (ch == '(') {
            current_depth++;
            max_depth = std::max(max_depth, current_depth);
        } else if (ch == ')') {
            current_depth--;
        }
    }

    if (max_depth > 0) {
        depths.push_back(max_depth);
    }

    return depths;
}","}
int main() {
    auto candidate = parse_nested_parens;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((""(()(())((())))"")) == (std::vector<long>({(long)4})));
}
"
HumanEval/7,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// صرف ان پٹ ویکٹر فلٹر کرٕن سٹرنگن خٲطرٕہ یوس دِنہٕ آمُت ذیلی تار چُھ آسان >>> filter_by_substring(((std::vector<std::string>() ، (""a"")) (std::vector<std::string>()) >>> filter_by_substring((((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""cde"", (std::string) ""array""}) ، (""a"") (std::vector<std::string>({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""array""}))
std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
","std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_substring;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""aaaxxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""aaaxxy"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""grunt"", (std::string)""trumpet"", (std::string)""prune"", (std::string)""gruesome""})), (""run"")) == (std::vector<std::string>({(std::string)""grunt"", (std::string)""prune""})));
}
"
HumanEval/8,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// انٹیجرزن ہندس اکس ویکٹرس خٲطرٕ، اکھ ٹپل یُس اکس ویکٹرس منٛز موجود تمام انٹیجرن ہند مجموعہ تہٕ ضربس پیٹھ مشتمل چُھ واپس کران۔ خٲلی مجموعہ گژھہِ 0 برابر آسن تہٕ خٲلی ضرب گژھہِ 1 برابر آسن۔ >>> sum_product((std::vector<long>())) (std::make_tuple(0, 1)) >>> sum_product(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple(10, 24))
std::tuple<long, long> sum_product(std::vector<long> numbers) {
","std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);
    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());
    return std::make_tuple(sum, product);
}","}
int main() {
    auto candidate = sum_product;
    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));
    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));
    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));
}
"
HumanEval/9,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// انٹیجرزن ہند دیتٕج ویکٹرٕ پیٹھہٕ، ترتیبس منز دِنہٕ آمتِس لمحس تام چُھ ملن وول میکسِم عنصرُک ویکٹرٕ جِنریٹ کٔرِتھ۔ >>> rolling_max(((std::vector<long>({long) 1، (long) 2، (long) 3، (long) 2، (long) 3، (long) 4، (long) 2}))) (std::vector<long>({long) 1، (long) 2، (long) 3، (long) 3، (long) 3، (long) 4، (long) 4}))
std::vector<long> rolling_max(std::vector<long> numbers) {
","std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> result;
    long max_so_far = LONG_MIN;

    for (long num : numbers) {
        max_so_far = std::max(max_so_far, num);
        result.push_back(max_so_far);
    }

    return result;
}","}
int main() {
    auto candidate = rolling_max;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));
}
"
HumanEval/10,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ساروی کھوتہٕ مختصر پالینڈوم تلاش کرُن یُس سپلائی کرنہٕ آمت سٹرنگہٕ سۭتۍ شروع چُھ گژھان۔ الگورتھم خیال چُھ آسان: - سپلائی کرنہٕ آمت سٹرنگک ساروی کھوتہٕ زیوٹھ پوسٹ فکس تلاش کرُن یُس اکھ پالینڈوم چُھ۔ - سٹرنگ کس اختتامس پیٹھ سٹرنگ پریفیکسک ریورس جوڑُن یُس پالینڈومک سرفیس برونٹھ چُھ یوان۔ >>> make_palindrome(("""")) ("""") >>> make_palindrome((""cat"")) (""catac"") >>> make_palindrome((""cata"")) (""catac"")
std::string make_palindrome(std::string string) {
","std::string make_palindrome(std::string string) {
    auto is_palindrome = [](const std::string &s) {
        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());
    };

    for (size_t i = 0; i < string.size(); ++i) {
        if (is_palindrome(string.substr(i))) {
            std::string prefix = string.substr(0, i);
            std::reverse(prefix.begin(), prefix.end());
            return string + prefix;
        }
    }

    return string;
}","}
int main() {
    auto candidate = make_palindrome;
    assert(candidate(("""")) == (""""));
    assert(candidate((""x"")) == (""x""));
    assert(candidate((""xyz"")) == (""xyzyx""));
    assert(candidate((""xyx"")) == (""xyx""));
    assert(candidate((""jerry"")) == (""jerryrrej""));
}
"
HumanEval/11,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ان پٹ چِھ زٕ تار a تہٕ b یِم صرف 1s تہٕ 0s پیٹھ مشتمل چِھ۔ یمن ان پٹسن پیٹھ چُھ بائنری XOR کٔرِتھ نتیجہٕ چُھ سٹرنگ کِس طورس پیٹھ تہٕ واپس کران۔ >>> string_xor((""010""), (""110"")) (""100"")
std::string string_xor(std::string a, std::string b) {
","std::string string_xor(std::string a, std::string b) {
    std::string result;
    for (size_t i = 0; i < a.size(); ++i) {
        result += (a[i] == b[i]) ? '0' : '1';
    }
    return result;
}","}
int main() {
    auto candidate = string_xor;
    assert(candidate((""111000""), (""101010"")) == (""010010""));
    assert(candidate((""1""), (""1"")) == (""0""));
    assert(candidate((""0101""), (""0000"")) == (""0101""));
}
"
HumanEval/12,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// سٹرنگس ہندس ویکٹرس منزہ، چُھ ساروی کھوتہٕ زیوٹھ واپس کران۔ ایکِس ہی لمبٲئی ہند متعدد سٹرنگس ہندِس صورتس منز چُھ گوڈنُک واپس کران۔ ان پٹ ویکٹر چُھ خٲلی آسنہٕ کہِ صورتس منز چُھ واپس نِنہٕ یوان۔ >>> longest((std::vector<std::string>())) std::nullopt >>> longest((std::vector<std::string>{(std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) ""a"" >>> longest(((std::vector<std::string>({(std::string) ""a"", (std::string) ""bb"", (stdstring) ""ccc""}))) ""ccc""
std::optional<std::string> longest(std::vector<std::string> strings) {
","std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) return std::nullopt;

    return *std::max_element(strings.begin(), strings.end(), 
                             [](const std::string& a, const std::string& b) {
                                 return a.size() < b.size();
                             });
}","}
int main() {
    auto candidate = longest;
    assert(candidate((std::vector<std::string>())) == std::nullopt);
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == ""x"");
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""yyy"", (std::string)""zzzz"", (std::string)""www"", (std::string)""kkkk"", (std::string)""abc""}))) == ""zzzz"");
}
"
HumanEval/13,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// دوٛن عددن a تہٕ b یُس >>> greatest_common_divisor((3) ، (5)) (1) >>> greatest_common_divisor((25) ، (15)) (5) سٕتۍ چُھ بڑُھ مشترک تقسیم کار واپس کران۔
long greatest_common_divisor(long a, long b) {
","long greatest_common_divisor(long a, long b) {
    return std::gcd(a, b);
}","}
int main() {
    auto candidate = greatest_common_divisor;
    assert(candidate((3), (7)) == (1));
    assert(candidate((10), (15)) == (5));
    assert(candidate((49), (14)) == (7));
    assert(candidate((144), (60)) == (12));
}
"
HumanEval/14,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ان پٹ سٹرنگ >>> all_prefixes((""abc"") پیٹھہٕ ساروی کھوتہٕ مختصر پیٹھہٕ زیوٹھس تام تمام پریفیکسزک واپسی ویکٹر) (std::vector<std::string>({(std::string) ""a"", (std::string) ""ab"", (std::string) ""abc""}))
std::vector<std::string> all_prefixes(std::string string) {
","std::vector<std::string> all_prefixes(std::string string) {
    std::vector<std::string> prefixes;
    for (size_t i = 1; i <= string.size(); ++i) {
        prefixes.push_back(string.substr(0, i));
    }
    return prefixes;
}","}
int main() {
    auto candidate = all_prefixes;
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""asdfgh"")) == (std::vector<std::string>({(std::string)""a"", (std::string)""as"", (std::string)""asd"", (std::string)""asdf"", (std::string)""asdfg"", (std::string)""asdfgh""})));
    assert(candidate((""WWW"")) == (std::vector<std::string>({(std::string)""W"", (std::string)""WW"", (std::string)""WWW""})));
}
"
HumanEval/15,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// سٹرنگ چُھ اکھ سٹرنگ رٹان یتھ منز 0 پیٹھہٕ n تام جاۓ سٕتۍ محدود نمبر چِھ شروع گژھان۔ >>> string_sequence((0)) (""0"") >>> string_sequence((5)) (""0 1 2 3 4 5"")
std::string string_sequence(long n) {
","std::string string_sequence(long n) {
    std::ostringstream oss;
    for (long i = 0; i <= n; ++i) {
        if (i > 0) oss << "" "";
        oss << i;
    }
    return oss.str();
}","}
int main() {
    auto candidate = string_sequence;
    assert(candidate((0)) == (""0""));
    assert(candidate((3)) == (""0 1 2 3""));
    assert(candidate((10)) == (""0 1 2 3 4 5 6 7 8 9 10""));
}
"
HumanEval/16,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ سٹرنگ دیتھ، ژھانٛڈو کیت تام الگ الگ کرل وٲلۍ حروف (کیس سٕتۍ قطع نظر) یہٕ چُھ >>> count_distinct_characters((""xyzXYZ"")) (3) >>> count_distinct_characters((""Jerry"")) (4)
long count_distinct_characters(std::string string) {
","long count_distinct_characters(std::string string) {
    std::unordered_set<char> distinct_chars;
    for (char ch : string) {
        distinct_chars.insert(std::tolower(ch));
    }
    return distinct_chars.size();
}","}
int main() {
    auto candidate = count_distinct_characters;
    assert(candidate(("""")) == (0));
    assert(candidate((""abcde"")) == (5));
    assert(candidate((""abcdecadeCADE"")) == (5));
    assert(candidate((""aaaaAAAAaaaa"")) == (1));
    assert(candidate((""Jerry jERRY JeRRRY"")) == (5));
}
"
HumanEval/17,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// یہٕ فنکشن چُھ اکھ سٹرنگ یوس میوزک نوٹس چُھ ASCII فارمیٹس منز ظٲہر کران۔ توہیہ چُھ سٹرنگ ویکٹر ہند تجزیہ کرن یتھ منز انٹیجر چِھ آسان یم وارہٕن بیٹسس سٕتۍ چِھ مطابقت تھاوان۔ یہٕ چُھ اکھ لیجنڈ: 'o' نوٹ، آخری بیٹس 'o 112' - آخری نصف نوٹ، آخری دو بیٹس 'o 112' - آخری کوارٹر نوٹ، آخری ایکہِ بیٹس >>> parse_music.
std::vector<long> parse_music(std::string music_string) {
","std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::istringstream iss(music_string);
    std::string note;
    
    while (iss >> note) {
        if (note == ""o"") beats.push_back(4);
        else if (note == ""o|"") beats.push_back(2);
        else if (note == "".|"") beats.push_back(1);
    }

    return beats;
}","}
int main() {
    auto candidate = parse_music;
    assert(candidate(("""")) == (std::vector<long>()));
    assert(candidate((""o o o o"")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate(("".| .| .| .|"")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));
    assert(candidate((""o| o| .| .| o o o o"")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));
    assert(candidate((""o| .| o| .| o o| o o|"")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));
}
"
HumanEval/18,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// یہٕ ژھانٛڈِو زِ اصل سٹرنگس منز کِتھہٕ کٕن چُھ اکھ ذیلی سٹرنگ ملان۔ اوورلیپنگ کیسز گنزرو۔ >>> how_many_times(("""") ، (""a"")) (0) >>> how_many_times(""aaa""), (""a"") (3) >>> how_many_times(""aaaa""), (""aa"") (3)
long how_many_times(std::string string, std::string substring) {
","long how_many_times(std::string string, std::string substring) {
    if (substring.empty()) return 0;
    
    long count = 0;
    size_t pos = 0;
    
    while ((pos = string.find(substring, pos)) != std::string::npos) {
        count++;
        pos++;  // Move one position forward to count overlapping occurrences
    }
    
    return count;
}","}
int main() {
    auto candidate = how_many_times;
    assert(candidate((""""), (""x"")) == (0));
    assert(candidate((""xyxyxyx""), (""x"")) == (4));
    assert(candidate((""cacacacac""), (""cac"")) == (4));
    assert(candidate((""john doe""), (""john"")) == (1));
}
"
HumanEval/19,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ان پٹ چُھ 'صفر' پیٹھہٕ 'نوے' تام عددن ہند اکھ جاۓ ہند محدود تار۔ درست انتخاب چِھ 'صفر'، 'اکھ'، 'دو'، 'تین'، 'ژور'، 'پانچ'، 'چھ'، 'سات'، 'آٹھ' تہٕ 'نِژھ'۔ نمبرن سٕتۍ سٹرنگ چُھ لوکٹہٕ پیٹھہٕ بڑس تام ترتیب دِنہٕ یوان >>> sort_numbers((""تین اکھ پانژھ"")) (""اکھ تریہ پانژھ"")
std::string sort_numbers(std::string numbers) {
","std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, int> num_map = {
        {""zero"", 0}, {""one"", 1}, {""two"", 2}, {""three"", 3}, {""four"", 4},
        {""five"", 5}, {""six"", 6}, {""seven"", 7}, {""eight"", 8}, {""nine"", 9}
    };

    std::unordered_map<int, std::string> rev_map = {
        {0, ""zero""}, {1, ""one""}, {2, ""two""}, {3, ""three""}, {4, ""four""},
        {5, ""five""}, {6, ""six""}, {7, ""seven""}, {8, ""eight""}, {9, ""nine""}
    };

    std::istringstream iss(numbers);
    std::vector<int> num_list;
    std::string word;

    while (iss >> word) {
        num_list.push_back(num_map[word]);
    }

    std::sort(num_list.begin(), num_list.end());

    std::ostringstream oss;
    for (size_t i = 0; i < num_list.size(); ++i) {
        if (i > 0) oss << "" "";
        oss << rev_map[num_list[i]];
    }

    return oss.str();
}","}
int main() {
    auto candidate = sort_numbers;
    assert(candidate(("""")) == (""""));
    assert(candidate((""three"")) == (""three""));
    assert(candidate((""three five nine"")) == (""three five nine""));
    assert(candidate((""five zero four seven nine eight"")) == (""zero four five seven eight nine""));
    assert(candidate((""six five four three two one zero"")) == (""zero one two three four five six""));
}
"
HumanEval/20,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اعدادن ہندس فراہم کردہ ویکٹرٕ (مطول کم از کم زٕ) پیٹھہٕ دو منتخب تہٕ دو واپس یُس اکس بیکس قریب چُھ تہٕ تہٕ یمن ترتیبس منٛز واپس ییہٕ کرنہٕ (ننہٕ نمبر، بڑ نمبر) ۔ >>> find_closest_elements{std::vector<float>{(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.2f}))) (std::make_tuple{std::vector<float>{std::float}1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.0f))
std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
","std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    std::sort(numbers.begin(), numbers.end());
    float min_diff = std::numeric_limits<float>::max();
    float num1 = 0, num2 = 0;

    for (size_t i = 1; i < numbers.size(); ++i) {
        float diff = numbers[i] - numbers[i - 1];
        if (diff < min_diff) {
            min_diff = diff;
            num1 = numbers[i - 1];
            num2 = numbers[i];
        }
    }

    return std::make_tuple(num1, num2);
}","}
int main() {
    auto candidate = find_closest_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));
}
"
HumanEval/21,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اعدادن ہندس اکس ویکٹرس (کم از کم زٕ عناصرن) دنہٕ آمت، اتھ ویکٹرس پیٹھ چُھ اکھ لکیری تبدیلی لاگو کرنہٕ یوان، یتھ پٲنٹھ ساروی کھوتہٕ لوکٹ نمبر گژھ 0 تہٕ ساری کھوتہٕ بڑ نمبر گژھ 1 >>> rescale_to_unit{(std::vector<float>{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) (std::vector<float>{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))
std::vector<float> rescale_to_unit(std::vector<float> numbers) {
","std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    float min_val = *std::min_element(numbers.begin(), numbers.end());
    float max_val = *std::max_element(numbers.begin(), numbers.end());

    if (min_val == max_val) {
        std::fill(numbers.begin(), numbers.end(), 0.0f);
        return numbers;
    }

    for (float &num : numbers) {
        num = (num - min_val) / (max_val - min_val);
    }

    return numbers;
}","}
int main() {
    auto candidate = rescale_to_unit;
    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
}
"
HumanEval/22,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فلٹر دیتُن cppthon ویلیو صرف انٹیجرز خٲطرٕ >>> filter_integers((std::vector<std::any>({(std::string) ""a"", (std::string) 3.14f, (std::string) 5}))) (std::vector<long>({(long) 5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, ""abc"", std::<long,map>), std::vector<long>((}))) (std::vector<long>({(long) 1, (long) 2, (long) 3}))
std::vector<long> filter_integers(std::vector<std::any> values) {
","std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (const auto& val : values) {
        if (val.type() == typeid(long)) {
            result.push_back(std::any_cast<long>(val));
        } else if (val.type() == typeid(int)) {
            result.push_back(std::any_cast<int>(val));
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_integers;
    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));
    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, ""adasd""}))) == (std::vector<long>({(long)4, (long)9})));
    assert(candidate((std::vector<std::any>({3, ""c"", 3, 3, ""a"", ""b""}))) == (std::vector<long>({(long)3, (long)3, (long)3})));
}
"
HumanEval/23,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// دِنہٕ آمت سٹرنگچ لمبائی واپس کرنہٕ >>> string_length(("""")) (0) >>> string_length((""abc"")) (3)
long string_length(std::string string) {
","long string_length(std::string string) {
    return string.length();
}","}
int main() {
    auto candidate = string_length;
    assert(candidate(("""")) == (0));
    assert(candidate((""x"")) == (1));
    assert(candidate((""asdasnakj"")) == (9));
}
"
HumanEval/24,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// دِنہٕ آمتِس نمبرس n خاطرٕ، ساروی کھوتہٕ بوٕڑ نمبر تلاش کرو یوس n یکساں طور پأنٹھ تقسیم چُھ کران، n کھوتہٕ لوکٹ >>> largest_divisor ({} ({15)) (5)
long largest_divisor(long n) {
","long largest_divisor(long n) {
    for (long i = n / 2; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return 1;
}","}
int main() {
    auto candidate = largest_divisor;
    assert(candidate((3)) == (1));
    assert(candidate((7)) == (1));
    assert(candidate((10)) == (5));
    assert(candidate((100)) == (50));
    assert(candidate((49)) == (7));
}
"
HumanEval/25,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// دِنہٕ آمت انٹیجرُک پرائم فیکٹرُک ریٹرن ویکٹر چُھ ساروی کھوتہٕ لوکٹھ پیٹھہٕ بڑس ترتیبس منز۔ فیکٹرُک پرتھ اکھ نمبر گژھہِ فیکٹرِزِشنس منز کُنہِ وٕہتھہِ وقتُک نمبر گژھہِ برابر آسن۔ ان پٹ نمبر گژھہِ تمام فیکٹرُک پروڈکٹُک برابر آسن >>> فیکٹرِزِٹ کریں ((8)) (std::vector<long> ({(long) 2، (long) 2، (long) 2}) >>> فیکٹرِزِٹ کریں ((25)) (std::vector<long> ({(long) 5، (long) 5}) >>> فیکٹرِزِٹ کریں (((70)) (std::vector<long> ({(long) 2، (long) 5، (long) 7}))
std::vector<long> factorize(long n) {
","std::vector<long> factorize(long n) {
    std::vector<long> factors;
    for (long i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;
}","}
int main() {
    auto candidate = factorize;
    assert(candidate((2)) == (std::vector<long>({(long)2})));
    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));
    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));
    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));
    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));
    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));
}
"
HumanEval/26,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// انٹیجرز ہندس ویکٹرٕ پیٹھہٕ، تمام عناصر یوس ایکہِ کھوتہٕ زیادٕہ لٹہِ پیدہ گژھان چُھ ہٹٲوِو۔ عناصرن ہند ترتیب چُھ ہاوان یتھے پٲٹھۍ زِ ان پٹس منز چُھ ۔ >>> remove_duplicates
std::vector<long> remove_duplicates(std::vector<long> numbers) {
","std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> freq;
    for (long num : numbers) {
        freq[num]++;
    }

    std::vector<long> result;
    for (long num : numbers) {
        if (freq[num] == 1) {
            result.push_back(num);
        }
    }

    return result;
}","}
int main() {
    auto candidate = remove_duplicates;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));
}
"
HumanEval/27,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ڈاٹا سٹرنگہٕ خٲطرٕ، لوکسر کیریکرن اپرکیسز تہٕ اپرکیسز لوکسرس منز پلٹٲوِو۔ >>> flip_case (((""ہیلو"")) (""ہیلو"")
std::string flip_case(std::string string) {
","std::string flip_case(std::string string) {
    for (char &ch : string) {
        if (std::islower(ch)) {
            ch = std::toupper(ch);
        } else if (std::isupper(ch)) {
            ch = std::tolower(ch);
        }
    }
    return string;
}","}
int main() {
    auto candidate = flip_case;
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hello!"")) == (""hELLO!""));
    assert(candidate((""These violent delights have violent ends"")) == (""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""));
}
"
HumanEval/28,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// سٹرنگس چُھ اکھ سٹرنگس منز کنکیٹنٹ ویکٹر بناوان >>> کنکیٹنٹ(((std::vector<std::string>())) ("""") >>> کنکیٹنٹ(((std::vector<std::string>({(std::string) ""a""، (std::string) ""b""، (std::string) ""c""}))) (""abc"")
std::string concatenate(std::vector<std::string> strings) {
","std::string concatenate(std::vector<std::string> strings) {
    std::string result;
    for (const auto& str : strings) {
        result += str;
    }
    return result;
}","}
int main() {
    auto candidate = concatenate;
    assert(candidate((std::vector<std::string>())) == (""""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == (""xyz""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z"", (std::string)""w"", (std::string)""k""}))) == (""xyzwk""));
}
"
HumanEval/29,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// صرف ان پٹ ویکٹر فلٹر کرُن یمو سٹرنگن صرف تمن ویکٹرن خٲطرٕہ چُھ یُس کُنہِ دِنہٕ آمٕژِ پریفیکسس سٕتۍ شروع چُھ گژھان۔ >>> filter_by_prefix((std::vector<std::string>() ، (""a"")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bcd"", (std::string) ""cde"", (stdstring) ""array""}) ، (""a"") (std::vector<std::string>(({(std::string) ""abc"", (std::string) ""array""}))
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
","std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_prefix;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
}
"
HumanEval/30,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// صرف مثبت نمبر چِھ ویکٹرس منٛز واپس کران۔ >>> get_positive((std::vector<long>({long) - 1، (long) 2، (long) - 4، (long) 5، (long) 6}))) (std::vector<long>({long) 2، (long) 5، (long) 6})) >>> get_positive((std::vector<long>({long) 5، (long) 3، (long) 5، (long) 5، (long) 2، (long) 3، (long) 9، (long) 0، (long) 123، (long) 1، (long) 10}))) (std::vector<long>{(long) 5، (long) 3، (long) 2، (long) 3، (long) 9، (long) 12، (long) 13، (long) 1}))
std::vector<long> get_positive(std::vector<long> l) {
","std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> result;
    for (long num : l) {
        if (num > 0) {
            result.push_back(num);
        }
    }
    return result;
}","}
int main() {
    auto candidate = get_positive;
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));
    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/31,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اگر اکھ دِنہٕ آمت نمبر پرائم چُھ تیلہٕ چُھ صحیح واپس یوان، تہٕ بییہٕ غلط۔ >>> is_prime((6)) (غلط) >>> is_prime((101)) (سچ) >>> is_prime((11) (سچ) >>> is_prime((13441)) (سچ) >>> is_prime(61)) (سچ) >>> is_prime(4) (غلط) >>> is_prime(1) (غلط)
bool is_prime(long n) {
","bool is_prime(long n) {
    if (n < 2) return false;
    if (n < 4) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_prime;
    assert(candidate((6)) == (false));
    assert(candidate((101)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((13441)) == (true));
    assert(candidate((61)) == (true));
    assert(candidate((4)) == (false));
    assert(candidate((1)) == (false));
    assert(candidate((5)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((17)) == (true));
    assert(candidate((85)) == (false));
    assert(candidate((77)) == (false));
    assert(candidate((255379)) == (false));
}
"
HumanEval/33,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// یہٕ فنکشن چُھ اکھ ویکٹر l نوان تہٕ چُھ اکھ ویکٹر l' واپس کران یتھ کٔن زَن l' چُھ یمن انڈیکسن منٛز l سٕتۍ مماثل آسان یم ترین سۭتۍ تقسیم گژھن چِھ نہٕ آسان، ییلہِ زَن کہ یمن انڈیکسن پیٹھ یم ترین سۭتۍ تقسیم گژھن چِھ تمن ہند ویلیو چِھ l کہ متعلقہٕ انڈیکسن ہند ویلیو برابر آسان، مگر ترتیب چِھ دنہٕ یوان۔ >>> sort_third: vector<long>{(long>1, (long) 2, (long) 3}))) (std: vector<long>{(long>1, (long) 2, (long) 3})) >>> sort_third: vector<long>{(long>5, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 2}))) (std: vector<(long>{(long>2, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long 5})
std::vector<long> sort_third(std::vector<long> l) {
","std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> third_indices;
    for (size_t i = 0; i < l.size(); i += 3) {
        third_indices.push_back(l[i]);
    }
    std::sort(third_indices.begin(), third_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 3) {
        l[i] = third_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_third;
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));
}
"
HumanEval/34,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ایکِس ویکٹرس منز چُھ ترتیب شدہ منفرد عناصر واپس کران >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) (std::vector<long>{(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))
std::vector<long> unique(std::vector<long> l) {
","std::vector<long> unique(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    l.erase(std::unique(l.begin(), l.end()), l.end());
    return l;
}","}
int main() {
    auto candidate = unique;
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));
}
"
HumanEval/35,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ویکٹرس منٛز زیادٕ کھوتہٕ زیادٕ عنصر واپس کران۔ >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long) -5, (long) 2, (long) -3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (123)
long max_element(std::vector<long> l) {
","long max_element(std::vector<long> l) {
    return *std::max_element(l.begin(), l.end());
}","}
int main() {
    auto candidate = max_element;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));
}
"
HumanEval/36,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// یہٕ چُھ 7 ہندسہٕ ہند تعداد واپس کران یُس n کھوتہٕ کم عددن منٛز چُھ ظاہر گژھان یم 11 یا 13 سۭتۍ تقسیم گژھہٕ۔ >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)
long fizz_buzz(long n) {
","long fizz_buzz(long n) {
    long count = 0;
    for (long i = 0; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            long temp = i;
            while (temp > 0) {
                if (temp % 10 == 7) count++;
                temp /= 10;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = fizz_buzz;
    assert(candidate((50)) == (0));
    assert(candidate((78)) == (2));
    assert(candidate((79)) == (3));
    assert(candidate((100)) == (3));
    assert(candidate((200)) == (6));
    assert(candidate((4000)) == (192));
    assert(candidate((10000)) == (639));
    assert(candidate((100000)) == (8026));
}
"
HumanEval/37,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// یہٕ فنکشن چُھ اکھ ویکٹر l نوان تہٕ چُھ اکھ ویکٹر l' واپس کران یتھکن زِ odd انڈیکسس منٛز چُھ l' ییتھ کیٛن زِ even انڈیکسس منٛز چِھ امچ قدر l کہ برابر، مگر ترتیب چُھ آمُت دینہٕ۔ >>> sort_even{(std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even{(std::vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std::vector<(long>{(long) 3, (long) 6, (long) 5, (long) 4}))
std::vector<long> sort_even(std::vector<long> l) {
","std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for (size_t i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 2) {
        l[i] = even_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_even;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));
}
"
HumanEval/39,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// prime_fib چُھ نٔمِس نمبرس واپس کران یوس اکھ فبونیکی نمبر چُھ تہٕ چُھ یہٕ تہٕ اکھ پرائم۔ >>> prime_fib((1)) (2) >>> prime_fib(2) (3) >>> prime_fib(3)) (5) >>> prime_fib(4)) (13) >>> prime_fib(5)) (89)
long prime_fib(long n) {
","bool is_prime(long num) {
    if (num < 2) return false;
    if (num < 4) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;
    for (long i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}

long prime_fib(long n) {
    std::vector<long> prime_fibs;
    long a = 1, b = 1;
    while (prime_fibs.size() < n) {
        long next = a + b;
        a = b;
        b = next;
        if (is_prime(next)) {
            prime_fibs.push_back(next);
        }
    }
    return prime_fibs[n - 1];
}","}
int main() {
    auto candidate = prime_fib;
    assert(candidate((1)) == (2));
    assert(candidate((2)) == (3));
    assert(candidate((3)) == (5));
    assert(candidate((4)) == (13));
    assert(candidate((5)) == (89));
    assert(candidate((6)) == (233));
    assert(candidate((7)) == (1597));
    assert(candidate((8)) == (28657));
    assert(candidate((9)) == (514229));
    assert(candidate((10)) == (433494437));
}
"
HumanEval/40,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// triples_sum_to_zero چُھ ان پٹ کِس طورس پیٹھ انٹیجرزُک ویکٹر نوان۔ یہٕ چُھ صحیح واپس کران اگر ویکٹرس منز چِھ ترے الگ الگ عناصر یم صفرس تام جمع چِھ گژھان، تہٕ بصورت دیگر غلط۔ >>> triples_sum_to_zero(std::vector<long>(long) 1، (long) 3، (long) 5، (long) 0}))) (false) >>> triples_sum_to_zero(std::vector<long>(long) 1، (long) 3، (long) 2، (long) 1} (true) >>> triples_sum_to_zero(std::vector<long>(long) 1، (long) 2، (long) 3، (long) 7}))) (se) >>> triples_sum_to_zero(std::vector<long> (long) 2، (long) 4، (long) 5، (long) 3، (long) 9، (long) 7))) (true) >>> triples_sum_to_long))) (long_vector) >>>
bool triples_sum_to_zero(std::vector<long> l) {
","bool triples_sum_to_zero(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    for (size_t i = 0; i < n - 2; i++) {
        size_t left = i + 1, right = n - 1;
        while (left < right) {
            long sum = l[i] + l[left] + l[right];
            if (sum == 0) return true;
            else if (sum < 0) left++;
            else right--;
        }
    }
    
    return false;
}","}
int main() {
    auto candidate = triples_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));
    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));
}
"
HumanEval/41,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ سڑک تصور کرو یس اکھ بالکل سیدھی لامحدود زیچھر چِھ۔ n کار چِھ بائیں پیٹھہٕ دائیں گژھان۔ بیک وقت، n کارن ہند اکھ مختلف سیٹ چِھ دائیں پیٹھہٕ بائیں گژھان۔ کارن ہندۍ زٕ سیٹہٕ چِھ اکس بییس نش واریاہ دور آسان۔ تمام کارہٕ چِھ ایکسی رفتارس پیٹھ حرکت کران۔ زٕ کارہٕ چِھ ٹکراوان ییلہِ اکھ کار چِھ بائیں پیٹھہٕ دائیں طرفہٕ حرکت کران تہٕ چِھ اکھ کارس ٹکران یُس دائیں پیٹھہٕ بائیں طرفہٕ حرکت چِھ کران۔ تاہم، کارہٕ چِھ لامحدود مضبوط تہٕ مضبوط۔ نتیجس منٛز، چِھ تم پننہٕ رفتارس منٛز حرکت کران گویا تم چِھنہٕ ٹکراوان۔ یہٕ فنکشن چُھ یتھ ٹکراون ہنٛز تعداد ظٲہر کران۔
long car_race_collision(long n) {
","long car_race_collision(long n) {
    return n * n;
}","}
int main() {
    auto candidate = car_race_collision;
    assert(candidate((2)) == (4));
    assert(candidate((3)) == (9));
    assert(candidate((4)) == (16));
    assert(candidate((8)) == (64));
    assert(candidate((10)) == (100));
}
"
HumanEval/42,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// عناصرن سۭتۍ چُھ 1 سۭتۍ اضافہٕ گژھن وٲل ویکٹر واپس گژھان۔ >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>({long) 2, (long) 3, (long) 4})) >>> incr_list((std::vector<long>({long) 5, (long) 3, (long) 5, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>({long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))
std::vector<long> incr_list(std::vector<long> l) {
","std::vector<long> incr_list(std::vector<long> l) {
    for (long &num : l) {
        num++;
    }
    return l;
}","}
int main() {
    auto candidate = incr_list;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));
    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));
}
"
HumanEval/43,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// جوڑ_سَم_تَن_صفر چُھ اَکہِ انٹیجر ویکٹرٕچ ان پٹ کِس طورس پیٹھ نوان۔ یہٕ چُھ صیح واپس کران اگر ویکٹرس منز چِھ زٕ الگ الگ عناصر یم صفرس سٕتۍ چِھ ملان، تہٕ بییہٕ غلط۔ >>> جوڑ_سَم_تَن_صفر چِھ
bool pairs_sum_to_zero(std::vector<long> l) {
","bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> seen;
    for (long num : l) {
        if (seen.count(-num)) {
            return true;
        }
        seen.insert(num);
    }
    return false;
}","}
int main() {
    auto candidate = pairs_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));
}
"
HumanEval/44,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ان پٹ نمبر x ہٕنٛز عددی بنیاد چُھ بیسسس منٛز تبدیل کران۔ تبدیل کرنہٕ پتہٕ چُھ سٹرنگ ریٚپرایزیشن واپس کران۔ بیسٕکۍ نمبر چھِ 10 کھۄتہٕ کم۔ >>> change_base((8), (3)) (""22"") >>> change_base(8), (2)) (""1000"") >>> change_base(7), (2)) (""111"")
std::string change_base(long x, long base) {
","std::string change_base(long x, long base) {
    if (x == 0) return ""0"";
    
    std::string result;
    while (x > 0) {
        result += std::to_string(x % base);
        x /= base;
    }
    
    std::reverse(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = change_base;
    assert(candidate((8), (3)) == (""22""));
    assert(candidate((9), (3)) == (""100""));
    assert(candidate((234), (2)) == (""11101010""));
    assert(candidate((16), (2)) == (""10000""));
    assert(candidate((8), (2)) == (""1000""));
    assert(candidate((7), (2)) == (""111""));
    assert(candidate((2), (3)) == (""2""));
    assert(candidate((3), (4)) == (""3""));
    assert(candidate((4), (5)) == (""4""));
    assert(candidate((5), (6)) == (""5""));
    assert(candidate((6), (7)) == (""6""));
    assert(candidate((7), (8)) == (""7""));
}
"
HumanEval/45,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// مثلث خاطرٕ اکھ طرفچ لمبائی تہٕ زیادٕ واپسی ہنٛد علاقہٕ دنہٕ آمت۔ >>> مثلث_علاقہٕ ({} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، {} ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } ، { } } ، { } } ، { } } ، { } ، { } } } ، { } } ، { } } } ، { } } } ، { } } } ، { } } } } ، { } } } } } } ، { { { } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
float triangle_area(long a, long h) {
","float triangle_area(long a, long h) {
    return 0.5f * a * h;
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((5), (3)) == (7.5f));
    assert(candidate((2), (2)) == (2.0f));
    assert(candidate((10), (8)) == (40.0f));
}
"
HumanEval/46,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فبونیکی نمبر سیکوینس چِھ فبونیکی سیکوینس ہیوۍ اکھ سیکوینس یمک تعریف چِھ یتھہ پاٹھۍ: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). براہ کرم fib4 نمبر سیکوینس ہند n-th عنصر موثر اندازس منز شمار کرنہٕ خٲطرٕہ اکھ فنکشن لیوکھو۔ ریکوریشن استعمال مت کٔرِتھ۔ >>> fib4((5)) (4) >>> fib4(6) (8) >>>4((7)) (14)
long fib4(long n) {
","long fib4(long n) {
    if (n == 0 || n == 1 || n == 3) return 0;
    if (n == 2) return 2;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 2;

    for (long i = 4; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fib4;
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (28));
    assert(candidate((10)) == (104));
    assert(candidate((12)) == (386));
}
"
HumanEval/47,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ویکٹر l منٛز عناصرن ہٕنٛز میڈین واپس کرنہٕ آمٕژ۔ >>> میڈین (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) ، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (
float median(std::vector<long> l) {
","float median(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    if (n % 2 == 1) {
        return static_cast<float>(l[n / 2]);
    } else {
        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;
    }
}","}
int main() {
    auto candidate = median;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));
    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));
    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));
    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));
    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));
}
"
HumanEval/48,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// یہٕ چُھ جانچ کران زِ کیا یہٕ ڈگری چِھ اکھ پالنڈروم >>> is_palindrome(("""")) (true) >>> is_palindrome((""aba"")) (true) >>> is_palindrome((""aaaaa"")) (true) >>> is_palindrome((""zbcd"")) (false)
bool is_palindrome(std::string text) {
","bool is_palindrome(std::string text) {
    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());
}","}
int main() {
    auto candidate = is_palindrome;
    assert(candidate(("""")) == (true));
    assert(candidate((""aba"")) == (true));
    assert(candidate((""aaaaa"")) == (true));
    assert(candidate((""zbcd"")) == (false));
    assert(candidate((""xywyx"")) == (true));
    assert(candidate((""xywyz"")) == (false));
    assert(candidate((""xywzx"")) == (false));
}
"
HumanEval/49,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ریٹرن 2 ^ n ماڈیولو p (نمبرس سٕتۍ آگاہ گژھُن) ۔ >>> modp(((3) ، (5)) (3) >>> modp((1101) ، (101)) (2) >>> modp((0) ، (101)) (1) >>> modp((3), (11)) (8) >>> modp((100) ، (101) (1)
long modp(long n, long p) {
","long modp(long n, long p) {
    return std::pow(2, n) % p;
}","}
int main() {
    auto candidate = modp;
    assert(candidate((3), (5)) == (3));
    assert(candidate((1101), (101)) == (2));
    assert(candidate((0), (101)) == (1));
    assert(candidate((3), (11)) == (8));
    assert(candidate((100), (101)) == (1));
    assert(candidate((30), (5)) == (4));
    assert(candidate((31), (5)) == (3));
}
"
HumanEval/51,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// remove_vowels چُھ اکھ فنکشن یُس سٹرنگ چُھ نوان تہٕ وولن وراۓ سٹرنگ چُھ واپس کران۔ >>> remove_vowels(("""")) ("""") >>> remove_vowels((""abcdef"")) (""bcdf"") >>> remove_vowels((""aaaaa"")) ("""") >>> remove_vowels(""aaBAA"")) (""B"") >>> remove_vowels((""zbcd"")) (""zbcd"")
std::string remove_vowels(std::string text) {
","std::string remove_vowels(std::string text) {
    std::string result;
    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
    
    for (char ch : text) {
        if (vowels.find(ch) == vowels.end()) {
            result += ch;
        }
    }
    
    return result;
}","}
int main() {
    auto candidate = remove_vowels;
    assert(candidate(("""")) == (""""));
    assert(candidate((""abcdef\nghijklm"")) == (""bcdf\nghjklm""));
    assert(candidate((""fedcba"")) == (""fdcb""));
    assert(candidate((""eeeee"")) == (""""));
    assert(candidate((""acBAA"")) == (""cB""));
    assert(candidate((""EcBOO"")) == (""cB""));
    assert(candidate((""ybcd"")) == (""ybcd""));
}
"
HumanEval/52,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ریٹرن true اگر ویکٹر l منٛز چھ تمام نمبر دہلیز t کھوتہٕ کم۔ >>> below_threshold((std::vector<long>({(long) 1، (long) 2، (long) 4، (long) 10}) ، (100)) (true) >>> below_threshold((std::vector<long>({(long) 1، (long) 20، (long) 4، (long) 10}) ، (5)) (false)
bool below_threshold(std::vector<long> l, long t) {
","bool below_threshold(std::vector<long> l, long t) {
    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });
}","}
int main() {
    auto candidate = below_threshold;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));
}
"
HumanEval/53,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// زٕ عدد x تہٕ y چِھ جمع کرنہٕ یوان، تہٕ چُھ جمع کرنہٕ یوان (2) ، (3)) (5) ، تہٕ چُھ جمع کرنہٕ یوان (5) ، (7) ، (12)
long add(long x, long y) {
","long add(long x, long y) {
    return x + y;
}","}
int main() {
    auto candidate = add;
    assert(candidate((0), (1)) == (1));
    assert(candidate((1), (0)) == (1));
    assert(candidate((2), (3)) == (5));
    assert(candidate((5), (7)) == (12));
    assert(candidate((7), (5)) == (12));
}
"
HumanEval/54,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// چیک کرو اگر زٕ لفظن منٛز چھِ اَکیٛن حروفن ہنٛد۔ >>> same_chars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) (true) >>> same_chars((""abcd""), (""dddddddabc"")) (true) >>> same_chars(""dddddddabc""), (""abcd"") (true) >>> same_chars((""eabcd""), (""dddddddabc"")) (false) same_chars >>>""((abcd""), (""dddddddddabce"") (false) >>> same_chars((""eabcd""), (""ddddzzzzzdzzdddabc"") (false)
bool same_chars(std::string s0, std::string s1) {
","bool same_chars(std::string s0, std::string s1) {
    std::unordered_set<char> set0(s0.begin(), s0.end());
    std::unordered_set<char> set1(s1.begin(), s1.end());
    return set0 == set1;
}","}
int main() {
    auto candidate = same_chars;
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(candidate((""abcd""), (""dddddddabc"")) == (true));
    assert(candidate((""dddddddabc""), (""abcd"")) == (true));
    assert(candidate((""eabcd""), (""dddddddabc"")) == (false));
    assert(candidate((""abcd""), (""dddddddabcf"")) == (false));
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(candidate((""aabb""), (""aaccc"")) == (false));
}
"
HumanEval/55,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// واپس n-th فبونیکی نمبر۔ >>> فبونیکی نمبر 10 (فبونیکی نمبر 10) (55) >>> فبونیکی نمبر 1 (فبونیکی نمبر 1) (1) >>> فبونیکی نمبر 8 (فبونیکی نمبر 21)
long fib(long n) {
","long fib(long n) {
    if (n <= 1) return n;
    
    long a = 0, b = 1, c;
    for (long i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    
    return b;
}","}
int main() {
    auto candidate = fib;
    assert(candidate((10)) == (55));
    assert(candidate((1)) == (1));
    assert(candidate((8)) == (21));
    assert(candidate((11)) == (89));
    assert(candidate((12)) == (144));
}
"
HumanEval/56,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets چُھ ""<"" تہٕ "">"" ہند اکھ سٹرنگ۔ اگر پرتھ اوپننگ بریکٹس منز چُھ اکھ مُطابقہ بند کرن وول بریکٹ تہٕ تیلہٕ چُھ ریٹرن true۔ >>> correct_bracketing((""<"")) (false) >>> correct_bracketing(""<>"")) (true) >>> correct_bracketing(""<><>"")) (true) >>> correct_bracketing("">(<>"") (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '<') balance++;
        else if (ch == '>') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""<>"")) == (true));
    assert(candidate((""<<><>>"")) == (true));
    assert(candidate((""<><><<><>><>"")) == (true));
    assert(candidate((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(candidate((""<<<><>>>>"")) == (false));
    assert(candidate((""><<>"")) == (false));
    assert(candidate((""<"")) == (false));
    assert(candidate((""<<<<"")) == (false));
    assert(candidate(("">"")) == (false));
    assert(candidate((""<<>"")) == (false));
    assert(candidate((""<><><<><>><>><<>"")) == (false));
    assert(candidate((""<><><<><>><>>><>"")) == (false));
}
"
HumanEval/57,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ریٹرن ٹرٛو چھ ویکٹر ایلیمنٹن ہنٛد مونٹونک پانٹھ بڑھان یا کم گژھن۔ >>> monotonic(((std::vector<long>({(long) 1، (long) 2، (long) 4، (long) 20}))) (true) >>> monotonic(((std::vector<long>{(long) 1، (long) 20، (long) 4، (long) 10}))) (false) >>> monotonic(((std::vector<long>{(long) 4، (long) 1، (long) 0، (long) 10}))) (true)
bool monotonic(std::vector<long> l) {
","bool monotonic(std::vector<long> l) {
    bool increasing = true, decreasing = true;
    
    for (size_t i = 1; i < l.size(); i++) {
        if (l[i] > l[i - 1]) decreasing = false;
        if (l[i] < l[i - 1]) increasing = false;
    }
    
    return increasing || decreasing;
}","}
int main() {
    auto candidate = monotonic;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));
    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));
}
"
HumanEval/58,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// دوٛن ویکٹرن خٲطرٕ چھ ترتیب شدٕ منفرد مشترکہ عناصر واپس کران۔ >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653})) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}) ، (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long>{long}2, (long) 3))
std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
","std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::unordered_set<long> set1(l1.begin(), l1.end());
    std::unordered_set<long> result_set;
    
    for (long num : l2) {
        if (set1.count(num)) {
            result_set.insert(num);
        }
    }
    
    std::vector<long> result(result_set.begin(), result_set.end());
    std::sort(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = common;
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/59,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// n ہٕنٛدس بڑس پرائم فاکٹرس واپس ییہٕ دنہٕ۔ فرض کرو n > 1 تہٕ یہ چھ نہٕ پرائم۔ >>> largest_prime_factor((13195)) (29) >>> largest_prime_factor((2048) (2)
long largest_prime_factor(long n) {
","long largest_prime_factor(long n) {
    long largest = -1;
    
    while (n % 2 == 0) {
        largest = 2;
        n /= 2;
    }
    
    for (long i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            largest = i;
            n /= i;
        }
    }
    
    if (n > 1) largest = n;
    
    return largest;
}","}
int main() {
    auto candidate = largest_prime_factor;
    assert(candidate((15)) == (5));
    assert(candidate((27)) == (3));
    assert(candidate((63)) == (7));
    assert(candidate((330)) == (11));
    assert(candidate((13195)) == (29));
}
"
HumanEval/60,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// sum_to_n چُھ اکھ فنکشن یُس 1 پیٹھ n تام نمبرن ہنز جَمح چُھ کران۔ >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)
long sum_to_n(long n) {
","long sum_to_n(long n) {
    return n * (n + 1) / 2;
}","}
int main() {
    auto candidate = sum_to_n;
    assert(candidate((1)) == (1));
    assert(candidate((6)) == (21));
    assert(candidate((11)) == (66));
    assert(candidate((30)) == (465));
    assert(candidate((100)) == (5050));
}
"
HumanEval/61,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets چُھ ""1"" تہٕ ""3"" ہند اکھ سٹرنگ۔) اگر پرتھ اوپننگ بریکٹس منز چُھ اکھ مُطابقہ بند کرن وول بریکٹ تہٕ تیلہٕ چُھ ریٹرن true۔ >>> correct_bracketing ""2"" (جھوٹ) >>> correct_bracketing ""4"" (جھوٹ) (سچ) >>> correct_bracketing ""4"" (جھوٹ)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '(') balance++;
        else if (ch == ')') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""()"")) == (true));
    assert(candidate((""(()())"")) == (true));
    assert(candidate((""()()(()())()"")) == (true));
    assert(candidate((""()()((()()())())(()()(()))"")) == (true));
    assert(candidate((""((()())))"")) == (false));
    assert(candidate(("")(()"")) == (false));
    assert(candidate((""("")) == (false));
    assert(candidate((""(((("")) == (false));
    assert(candidate(("")"")) == (false));
    assert(candidate((""(()"")) == (false));
    assert(candidate((""()()(()())())(()"")) == (false));
    assert(candidate((""()()(()())()))()"")) == (false));
}
"
HumanEval/62,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// xs چُھ کثیر الثانیس ہند کوفیسنٹ۔ xs[0] + xs[1] * x + xs[2] * x^2 + .... اتھ کثیر الثانیس ہند ماخوذ واپس کرن یژھی شکلہِ منز۔ >>> derivative((std::vector<long>({long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> derivative::std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))
std::vector<long> derivative(std::vector<long> xs) {
","std::vector<long> derivative(std::vector<long> xs) {
    std::vector<long> result;
    for (size_t i = 1; i < xs.size(); i++) {
        result.push_back(xs[i] * i);
    }
    return result;
}","}
int main() {
    auto candidate = derivative;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));
    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));
}
"
HumanEval/63,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فبوفب نمبر سیکوینس چِھ فبوبونکی سیکوینس ہیوۍ اکھ سیکوینس یمیچ تعریف ییتھ کیٛن چِھ کرنہٕ آمژ: فبوفب (۰) == 0 فبوفب (۱) == 0 فبوفب (۲) == 1 فبوفب (ن) == فبوفب (ن - ۱) + فبوفب (ن - ۲) + فبوفب (ن - ۳) براہ کرم اکھ فنکشن لیوکھو تاکہ فبوفب نمبر سیکوینس ہند n-th عنصر موثر اندازس منٛز شمار کرنہٕ ییہٕ۔ >>> فبوفب (ن - ۱) (0) >>> فبوفب (ن - ۵) (4) >>> فبوفب (ن - ۸) (24)
long fibfib(long n) {
","long fibfib(long n) {
    if (n == 0 || n == 1) return 0;
    if (n == 2) return 1;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 1;

    for (long i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fibfib;
    assert(candidate((2)) == (1));
    assert(candidate((1)) == (0));
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (24));
    assert(candidate((10)) == (81));
    assert(candidate((12)) == (274));
    assert(candidate((14)) == (927));
}
"
HumanEval/64,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لکھو vowels_count یُس اکھ لفظچ نمائندگی کرن وول سٹرنگ ان پٹ کہ طور پأنٹھ چُھ نیوان تہٕ سٹرنگس منٛز وولن ہنٛد تعداد چُھ واپس کران۔ اتھ صورتس منٛز وول چِھ 'a'، 'e'، 'i'، 'o'، 'u'۔ ییتہٕ چُھ 'y' تییہٕ اکھ وول، مگر صرف ییلہٕ یہٕ دِنہٕ آمت لفظ کس آخرس منٛز چُھ۔ مثال: >>> vowels_count (((""abcde"")) (2) >>> vowels_count ((""ACEDY"") (3)
long vowels_count(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long vowels_count(std::string s) {
  long count = 0;
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  for (char c : s) {
    if (vowels.count(c)) {
      count++;
    }
  }
  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {
    count++;
  }
  return count;
}","}
int main() {
    auto candidate = vowels_count;
    assert(candidate((""abcde"")) == (2));
    assert(candidate((""Alone"")) == (3));
    assert(candidate((""key"")) == (2));
    assert(candidate((""bye"")) == (1));
    assert(candidate((""keY"")) == (2));
    assert(candidate((""bYe"")) == (1));
    assert(candidate((""ACEDY"")) == (3));
}
"
HumanEval/65,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// انٹیجر x ہند ہندسہٕ سرکلر شیپ کرُن، ہندسہٕ دٲیچ شفٹ کرُن تہٕ نتیجہٕ سٹرنگ کہِ طورس پیٹھ واپس کرُن۔ اگر شفٹ > ہندسن ہند تعداد، تو واپس ہندسہٕ الٹہٕ کرُن۔ >>> circular_shift((12), (1)) (""21"") >>> circular_shift((12), (2)) (""12"")
std::string circular_shift(long x, long shift) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string circular_shift(long x, long shift) {
  std::string s = std::to_string(x);
  long n = s.length();
  if (n == 0) {
    return """";
  }
  shift %= n;
  if (shift < 0) {
    shift += n;
  }
  if (shift == 0) {
    return s;
  }
  if (shift > n) {
    std::reverse(s.begin(), s.end());
    return s;
  }
  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);
  return shifted_s;
}","}
int main() {
    auto candidate = circular_shift;
    assert(candidate((100), (2)) == (""001""));
    assert(candidate((12), (2)) == (""12""));
    assert(candidate((97), (8)) == (""79""));
    assert(candidate((12), (1)) == (""21""));
    assert(candidate((11), (101)) == (""11""));
}
"
HumanEval/66,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ٹاسک اکھ فنکشن لیوکھن یوس ان پٹ کہِ طورس پیٹھ چُھ اکھ سٹرنگ نوان تہٕ چُھ صرف بالٲئی حروفن ہند مجموعہ ASCII کوڈس منز واپس کران۔ مثال: >>> digitSum(("""")) (0) >>> digitSum((""abAB"")) (131) >>> digitSum((""abcCd"")) (67) >>> digitSum((""helloE"")) (69) >>> digitSum((""woArBld"")) (131) >>> digitSum((""aAXaaaa"") (153)
long digitSum(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long digitSum(std::string s) {
  long sum = 0;
  for (char c : s) {
    if (isupper(c)) {
      sum += static_cast<long>(c);
    }
  }
  return sum;
}","}
int main() {
    auto candidate = digitSum;
    assert(candidate(("""")) == (0));
    assert(candidate((""abAB"")) == (131));
    assert(candidate((""abcCd"")) == (67));
    assert(candidate((""helloE"")) == (69));
    assert(candidate((""woArBld"")) == (131));
    assert(candidate((""aAaaaXa"")) == (153));
    assert(candidate(("" How are yOu?"")) == (151));
    assert(candidate((""You arE Very Smart"")) == (327));
}
"
HumanEval/67,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اتھ کامہِ منز، چھےٚ توٚہۍ سٕنٛدس اکس سٹرینٛگس سۭتۍ اکھ عدد وٕچھنہٕ یوان یس اپیل تہٕ نارنجٕچ تعداد چھےٚ ہاونہٕ یوان یم میون ہٕنٛزِ ٹوکری منٛز تقسیم کرنہٕ آمژٕ چھےٚ۔ اتھ ٹوکری منٛز چھِ اپیل، نارنج تہٕ مانگو میون شٲمل۔ سٹرنگس سۭتۍ یس نارنجٕچ تہٕ اپیلٕچ مجموعی تعداد تہٕ اکھ عدد وٕچھنہٕ چھُ یس ٹوکری منٛز میون ہٕنٛز مجموعی تعداد چھِ ہاونہٕ یوان، اتھ سٹرنگس سۭتۍ چھِ ٹوکری منٛز موجود مانگو میون ہٕنٛز تعداد واپس کرنہٕ یوان۔ مثال: >>> fruit_distribution ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
long fruit_distribution(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long fruit_distribution(std::string s, long n) {
  long apples = 0;
  long oranges = 0;
  size_t apples_pos = s.find(""apples"");
  if (apples_pos != std::string::npos) {
    size_t start = 0;
    while (!isdigit(s[start])) {
      start++;
    }
    apples = std::stoll(s.substr(start, apples_pos - start));
  }
  size_t oranges_pos = s.find(""oranges"");
  if (oranges_pos != std::string::npos) {
    size_t and_pos = s.find(""and"");
    size_t start = and_pos + 3;
    while (!isdigit(s[start])) {
      start++;
    }
    oranges = std::stoll(s.substr(start, oranges_pos - start));
  }
  return n - apples - oranges;
}","}
int main() {
    auto candidate = fruit_distribution;
    assert(candidate((""5 apples and 6 oranges""), (19)) == (8));
    assert(candidate((""5 apples and 6 oranges""), (21)) == (10));
    assert(candidate((""0 apples and 1 oranges""), (3)) == (2));
    assert(candidate((""1 apples and 0 oranges""), (3)) == (2));
    assert(candidate((""2 apples and 3 oranges""), (100)) == (95));
    assert(candidate((""2 apples and 3 oranges""), (5)) == (0));
    assert(candidate((""1 apples and 100 oranges""), (120)) == (19));
}
"
HumanEval/68,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""اگر اکھ ویکٹر چُھ اکس کُلۍ کِس شاخس ہنز نمائندگی کران یتھ منز غٲر منفی عدد نود چِھ آسان تہٕ توہیہٕ سُند کٲم چُھ یہٕ زِ کنہٕ نوڈس پُھٹرو تہٕ بییہٕ بییہٕ لٲوِو۔ پُھٹرن وول گژھہٕ سُہ نوڈ آسن یتھ منز ساروی کھوتہٕ لوکٹ even ویلیو چُھ۔ اگر اکسی لٲٹہٕ even ویلیو ہند متعدد نوڈ چِھ ملان تہٕ بییہٕ کرِو نوڈس واپس یتھ منز ساروی کھوتہٕ لوکٹ انڈیکس چُھ۔ پُھٹرن وول گژھہٕ بییہٕ وول ویلیو واپس ویکٹرس منز، [smallest_value، its index]، اگر نہٕ کنہِ even ویلیو چُھ نہٕ یا یہٕ وول ویکٹر چُھ خٲلی، تہٕ بییہٕ بییہٕ کرِو []۔ مثال 1: >>> pluck{((((stdvector<long>{long}{long}4, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long (long) (long) (long (long) (long) (long) (long (long) (long) (long (long) (long) (long (long) (long (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long (long) (long) (long (long) (long) (long (long) (long) (long (long) (long (long)
std::vector<long> pluck(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> pluck(std::vector<long> arr) {
  if (arr.empty()) {
    return {};
  }
  long min_even = -1;
  long min_index = -1;
  for (long i = 0; i < arr.size(); ++i) {
    if (arr[i] % 2 == 0) {
      if (min_even == -1 || arr[i] < min_even) {
        min_even = arr[i];
        min_index = i;
      }
    }
  }
  if (min_even == -1) {
    return {};
  }
  return {min_even, min_index};
}","}
int main() {
    auto candidate = pluck;
    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));
}
"
HumanEval/69,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چھیہ مثبت عددن ہند اکھ غٲر خالی ویکٹر۔ زیرو کھوتہ بوڑ عدد واپس کرو، تہ امچ فریکوئنسی چھہ پورہ عددس برابر یا اسہِ کھوتہ زیوٹھ۔ پورہ عددچ فریکوئنسی چھہ ویکٹرس منز ظٲہر گژھن وٲلۍ وۅنۍ تعداد۔ اگر نہ یتھ ویلیو موجود آسہِ، تہ واپس کرو -1. مثال: >>> search(((std::vector<long>{(long) 4, (long) 1, (long) 2, (long) 3, (long) 1}))) (2) >>> search(std::vector<(long>{(long) 1, (long) 2, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4, (long) 4} (3)))) >>>(std::vector<(long>{(long) 5, (long) 5, (long) 4, (long) 4, (long) 4-1} (long)))
long search(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long search(std::vector<long> lst) {
  std::map<long, long> counts;
  for (long x : lst) {
    counts[x]++;
  }
  long result = -1;
  for (auto const& [value, count] : counts) {
    if (value > 0 && count >= value) {
      result = std::max(result, value);
    }
  }
  return result;
}","}
int main() {
    auto candidate = search;
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));
    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));
    assert(candidate((std::vector<long>({(long)10}))) == (-1));
    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));
}
"
HumanEval/70,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// انٹیجرز ہند ویکٹر دنہٕ آمت، عجیب ترتیب سۭتۍ چُھ ویکٹر واپس یوان۔ عجیب ترتیب، چُھ ییلہِ تہٕ کم کھوتہٕ کم قدر سۭتۍ شروع گژھِ، تہٕ پتہٕ بقیہ انٹیجرن ہنٛد زیادٕ کھوتہٕ زیادٕ، تہٕ پتہٕ کم کھوتہٕ کم تہٕ بییہٕ۔ مثالہٕ: >>> strange_sort_list{((((std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 4, (long) 2, (long) 3})) >>> strange_sort_list<(((std::vector<long>{(long) 5, (long) 5, (long) 5, (long) 5}))) (std::vector<(long>{(long) 5, (long) 5, (long) 5, (long) 5}))) >>> strange_sort_list<(((((std::vector<(long)) (std::vector))
std::vector<long> strange_sort_list(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> strange_sort_list(std::vector<long> lst) {
  if (lst.empty()) {
    return {};
  }
  std::sort(lst.begin(), lst.end());
  std::vector<long> result;
  long left = 0;
  long right = lst.size() - 1;
  bool take_min = true;
  while (left <= right) {
    if (take_min) {
      result.push_back(lst[left++]);
    } else {
      result.push_back(lst[right--]);
    }
    take_min = !take_min;
  }
  return result;
}","}
int main() {
    auto candidate = strange_sort_list;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));
}
"
HumanEval/71,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// مثلث کہ ترٛیٚو طرفو ہٕنٛز لمبٲیی دنہٕ آمژ۔ مثلث کس رقبس چھ 2 اعشاریہ پوائنٹس تام پھیرنہٕ ییلہ ترٛیٚو طرفو اکھ درست مثلث بناوان چھ۔ بصورت دیگر -1 واپس ییٚلہ ترٛیٚو طرفو ہنٛد مجموعہ ترٛیٚیمہٕ طرفہ کھۄتہٕ زیٛادٕ آسہ، تہٕ سہارٕ طرفہٕ چھ درست مثلث بناوان۔ مثال: >>> triangle_area((3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())
float triangle_area(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>
float triangle_area(long a, long b, long c) {
  if (a + b <= c || a + c <= b || b + c <= a) {
    return -1.0f;
  }
  double s = static_cast<double>(a + b + c) / 2.0;
  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));
  std::stringstream ss;
  ss << std::fixed << std::setprecision(2) << area;
  return std::stof(ss.str());
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((3), (4), (5)) == (6.0f));
    assert(candidate((1), (2), (10)) == (float(-1)));
    assert(candidate((4), (8), (5)) == (8.18f));
    assert(candidate((2), (2), (2)) == (1.73f));
    assert(candidate((1), (2), (3)) == (float(-1)));
    assert(candidate((10), (5), (7)) == (16.25f));
    assert(candidate((2), (6), (3)) == (float(-1)));
    assert(candidate((1), (1), (1)) == (0.43f));
    assert(candidate((2), (2), (10)) == (float(-1)));
}
"
HumanEval/72,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لیوکھمُت یُس صحیح چُھ واپس کران اگر آبجیکٹ q اڑان چُھ، تہٕ غلط بیترِ۔ آبجیکٹ q اڑان چُھ اگر یہٕ متوازن چُھ (یہٕ چُھ اکھ پالنڈرومک ویکٹر) تہٕ امہٕ کیٛن عناصرن ہنٛد مجموعہ چُھ زیادٕ کھوتہٕ کم یا برابر زیادٕ کھوتہٕ زیادٕ ممکنہ وزن w۔ مثال: >>> will_it_fly((std::vector<long>(long>{long>{long>{long}}1, (long>{long}2}) ، (5)) (false) # 1+2 چُھ زیادٕ کھوتہٕ کم ممکنہ وزن، مگر یہٕ چُھ متوازن۔ >>> will_it_fly{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool will_it_fly(std::vector<long> q, long w) {
","#include<assert.h>
#include<bits/stdc++.h>
bool will_it_fly(std::vector<long> q, long w) {
  std::vector<long> reversed_q = q;
  std::reverse(reversed_q.begin(), reversed_q.end());
  if (q != reversed_q) {
    return false;
  }
  long sum = 0;
  for (long val : q) {
    sum += val;
  }
  return sum <= w;
}","}
int main() {
    auto candidate = will_it_fly;
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));
    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));
}
"
HumanEval/73,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// انٹیجرزن ہندس اکس ویکٹرس arr دنہٕ آمت، ویکٹرس پالینڈروم بناونہٕ خاطرٕ کم کھوتہٕ کم عناصرن ہنٛز تعداد تلاش کرُن۔ اکھ پالینڈروم ویکٹر چُھ اکھ ویکٹر یُس پٔتمیو پیٹھہٕ برونٹھ چُھ یوان وُچھنہٕ۔ اکہٕ تبدیلی منٛز، ہیٛکو اکھ عنصر دیمس عنصرس منٛز تبدیل کرتھ۔ مثلن: >>> smallest_change(std::vector<long>({long) 1، (long) 2، (long) 3، (long) 5، (long) 4، (long) 7، (long) 9، (long) 6}))) (4) >>> smallest_change(std::vector<long>{(long) 1، (long) 2، (long) 3، (long) 2، (long) 2} (1) >>> smallest_change(std::vector<long>{(long) 1، (long) 2، (long) 3، (long) 2، (long) 1)))
long smallest_change(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long smallest_change(std::vector<long> arr) {
  long n = arr.size();
  long changes = 0;
  for (long i = 0; i < n / 2; ++i) {
    if (arr[i] != arr[n - 1 - i]) {
      changes++;
    }
  }
  return changes;
}","}
int main() {
    auto candidate = smallest_change;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
}
"
HumanEval/74,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لیوکھ یتھ ز سٹرنگک زٕ ویکٹر چِھ قبول کران تہٕ چُھ سٹرنگک سٹرنگس منٛز کیٛن ویکٹرن ہنٛد کل تعدادس دیمس ویکٹر کھوتہٕ کم واپس کران۔ اگر زٕ ویکٹرن منٛز کیٛن ویکٹرن ہنٛد کل تعداد آسہٕ کم، تیلہٕ گوڑنک ویکٹر چُھ واپس کران۔ مثالہٕ >>> total_match ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}، ({""}) ، ({""}) ، ({""}) ، ({""}) ، ({""}) ، ({""}) ،"" ({""}) ،"" ({""}) ({""}) ({""}) ({""}) ،"" ({""} ({""}) (}) ({""}) ({""}) (}) ({""}) ({""}) (}) ({"" (}) ({"" (}) (}) ({"" (}) (}) ({"" (}) (}) ({"" (}) ({"" (}) (}) (}) ({"" (}) (}) ({"" (}) (}) (}) ({"" (}) (}) (}) ({"" (}) (}) ({"" (}) (}) (} (}) (}) (} (}) ({"" (}) (}) (} (}) (}) ({"" (}) (} (}) (}) (} (}) (
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
  long count1 = 0;
  for (const std::string& s : lst1) {
    count1 += s.length();
  }
  long count2 = 0;
  for (const std::string& s : lst2) {
    count2 += s.length();
  }
  if (count1 <= count2) {
    return lst1;
  } else {
    return lst2;
  }
}","}
int main() {
    auto candidate = total_match;
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi"", (std::string)""admin"", (std::string)""project""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>({(std::string)""4""})), (std::vector<std::string>({(std::string)""1"", (std::string)""2"", (std::string)""3"", (std::string)""4"", (std::string)""5""}))) == (std::vector<std::string>({(std::string)""4""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hii""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)""this""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""this""})), (std::vector<std::string>())) == (std::vector<std::string>()));
}
"
HumanEval/75,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لیوکھو یُس صحیح چُھ واپس کران اگر دِنہٕ آمُت نمبر چُھ 3 پرائم نمبرن ہند ضرب تہٕ بییہٕ غلط۔ یہ زانُن کہ (a) چُھ 100 کھوتہٕ کم۔ مثال: >>> is_multiply_prime((30)) (سچ) 30 = 2 * 3 * 5
bool is_multiply_prime(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_multiply_prime(long a) {
  if (a <= 0) {
    return false;
  }
  std::vector<int> primes;
  std::vector<bool> is_prime(100, true);
  is_prime[0] = is_prime[1] = false;
  for (int p = 2; p * p < 100; p++) {
    if (is_prime[p]) {
      for (int i = p * p; i < 100; i += p)
        is_prime[i] = false;
    }
  }
  for (int p = 2; p < 100; p++) {
    if (is_prime[p]) {
      primes.push_back(p);
    }
  }
  int count = 0;
  for (int p1 : primes) {
    if (a % p1 == 0) {
      count++;
      int rem = a / p1;
      for (int p2 : primes) {
        if (rem % p2 == 0) {
          count++;
          int rem2 = rem / p2;
          for (int p3 : primes) {
            if (rem2 == p3) {
              count++;
              if (count == 3) {
                return true;
              }
              count--;
            }
          }
          count--;
        }
      }
      count--;
    }
  }
  return false;
}","}
int main() {
    auto candidate = is_multiply_prime;
    assert(candidate((5)) == (false));
    assert(candidate((30)) == (true));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (false));
    assert(candidate((125)) == (true));
    assert(candidate((105)) == (true));
    assert(candidate((126)) == (false));
    assert(candidate((729)) == (false));
    assert(candidate((891)) == (false));
    assert(candidate((1001)) == (true));
}
"
HumanEval/76,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہُند کٲم چھُ اکھ فنکشن لیکھُن یُس ٹُرٛیُن لٲگِتھ چھُ اگر کانٛہہ نمبر x چھُ n کِس سادٕس پوٗرٹس منز تہٕ بیٚین صورتن منٛز چھُ جھوٚٹ۔ x چھُ n کِس سادٕس پوٗرٹس منز اگر n**int=x مثالہٕ پٲٹھۍ: >>> is_simple_power((1), (4)) (true) >>> is_simple_power(2), (2)) (true) >>> is_simple_power(8), (2)) (true) >>> is_simple_power(3), (2)) (false) >>> is_simple_power(3), (1)) (false) >>> is_simple_power(5), (3)) (false)
bool is_simple_power(long x, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_simple_power(long x, long n) {
  if (x == n) return true;
  if (n == 1) return x == 1;
  if (n == 0) return x == 0;
  if (x == 0) return false;
  if (x == 1) return true;
  long power = n;
  while (power < x) {
    if (x % n != 0) return false;
    if (power > x / n) return false;
    power *= n;
  }
  return power == x;
}","}
int main() {
    auto candidate = is_simple_power;
    assert(candidate((16), (2)) == (true));
    assert(candidate((143214), (16)) == (false));
    assert(candidate((4), (2)) == (true));
    assert(candidate((9), (3)) == (true));
    assert(candidate((16), (4)) == (true));
    assert(candidate((24), (2)) == (false));
    assert(candidate((128), (4)) == (false));
    assert(candidate((12), (6)) == (false));
    assert(candidate((1), (1)) == (true));
    assert(candidate((1), (12)) == (true));
}
"
HumanEval/77,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لیوکھن یوس اکھ انٹیجر a چُھ نوان تہٕ اگر یہٕ انٹیجر کنٛہہ انٹیجر نمبرُک کیوب چُھ تیلہٕ چُھ صحیح واپس کران۔ نوٹ: توہیہ ہیکہِ یہٕ فرض کرِتھ زِ ان پٹ چُھ ہمیشہٕ درست۔ مثال: >>> iscube((1)) (true) >>> iscube(2)) (false) >>> iscube(-1)) (true) >>> iscube(64)) (true) >>> iscube(0)) (true) >>> iscube((180)) (false)
bool iscube(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool iscube(long a) {
  if (a == 0) return true;
  long abs_a = std::abs(a);
  long root = round(std::cbrt(abs_a));
  return root * root * root == abs_a;
}","}
int main() {
    auto candidate = iscube;
    assert(candidate((1)) == (true));
    assert(candidate((2)) == (false));
    assert(candidate((-1)) == (true));
    assert(candidate((64)) == (true));
    assert(candidate((180)) == (false));
    assert(candidate((1000)) == (true));
    assert(candidate((0)) == (true));
    assert(candidate((1729)) == (false));
}
"
HumanEval/78,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چھیہ اکھ فنکشن لیکھنک کٲم آمت کرنہ یتھ ہیکساڈسیمل نمبر چھ سٹرنگہِ پٲٹھۍ وصول کران تہٕ ہیکساڈسیمل ہندسن ہند تعداد چھ گنتی کران یم پرائم چھ (پرائم نمبر، یا پرائم، چھ اکھ قدرتی نمبر یس 1 کھوتہٕ زیادٕ چھ یس زٕ لکٕٹۍ قدرتی نمبرن ہند پروڈکٹ چُھ نہٕ) ۔ ہیکساڈسیمل ہندسہٕ چھ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F۔ پرائم نمبر چھ 2, 3, 5, 7, 11, 13, 17،...۔ توہیہ چھیہ درج ذیل ہندسن ہند اکھ تعداد مقرر کرن: 2, 3, 5, 7, B (=ڈیسیمل 11), D (=ڈیسیمل 13) ۔ نوٹ: توہیہ ہیکو یہٕ فرض کٔرتھ زِ ان پٹ چُھ ہمیشہ صحیح یا خالی سٹرنگ، تہٕ علامت A،B،C،D،E،F چِھ ہمیشہ اپر لیٹر۔ مثالہ: >>> hex_((AB""کی"") >>> hex_{1} hex_{2}{10}{10{10}{10}{10}{7}{2}{2}{2}{2}{3}{3}{3}3{3}3{3}3{4}3{}3{}3{3}3{}3}3{}3{}4}3{}3{}3{}3{}3}3{}3}3{}4}3{}3{}3{}3}3{}3{}3}3{}4}3{}3}3}3{}3{}3{}3}3}3{}4}3{}3}3}3{}3{}3}3{}3}3}3{}3}3{}3}4}3{}3}3}3{}3}3{}3}3}3{}3{}3}3}3{}3}4}3{}3}3}3{}3}3}3{}3}3}3{}3}3}3{}3
long hex_key(std::string num) {
","#include<assert.h>
#include<bits/stdc++.h>
long hex_key(std::string num) {
  long count = 0;
  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};
  for (char c : num) {
    if (prime_hex.count(c)) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = hex_key;
    assert(candidate((""AB"")) == (1));
    assert(candidate((""1077E"")) == (2));
    assert(candidate((""ABED1A33"")) == (4));
    assert(candidate((""2020"")) == (2));
    assert(candidate((""123456789ABCDEF0"")) == (6));
    assert(candidate((""112233445566778899AABBCCDDEEFF00"")) == (12));
}
"
HumanEval/79,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چِھ اکھ اعشاریہ شکلہٕ منٛز اکھ نمبر دنہٕ یوان تہٕ توہیہٕ ہنٛد کٲم چِھ یہٕ بائنری شکلہٕ منٛز تبدیل کرن۔ فنکشن گژھہٕ اکھ سٹرنگ واپس ین، یتھ منٛز پرتھ کردارس سۭتۍ چُھ اکھ بائنری نمبرچ نمائندگی کران۔ سٹرنگس منٛز پرتھ کردار گژھہٕ '0' یا '1' آسن۔ سٹرنگ کس شروعس تہٕ اختتامس پیٹھ گژھہٕ 'db' ہنٛد اکھ اضأفی جوڑٕ حروف آسن۔ اضأفی حروف چِھ فارمیٹس منٛز مدد کرنہٕ خاطرٕ موجود۔ مثالہٕ: >>> decimal_to_binary((15)) (""db1111db"") >>> decimal_to_binary(32) (""db100000db"")
std::string decimal_to_binary(long decimal) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string decimal_to_binary(long decimal) {
  if (decimal == 0) {
    return ""db0db"";
  }
  std::string binaryString = """";
  long temp = std::abs(decimal);
  while (temp > 0) {
    binaryString = (temp % 2 == 0 ? ""0"" : ""1"") + binaryString;
    temp /= 2;
  }
  return ""db"" + binaryString + ""db"";
}","}
int main() {
    auto candidate = decimal_to_binary;
    assert(candidate((0)) == (""db0db""));
    assert(candidate((32)) == (""db100000db""));
    assert(candidate((103)) == (""db1100111db""));
    assert(candidate((15)) == (""db1111db""));
}
"
HumanEval/80,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چھیہ اکھ سٹرنگ دیتمت۔ توہیہ چھوہ یہ چیک کرن کہ سٹرنگ چھا hapcpp یا نہ۔ اکھ سٹرنگ چھا hapcpp اگر امچ لمبائی کم از کم 3 تہ پرتھ 3 ترتیب وار حروف چھہِ الگ الگ۔ مثال: >>> is_happy((""a"")) (false) >>> is_happy((""aa"")) (false) >>> is_happy((""abcd"")) (true) >>> is_happy((""aabb"")) (false) >>> is_happy(""adb"")) (true) >>> is_happy((""xyy"") (false)
bool is_happy(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_happy(std::string s) {
  if (s.length() < 3) {
    return false;
  }
  for (size_t i = 0; i <= s.length() - 3; ++i) {
    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_happy;
    assert(candidate((""a"")) == (false));
    assert(candidate((""aa"")) == (false));
    assert(candidate((""abcd"")) == (true));
    assert(candidate((""aabb"")) == (false));
    assert(candidate((""adb"")) == (true));
    assert(candidate((""xyy"")) == (false));
    assert(candidate((""iopaxpoi"")) == (true));
    assert(candidate((""iopaxioi"")) == (false));
}
"
HumanEval/81,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// یہ چھ سمسٹرُک ٲخری ہفتہٕ تہٕ اساتذہ چھ طلباءن گریڈ دوان۔ اساتذہ چھ گریڈنگ خٲطرٕ پنن الگورتھم بناوان۔ صرف اکھ مسئلہ چھ یہ زِ سُہ چھ گریڈنگ خٲطرٕ استعمال گژھن وٲل کوڈ کھوژان۔ سُہ چھ توہیہ کینژن طلباءن خٲطرٕ GPAs ہٕنٛدس ویکٹرس دتمت تہ تہٕ توہیہ چھ اکھ فنکشن لیکھان یس لیٹر گریڈس ہٕنٛدس ویکٹرس پٮ۪ٹھ استعمال کران چھ یتھ ٹیبلہٕ استعمال کران: GPA لیٹر گریڈ 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E مثال: >>>_grade_equation""
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
  std::vector<std::string> letter_grades;
  for (float gpa : grades) {
    if (gpa == 4.0f) {
      letter_grades.push_back(""A+"");
    } else if (gpa > 3.7f) {
      letter_grades.push_back(""A"");
    } else if (gpa > 3.3f) {
      letter_grades.push_back(""A-"");
    } else if (gpa > 3.0f) {
      letter_grades.push_back(""B+"");
    } else if (gpa > 2.7f) {
      letter_grades.push_back(""B"");
    } else if (gpa > 2.3f) {
      letter_grades.push_back(""B-"");
    } else if (gpa > 2.0f) {
      letter_grades.push_back(""C+"");
    } else if (gpa > 1.7f) {
      letter_grades.push_back(""C"");
    } else if (gpa > 1.3f) {
      letter_grades.push_back(""C-"");
    } else if (gpa > 1.0f) {
      letter_grades.push_back(""D+"");
    } else if (gpa > 0.7f) {
      letter_grades.push_back(""D"");
    } else if (gpa > 0.0f) {
      letter_grades.push_back(""D-"");
    } else {
      letter_grades.push_back(""E"");
    }
  }
  return letter_grades;
}","}
int main() {
    auto candidate = numerical_letter_grade;
    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)""A+"", (std::string)""B"", (std::string)""C-"", (std::string)""C"", (std::string)""A-""})));
    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)""D+""})));
    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)""D-""})));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)""E""})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)""D"", (std::string)""D-"", (std::string)""C-"", (std::string)""B"", (std::string)""B+""})));
    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)""E"", (std::string)""D-""})));
}
"
HumanEval/82,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لیوکھمُت یُس سٹرنگ چُھ نوان تہٕ اگر سٹرنگچ لمبائی چِھ پرائم نمبر یا غلط آسن تیلہٕ چُھ صحیح واپس کران۔ مثالہٕ >>> prime_length(((""ہیلو"")) (سچ) >>> prime_length((""abcdcba"")) (سچ) >>> prime_length((""کیٹن"")) (سچ) >>> prime_length((""اورنج"")) (غلط)
bool prime_length(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(int n) {
  if (n <= 1) return false;
  for (int i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

bool prime_length(std::string string) {
  return is_prime(string.length());
}","}
int main() {
    auto candidate = prime_length;
    assert(candidate((""Hello"")) == (true));
    assert(candidate((""abcdcba"")) == (true));
    assert(candidate((""kittens"")) == (true));
    assert(candidate((""orange"")) == (false));
    assert(candidate((""wow"")) == (true));
    assert(candidate((""world"")) == (true));
    assert(candidate((""MadaM"")) == (true));
    assert(candidate((""Wow"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""HI"")) == (true));
    assert(candidate((""go"")) == (true));
    assert(candidate((""gogo"")) == (false));
    assert(candidate((""aaaaaaaaaaaaaaa"")) == (false));
    assert(candidate((""Madam"")) == (true));
    assert(candidate((""M"")) == (false));
    assert(candidate((""0"")) == (false));
}
"
HumanEval/83,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ مثبت انٹیجر n دینہٕ آمت، n ہندسہٕ ہند مثبت انٹیجرن ہند تعداد یُس 1 سۭتۍ شروع یا ختم چُھ گژھان، یُس گنتی چُھ کران۔
long starts_one_ends(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long starts_one_ends(long n) {
  if (n <= 0) {
    return 0;
  }
  if (n == 1) {
    return 1;
  }
  long starts_with_one = std::pow(10, n - 1);
  long ends_with_one = std::pow(10, n - 1);
  long starts_and_ends_with_one = std::pow(10, n - 2);
  return starts_with_one + ends_with_one - starts_and_ends_with_one;
}","}
int main() {
    auto candidate = starts_one_ends;
    assert(candidate((1)) == (1));
    assert(candidate((2)) == (18));
    assert(candidate((3)) == (180));
    assert(candidate((4)) == (1800));
    assert(candidate((5)) == (18000));
}
"
HumanEval/84,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// مثبت عدد N دنہٕ آمت، امہٕ کہ ہندسن ہند مجموعہ چُھ بائنری منٛز واپس کران۔ مثال >>> حل کریں((1000)) (""1"") >>> حل کریں((150)) (""110"") >>> حل کریں((147)) (""1100"") متغیرات: @N انٹیجر پابندیاں: 0 ≤ N ≤ 10000. آؤٹ پٹ: بائنری نمبرن ہنٛز اکھ تار
std::string solve(long N) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string solve(long N) {
  if (N < 0 || N > 10000) {
    return """"; // Or handle invalid input as needed
  }
  long sum = 0;
  std::string s = std::to_string(N);
  for (char c : s) {
    sum += c - '0';
  }
  if (sum == 0) {
    return ""0"";
  }
  std::string binary_sum = """";
  while (sum > 0) {
    binary_sum = (sum % 2 == 0 ? ""0"" : ""1"") + binary_sum;
    sum /= 2;
  }
  return binary_sum;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((1000)) == (""1""));
    assert(candidate((150)) == (""110""));
    assert(candidate((147)) == (""1100""));
    assert(candidate((333)) == (""1001""));
    assert(candidate((963)) == (""10010""));
}
"
HumanEval/85,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// انٹیجرزن ہند اکھ غٲر خٲلی ویکٹر دِنہٕ آمت۔ lst۔ جوڑٕ جوڑ عناصر یم عجیب انڈیکسس پیٹھ چِھ ۔ مثالہٕ: >>> add((std::vector<long>({(long) 4, (long) 2, (long) 6, (long) 7}))) (2)
long add(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long add(std::vector<long> lst) {
  long sum = 0;
  for (long i = 1; i < lst.size(); i += 2) {
    if (lst[i] % 2 == 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add;
    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));
    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));
    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));
}
"
HumanEval/86,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لیوکھ یتھ سٹرنگ چُھ نیوان تہٕ امک اکھ آرڈرڈ ورژن چُھ واپس کران۔ سٹرنگک آرڈرڈ ورژن چُھ اکھ سٹرنگ ییتہٕ تمام الفاظ (جدا کرتھ) اکس نئس لفظس سۭتۍ چِھ تبدیل یوان کرنہٕ یتہٕ تمام کردار چِھ ascii ویلیو کہ بنیادس پیٹھ بڑھون ترتیبس منٛز ترتیب دینہٕ یوان۔ نوٹ: توہیہ گژھہٕ جملس منٛز الفاظ تہٕ خالی جگہوں ہینز ترتیب برقرار تھون۔ مثلن: >>> anti_shuffle((""Hi"")) (""Hi"") >>> anti_shuffle((""hello"")) (""ehllo"") >>> anti_shuffle""(Hello World!!!"")) (""Hello !!!Wdlor"")
std::string anti_shuffle(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string anti_shuffle(std::string s) {
  std::string result = """";
  std::string current_word = """";
  for (char c : s) {
    if (c == ' ') {
      std::sort(current_word.begin(), current_word.end());
      result += current_word;
      result += c;
      current_word = """";
    } else {
      current_word += c;
    }
  }
  std::sort(current_word.begin(), current_word.end());
  result += current_word;
  return result;
}","}
int main() {
    auto candidate = anti_shuffle;
    assert(candidate((""Hi"")) == (""Hi""));
    assert(candidate((""hello"")) == (""ehllo""));
    assert(candidate((""number"")) == (""bemnru""));
    assert(candidate((""abcd"")) == (""abcd""));
    assert(candidate((""Hello World!!!"")) == (""Hello !!!Wdlor""));
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hi. My name is Mister Robot. How are you?"")) == ("".Hi My aemn is Meirst .Rboot How aer ?ouy""));
}
"
HumanEval/87,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چھِ اکھ 2 جہتی ڈیٹا، یس نیسٹڈ ویکٹرز کہ طور پٲنٹھ، میٹرکس ہشہٕ، تاہم، میٹرکس برعکس، پرتھ صفس منٛز ہیکہٕ کالمن ہینز اکھ مختلف تعداد آستھ۔ lst، تہٕ انٹیجر x دنہٕ آمت، ویکٹرس منٛز انٹیجرز x ژھانٛڈو، تہٕ ٹپلزن ہنٛد واپسی ویکٹر، [(x1, y1), (x2, y2) ...] یتھ پٲنٹھ زِ پرتھ ٹپل چُھ اکھ کوآرڈینیٹ - (صف، کالم) ، شروع گژھن وٲل 0. ابتدائی طور پٲنٹھ چُھ کوآرڈینیٹس چُھ صفن پیٹھہٕ آرڈر کران۔ نیز، کالمن ہنٛد کوآرڈینیٹس چُھ آرڈرنگس منٛز ترتیب دینہٕ یوان۔ مثالہٕ: >>> get_row(std::vector<std::vector<st><long>، تاہم، ہر صف ہیکہٕ مختلف تعدادس منٛز کالمن پیٹھ مشتمل آستھ۔ (1) ، تہٕ انٹیجر x دنہٕ آمت، تہٕ واپسی ویکٹر چھِ ٹپلزن ہنٛد ویکٹر، [(x1, y1), یتھ پٲن کہ پرتھ ٹپللن ہنٛد واپسی ویکٹر چُھ 0 سۭتۍ شروع گژھان۔
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
  std::vector<std::tuple<long, long>> coordinates;
  for (long i = 0; i < lst.size(); ++i) {
    std::vector<std::pair<long, long>> row_coords;
    for (long j = 0; j < lst[i].size(); ++j) {
      if (lst[i][j] == x) {
        row_coords.push_back({j, i});
      }
    }
    std::sort(row_coords.rbegin(), row_coords.rend());
    for (const auto& coord_pair : row_coords) {
      coordinates.emplace_back(coord_pair.second, coord_pair.first);
    }
  }
  return coordinates;
}","}
int main() {
    auto candidate = get_row;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));
    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));
}
"
HumanEval/88,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// غیر منفی عددن ہند ویکٹر دنہٕ آمت، ترتیب دینہٕ پتہٕ دینہٕ آمت ویکٹرُک کوکی پی پی واپس کرُن، اگر رقم (پہلا انڈیکس ویلیو، آخری انڈیکس ویلیو) عجیب چُھ، تہٕ اگر رقم (پہلا انڈیکس ویلیو، آخری انڈیکس ویلیو) چُھ جڑتھ، تہٕ اگر یہٕ ترتیب ترتیب ترتیب ترتیب چُھ، تہٕ اگر یہٕ رقم (پہلا انڈیکس ویلیو، آخری انڈیکس ویلیو) چُھ ہموار، تہٕ توہیہ چِھ ترتیب دینہٕ آمت۔ نوٹ: * دیتمت ویکٹر مت بدلاون۔ مثالہٕ: >>> sort_array{d}: vector<long> ({d}: vector<long>) ({d}: vector<long>) (long>) (long>) (long>) (long>) (long>) (long>) (long>) (long>) (long>) (long>) (long> (long>) (long>) (long> (long>) (long>) (long> (long>) (long>) (long> (long>) (long> (long>) (long>) (long> (long>) (long> (long>) (long>long> (long>) (long>long>) (long>long> (long>) (long>long>long> (long>) (long>long>long>long> (long>) (long>long>long>long>long>long> (long>long>long>long>long>) (long>long>long>long>long>long>long>long>long>long> (<<<<<<<) (long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long (long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long
std::vector<long> sort_array(std::vector<long> array) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> sort_array(std::vector<long> array) {
  std::vector<long> sorted_array = array;
  if (sorted_array.empty()) {
    return sorted_array;
  }
  long first = 0;
  long last = sorted_array.size() - 1;
  if ((first + last) % 2 != 0) {
    std::sort(sorted_array.begin(), sorted_array.end());
  } else {
    std::sort(sorted_array.rbegin(), sorted_array.rend());
  }
  return sorted_array;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));
    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));
    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));
    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));
}
"
HumanEval/89,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن انکرپٹ بناو یُس اکھ سٹرنگ بطور دلیل چُھ نیوان تہٕ اکھ سٹرنگ چُھ واپس کران یتھ منٛز الفٔبیٹ چُھ روٹ کرنہٕ یوان۔ الفٔبیٹ گژھہٕ یتھ پأٹھۍ روٹ کرنہٕ ین زِ حرف گژھن دوٛن مقاماتن پیٹھ زٕ ضرب سۭتۍ نیبَر منتقل۔ مثلن: >>> انکرپٹ (((""hi"")) (""lm"") >>> انکرپٹ (((""asdfghjkl"")) (""ewhjklnop"") >>> انکرپٹ (((""gf"")) (""kj"") >>> انکرپٹ (((""et"")) (""ix"")
std::string encrypt(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encrypt(std::string s) {
  std::string encrypted_s = """";
  int shift = 2 * 2;
  for (char c : s) {
    if (isalpha(c)) {
      char base = islower(c) ? 'a' : 'A';
      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);
    } else {
      encrypted_s += c;
    }
  }
  return encrypted_s;
}","}
int main() {
    auto candidate = encrypt;
    assert(candidate((""hi"")) == (""lm""));
    assert(candidate((""asdfghjkl"")) == (""ewhjklnop""));
    assert(candidate((""gf"")) == (""kj""));
    assert(candidate((""et"")) == (""ix""));
    assert(candidate((""faewfawefaewg"")) == (""jeiajeaijeiak""));
    assert(candidate((""hellomyfriend"")) == (""lippsqcjvmirh""));
    assert(candidate((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")) == (""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""));
    assert(candidate((""a"")) == (""e""));
}
"
HumanEval/90,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہہ چھہِ انٹیجرزک اکھ ویکٹر دنہ آمت۔ اکھ فنکشن لیوکھ next_smallest() یوس ویکٹرُک 2nd لۄکُٹ عنصر واپس چھُ کران۔ ییلہِ نہٕ یتھہِ کٔنۍ عنصر آسہِ واپس چھُ نٔن۔ >>> next_smallest(std::vector<long>(long) 1، 2، 3، 4، 5، 6، 7، 8، 9، 11، 12، 13، 14، 15، 16، 17، 18، 19، 19، 20، 20، 20، 20، 20، 21، 21، 22، 22، 23، 22، 23، 24، 23، 24، 25، 25، 26، 27، 28، 29، 29، 29، 29، 29، 29، 29، 30، 30، 30، 30، 30، 31، 31، 31، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 33، 32، 32، 32، 32، 32، 33، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32، 32
std::optional<long> next_smallest(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> next_smallest(std::vector<long> lst) {
  if (lst.size() < 2) {
    return std::nullopt;
  }
  std::sort(lst.begin(), lst.end());
  if (lst[0] == lst[1]) {
    return std::nullopt;
  }
  return lst[1];
}","}
int main() {
    auto candidate = next_smallest;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);
    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);
}
"
HumanEval/91,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چِھ لفظن ہند اکھ تار وون، تہٕ توہیہ چِھ ٹاسک بورڈمن ہند تعداد گنُن۔ بورڈ چُھ اکھ جملہ یوس لفظ ""I"" سٕتۍ شروع چُھ گژھان۔ جملہ چِھ '.', '?' یا '! سٕتۍ محدود۔ مثالہٕ پٲٹھۍ: >>> is_bored((""ہیلو ورلڈ"")) (0) >>> is_bored((""آسمان چُھ نیلا۔ آفتاب چُھ چمکان۔ میہ چُھ یتھہِ موسمس پسند کران"")) (1)
long is_bored(std::string S) {
","#include<assert.h>
#include<bits/stdc++.h>
long is_bored(std::string S) {
  long boredom_count = 0;
  std::string current_sentence = """";
  for (char c : S) {
    current_sentence += c;
    if (c == '.' || c == '?' || c == '!') {
      std::stringstream ss(current_sentence);
      std::string first_word;
      ss >> first_word;
      if (first_word == ""I"") {
        boredom_count++;
      }
      current_sentence = """";
    }
  }
  return boredom_count;
}","}
int main() {
    auto candidate = is_bored;
    assert(candidate((""Hello world"")) == (0));
    assert(candidate((""Is the sky blue?"")) == (0));
    assert(candidate((""I love It !"")) == (1));
    assert(candidate((""bIt"")) == (0));
    assert(candidate((""I feel good today. I will be productive. will kill It"")) == (2));
    assert(candidate((""You and I are going for a walk"")) == (0));
}
"
HumanEval/92,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن بنٲوِتھ یُس 3 نمبرن نِش ہیکہِ تھٲوِتھ۔ اگر اکھ نمبر بیین دۄن ہندس مجموعس برابر آسہِ تہٕ تمام نمبر آسہِ انٹیجر۔ بیین صورتن منز چُھ غلط واپس گژھان۔ مثالہٕ >>> any_int{(float{(5)) ، (float{(2)) ، (float{(7))) (true) >>> any_int{(((float{(3)) ، (float{(2)) ، (float{(2))) (false) >>> any_int{((float{(3)) ، (float{(-2) ، (float{(1))) (true) >>> any_int{(((3.6f) ، (-2.2f) ، (float{(2))) (false)
bool any_int(float x, float y, float z) {
","#include<assert.h>
#include<bits/stdc++.h>
bool any_int(float x, float y, float z) {
  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {
    return false;
  }
  long ix = static_cast<long>(x);
  long iy = static_cast<long>(y);
  long iz = static_cast<long>(z);
  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);
}","}
int main() {
    auto candidate = any_int;
    assert(candidate((float(2)), (float(3)), (float(1))) == (true));
    assert(candidate((2.5f), (float(2)), (float(3))) == (false));
    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));
    assert(candidate((float(2)), (float(6)), (float(2))) == (false));
    assert(candidate((float(4)), (float(2)), (float(2))) == (true));
    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));
    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));
    assert(candidate((float(2)), (float(1)), (float(1))) == (true));
    assert(candidate((float(3)), (float(4)), (float(7))) == (true));
    assert(candidate((3.0f), (float(4)), (float(7))) == (false));
}
"
HumanEval/93,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لیوکھُن یُس اکھ پیغام چُھ نوان، تہٕ اتھ پٮ۪ٹھ کوڈ چُھ لگٲون یتھ پٮ۪ٹھ یہ تمام حروفن ہٕندۍ کیس بدلاوان چُھ، تہٕ تمام وولن چُھ میسجس منز اتھ حروفس سٕتۍ بدلاوان یُس انگریزی الفبِیہ منز وولس برونٛہہ 2 جایہٕ چُھ آسان۔ صرف حروف چِھ فرض کران۔ مثالہٕ: >>> encode((""test"")) (""TGST"") >>> encode((""یہ چُھ اکھ پیغام"")) (""tHKS KS C MGSSCGG"")
std::string encode(std::string message) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encode(std::string message) {
  std::string encoded_message = """";
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  std::map<char, char> vowel_map = {
      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},
      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};
  for (char c : message) {
    if (isalpha(c)) {
      char swapped_case = islower(c) ? toupper(c) : tolower(c);
      if (vowels.count(c)) {
        encoded_message += vowel_map[c];
      } else {
        encoded_message += swapped_case;
      }
    } else {
      encoded_message += c;
    }
  }
  return encoded_message;
}","}
int main() {
    auto candidate = encode;
    assert(candidate((""TEST"")) == (""tgst""));
    assert(candidate((""Mudasir"")) == (""mWDCSKR""));
    assert(candidate((""YES"")) == (""ygs""));
    assert(candidate((""This is a message"")) == (""tHKS KS C MGSSCGG""));
    assert(candidate((""I DoNt KnOw WhAt tO WrItE"")) == (""k dQnT kNqW wHcT Tq wRkTg""));
}
"
HumanEval/94,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہہ چھہِ انٹیجرن ہند اکھ ویکٹر دنہ آمت۔ توہہ چھہِ امہِ ہند زیٹھین پرائم ویلیو ژھانڈنہ تہ امہِ ہند ہندسن ہند مجموعہ واپس کرنہ۔ مثالہ: >>> skjkasdkdd((std::vector<long>((long) 0، (long) 3، (long) 2، (long) 1، (long) 3، (long) 4، (long) 7، (long) 5، (long) 5، (long) 2، (long) 2، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 4، (long) 3، (long) 3، (long) 3، (long) 8، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long (long) (long) (long) (long (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long (long) (long) (long (long) (long) (long (long) (long) (long (long)
long skjkasdkd(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

long sum_digits(long n) {
  long sum = 0;
  std::string s = std::to_string(n);
  for (char c : s) {
    sum += c - '0';
  }
  return sum;
}

long skjkasdkd(std::vector<long> lst) {
  long largest_prime = -1;
  for (long num : lst) {
    if (num > largest_prime && is_prime(num)) {
      largest_prime = num;
    }
  }
  if (largest_prime == -1) {
    return 0;
  }
  return sum_digits(largest_prime);
}","}
int main() {
    auto candidate = skjkasdkd;
    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));
    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));
    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));
    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)8191}))) == (19));
    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));
    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));
}
"
HumanEval/95,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// نقشہٕ دنہٕ آمت، اگر تمام چابہٕ لوئر کیس منٛز تار چِھ یا تمام چابہٕ ہیرن منٛز تار چِھ آسان تہٕ اگر نہٕ تیلہٕ غلط چُھ واپس کران۔ فنکشن گژھ غلط واپس کرن دیتمت چُھ نقشہٕ خٲلی۔ مثالہٕ: >>> check_dict_case(((std::map<std::string,std::string>(({{""a"", ""apple""}, {""b"", ""banana""}}))) (true) >>> check_dict_case((((std::map,std::string>{{""a"", ""apple""}, {""A"", ""banana""}, {""B"", ""banana""}}))) (غلط) >>> check_dict_case_map{""a"", ""banana""}, {""B"", ""map""}}))) (غلط) >>> check_dict_case_map{""a"", ""apple""}, {""banana""}, {""a"", {""a"", ""}, {""apple""}:std::std::string:std::string> (غلط) >>> check_case_string>{{""A"", ""{{""A"", ""apple""std""apple""}}، {""std}}، ""{{""apple"":std_std_std}}""apple"":std""std""}}</string> ({{""A"", ""{{""apple""apple""apple""apple""apple""}}، ""}}""}}""}}</string_st:st:st:std ""{{""}}""}}""{{""}}""Ctrue"": ""{{""}}""}}""{{""Ctrue:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st
bool check_dict_case(std::map<std::string,std::string> dict) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_dict_case(std::map<std::string,std::string> dict) {
  if (dict.empty()) {
    return false;
  }
  bool first_key_lower = false;
  bool first_key_upper = false;
  auto it = dict.begin();
  if (!it->first.empty() && islower(it->first[0])) {
    first_key_lower = true;
  } else if (!it->first.empty() && isupper(it->first[0])) {
    first_key_upper = true;
  } else {
    return false;
  }
  for (const auto& pair : dict) {
    if (pair.first.empty()) {
      return false;
    }
    bool current_lower = true;
    bool current_upper = true;
    for (char c : pair.first) {
      if (!islower(c)) {
        current_lower = false;
      }
      if (!isupper(c)) {
        current_upper = false;
      }
    }
    if (first_key_lower && !current_lower) {
      return false;
    }
    if (first_key_upper && !current_upper) {
      return false;
    }
    if (!first_key_lower && !first_key_upper) {
        if (current_lower) first_key_lower = true;
        else if (current_upper) first_key_upper = true;
        else return false;
    }
  }
  return first_key_lower || first_key_upper;
}","}
int main() {
    auto candidate = check_dict_case;
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""b"", ""banana""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""A"", ""banana""}, {""B"", ""banana""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""5"", ""banana""}, {""a"", ""apple""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""STATE"", ""NC""}, {""ZIP"", ""12345""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""fruit"", ""Orange""}, {""taste"", ""Sweet""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>())) == (false));
}
"
HumanEval/96,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن چُھ نافذ کران یُس اکھ غأر منفی عدد چُھ نیوان تہٕ گۄڈنکی n عددن ہنٛد ویکٹر چُھ واپس کران یم پرائم نمبر چِھ تہٕ n کھوتہٕ کم چِھ۔ مثلن: >>> count_up_to((5)) (std::vector<long>{(long) 2، (long) 3)) >>> count_up_to(11) (std::vector<long>{(long) 2، (long) 3، (long) 5، (long) 7)) >>> count_up_to(0)) (std::vector<long>) >>> count_up_to(20)) (std::vector<long>{(2, (long) 3، (long) 5، (long) 7، (long) 11، (long) 13، (long) 17، (long) >>> count_up_to_1) (std::vector<long>1، (long) 8، (long) 3، (long) 5، (long) 17، (long) (long) 1، (long) (long) 3، (long)) (long)
std::vector<long> count_up_to(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long num) {
  if (num <= 1) return false;
  for (long i = 2; i * i <= num; ++i) {
    if (num % i == 0) return false;
  }
  return true;
}

std::vector<long> count_up_to(long n) {
  std::vector<long> primes;
  if (n <= 2) {
    return primes;
  }
  for (long i = 2; i < n; ++i) {
    if (is_prime(i)) {
      primes.push_back(i);
    }
  }
  return primes;
}","}
int main() {
    auto candidate = count_up_to;
    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));
    assert(candidate((0)) == (std::vector<long>()));
    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));
    assert(candidate((1)) == (std::vector<long>()));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));
    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));
}
"
HumanEval/97,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فنکشن مکمل یُس زٕ انٹیجر چھ نوان تہٕ یمن ہٕنٛدیٚن اکٲیی ہندسن ہٕنٛدۍ پٲداوار واپس چھ کران۔ فرض کرو ز ان پٹ چھ ہمیشہ موٗجوٗد۔ مثال: >>> ضرب (۱۴۸) (۴۱۲) (۱۶) >>> ضرب (۱۹) (۲۸) (۷۲) >>> ضرب (۲۰) (۱۸۵۱) (۰) >>> ضرب (۱۴) (۱۵) (۲۰)
long multiply(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>
long multiply(long a, long b) {
  long unit_a = std::abs(a) % 10;
  long unit_b = std::abs(b) % 10;
  return unit_a * unit_b;
}","}
int main() {
    auto candidate = multiply;
    assert(candidate((148), (412)) == (16));
    assert(candidate((19), (28)) == (72));
    assert(candidate((2020), (1851)) == (0));
    assert(candidate((14), (-15)) == (20));
    assert(candidate((76), (67)) == (42));
    assert(candidate((17), (27)) == (49));
    assert(candidate((0), (1)) == (0));
    assert(candidate((0), (0)) == (0));
}
"
HumanEval/98,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ سٹرنگ s دنہٕ آمت، اپرکیسٕل ووکلن ہندس تعدادس چُھ برابر انڈیکسس منز شمار کران۔ مثالہٕ پٲٹھۍ: >>> count_upper((""aBCdEf"")) (1) >>> count_upper((""abcdefg"")) (0) >>> count_upper((""dBBE"")) (0)
long count_upper(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long count_upper(std::string s) {
  long count = 0;
  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};
  for (long i = 0; i < s.length(); ++i) {
    if (i % 2 == 0 && upper_vowels.count(s[i])) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_upper;
    assert(candidate((""aBCdEf"")) == (1));
    assert(candidate((""abcdefg"")) == (0));
    assert(candidate((""dBBE"")) == (0));
    assert(candidate((""B"")) == (0));
    assert(candidate((""U"")) == (1));
    assert(candidate(("""")) == (0));
    assert(candidate((""EEEE"")) == (2));
}
"
HumanEval/99,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن بنٲوِتھ یُس اکھ قدر (سٹرینگ) چُھ ننیوان یوس اکھ نمبرٕچ نمائندگی کران چُھ تہٕ اتھ قریب ترین عدد چُھ واپس کران۔ اگر یہ نمبر زٕ عددن سٕتۍ چُھ برابر، تہٕ چُھس صفرٕ نِش دور کران۔ مثالہٕ >>> closest_integer((""10"")) (10) >>> closest_integer((""15.3"")) (15) نوٹ: صفرٕ نِش دور گژھنُک مطلب چُھ یہ زِ اگر دِنہٕ آمُت عدد زٕ عددن سٕتۍ چُھ برابر، تہٕ توہیہ گژھہِ یہٕ واپس کرنُک زِ یوس صفرٕ نِش دور چُھ آسان سُہٕ چُھ یوس صفرٕ نِش دور چُھ۔ مثلن closest_integer(""14.5"") گژھہِ 15 واپس کرن تہٕ closest_integer""-14.5"") گژھہِ -15.
long closest_integer(std::string value) {
","#include<assert.h>
#include<bits/stdc++.h>
long closest_integer(std::string value) {
  double num = std::stod(value);
  if (num >= 0) {
    if (num - std::floor(num) <= 0.5) {
      return static_cast<long>(std::floor(num));
    } else {
      return static_cast<long>(std::ceil(num));
    }
  } else {
    if (std::ceil(num) - num <= 0.5) {
      return static_cast<long>(std::ceil(num));
    } else {
      return static_cast<long>(std::floor(num));
    }
  }
}","}
int main() {
    auto candidate = closest_integer;
    assert(candidate((""10"")) == (10));
    assert(candidate((""14.5"")) == (15));
    assert(candidate((""-15.5"")) == (-16));
    assert(candidate((""15.3"")) == (15));
    assert(candidate((""0"")) == (0));
}
"
HumanEval/100,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ مثبت عدد n دنہٕ آمت، توہیہ چُھ پتھرن ہنٛد n سطحن ہنٛد اکھ ڈھیر بناون۔ گۄڈنچ سطحس منٛز چِھ n پتھر۔ پتکین سطحن ہنٛد تعداد چُھ: - اگر n عجیب چُھ تیلہٕ چُھ اگمی عجیب نمبر۔ - اگر n جوڑ چُھ تیلہٕ چُھ اگمی جوڑ نمبر۔ ہر سطحس منٛز پتھرن ہنٛد تعداد چُھ ویکٹر منٛز واپس کران، یتہٕ عنصر انڈیکس i سطحس منٛز پتھرن ہنٛد تعدادچ نمائندگی چُھ کران (i+1) ۔ مثال: >>> make_a_pile(3) (std::vector<long>{long) 3، (long) 5، (long) 7}))
std::vector<long> make_a_pile(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> make_a_pile(long n) {
  std::vector<long> pile;
  long current_stones = n;
  for (int i = 0; i < n; ++i) {
    pile.push_back(current_stones);
    if (current_stones % 2 != 0) {
      current_stones += 2;
    } else {
      current_stones += 2;
    }
  }
  return pile;
}","}
int main() {
    auto candidate = make_a_pile;
    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));
    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));
    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));
    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));
    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));
}
"
HumanEval/101,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چھِ لفظن ہند اکھ تار یتھ کما یا اسپیسن سۭتۍ الگ کرنہٕ آمت۔ توہیہ چھِ سٹرنگس لفظن منٛز تقسیم کرُن تہٕ لفظن ہند ویکٹر واپس کرُن۔ مثال: >>> words_string((""ہیو، میہٕ ناو چھُ جان"")) (std::vector<std::string>({(std::string) ""ہیو، (std::string) ""میٛون""، (std::string) ""نام""، (std::string) ""یہٕ چُھ""، (std::string) ""جان""}) >>> words_string((""اکھ، زٕ، ترٛے، ژور، پانٛژ، شۄد"")) (std::vector<std::string>{(stdstring) ""اکھ، زٕ، زٕ، زٕ، ترٛے""، "" (stdstring) ""، (stdstring) "" (std::string) "" (stdstring) ""): (stdstring))
std::vector<std::string> words_string(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> words_string(std::string s) {
  std::vector<std::string> words;
  std::string current_word;
  for (char c : s) {
    if (c == ',' || c == ' ') {
      if (!current_word.empty()) {
        words.push_back(current_word);
        current_word = """";
      }
    } else {
      current_word += c;
    }
  }
  if (!current_word.empty()) {
    words.push_back(current_word);
  }
  return words;
}","}
int main() {
    auto candidate = words_string;
    assert(candidate((""Hi, my name is John"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name"", (std::string)""is"", (std::string)""John""})));
    assert(candidate((""One, two, three, four, five, six"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate((""Hi, my name"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name""})));
    assert(candidate((""One,, two, three, four, five, six,"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""ahmed     , gamal"")) == (std::vector<std::string>({(std::string)""ahmed"", (std::string)""gamal""})));
}
"
HumanEval/102,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// یہٕ فنکشن چُھ زٕ مثبت نمبر x تہٕ y نوان تہٕ چُھ ساری کھوتہٕ بڑُھ جُز تعداد واپس کران یُس حد [x، y] تام چُھ آسان۔ اگر ییتھ نمبر چُھ نہٕ، تیلہٕ فنکشن گژھ -1 واپس کرن۔ مثلن: >>> choose_num (((12), (15)) (14) >>> choose_num (((13), (12)) (-1)
long choose_num(long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>
long choose_num(long x, long y) {
  if (x > y) {
    return -1;
  }
  long end = y;
  if (end % 2 != 0) {
    end--;
  }
  if (end < x) {
    return -1;
  }
  return end;
}","}
int main() {
    auto candidate = choose_num;
    assert(candidate((12), (15)) == (14));
    assert(candidate((13), (12)) == (-1));
    assert(candidate((33), (12354)) == (12354));
    assert(candidate((5234), (5233)) == (-1));
    assert(candidate((6), (29)) == (28));
    assert(candidate((27), (10)) == (-1));
    assert(candidate((7), (7)) == (-1));
    assert(candidate((546), (546)) == (546));
}
"
HumanEval/103,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// توہہ چھہِ زہ مثبت عدد n تہٕ m دنہ آمت، تہٕ توہہِ کامہ چھہ n پیٹھہٕ m تام عددن ہنز اوسطُک حساب لگاون۔ جوابس قریب ترین عددس تام کرو کرو گول تہٕ یہِ بائنری نمبرس منز تبدیل کرُن۔ اگر n چُھ m کھوتہٕ بڈ، تہٕ -1 واپس کرُن۔ مثال: >>> rounded_avg((1), (5)) ""0b11"" >>> rounded_avg(7), (5)) -1 >>> rounded_avg(10), (20)) ""0b1111"" >>> rounded_avg(20), (33) ""0b11010""
Union_std_string_long rounded_avg(long n, long m) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;
    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_string_long rounded_avg(long n, long m) {
  if (n > m) {
    return Union_std_string_long(-1);
  }
  double sum = 0;
  for (long i = n; i <= m; ++i) {
    sum += i;
  }
  double avg = sum / (m - n + 1);
  long rounded_avg_long = std::round(avg);
  if (rounded_avg_long == 0) {
    return Union_std_string_long(""0b0"");
  }
  std::string binary_string = """";
  long temp = std::abs(rounded_avg_long);
  while (temp > 0) {
    binary_string = (temp % 2 == 0 ? ""0"" : ""1"") + binary_string;
    temp /= 2;
  }
  return Union_std_string_long(""0b"" + binary_string);
}","}
int main() {
    auto candidate = rounded_avg;
    assert(candidate((1), (5)) == ""0b11"");
    assert(candidate((7), (13)) == ""0b1010"");
    assert(candidate((964), (977)) == ""0b1111001010"");
    assert(candidate((996), (997)) == ""0b1111100100"");
    assert(candidate((560), (851)) == ""0b1011000010"");
    assert(candidate((185), (546)) == ""0b101101110"");
    assert(candidate((362), (496)) == ""0b110101101"");
    assert(candidate((350), (902)) == ""0b1001110010"");
    assert(candidate((197), (233)) == ""0b11010111"");
    assert(candidate((7), (5)) == -1);
    assert(candidate((5), (1)) == -1);
    assert(candidate((5), (5)) == ""0b101"");
}
"
HumanEval/104,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// مثبت عدد x ہند ویکٹر دیتھ، تمام عناصرن ہند اکھ ترتیب شدہ ویکٹر چُھ واپس کران یتھ منز کنٛہہ تہٕ عدد چُھ نہٕ آسان۔ نوٹ: واپس کرنہٕ آمُت ویکٹر گژھہِ بڑن واجنہِ ترتیبس منز ترتیب دنہٕ یِن۔ مثال: >>> unique_digits(std::vector<long>({long) 15، (long) 33، (long) 142، (long) 1}))) (std::vector<long>{(long) 1، (long) 15، (long) 33})) >>> unique_digits(std::vector<long>{(long) 152، (long) 323، (long) 142، (long) 10}))) (std::vector<long>(long))
std::vector<long> unique_digits(std::vector<long> x) {
","#include<assert.h>
#include<bits/stdc++.h>
bool has_even_digit(long n) {
  std::string s = std::to_string(n);
  for (char c : s) {
    if ((c - '0') % 2 == 0) {
      return true;
    }
  }
  return false;
}

std::vector<long> unique_digits(std::vector<long> x) {
  std::vector<long> result;
  for (long val : x) {
    if (!has_even_digit(val)) {
      result.push_back(val);
    }
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = unique_digits;
    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));
    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));
    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));
}
"
HumanEval/105,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// انٹیجرزن ہند ویکٹر دنہٕ آمت، انٹیجرزن یِم 1 تہٕ 9 شٲمل چِھ آسان، ترتیب دیو، نتیجہٕ ویکٹر الٹہٕ، تہٕ پَتہٕ پرتھ ہندسہٕ امہٕ کہ متعلقہٕ ناوٕ سۭتۍ تبدیل کرو ""1""، ""2""، ""3""، ""4""، ""5""، ""6""، ""7""، ""8""، ""9"" مثلن: >>> by_length:{st:string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string:}<string: (long:}<string:}<string: (long:}<string: (long:}<string: ({st:string:}<string:}<string: ({st:}<string:}<string: ({string:}<string: ({string:}<string: (string: (string: (string: (string) (string: (string) (string: (string) (string: (string) (string: (string) (string: (string) (string) (string: (string) (string) (string: (string) (string) (string (string) (string) (string (string) (string) (string) (string (string) (string) (string) (string (string) (string) (string (string) (string) (string) (string) (string (string) (string) (string) (string (string) (string) (string (string) (string) (string) (string (string) (string) (string (string) (string) (string (
std::vector<std::string> by_length(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> by_length(std::vector<long> arr) {
  std::vector<long> valid_numbers;
  std::vector<std::string> result;
  std::map<long, std::string> number_names = {
      {1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""}, {5, ""Five""},
      {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}};
  for (long num : arr) {
    if (num >= 1 && num <= 9) {
      valid_numbers.push_back(num);
    }
  }
  std::sort(valid_numbers.begin(), valid_numbers.end());
  std::reverse(valid_numbers.begin(), valid_numbers.end());
  for (long num : valid_numbers) {
    result.push_back(number_names[num]);
  }
  return result;
}","}
int main() {
    auto candidate = by_length;
    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)""Eight"", (std::string)""Five"", (std::string)""Four"", (std::string)""Three"", (std::string)""Two"", (std::string)""Two"", (std::string)""One"", (std::string)""One""})));
    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)""One""})));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)""Three"", (std::string)""Two"", (std::string)""One""})));
    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)""Nine"", (std::string)""Eight"", (std::string)""Four""})));
}
"
HumanEval/106,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فنکشن f یُس n بطور پیرامیٹر چُھ نوان، تہٕ n سائزُک ویکٹر چُھ واپس کران، یتھ کٔنۍ زِ انڈیکس i پیٹھ عنصرچ قدر i ہند فیکٹوریل چِھ اگر i چُھ برابر یا 1 پیٹھ i تام اعدادن ہند مجموعہ۔ i چُھ 1 پیٹھ شروع گژھان۔ i ہند فیکٹوریل چُھ 1 پیٹھ i تام اعدادن ہند ضرب (1 * 2 * ... * i) ۔ مثال: >>> f((5)) (std::vector<long>{(long) 1, (long) 2, (long) 6, (long) 24, (long) 15}))
std::vector<long> f(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> f(long n) {
  std::vector<long> result;
  for (long i = 1; i <= n; ++i) {
    if (i % 2 == 0) {
      long factorial = 1;
      for (long j = 1; j <= i; ++j) {
        factorial *= j;
      }
      result.push_back(factorial);
    } else {
      long sum = 0;
      for (long j = 1; j <= i; ++j) {
        sum += j;
      }
      result.push_back(sum);
    }
  }
  return result;
}","}
int main() {
    auto candidate = f;
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));
}
"
HumanEval/107,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// مثبت عدد n دنہٕ آمت، اکھ ٹپل واپس ییتھ منٛز even تہٕ odd انٹیجر پالنڈرومچ تعداد آسہٕ یُس حدٕ اندر چُھ آسان (تجزیہ: 1) ۔ >>> even_odd_palindrome ({1, n}) ، بشمول۔ مثال 1: >>> even_odd_palindrome ({1, n}) (std::make_tuple ({1, 2)) وضاحت: انٹیجر پالنڈروم چِھ 1، 2، 3۔ یمن منٛز چُھ اکھ even تہٕ دۄن چِھ odd۔ مثال 2: >>> even_odd_palindrome ({1}) (std::make_tuple ({4, 6)) وضاحت: انٹیجر پالنڈروم چِھ 1، 2، 3، 4، 5، 6، 7، 8، 9، 11۔ یمن منٛز چِھ ژور even تہٕ 6 odd۔ نوٹ: 1 <= n = 10 ^ 3 2۔ واپس آو ٹپلچ تعداد بالترتیب even تہٕ odd انٹیجر پالنڈرومچ چِھ۔
std::tuple<long, long> even_odd_palindrome(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_palindrome(long num) {
  std::string s = std::to_string(num);
  std::string reversed_s = s;
  std::reverse(reversed_s.begin(), reversed_s.end());
  return s == reversed_s;
}

std::tuple<long, long> even_odd_palindrome(long n) {
  long even_count = 0;
  long odd_count = 0;
  for (long i = 1; i <= n; ++i) {
    if (is_palindrome(i)) {
      if (i % 2 == 0) {
        even_count++;
      } else {
        odd_count++;
      }
    }
  }
  return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_palindrome;
    assert(candidate((123)) == (std::make_tuple(8, 13)));
    assert(candidate((12)) == (std::make_tuple(4, 6)));
    assert(candidate((3)) == (std::make_tuple(1, 2)));
    assert(candidate((63)) == (std::make_tuple(6, 8)));
    assert(candidate((25)) == (std::make_tuple(5, 6)));
    assert(candidate((19)) == (std::make_tuple(4, 6)));
    assert(candidate((9)) == (std::make_tuple(4, 5)));
    assert(candidate((1)) == (std::make_tuple(0, 1)));
}
"
HumanEval/108,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لکھو count_nums یُس انٹیجرزن ہیند ویکٹر چُھ نیوان تہٕ چُھ عناصرک تعداد واپس کران یتھ منٛز ہندسن ہند مجموعہ چُھ > 0۔ اگر اکھ نمبر منفی چُھ، تیلہٕ چُھ امک گوڑنک دستخط شدہ ہندسہ منفی آسہٕ: مثلن -123 چُھ ہندسن -1، 2، تہٕ 3 پیٹھ دستخط آمت کرنہٕ: >>> count_nums{(std::vector<long>())) (0) >>> count_nums{(std::vector<long>{(long) - 1، (long) 11، (long) - 11}))) (1) >>> count_nums::std::vector<long>{(long) 1، (long) 1، (long) 2} (3))))
long count_nums(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_digits_signed(long n) {
  std::string s = std::to_string(n);
  long sum = 0;
  for (long i = 0; i < s.length(); ++i) {
    if (i == 0 && s[i] == '-') {
      if (s.length() > 1) {
        sum -= (s[i + 1] - '0');
        i++;
      }
    } else {
      sum += (s[i] - '0');
    }
  }
  return sum;
}

long count_nums(std::vector<long> arr) {
  long count = 0;
  for (long num : arr) {
    if (sum_digits_signed(num) > 0) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_nums;
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));
    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));
    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
}
"
HumanEval/109,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اسہِ چِھ اکھ ویکٹر 'آرر' N عددن ہند۔ ویکٹر چِھ بے ترتیب ترتیب آمت کرنہٕ۔ توہیہٕ سُہٕ ییہٕ وَننہٕ زِ کیاہ چُھ ممکن زِ ویکٹر گژھہٕ غٲر کم گژھنہٕ والین ترتیبس منٛز ترتیب دنہٕ۔ توہیہٕ چِھ یہٕ وَننہٕ یِوان زِ کیاہ چُھ ممکن کہ اکھ ویکٹر گژھہٕ غٲر کم گژھنہٕ والین ترتیبس منٛز ترتیب دنہٕ یُس دِنہٕ آمت آپریشن چُھ کران۔ توہیہٕ چِھ دِنہٕ آمت دٲیکھہٕ پیٹھہٕ بۄن آپریشن کرُن: توہیہٕ چِھ دٲیکھس پیٹھہٕ بۄن آپریشن کرُن یُس وَنُن چُھ کہ ویکٹر کہ تمام عناصرن دٲیکھس پوزیشنہٕ پیٹھہٕ دٲیکھس سمتہٕ منتقل کرُن۔ ویکٹرُک ٲخری عنصر چُھ وُن ویکٹر کہ آغاز کہ پوزیشنس پیٹھ منتقل کرنہٕ یُن یعنی 0th انڈیکس انڈیکس۔ اگر یہٕ آپریشن کرُن چُن ممکن چُن تہٕ تہٕ صحیح چُہٕ بیاکھ واپس بیاکھ واپس بیاکھ کرنہٕ یُن۔ اگر دٲس ویکٹر چُک خٲلی چُہٕ تہٕ تہٕ بیاکھ خٲلی چُن بیاکھ تہٕ واپس بیاکھ بیاکھ واپس۔ نو بیاکھ صحیح۔ نو بیاکھ واپس بیاکھ کرنہٕ۔ نو بیاکھ وُن۔ نوٹہٕ۔
bool move_one_ball(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
bool move_one_ball(std::vector<long> arr) {
  if (arr.empty()) {
    return true;
  }
  int n = arr.size();
  std::vector<long> sorted_arr = arr;
  std::sort(sorted_arr.begin(), sorted_arr.end());
  for (int shift = 0; shift < n; ++shift) {
    std::vector<long> shifted_arr(n);
    for (int i = 0; i < n; ++i) {
      shifted_arr[i] = arr[(i - shift + n) % n];
    }
    if (shifted_arr == sorted_arr) {
      return true;
    }
  }
  return false;
}","}
int main() {
    auto candidate = move_one_ball;
    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
}
"
HumanEval/110,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اتھ مسلس منز، کرِہ توہی اکھ فنکشن یم زٕ نمبر ویکٹر لیوکھ، تہٕ یہٕ طے کرِہ زِ کیا یمن درمیان چُھ عناصرن ہند تبادلہ کرن ممکن تاکہ صرف lst1 ہیکو even نمبرن ہند ویکٹر بناوِتھ۔ lst1 تہٕ lst2 درمیان چُھ نہٕ تبدیل کرنہٕ آمتین عناصرن ہندس تعدادس پیٹھ کنہہ حد۔ اگر lst1 تہٕ lst2 درمیان عناصرن ہند تبادلہ کرن ممکن چُھ تاکہ lst1 ہیک تمام عناصر برابر آستھ، توہی چِھ ""YES"" واپس کران۔ بصورت دیگر، توہی چِھ ""NO"" واپس کران۔ مثالہٕ پٲٹھۍ: >>> exchange(std::vector<>(long) 1, (long) 2, (long) 3, (long) 4}) ، (std::vector<>(long) 1, (long) 2, (long) 3, (long) 4}) ، (std::vector<>(long 1، (long) 3، (long) 4)) (""YES"") >>> exchange:{(std::vector<>{(long}، (long) (long 4) (""YES"") (""YES"") (""YES"") پیٹھہٕچِہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕہٕ
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
  long odd_count_lst1 = 0;
  for (long num : lst1) {
    if (num % 2 != 0) {
      odd_count_lst1++;
    }
  }
  long even_count_lst2 = 0;
  for (long num : lst2) {
    if (num % 2 == 0) {
      even_count_lst2++;
    }
  }
  if (even_count_lst2 >= odd_count_lst1) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = exchange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (""YES""));
}
"
HumanEval/111,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اگر اکھ سٹرنگ چُھ اکھ اسپیس سیپیرایڈ لۄکٹسٹری حروفچ نمائندگی کران، تیلہٕ لیٹرچ نقشہٕ ییتھ منٛز زیادٕ تر تکرار چِھ آسان تہٕ اتھ منٛز چُھ متعلقہ گنتی آسان واپس کرٕن۔ اگر کنہہ حروف چِھ اَکیٛن واقعاتن ہنٛد، تیلہٕ یمن تمام لوٛب واپس کرٕن۔ مثال: >>> histogram{""a"", 1}, {""b"", 1}, {""c"", 1}}) >>> histogram{""a"", 2}, {""b"", 2}})) >>> histogram{""a, b, c, b"") (std::map{""a, b, b, b""} >>> histogram{""a, b, b, b, b, b, b, b, b, b, b, b, b, b, b, c, d, e, f, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g
std::map<std::string,long> histogram(std::string test) {
","#include<assert.h>
#include<bits/stdc++.h>
std::map<std::string,long> histogram(std::string test) {
  std::map<std::string, long> counts;
  std::string current_word;
  std::stringstream ss(test);
  while (ss >> current_word) {
    counts[current_word]++;
  }
  if (counts.empty()) {
    return {};
  }
  long max_count = 0;
  for (const auto& pair : counts) {
    if (pair.second > max_count) {
      max_count = pair.second;
    }
  }
  std::map<std::string, long> result;
  for (const auto& pair : counts) {
    if (pair.second == max_count) {
      result[pair.first] = pair.second;
    }
  }
  return result;
}","}
int main() {
    auto candidate = histogram;
    assert(candidate((""a b b a"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c a b"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c d g"")) == (std::map<std::string,long>({{""a"", 1}, {""b"", 1}, {""c"", 1}, {""d"", 1}, {""g"", 1}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate((""b b b b a"")) == (std::map<std::string,long>({{""b"", 4}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate(("""")) == (std::map<std::string,long>()));
    assert(candidate((""a"")) == (std::map<std::string,long>({{""a"", 1}})));
}
"
HumanEval/112,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ٹاسک چِھ دوٛن سٹرنگن s تہٕ c دنہٕ آمت، توہیہ چُھ اتھ منٛز موجود تمام کردار حذف کرنچ ضرورت یُس c منٛز کنہٕ تہٕ کردارس برابر چُھ تہٕ پتہٕ چیک کرٕ اگر نتیجہٕ سٹرنگ چھ پالینڈروم۔ سٹرنگس چُھ پالینڈروم وننہٕ یوان اگر یہٕ برونٹھ پتھ کُن چُھ ہاوان۔ توہیہ پزِ چیک کرنہٕ خاطرٕ نتیجہٕ سٹرنگ تہٕ صحیح/غلطس پیٹھ مشتمل ٹپل واپس کرُن۔ مثال >>> reverse_delete{""abcde""}، (""ae"")) (std::make_tuple{""bcd""}، false)) >>> reverse_delete{""abcdef""}، (""b"") (std::make_tuple{""acdef""}، (""b"") (std::make_tuple{""abcded""}، false))
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
","#include<assert.h>
#include<bits/stdc++.h>
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
  std::string result = """";
  std::unordered_set<char> chars_to_delete(c.begin(), c.end());
  for (char ch : s) {
    if (chars_to_delete.find(ch) == chars_to_delete.end()) {
      result += ch;
    }
  }
  std::string reversed_result = result;
  std::reverse(reversed_result.begin(), reversed_result.end());
  return std::make_tuple(result, result == reversed_result);
}","}
int main() {
    auto candidate = reverse_delete;
    assert(candidate((""abcde""), (""ae"")) == (std::make_tuple(""bcd"", false)));
    assert(candidate((""abcdef""), (""b"")) == (std::make_tuple(""acdef"", false)));
    assert(candidate((""abcdedcba""), (""ab"")) == (std::make_tuple(""cdedc"", true)));
    assert(candidate((""dwik""), (""w"")) == (std::make_tuple(""dik"", false)));
    assert(candidate((""a""), (""a"")) == (std::make_tuple("""", true)));
    assert(candidate((""abcdedcba""), ("""")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""abcdedcba""), (""v"")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""vabba""), (""v"")) == (std::make_tuple(""abba"", true)));
    assert(candidate((""mamma""), (""mia"")) == (std::make_tuple("""", true)));
}
"
HumanEval/113,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// سٹرنگن ہند اکھ ویکٹر، یتہِ پرتھ سٹرنگس منز چِھ صرف ہندسہٕ آسان، چُھ اکھ ویکٹر واپس کران۔ آؤٹ پٹُک پرتھ عنصر i گژھہِ ""1"" ان پٹ کہِ سٹرنگ i منز عجیب عناصرن ہند تعداد ""1"" آسن۔ یتہِ تمام i گژھہِ ان پٹ کہِ i مہِ سٹرنگس منز عجیب ہندسن ہند تعداد سٕتۍ تبدیل گژھُن ۔ >>> odd_count{""}{""}} ({""}):{""} ({""}:{""}:{""} ({""}:{""}:{""}:{""}:{""} ({""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}:{""}: 8}: 8}: 8}: 8}: 8 ""8"" سٹرنگسٹرنگس منز چُھ عجیب عناصرن ہند تعداد 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 4n 5۔""})
std::vector<std::string> odd_count(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> odd_count(std::vector<std::string> lst) {
  std::vector<std::string> result;
  for (const std::string& s : lst) {
    int count = 0;
    for (char c : s) {
      if ((c - '0') % 2 != 0) {
        count++;
      }
    }
    std::string count_str = std::to_string(count);
    std::string modified_s = s;
    for (char& c : modified_s) {
      if (isdigit(c) && (c - '0') % 2 != 0) {
        c = count_str[0];
      }
    }
    result.push_back(""the number of odd elements "" + count_str + ""n the str"" + modified_s + ""ng "" + modified_s + "" of the "" + modified_s + ""nput."");
  }
  return result;
}","}
int main() {
    auto candidate = odd_count;
    assert(candidate((std::vector<std::string>({(std::string)""1234567""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 4n the str4ng 4 of the 4nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""3"", (std::string)""11111111""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (std::string)""the number of odd elements 8n the str8ng 8 of the 8nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""271"", (std::string)""137"", (std::string)""314""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 2n the str2ng 2 of the 2nput."", (std::string)""the number of odd elements 3n the str3ng 3 of the 3nput."", (std::string)""the number of odd elements 2n the str2ng 2 of the 2nput.""})));
}
"
HumanEval/114,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// انٹیجرز اینومرز ہندس ویکٹرس دیتتھ، نمبرن ہند کنہ تہٕ غٲر خٲلی ذیلی ویکٹرُک کم کھوتہٕ کم مجموعہٕ ژھانٛڈٕو۔ مثال >>> minSubArraySum(((std::vector<long>({long) 2، (long) 3، (long) 4، (long) 1، (long) 2، (long) 4}))) (1) >>> minSubArraySum(std::vector<long>{(long) 1، (long) 2، (long) 3}))) (-6)
long minSubArraySum(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>
long minSubArraySum(std::vector<long> nums) {
  if (nums.empty()) {
    throw std::invalid_argument(""Input vector cannot be empty."");
  }
  long min_so_far = nums[0];
  long current_min = nums[0];
  for (size_t i = 1; i < nums.size(); ++i) {
    current_min = std::min(nums[i], current_min + nums[i]);
    min_so_far = std::min(min_so_far, current_min);
  }
  return min_so_far;
}","}
int main() {
    auto candidate = minSubArraySum;
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));
    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));
    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));
    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));
    assert(candidate((std::vector<long>({(long)-10}))) == (-10));
    assert(candidate((std::vector<long>({(long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));
}
"
HumanEval/115,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہہ چھہِ کنہِ ہندِس بُتھس منز اکھ مستطیل گرڈ دِنہ آمت۔ پرتھ صفس منز چھیہ اکھ بُتھ تہٕ پرتھ صفس منز چھیہ اکھ آبچ اکٲئی۔ پرتھ بُتھس منز چھیہ اکھ بالٹی یس اتھ منز آب ننہ خاطرہ استعمال ہکو کٔرتھ۔ تہٕ تمام بالٹی چھہِ ہوی گنجٲیشہ تھاوان۔ توہہُند کٲم چھہ بُتھہِ ہندِ استعمال کرُن بُتھہ خالی کرنُک۔ بُتھہِ ہند تعداد آوٹ پٹ کرنہٕ خٲطرٕ۔ مثال 1: >>> max_fill((std::vector<std::vector<std::vector<long><long>0, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long)
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
","#include<assert.h>
#include<bits/stdc++.h>
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
  long bucket_lowering_count = 0;
  for (const auto& row : grid) {
    long water_in_well = 0;
    for (long unit : row) {
      water_in_well += unit;
    }
    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;
  }
  return bucket_lowering_count;
}","}
int main() {
    auto candidate = max_fill;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));
}
"
HumanEval/116,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اتھ کٹاہس منز چُھ توہیہِ منفی عددن ہند ویکٹر ترتیب دینہٕ یوان تہٕ تہندِ بائنری نمائندگی منز چُھ یمن ہند تعداد بڑھنہٕ یوان۔ یتھی تعدادس خٲطرٕہ چُھ اعشاریہ قدرس پیٹھ مبنی ترتیب دینہٕ یوان۔ اتھ گژھہِ ییتہٕ نافذ کرنہٕ: >>> sort_array((std::vector<long>{(long) 1, (long) 5, (long) 2, (long) 3, (long) 4، (long) 5))) (std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5)) >>> sort_array(std::vector<long>{(long>{(long-2, (long) 3, (long) 4, (long) 5, (long) 6} (std::vector<long>{(long>{-6, (long) 5, (long-4, (long) 3, (long) 2} >>> array_array:d::vector<long>{(long>0, (long>long}{long}long 2, (long)) (long) 3, (long)) (long) 4، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long (long) (long) (long) (long) (long) (long) (long (long) (long (long) (long) (long) (long)) (long (long (long)) (long))
std::vector<long> sort_array(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
int count_set_bits(long n) {
  int count = 0;
  if (n < 0) {
    n = std::abs(n);
  }
  while (n > 0) {
    n &= (n - 1);
    count++;
  }
  return count;
}

bool compare(long a, long b) {
  int bits_a = count_set_bits(a);
  int bits_b = count_set_bits(b);
  if (bits_a != bits_b) {
    return bits_a < bits_b;
  }
  return a < b;
}

std::vector<long> sort_array(std::vector<long> arr) {
  std::sort(arr.begin(), arr.end(), compare);
  return arr;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));
    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
}
"
HumanEval/117,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اگر سٹرنگ s چُھ خٲلی تہٕ فنکشن گژھہٕ خٲلی ویکٹر واپس۔ نوٹ: توہہ ہیکہِ یہٕ فرض کٔرِتھ زِ ان پٹ سٹرنگ چِھ صرف لیٹرز تہٕ سپیسز۔ مثالہٕ: >>> select_words((""مارۍ ٲس اکھ لَکٹِچ لَمل"""") ، (4)) (std::vector<std::string>({(std::string) ""لَکٹِچ""}) ، >>> select_words<(""مارۍ ٲس اکھ لَکٹِچ لَمل"") ، (3)) (std::vector<std::string>({(std::string) ""مارۍ""، (std::string) ""لَمل""}، >>> select_words""سادہ سفید""""، (2) (std::vector<std::string>(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> select_words(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_consonant(char c) {
  c = tolower(c);
  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');
}

std::vector<std::string> select_words(std::string s, long n) {
  std::vector<std::string> result;
  std::string current_word;
  for (char c : s) {
    if (c == ' ') {
      long consonant_count = 0;
      for (char word_char : current_word) {
        if (is_consonant(word_char)) {
          consonant_count++;
        }
      }
      if (consonant_count == n) {
        result.push_back(current_word);
      }
      current_word = """";
    } else {
      current_word += c;
    }
  }
  long consonant_count = 0;
  for (char word_char : current_word) {
    if (is_consonant(word_char)) {
      consonant_count++;
    }
  }
  if (consonant_count == n) {
    result.push_back(current_word);
  }
  return result;
}","}
int main() {
    auto candidate = select_words;
    assert(candidate((""Mary had a little lamb""), (4)) == (std::vector<std::string>({(std::string)""little""})));
    assert(candidate((""Mary had a little lamb""), (3)) == (std::vector<std::string>({(std::string)""Mary"", (std::string)""lamb""})));
    assert(candidate((""simple white space""), (2)) == (std::vector<std::string>()));
    assert(candidate((""Hello world""), (4)) == (std::vector<std::string>({(std::string)""world""})));
    assert(candidate((""Uncle sam""), (3)) == (std::vector<std::string>({(std::string)""Uncle""})));
    assert(candidate((""""), (4)) == (std::vector<std::string>()));
    assert(candidate((""a b c d e f""), (1)) == (std::vector<std::string>({(std::string)""b"", (std::string)""c"", (std::string)""d"", (std::string)""f""})));
}
"
HumanEval/118,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چھ اکھ لفظ دنہ آمت۔ توہیہ چھوہ اکھ وۅنۍ نزدیک وول وچھان یس دۅن مصمتن درمیان چھہ (لفظن ہنز ترتیب) ۔ لفظس آغاز تہ اختتامس منز وۅنۍ وۅنۍ وۅنۍ وۅنۍ چھنہ شمار کرنہ یوان۔ اگر توہیہ وۅنۍ کنہِ تہِ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ وۅنۍ چھہ صرف انگریزی حرف۔ مثال: >>> get_closest_vowel "" ((""yogurt"")) (""u"") >>> get_closest_vowel "" (FULL"") (""U"") >>> get_closest_vowel "" (quick"") ("""")
std::string get_closest_vowel(std::string word) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_vowel(char c) {
  c = tolower(c);
  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');
}

bool is_consonant(char c) {
  return isalpha(c) && !is_vowel(c);
}

std::string get_closest_vowel(std::string word) {
  if (word.length() < 3) {
    return """";
  }
  for (int i = word.length() - 2; i >= 1; --i) {
    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {
      return std::string(1, word[i]);
    }
  }
  return """";
}","}
int main() {
    auto candidate = get_closest_vowel;
    assert(candidate((""yogurt"")) == (""u""));
    assert(candidate((""full"")) == (""u""));
    assert(candidate((""easy"")) == (""""));
    assert(candidate((""eAsy"")) == (""""));
    assert(candidate((""ali"")) == (""""));
    assert(candidate((""bad"")) == (""a""));
    assert(candidate((""most"")) == (""o""));
    assert(candidate((""ab"")) == (""""));
    assert(candidate((""ba"")) == (""""));
    assert(candidate((""quick"")) == (""""));
    assert(candidate((""anime"")) == (""i""));
    assert(candidate((""Asia"")) == (""""));
    assert(candidate((""Above"")) == (""o""));
}
"
HumanEval/119,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چھہِ دوٛن تارن ہند اکھ ویکٹر دِنہ آمت، دۄنوے تار چِھ صرف اوپن parentheses '(' یا بند parentheses ') ' پیٹھ مشتمل۔ توہیہُن کامہ چُھ یہ چیک کرن زِ کیاہ چھہِ دوٛن تارن کنہِ ترتیبس منز جوڑنہٕ آمت، زِ نتیجہٕ گژھہِ سٹرنگ اصل۔ اکھ سٹرنگ S چُھ اصل اگر تہٕ صرف اگر S منز چِھ تمام parentheses متوازن۔ مثالہٕ پٲٹھۍ: سٹرنگ '((()) ' چِھ اصل، ییلہِ زَن سٹرنگ '(()) ' چِھ نہٕ اصل۔ اگر اکھ اصل سٹرنگ بناونک طریقہٕ آسہِ، تہٕ 'YES' واپس کرِتھ، تہٕ بییہٕ 'NO' واپس کرِتھ۔ مثالہ: >>> match_parens(std::vector<std::string>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((())))))))))))))))))))))))))))))))))))))))))))))
std::string match_parens(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_good(const std::string& s) {
  int balance = 0;
  for (char c : s) {
    if (c == '(') {
      balance++;
    } else if (c == ')') {
      balance--;
    }
    if (balance < 0) {
      return false;
    }
  }
  return balance == 0;
}

std::string match_parens(std::vector<std::string> lst) {
  std::string s1 = lst[0];
  std::string s2 = lst[1];
  if (is_good(s1 + s2) || is_good(s2 + s1)) {
    return ""Yes"";
  } else {
    return ""No"";
  }
}","}
int main() {
    auto candidate = match_parens;
    assert(candidate((std::vector<std::string>({(std::string)""()("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)"")""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()(())"", (std::string)""())())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")())"", (std::string)""(()()(""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(())))"", (std::string)""(()())((""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""()"", (std::string)""())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()("", (std::string)""()))()""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(((("", (std::string)""((())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")(()"", (std::string)""(()(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")("", (std::string)"")(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)""(""}))) == (""Yes""));
}
"
HumanEval/120,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ ویکٹر arr یُس انٹیجرز تہٕ اکھ مثبت انٹیجر k چُھ دیوان، آر آر منٛز زیادٕ کھوتہٕ زیادٕ k نمبرن سۭتۍ لمبائی k ہنٛد ترتیب دینہٕ آمت ویکٹر واپس ییہٕ دنہٕ۔ مثال 1: >>> maximum((std::vector<long>({long) - 3، (long) -4، (long) -5}) ، (3)) (std::vector<long>({long) -4، (long) -3، (long) -5}) مثال 2: >>> maximum(std::vector<long>({long) 4، (long) -4، (long) 4}) ، (2)) (std::vector<long>{long}4، (long) 4)) مثال 3: >>> maximum(std::vector<long>{long} - 3، (long) 2، (long) 1، (long) 2، (long) 1، (long) 1، (long) (1) (std::vector<long>2}) ویکٹرچ لمبائی 1000 کہِ اندر گژھہٕ ۔ نوٹ: ویکٹر چُھ 1000 کہِن عناصرن ہنٛز حدس منٛز آسان۔ لین -1، 2، 1000۔
std::vector<long> maximum(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> maximum(std::vector<long> arr, long k) {
  std::sort(arr.rbegin(), arr.rend());
  std::vector<long> result;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    result.push_back(arr[i]);
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = maximum;
    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));
    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));
    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));
    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));
    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));
}
"
HumanEval/121,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// انٹیجرزن ہند اکھ غٲر خٲلی ویکٹر دِنہٕ آمت، تمام عجیب عناصرن ہند مجموعہٕ یُس برابر پوزیشنن پیٹھ چُھ، چُھ واپس کران۔ مثالہٕ >>> solution((std::vector<long>({long) 5، (long) 8، (long) 7، (long) 1}))) (12) >>> solution(((std::vector<long>({long) 3، (long) 3، (long) 3، (long) 3}))) (9) >>> solution((std::vector<long>({long) 30، (long) 13، (long) 24، (long) 321}))) (0)
long solution(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long solution(std::vector<long> lst) {
  long sum = 0;
  for (long i = 0; i < lst.size(); i += 2) {
    if (lst[i] % 2 != 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = solution;
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));
    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));
    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));
    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));
}
"
HumanEval/122,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// آر آر تہٕ اکھ انٹیجر k ہنٛد غٲر خٲلی ویکٹر دِنہٕ آمت، آر آر کیٛن گوڑنکیٛن k عناصرن منٛز زیادٕ کھوتہٕ زیادٕ دوٛن ہندسن سۭتۍ عناصرن ہیند مجموعہٕ چُھ واپس کران۔ مثال: >>> add_elements{}std::vector<long>{(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9}) ، (4)) (24) پابندیاں: 1. 1 <= len{arr) <= 100 2. 1 <= k <= len{arr})
long add_elements(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
long add_elements(std::vector<long> arr, long k) {
  long sum = 0;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    if (arr[i] >= -99 && arr[i] <= 99) {
      sum += arr[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add_elements;
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));
    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));
    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));
    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));
    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));
}
"
HumanEval/123,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// مثبت عدد n دنہٕ آمت، چھُ اکھ ترتیب وٕچھنہٕ آمت ویکٹر واپس یوان یتھ منٛز کُلٹز ترتیبس منٛز عجیب نمبر آسن۔ کُلٹز قیاس چُھ ریاضی منٛز اکھ قیاس یُس اکس ترتیبس متعلق چھُ یتھ کٔنۍ بیان کرنہٕ آمت: کنہ تہٕ مثبت عددس سۭتۍ شروع کرو n۔ پَتہٕ پرتھ اصطلاحس پٔتِمہٕ اصطلاح سۭتۍ یِتھہٕ پأنٹھ حٲصل یِوان: اگر پٔتِمہٕ اصطلاح چِھ برابر، تیلہٕ چِھ ینہٕ وٲل اصطلاح پچھم اصطلاحک اکھ نصف۔ اگر پٔتِمہٕ اصطلاح چِھ عجیب، تیلہٕ چِھ ینہٕ وٲل اصطلاح پچھم اصطلاحک 3 گنا زیادٕ 1۔ قیاس چُھ یہٕ زِ n یُس قدر آسہٕ نہٕ، ترتیب چِھ ہمیشہ 1 تام واتان۔ نوٹ: 1. کُلٹز ((1) چُھ [1] ۔ 2. واپس آمت ویکٹر چُھ بڑھون ترتیبس منٛز ترتیب دینہٕ آمت۔ مثال پٲٹھ: get_odd_collatz5) واپس چُھ یوان [1, 5] 5 خاطرٕ کُھ کُلٹز ترتیب 5 خاطرٕ [5, 8, 16, 4, 2, 1، لہذا عجیب نمبر چِھ 1، تہٕ 5۔ >>> کُلٹز_کولیٹز (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> get_odd_collatz(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> get_odd_collatz(long n) {
  std::vector<long> odd_numbers;
  std::unordered_set<long> seen;
  long current = n;
  while (seen.find(current) == seen.end()) {
    seen.insert(current);
    if (current % 2 != 0) {
      odd_numbers.push_back(current);
    }
    if (current == 1) {
      break;
    }
    if (current % 2 == 0) {
      current /= 2;
    } else {
      current = 3 * current + 1;
    }
  }
  std::sort(odd_numbers.begin(), odd_numbers.end());
  return odd_numbers;
}","}
int main() {
    auto candidate = get_odd_collatz;
    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));
    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
}
"
HumanEval/124,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چھِ اکھ فنکشن لیکھان یُس دِنہٕ آمتِس ڈیٹ سٹرنگس درست کران چھِ تہٕ اگر ڈیٹ چھِ درست تیلہٕ چُھ غلط واپس کران۔ ڈیٹ چِھ درست اگر یم تمام قواعد پورٕ گژھن: 1. ڈیٹ سٹرنگ چِھ نہٕ خٲلی۔ 2. مہینن خاطرٕ چِھ دوہن ہینز تعداد کم کھوتہٕ کم 1 یا زیادٕ 31 دوہ۔ تہٕ مہینن خاطرٕ چِھ دوہن ہینز تعداد کم کھوتہٕ کم 1 یا زیادٕ 30 دوہ۔ تہٕ، مہینن خاطرٕ چِھ دوہن ہینز تعداد کم کھوتہٕ کم 1 یا زیادٕ 29 دوہ۔ 3. مہینن ہینز تعداد گژھ نہٕ کم کھوتہٕ کم 1 یا زیادٕ گژھت۔ 4. ڈیٹ گژھہٕ فارمیٹس منٛز آسن: mm-dd-yyyy >>> valid_(date(((01-15-2012)) (true) >>> valid_date(((01-15-2012"")) (false) >>> valid_date((04-2040"") (false) >>>valid_(((((06-2020) (true) >>>valid_date (false)
bool valid_date(std::string date) {
","#include<assert.h>
#include<bits/stdc++.h>
bool valid_date(std::string date) {
  if (date.empty()) {
    return false;
  }
  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {
    return false;
  }
  int month, day, year;
  try {
    month = std::stoi(date.substr(0, 2));
    day = std::stoi(date.substr(3, 2));
    year = std::stoi(date.substr(6, 4));
  } catch (const std::invalid_argument& e) {
    return false;
  } catch (const std::out_of_range& e) {
    return false;
  }
  if (month < 1 || month > 12) {
    return false;
  }
  if (day < 1) {
    return false;
  }
  if (month == 2) {
    if (day > 29) {
      return false;
    }
  } else if (month == 4 || month == 6 || month == 9 || month == 11) {
    if (day > 30) {
      return false;
    }
  } else {
    if (day > 31) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = valid_date;
    assert(candidate((""03-11-2000"")) == (true));
    assert(candidate((""15-01-2012"")) == (false));
    assert(candidate((""04-0-2040"")) == (false));
    assert(candidate((""06-04-2020"")) == (true));
    assert(candidate((""01-01-2007"")) == (true));
    assert(candidate((""03-32-2011"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""04-31-3000"")) == (false));
    assert(candidate((""06-06-2005"")) == (true));
    assert(candidate((""21-31-2000"")) == (false));
    assert(candidate((""04-12-2003"")) == (true));
    assert(candidate((""04122003"")) == (false));
    assert(candidate((""20030412"")) == (false));
    assert(candidate((""2003-04"")) == (false));
    assert(candidate((""2003-04-12"")) == (false));
    assert(candidate((""04-2003"")) == (false));
}
"
HumanEval/125,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// لفظن ہندس تارس دیتتھ، سفیدس پیٹھ تقسیم گژھن والن الفاظن ہندس ویکٹرس واپس کرُن، اگر متنس منٛز سفیدس پیٹھ کنہہ تہٕ جایہٕ نہٕ آسن تم گژھن کماہس پیٹھ تقسیم گژھت۔'، اگر کنہہ تہٕ جایہٕ نہٕ آسن تہٕ تہٕ توہہٕ الفباہس منٛز عجیب ترتیب سۭتۍ لوئر کیسزک حروفن ہنٛز تعداد گژھہٕ واپس کرُن، آرڈ (a) = 0، آرڈ (b) = 1، ... آرڈ (z) = 25 مثالہٕ >>> تقسیم_ الفاظ (d) >>> تقسیم_ الفاظ (d) >>> تقسیم_ الفاظ (d) >>> تقسیم_ الفاظ (d)
Union_std_vector_std_string__long split_words(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;
    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_vector_std_string__long split_words(std::string txt) {
  if (txt.find(' ') != std::string::npos) {
    std::vector<std::string> words;
    std::stringstream ss(txt);
    std::string word;
    while (ss >> word) {
      words.push_back(word);
    }
    return Union_std_vector_std_string__long(words);
  } else if (txt.find(',') != std::string::npos) {
    std::vector<std::string> words;
    std::string current_word;
    for (char c : txt) {
      if (c == ',') {
        words.push_back(current_word);
        current_word = """";
      } else {
        current_word += c;
      }
    }
    words.push_back(current_word);
    return Union_std_vector_std_string__long(words);
  } else {
    long odd_order_count = 0;
    for (char c : txt) {
      if (islower(c)) {
        if ((c - 'a') % 2 != 0) {
          odd_order_count++;
        }
      }
    }
    return Union_std_vector_std_string__long(odd_order_count);
  }
}","}
int main() {
    auto candidate = split_words;
    assert(candidate((""Hello world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello,world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello world,!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world,!""}));
    assert(candidate((""Hello,Hello,world !"")) == std::vector<std::string>({(std::string)""Hello,Hello,world"", (std::string)""!""}));
    assert(candidate((""abcdef"")) == 3);
    assert(candidate((""aaabb"")) == 2);
    assert(candidate((""aaaBb"")) == 1);
    assert(candidate(("""")) == 0);
}
"
HumanEval/126,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اعدادن ہندس ویکٹرس دنہٕ آمت، ییہٕ واپس کرنہٕ اگر تم چِھ بڑھون ترتیبس منٛز ترتیب دینہٕ آمت۔ اگر ویکٹرس منٛز اکس کھوتہٕ زیادٕ نمبر چِھ آسان، تیلہٕ غلط چُھ واپس کرنہٕ یوان۔ کنہہ منفی نمبرن ہنٛد تصور کرو تہٕ صرف انٹیجرز۔ مثالہٕ >>> چُھ ترتیب دینہٕ آمت ({(std::vector<long>{(long>5}))) (true) >>> چُھ ترتیب دینہٕ آمت ({(std::vector<long>1) ، ({(long>2، ({(long>3، ({(long>4}) ، (true) >>> چُھ ترتیب دینہٕ آمت ({(long>1، ({(long>2، ({(long>3، ({(long>4}) ، (long>6، ({(long>6، ({(long>1، (long>6، (long>6، (long)) ، (long>7، (long>6، (long)) ، (long>long>long>6، (long>long)) ، (long>long>long>long>long>long)) ، (long>long>long>long>long>long>long)) ، (long>long>long>long>long>long>long)) ، (<long>long>long>long>long>long>long>long>long>long>long>long)) ، (<long>long>long>long>long>long>long>long>long>long)) ، (<<<long>long>long>long>long>long>long)) ، (<<<<<<<<<<<<<<<<<<<<<<<>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long>long)) ،</>long>long>long)) ،</>long)) (<<<<>long>long>long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (
bool is_sorted(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_sorted(std::vector<long> lst) {
  if (lst.size() <= 1) {
    return true;
  }
  std::map<long, int> counts;
  for (long x : lst) {
    counts[x]++;
  }
  for (auto const& [key, val] : counts) {
    if (val > 2) {
      return false;
    }
  }
  for (size_t i = 0; i < lst.size() - 1; ++i) {
    if (lst[i] > lst[i + 1]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_sorted;
    assert(candidate((std::vector<long>({(long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));
}
"
HumanEval/127,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہہ چھہ دۅن وقفہ دنہ آمت، یتہ پرٛیٚتھ وقفہ چھہ انٹیجرزن ہند جوڑ۔ مثلن، وقفہ = (شروع، اختتام) = (1, 2) ۔ دِنہٕ آمت وقفہ چھہ بند، امہ کنۍ زِ وقفہ (شروع، اختتام) چُھ شروع تہٕ اختتام دۄنوے شٲمل کران۔ پرٛیٚتھ وقفہ خٲطرٕ، یہ فرض چھہ یوان کرنہٕ ز امک آغاز چھہ امہ کس اختتامس برابر یا امہ کس کمس برابر۔ تہند کٲم چھہ یہ دٔریافت کرن زِ یمن دۄن وقفن ہنٛد انٹرسیکشنچ لمبٲیی چھہ اکھ پرائم نمبر۔ مثال، وقفن ہنٛد انٹرسیکشن (1, 3) ، (2، 4) چھہ (2، 3) یمک لمبٲیی چھہ 1، یُس نہٕ اکھ پرائم نمبر چھہ۔ اگر انٹرسیکشنچ لمبٲیی چھہ اکھ پرائم نمبر، تیلہ کٔرِ ""YES"" واپس، بصورت دیگر کٔرِ ""NO"" واپس۔ اگر زٕہٕہٕن وقفہ چھنہ انٹرسی سۭتۍ متٲفل، کٔر ""NO"" واپس۔ [input/output] نمونے: >>>intersection::((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
  long start1 = std::get(interval1);
  long end1 = std::get(interval1);
  long start2 = std::get(interval2);
  long end2 = std::get(interval2);
  long intersection_start = std::max(start1, start2);
  long intersection_end = std::min(end1, end2);
  long intersection_length = intersection_end - intersection_start + 1;
  if (intersection_length <= 0) {
    return ""NO"";
  }
  if (is_prime(intersection_length)) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = intersection;
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (""NO""));
    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (""NO""));
    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (""YES""));
    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (""YES""));
    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (""NO""));
    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (""NO""));
}
"
HumanEval/128,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہہ چھِ پورٕ اعدادن ہند اکھ ویکٹر دنہٕ آمت تہٕ توہہ چھِ پورٕ اعدادن ہنز مقدارُک مجموعہٕ پورٕ اعدادن ہند ضرب ویکٹرس منز ہر نمبر کہ تمام نشاناتن ہند پروڈکٹہٕ سۭتۍ واپس کرنچ ضرورت، یمچ نمائندگی 1، -1 یا 0 سۭتۍ چِھ یوان کرنہٕ۔ نوٹ: خالی arr خاطرٕ چُھ نہٕ کنہہ تہٕ واپس کرنہٕ یُن۔ مثال: >>> prod_signs{(std::vector<long>{(long) 1، (long) 2، (long) 2، (long) 4}))) 9 >>> prod_signs{(std::vector<long>{(long) 0، (long) 1}))) 0 >>> prod_signs{(std::vector<long>((d))) std::nopt
std::optional<long> prod_signs(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> prod_signs(std::vector<long> arr) {
  if (arr.empty()) {
    return std::nullopt;
  }
  long sum_magnitudes = 0;
  long product_of_signs = 1;
  for (long num : arr) {
    sum_magnitudes += std::abs(num);
    if (num > 0) {
      product_of_signs *= 1;
    } else if (num < 0) {
      product_of_signs *= -1;
    } else {
      product_of_signs *= 0;
    }
  }
  return sum_magnitudes * product_of_signs;
}","}
int main() {
    auto candidate = prod_signs;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);
}
"
HumanEval/129,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// N راین تہٕ N کالمن (N >= 2) تہٕ اکھ مثبت انٹیجر k سۭتۍ اکھ گرڈ دینہٕ آمت، گرڈک پرتھ سیل چُھ اکھ قدرس پیٹھ مشتمل۔ رینجچ ہر انٹیجر چُھ گرڈک سیلن پیٹھ بالکل اکہٕ لٹہٕ ظأہر گژان۔ توہیہ چُھ گرڈس منٛز لمبائی k ہنٛد کم کھوتہٕ کم وتھ ژھانٛڈن پیٛوان۔ توہیہ ہیکہِ کُنہٕ تہٕ سیل نش شروع گژھت، تہٕ پرتھ مرحلس منٛز ہیکہِ توہہٕ ہمسایہٕ سیلن منٛز گژھت، بیین لفظن منٛز، توہیہ ہیکہِ سوٛن سیلن منٛز گژھت یم توہیہٕ موجودٕ سیلن سۭتۍ اکھ کنڈ چھ شیئر کران۔ براہ کرم نوٹ کٔرو کہ لمبائی k ہنٛد پاتھ چُھ مطلب بالکل k سیلن ہنٛد دورٕ کرن (ضروری طور پٲن چُھنہٕ الگ) ۔ توہیہ ہیکہِ نہٕ گرڈس نیبر گژھت۔ A (لمبائی k) چُھ اکھ پاتھ B (لمبائی k) کھوتہٕ کم سمجھنہٕ ییلہٕ اگر A تہٕ B (آوٛو تمن lst_A تہٕ l_st_A تہٕ l_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_J تہٕ) پیٹھ قدرن ترتیب دینہٕ والن والن ویک ترتیب دینہٕ ویک ترتیب بناون پتہٕ (ت چُن) ، توہی چُہٕ اکھ ویکٹ ویکٹ ویکٹ ویکٹ ویک لحاظ سۭتۍ کم چُک خیال چُک اکھ ویکٹٕ لوٛت اگر A (آ k_j_j_j_j_j_j_j_j_j_j_j_j_j تہٕ l تہٕ l_j_j_j_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_b_
std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
  int n = grid.size();
  std::vector<long> min_path;

  std::function<void(int, int, std::vector<long>)> dfs = 
    [&](int row, int col, std::vector<long> current_path) {
    if (current_path.size() == k) {
      if (min_path.empty() || current_path < min_path) {
        min_path = current_path;
      }
      return;
    }

    current_path.push_back(grid[row][col]);

    int dr= {-1, 1, 0, 0};
    int dc= {0, 0, -1, 1};

    for (int i = 0; i < 4; ++i) {
      int next_row = row + dr[i];
      int next_col = col + dc[i];
      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {
        dfs(next_row, next_col, current_path);
      }
    }
  };

  for (int start_row = 0; start_row < n; ++start_row) {
    for (int start_col = 0; start_col < n; ++start_col) {
      dfs(start_row, start_col, {});
    }
  }

  return min_path;
}","}
int main() {
    auto candidate = minPath;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
}
"
HumanEval/130,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فبونیکی ترتیب چِھ ساروی کھوتہٕ زیادٕ مشہور، ریاضی دانو چُھ امچ گہری مطالعہٕ کرمُت۔ تاہم، یُس لوکھ چِھ نہٕ زانان چُھ ٹریبونیکی ترتیب۔ ٹریبونیکی ترتیبچ تعریف چِھ تکرارس سۭتۍ کرنہٕ یوان: tri(1) = 3 tri(n) = 1 + n / 2 ، اگر n چُھ برابر۔ tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ، اگر n چُھ عجیب۔ مثلن: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 اگر توہہٕ چِھ اکھ غأر منفی عدد n دنہٕ آمت، توہہٕ چِھ ٹریبونیکی ترتیبچ گوڑنچ n + 1 ویکٹر واپس کرن۔ مثال: >>> tri(3) (longdst vector><<{(long} (long1, long (3, long) (long) (8, long))
std::vector<long> tri(long n) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> tri(long n) {
  std::vector<long> result;
  if (n >= 0) {
    result.push_back(1);
  }
  if (n >= 1) {
    result.push_back(3);
  }
  for (long i = 2; i <= n; ++i) {
    if (i % 2 == 0) {
      result.push_back(1 + i / 2);
    } else {
      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)
      {
          result.push_back(result[i-1] + result[i-2] + result[i]);
      }
      else if (i - 1 >= 0 && i - 2 >= 0)
      {
          result.push_back(result[i-1] + result[i-2]);
      }
      else if (i - 1 >= 0)
      {
          result.push_back(result[i-1]);
      }
      else
      {
          result.push_back(0);
      }
    }
  }
  return result;
}","}
int main() {
    auto candidate = tri;
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));
    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));
    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));
    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));
    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));
    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));
    assert(candidate((0)) == (std::vector<long>({(long)1})));
    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));
}
"
HumanEval/131,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ مثبت عدد n دنہٕ آمت، عجیب ہندسن ہند پیداوار واپس ییہٕ دنہٕ۔ 0 ییہٕ واپس ییہٕ دنہٕ اگر تمام ہندسہٕ چِھ یکساں۔ مثال: >>> ہندسہٕ (۱) (۱) >>> ہندسہٕ (۲) (۴) (۰) >>> ہندسہٕ (۲۳۵) (۱۵)
long digits(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long digits(long n) {
  long product = 1;
  std::string s = std::to_string(n);
  bool has_odd = false;
  for (char c : s) {
    long digit = c - '0';
    if (digit % 2 != 0) {
      product *= digit;
      has_odd = true;
    }
  }
  if (!has_odd) {
    return 0;
  }
  return product;
}","}
int main() {
    auto candidate = digits;
    assert(candidate((5)) == (5));
    assert(candidate((54)) == (5));
    assert(candidate((120)) == (1));
    assert(candidate((5014)) == (5));
    assert(candidate((98765)) == (315));
    assert(candidate((5576543)) == (2625));
    assert(candidate((2468)) == (0));
}
"
HumanEval/132,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن بنٲوِتھ یُس صرف مربع بریکٹس وٲل سٹرنگ ان پٹ کٔرِ۔ فنکشن گژھہِ ٹرو لٲوِتھ اگر تہٕ صرف اگر بریکٹسٕچ اکھ درست ذیلی ترتیب آسہِ یتھ منز ذیلی ترتیبس منز کم از کم اکھ بریکٹ چُھ نیسٹڈ۔ >>> is_nested((""[[]]"")) (true) >>> is_nested((""[]]]]]]]]]][[[[[[[]"")) (false) >>> is_nested((""[][]"") (false) >>> is_nested(""[]"") (false) >>> is_nested(""[[]]"") (true) >>> is_nested(""[[]]"") (true)
bool is_nested(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_nested(std::string string) {
  int balance = 0;
  bool nested = false;
  for (char c : string) {
    if (c == '[') {
      balance++;
    } else if (c == ']') {
      if (balance > 1) {
        nested = true;
      }
      balance--;
      if (balance < 0) {
        return false;
      }
    }
  }
  return balance == 0 && nested;
}","}
int main() {
    auto candidate = is_nested;
    assert(candidate((""[[]]"")) == (true));
    assert(candidate((""[]]]]]]][[[[[]"")) == (false));
    assert(candidate((""[][]"")) == (false));
    assert(candidate((""[]"")) == (false));
    assert(candidate((""[[[[]]]]"")) == (true));
    assert(candidate((""[]]]]]]]]]]"")) == (false));
    assert(candidate((""[][][[]]"")) == (true));
    assert(candidate((""[[]"")) == (false));
    assert(candidate((""[]]"")) == (false));
    assert(candidate((""[[]][["")) == (true));
    assert(candidate((""[[][]]"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""[[[[[[[["")) == (false));
    assert(candidate((""]]]]]]]]"")) == (false));
}
"
HumanEval/133,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہہ چھ اعدادن ہند اکھ ویکٹر دنہ آمت۔ توہہ چھ دراو ویکٹرس منز مربع نمبرن ہند مجموعہ واپس کرنچ ضرورت، تہٕ ویکٹرس منز پرتھ عنصرس گوڈٕ پیٹھہٕ ہیر کٔرتھ۔ مثالہٕ: >>> lst: vector<float>{(float) 1.0f, (float) 2.0f, (float) 3.0f)) (14) >>> lst: vector<float>{(float) 1.0f, (float) 4.0f, (float) 9.0f))) >>> (98) lst: vector<float>{(float) 1.0f, (float) 3.0f, (float) 5.0f, (float) 7.0f)) (84) >>> lst: vector<float>{((float) 1.4f, (float) 2.4.2f, (float) 3.0f)) (6) >>> lst: vector<float>{(float) 2.4.0f, (float) 2.4.0f, (float) (6) >>> (float) 2.4.0f, (float)
long sum_squares(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_squares(std::vector<float> lst) {
  long sum = 0;
  for (float num : lst) {
    long rounded_up = std::ceil(num);
    sum += rounded_up * rounded_up;
  }
  return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));
    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));
    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));
    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));
    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));
}
"
HumanEval/134,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن بنٲوِتھ یُس ٹرٕ چُھ واپس کران اگر دِنہٕ آمتِس سٹرنگُک ٲخری کردار چُھ اکھ حروف تہجی ہند کردار تہٕ چُھ نہٕ کنٛہہ لفظُک حصہ تہٕ بییہٕ غلط۔ نوٹ: ""1"" لفظ ""2"" چُھ حروفن ہند اکھ گروپ یوس اسپیسس سٕتۍ چُھ الگ کرنہٕ آمُت۔ مثالہٕ: >>> check_if_last_char_is_a_letter"" (((""apple pie"")) (false) >>> check_if_last_char_is_a_letter"" ((apple pi e"")) (true) >>> check_if_last_char_is_a_letter "" (((apple pi e)) (false) >>> check_if_last_char_is_a_letter "" (false)
bool check_if_last_char_is_a_letter(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_if_last_char_is_a_letter(std::string txt) {
  if (txt.empty()) {
    return false;
  }
  if (!isalpha(txt.back())) {
    return false;
  }
  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {
    return false;
  }
  return true;
}","}
int main() {
    auto candidate = check_if_last_char_is_a_letter;
    assert(candidate((""apple"")) == (false));
    assert(candidate((""apple pi e"")) == (true));
    assert(candidate((""eeeee"")) == (false));
    assert(candidate((""A"")) == (true));
    assert(candidate((""Pumpkin pie "")) == (false));
    assert(candidate((""Pumpkin pie 1"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""eeeee e "")) == (false));
    assert(candidate((""apple pie"")) == (false));
    assert(candidate((""apple pi e "")) == (false));
}
"
HumanEval/135,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن بنٲوِتھ اکھ ایلیمنٹس سٕنز ساروی کھوتہٕ بٕڑ انڈیکس چُھ واپس کران یوس ایمہِ برونٛہہ کہِ ایلیمنٹس سٕتۍ زیادٕہ یا مسٲوی چُھ نہٕ کینٛہہ۔ اگر ایمہِ قٕسمُک ایلیمنٹس موجود آسہِ نہٕ تیلہِ چُھ واپس کران -1۔ دِنہٕ آمُتۍ ویکٹر منز چُھ نہٕ ڈپلیکیٹ ویلیوز آسان کینٛہہ۔ مثال: >>> can_arrange(((std::vector<long>({long) 1، (long) 2، (long) 4، (long) 3، (long) 5}))) (3) >>> can_arrange((std::vector<long>{(long) 1، (long) 2، (long) 3}))) (-1)
long can_arrange(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long can_arrange(std::vector<long> arr) {
  for (long i = 1; i < arr.size(); ++i) {
    if (arr[i] < arr[i - 1]) {
      return i;
    }
  }
  return -1;
}","}
int main() {
    auto candidate = can_arrange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));
    assert(candidate((std::vector<long>())) == (-1));
}
"
HumanEval/136,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن بنٲوِتھ یُس ٹپل (a، b) چُھ رٹان، یتہِ 'a' منفی عددن منز ساروی کھوتہٕ بوٕڑ چُھ، تہٕ 'b' چُھ ویکٹرس منز مثبت عددن منز ساروی کھوتہٕ لوکٹ۔ اگر نہٕ منفی تہٕ نہٕ مثبت عدد آسہِ، تہٕ بییہِ ایمِچ واپسی None کِس طورس پیٹھ۔ مثالہٕ: >>> largest_smallest_integers((std::vector<long>{long>) 2، (long) 4، (long) 1، (long) 3، (long) 5، (long) 7))) std::make_tuplest_d::optional<long>{long>) ، std::optional<long>{long>) >>> largest_smallest_integers{long>{long>}، std::optional<long>{long>) ، std::optional<long>{long>{long>}، std::optional<long>{long>}، std::optional<long>{long>}<optional<optional>
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<tuple>
#include<vector>

std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> largest_negative = std::nullopt;
    std::optional<long> smallest_positive = std::nullopt;
    for (long num : lst) {
        if (num < 0) {
            if (!largest_negative.has_value() || num > largest_negative.value()) {
                largest_negative = num;
            }
        } else if (num > 0) {
            if (!smallest_positive.has_value() || num < smallest_positive.value()) {
                smallest_positive = num;
            }
        }
    }
    return std::make_tuple(largest_negative, smallest_positive);
}","}
int main() {
    auto candidate = largest_smallest_integers;
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));
    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));
    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));
}
"
HumanEval/137,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};
// اکھ فنکشن بنٲوِتھ یُس انٹیجر، فلوٹس، یا سٹرنگس چُھ ننان یوس حقیقی نمبرن ہنز نمائندگی کران چُھ، تہٕ چُھ بڑٕے متغیرس اتھ متغیر ٹائپس منز واپس کران۔ اگر ویلیو برابر آسن تہٕ چُھ نون واپس کران۔ نوٹ: اگر اکھ حقیقی نمبر چُھ سٹرنگ کہِ طورس پیٹھ پیش کرنہٕ یوان، تہٕ فلوٹنگ پوائنٹ ہیکہِ ٲسٕتۍ . یا ، >>> compare_one{1,2.5f} 2.5f >>> compare_one{1, ""2,3"") ""2,3"" >>> compare_one{5,1"", ""6"") ""6"" >>> compare_one{1"", 1) std::nullopt
Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<string>

union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;
    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;
    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};

double parse_real(const std::string& s) {
    std::string temp = s;
    std::replace(temp.begin(), temp.end(), ',', '.');
    try {
        return std::stod(temp);
    } catch (const std::invalid_argument& e) {
        return std::numeric_limits<double>::quiet_NaN();
    } catch (const std::out_of_range& e) {
        return std::numeric_limits<double>::quiet_NaN();
    }
}

Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a.f2.empty() && b.f2.empty()) {
        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {
            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {
            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);
            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {
            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {
            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);
            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);
        }
    } else {
        double val_a, val_b;
        if (!a.f2.empty()) val_a = parse_real(a.f2);
        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);
        else val_a = static_cast<double>(a.f1);

        if (!b.f2.empty()) val_b = parse_real(b.f2);
        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);
        else val_b = static_cast<double>(b.f1);

        if (!std::isnan(val_a) && !std::isnan(val_b)) {
            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);
            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);
        }
    }
    return Union_long_float_std_string_std_nullopt(std::nullopt{});
}","}
int main() {
    auto candidate = compare_one;
    assert(candidate(1, 2) == 2);
    assert(candidate(1, 2.5f) == 2.5f);
    assert(candidate(2, 3) == 3);
    assert(candidate(5, 6) == 6);
    assert(candidate(1, ""2,3"") == ""2,3"");
    assert(candidate(""5,1"", ""6"") == ""6"");
    assert(candidate(""1"", ""2"") == ""2"");
    assert(candidate(""1"", 1) == std::nullopt);
}
"
HumanEval/138,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// تشخیص کٔرو زِ کیا دِنہٕ آمت نمبر n ہیکو بالکل 4 پازِٹو Even نمبرن ہندس مجموعس طورس پیٹھ لیکھتھ مثال >>> is_equal_to_sum_even ({\displaystyle n_{\displaystyle _{\displaystyle _{\displaystyle _{\frac {e}}}) (جھوٹ) >>> is_equal_to_sum_even ({\displaystyle _{\frac {e}}}) (جھوٹ) >>> is_equal_to_sum_even ({\displaystyle _{\frac {e}}}) (جھوٹ) >>> is_equal_to_sum_even ({\displaystyle _{\frac {e}}}) (جھوٹ) >>> is_equal_to_sum_even ({\displaystyle _{\frac {e}}}) (جھوٹ)
bool is_equal_to_sum_even(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_equal_to_sum_even(long n) {
    if (n <= 6 || n % 2 != 0) {
        return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_equal_to_sum_even;
    assert(candidate((4)) == (false));
    assert(candidate((6)) == (false));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (true));
    assert(candidate((11)) == (false));
    assert(candidate((12)) == (true));
    assert(candidate((13)) == (false));
    assert(candidate((16)) == (true));
}
"
HumanEval/139,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// برازیلی فیکٹریئل چُھ یتھ کٔنۍ بیان کرنہٕ آمت: برازیلی_فیکٹریئل ((n) = n! * (n-1)! * (n-2)! * ... * 1! یتین n > 0 مثلن: >>> خصوصی_فیکٹریئل (((4)) (288) فنکشن ان پٹ کس طورس پیٹھ چُھ اکھ انٹیجر حٲصل کران تہٕ اتھ انٹیجرس سٔتۍ گژھہٕ خصوصی فیکٹریئل واپس گژھت۔
long special_factorial(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long factorial(long k) {
    long res = 1;
    for (long i = 2; i <= k; ++i) {
        res *= i;
    }
    return res;
}

long special_factorial(long n) {
    if (n <= 0) {
        return 1;
    }
    long result = 1;
    for (long i = 1; i <= n; ++i) {
        result *= factorial(i);
    }
    return result;
}","}
int main() {
    auto candidate = special_factorial;
    assert(candidate((4)) == (288));
    assert(candidate((5)) == (34560));
    assert(candidate((7)) == (125411328000));
    assert(candidate((1)) == (1));
}
"
HumanEval/140,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ سٹرنگ متن دیتھ، اتھ منٛز موجود تمام خالی جگہوں پیٹھ زیرکورس سۭتۍ تبدیل کرُن، تہٕ اگر سٹرنگس منٛز 2 کھوتہٕ زیادٕ لگاتار خالی جگہوں چِھ آسان، تیلہٕ تمام لگاتار خالی جگہوں پیٹھ تبدیل کرُن - >>> fix_spaces((""مثال"")) (""مثال"") >>> fix_spaces((""مثال 1"")) (""مثال_1"") >>> fix_spaces((""مثال 2"")) (""_مثال_2"") >>> fix_spaces((""مثال 3"")) (""_مثال-3"")
std::string fix_spaces(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string fix_spaces(std::string text) {
    std::string result = """";
    int space_count = 0;
    for (char c : text) {
        if (c == ' ') {
            space_count++;
        } else {
            if (space_count == 1) {
                result += '_';
            } else if (space_count > 1) {
                result += '-';
            }
            result += c;
            space_count = 0;
        }
    }
    if (space_count == 1 && !result.empty() && result.back() != '_') {
        result += '_';
    } else if (space_count > 1 && !result.empty() && result.back() != '-') {
        result += '-';
    } else if (space_count > 0 && result.empty()) {
        if (space_count > 2) result += '-';
        else if (space_count == 1) result += '_';
    } else if (space_count == 1 && result.empty()) {
        result += '_';
    }

    std::string trimmed_result = """";
    bool non_space_found = false;
    for (char c : result) {
        if (c != ' ') {
            non_space_found = true;
            trimmed_result += c;
        } else if (non_space_found) {
            trimmed_result += c;
        }
    }

    while (!trimmed_result.empty() && trimmed_result.front() == '_') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '_') {
        trimmed_result.pop_back();
    }
     while (!trimmed_result.empty() && trimmed_result.front() == '-') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '-') {
        trimmed_result.pop_back();
    }

    std::string final_result = """";
    space_count = 0;
    for (char c : trimmed_result) {
        if (c == '_') {
            space_count++;
        } else {
            if (space_count == 1) {
                final_result += '_';
            } else if (space_count > 1) {
                final_result += '-';
            }
            final_result += c;
            space_count = 0;
        }
    }
    if (space_count == 1) {
        final_result += '_';
    } else if (space_count > 1) {
        final_result += '-';
    }

    return final_result;
}","}
int main() {
    auto candidate = fix_spaces;
    assert(candidate((""Example"")) == (""Example""));
    assert(candidate((""Mudasir Hanif "")) == (""Mudasir_Hanif_""));
    assert(candidate((""Yellow Yellow  Dirty  Fellow"")) == (""Yellow_Yellow__Dirty__Fellow""));
    assert(candidate((""Exa   mple"")) == (""Exa-mple""));
    assert(candidate((""   Exa 1 2 2 mple"")) == (""-Exa_1_2_2_mple""));
}
"
HumanEval/141,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن بنٲوِتھ یُس اکھ سٹرنگ چُھ نوان یوس فائلُک ناو چُھ ظٲہر کران، تہٕ اگر سٹرنگُک ناو چُھ درست، تہٕ اگر سٹرنگُک ناو چُھ غلط تہٕ چُھ ""نٔ"" واپس کران۔ اکھ فائلُک ناو چُھ صیح ماننہٕ یوان اگر تہٕ صرف اگر سٹرنگُک تمام درج ذیل شرطہٕ پورٕ گژھِ: - فائلُک ناو گژھِ نہٕ تریو ہندسن سٕتۍ زیادٕہ آسن ('0'-'9') ۔ - فائلُک ناوس منز گژھِ نہٕ بالکل اکھ ڈاٹ '۔ - ڈاٹ برونٹھ چُھ سبسٹنگ خٲلی گژھُن، تہٕ یہٕ گژھہِ نہٕ ڈاٹ برونٹھ اکہِ حرفہٕ سٕتۍ شروع گژھُن ('a'-'z' تہٕ 'A'-Z') ۔ ڈاٹ برونٹھ چُھ سبسٹنگ یُس اَتھ منزٕ اکھ آسہٕ: ['txt'، 'exe', 'll'] مثالہٕ: >>> file_name_check_{""{""{example.txt"") (""Yes"") >>> file_name_check_{""{example.d1}""{example.t""} (""No"")
std::string file_name_check(std::string file_name) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string file_name_check(std::string file_name) {
    int digit_count = 0;
    int dot_count = 0;
    size_t dot_pos = std::string::npos;

    for (size_t i = 0; i < file_name.length(); ++i) {
        if (isdigit(file_name[i])) {
            digit_count++;
        } else if (file_name[i] == '.') {
            dot_count++;
            dot_pos = i;
        }
    }

    if (digit_count > 3 || dot_count != 1) {
        return ""No"";
    }

    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {
        return ""No"";
    }

    std::string name_part = file_name.substr(0, dot_pos);
    std::string ext_part = file_name.substr(dot_pos + 1);

    if (name_part.empty() || !isalpha(name_part[0])) {
        return ""No"";
    }

    if (ext_part == ""txt"" || ext_part == ""exe"" || ext_part == ""dll"") {
        return ""Yes"";
    } else {
        return ""No"";
    }
}","}
int main() {
    auto candidate = file_name_check;
    assert(candidate((""example.txt"")) == (""Yes""));
    assert(candidate((""1example.dll"")) == (""No""));
    assert(candidate((""s1sdf3.asd"")) == (""No""));
    assert(candidate((""K.dll"")) == (""Yes""));
    assert(candidate((""MY16FILE3.exe"")) == (""Yes""));
    assert(candidate((""His12FILE94.exe"")) == (""No""));
    assert(candidate((""_Y.txt"")) == (""No""));
    assert(candidate((""?aREYA.exe"")) == (""No""));
    assert(candidate((""/this_is_valid.dll"")) == (""No""));
    assert(candidate((""this_is_valid.wow"")) == (""No""));
    assert(candidate((""this_is_valid.txt"")) == (""Yes""));
    assert(candidate((""this_is_valid.txtexe"")) == (""No""));
    assert(candidate((""#this2_i4s_5valid.ten"")) == (""No""));
    assert(candidate((""@this1_is6_valid.exe"")) == (""No""));
    assert(candidate((""this_is_12valid.6exe4.txt"")) == (""No""));
    assert(candidate((""all.exe.txt"")) == (""No""));
    assert(candidate((""I563_No.exe"")) == (""Yes""));
    assert(candidate((""Is3youfault.txt"")) == (""Yes""));
    assert(candidate((""no_one#knows.dll"")) == (""Yes""));
    assert(candidate((""1I563_Yes3.exe"")) == (""No""));
    assert(candidate((""I563_Yes3.txtt"")) == (""No""));
    assert(candidate((""final..txt"")) == (""No""));
    assert(candidate((""final132"")) == (""No""));
    assert(candidate((""_f4indsartal132."")) == (""No""));
    assert(candidate(("".txt"")) == (""No""));
    assert(candidate((""s."")) == (""No""));
}
"
HumanEval/142,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// یہٕ فنکشن چُھ انٹیجرزن ہند ویکٹر نوان۔ ویکٹر کہِ تمام اندراجاتٕ خٲطرٕہ، فنکشن چُھ انٹیجر انٹریس مربع کرُن اگر ایمِچ انڈیکس 3 ہند ضرب چُھ تہٕ انٹیجر انٹریس کوب کرُن اگر ایمِچ انڈیکس 4 ہند ضرب چُھ تہٕ نہٕ کہ 3 ہند ضرب۔ فنکشن چُھ نہٕ ویکٹر کہِ انٹریزن تبدیل کران یمیوک انڈیکس 3 یا 4 ہند ضرب چُھ نہٕ کینٛہہ۔ فنکشن چُھ پتہٕ تمام اندراجاتُک جمع واپس کران۔ مثالہٕ: >>> lst (long({(long) 1، (long) 2، (long) 3})) >>> lst (long) 1، (long) 2، (long) 1، (long) 5})
long sum_squares(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for (size_t i = 0; i < lst.size(); ++i) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));
    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));
    assert(candidate((std::vector<long>({(long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));
    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));
    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));
}
"
HumanEval/143,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چھہ اکھ جملہ پیش کرنہ آمت، جملس منز چھہ کینہہ لفظ یس پرایس سٹیج سیتۍ الگ چھہ، تہ توہیہ چھہ اکھ جملہ واپس کرنۍ یمہ منز اصل جملک لفظ آسہ، یمچ لمبائی پرائم نمبر آسہ، نٔوِس سٹرنگس منز لفظن ہنز ترتیب گژھہِ اصلی ہندس ہیوۍ آسن۔ مثال 1: >>> words_in_sentence (((""یہ چھیہ اکھ ٹیسٹ"")) (""is"") مثال 2: >>> words_in_sentence (((""چھیہ سوئمنگس منز وۅتلان"")) (""go for"") پابند: * 1 <= len ((sentence) <= 100 * جملس منز چھہِ صرف حرف
std::string words_in_sentence(std::string sentence) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

std::string words_in_sentence(std::string sentence) {
    std::string result = """";
    std::stringstream ss(sentence);
    std::string word;
    while (ss >> word) {
        if (is_prime(word.length())) {
            if (!result.empty()) {
                result += "" "";
            }
            result += word;
        }
    }
    return result;
}","}
int main() {
    auto candidate = words_in_sentence;
    assert(candidate((""This is a test"")) == (""is""));
    assert(candidate((""lets go for swimming"")) == (""go for""));
    assert(candidate((""there is no place available here"")) == (""there is no place""));
    assert(candidate((""Hi I am Hussein"")) == (""Hi am Hussein""));
    assert(candidate((""go for it"")) == (""go for it""));
    assert(candidate((""here"")) == (""""));
    assert(candidate((""here is"")) == (""is""));
}
"
HumanEval/144,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہند کٲم چھ اکھ فنکشن لاگو کرن یُس اظہار x * n آسان بناوٕ۔ یہٕ فنکشن چھ صحیح واپس کران اگر x * n چُھ اکھ پورٕ نمبر تہٕ بصورت دیگر غلط۔ x تہٕ n، چھ اکھ فریکشنچ سٹرنگ نمائندگی، تہٕ یمن منٛز چھِ درج ذیل شکل، <numerator>/<denominator> ییتھ منٛز ننیومنٹر تہٕ ڈینومینٹر دۄنوے مثبت پورٕ نمبر چِھ۔ توہیہ ہیکو یہٕ فرض کرتھ زِ x، تہٕ n چھ درست فریکشن، تہٕ ڈینومینٹر چھُ نہٕ صفر۔ >>> آسان بناوُن (((""1/5"") ، (""5/1"")) (حقیقت) >>> آسان بناوُن ((""1/6"") ، (""2/1"") (غلط) >>> آسان بناوُن (((""7/10"") ، (""10/2"") (غلط)
bool simplify(std::string x, std::string n) {
","#include<assert.h>
#include<bits/stdc++.h>

long gcd(long a, long b) {
    while (b) {
        a %= b;
        std::swap(a, b);
    }
    return a;
}

bool simplify(std::string x, std::string n) {
    long x_num, x_den, n_num, n_den;
    size_t slash_pos = x.find('/');
    x_num = std::stol(x.substr(0, slash_pos));
    x_den = std::stol(x.substr(slash_pos + 1));

    slash_pos = n.find('/');
    n_num = std::stol(n.substr(0, slash_pos));
    n_den = std::stol(n.substr(slash_pos + 1));

    long num = x_num * n_num;
    long den = x_den * n_den;

    long common_divisor = gcd(num, den);
    den /= common_divisor;

    return den == 1;
}","}
int main() {
    auto candidate = simplify;
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/6""), (""2/1"")) == (false));
    assert(candidate((""5/1""), (""3/1"")) == (true));
    assert(candidate((""7/10""), (""10/2"")) == (false));
    assert(candidate((""2/10""), (""50/10"")) == (true));
    assert(candidate((""7/2""), (""4/2"")) == (true));
    assert(candidate((""11/6""), (""6/1"")) == (true));
    assert(candidate((""2/3""), (""5/2"")) == (false));
    assert(candidate((""5/2""), (""3/5"")) == (false));
    assert(candidate((""2/4""), (""8/4"")) == (true));
    assert(candidate((""2/4""), (""4/2"")) == (true));
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/5""), (""1/5"")) == (false));
}
"
HumanEval/145,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لیوکھ یتھ منز انٹیجرزن ہند دِنہٕ آمُت ویکٹر چُھ دِنہٕ یوان تہٕ چُھ دِنہٕ یوان تہندین ہندسن ہندس مجموعس مطابق۔ نوٹ: اگر ہیوی ہندسن ہندس مجموعس سٕتۍ چِھ واریاہ چیز، تہٕ توٲی چُھ تہندِس اصل ویکٹرس منز تہندِس انڈیکس کہِ بنیادس پیٹھ ترتیب دِنہٕ یوان۔ مثال کہِ طورس پیٹھ: >>> order_by_points((std::vector<long>({long) 1, (long) 11, (long) -1, (long) -1, (long) -12}))) (std::vector<long>({long) -1, (long) -11, (long) -1, (long) -12, (long) -11}) >>> order_by_points
std::vector<long> order_by_points(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_digits(long n) {
    long sum = 0;
    std::string s = std::to_string(std::abs(n));
    for (char c : s) {
        sum += c - '0';
    }
    return sum;
}

std::vector<long> order_by_points(std::vector<long> nums) {
    std::vector<std::pair<long, size_t>> indexed_nums;
    for (size_t i = 0; i < nums.size(); ++i) {
        indexed_nums.push_back({nums[i], i});
    }

    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {
        long sum_a = sum_digits(a.first);
        long sum_b = sum_digits(b.first);
        if (sum_a != sum_b) {
            return sum_a < sum_b;
        }
        return a.second < b.second;
    });

    std::vector<long> result;
    for (const auto& pair : indexed_nums) {
        result.push_back(pair.first);
    }
    return result;
}","}
int main() {
    auto candidate = order_by_points;
    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));
    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));
    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));
}
"
HumanEval/146,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لیوکھ یتھ منز اعدادن ہند ویکٹر ان پٹ چُھ یوان کرنہٕ تہٕ ویکٹر چِھ عناصرک تعداد واپس کران یم 10 کھوتہٕ زیادٕ چِھ آسان تہٕ نمبرٕک گوڈنِک تہٕ ٲخری ہندسہٕ چِھ عجیب آسان (1, 3, 5, 7, 9) ۔ مثالہٕ پٲٹھۍ: >>> specialFilter((std::vector<long>({long) 15, (long) -73، (long) 14، (long) -15}))) (1) >>> specialFilter((std::vector<long>({long) 33، (long) - 2، (long) - 3، (long) 45، (long) 21، (long) 109} (2))))
long specialFilter(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_odd_digit(char c) {
    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');
}

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for (long num : nums) {
        if (std::abs(num) > 10) {
            std::string s = std::to_string(std::abs(num));
            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {
                count++;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = specialFilter;
    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));
    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));
    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));
    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));
    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>())) == (0));
}
"
HumanEval/147,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہہ چھوہ اکھ مثبت عدد n دنہ آمت۔ توہہ چھوہ اکھ عدد ویکٹر بناون پیوان a زیچھر n ہچ۔ پرتھ i (1 ≤ i ≤ n) خاطرٕ ، a[i] = i * i - i + 1چ قدر۔ a a کیٛن ٹرپلزن ہنٛز تعداد واپس کرو (a[i] ، a[j] ، a[k]) ییتہ i < j < k چُھ، تہٕ a[i] + a[j] + a[k] چُھ 3 ہند ضرب۔ مثال: >>> get_max_triples((5)) (1) وضاحت: a = [1, 3, 7, 13, 21] واحد درست ٹرپل چُھ (1, 7, 13) ۔
long get_max_triples(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long get_max_triples(long n) {
    if (n < 3) {
        return 0;
    }
    std::vector<long> a(n);
    for (long i = 0; i < n; ++i) {
        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;
    }

    long count = 0;
    for (long i = 0; i < n; ++i) {
        for (long j = i + 1; j < n; ++j) {
            for (long k = j + 1; k < n; ++k) {
                if ((a[i] + a[j] + a[k]) % 3 == 0) {
                    count++;
                }
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = get_max_triples;
    assert(candidate((5)) == (1));
    assert(candidate((6)) == (4));
    assert(candidate((10)) == (36));
    assert(candidate((100)) == (53361));
}
"
HumanEval/148,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// شمسی نظامس منز چِھ آٹھ سیارٕ: آفتابس قریب ترین سیارٕ چُھ مرکری، برونٹھ چُھ ونرس، تہٕ پتہٕ زمین، مریخ، مشتری، زحل، یورینس، نیپچون۔ اکھ فنکشن لیوکھو یوس زٕ سیارن ہند ناو چُھ سیارٕ1 تہٕ سیارٕ2 کِس سٹرنگس منز نوان۔ فنکشنس گژھہِ اکھ ٹپل واپس انِن یوس تمام سیارن ہند مدار چُھ سیارٕ1 تہٕ سیارٕ2 کِس مدارس درمیان واقع، آفتابس قریبیتس مطابق چُھ ترتیب دِنہٕ آمُت۔ اگر سیارٕ1 یا سیارٕ2 چِھ نہٕ سیارن ہند صحیح ناو کینٛہہ تہٕ فنکشن گژھہِ خٲلی ٹپل واپس انِن۔ مثالہٕ >>> bf((""جوبائٹر"") ، (""نیپٹن"")) (std::vector<std::string>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> bf(std::string planet1, std::string planet2) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);

    if (it1 == planets.end() || it2 == planets.end()) {
        return {};
    }

    int index1 = std::distance(planets.begin(), it1);
    int index2 = std::distance(planets.begin(), it2);

    if (index1 == index2) {
        return {};
    }

    int start = std::min(index1, index2) + 1;
    int end = std::max(index1, index2);

    std::vector<std::string> result;
    for (int i = start; i < end; ++i) {
        result.push_back(planets[i]);
    }
    return result;
}","}
int main() {
    auto candidate = bf;
    assert(candidate((""Jupiter""), (""Neptune"")) == (std::vector<std::string>({(std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Mercury"")) == (std::vector<std::string>({(std::string)""Venus""})));
    assert(candidate((""Mercury""), (""Uranus"")) == (std::vector<std::string>({(std::string)""Venus"", (std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn""})));
    assert(candidate((""Neptune""), (""Venus"")) == (std::vector<std::string>({(std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Mars""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Jupiter""), (""Makemake"")) == (std::vector<std::string>()));
}
"
HumanEval/149,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لیوکھ یتھ منٛز تارن ہنٛد اکھ ویکٹر پیرامیٹر کس طورس پیٹھ چُھ قبول کرنہٕ یوان، تمن تارن چُھ ہٹان یمن منٛز عجیب لمبائی چِھ آسان، تہٕ ترتیب دینہٕ آمت ویکٹر چُھ واپس کران۔ ویکٹر چُھ ہمیشہ تارن ہنٛد ویکٹر آسان تہٕ نہٕ چُھ کُنہٕ ویکٹر نمبرن ہنٛد تہٕ اتھ منٛز ہیکن نقلہٕ شأمل أستھ۔ ویکٹرچ ترتیب گژھہٕ پرتھ لفظ کس لمبائی سۭتۍ چلان گژھت، تہٕ توہیہ گژھہٕ ویکٹر اَتھ قأیلس مطأبق ترتیب دینہٕ یُن۔ اگر دشویی لفظ چِھ اَکی لمبائی سۭتۍ، تیلہٕ ویکٹر چُھ الفبأتی ترتیب سۭتۍ ترتیب دینہٕ یُن۔ فنکشن گژھہٕ ترتیب دینہٕ آمت تارن ہنٛد ویکٹر واپس کرُن۔ توہیہ ہیکہٕ یہٕ فرض کرتھ کہ تمام الفاظن چِھ اَکی لمبائی۔ مثال کہ طور: >>> list_sort{""}std::stdvector<stdstring>{""}st:{""}st:d""d""d""d""d""a""a"" (d""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    std::vector<std::string> even_length_strings;
    for (const std::string& s : lst) {
        if (s.length() % 2 == 0) {
            even_length_strings.push_back(s);
        }
    }

    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {
        if (a.length() != b.length()) {
            return a.length() < b.length();
        }
        return a < b;
    });

    return even_length_strings;
}","}
int main() {
    auto candidate = sorted_list_sum;
    assert(candidate((std::vector<std::string>({(std::string)""aa"", (std::string)""a"", (std::string)""aaa""}))) == (std::vector<std::string>({(std::string)""aa""})));
    assert(candidate((std::vector<std::string>({(std::string)""school"", (std::string)""AI"", (std::string)""asdf"", (std::string)""b""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""asdf"", (std::string)""school""})));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""b"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""dcba"", (std::string)""abcd"", (std::string)""a""}))) == (std::vector<std::string>({(std::string)""abcd"", (std::string)""dcba""})));
    assert(candidate((std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""})));
    assert(candidate((std::vector<std::string>({(std::string)""a"", (std::string)""b"", (std::string)""b"", (std::string)""c"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""aaaa"", (std::string)""bbbb"", (std::string)""dd"", (std::string)""cc""}))) == (std::vector<std::string>({(std::string)""cc"", (std::string)""dd"", (std::string)""aaaa"", (std::string)""bbbb""})));
}
"
HumanEval/150,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ سادٕ پروگرام یُس xچ قدر یلہٕ n پرائم نمبر آسہٕ تہٕ yچ قدر یلہٕ بییہٕ واپس آسہٕ۔ مثالہٕ: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)
long x_or_y(long n, long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(long n) {
    if (n <= 1) return false;
    for (long i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

long x_or_y(long n, long x, long y) {
    if (is_prime(n)) {
        return x;
    } else {
        return y;
    }
}","}
int main() {
    auto candidate = x_or_y;
    assert(candidate((7), (34), (12)) == (34));
    assert(candidate((15), (8), (5)) == (5));
    assert(candidate((3), (33), (5212)) == (33));
    assert(candidate((1259), (3), (52)) == (3));
    assert(candidate((7919), (-1), (12)) == (-1));
    assert(candidate((3609), (1245), (583)) == (583));
    assert(candidate((91), (56), (129)) == (129));
    assert(candidate((6), (34), (1234)) == (1234));
    assert(candidate((1), (2), (0)) == (0));
    assert(candidate((2), (2), (0)) == (2));
}
"
HumanEval/151,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اعدادن ہندس ویکٹرس دیتھ، ویکٹرس منز اعدادن ہند مربعٕ ہند رقم واپس یُس عجیب چُھ ۔ منفی یا نہٕ عدد چِھ اعداد نظر انداز کران۔ >>> double_the_difference{((std::vector<float>({(long) 1, (long) 3, (long) 2, (long) 0}))) (10) >>> double_the_difference{(std::vector<float>{(long) -1, (long) -2, (long) 0}))) (0) >>> double_the_difference{(std::vector<float>{(long) -9, (long) -2}))) (81) >>> double_the_difference{(std::vector<float>{(long) -0}))) (0) اگر ان پٹ ویکٹر چُھ خٲلی، توہیہٕ چُھ 0 واپس کران۔
long double_the_difference(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long double_the_difference(std::vector<float> lst) {
    long sum_of_squares = 0;
    for (float num : lst) {
        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {
            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);
        }
    }
    return sum_of_squares;
}","}
int main() {
    auto candidate = double_the_difference;
    assert(candidate((std::vector<float>())) == (0));
    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));
    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));
    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));
    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));
}
"
HumanEval/152,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// میہ چُھ سونچ زِ ییلہٕ کنہہ طویل انتظارک نتیجہ چُھ أخٕرکار معلوم گژان تہٕ تمن احساسن تہٕ خیالاتن یُس تٔمۍ اسہِ چُھ آسان تم چِھ یقینی طورس پیٹھ نوٹ کرنچ تہٕ موازنہٕ کرنک قٲبل۔ تہند کٲم چِھ یہٕ طے کرُن کہ کیا اکس نفرن چُھ واریاہ میچچچرن ہنٛد نتائج صحیح اندازٕ لگاون۔ توہیہ چِھ آمٕتۍ دوٛن ویکٹرن ہنٛد اسکور تہٕ برابر لمبائی ہنٛد اندازٕ لگاون، یتہٕ پرتھ انڈیکس چُھ اکھ میچچچچ ظٲہر کران۔ اکہ ویکٹرک چُھ ہیوی لمبائی دیوان یمہٕ سۭتۍ یہٕ چُھ ظٲہر گژھان زِ ہر اندازٕ کتھ کتھ حدس تام اوس۔ اگر تمو صحیح اندازٕ لگاون، تیلہٕ چُھ ویلیو 0، تہٕ اگر نہٕ، تیلہٕ چُھ ویلیو اندازٕ تہٕ تہٕ اسکورس درمیان مطلق فرق۔ مثال: >>> (long (long) (long (long) (long (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long)
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    std::vector<long> diff;
    for (size_t i = 0; i < game.size(); ++i) {
        diff.push_back(std::abs(game[i] - guess[i]));
    }
    return diff;
}","}
int main() {
    auto candidate = compare;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));
    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));
}
"
HumanEval/153,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ آیہ کلاسک ناو (اکھ سٹرنگ) تہٕ توسیعک ویکٹر دنہٕ۔ توسیعہٕ چھ اضٲفی کلاسس کلاسس منٛز لوڈ کرنہٕ خٲطرٕ استعمال کرنہٕ ین۔ توسیعچ طاقت چھ ییتھ کیٛن: سی اے پی ییہ توسیع کس ناوس منٛز بڑے حروفن ہنٛز تعداد، تہٕ ایس ایم ییہ توسیع کس ناوس منٛز لوئرسیٹس حروفن ہنٛز تعداد، طاقت چھ کسر سی اے پی - ایس ایم سۭتۍ دنہٕ آمژ۔ توہیہ گژھ مضبوط ترین توسیع تلاش کرتھ تہٕ امہٕ شکلہٕ منٛز سٹرنگ واپس ین: ClassName.StrongestExtensionName۔ اگر اکسی طاقتک زٕ یا زیادٕ توسیعہٕ آسہٕ، توہیہ گژھ ویکٹرس منٛز گۄڈنیتھ ینس منتخب کرُن۔ مثلن، اگر توہیہ چُھ ""سلائسز"" کلاس تہٕ توسیعک ویکٹر کس طورس پیٹھ دنہٕ آمت: ['SErviSliNGCes'، 'Cheese', 'StuFfed'] تہٕ توہیہ گژھ توہیہ 'Slices.SliSliSliCliSviC' واپس کرن ییتھ ییتھ ییتھ توہیہ توہیہ گژھ 'SviSliC::::st::::::::: my: my: my: my: my: my: my: my:st: ایس ایس ایس ایس ایس ایس ایس ایس ایس ایس ایس ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس: ایس
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
","#include<assert.h>
#include<bits/stdc++.h>

int calculate_strength(const std::string& extension) {
    int cap_count = 0;
    int sm_count = 0;
    for (char c : extension) {
        if (isupper(c)) {
            cap_count++;
        } else if (islower(c)) {
            sm_count++;
        }
    }
    return cap_count - sm_count;
}

std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    if (extensions.empty()) {
        return class_name;
    }

    std::string strongest_extension = extensions[0];
    int max_strength = calculate_strength(extensions[0]);

    for (size_t i = 1; i < extensions.size(); ++i) {
        int current_strength = calculate_strength(extensions[i]);
        if (current_strength > max_strength) {
            max_strength = current_strength;
            strongest_extension = extensions[i];
        }
    }

    return class_name + ""."" + strongest_extension;
}","}
int main() {
    auto candidate = Strongest_Extension;
    assert(candidate((""Watashi""), (std::vector<std::string>({(std::string)""tEN"", (std::string)""niNE"", (std::string)""eIGHt8OKe""}))) == (""Watashi.eIGHt8OKe""));
    assert(candidate((""Boku123""), (std::vector<std::string>({(std::string)""nani"", (std::string)""NazeDa"", (std::string)""YEs.WeCaNe"", (std::string)""32145tggg""}))) == (""Boku123.YEs.WeCaNe""));
    assert(candidate((""__YESIMHERE""), (std::vector<std::string>({(std::string)""t"", (std::string)""eMptY"", (std::string)""nothing"", (std::string)""zeR00"", (std::string)""NuLl__"", (std::string)""123NoooneB321""}))) == (""__YESIMHERE.NuLl__""));
    assert(candidate((""K""), (std::vector<std::string>({(std::string)""Ta"", (std::string)""TAR"", (std::string)""t234An"", (std::string)""cosSo""}))) == (""K.TAR""));
    assert(candidate((""__HAHA""), (std::vector<std::string>({(std::string)""Tab"", (std::string)""123"", (std::string)""781345"", (std::string)""-_-""}))) == (""__HAHA.123""));
    assert(candidate((""YameRore""), (std::vector<std::string>({(std::string)""HhAas"", (std::string)""okIWILL123"", (std::string)""WorkOut"", (std::string)""Fails"", (std::string)""-_-""}))) == (""YameRore.okIWILL123""));
    assert(candidate((""finNNalLLly""), (std::vector<std::string>({(std::string)""Die"", (std::string)""NowW"", (std::string)""Wow"", (std::string)""WoW""}))) == (""finNNalLLly.WoW""));
    assert(candidate((""_""), (std::vector<std::string>({(std::string)""Bb"", (std::string)""91245""}))) == (""_.Bb""));
    assert(candidate((""Sp""), (std::vector<std::string>({(std::string)""671235"", (std::string)""Bb""}))) == (""Sp.671235""));
}
"
HumanEval/154,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہیہ چِھ 2 لفظ دنہٕ آمت۔ توہیہ چُھ ضرورت صحیح واپس کرن کہ اگر دیم لفظ یا امچ کنہہ گردش گوڑنک لفظس منٛز چِھ اکھ سبسٹنگ >>> cycpattern_check((""abcd"") ، (""abd"")) (غلط) >>> cycpattern_check((""ہیلو"") ، (""ell"")) (سچ) >>> cycpattern_check(""whassup"") ، (""psus"")) (غلط) >>> cycpattern_check(""abab"") ، (""baa"")) (سچ) >>> cycpattern_(check""efef"") ، (""eeff"") (غلط) >>> cycpattern_check(""himens"") ، (""simen"") (سچ)
bool cycpattern_check(std::string a, std::string b) {
","#include<assert.h>
#include<bits/stdc++.h>

bool cycpattern_check(std::string a, std::string b) {
    if (b.empty()) {
        return true;
    }
    if (a.length() < b.length()) {
        return false;
    }
    for (int i = 0; i < b.length(); ++i) {
        std::rotate(b.begin(), b.begin() + 1, b.end());
        if (a.find(b) != std::string::npos) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = cycpattern_check;
    assert(candidate((""xyzw""), (""xyw"")) == (false));
    assert(candidate((""yello""), (""ell"")) == (true));
    assert(candidate((""whattup""), (""ptut"")) == (false));
    assert(candidate((""efef""), (""fee"")) == (true));
    assert(candidate((""abab""), (""aabb"")) == (false));
    assert(candidate((""winemtt""), (""tinem"")) == (true));
}
"
HumanEval/155,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ انٹیجر دنہٕ آمت، اکھ ٹپل چُھ واپس کران یتھ منٛز بالترتیب برابر تہٕ عجیب ہندسن ہند تعداد آسہٕ۔ مثال: >>> even_odd_count((-12)) (std::make_tuple(1, 1)) >>> even_odd_count((123)) (std::make_tuple(1, 2)
std::tuple<long, long> even_odd_count(long num) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<tuple>

std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0;
    long odd_count = 0;
    std::string s = std::to_string(std::abs(num));
    for (char c : s) {
        int digit = c - '0';
        if (digit % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
    }
    return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_count;
    assert(candidate((7)) == (std::make_tuple(0, 1)));
    assert(candidate((-78)) == (std::make_tuple(1, 1)));
    assert(candidate((3452)) == (std::make_tuple(2, 2)));
    assert(candidate((346211)) == (std::make_tuple(3, 3)));
    assert(candidate((-345821)) == (std::make_tuple(3, 3)));
    assert(candidate((-2)) == (std::make_tuple(1, 0)));
    assert(candidate((-45347)) == (std::make_tuple(2, 3)));
    assert(candidate((0)) == (std::make_tuple(1, 0)));
}
"
HumanEval/156,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ مثبت انٹیجر دینہٕ آمت، امک رومن ہندسہٕ مساوی سٹرنگ کس طورس پیٹھ حٲصل کرُن، تہٕ لوئر کیسٹس منٛز واپس کرُن۔ پابندیاں: 1 <= num <= 1000 مثالہٕ: >>> int_to_mini_roman((19)) (""xix"") >>> int_to_mini_roman((152)) (""clii"") >>> int_to_mini_roman(426) (""cdxxvi"")
std::string int_to_mini_roman(long number) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string int_to_mini_roman(long number) {
    std::string roman = """";
    std::vector<std::pair<int, std::string>> roman_map = {
        {1000, ""m""}, {900, ""cm""}, {500, ""d""}, {400, ""cd""}, {100, ""c""},
        {90, ""xc""}, {50, ""l""}, {40, ""xl""}, {10, ""x""}, {9, ""ix""}, {5, ""v""},
        {4, ""iv""}, {1, ""i""}
    };

    for (const auto& pair : roman_map) {
        while (number >= pair.first) {
            roman += pair.second;
            number -= pair.first;
        }
    }
    return roman;
}","}
int main() {
    auto candidate = int_to_mini_roman;
    assert(candidate((19)) == (""xix""));
    assert(candidate((152)) == (""clii""));
    assert(candidate((251)) == (""ccli""));
    assert(candidate((426)) == (""cdxxvi""));
    assert(candidate((500)) == (""d""));
    assert(candidate((1)) == (""i""));
    assert(candidate((4)) == (""iv""));
    assert(candidate((43)) == (""xliii""));
    assert(candidate((90)) == (""xc""));
    assert(candidate((94)) == (""xciv""));
    assert(candidate((532)) == (""dxxxii""));
    assert(candidate((900)) == (""cm""));
    assert(candidate((994)) == (""cmxciv""));
    assert(candidate((1000)) == (""m""));
}
"
HumanEval/157,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// مثلثن ہند تریو اطرافن ہنز لمبائی دِنہٕ آمٕژ۔ اگر تریو اطراف اکھ مستحکم مثلث چِھ بناوان تہٕ دیمہٕ صورتس منٛز غلط چُھ واپس کران۔ اکھ مستحکم مثلث چِھ اکھ مثلث ییتھ منٛز اکھ زاویہ چُھ سیدھ زاویہ یا 90 ڈگری۔ مثال: >>> right_angle_triangle((3), (4), (5)) (true) >>> right_angle_triangle(1), (2), (3)) (false)
bool right_angle_triangle(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>

bool right_angle_triangle(long a, long b, long c) {
    std::vector<long> sides = {a, b, c};
    std::sort(sides.begin(), sides.end());
    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);
}","}
int main() {
    auto candidate = right_angle_triangle;
    assert(candidate((3), (4), (5)) == (true));
    assert(candidate((1), (2), (3)) == (false));
    assert(candidate((10), (6), (8)) == (true));
    assert(candidate((2), (2), (2)) == (false));
    assert(candidate((7), (24), (25)) == (true));
    assert(candidate((10), (5), (7)) == (false));
    assert(candidate((5), (12), (13)) == (true));
    assert(candidate((15), (8), (17)) == (true));
    assert(candidate((48), (55), (73)) == (true));
    assert(candidate((1), (1), (1)) == (false));
    assert(candidate((2), (2), (10)) == (false));
}
"
HumanEval/158,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اکھ فنکشن لیوکھ یتھ منٛز سٹرنگن ہنٛد ویکٹر چُھ قبول کرنہٕ یوان۔ ویکٹرس منٛز چِھ مختلف الفاظ آسان۔ لفظ چُھ زیادہ سے زیادہ منفرد کردارن سۭتۍ واپس کران۔ اگر کنہہ سٹرنگن منٛز چِھ زیادٕ سے زیادٕ منفرد کردارن ہنٛد تعداد آسان، تیلہٕ چُھ سُوٛ لَبہٕ واپس یُس پہلے لغوی ترتیبس منٛز چُھ یوان۔ >>> find_max{(std::vector<std::string>({(std::string) ""name"", (std::string) ""of"", (std::string) ""string""}))) (""string"") >>> find_max{(std::vector<std::string>({(std::string) ""name"", (std::string) ""enam"") >>> find_max{(std::vector<std::string>{(std:string) ""aaaaaa"" >>> find_max{(std::vector<std>{(std:string}""bb""string""} (""string"")
std::string find_max(std::vector<std::string> words) {
","#include<assert.h>
#include<bits/stdc++.h>

int count_unique_chars(const std::string& s) {
    std::set<char> unique_chars;
    for (char c : s) {
        unique_chars.insert(c);
    }
    return unique_chars.size();
}

std::string find_max(std::vector<std::string> words) {
    if (words.empty()) {
        return """";
    }

    std::string max_unique_word = words[0];
    int max_unique_count = count_unique_chars(words[0]);

    for (size_t i = 1; i < words.size(); ++i) {
        int current_unique_count = count_unique_chars(words[i]);
        if (current_unique_count > max_unique_count) {
            max_unique_count = current_unique_count;
            max_unique_word = words[i];
        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {
            max_unique_word = words[i];
        }
    }
    return max_unique_word;
}","}
int main() {
    auto candidate = find_max;
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""of"", (std::string)""string""}))) == (""string""));
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""enam"", (std::string)""game""}))) == (""enam""));
    assert(candidate((std::vector<std::string>({(std::string)""aaaaaaa"", (std::string)""bb"", (std::string)""cc""}))) == (""aaaaaaa""));
    assert(candidate((std::vector<std::string>({(std::string)""abc"", (std::string)""cba""}))) == (""abc""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""this"", (std::string)""game"", (std::string)""of"", (std::string)""footbott""}))) == (""footbott""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""gonna"", (std::string)""rock""}))) == (""gonna""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""a"", (std::string)""mad"", (std::string)""nation""}))) == (""nation""));
    assert(candidate((std::vector<std::string>({(std::string)""this"", (std::string)""is"", (std::string)""a"", (std::string)""prrk""}))) == (""this""));
    assert(candidate((std::vector<std::string>({(std::string)""b""}))) == (""b""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""play"", (std::string)""play""}))) == (""play""));
}
"
HumanEval/159,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// توہہ چھہِ بھوک مٲرۍ، تہ توہہ چھہِ گارٹین ہنز اکھ مخصوص تعداد کھٲم کرمت، مگر از چھہِ توہہ دنہک کھین مکمل کرنہ خاطرہ مزید گارٹین کھینچ ضرورت۔ توہہ پزِ [ کھینس پتہ گارٹین ہنز کل تعداد، کھینس پتہ گارٹین ہنز تعداد ] اکھ ویکٹر واپس کرُن اگر نہٕ پورہ گارٹین روزِ، توہہ چھہِ باقی گارٹین کھینن، مگر توہہ گژھہِ وُنہِ بھوک۔ مثال: >>> کھین (((5), (6), (10)) (std::vector<long>{()11, (long) 4}) >>> کھین ((4), (8), (9) (std::vector<long>{() 12, ( (1})) >>> کھین ((1), (10), (10) (std::vector<long>{(11, (long) 0)) >>> کھین ((2), (11), (5) (std::vector<<d>{0, (long)) V: integer number of remaining carrots that you need to eat in stock: 1000) * کنٹریٹرینٹ = انٹیجر: 0 = انٹیجر: 0 انٹیجر: 0 @ تمن ہند تعداد یمہِ باقی یمہِ گارٹین گارٹین ہنز ضرورت چھہ کھینن۔
std::vector<long> eat(long number, long need, long remaining) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> eat(long number, long need, long remaining) {
    long eaten = 0;
    long left = remaining;
    long to_eat = need;

    if (left >= to_eat) {
        eaten = to_eat;
        left -= to_eat;
    } else {
        eaten = left;
        left = 0;
    }

    return {(long)number + eaten, left};
}","}
int main() {
    auto candidate = eat;
    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));
    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));
    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));
    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));
    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));
    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));
}
"
HumanEval/160,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// دوٚن ویکٹر آپریٹر تہٕ آپریڈنڈس دنہٕ آمت۔ گۄڈنیُک ویکٹر چُھ بنیادی الجبرا آپریشنہٕ، تہٕ دوٚیم ویکٹر چُھ انٹیجرزُک ویکٹر۔ الجبرا اظہارٕ بنانہٕ خٲطرٕ دوٚن دیتمتن ویکٹرن ہنٛد استعمال کٔرو تہٕ امہ اظہارچ تشخیص واپس وٲتھ۔ بنیادی الجبرا آپریشن: جمع (+) گھٹاؤ (-) ضرب (*) فلور ڈویژن (//) ایکسپوننسیشن (**) مثال: آپریٹر['+'، '*'، '-'] ویکٹر = [2, 3, 4, 5] نتیجہ = 2 + 3 * 4 - 5 => نتیجہ = 9 نوٹ: آپریٹرن ویکٹرچ لمبائی چِھ آپریٹرن ویکٹر کس لمبائی برابر مائنس ون۔ آپریٹرن ویکٹر چُھ غٲر منفی انٹیجرن ہنٛد ویکٹر۔ آپریٹر ویکٹر چُھ کم کھوتہٕ کم اکھ آپریٹر آسان، تہٕ آپریٹرن ویکٹر چُک کم کھوتہٕ کم زٕ آپریٹرن چِھ آسان۔
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
","#include<assert.h>
#include<bits/stdc++.h>

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    std::vector<long> current_operand = operand;
    std::vector<std::string> current_operator = op;

    auto apply_op = [&](long a, long b, const std::string& o) {
        if (o == ""+"") return a + b;
        if (o == ""-"") return a - b;
        if (o == ""*"") return a * b;
        if (o == ""//"") return a / b;
        if (o == ""**"") return static_cast<long>(pow(a, b));
        return 0L; // Should not happen
    };

    std::vector<std::string> precedence1 = {""**""};
    std::vector<std::string> precedence2 = {""*"", ""//""};
    std::vector<std::string> precedence3 = {""+"", ""-""};

    auto evaluate = [&](const std::vector<std::string>& prec) {
        size_t i = 0;
        while (i < current_operator.size()) {
            bool found = false;
            for (const auto& o : prec) {
                if (current_operator[i] == o) {
                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);
                    current_operand.erase(current_operand.begin() + i + 1);
                    current_operator.erase(current_operator.begin() + i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                i++;
            }
        }
    };

    evaluate(precedence1);
    evaluate(precedence2);
    evaluate(precedence3);

    return current_operand[0];
}","}
int main() {
    auto candidate = do_algebra;
    assert(candidate((std::vector<std::string>({(std::string)""**"", (std::string)""*"", (std::string)""+""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));
    assert(candidate((std::vector<std::string>({(std::string)""+"", (std::string)""*"", (std::string)""-""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));
    assert(candidate((std::vector<std::string>({(std::string)""//"", (std::string)""*""})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));
}
"
HumanEval/161,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اگر s[i] چُھ اکھ حرف، تہٕ توہیہ چِھ اتھ پیٹھ پنن کیس تبدیل کرُن، یا بییہٕ ییہٕ برقرار تھاوُن۔ اگر سٹرنگس منٛز چُھنہٕ کنہہ حرف، سٹرنگس تبدیل کرُن۔ فنکشن گژھہٕ نتائجی سٹرنگ واپس کرٕن۔ مثالہٕ >>> حل کریں((""1234"")) (""4321"") >>> حل کریں((""ab"")) (""AB"") >>> حل کریں""#a@C"") (""#A@c"")
std::string solve(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string solve(std::string s) {
    bool has_letter = false;
    for (char c : s) {
        if (isalpha(c)) {
            has_letter = true;
            break;
        }
    }

    if (has_letter) {
        for (char& c : s) {
            if (islower(c)) {
                c = toupper(c);
            } else if (isupper(c)) {
                c = tolower(c);
            }
        }
    } else {
        std::reverse(s.begin(), s.end());
    }
    return s;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((""AsDf"")) == (""aSdF""));
    assert(candidate((""1234"")) == (""4321""));
    assert(candidate((""ab"")) == (""AB""));
    assert(candidate((""#a@C"")) == (""#A@c""));
    assert(candidate((""#AsdfW^45"")) == (""#aSDFw^45""));
    assert(candidate((""#6@2"")) == (""2@6#""));
    assert(candidate((""#$a^D"")) == (""#$A^d""));
    assert(candidate((""#ccc"")) == (""#CCC""));
}
"
HumanEval/162,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// اگر اکھ سٹرنگ 'ٹیکسٹ' چُھ دِنہٕ آمُت، تہٕ ایم ڈی 5 ہیش مساوی سٹرنگ چُھ واپس کران۔ اگر 'ٹیکسٹ' اکھ خٲلی سٹرنگ چُھ، تہٕ چُھ واپس نون۔ >>> string_to_md5((""ہیلو ورلڈ"")) ""3e25960a79dbc69b674cd4ec67a72c62""
std::optional<std::string> string_to_md5(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>
#include <optional>

#include <openssl/md5.h>
#include <iomanip>
#include <sstream>

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return std::nullopt;
    }

    unsigned char digest[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), digest);

    std::stringstream ss;
    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];
    }
    return ss.str();
}","}
int main() {
    auto candidate = string_to_md5;
    assert(candidate((""Hello world"")) == ""3e25960a79dbc69b674cd4ec67a72c62"");
    assert(candidate(("""")) == std::nullopt);
    assert(candidate((""A B C"")) == ""0ef78513b0cb8cef12743f5aeb35f888"");
    assert(candidate((""password"")) == ""5f4dcc3b5aa765d61d8327deb882cf99"");
}
"
HumanEval/163,kas_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// دوٛن مثبت انٹیجرزن a تہٕ b دنہٕ آمت، a تہٕ b درمیان چُھ ہندسن ہند تعداد بڑھنہٕ کہِ ترتیبس منز واپس کران۔ مثال کہِ طورس پیٹھ: >>> generate_integers((2), (8)) (std::vector<long>({long)2, (long)4, (long)6, (long)8})) >>> generate_integers((8), (2)) (std::vector<long>({long)2, (long)4, (long)6, (long)8})) >>> generate_integers((10), (14) (std::vector<long>())
std::vector<long> generate_integers(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    long start = std::min(a, b);
    long end = std::max(a, b);
    for (long i = start; i <= end; ++i) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;
}","}
int main() {
    auto candidate = generate_integers;
    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((17), (89)) == (std::vector<long>()));
}
"
