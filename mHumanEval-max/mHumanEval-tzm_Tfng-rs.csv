task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,tzm_Tfng,rs,"/// ⴰⵥⵟⵟⴰ ⴰⴽⴽⵡ /// ⵙⵙⵉⵔⵉⴷ ⴳ ⵓⵎⵉⴹⴰⵏ ⵏ ⵓⴽⵜⵓⵔ, ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏⵏ ⵢⴰⴹⵏⵉⵏ ⵢⵓⴳⵔⵏ /// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)
/// false
/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
/// true
fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {
","fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {
    for i in 0..numbers.len() {
        for j in (i + 1)..numbers.len() {
            if (numbers[i] - numbers[j]).abs() < threshold {
                return true;
            }
        }
    }
    false
}","}

fn main() {
    let candidate = has_close_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);
}
"
HumanEval_1,tzm_Tfng,rs,"/// ⵓⵔ ⴷⴰ ⵏⵙⵙⴽⵜⵉ ⴽⵔⴰ ⵏ ⵡⴰⵏⵙⴰ ⴳ ⵜⵣⵍⵉⵜ ⵏ ⵓⵙⴽⵛⵎ. /// ⵜⵔⴰⴱⴱⵓⵜⵉⵏ ⵉⴱⴹⴰⵏ ⵜⵜⵓⵙⵎⵙⴰⵙⴰⵏ (ⵢⴰⵜⵜⵓⵇⵇⵏ ⴽⵓ ⵢⴰⵏ ⵏ ⵓⴱⵕⴰⵟⴰⵚ ⵉⵕⵥⵎⵏ ⵙ ⵜⵖⴰⵔⴰⵙⵜ ⵉⵖⵓⴷⴰⵏ) ⴷ ⵓⵔ ⵜⵜⵓⵙⵎⵓⵏ ⴳ ⵢⴰⵏ /// ⴰⴷ ⵏⵙⴱⴹ ⵜⴰⵔⴰⴱⴱⵓⵜ ⴰⴷ ⵖⵔ ⵜⵉⴼⵉⵏⴰⵖ ⵉⵥⵍⵉⵏ ⴷ ⴰⴷ ⵏⵔⴰⵔ ⴰⴱⴽⴽⵉⴹ ⵏ ⵜⵉⴼⵉⵏⴰⵖ. /// ⴰⵙⴽⵛⵎ ⵙ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵏ ⵉⴽⵛⵛⵓⵎⵏ ⵉⵎⵣⴳⵓⵏⵏ. ⴰⵡⵜⵜⴰⵙ ⵏⵏⴽ ⵉⴳⴰ ⴰⴷ /// >>> separate_paren_groups(String::from(""( ) (( )) (( )( ))""))
/// vec![String::from(""()""), String::from(""(())""), String::from(""(()())"")]
fn separate_paren_groups(paren_string: String) -> Vec<String> {
","fn separate_paren_groups(paren_string: String) -> Vec<String> {
    let mut groups = Vec::new();
    let mut current_group = String::new();
    let mut open_count = 0;

    for char in paren_string.chars() {
        if char == '(' {
            open_count += 1;
            current_group.push(char);
        } else if char == ')' {
            open_count -= 1;
            current_group.push(char);
        }

        if open_count == 0 && !current_group.is_empty() {
            groups.push(current_group.clone());
            current_group.clear();
        }
    }

    groups
}","}

fn main() {
    let candidate = separate_paren_groups;
    assert_eq!(candidate(String::from(""(()()) ((())) () ((())()())"")), vec![String::from(""(()())""), String::from(""((()))""), String::from(""()""), String::from(""((())()())"")]);
    assert_eq!(candidate(String::from(""() (()) ((())) (((())))"")), vec![String::from(""()""), String::from(""(())""), String::from(""((()))""), String::from(""(((())))"")]);
    assert_eq!(candidate(String::from(""(()(())((())))"")), vec![String::from(""(()(())((())))"")]);
    assert_eq!(candidate(String::from(""( ) (( )) (( )( ))"")), vec![String::from(""()""), String::from(""(())""), String::from(""(()())"")]);
}
"
HumanEval_2,tzm_Tfng,rs,"/// ⵙⵏⵓⵍⴼⵓ ⵜⴰⴳⵣⵣⵓⵎⵜ ⵏ ⵓⵟⵟⵓⵏ ⵏ ⵜⵓⵙⴷⵉⴷⵜ. /// (ⴰⴳⵣⵣⵓⵎ ⵏ ⵓⵃⴹⵓ ⴰⵀⴰ ⵉⵎⵥⵥⵉⵢⵏ ⵙⴳ 1). /// ⴷ ⵓⴳⵣⵣⵓⵎ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ (ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⵉⵎⵥⵥⵉⵢⵏ ⵙⴳ ⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⴼⴽⴰⵏ) ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⵔⴰⵡⵏ /// ⵙ ⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵎⵙⵙⵓⴷⵓ, ⵏⵣⵎⵔ ⴰⴷ ⵏⵙⴱⴹ /// >>> truncate_number(3.5)
/// 0.5
fn truncate_number(number: f64) -> f64 {
","fn truncate_number(number: f64) -> f64 {
    number - number.floor()
}

fn main() {
    println!(""{}"", truncate_number(3.5)); // 0.5
}","}

fn main() {
    let candidate = truncate_number;
    assert_eq!(candidate(3.5), 0.5);
    assert_eq!(candidate(1.25), 0.25);
    assert_eq!(candidate(123.0), 0.0);
}
"
HumanEval_3,tzm_Tfng,rs,"/// ⴳ ⵓⵙⴰⵜⵉ ⴷⵖ, ⵔⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ true. ⵎⴽ ⵓⵔ ⵜⵔⴰⵔ, ⵔⴰⴷ ⵜⵔⴰⵔ false./// ⴰⵣⵓⵍ ⵏ ⵓⵎⵢⴰ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⴼⵍⴷ ⵎⴽ ⴳ ⴽⵔⴰ ⵏ ⵜⴰⵙⴳⴰ ⵉⵣⵡⴰⵔ ⵓⵣⵓⵍ ⵏ ⵓⵎⵢⴰ, ⴷ /// ⴰⵖ ⴷ ⵢⵓⴼⴰ ⵢⴰⵏ ⵓⴱⴰⵢⵢⵓⵕ ⵏ ⵜⵎⵀⵍⵉⵡⵉⵏ ⵏ ⵓⵙⵙⴰⵔⵓ ⴷ ⵓⵙⵙⴰⵢ ⴳ ⵢⴰⵏ ⵓⴽⵓⵏⵟⵓ ⵏ ⵍⴱⴰⵏⴽ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵙ /// >>> below_zero(vec![1, 2, 3])
/// false
/// >>> below_zero(vec![1, 2, -4, 5])
/// true
fn below_zero(operations: Vec<isize>) -> bool {
","fn below_zero(operations: Vec<isize>) -> bool {
    let mut balance = 0;
    for operation in operations {
        balance += operation;
        if balance < 0 {
            return true;
        }
    }
    false
}

fn main() {
    println!(""{}"", below_zero(vec![1, 2, 3])); // false
    println!(""{}"", below_zero(vec![1, 2, -4, 5])); // true
    println!(""{}"", below_zero(vec![1, -1, -1, 2])); // true
}","}

fn main() {
    let candidate = below_zero;
    assert_eq!(candidate(Vec::<isize>::new()), false);
    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);
    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);
    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);
}
"
HumanEval_4,tzm_Tfng,rs,"/// MAD = ⴰⵙⵖⵏ ∙ x - x_mean ∙/// ⴰⴳⵣⵣⵓⵎ ⴷ ⵜⵏⵇⵇⵉⴹⵜ ⵜⴰⵏⴰⵎⵎⴰⵙⵜ (ⴰⵎⵎⴰⵙⵙ ⴳ ⵡⴰⴷⴷⴰⴷ ⴰⴷ): /// Mean Absolute Deviation ⴷ ⴰⵎⵣⴰⵔⴰⵢ ⴰⵎⵏⴹⴰⵏ ⴰⵖⴰⵔⵉⵎ ⴳⵔ ⴽⵓ /// ⴰⵜⵜⴰⵢⵏ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵜⵔⴰⴱⴱⵓⵜ ⵏ ⵉⵙⵎⵎⴰⵍⵏ ⴰⴷ. /// ⵉ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵛⵛⵓⵎ, ⵙⵙⵉⴹⵏ ⴰⵎⵏⵣⴰⵢ ⴰⵖⴰⵔⴰⵏ /// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])
/// 1.0
fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {
","fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {
    let n = numbers.len() as f64;
    if n == 0.0 {
        return 0.0;
    }

    let mean: f64 = numbers.iter().sum::<f64>() / n;
    let mad: f64 = numbers.iter().map(|&x| (x - mean).abs()).sum::<f64>() / n;
    
    mad
}

fn main() {
    let numbers = vec![1.0, 2.0, 3.0, 4.0];
    println!(""{}"", mean_absolute_deviation(numbers)); // Output: 1.0
}","}

fn main() {
    let candidate = mean_absolute_deviation;
    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);
}
"
HumanEval_5,tzm_Tfng,rs,"/// ⵙⵙⴽⵛⵎ ⴰⵎⴹⴰⵏ ""ⴷⵉⵍⵉⵜⵔⵓⵎ"" ⴳⵔ ⴽⵓ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⴹⴼⴰⵕⵏ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ∀numbers"" /// >>> intersperse(vec![], 4)
/// Vec::<isize>::new()
/// >>> intersperse(vec![1, 2, 3], 4)
/// vec![1, 4, 2, 4, 3]
fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {
","fn intersperse(numbers: Vec<isize>, delimiter: isize) -> Vec<isize> {
    if numbers.is_empty() {
        return Vec::new();
    }
    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);
    for (i, &num) in numbers.iter().enumerate() {
        result.push(num);
        if i != numbers.len() - 1 {
            result.push(delimiter);
        }
    }
    result
}

fn main() {
    println!(""{:?}"", intersperse(vec![], 4)); // Output: Vec::<isize>::new()
    println!(""{:?}"", intersperse(vec![1, 2, 3], 4)); // Output: vec![1, 4, 2, 4, 3]
}","}

fn main() {
    let candidate = intersperse;
    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);
    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);
}
"
HumanEval_6,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ (() (()) ⵖⵓⵔⵙ ⵙⵉⵏ ⵉⵙⵡⵉⵔⵏ ⵏ ⵓⵖⵔⵔⴰⴱⵓ ⴳ ⵜⵉⵣⵉ ⵏⵏⴰ ⴳ ((())) ⵖⵓⵔⵙ ⴽⵕⴰⴹ. /// ⵉ ⴽⵓ ⵜⴰⵔⴰⴱⴱⵓⵜ, ⵙⵙⵓⴼⵖ ⴰⵙⵡⵉⵔ ⵏ ⵓⵙⵎⵓⵏ ⵏ ⵜⴱⵕⴰⵏⴽⵉⵙⵉⵏ. /// ⴰⵙⴽⵛⵎ ⵏ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵜⵓⵎ ⵉⵙⵎⴷⵢⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵉ ⵉⴽⵛⵛⵓⵎⵏ ⵏ ⵜⴱⵕⴰⵏⴽⵉⵙⵜⵉⵏ ⵉⵜⵜⵓⵣⵍⴰⵢⵏ ⵙ ⵉⵎⵏⴷⵉ. /// >>> parse_nested_parens(String::from(""(()()) ((())) () ((())()())""))
/// vec![2, 3, 1, 3]
fn parse_nested_parens(paren_string: String) -> Vec<isize> {
","fn parse_nested_parens(paren_string: String) -> Vec<isize> {
    paren_string.split_whitespace().map(|group| {
        let mut max_depth = 0;
        let mut current_depth = 0;
        for char in group.chars() {
            match char {
                '(' => {
                    current_depth += 1;
                    if current_depth > max_depth {
                        max_depth = current_depth;
                    }
                },
                ')' => {
                    current_depth -= 1;
                },
                _ => {}
            }
        }
        max_depth
    }).collect()
}

fn main() {
    let result = parse_nested_parens(String::from(""(()()) ((())) () ((())()())""));
    println!(""{:?}"", result); // Output: [2, 3, 1, 3]
}","}

fn main() {
    let candidate = parse_nested_parens;
    assert_eq!(candidate(String::from(""(()()) ((())) () ((())()())"")), vec![2, 3, 1, 3]);
    assert_eq!(candidate(String::from(""() (()) ((())) (((())))"")), vec![1, 2, 3, 4]);
    assert_eq!(candidate(String::from(""(()(())((())))"")), vec![4]);
}
"
HumanEval_7,tzm_Tfng,rs,"/// ⵙⵙⵓⴼⵖ ⵏ ⵓⵎⵙⵙⵉⴹⵏ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ /// >>> filter_by_substring(vec![], String::from(""a""))
/// Vec::<String>::new()
/// >>> filter_by_substring(vec![String::from(""abc""), String::from(""bacd""), String::from(""cde""), String::from(""array"")], String::from(""a""))
/// vec![String::from(""abc""), String::from(""bacd""), String::from(""array"")]
fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {
","fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {
    strings.into_iter().filter(|s| s.contains(&substring)).collect()
}","}

fn main() {
    let candidate = filter_by_substring;
    assert_eq!(candidate(Vec::<String>::new(), String::from(""john"")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""xxx""), String::from(""asd""), String::from(""xxy""), String::from(""john doe""), String::from(""xxxAAA""), String::from(""xxx"")], String::from(""xxx"")), vec![String::from(""xxx""), String::from(""xxxAAA""), String::from(""xxx"")]);
    assert_eq!(candidate(vec![String::from(""xxx""), String::from(""asd""), String::from(""aaaxxy""), String::from(""john doe""), String::from(""xxxAAA""), String::from(""xxx"")], String::from(""xx"")), vec![String::from(""xxx""), String::from(""aaaxxy""), String::from(""xxxAAA""), String::from(""xxx"")]);
    assert_eq!(candidate(vec![String::from(""grunt""), String::from(""trumpet""), String::from(""prune""), String::from(""gruesome"")], String::from(""run"")), vec![String::from(""grunt""), String::from(""prune"")]);
}
"
HumanEval_8,tzm_Tfng,rs,"/// ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵓⵎⴹⴰⵏ ⵏ ⵜⴷⵔⵉⵎⵜ 0 ⴷ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵓⵢⴰⴼⵓ ⵏ ⵜⴷⵔⵉⵎⵜ 1. /// ⵉ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵓⵏⵖⵉⵍⵜ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵖⵣⵓⵔ ⴷ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⴽⵜⵓⵔ. /// >>> sum_product(vec![])
/// (0, 1)
/// >>> sum_product(vec![1, 2, 3, 4])
/// (10, 24)
fn sum_product(numbers: Vec<isize>) -> (isize, isize) {
","fn sum_product(numbers: Vec<isize>) -> (isize, isize) {
    let sum = numbers.iter().sum();
    let product = numbers.iter().fold(1, |acc, &x| acc * x);
    (sum, product)
}

fn main() {
    println!(""{:?}"", sum_product(vec![])); // (0, 1)
    println!(""{:?}"", sum_product(vec![1, 2, 3, 4])); // (10, 24)
}","}

fn main() {
    let candidate = sum_product;
    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));
    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));
    assert_eq!(candidate(vec![100, 0]), (100, 0));
    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));
    assert_eq!(candidate(vec![10]), (10, 10));
}
"
HumanEval_9,tzm_Tfng,rs,"/// ⴳ ⵓⴹⴼⴼⵓⵕ. /// ⵙⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵓⴽⵙⴰⵢ ⴰⵅⴰⵜⴰⵔ ⵉⵜⵜⵢⴰⴼⴰⵏ ⴰⵔ ⵜⵉⵣⵉ ⵏⵏⴰ ⵔⴰⴷ ⵉⵜⵜⵢⴰⴼⴰ./// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])
/// vec![1, 2, 3, 3, 3, 4, 4]
fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {
","fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {
    let mut result = Vec::new();
    let mut current_max = isize::MIN;
    for &num in &numbers {
        if num > current_max {
            current_max = num;
        }
        result.push(current_max);
    }
    result
}","}

fn main() {
    let candidate = rolling_max;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);
    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);
}
"
HumanEval_10,tzm_Tfng,rs,"/// - ⴰⴷ ⵏⴰⵔⵉ ⴳ ⵜⴳⵉⵔⴰ ⵏ ⵓⴱⵔⵔⵉⴷ ⵏ ⵓⴱⵔⵔⵉⴷ ⵏ ⵓⵙⵏⵜⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵣⵎⵎⴻⵎⵏ ⴷⴰⵜ ⵏ ⵓⴷⵎ ⵏ ⵓⴱⴰⵍⵉⵏⴷⵔⵓⵎ. /// - ⵥⵕ ⵜⴰⴳⵓⵔⵉ ⵜⴰⵖⵣⵉⴼⵜ ⵏ ⵓⵖⵉⵍⵓⴼ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵏⵏⴰ ⵉⴳⴰⵏ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ. /// ⵜⴰⵏⵎⵎⵉⵔⵜ ⵏ ⴰⵍⴳⵓⵔⵉⵜⵎ ⵉⴳⴰ ⴰⵎⵙⴷⵓⵙ: ///ⴰⴼ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ ⵜⴰⵔⵓⵙⵜ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵙ ⵢⴰⵏ ⵓⵖⵉⵍⵓⴼ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ. /// >>> make_palindrome(String::from(""""))
/// String::from("""")
/// >>> make_palindrome(String::from(""cat""))
/// String::from(""catac"")
/// >>> make_palindrome(String::from(""cata""))
/// String::from(""catac"")
fn make_palindrome(string: String) -> String {
","fn make_palindrome(string: String) -> String {
    fn is_palindrome(s: &str) -> bool {
        s.chars().eq(s.chars().rev())
    }

    if string.is_empty() || is_palindrome(&string) {
        return string;
    }

    for i in (0..string.len()).rev() {
        if is_palindrome(&string[i..]) {
            let prefix = &string[..i];
            let reversed_prefix: String = prefix.chars().rev().collect();
            return string + &reversed_prefix;
        }
    }

    string
}

fn main() {
    println!(""{:?}"", make_palindrome(String::from(""""))); // String::from("""")
    println!(""{:?}"", make_palindrome(String::from(""cat""))); // String::from(""catac"")
    println!(""{:?}"", make_palindrome(String::from(""cata""))); // String::from(""catac"")
}","}

fn main() {
    let candidate = make_palindrome;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""x"")), String::from(""x""));
    assert_eq!(candidate(String::from(""xyz"")), String::from(""xyzyx""));
    assert_eq!(candidate(String::from(""xyx"")), String::from(""xyx""));
    assert_eq!(candidate(String::from(""jerry"")), String::from(""jerryrrej""));
}
"
HumanEval_11,tzm_Tfng,rs,"/// ⵙⴽⵔ XOR ⴱⵉⵏⴰⵔⵉ ⵅⴼ ⵉⵙⴽⴽⵉⵍⵏ ⴰⴷ ⵏ ⵓⵙⴽⵛⵎ ⴷ ⵜⵔⴰⵔ ⵜⴰⵢⴰⴼⵓⵜ ⴰⵡⴷ ⵏⵜⵜⴰⵜ ⴰⵎⵎ ⵜⵉⴼⵉⵏⴰⵖ. /// Input ⴳⴰⵏ ⵙⵉⵏ ⵉⵙⴽⴽⵉⵍⵏ a ⴷ b ⴳ ⵍⵍⴰⵏ 1 ⴷ 0 ⵅⴰⵙ. /// >>> string_xor(String::from(""010""), String::from(""110""))
/// String::from(""100"")
fn string_xor(a: String, b: String) -> String {
","fn string_xor(a: String, b: String) -> String {
    a.chars()
     .zip(b.chars())
     .map(|(char_a, char_b)| if char_a == char_b { '0' } else { '1' })
     .collect()
}","}

fn main() {
    let candidate = string_xor;
    assert_eq!(candidate(String::from(""111000""), String::from(""101010"")), String::from(""010010""));
    assert_eq!(candidate(String::from(""1""), String::from(""1"")), String::from(""0""));
    assert_eq!(candidate(String::from(""0101""), String::from(""0000"")), String::from(""0101""));
}
"
HumanEval_12,tzm_Tfng,rs,"/// ⵜⵉⴼⵉⵏⴰⵖ ⵏ ⵜⵉⵖⵣⵉ ⵏⵏⴰⵖ. ⵔⴰⴷ ⵏⵔⴰⵔ None ⴳ ⵡⴰⴷⴷⴰⴷ ⵏ ⵓⴱⴽⴽⵉⴹ ⵏ ⵓⴽⵛⵛⵓⵎ ⵉⴳⴰⵏ ⵡⴰⴽⴰⵍ. /// ⴳ ⵓⴱⴰⵢⵢⵓⵕ ⵏ ⵉⵙⴽⴽⵉⵍⵏ, ⵙⴽⵔ ⴰⵙⴽⴽⵉⵍ ⴰⵣⵣⴰⵢⵔⵉ. ⵙⴽⵔ ⴰⵙⴽⴽⵉⵍ ⴰⵎⵣⵡⴰⵔⵓ ⴳ ⵡⴰⴷⴷⴰⴷ ⵏ ⴽⵉⴳⴰⵏ /// >>> longest(vec![])
/// None
/// >>> longest(vec![String::from(""a""), String::from(""b""), String::from(""c"")])
/// Some(String::from(""a""))
/// >>> longest(vec![String::from(""a""), String::from(""bb""), String::from(""ccc"")])
/// Some(String::from(""ccc""))
fn longest(strings: Vec<String>) -> Option<String> {
","fn longest(strings: Vec<String>) -> Option<String> {
    strings.into_iter().max_by_key(|s| s.len())
}","}

fn main() {
    let candidate = longest;
    assert_eq!(candidate(Vec::<String>::new()), None);
    assert_eq!(candidate(vec![String::from(""x""), String::from(""y""), String::from(""z"")]), Some(String::from(""x"")));
    assert_eq!(candidate(vec![String::from(""x""), String::from(""yyy""), String::from(""zzzz""), String::from(""www""), String::from(""kkkk""), String::from(""abc"")]), Some(String::from(""zzzz"")));
}
"
HumanEval_13,tzm_Tfng,rs,"/// ⴰⴷ ⵏⵔⴰⵔ ⴰⵎⵟⵟⵓ ⴰⵎⵛⵛⴰⵔⵏ ⴰⵅⴰⵜⴰⵔ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⴷ b /// >>> greatest_common_divisor(3, 5)
/// 1
/// >>> greatest_common_divisor(25, 15)
/// 5
fn greatest_common_divisor(a: isize, b: isize) -> isize {
","fn greatest_common_divisor(mut a: isize, mut b: isize) -> isize {
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a
}","}

fn main() {
    let candidate = greatest_common_divisor;
    assert_eq!(candidate(3, 7), 1);
    assert_eq!(candidate(10, 15), 5);
    assert_eq!(candidate(49, 14), 7);
    assert_eq!(candidate(144, 60), 12);
}
"
HumanEval_14,tzm_Tfng,rs,"/// ⴰⴱⵔⵉⴷ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⴽⵓⵍⵍⵓ ⵉⵙⵏⴼⴰⵔⵏ ⵙⴳ ⵓⵥⵥⵥⵓ ⴰⵔ ⵓⵣⵣⵓⵣⵔ ⵏ ⵜⵣⵍⵉⵜ ⵏ ⵓⵙⴽⵛⵎ /// >>> all_prefixes(String::from(""abc""))
/// vec![String::from(""a""), String::from(""ab""), String::from(""abc"")]
fn all_prefixes(string: String) -> Vec<String> {
","fn all_prefixes(string: String) -> Vec<String> {
    let mut prefixes = Vec::new();
    for i in 1..=string.len() {
        prefixes.push(string[..i].to_string());
    }
    prefixes
}

// Example usage
fn main() {
    let prefixes = all_prefixes(String::from(""abc""));
    println!(""{:?}"", prefixes);
}","}

fn main() {
    let candidate = all_prefixes;
    assert_eq!(candidate(String::from("""")), Vec::<String>::new());
    assert_eq!(candidate(String::from(""asdfgh"")), vec![String::from(""a""), String::from(""as""), String::from(""asd""), String::from(""asdf""), String::from(""asdfg""), String::from(""asdfgh"")]);
    assert_eq!(candidate(String::from(""WWW"")), vec![String::from(""W""), String::from(""WW""), String::from(""WWW"")]);
}
"
HumanEval_15,tzm_Tfng,rs,"/// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵜⵜⵓⵙⵏⴽⴰⴷⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ ⴳⵔ 0 ⴷ n. /// >>> string_sequence(0)
/// String::from(""0"")
/// >>> string_sequence(5)
/// String::from(""0 1 2 3 4 5"")
fn string_sequence(n: isize) -> String {
","fn string_sequence(n: isize) -> String {
    (0..=n).map(|num| num.to_string()).collect::<Vec<String>>().join("" "")
}","}

fn main() {
    let candidate = string_sequence;
    assert_eq!(candidate(0), String::from(""0""));
    assert_eq!(candidate(3), String::from(""0 1 2 3""));
    assert_eq!(candidate(10), String::from(""0 1 2 3 4 5 6 7 8 9 10""));
}
"
HumanEval_16,tzm_Tfng,rs,"/// ⵙ ⵓⴽⵙⵉⵍ, ⵙⵙⵏⵖ ⵎⵏⵏⴰⵡ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ (ⵓⵔ ⵏⵙⵙⵉⵏ ⵎⴰⵏⵉ ⵉⴳⴰ ⵡⴰⴷⴷⴰⴷ) /// >>> count_distinct_characters(String::from(""xyzXYZ""))
/// 3
/// >>> count_distinct_characters(String::from(""Jerry""))
/// 4
fn count_distinct_characters(string: String) -> isize {
","use std::collections::HashSet;

fn count_distinct_characters(string: String) -> isize {
    let lowercase_string = string.to_lowercase();
    let distinct_chars: HashSet<char> = lowercase_string.chars().collect();
    distinct_chars.len() as isize
}","}

fn main() {
    let candidate = count_distinct_characters;
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""abcde"")), 5);
    assert_eq!(candidate(String::from(""abcdecadeCADE"")), 5);
    assert_eq!(candidate(String::from(""aaaaAAAAaaaa"")), 1);
    assert_eq!(candidate(String::from(""Jerry jERRY JeRRRY"")), 5);
}
"
HumanEval_17,tzm_Tfng,rs,"//"" 'ⴽⵓⴹⴰⴽⴰ "" ' - ⴰⵖⵔⵔⴰⴱⵓ ⵏ ⴽⴽⵓⵥ, ⵉⵇⵇⵉⵎ ⵢⴰⵏ ⵓⴽⵓⴷ ///o ""ⴰⴷⵊⵉⴷ"" - ⴰⵣⴳⵏ ⵏ ⵓⵏⴰⴹ, ⴷⴰ ⵉⵜⵜⴳⴳ ⵙⵏⴰⵜ ⵜⵓⵔⵉⵏ /// 'o' - ⴰⵖⵏⵏⵉⵊ ⴰⴽⴽⵡ, ⴷⴰ ⵉⵜⵜⴳⴳⴰⵔ ⴽⴽⵓⵥ ⵏ ⵉⵔⵖⴰⵏ /// ⵀⴰ ⵢⴰⵏ ⵓⵎⵣⵔⵓⵢ: /// ⵓⵔ ⴷ ⴰⵎⴳⴳⴰⵔⵓ. /// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴼⵙⵉ ⵜⴰⵡⴰⵍⵜ ⴰⴷ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵉⵎⵉⴹⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⴽⵉⴳⴰⵏ ⵏ ⵉⵎⵉⴹⵏ ⵏⵏⴰ ⴷⴰ ⵉⵜⵜⴳⴳ ⴽⵓ ⵢⴰⵏ /// ⴰⵙⴽⵛⵎ ⵏ ⵜⵡⵓⵔⵉ ⴰⴷ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵜⵓⵎ ⵉⵙⵎⴷⵢⴰⵏ ⵜⵉⵔⵔⴰ ⵏ ⵓⵥⴰⵡⴰⵏ ⵙ ⵢⴰⵜ ⵜⵍⵖⴰ ⵏ ASCII ⵉⵥⵍⵉⵏ. /// >>> parse_music(String::from(""o o| .| o| o| .| .| .| .| o o""))
/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
fn parse_music(music_string: String) -> Vec<isize> {
","fn parse_music(music_string: String) -> Vec<isize> {
    let mut result = Vec::new();
    let notes: Vec<&str> = music_string.split_whitespace().collect();

    for note in notes {
        match note {
            ""o"" => result.push(4),
            ""o|"" => result.push(2),
            "".|"" => result.push(1),
            _ => (),
        }
    }

    result
}

fn main() {
    let music_string = String::from(""o o| .| o| o| .| .| .| .| o o"");
    let beats = parse_music(music_string);
    println!(""{:?}"", beats); // Outputs: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
}","}

fn main() {
    let candidate = parse_music;
    assert_eq!(candidate(String::from("""")), Vec::<isize>::new());
    assert_eq!(candidate(String::from(""o o o o"")), vec![4, 4, 4, 4]);
    assert_eq!(candidate(String::from("".| .| .| .|"")), vec![1, 1, 1, 1]);
    assert_eq!(candidate(String::from(""o| o| .| .| o o o o"")), vec![2, 2, 1, 1, 4, 4, 4, 4]);
    assert_eq!(candidate(String::from(""o| .| o| .| o o| o o|"")), vec![2, 1, 2, 1, 4, 2, 4, 2]);
}
"
HumanEval_18,tzm_Tfng,rs,"///ⴰⴼⵉ ⵎⵏⵏⴰⵡⵜ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵥⴹⴰⵕ ⴰⴷ ⵢⴰⴼ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵎⵣⵡⴰⵔⵓ ⴳ ⵓⵡⵉⴽⵉ ⴰⵎⵣⵡⴰⵔⵓ. ⵔⵎⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵙⴳⴷⴰⵍⵏ./// >>> how_many_times(String::from(""""), String::from(""a""))
/// 0
/// >>> how_many_times(String::from(""aaa""), String::from(""a""))
/// 3
/// >>> how_many_times(String::from(""aaaa""), String::from(""aa""))
/// 3
fn how_many_times(string: String, substring: String) -> isize {
","fn how_many_times(string: String, substring: String) -> isize {
    if substring.is_empty() || string.is_empty() {
        return 0;
    }

    let mut count = 0;
    let mut position = 0;

    while let Some(pos) = string[position..].find(&substring) {
        count += 1;
        position += pos + 1; // Move to the start of the next potential substring
    }

    count
}

fn main() {
    println!(""{}"", how_many_times(String::from(""""), String::from(""a""))); // 0
    println!(""{}"", how_many_times(String::from(""aaa""), String::from(""a""))); // 3
    println!(""{}"", how_many_times(String::from(""aaaa""), String::from(""aa""))); // 3
}","}

fn main() {
    let candidate = how_many_times;
    assert_eq!(candidate(String::from(""""), String::from(""x"")), 0);
    assert_eq!(candidate(String::from(""xyxyxyx""), String::from(""x"")), 4);
    assert_eq!(candidate(String::from(""cacacacac""), String::from(""cac"")), 4);
    assert_eq!(candidate(String::from(""john doe""), String::from(""john"")), 1);
}
"
HumanEval_19,tzm_Tfng,rs,"/// ⴰⵔ ⵏⵙⵙⴽⵛⵎ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵉⵎⴹⴰⵏⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙⴳ ⵉⵎⵥⵥⵢⴰⵏⵏ ⴰⵔ ⵉⵎⵇⵇⵔⴰⵏⵏ /// ⵉⵙⵜⴰⵢⵏ ⵉⵣⵔⴼⴰⵏ ⴳⴰⵏ ""ⵙⵢⴰ"", ""ⵢⵉⵡⵏ"", "" ⵙⵉⵏ"", "" ⴽⵕⴰⴹ"", ""ⴽⵓⵥ"", ""ⵎⵎⵓⵙ"", ""ⵚⴹⵉⵚ"", ""ⴰⵙⵙⴰ"", ""ⴰⵙⴰ"" ⴷ ""ⴰⵥⴰ"". /// ⴰⵙⴽⵛⵎ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ ""ⵙⵢⴰ"" ⴰⵔ ""ⵜⵥⴰ""/// >>> sort_numbers(String::from(""three one five""))
/// String::from(""one three five"")
fn sort_numbers(numbers: String) -> String {
","fn sort_numbers(numbers: String) -> String {
    let word_to_number = |word: &str| -> u32 {
        match word {
            ""zero"" => 0,
            ""one"" => 1,
            ""two"" => 2,
            ""three"" => 3,
            ""four"" => 4,
            ""five"" => 5,
            ""six"" => 6,
            ""seven"" => 7,
            ""eight"" => 8,
            ""nine"" => 9,
            _ => panic!(""Invalid input""),
        }
    };

    let words: Vec<&str> = numbers.split_whitespace().collect();
    let mut number_words: Vec<(&str, u32)> = words.iter().map(|&w| (w, word_to_number(w))).collect();

    number_words.sort_by_key(|&(_, number)| number);

    number_words.iter().map(|&(word, _)| word).collect::<Vec<&str>>().join("" "")
}","}

fn main() {
    let candidate = sort_numbers;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""three"")), String::from(""three""));
    assert_eq!(candidate(String::from(""three five nine"")), String::from(""three five nine""));
    assert_eq!(candidate(String::from(""five zero four seven nine eight"")), String::from(""zero four five seven eight nine""));
    assert_eq!(candidate(String::from(""six five four three two one zero"")), String::from(""zero one two three four five six""));
}
"
HumanEval_20,tzm_Tfng,rs,"/// ⴰⴹⵏⵉⵏ ⴷ ⴰⵔ ⵜⵜⴰⵔⴰⵏ ⵙ ⵓⵙⵓⴷⵙ (ⵉⴹⵏ ⵉⵎⵥⵥⵉⵏ, ⵡⵉⴹⵏ ⵉⵎⵇⵇⵓⵕⵏ)./// ⵙⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏⵏ (ⵙ ⵓⴳⴳⴰⵔ ⵏ ⵙⵉⵏ) ⵙⵜⴰⵢ ⴷ ⴷⵔⵓⵙ ⵙⵉⵏ ⵉⵎⴹⴰⵏⵏ ⵏⵏⴰ ⵢⵜⵜⵎⴰⵥⵏ ⴽⵓ ⵢⴰⵏ /// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {
","fn find_closest_elements(mut numbers: Vec<f64>) -> (f64, f64) {
    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());
    let mut min_diff = f64::INFINITY;
    let mut result = (0.0, 0.0);

    for i in 0..(numbers.len() - 1) {
        let diff = numbers[i + 1] - numbers[i];
        if diff < min_diff {
            min_diff = diff;
            result = (numbers[i], numbers[i + 1]);
        }
    }
    
    result
}

fn main() {
    // Example usage
    let vec1 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2];
    let res1 = find_closest_elements(vec1);
    println!(""{:?}"", res1); // (2.0, 2.2)

    let vec2 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0];
    let res2 = find_closest_elements(vec2);
    println!(""{:?}"", res2); // (2.0, 2.0)
}","}

fn main() {
    let candidate = find_closest_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));
}
"
HumanEval_21,tzm_Tfng,rs,"/// ⵣⵓⵏⴷ ⵎⴰⵙⴷ ⴰⵎⴹⴰⵏ ⴰⵎⵥⵥⵢⴰⵏ ⴰⴷ ⵉⴳⴰⵏ 0 ⴷ ⴰⵎⴹⴰⵏ ⴰⵎⵇⵔⴰⵏ ⴰⴷ ⵉⴳⴰⵏ 1 /// ⵙ ⵓⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ (ⵙ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⴷⵖⴰⵔ), ⵙⵙⵎⵔⵙⵏ ⵜⴰⵙⵏⴼⵍⵜ ⵜⴰⵣⵔⵉⴼⵜ ⵉ ⵓⴽⵜⵓⵔ ⴰⴷ, /// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])
/// vec![0.0, 0.25, 0.5, 0.75, 1.0]
fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {
","fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {
    if numbers.len() < 2 {
        return numbers;
    }

    let min_value = numbers.iter().cloned().fold(f64::INFINITY, f64::min);
    let max_value = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);

    numbers.into_iter().map(|x| (x - min_value) / (max_value - min_value)).collect()
}

fn main() {
    let numbers = vec![1.0, 2.0, 3.0, 4.0, 5.0];
    let rescaled = rescale_to_unit(numbers);
    println!(""{:?}"", rescaled);
}","}

fn main() {
    let candidate = rescale_to_unit;
    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);
    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);
    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
}
"
HumanEval_23,tzm_Tfng,rs,"/// ⴰⴷ ⵏⵔⴰⵔ ⵜⵉⵖⵣⵉ ⵏ ⵓⵖⵉⵍⵓⴼ /// >>> strlen(String::from(""""))
/// 0
/// >>> strlen(String::from(""abc""))
/// 3
fn strlen(string: String) -> isize {
","fn strlen(string: String) -> isize {
    string.chars().count() as isize
}

fn main() {
    println!(""{}"", strlen(String::from(""""))); // Output: 0
    println!(""{}"", strlen(String::from(""abc""))); // Output: 3
}","}

fn main() {
    let candidate = strlen;
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""x"")), 1);
    assert_eq!(candidate(String::from(""asdasnakj"")), 9);
}
"
HumanEval_24,tzm_Tfng,rs,"/// ⵉ ⵓⵎⴹⴰⵏ n, ⵥⵕ ⴰⵎⴹⴰⵏ ⴰⵅⴰⵜⴰⵔ ⵏⵏⴰ ⵉⵜⵜⴱⴹⵓⵏ n ⵙ ⵉⵎⵉⴽ, ⴷ ⵉⵎⵥⵥⵉⵏ ⵙⴳ n /// >>> largest_divisor(15)
/// 5
fn largest_divisor(n: isize) -> isize {
","fn largest_divisor(n: isize) -> isize {
    for i in (1..n).rev() {
        if n % i == 0 {
            return i;
        }
    }
    1 // If no other divisor is found, return 1
}

fn main() {
    println!(""{}"", largest_divisor(15)); // Output: 5
}","}

fn main() {
    let candidate = largest_divisor;
    assert_eq!(candidate(3), 1);
    assert_eq!(candidate(7), 1);
    assert_eq!(candidate(10), 5);
    assert_eq!(candidate(100), 50);
    assert_eq!(candidate(49), 7);
}
"
HumanEval_25,tzm_Tfng,rs,"/// ⴰⴷ ⵉⴽⴽⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⵙⴽⵛⵎ ⴰⵎⵢⴰⴼⵓ ⵏ ⴽⵓⵍⵍⵓ ⵉⵎⴳⴳⵉⵜⵏ /// ⴽⵓ ⵢⴰⵏ ⴳ ⵉⵎⴳⴳⵉⵜⵏ ⴰⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰ ⵙ ⵓⴽⵓⴷ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⴷⴰ ⵉⵜⵜⵓⴳⴰ ⴳ ⵓⵙⴼⵙⵔ. /// ⴰⴱⵔⵉⴷ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵉⵎⴳⴳⵉⵜⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵙⵙⵓⴷⵙ ⵙⴳ ⵉⵎⵥⵥⵉⵏ ⴰⵔ ⵉⵎⵇⵇⵔⴰⵏ. /// >>> factorize(8)
/// vec![2, 2, 2]
/// >>> factorize(25)
/// vec![5, 5]
/// >>> factorize(70)
/// vec![2, 5, 7]
fn factorize(n: isize) -> Vec<isize> {
","fn factorize(mut n: isize) -> Vec<isize> {
    let mut factors = Vec::new();
    let mut divisor = 2;
    while n >= divisor * divisor {
        while n % divisor == 0 {
            factors.push(divisor);
            n /= divisor;
        }
        divisor += 1;
    }
    if n > 1 {
        factors.push(n);
    }
    factors
}

fn main() {
    // Test cases
    println!(""{:?}"", factorize(8));  // Should print: [2, 2, 2]
    println!(""{:?}"", factorize(25)); // Should print: [5, 5]
    println!(""{:?}"", factorize(70)); // Should print: [2, 5, 7]
}","}

fn main() {
    let candidate = factorize;
    assert_eq!(candidate(2), vec![2]);
    assert_eq!(candidate(4), vec![2, 2]);
    assert_eq!(candidate(8), vec![2, 2, 2]);
    assert_eq!(candidate(57), vec![3, 19]);
    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);
    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);
    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);
    assert_eq!(candidate(18), vec![2, 3, 3]);
}
"
HumanEval_26,tzm_Tfng,rs,"/// ⵃⴹⵓ ⵜⴰⴼⵙⵓⵜ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵍⵉ ⵢⴰⴷ ⵣⵓⵏⴷ ⴳ ⵓⴽⵛⵛⵓⵎ. /// ⵙⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⴽⵓⵍⵍⵓ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵉⵜⵜⵊⵕⴰⵏ ⵓⴳⴳⴰⵔ ⵏ ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ. /// >>> remove_duplicates(vec![1, 2, 3, 2, 4])
/// vec![1, 3, 4]
fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {
","use std::collections::HashMap;

fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {
    let mut occurrences = HashMap::new();
    
    // Count occurrences of each number
    for &number in &numbers {
        *occurrences.entry(number).or_insert(0) += 1;
    }

    // Filter out numbers that occur more than once
    numbers.into_iter()
        .filter(|&number| occurrences[&number] == 1)
        .collect()
}","}

fn main() {
    let candidate = remove_duplicates;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);
}
"
HumanEval_27,tzm_Tfng,rs,"/// ⵉ ⵢⴰⵏ ⵓⵡⵉⴽⵉⵍ, ⵙⵙⵓⵜⵍ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵉⵏ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴷ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵉⵏⵏ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵉⵏⵏ. /// >>> flip_case(String::from(""Hello""))
/// String::from(""hELLO"")
fn flip_case(string: String) -> String {
","fn flip_case(string: String) -> String {
    string.chars().map(|c| {
        if c.is_lowercase() {
            c.to_ascii_uppercase()
        } else {
            c.to_ascii_lowercase()
        }
    }).collect()
}","}

fn main() {
    let candidate = flip_case;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""Hello!"")), String::from(""hELLO!""));
    assert_eq!(candidate(String::from(""These violent delights have violent ends"")), String::from(""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""));
}
"
HumanEval_28,tzm_Tfng,rs,"/// ⵙⵙⵎⵓⵏ ⵏ ⵓⵎⵙⵙⵉⴹⵏ ⵏ ⵉⵙⵉⴹⵏ ⴳ ⵢⴰⵏ ⵓⵙⵉⴹⵏ /// >>> concatenate(vec![])
/// String::from("""")
/// >>> concatenate(vec![String::from(""a""), String::from(""b""), String::from(""c"")])
/// String::from(""abc"")
fn concatenate(strings: Vec<String>) -> String {
","fn concatenate(strings: Vec<String>) -> String {
    strings.concat()
}","}

fn main() {
    let candidate = concatenate;
    assert_eq!(candidate(Vec::<String>::new()), String::from(""""));
    assert_eq!(candidate(vec![String::from(""x""), String::from(""y""), String::from(""z"")]), String::from(""xyz""));
    assert_eq!(candidate(vec![String::from(""x""), String::from(""y""), String::from(""z""), String::from(""w""), String::from(""k"")]), String::from(""xyzwk""));
}
"
HumanEval_29,tzm_Tfng,rs,"/// ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⵉⵙⵙⵏⵜⵉⵢⵏ ⵙ ⵢⴰⵏ ⵓⵣⵡⵍ ⵉⵜⵜⵢⴰⴽⴽⴰⵏ. /// >>> filter_by_prefix(vec![], String::from(""a""))
/// Vec::<String>::new()
/// >>> filter_by_prefix(vec![String::from(""abc""), String::from(""bcd""), String::from(""cde""), String::from(""array"")], String::from(""a""))
/// vec![String::from(""abc""), String::from(""array"")]
fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {
","fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {
    strings.into_iter()
        .filter(|s| s.starts_with(&prefix))
        .collect()
}","}

fn main() {
    let candidate = filter_by_prefix;
    assert_eq!(candidate(Vec::<String>::new(), String::from(""john"")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""xxx""), String::from(""asd""), String::from(""xxy""), String::from(""john doe""), String::from(""xxxAAA""), String::from(""xxx"")], String::from(""xxx"")), vec![String::from(""xxx""), String::from(""xxxAAA""), String::from(""xxx"")]);
}
"
HumanEval_30,tzm_Tfng,rs,"/// ⴰⵔ ⵏⵜⵜⵔⴰⵔ ⵖⴰⵙ ⵉⵎⴹⴰⵏ ⵉⴽⵙⵡⴰⵜⵏ ⴳ ⵓⴱⴰⵢⵢⵓⵕ. /// >>> get_positive(vec![-1, 2, -4, 5, 6])
/// vec![2, 5, 6]
/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// vec![5, 3, 2, 3, 9, 123, 1]
fn get_positive(l: Vec<isize>) -> Vec<isize> {
","fn get_positive(l: Vec<isize>) -> Vec<isize> {
    l.into_iter().filter(|&x| x > 0).collect()
}","}

fn main() {
    let candidate = get_positive;
    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);
    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);
    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
}
"
HumanEval_31,tzm_Tfng,rs,"/// ⴰⵔ ⵉⵜⵜⵔ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ. /// >>> is_prime(6)
/// false
/// >>> is_prime(101)
/// true
/// >>> is_prime(11)
/// true
/// >>> is_prime(13441)
/// true
/// >>> is_prime(61)
/// true
/// >>> is_prime(4)
/// false
/// >>> is_prime(1)
/// false
fn is_prime(n: isize) -> bool {
","fn is_prime(n: isize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}","}

fn main() {
    let candidate = is_prime;
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(101), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(13441), true);
    assert_eq!(candidate(61), true);
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(1), false);
    assert_eq!(candidate(5), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(17), true);
    assert_eq!(candidate(85), false);
    assert_eq!(candidate(77), false);
    assert_eq!(candidate(255379), false);
}
"
HumanEval_33,tzm_Tfng,rs,"/// ⵙ ⵡⴰⵜⵉⴳⵏ ⵏ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵙⴰⵙⴰⵏ ⵏ l, ⵎⴰⵛⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ.///l' ⴷⴰ ⵢⴰⴽⵣ l ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵏⵏⴰ ⵓⵔ ⵏⵣⴹⴰⵔ ⴰⴷ ⵏⴱⴹⵓ ⵙ ⴽⵕⴰⴹ, ⵎⴰⵛⴰ ⵜⵉⵏⵉⴳⵉⵏ ⵏⵏⵙ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵏⵏⴰ ⵉⵜⵜⵣⴹⴰⵔⵏ ⵙ ⴽⵕⴰⴹ ⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ /// ⴷⴰ ⵜⵓⵎⵥ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ l ⴰⵔ ⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ l' ⵣⵓⵏⴷ /// >>> sort_third(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])
/// vec![2, 6, 3, 4, 8, 9, 5]
fn sort_third(l: Vec<isize>) -> Vec<isize> {
","fn sort_third(l: Vec<isize>) -> Vec<isize> {
    let mut divisible_by_three: Vec<(usize, isize)> = l.iter()
        .enumerate()
        .filter(|&(i, _)| i % 3 == 0)
        .map(|(i, &value)| (i, value))
        .collect();

    // Sort the values that are at indices divisible by 3
    divisible_by_three.sort_by_key(|&(_, value)| value);

    let mut result = l.clone();
    for (sorted_index, (original_index, _)) in divisible_by_three.iter().enumerate() {
        result[*original_index] = divisible_by_three[sorted_index].1;
    }

    result
}","}

fn main() {
    let candidate = sort_third;
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);
    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);
    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);
}
"
HumanEval_34,tzm_Tfng,rs,"/// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⵉⵡⴰⵏⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⴳ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ /// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![0, 2, 3, 5, 9, 123]
fn unique(l: Vec<isize>) -> Vec<isize> {
","fn unique(mut l: Vec<isize>) -> Vec<isize> {
    l.sort_unstable();
    l.dedup();
    l
}

fn main() {
    let result = unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]);
    println!(""{:?}"", result);
}","}

fn main() {
    let candidate = unique;
    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);
}
"
HumanEval_35,tzm_Tfng,rs,"/// ⴰⴷ ⵢⴰⴽⵣ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵇⵇⵓⵔⵏ ⴳ ⵓⴱⴰⵢⵢⵓⵕ. /// >>> max_element(vec![1, 2, 3])
/// 3
/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
fn max_element(l: Vec<isize>) -> isize {
","fn max_element(l: Vec<isize>) -> isize {
    l.into_iter().max().unwrap()
}","}

fn main() {
    let candidate = max_element;
    assert_eq!(candidate(vec![1, 2, 3]), 3);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);
}
"
HumanEval_36,tzm_Tfng,rs,"/// ⴰⴷ ⵢⴰⴽⵣ ⴰⵎⴹⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵜⵜⵓⵢⴰⵔⴰⵏ ⵓⵟⵟⵓⵏ 7 ⴳ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵥⵥⵉⵏ ⵏⵏⴰ ⵓⵔ ⵏⵏⵉⴳⵏ n ⵏⵏⴰ ⵉⵜⵜⵓⵢⴰⵔⴰⵏ ⵙ 11 ⵏⵖ 13. /// >>> fizz_buzz(50)
/// 0
/// >>> fizz_buzz(78)
/// 2
/// >>> fizz_buzz(79)
/// 3
fn fizz_buzz(n: isize) -> isize {
","fn fizz_buzz(n: isize) -> isize {
    (0..n)
        .filter(|&x| x % 11 == 0 || x % 13 == 0)
        .flat_map(|x| x.to_string().chars())
        .filter(|&c| c == '7')
        .count() as isize
}","}

fn main() {
    let candidate = fizz_buzz;
    assert_eq!(candidate(50), 0);
    assert_eq!(candidate(78), 2);
    assert_eq!(candidate(79), 3);
    assert_eq!(candidate(100), 3);
    assert_eq!(candidate(200), 6);
    assert_eq!(candidate(4000), 192);
    assert_eq!(candidate(10000), 639);
    assert_eq!(candidate(100000), 8026);
}
"
HumanEval_37,tzm_Tfng,rs,"/// ⵙ ⵡⴰⵜⵉⴳⵏ ⵏ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏ l, ⵎⴰⵛⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ. ///l' ⴷⴰ ⵢⴰⴽⵣ l ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵎⴰⵛⴰ ⵡⴰⵜⵉⴳⵏ ⵏⵏⵙ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ /// ⴷⴰ ⵜⴽⴽⴰ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ l ⴰⵔ ⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ l' ⵣⵓⵏⴷ /// >>> sort_even(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_even(vec![5, 6, 3, 4])
/// vec![3, 6, 5, 4]
fn sort_even(l: Vec<isize>) -> Vec<isize> {
","fn sort_even(l: Vec<isize>) -> Vec<isize> {
    // Collect even indexed elements and sort them
    let mut even_elements: Vec<isize> = l.iter().enumerate()
        .filter(|&(i, _)| i % 2 == 0)
        .map(|(_, &val)| val)
        .collect();
    even_elements.sort();

    // Reconstruct the vector `l'`
    let mut result = l.clone();
    let mut even_index = 0;

    for i in 0..l.len() {
        if i % 2 == 0 {
            result[i] = even_elements[even_index];
            even_index += 1;
        }
    }
    
    result
}","}

fn main() {
    let candidate = sort_even;
    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}
"
HumanEval_39,tzm_Tfng,rs,"/// prime_fib ⴷⴰ ⵢⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ n-ⵜⵏ ⵡⵉ-ⵏⵏⴰ ⵉⴳⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⴷ ⵉⴳⴰ ⴰⵡⴷ ⴰⵎⵣⵡⴰⵔⵓ. /// >>> prime_fib(1)
/// 2
/// >>> prime_fib(2)
/// 3
/// >>> prime_fib(3)
/// 5
/// >>> prime_fib(4)
/// 13
/// >>> prime_fib(5)
/// 89
fn prime_fib(n: isize) -> isize {
","fn prime_fib(n: isize) -> isize {
    fn is_prime(num: isize) -> bool {
        if num <= 1 {
            return false;
        }
        if num <= 3 {
            return true;
        }
        if num % 2 == 0 || num % 3 == 0 {
            return false;
        }
        let mut i = 5;
        while i * i <= num {
            if num % i == 0 || num % (i + 2) == 0 {
                return false;
            }
            i += 6;
        }
        true
    }

    fn fibonacci() -> impl Iterator<Item = isize> {
        let mut a: isize = 0;
        let mut b: isize = 1;
        std::iter::from_fn(move || {
            let next = a + b;
            a = b;
            b = next;
            Some(a)
        })
    }

    let mut count = 0;
    for fib_num in fibonacci() {
        if is_prime(fib_num) {
            count += 1;
            if count == n {
                return fib_num;
            }
        }
    }
    -1
}","}

fn main() {
    let candidate = prime_fib;
    assert_eq!(candidate(1), 2);
    assert_eq!(candidate(2), 3);
    assert_eq!(candidate(3), 5);
    assert_eq!(candidate(4), 13);
    assert_eq!(candidate(5), 89);
    assert_eq!(candidate(6), 233);
    assert_eq!(candidate(7), 1597);
    assert_eq!(candidate(8), 28657);
    assert_eq!(candidate(9), 514229);
    assert_eq!(candidate(10), 433494437);
}
"
HumanEval_40,tzm_Tfng,rs,"/// ⴰⵖⵎⵉⵙ ⵙ ⵓⵎⵢⴰ, ⴷ ⵡⴰⵍⴰ ⵏ ⵓⵢⴰ. /// ⴷⴰ ⵢⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ///triple_sum_to_zero ⴷⴰ ⵉⵜⵜⴰⵙⵉ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ. /// >>> triples_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(vec![1])
/// false
fn triples_sum_to_zero(l: Vec<isize>) -> bool {
","fn triples_sum_to_zero(l: Vec<isize>) -> bool {
    let n = l.len();
    if n < 3 {
        return false;
    }

    let mut sorted_l = l.clone();
    sorted_l.sort();

    for i in 0..n-2 {
        let a = sorted_l[i];
        let mut left = i + 1;
        let mut right = n - 1;

        while left < right {
            let sum = a + sorted_l[left] + sorted_l[right];
            if sum == 0 {
                return true;
            } else if sum < 0 {
                left += 1;
            } else {
                right -= 1;
            }
        }
    }

    false
}","}

fn main() {
    let candidate = triples_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, 5, -1]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), true);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![1, 2, 5, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![1, 3, 5, -100]), false);
    assert_eq!(candidate(vec![100, 3, 5, -100]), false);
}
"
HumanEval_41,tzm_Tfng,rs,"/// ⴷⴰ ⵜⵙⵙⵓⴼⵖ ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵏⵖⵉ ⴰⴷ. /// ⴳ ⵓⴱⵔⵉⴷ ⵏⵏⵙⵏ ⴰⵎⵎ ⵉⵙ ⵓⵔ ⵜⵜⵓⵥⴹⴰⵕⵏ ⴰⴷ ⵜⵜⵓⵥⴹⴰⵕⵏ. /// ⵎⴰⵛⴰ, ⵍⵍⴰⵏⵜ ⵜⴽⴰⵔⵉⵏⵉⵏ ⵜⵉⴷⵓⵙⵏⵉⵏ ⴷ ⵉⴷⵓⵙⵏⵉⵏ ⴱⴰⵀⵔⴰ; ⵙ ⵡⴰⵢⴰ, ⴰⵔ ⵙⵓⵍⵏⵜ ⵙⵎⵓⵜⵜⵓⵢⵏⵜ /// ⵍⵍⵉⵖ ⵜⵙⵙⵏⴷ ⵢⴰⵜ ⵜⴽⴰⵔⴹⴰ ⵍⵍⵉ ⵢⵎⵓⵙⵙⵓⵏ ⵙ ⵓⵣⵍⵎⴰⴹ ⵙ ⵓⵣⵔⴼ ⵢⴰⵜ ⵜⴽⴰⵔⴹⴰ ⵍⵍⵉ ⵢⵎⵓⵙⵙⵓⵏ ⵙ ⵓⵣⵔⴼ ⵙ ⵓⵣⵍⵎⴰⴹ. /// ⴽⵓⵍⵍⵓ ⵜⴽⴰⵔⵢⵉⵏ ⴷⴰ ⵙⵙⵓⴷⵙⵏ ⵙ ⵢⴰⵜ ⵜⴰⵣⵣⵍⴰ. ⵔⴰⴷ ⵏⵉⵏⵉ ⵉⵙ ⵇⵍⵍⵏⵜ ⵙⵏⴰⵜ ⵜⴽⴰⵔⵢⵉⵏ.//ⵔⴰⴷ ⵙⵡⵓⵔⵉⵏ ⵙ ⵓⵣⵔⴼ ⵙ ⵓⵥⵍⵎⴰⴹ. ⵔⴰⴷ ⵙⵡⵓⵔⵉⵏ ⵙⵉⵏ ⵏ ⵉⵎⵓⴷⴷⵓⵜⵏ ⵙ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ.///n ⵜⴰⴽⴰⵔⵉⵏ ⴷⴰ ⵙⵙⵓⴷⵙⵏ ⵙⴳ ⵓⵥⵍⵎⴰⴹ ⵖⵔ ⵓⵢⴼⴼⵓⵙ; ⴳ ⵢⴰⵜ ⵜⵉⵣⵉ, ⵜⴰⵔⴰⴱⴱⵓⵜ ⵏ n ⵜⴰⴽⴰⵔⵉⵏ /// ⵙⵙⵏⵏ ⵉⵙ ⵉⴳⴰ ⵓⴱⵔⵉⴷ ⵢⴰⵏ ⵓⴱⵔⵉⴷ ⴰⵎⵙⴷⵓⵙ ⴱⴰⵀⵔⴰ ⵉⵖⵣⵣⵉⴼⵏ. fn car_race_collision(n: isize) -> isize {
","fn car_race_collision(n: isize) -> isize {
    // Since every car moving left to right will collide exactly once
    // with every car moving right to left, the number of collisions is n * n
    n * n
}

fn main() {
    let n = 5;
    println!(""Number of collisions: {}"", car_race_collision(n));
}","}

fn main() {
    let candidate = car_race_collision;
    assert_eq!(candidate(2), 4);
    assert_eq!(candidate(3), 9);
    assert_eq!(candidate(4), 16);
    assert_eq!(candidate(8), 64);
    assert_eq!(candidate(10), 100);
}
"
HumanEval_42,tzm_Tfng,rs,"/// ⴰⴱⵔⵉⴷ ⵏ ⵓⴽⵛⵛⵓⵎ ⵙ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵢⴰⵔⴰⵏ ⵙ 1. /// >>> incr_list(vec![1, 2, 3])
/// vec![2, 3, 4]
/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]
fn incr_list(l: Vec<isize>) -> Vec<isize> {
","fn incr_list(l: Vec<isize>) -> Vec<isize> {
    l.iter().map(|&x| x + 1).collect()
}","}

fn main() {
    let candidate = incr_list;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);
    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);
}
"
HumanEval_43,tzm_Tfng,rs,"/// ⴰⵖⵎⵉⵙ ⵙ ⵓⵎⵢⴰ, ⴷ ⵡⴰⵍⴰ ⵏ ⵓⵢⴰ. /// ⴷⴰ ⵢⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ /// pairs_sum_to_zero ⴷⴰ ⵉⵜⵜⴰⵙⵉ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ. /// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(vec![1])
/// false
fn pairs_sum_to_zero(l: Vec<isize>) -> bool {
","fn pairs_sum_to_zero(l: Vec<isize>) -> bool {
    use std::collections::HashSet;
    let mut seen = HashSet::new();
    
    for &num in &l {
        if seen.contains(&-num) {
            return true;
        }
        seen.insert(num);
    }
    false
}

fn main() {
    println!(""{}"", pairs_sum_to_zero(vec![1, 3, 5, 0])); // false
    println!(""{}"", pairs_sum_to_zero(vec![1, 3, -2, 1])); // false
    println!(""{}"", pairs_sum_to_zero(vec![1, 2, 3, 7])); // false
    println!(""{}"", pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])); // true
    println!(""{}"", pairs_sum_to_zero(vec![1])); // false
}","}

fn main() {
    let candidate = pairs_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);
}
"
HumanEval_44,tzm_Tfng,rs,"/// ⵉⵎⴹⴰⵏ ⵏ ⵜⵔⵙⴰⵍ ⵎⵥⵥⵉⵢⵏ ⵙⴳ 10. /// ⴰⴷ ⵢⴰⴽⵣ ⵜⵉⴼⵉⵏⴰⵖ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵏⴼⵍ. /// ⵙⵏⴼⵍ ⵜⴰⵙⵉⵍⴰ ⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵛⵛⵓⵎ x ⵙ ⵜⴰⵙⵉⵍⴰ. /// >>> change_base(8, 3)
/// String::from(""22"")
/// >>> change_base(8, 2)
/// String::from(""1000"")
/// >>> change_base(7, 2)
/// String::from(""111"")
fn change_base(x: isize, base: isize) -> String {
","fn change_base(x: isize, base: isize) -> String {
    if base < 2 || base > 9 {
        panic!(""Base must be between 2 and 9"");
    }
    
    if x == 0 {
        return String::from(""0"");
    }
    
    let mut result = String::new();
    let mut number = x;
    
    while number > 0 {
        let remainder = number % base;
        result.push_str(&remainder.to_string());
        number /= base;
    }
    
    result.chars().rev().collect()
}","}

fn main() {
    let candidate = change_base;
    assert_eq!(candidate(8, 3), String::from(""22""));
    assert_eq!(candidate(9, 3), String::from(""100""));
    assert_eq!(candidate(234, 2), String::from(""11101010""));
    assert_eq!(candidate(16, 2), String::from(""10000""));
    assert_eq!(candidate(8, 2), String::from(""1000""));
    assert_eq!(candidate(7, 2), String::from(""111""));
    assert_eq!(candidate(2, 3), String::from(""2""));
    assert_eq!(candidate(3, 4), String::from(""3""));
    assert_eq!(candidate(4, 5), String::from(""4""));
    assert_eq!(candidate(5, 6), String::from(""5""));
    assert_eq!(candidate(6, 7), String::from(""6""));
    assert_eq!(candidate(7, 8), String::from(""7""));
}
"
HumanEval_45,tzm_Tfng,rs,"/// ⴰⵖⵣⵉ ⵏ ⵓⴳⴰⴼⴰ ⴷ ⵢⵉⴳⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵎⵇⵔⴰⵏ ⵉ ⵢⴰⵏ ⵓⴽⵕⴰⴹ. /// >>> triangle_area(5, 3)
/// 7.5
fn triangle_area(a: isize, h: isize) -> f64 {
","fn triangle_area(a: isize, h: isize) -> f64 {
    (a as f64 * h as f64) / 2.0
}

fn main() {
    let area = triangle_area(5, 3);
    println!(""{}"", area);
}","}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(5, 3), 7.5);
    assert_eq!(candidate(2, 2), 2.0);
    assert_eq!(candidate(10, 8), 40.0);
}
"
HumanEval_46,tzm_Tfng,rs,"/// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵉⴹⵏ ⴰⵎⵏⵣⵓ ⵡⵉⵙⵙ n ⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ fib4. ⵔⵥⵎ ⵓⵔ ⵜⵙⵙⵎⵔⵙ ⵜⵉⵔⵔⴰ. /// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). /// fib4(3) -> 0 /// fib4(2) -> 2 /// fib4(1) -> 0 /// fib4(0) -> 0 /// ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ Fib4 ⵜⴳⴰ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵣⵓⵏⴷ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ: /// >>> fib4(5)
/// 4
/// >>> fib4(6)
/// 8
/// >>> fib4(7)
/// 14
fn fib4(n: isize) -> isize {
","fn fib4(n: isize) -> isize {
    if n < 0 {
        return 0; // Define behavior for negative input
    }

    let mut sequence = vec![0, 0, 2, 0];

    if n < 4 {
        return sequence[n as usize];
    }

    for i in 4..=n {
        let next_value = sequence[(i - 1) as usize] 
                       + sequence[(i - 2) as usize] 
                       + sequence[(i - 3) as usize] 
                       + sequence[(i - 4) as usize];
        sequence.push(next_value);
    }

    sequence[n as usize]
}

fn main() {
    println!(""{}"", fib4(5)); // 4
    println!(""{}"", fib4(6)); // 8
    println!(""{}"", fib4(7)); // 14
}","}

fn main() {
    let candidate = fib4;
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 28);
    assert_eq!(candidate(10), 104);
    assert_eq!(candidate(12), 386);
}
"
HumanEval_47,tzm_Tfng,rs,"/// ⴰⵔⵔⵉⴼ ⵏ ⵡⴰⵎⵎⴰⵙ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⴱⵉⴽⵜⵓⵔ l. /// >>> median(vec![3, 1, 2, 4, 5])
/// 3.0
/// >>> median(vec![-10, 4, 6, 1000, 10, 20])
/// 15.0
fn median(l: Vec<isize>) -> f64 {
","fn median(l: Vec<isize>) -> f64 {
    let mut l = l.clone();
    l.sort();
    let len = l.len();

    if len % 2 == 0 {
        let mid1 = len / 2;
        let mid2 = mid1 - 1;
        ((l[mid1] as f64) + (l[mid2] as f64)) / 2.0
    } else {
        l[len / 2] as f64
    }
}","}

fn main() {
    let candidate = median;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);
    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);
    assert_eq!(candidate(vec![5]), 5.0);
    assert_eq!(candidate(vec![6, 5]), 5.5);
    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);
}
"
HumanEval_48,tzm_Tfng,rs,"/// ⴷⴰ ⵉⵜⵜⵉⵔⵉ ⵎⴽ ⵜⴳⴰ ⵜⵣⵍⵉⵜ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵢⴰⵜ ⵜⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ /// >>> is_palindrome(String::from(""""))
/// true
/// >>> is_palindrome(String::from(""aba""))
/// true
/// >>> is_palindrome(String::from(""aaaaa""))
/// true
/// >>> is_palindrome(String::from(""zbcd""))
/// false
fn is_palindrome(text: String) -> bool {
","fn is_palindrome(text: String) -> bool {
    let chars: Vec<char> = text.chars().collect();
    let len = chars.len();
    for i in 0..len / 2 {
        if chars[i] != chars[len - 1 - i] {
            return false;
        }
    }
    true
}","}

fn main() {
    let candidate = is_palindrome;
    assert_eq!(candidate(String::from("""")), true);
    assert_eq!(candidate(String::from(""aba"")), true);
    assert_eq!(candidate(String::from(""aaaaa"")), true);
    assert_eq!(candidate(String::from(""zbcd"")), false);
    assert_eq!(candidate(String::from(""xywyx"")), true);
    assert_eq!(candidate(String::from(""xywyz"")), false);
    assert_eq!(candidate(String::from(""xywzx"")), false);
}
"
HumanEval_49,tzm_Tfng,rs,"/// ⵙⴽⵔ 2^n modulo p (ⴰⴷ ⵜⵙⵙⵏⴷ ⵉⵎⴹⴰⵏⵏ)./// >>> modp(3, 5)
/// 3
/// >>> modp(1101, 101)
/// 2
/// >>> modp(0, 101)
/// 1
/// >>> modp(3, 11)
/// 8
/// >>> modp(100, 101)
/// 1
fn modp(n: isize, p: isize) -> isize {
","fn modp(n: isize, p: isize) -> isize {
    if p == 1 {
        return 0;
    }
    let mut result = 1;
    let mut base = 2 % p;
    let mut exponent = n;
    
    while exponent > 0 {
        if exponent % 2 == 1 {
            result = (result * base) % p;
        }
        base = (base * base) % p;
        exponent /= 2;
    }
    
    result
}","}

fn main() {
    let candidate = modp;
    assert_eq!(candidate(3, 5), 3);
    assert_eq!(candidate(1101, 101), 2);
    assert_eq!(candidate(0, 101), 1);
    assert_eq!(candidate(3, 11), 8);
    assert_eq!(candidate(100, 101), 1);
    assert_eq!(candidate(30, 5), 4);
    assert_eq!(candidate(31, 5), 3);
}
"
HumanEval_51,tzm_Tfng,rs,"/// remove_vowels ⵜⴳⴰ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵉⵜⵜⴰⵙⵉⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴷ ⴰⵔ ⵜⵙⴽⴰⵔ ⵜⵉⴼⵉⵏⴰⵖ ⴱⵍⴰ ⵜⵉⴼⵉⵏⴰⵖ. /// >>> remove_vowels(String::from(""""))
/// String::from("""")
/// >>> remove_vowels(String::from(""abcdef""))
/// String::from(""bcdf"")
/// >>> remove_vowels(String::from(""aaaaa""))
/// String::from("""")
/// >>> remove_vowels(String::from(""aaBAA""))
/// String::from(""B"")
/// >>> remove_vowels(String::from(""zbcd""))
/// String::from(""zbcd"")
fn remove_vowels(text: String) -> String {
","fn remove_vowels(text: String) -> String {
    text.chars()
        .filter(|&c| !""aeiouAEIOU"".contains(c))
        .collect()
}","}

fn main() {
    let candidate = remove_vowels;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""abcdef
ghijklm"")), String::from(""bcdf
ghjklm""));
    assert_eq!(candidate(String::from(""fedcba"")), String::from(""fdcb""));
    assert_eq!(candidate(String::from(""eeeee"")), String::from(""""));
    assert_eq!(candidate(String::from(""acBAA"")), String::from(""cB""));
    assert_eq!(candidate(String::from(""EcBOO"")), String::from(""cB""));
    assert_eq!(candidate(String::from(""ybcd"")), String::from(""ybcd""));
}
"
HumanEval_52,tzm_Tfng,rs,"/// ⴰⵔ ⵉⵜⵜⵔ true ⵎⴽ ⴷⴰ ⵜⵜⴳⵡⴷⵊⴰⵏ ⵉⵎⴹⴰⵏⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ l ⴷⴷⴰⵡ ⵏ ⵓⴽⵜⵜⵓⵔ t. /// >>> below_threshold(vec![1, 2, 4, 10], 100)
/// true
/// >>> below_threshold(vec![1, 20, 4, 10], 5)
/// false
fn below_threshold(l: Vec<isize>, t: isize) -> bool {
","fn below_threshold(l: Vec<isize>, t: isize) -> bool {
    l.iter().all(|&x| x < t)
}

fn main() {
    println!(""{}"", below_threshold(vec![1, 2, 4, 10], 100)); // true
    println!(""{}"", below_threshold(vec![1, 20, 4, 10], 5));  // false
}","}

fn main() {
    let candidate = below_threshold;
    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);
    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);
}
"
HumanEval_53,tzm_Tfng,rs,"/// ⵙⵙⵓⵏⴼⵓ ⵙⵉⵏ ⵉⵎⴹⴰⵏⵏ x ⴷ y /// >>> add(2, 3)
/// 5
/// >>> add(5, 7)
/// 12
fn add(x: isize, y: isize) -> isize {
","fn add(x: isize, y: isize) -> isize {
    x + y
}","}

fn main() {
    let candidate = add;
    assert_eq!(candidate(0, 1), 1);
    assert_eq!(candidate(1, 0), 1);
    assert_eq!(candidate(2, 3), 5);
    assert_eq!(candidate(5, 7), 12);
    assert_eq!(candidate(7, 5), 12);
}
"
HumanEval_54,tzm_Tfng,rs,"/// ⵙⵜⴰⵍⵉⵖ ⵉⵙ ⵖⵓⵔ ⵙⵏⴰⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵎⵙⴽⴰⵔⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ. /// >>> same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddeddabc""))
/// true
/// >>> same_chars(String::from(""abcd""), String::from(""dddddddabc""))
/// true
/// >>> same_chars(String::from(""dddddddabc""), String::from(""abcd""))
/// true
/// >>> same_chars(String::from(""eabcd""), String::from(""dddddddabc""))
/// false
/// >>> same_chars(String::from(""abcd""), String::from(""dddddddabce""))
/// false
/// >>> same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddddabc""))
/// false
fn same_chars(s0: String, s1: String) -> bool {
","use std::collections::HashSet;

fn same_chars(s0: String, s1: String) -> bool {
    let set0: HashSet<char> = s0.chars().collect();
    let set1: HashSet<char> = s1.chars().collect();
    set0 == set1
}

fn main() {
    println!(""{}"", same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddeddabc""))); // true
    println!(""{}"", same_chars(String::from(""abcd""), String::from(""dddddddabc""))); // true
    println!(""{}"", same_chars(String::from(""dddddddabc""), String::from(""abcd""))); // true
    println!(""{}"", same_chars(String::from(""eabcd""), String::from(""dddddddabc""))); // false
    println!(""{}"", same_chars(String::from(""abcd""), String::from(""dddddddabce""))); // false
    println!(""{}"", same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddddabc""))); // false
}","}

fn main() {
    let candidate = same_chars;
    assert_eq!(candidate(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddeddabc"")), true);
    assert_eq!(candidate(String::from(""abcd""), String::from(""dddddddabc"")), true);
    assert_eq!(candidate(String::from(""dddddddabc""), String::from(""abcd"")), true);
    assert_eq!(candidate(String::from(""eabcd""), String::from(""dddddddabc"")), false);
    assert_eq!(candidate(String::from(""abcd""), String::from(""dddddddabcf"")), false);
    assert_eq!(candidate(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddddabc"")), false);
    assert_eq!(candidate(String::from(""aabb""), String::from(""aaccc"")), false);
}
"
HumanEval_55,tzm_Tfng,rs,"/// ⵙⵏⵓⵍⴼⵓ ⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵛⵉ ⵡⵉⵙⵙ ⵏ. /// >>> fib(10)
/// 55
/// >>> fib(1)
/// 1
/// >>> fib(8)
/// 21
fn fib(n: isize) -> isize {
","fn fib(n: isize) -> isize {
    match n {
        0 => 0,
        1 => 1,
        _ => fib(n - 1) + fib(n - 2),
    }
}

fn main() {
    println!(""{}"", fib(10)); // 55
    println!(""{}"", fib(1));  // 1
    println!(""{}"", fib(8));  // 21
}","}

fn main() {
    let candidate = fib;
    assert_eq!(candidate(10), 55);
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(8), 21);
    assert_eq!(candidate(11), 89);
    assert_eq!(candidate(12), 144);
}
"
HumanEval_56,tzm_Tfng,rs,"/// ⴰⵔ ⵉⵜⵜⵔ true ⵎⴽ ⴷⴰⵔ ⴽⵓ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵕⵥⵥⵓⵎ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵇⵇⵏ. /// brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏ ""<"" ⴷ "">"". /// >>> correct_bracketing(String::from(""<""))
/// false
/// >>> correct_bracketing(String::from(""<>""))
/// true
/// >>> correct_bracketing(String::from(""<<><>>""))
/// true
/// >>> correct_bracketing(String::from(""><<>""))
/// false
fn correct_bracketing(brackets: String) -> bool {
","fn correct_bracketing(brackets: String) -> bool {
    let mut balance = 0;
    
    for bracket in brackets.chars() {
        if bracket == '<' {
            balance += 1;
        } else if bracket == '>' {
            balance -= 1;
            if balance < 0 {
                return false;
            }
        }
    }
    
    balance == 0
}","}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from(""<>"")), true);
    assert_eq!(candidate(String::from(""<<><>>"")), true);
    assert_eq!(candidate(String::from(""<><><<><>><>"")), true);
    assert_eq!(candidate(String::from(""<><><<<><><>><>><<><><<>>>"")), true);
    assert_eq!(candidate(String::from(""<<<><>>>>"")), false);
    assert_eq!(candidate(String::from(""><<>"")), false);
    assert_eq!(candidate(String::from(""<"")), false);
    assert_eq!(candidate(String::from(""<<<<"")), false);
    assert_eq!(candidate(String::from("">"")), false);
    assert_eq!(candidate(String::from(""<<>"")), false);
    assert_eq!(candidate(String::from(""<><><<><>><>><<>"")), false);
    assert_eq!(candidate(String::from(""<><><<><>><>>><>"")), false);
}
"
HumanEval_57,tzm_Tfng,rs,"/// ⴰⵔ ⵉⵜⵜⵔⴰⵔ true ⵉⴳ ⴷ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⴱⵉⴽⵜⵓⵔ ⴷⴰ ⵙⵙⵓⴷⵓⵏ ⵙ ⵓⵖⵍⵉ ⵏⵖⴷ ⵙ ⵓⴷⵔⴰⵔ. /// >>> monotonic(vec![1, 2, 4, 20])
/// true
/// >>> monotonic(vec![1, 20, 4, 10])
/// false
/// >>> monotonic(vec![4, 1, 0, -10])
/// true
fn monotonic(l: Vec<isize>) -> bool {
","fn monotonic(l: Vec<isize>) -> bool {
    if l.len() <= 1 {
        return true;
    }
    
    let mut increasing = true;
    let mut decreasing = true;
    
    for i in 0..l.len() - 1 {
        if l[i] < l[i + 1] {
            decreasing = false;
        }
        if l[i] > l[i + 1] {
            increasing = false;
        }
    }
    
    increasing || decreasing
}

fn main() {
    println!(""{}"", monotonic(vec![1, 2, 4, 20])); // true
    println!(""{}"", monotonic(vec![1, 20, 4, 10])); // false
    println!(""{}"", monotonic(vec![4, 1, 0, -10])); // true
}","}

fn main() {
    let candidate = monotonic;
    assert_eq!(candidate(vec![1, 2, 4, 10]), true);
    assert_eq!(candidate(vec![1, 2, 4, 20]), true);
    assert_eq!(candidate(vec![1, 20, 4, 10]), false);
    assert_eq!(candidate(vec![4, 1, 0, -10]), true);
    assert_eq!(candidate(vec![4, 1, 1, 0]), true);
    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);
    assert_eq!(candidate(vec![9, 9, 9, 9]), true);
}
"
HumanEval_58,tzm_Tfng,rs,"/// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⵉⵡⴰⵏⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵉ ⵙⵉⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ. /// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])
/// vec![1, 5, 653]
/// >>> common(vec![5, 3, 2, 8], vec![3, 2])
/// vec![2, 3]
fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {
","use std::collections::HashSet;

fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {
    // Convert both vectors to hash sets to remove duplicates and allow set operations
    let set1: HashSet<_> = l1.into_iter().collect();
    let set2: HashSet<_> = l2.into_iter().collect();

    // Find the intersection of both sets
    let intersection: HashSet<_> = set1.intersection(&set2).cloned().collect();

    // Convert the intersection set to a sorted vector
    let mut result: Vec<_> = intersection.into_iter().collect();
    result.sort();

    result
}

fn main() {
    // Test cases
    println!(""{:?}"", common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])); // Should print: [1, 5, 653]
    println!(""{:?}"", common(vec![5, 3, 2, 8], vec![3, 2])); // Should print: [2, 3]
}","}

fn main() {
    let candidate = common;
    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);
    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);
    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());
}
"
HumanEval_59,tzm_Tfng,rs,"/// ⵙⵏⵓⵍⴼⵓ ⴰⵎⴳⴳⴰⵔⵓ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ ⵏ n. ⵏⵙⵙⵏ ⵉⵙ n > 1 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵎⵣⵡⴰⵔⵓ. /// >>> largest_prime_factor(13195)
/// 29
/// >>> largest_prime_factor(2048)
/// 2
fn largest_prime_factor(n: isize) -> isize {
","fn largest_prime_factor(mut n: isize) -> isize {
    let mut largest_factor = 1;

    // Check for number of twos that divide n
    while n % 2 == 0 {
        largest_factor = 2;
        n /= 2;
    }

    // n must be odd at this point, so we can skip even numbers
    let mut factor = 3;
    while factor * factor <= n {
        while n % factor == 0 {
            largest_factor = factor;
            n /= factor;
        }
        factor += 2;
    }

    // If n becomes a prime number greater than 2
    if n > 2 {
        largest_factor = n;
    }

    largest_factor
}

fn main() {
    println!(""{}"", largest_prime_factor(13195));
    println!(""{}"", largest_prime_factor(2048));
}","}

fn main() {
    let candidate = largest_prime_factor;
    assert_eq!(candidate(15), 5);
    assert_eq!(candidate(27), 3);
    assert_eq!(candidate(63), 7);
    assert_eq!(candidate(330), 11);
    assert_eq!(candidate(13195), 29);
}
"
HumanEval_60,tzm_Tfng,rs,"/// sum_to_n ⵜⴳⴰ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵉⵙⵎⵓⵏⵏ ⵉⵎⴹⴰⵏⵏ ⵙⴳ 1 ⴰⵔ n. /// >>> sum_to_n(30)
/// 465
/// >>> sum_to_n(100)
/// 5050
/// >>> sum_to_n(5)
/// 15
/// >>> sum_to_n(10)
/// 55
/// >>> sum_to_n(1)
/// 1
fn sum_to_n(n: isize) -> isize {
","fn sum_to_n(n: isize) -> isize {
    n * (n + 1) / 2
}","}

fn main() {
    let candidate = sum_to_n;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(6), 21);
    assert_eq!(candidate(11), 66);
    assert_eq!(candidate(30), 465);
    assert_eq!(candidate(100), 5050);
}
"
HumanEval_61,tzm_Tfng,rs,"/// ⴰⵔ ⵉⵜⵜⵔ true ⵎⴽ ⴷⴰⵔ ⴽⵓ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵕⵥⵥⵓⵎ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵇⵇⵏ. /// brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏ ""("" ⴷ "")""./// >>> correct_bracketing(String::from(""(""))
/// false
/// >>> correct_bracketing(String::from(""()""))
/// true
/// >>> correct_bracketing(String::from(""(()())""))
/// true
/// >>> correct_bracketing(String::from("")(()""))
/// false
fn correct_bracketing(brackets: String) -> bool {
","fn correct_bracketing(brackets: String) -> bool {
    let mut balance = 0;
    
    for c in brackets.chars() {
        if c == '(' {
            balance += 1;
        } else if c == ')' {
            balance -= 1;
        }

        if balance < 0 {
            return false;
        }
    }
    
    balance == 0
}","}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from(""()"")), true);
    assert_eq!(candidate(String::from(""(()())"")), true);
    assert_eq!(candidate(String::from(""()()(()())()"")), true);
    assert_eq!(candidate(String::from(""()()((()()())())(()()(()))"")), true);
    assert_eq!(candidate(String::from(""((()())))"")), false);
    assert_eq!(candidate(String::from("")(()"")), false);
    assert_eq!(candidate(String::from(""("")), false);
    assert_eq!(candidate(String::from(""(((("")), false);
    assert_eq!(candidate(String::from("")"")), false);
    assert_eq!(candidate(String::from(""(()"")), false);
    assert_eq!(candidate(String::from(""()()(()())())(()"")), false);
    assert_eq!(candidate(String::from(""()()(()())()))()"")), false);
}
"
HumanEval_62,tzm_Tfng,rs,"/// ⴰⴷ ⵏⵔⴰⵔ ⵜⴰⵙⵏⴼⵍⵓⵍⵜ ⵏ ⵓⵎⴳⴳⵉⵡⵙ ⴰⴷ ⴳ ⵜⴰⵍⵖⴰ ⵢⴰⴷⵏⵉⵏ. /// xs[0] + xs[1] * x + xs[2] * x^2 + .... /// xs ⴷⴰ ⵉⵙⵎⴷⵢⴰ ⵉⵎⵙⴷⴷⵉⵜⵏ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ. /// >>> derivative(vec![3, 1, 2, 4, 5])
/// vec![1, 4, 12, 20]
/// >>> derivative(vec![1, 2, 3])
/// vec![2, 6]
fn derivative(xs: Vec<isize>) -> Vec<isize> {
","fn derivative(xs: Vec<isize>) -> Vec<isize> {
    let mut result = Vec::new();
    for (i, &coeff) in xs.iter().enumerate().skip(1) {
        result.push(coeff * i as isize);
    }
    result
}

fn main() {
    let poly1 = vec![3, 1, 2, 4, 5];
    let poly2 = vec![1, 2, 3];
    println!(""{:?}"", derivative(poly1)); // Output: [1, 4, 12, 20]
    println!(""{:?}"", derivative(poly2)); // Output: [2, 6]
}","}

fn main() {
    let candidate = derivative;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);
    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);
    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);
    assert_eq!(candidate(vec![1]), Vec::<isize>::new());
}
"
HumanEval_63,tzm_Tfng,rs,"/// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵉⴹⵏ ⴰⵎⵏⵣⵓ ⵡⵉⵙⵙ n ⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ fibfib. /// fibfib{n} == fibfib{n-1} + fibfib{n-2} + fibfib{n-3} /// fib fib ((2) == 1 /// fib fib ((1) == 0 /// fib fib ((0) == 0 /// ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱ ⴼⵉⴱ ⵜⴳⴰ ⵢⴰⵜ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵣⵓⵏⴷ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ: /// >>> fibfib(1)
/// 0
/// >>> fibfib(5)
/// 4
/// >>> fibfib(8)
/// 24
fn fibfib(n: isize) -> isize {
","fn fibfib(n: isize) -> isize {
    if n < 0 {
        // Optionally handle negative indices as an error or specific value
        return -1; // Example error indicator
    }
    match n {
        0 => 0,
        1 => 0,
        2 => 1,
        _ => {
            let mut a = 0;
            let mut b = 0;
            let mut c = 1;
            let mut result = 0;
            for _ in 3..=n {
                result = a + b + c;
                a = b;
                b = c;
                c = result;
            }
            result
        }
    }
}","}

fn main() {
    let candidate = fibfib;
    assert_eq!(candidate(2), 1);
    assert_eq!(candidate(1), 0);
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 24);
    assert_eq!(candidate(10), 81);
    assert_eq!(candidate(12), 274);
    assert_eq!(candidate(14), 927);
}
"
HumanEval_64,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// ⴰⵖⵔⵉ, ⵎⴰⵛⴰ ⴷⴰⵢ ⵉⴳⴰⵏ ⴳ ⵜⴳⵉⵔⴰ ⵏ ⵜⴳⵓⵔⵉ ⵉⵜⵜⵓⴼⴽⴰⵏ. /// ⵉⵎⵓⵀⴰⵖ ⴳ ⵡⴰⴷⴷⴰⴷ ⴰⴷ ⴳⴰⵏ ""ⴰ"", ""ⵢ"", ""ⵉ"", ""ⵓ"", ""ⵓ"". ⴷⵖⵉ, ""ⵢ"" ⵉⴳⴰ ⴰⵡⴷ ⵢⴰⵏ /// ⵢⴰⵏ ⵡⴰⵡⴰⵍ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵙⴽⴰⵔ ⵉⵎⵉⴹ ⵏ ⵉⵎⵙⵍⵉ ⴳ ⵜⵣⵍⵉⵜ. /// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ vowels_count ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵜⴰⵡⵓⵔⵉ ⵏ /// >>> vowels_count(String::from(""abcde""))
/// 2
/// >>> vowels_count(String::from(""ACEDY""))
/// 3
fn vowels_count(s: String) -> isize {
","fn vowels_count(s: String) -> isize {
    let vowels = ['a', 'e', 'i', 'o', 'u'];
    let s = s.to_lowercase();
    let mut count = 0;

    for (i, c) in s.chars().enumerate() {
        if vowels.contains(&c) || (c == 'y' && i == s.len() - 1) {
            count += 1;
        }
    }
    
    count
}

fn main() {
    println!(""{}"", vowels_count(String::from(""abcde""))); // Output: 2
    println!(""{}"", vowels_count(String::from(""ACEDY""))); // Output: 3
}","}

fn main() {
    let candidate = vowels_count;
    assert_eq!(candidate(String::from(""abcde"")), 2);
    assert_eq!(candidate(String::from(""Alone"")), 3);
    assert_eq!(candidate(String::from(""key"")), 2);
    assert_eq!(candidate(String::from(""bye"")), 1);
    assert_eq!(candidate(String::from(""keY"")), 2);
    assert_eq!(candidate(String::from(""bYe"")), 1);
    assert_eq!(candidate(String::from(""ACEDY"")), 3);
}
"
HumanEval_65,tzm_Tfng,rs,"/// ⵎⴽ ⵜⵣⴷⵉ > ⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵔⴰⴷ ⵜⵔⵉⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵙ ⵓⴷⴼⵍ./// ⴷ ⴰⵔ ⵏⵙⵙⴽⵛⵎ ⵜⴰⵢⴰⴼⵓⵜ ⵙ ⵢⴰⵜ ⵜⵉⵔⵔⴰ. /// ⵙⵙⵓⵜⵍ ⴰⵎⵓⵙⵙⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ x, ⵙⵙⵓⵜⵍ ⴰⵎⵓⵙⵙⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙ ⵓⵣⵔⴼ ⵙ ⵓⵎⵓⵙⵙⵓ /// >>> circular_shift(12, 1)
/// String::from(""21"")
/// >>> circular_shift(12, 2)
/// String::from(""12"")
fn circular_shift(x: isize, shift: isize) -> String {
","fn circular_shift(x: isize, shift: isize) -> String {
    let mut digits: Vec<char> = x.abs().to_string().chars().collect();
    let len = digits.len() as isize;
    
    if shift > len {
        digits.reverse();
    } else {
        digits.rotate_right(shift as usize % len as usize);
    }
    
    digits.into_iter().collect()
}","}

fn main() {
    let candidate = circular_shift;
    assert_eq!(candidate(100, 2), String::from(""001""));
    assert_eq!(candidate(12, 2), String::from(""12""));
    assert_eq!(candidate(97, 8), String::from(""79""));
    assert_eq!(candidate(12, 1), String::from(""21""));
    assert_eq!(candidate(11, 101), String::from(""11""));
}
"
HumanEval_66,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵉⵙⵏⴼⴰⵔⵏ ⵏ ASCII. /// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴷ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⴰⴳⵓⵜ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵓⴼⵍⵍⴰ ⵅⴰⵙ'/// ⵜⴰⵡⵓⵔⵉ /// >>> digitSum(String::from(""""))
/// 0
/// >>> digitSum(String::from(""abAB""))
/// 131
/// >>> digitSum(String::from(""abcCd""))
/// 67
/// >>> digitSum(String::from(""helloE""))
/// 69
/// >>> digitSum(String::from(""woArBld""))
/// 131
/// >>> digitSum(String::from(""aAaaaXa""))
/// 153
fn digitSum(s: String) -> isize {
","fn digitSum(s: String) -> isize {
    s.chars()
     .filter(|c| c.is_uppercase())
     .map(|c| c as isize)
     .sum()
}","}

fn main() {
    let candidate = digitSum;
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""abAB"")), 131);
    assert_eq!(candidate(String::from(""abcCd"")), 67);
    assert_eq!(candidate(String::from(""helloE"")), 69);
    assert_eq!(candidate(String::from(""woArBld"")), 131);
    assert_eq!(candidate(String::from(""aAaaaXa"")), 153);
    assert_eq!(candidate(String::from("" How are yOu?"")), 151);
    assert_eq!(candidate(String::from(""You arE Very Smart"")), 327);
}
"
HumanEval_67,tzm_Tfng,rs,"/// ⵉ ⵓⵙⴽⴽⵉⵍ: /// ⴳ ⵜⴽⴰⵔⴹⴰ ⵔⵎⵙⵏ ⴰⵎⴹⴰⵏ ⵏ ⵜⴽⴰⵔⴹⴰ ⵏ ⵍⵎⵉⵏⴳⵓ ⴳ ⵜⴽⴰⵔⴹⴰ. /// ⵜⵉⴱⵕⴰⵏⵊⵉⵏ ⴷ ⵜⴱⵔⵖⴰ ⴷ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ ⴰⵎⴹⴰⵏ ⵏ ⵜⵢⴰⴼⵓⵜⵉⵏ /// ⵜⵉⴱⵔⵣⴰ, ⵜⵉⴱⵕⴰⵏⵊⵉⵏ, ⴷ ⵜⴽⴰⵔⴹⵉⵡⵉⵏ ⵏ ⵍⵎⴰⵏⴳⵓ. ⵥⵕ ⵜⴰⵡⴰⵍⵜ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ ⴰⵎⴹⴰⵏ ⵏ /// ⵏⵏⴰ ⵉⵜⵜⵓⵣⵟⵟⴰ ⴳ ⵢⴰⵜ ⵜⴽⵕⴹⴰ ⵏ ⵜⴽⵕⴹⴰ ⵏ ⵜⵢⴰⴼⵓⵜⵉⵏ ⵍⵉ ⵉⵍⵍⴰⵏ /// ⴳ ⵜⵎⵙⴰⵔⵜ ⴰⴷ, ⵔⴰⴷ ⴽⴽⵙⵜ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⴱⵔⵣⴰ ⴷ ⵜⴱⵓⵕⵜⵓⵖⴰⵍ /// >>> fruit_distribution(String::from(""5 apples and 6 oranges""), 19)
/// 8
/// >>> fruit_distribution(String::from(""0 apples and 1 oranges""), 3)
/// 2
/// >>> fruit_distribution(String::from(""2 apples and 3 oranges""), 100)
/// 95
/// >>> fruit_distribution(String::from(""100 apples and 1 oranges""), 120)
/// 19
fn fruit_distribution(s: String, n: isize) -> isize {
","fn fruit_distribution(s: String, n: isize) -> isize {
    let mut parts = s.split_whitespace();
    let apples: isize = parts.next().unwrap().parse().unwrap();
    parts.next(); // skip ""apples""
    parts.next(); // skip ""and""
    let oranges: isize = parts.next().unwrap().parse().unwrap();
    
    n - (apples + oranges)
}

fn main() {
    assert_eq!(fruit_distribution(String::from(""5 apples and 6 oranges""), 19), 8);
    assert_eq!(fruit_distribution(String::from(""0 apples and 1 oranges""), 3), 2);
    assert_eq!(fruit_distribution(String::from(""2 apples and 3 oranges""), 100), 95);
    assert_eq!(fruit_distribution(String::from(""100 apples and 1 oranges""), 120), 19);
    println!(""All test cases passed!"");
}","}

fn main() {
    let candidate = fruit_distribution;
    assert_eq!(candidate(String::from(""5 apples and 6 oranges""), 19), 8);
    assert_eq!(candidate(String::from(""5 apples and 6 oranges""), 21), 10);
    assert_eq!(candidate(String::from(""0 apples and 1 oranges""), 3), 2);
    assert_eq!(candidate(String::from(""1 apples and 0 oranges""), 3), 2);
    assert_eq!(candidate(String::from(""2 apples and 3 oranges""), 100), 95);
    assert_eq!(candidate(String::from(""2 apples and 3 oranges""), 5), 0);
    assert_eq!(candidate(String::from(""1 apples and 100 oranges""), 120), 19);
}
"
HumanEval_68,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ 1: /// ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⵡⴰⵜⵉⴳⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ ⵏⵖⴷ ⵉⴳⴰ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵉⵍⵍⴰ, ⵙⵓⵍⵏ []. /// ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵏⵔⴰⵔ ⵜⴰⴳⴳⴰⵢⵜ ⵉⵜⵜⵓⵙⵜⴰⵢⵏ ⴳ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ, [ smalest_value, its index ], /// ⵎⴽ ⵍⵍⴰⵏⵜ ⴽⵉⴳⴰⵏ ⵏ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⴰⵎⴽⵙⵓⵍ, ⵙⵙⵓⴼⵖ ⵜⵓⵏⵏⵓⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵥⵥⵢⴰⵏ. /// ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⴳ ⵜⵓⵏⵏⵓⵏⵜ ⵉⵜⵜⵓⵙⴽⵔⵏ ⵜⴰⵡⵜⵎⵉⵢⵜ ⵜⴰⵥⵥⵉⴹⵕⴰ ⴷ ⵜⵥⵥⵉⴹⵕⴰ. /// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵢⴰⵜ ⵙⴳ ⵜⵓⵏⵏⵓⵏⵜⵉⵏ ⴰⴷ ⴷ ⵜⵔⴰⵔ. /// ""ⴰⴽⵓⴷ ⵉⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵏ ⵓⵥⵟⵟⴰ ⵏ ⵢⴰⵜ ⵜⵙⴽⵍⴰ ⵏⵏⴰ ⵖⵓⵔ ⵍⵍⴰⵏⵜ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵔⵉⵏ /// >>> pluck(vec![4, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(vec![1, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(vec![])
/// Vec::<isize>::new()
/// Example 4:
/// >>> pluck(vec![5, 0, 3, 0, 4, 2])
/// vec![0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
fn pluck(arr: Vec<isize>) -> Vec<isize> {
","fn pluck(arr: Vec<isize>) -> Vec<isize> {
    let mut smallest_even: Option<(isize, usize)> = None;

    for (index, &value) in arr.iter().enumerate() {
        if value % 2 == 0 {
            match smallest_even {
                None => smallest_even = Some((value, index)),
                Some((smallest_value, _)) if value < smallest_value => smallest_even = Some((value, index)),
                _ => {}
            }
        }
    }

    match smallest_even {
        Some((value, index)) => vec![value, index as isize],
        None => Vec::new(),
    }
}","}

fn main() {
    let candidate = pluck;
    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);
    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);
    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);
    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);
    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());
}
"
HumanEval_69,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⵜⵉⴳ ⴰⴷ, ⵔⴰⴷ ⵏⵔⴰⵔ -1. /// ⵜⴰⴽⴰⵜ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵉⴳⴰ ⵜ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⴷⴰ ⵉⵜⵜⴼⴼⵖ ⴳ ⵓⴱⵉⴽⵜⵓⵔ. /// ⴰⵎⵢⴰ, ⴷ ⴷⴰⵔⵙ ⵢⴰⵏ ⵓⴽⵓⴷ ⴰⵅⴰⵜⴰⵔ ⵏⵖⴷ ⵉⵎⵣⴷⴰⵖ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵉⵎⵉⴹ ⴰⵎⴷⴷⴰⴷ ⵉⵎⴰⵏ ⵏⵏⵙ./// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵜⵓⵔ ⵓⵔ ⵉⴳⵉⵏ ⵡⴰⴽⴰⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵔⵎⴹ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⵏⵏⴰ ⵢⵓⴳⵔⵏ /// >>> search(vec![4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(vec![5, 5, 4, 4, 4])
/// -1
fn search(lst: Vec<isize>) -> isize {
","fn search(lst: Vec<isize>) -> isize {
    use std::collections::HashMap;
    
    let mut frequency_map = HashMap::new();
    
    // Count the frequency of each integer in the vector
    for &num in &lst {
        *frequency_map.entry(num).or_insert(0) += 1;
    }
    
    let mut result = -1;
    
    // Iterate over the map to find the greatest integer with a frequency
    // greater than or equal to its value
    for (&num, &freq) in &frequency_map {
        if freq >= num && num > result {
            result = num;
        }
    }
    
    result
}

// Test cases
fn main() {
    assert_eq!(search(vec![4, 1, 2, 2, 3, 1]), 2);
    assert_eq!(search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4]), 3);
    assert_eq!(search(vec![5, 5, 4, 4, 4]), -1);
}","}

fn main() {
    let candidate = search;
    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);
    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);
    assert_eq!(candidate(vec![3, 3]), -1);
    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);
    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);
    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);
    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);
    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);
    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);
    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);
    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);
    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);
    assert_eq!(candidate(vec![1]), 1);
    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);
    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);
    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);
    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);
    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);
    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);
    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);
    assert_eq!(candidate(vec![10]), -1);
    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);
    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);
    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);
    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);
}
"
HumanEval_70,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⴷⴼⴼⵉⵔ ⵏ ⵓⴳⴳⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵇⵇⵉⵎⵏ, ⴷⴼⴼⵉⵔ ⵏ ⵓⴳⴳⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ ⴰⵢⴰⴷ. /// ⴰⵙⵎⵉⵍ ⴰⵎⵣⴳⵓⵏ, ⵉⴳ ⴷⴰ ⵜⵙⵙⵏⵜⵉⴷ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ, /// ⵙ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵔⴰⴷ ⵏⵔⴰⵔⵓ ⴰⴽⴽⵡ ⵉⵎⴹⴰⵏⵏ ⴳ ⵓⴱⵔⵉⴷ ⴰⵎⵢⴰⵏⴰⵡ. /// >>> strange_sort_list(vec![1, 2, 3, 4])
/// vec![1, 4, 2, 3]
/// >>> strange_sort_list(vec![5, 5, 5, 5])
/// vec![5, 5, 5, 5]
/// >>> strange_sort_list(vec![])
/// Vec::<isize>::new()
fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {
","fn strange_sort_list(mut lst: Vec<isize>) -> Vec<isize> {
    let mut result = Vec::with_capacity(lst.len());
    lst.sort();

    while !lst.is_empty() {
        // Take the smallest element
        if let Some(min) = lst.first().cloned() {
            result.push(min);
            lst.remove(0);
        }
        // Take the largest element
        if let Some(max) = lst.last().cloned() {
            result.push(max);
            lst.pop();
        }
    }

    result
}

fn main() {
    println!(""{:?}"", strange_sort_list(vec![1, 2, 3, 4])); // Output: vec![1, 4, 2, 3]
    println!(""{:?}"", strange_sort_list(vec![5, 5, 5, 5])); // Output: vec![5, 5, 5, 5]
    println!(""{:?}"", strange_sort_list(vec![])); // Output: Vec::<isize>::new()
}","}

fn main() {
    let candidate = strange_sort_list;
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);
    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);
    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);
    assert_eq!(candidate(vec![111111]), vec![111111]);
}
"
HumanEval_71,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// ⵓⴳⴳⴰⵔ ⵏ ⵜⵙⴳⴰ ⵜⵉⵙⵙ ⴽⵕⴰⴹⵜ. /// ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⴷⴰ ⵙⴽⴰⵔⵏ ⵢⴰⵜ ⵜⵔⴳⴰⵍⵜ ⵉⵖⵓⴷⴰⵏ ⵎⴽⵍⵍⵉ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵙⵏⴰⵜ ⵜⴼⵓⵍⵉⵏ ⵎⴰⴷ ⵢⵓⴼⵏ ⵅⴰⵜⴰⵔ ./// ⵎⴽ ⵓⵔ ⵜⴽⴽⵉⴷ ⵔⴱⴱⵉ -1 /// ⵜⴰⵎⵉⴹⵉ ⵏ ⴽⵕⴰⴹ ⵉⵎⵉⴹⵉ ⵏ ⵜⵔⴳⴰⵍⵜ ⵎⴽⵍⵍⵉ ⴳⴰⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵢⴰⵏ ⵓⵎⵉⴹⵉ ⵏ ⴽⵕⴰⴹ ⵉⵎⵉⴹⵉ ⵏ ⵜⵔⴳⴰⵍⵜ. /// ⵙ ⵓⵙⵙⴽⵛⵎ ⵏ ⵜⵉⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⵢⴰⵏ ⵓⴽⵕⴰⴹ. ⵔⵎⵙⵏ ⵜⴰⵊⵓⵎⵎⴰ ⵏ /// >>> triangle_area(3, 4, 5)
/// 6.0
/// >>> triangle_area(1, 2, 10)
/// -1.0
fn triangle_area(a: isize, b: isize, c: isize) -> f64 {
","fn triangle_area(a: isize, b: isize, c: isize) -> f64 {
    if a + b > c && a + c > b && b + c > a {
        let s = (a + b + c) as f64 / 2.0;
        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();
        (area * 100.0).round() / 100.0
    } else {
        -1.0
    }
}

fn main() {
    println!(""{}"", triangle_area(3, 4, 5)); // 6.0
    println!(""{}"", triangle_area(1, 2, 10)); // -1.0
}","}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(3, 4, 5), 6.0);
    assert_eq!(candidate(1, 2, 10), -1.0);
    assert_eq!(candidate(4, 8, 5), 8.18);
    assert_eq!(candidate(2, 2, 2), 1.73);
    assert_eq!(candidate(1, 2, 3), -1.0);
    assert_eq!(candidate(10, 5, 7), 16.25);
    assert_eq!(candidate(2, 6, 3), -1.0);
    assert_eq!(candidate(1, 1, 1), 0.43);
    assert_eq!(candidate(2, 2, 10), -1.0);
}
"
HumanEval_72,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// ⴰⴷ ⵉⵣⵣⵔⵉ ⵓⴷⵎ q ⵎⴽ ⵉⴳⴰ ⴰⵎⵙⴰⵙⴰ (ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉ) ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⵙ ⵉⴳⴰ ⵜⵜ ⵡⴰⵔ ⵓⴳⴳⴰⵔ ⵏ ⵓⴽⵙⴰⵢ ⴰⵎⵇⵔⴰⵏ w. /// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⴷⴰ ⵉⵜⵜⴳ ⵡⴰⵏⴰⵡ q, ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ. /// >>> will_it_fly(vec![1, 2], 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(vec![3, 2, 3], 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(vec![3, 2, 3], 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(vec![3], 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
fn will_it_fly(q: Vec<isize>, w: isize) -> bool {
","fn will_it_fly(q: Vec<isize>, w: isize) -> bool {
    let sum: isize = q.iter().sum();
    let is_palindromic = q.iter().eq(q.iter().rev());

    is_palindromic && sum <= w
}

fn main() {
    // Test cases
    println!(""{}"", will_it_fly(vec![1, 2], 5)); // false
    println!(""{}"", will_it_fly(vec![3, 2, 3], 1)); // false
    println!(""{}"", will_it_fly(vec![3, 2, 3], 9)); // true
    println!(""{}"", will_it_fly(vec![3], 5)); // true
}","}

fn main() {
    let candidate = will_it_fly;
    assert_eq!(candidate(vec![3, 2, 3], 9), true);
    assert_eq!(candidate(vec![1, 2], 5), false);
    assert_eq!(candidate(vec![3], 5), true);
    assert_eq!(candidate(vec![3, 2, 3], 1), false);
    assert_eq!(candidate(vec![1, 2, 3], 6), false);
    assert_eq!(candidate(vec![5], 5), true);
}
"
HumanEval_73,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⴷⴰ ⵉⵜⵜⵓⵙⵔⴰⵙ ⵙ ⵢⴰⵜ ⵜⵖⴰⵔⴰⵙⵜ ⵉⵎⵙⴰⵙⴰⵏ ⴳ ⵓⵎⵏⵉⴷ ⴷ ⵓⴳⴰⴼⴰ. ⴳ ⵢⴰⵏ ⵓⵙⵏⴼⵍ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵏⴼⵍⴷ ⵢⴰⵏ ⵉⴼⵔⴷⵉⵙ ⵙ ⴽⵔⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵢⴰⴹⵏⵉⵏ./// ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⵍ ⴰⴼⴰⴷ ⴰⴷ ⵉⴳ ⵓⵡⵉⴽⵜⵓⵔ ⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉ. ⵓⵡⵉⴽⵜⵓⵔ ⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉ ⵉⴳⴰ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ /// ⴰⵖ ⴷ ⵢⵓⴼⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵢⴰⴼⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ /// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(vec![1, 2, 3, 2, 1])
/// 0
fn smallest_change(arr: Vec<isize>) -> isize {
","fn smallest_change(arr: Vec<isize>) -> isize {
    let mut changes = 0;
    let n = arr.len();
    
    for i in 0..n/2 {
        if arr[i] != arr[n - i - 1] {
            changes += 1;
        }
    }
    
    changes
}

// Example usage:
// fn main() {
//     let result = smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6]);
//     println!(""{}"", result); // Outputs: 4
// }","}

fn main() {
    let candidate = smallest_change;
    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);
    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);
    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(vec![0, 1]), 1);
}
"
HumanEval_74,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ /// ⵎⴽ ⴷⴰⵔ ⵙⵉⵏ ⵉⵎⵙⵙⵓⴷⵙⵏ ⵉⵎⵉⴹⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ, ⵙⵙⵓⴼⵖ ⴰⵎⵙⵙⵓⴷⵙ ⴰⵎⵣⵡⴰⵔⵓ. /// ⴰⵟⵟⵓⵏ ⵏ ⵜⴽⴰⵔ ⴳ ⴽⵓⵍⵍⵓ ⵜⵉⵙⴷⴷⴰⵔ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵎⵥⵥⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵢⴰⴹⵏ. /// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵙⵉⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⴰⵔ ⵙⴽⴰⵔⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵏⵏⴰ ⵖⵓⵔ /// >>> total_match(vec![], vec![])
/// Vec::<String>::new()
/// >>> total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""Hi"")])
/// vec![String::from(""hI""), String::from(""Hi"")]
/// >>> total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hi""), String::from(""hi""), String::from(""admin""), String::from(""project"")])
/// vec![String::from(""hi""), String::from(""admin"")]
/// >>> total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")])
/// vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")]
/// >>> total_match(vec![String::from(""4"")], vec![String::from(""1""), String::from(""2""), String::from(""3""), String::from(""4""), String::from(""5"")])
/// vec![String::from(""4"")]
fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {
","fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {
    let char_count = |lst: &Vec<String>| lst.iter().map(|s| s.len()).sum::<usize>();

    if char_count(&lst1) <= char_count(&lst2) {
        lst1
    } else {
        lst2
    }
}

// Example usage
fn main() {
    let result1 = total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""Hi"")]);
    println!(""{:?}"", result1);

    let result2 = total_match(vec![String::from(""4"")], vec![String::from(""1""), String::from(""2""), String::from(""3""), String::from(""4""), String::from(""5"")]);
    println!(""{:?}"", result2);
}","}

fn main() {
    let candidate = total_match;
    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hi""), String::from(""hi"")]), vec![String::from(""hi""), String::from(""hi"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hi""), String::from(""hi""), String::from(""admin""), String::from(""project"")]), vec![String::from(""hi""), String::from(""admin"")]);
    assert_eq!(candidate(vec![String::from(""4"")], vec![String::from(""1""), String::from(""2""), String::from(""3""), String::from(""4""), String::from(""5"")]), vec![String::from(""4"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""Hi"")]), vec![String::from(""hI""), String::from(""Hi"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")]), vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""hi""), String::from(""hii"")]), vec![String::from(""hi""), String::from(""admin"")]);
    assert_eq!(candidate(Vec::<String>::new(), vec![String::from(""this"")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""this"")], Vec::<String>::new()), Vec::<String>::new());
}
"
HumanEval_75,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// ⵙ ⵓⵙⵙⴰⵏ ⵏ ⵎⴰⵙ ⴷ (ⴰ) ⴷⵔⵓⵙ ⵙⴳ 100. /// ⴷ ⵜⵉⵣⴳⴰⵍ ⴹⴰⵕⵜ ⵓⵢⴰ./// ⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵉⵜⵜⴰⵡⵙⵏ ⴰⴷ ⵏⵙⵙⴽⵔ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⴰ ⵏⵜⵜⴰⴼⴰ ⴰⵎⴽ ⵉⴳⴰ ⵓⴽⴼⵓⴷ ⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ /// >>> is_multiply_prime(30)
/// true
/// 30 = 2 * 3 * 5
fn is_multiply_prime(a: isize) -> bool {
","fn is_multiply_prime(a: isize) -> bool {
    fn is_prime(n: isize) -> bool {
        if n <= 1 {
            return false;
        }
        if n <= 3 {
            return true;
        }
        if n % 2 == 0 || n % 3 == 0 {
            return false;
        }
        let mut i = 5;
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 {
                return false;
            }
            i += 6;
        }
        true
    }

    if a < 2 {
        return false;
    }

    let mut primes = Vec::new();
    for i in 2..a {
        if is_prime(i) {
            primes.push(i);
        }
    }

    let p_len = primes.len();
    for i in 0..p_len {
        for j in i..p_len {
            for k in j..p_len {
                if primes[i] * primes[j] * primes[k] == a {
                    return true;
                }
            }
        }
    }
    false
}","}

fn main() {
    let candidate = is_multiply_prime;
    assert_eq!(candidate(5), false);
    assert_eq!(candidate(30), true);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), false);
    assert_eq!(candidate(125), true);
    assert_eq!(candidate(105), true);
    assert_eq!(candidate(126), false);
    assert_eq!(candidate(729), false);
    assert_eq!(candidate(891), false);
    assert_eq!(candidate(1001), true);
}
"
HumanEval_76,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// x ⴷ ⵜⴰⵣⴷⵓⵖⵜ ⵜⴰⵎⵢⵉⵡⴰⵏⵜ ⵏ n ⵎⴽ n**int=x /// ⵜⴰⵣⵎⵔⵜ ⵏ n ⴷ false ⴳ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏⵉⵏ. /// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵔⵔⴰⵎ ⵢⴰⵜ ⵜⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ x ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⵀⴰⵢⵢⵉ/// >>> is_simple_power(1, 4)
/// true
/// >>> is_simple_power(2, 2)
/// true
/// >>> is_simple_power(8, 2)
/// true
/// >>> is_simple_power(3, 2)
/// false
/// >>> is_simple_power(3, 1)
/// false
/// >>> is_simple_power(5, 3)
/// false
fn is_simple_power(x: isize, n: isize) -> bool {
","fn is_simple_power(x: isize, n: isize) -> bool {
    if x <= 0 || n <= 0 {
        return false;
    } else if x == 1 {
        return true;
    } else if n == 1 {
        return x == 1;
    }

    let mut power_n = n;
    while power_n < x {
        power_n *= n;
    }
    power_n == x
}

fn main() {
    println!(""{}"", is_simple_power(1, 4)); // true
    println!(""{}"", is_simple_power(2, 2)); // true
    println!(""{}"", is_simple_power(8, 2)); // true
    println!(""{}"", is_simple_power(3, 2)); // false
    println!(""{}"", is_simple_power(3, 1)); // false
    println!(""{}"", is_simple_power(5, 3)); // false
}","}

fn main() {
    let candidate = is_simple_power;
    assert_eq!(candidate(16, 2), true);
    assert_eq!(candidate(143214, 16), false);
    assert_eq!(candidate(4, 2), true);
    assert_eq!(candidate(9, 3), true);
    assert_eq!(candidate(16, 4), true);
    assert_eq!(candidate(24, 2), false);
    assert_eq!(candidate(128, 4), false);
    assert_eq!(candidate(12, 6), false);
    assert_eq!(candidate(1, 1), true);
    assert_eq!(candidate(1, 12), true);
}
"
HumanEval_77,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵜⴰⵏⵏⴰⵢⵜ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴷ ⵉⵙ ⵉⴳⴰ ⵡⵉⵏ ⵜⴽⵛⵛⵓⵎⵜ ⴰⵀⴰ ⵉⴳⴰ ⵡⵉⵏ ⵜⴽⵛⵛⵓⵎⵜ./// ⵉⵖ ⵉⴳⴰ ⵡⵉⴽⵉⴱⵉⴷⵢⴰ ⴰⴷ ⵢⴰⵏ ⵓⴽⵡⴼⴰⵢ ⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ. /// ⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ a ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ true /// >>> iscube(1)
/// true
/// >>> iscube(2)
/// false
/// >>> iscube(-1)
/// true
/// >>> iscube(64)
/// true
/// >>> iscube(0)
/// true
/// >>> iscube(180)
/// false
fn iscube(a: isize) -> bool {
","fn iscube(a: isize) -> bool {
    if a < 0 {
        // For negative numbers, take the cube root of the absolute value.
        let cube_root = (-a as f64).cbrt();
        let rounded_cube = cube_root.round() as isize;
        rounded_cube * rounded_cube * rounded_cube == a
    } else {
        let cube_root = (a as f64).cbrt();
        let rounded_cube = cube_root.round() as isize;
        rounded_cube * rounded_cube * rounded_cube == a
    }
}

fn main() {
    println!(""{}"", iscube(1));   // true
    println!(""{}"", iscube(2));   // false
    println!(""{}"", iscube(-1));  // true
    println!(""{}"", iscube(64));  // true
    println!(""{}"", iscube(0));   // true
    println!(""{}"", iscube(180)); // false
}","}

fn main() {
    let candidate = iscube;
    assert_eq!(candidate(1), true);
    assert_eq!(candidate(2), false);
    assert_eq!(candidate(-1), true);
    assert_eq!(candidate(64), true);
    assert_eq!(candidate(180), false);
    assert_eq!(candidate(1000), true);
    assert_eq!(candidate(0), true);
    assert_eq!(candidate(1729), false);
}
"
HumanEval_78,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⴷ ⵉⵙⵎⵎⴰⵡⵏ A,B,C,D,E,F ⴰⵀⴰ ⴳⴰⵏ ⵉⵎⵣⴳⵓⵏⵏ ⵉⵎⵇⵔⴰⵏⵏ. /// ⵜⴰⵏⵏⴰⵢⵜ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴷ ⵉⵙ ⵉⴳⴰ ⵡⴰⴷⴷⴰⴷ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵀⴰ ⵉⴳⴰ ⵜⴷⵓⵙ ⵏⵖⴷ ⴰⵖⵉⵍⵓⴼ ⵉⴼⵔⵓⵔⵉⵏ, /// B (= ⴷⵣⵉⵎⴰⵍ 11), D (= ⴷⵣⵉⵎⴰⵍ 13). /// ⴰⵢⴰ ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵙⵙⵏⵎⴹⵎ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ ⵡⵓⵟⵟⵓⵏⵏ ⴰⴷ: 2, 3, 5, 7, /// ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴳⴰⵏ 2, 3, 5, 7, 11, 13, 17,... /// ⴷⵉⵀⴰⵣⴰⴷⵉⴽⵉⵎⴰⵜ ⴷⵉⵊⵉⵜⵏ ⴳⴰⵏ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. /// ⴰⵅⴰⵜⴰⵔ ⵙⴳ 1 ⵓⵔ ⵉⴳⵉ ⴰⵎⵢⴰⴼⵓ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵥⵥⵉⵏ ⵏ ⵓⴳⴰⵎⴰ)./// ⴷ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ (ⵉⴹ ⴰⵎⵣⵡⴰⵔⵓ, ⵏⵖ ⴰⵎⵣⵡⴰⵔⵓ, ⵉⴳⴰ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⴳⴰⵎⴰⵏ /// ⴰⵎⴹⴰⵏ ⴰⵀⵉⵊⴰⴷⵉⵛⵎⴰⵍ ⴰⵎⵎ ⵜⴰⵡⴰⵍⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⴷ ⴰⵔ ⵉⵙⵉⴹⵏ ⴰⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⴰⵀⵉⵊⴰⴷⵉⵛⵎⴰⵍⵏ /// ⵜⵜⵓⵣⵔⴰⴽ ⴰⴷ ⵜⴰⵔⵉⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵔⴰⴷ ⵢⴰⵎⵥ /// >>> hex_key(String::from(""AB""))
/// 1
/// >>> hex_key(String::from(""1077E""))
/// 2
/// >>> hex_key(String::from(""ABED1A33""))
/// 4
/// >>> hex_key(String::from(""123456789ABCDEF0""))
/// 6
/// >>> hex_key(String::from(""2020""))
/// 2
fn hex_key(num: String) -> isize {
","fn hex_key(num: String) -> isize {
    let prime_hex_chars = vec!['2', '3', '5', '7', 'B', 'D'];
    num.chars()
        .filter(|c| prime_hex_chars.contains(c))
        .count() as isize
}","}

fn main() {
    let candidate = hex_key;
    assert_eq!(candidate(String::from(""AB"")), 1);
    assert_eq!(candidate(String::from(""1077E"")), 2);
    assert_eq!(candidate(String::from(""ABED1A33"")), 4);
    assert_eq!(candidate(String::from(""2020"")), 2);
    assert_eq!(candidate(String::from(""123456789ABCDEF0"")), 6);
    assert_eq!(candidate(String::from(""112233445566778899AABBCCDDEEFF00"")), 12);
}
"
HumanEval_79,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵉⵙⴽⴽⵉⵍⵏ ⵢⴰⴹⵏ ⵉⵍⵍⴰⵏ ⴰⴼⴰⴷ ⴰⴷ ⵙⵙⵓⴷⵙⵏ ⵜⴰⵍⵖⴰ. /// ⴰⴷ ⵉⵍⵉⵏⵜ ⴽⵔⴰ ⵏ ⵜⴽⴰⵔⴹⵉⵡⵉⵏ ⵢⴰⴹⵏⵉⵏ 'db' ⴳ ⵍⴱⴷⵓ ⴷ ⵜⴳⵉⵔⴰ ⵏ ⵜⵣⵍⵉⵜ. //ⴽⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ ⵜⵣⵍⵉⵜ ⵔⴰⴷ ⴳⵉⵏ '0' ⵏⵖ '1'./// ⴷⵓⵎⵎⵍ ⵏ ⵙⵉⵏⵉⵕ. ⵔⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ, ⴷ ⴽⵓ ⵉⵙⴽⴽⵉⵍ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵏ ⴹⵓⵎⵎⵍ ⵏ ⵙⵉⵏⵉⵕ./// ⴰⴷ ⴽⴽⵙⵎ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴳ ⵜⴰⵍⵖⴰ ⵏ ⵜⵓⵙⴷⵉⴷⵜ ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⴼⵍⵎ ⵖⵔ /// >>> decimal_to_binary(15)
/// String::from(""db1111db"")
/// >>> decimal_to_binary(32)
/// String::from(""db100000db"")
fn decimal_to_binary(decimal: isize) -> String {
","fn decimal_to_binary(decimal: isize) -> String {
    let binary_string = format!(""{:b}"", decimal);
    format!(""db{}db"", binary_string)
}

fn main() {
    // Example usage
    let binary_15 = decimal_to_binary(15);
    let binary_32 = decimal_to_binary(32);
    println!(""{}"", binary_15); // Outputs: db1111db
    println!(""{}"", binary_32); // Outputs: db100000db
}","}

fn main() {
    let candidate = decimal_to_binary;
    assert_eq!(candidate(0), String::from(""db0db""));
    assert_eq!(candidate(32), String::from(""db100000db""));
    assert_eq!(candidate(103), String::from(""db1100111db""));
    assert_eq!(candidate(15), String::from(""db1111db""));
}
"
HumanEval_80,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⵜⴰⵡⴰⵍⵜ ⵜⴳⴰ ⵜⵜ ⵉⵖ ⵉⵖ ⵜⴳⴰ ⵜⴰⵖⵣⵉ ⵏⵏⵙ ⴽⵕⴰⴹ ⴷ ⴽⵕⴰⴹⵜ ⵜⵉⵔⵔⴰ ⵉⵎⵣⴰⵔⴰⵢⵏ /// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵥⵕⵎ ⵎⴽ ⵜⴳⴰ ⵜⵊⵊⵉⵜ ⵏ ⵓⵖⵉⵍⵓⴼ ⵏⵖ ⵓⵔ ⵜⵍⵍⵉ. /// ⴰⵜⵏⵢⴰⵜ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵜ ⵜⵣⵍⵉⵜ s. /// >>> is_happy(String::from(""a""))
/// false
/// >>> is_happy(String::from(""aa""))
/// false
/// >>> is_happy(String::from(""abcd""))
/// true
/// >>> is_happy(String::from(""aabb""))
/// false
/// >>> is_happy(String::from(""adb""))
/// true
/// >>> is_happy(String::from(""xyy""))
/// false
fn is_happy(s: String) -> bool {
","fn is_happy(s: String) -> bool {
    if s.len() < 3 {
        return false;
    }

    let chars: Vec<char> = s.chars().collect();
    for i in 0..(chars.len() - 2) {
        if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] || chars[i + 1] == chars[i + 2] {
            return false;
        }
    }

    true
}

fn main() {
    println!(""{}"", is_happy(String::from(""a""))); // false
    println!(""{}"", is_happy(String::from(""aa""))); // false
    println!(""{}"", is_happy(String::from(""abcd""))); // true
    println!(""{}"", is_happy(String::from(""aabb""))); // false
    println!(""{}"", is_happy(String::from(""adb""))); // true
    println!(""{}"", is_happy(String::from(""xyy""))); // false
}","}

fn main() {
    let candidate = is_happy;
    assert_eq!(candidate(String::from(""a"")), false);
    assert_eq!(candidate(String::from(""aa"")), false);
    assert_eq!(candidate(String::from(""abcd"")), true);
    assert_eq!(candidate(String::from(""aabb"")), false);
    assert_eq!(candidate(String::from(""adb"")), true);
    assert_eq!(candidate(String::from(""xyy"")), false);
    assert_eq!(candidate(String::from(""iopaxpoi"")), true);
    assert_eq!(candidate(String::from(""iopaxioi"")), false);
}
"
HumanEval_81,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// 0.0 E /// > 0.0 D- /// > 0.7 D /// > 1.0 ⴷ+ /// > 1.3 C- /// > 1.7 C /// > 2.0 C+ /// > 2.3 ⴱ- /// > 2.7 B /// > 3.0 ⴱ+ /// > 3.3 ⴰ- /// > 3.7 ⴰ /// 4.0 ⴰ+ /// GPA. ⵍⵉⴱⵔⵉⴷ ⵏ ⵓⵙⵡⵉⵔ /// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵥⴹⴰⵕⵏ ⴰⴷ ⵉⴼⴽ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵙⵡⵉⵔⵏ ⵏ ⵜⵉⵔⵔⴰ ⵙ ⵓⵙⵎⵔⵙ ⵏ ⵜⴽⴰⵔⴹⴰ ⴰⴷ: /// ⵜⵙⴽⵔ ⵢⴰⵜ ⵜⴽⵍⵉⵜ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⴽⵔⴰ ⵏ ⵉⵏⵍⵎⴰⴷⵏ ⴷ ⵜⵙⵎⵓⵜⵜⴳⵏ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵔⵔⴰⵎ /// ⵜⴰⵎⵓⴽⵔⵉⵙⵜ ⴷⴰ ⵜⵍⵍⴰ ⴷⵉ ⵎⴰⵙ ⴷ ⵜⵓⴼⴰ ⴰⵙⵏⴼⴰⵔ ⵏⵏⴰ ⵜⵙⵎⵔⴰⵙ ⵉ ⵓⵙⵜⴰⵍ. /// ⵉ ⵉⵏⵍⵎⴰⴷⵏ. ⵉⵙⴽⵔ ⵓⵙⵍⵎⴰⴷ ⴰⵍⴳⵓⵔⵉⵜⵎ ⵏⵏⵙ ⵉⵅⴼ ⵏⵙ ⵉ ⵓⵙⵜⴰⵍ./// ⴷ ⵉⵎⴰⵍⴰⵙⵙ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵜⵙⵓⵜⵍⵜ ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⴼⴽ ⵓⵙⵍⵎⴰⴷ ⵜⵉⵙⴽⵜⵉⵜⵉⵏ /// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])
/// vec![String::from(""A+""), String::from(""B""), String::from(""C-""), String::from(""C""), String::from(""A-"")]
fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {
","fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {
    grades.into_iter().map(|gpa| {
        match gpa {
            4.0 => String::from(""A+""),
            v if v > 3.7 => String::from(""A""),
            v if v > 3.3 => String::from(""A-""),
            v if v > 3.0 => String::from(""B+""),
            v if v > 2.7 => String::from(""B""),
            v if v > 2.3 => String::from(""B-""),
            v if v > 2.0 => String::from(""C+""),
            v if v > 1.7 => String::from(""C""),
            v if v > 1.3 => String::from(""C-""),
            v if v > 1.0 => String::from(""D+""),
            v if v > 0.7 => String::from(""D""),
            v if v > 0.0 => String::from(""D-""),
            _ => String::from(""E""),
        }
    }).collect()
}","}

fn main() {
    let candidate = numerical_letter_grade;
    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from(""A+""), String::from(""B""), String::from(""C-""), String::from(""C""), String::from(""A-"")]);
    assert_eq!(candidate(vec![1.2]), vec![String::from(""D+"")]);
    assert_eq!(candidate(vec![0.5]), vec![String::from(""D-"")]);
    assert_eq!(candidate(vec![0.0]), vec![String::from(""E"")]);
    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from(""D""), String::from(""D-""), String::from(""C-""), String::from(""B""), String::from(""B+"")]);
    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from(""E""), String::from(""D-"")]);
}
"
HumanEval_82,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ /// ⵜⵉⵖⵣⵉ ⵜⴳⴰ ⴰⵎⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵏⵖⴷ ⵜⵉⴳⵡⵏⵙⵉ /// ⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵍⴰⵏ ⴰⵔ ⵉⵜⵜⴰⴽⵡⵍ ⵜⵉⴷⵜ ⵎⴽ ⵜⴳⴰ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵍⴰⵏ /// >>> prime_length(String::from(""Hello""))
/// true
/// >>> prime_length(String::from(""abcdcba""))
/// true
/// >>> prime_length(String::from(""kittens""))
/// true
/// >>> prime_length(String::from(""orange""))
/// false
fn prime_length(string: String) -> bool {
","fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn prime_length(string: String) -> bool {
    let length = string.len();
    is_prime(length)
}

// Example usage
fn main() {
    println!(""{}"", prime_length(String::from(""Hello""))); // true
    println!(""{}"", prime_length(String::from(""abcdcba""))); // true
    println!(""{}"", prime_length(String::from(""kittens""))); // true
    println!(""{}"", prime_length(String::from(""orange""))); // false
}","}

fn main() {
    let candidate = prime_length;
    assert_eq!(candidate(String::from(""Hello"")), true);
    assert_eq!(candidate(String::from(""abcdcba"")), true);
    assert_eq!(candidate(String::from(""kittens"")), true);
    assert_eq!(candidate(String::from(""orange"")), false);
    assert_eq!(candidate(String::from(""wow"")), true);
    assert_eq!(candidate(String::from(""world"")), true);
    assert_eq!(candidate(String::from(""MadaM"")), true);
    assert_eq!(candidate(String::from(""Wow"")), true);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""HI"")), true);
    assert_eq!(candidate(String::from(""go"")), true);
    assert_eq!(candidate(String::from(""gogo"")), false);
    assert_eq!(candidate(String::from(""aaaaaaaaaaaaaaa"")), false);
    assert_eq!(candidate(String::from(""Madam"")), true);
    assert_eq!(candidate(String::from(""M"")), false);
    assert_eq!(candidate(String::from(""0"")), false);
}
"
HumanEval_83,tzm_Tfng,rs,"/// ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⵏ ⵏⵖ ⵉⵜⵜⵉⵔⴰⵢⵏ ⵙ 1. /// ⵙ ⵓⴹⴼⵓⵕ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ n, ⵙⴽⵔ ⵜⴰⵙⵙⵉⴹⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ n ⴹⴹⵉⵊⵉⵜⵏ fn starts_one_ends(n: isize) -> isize {
","fn starts_one_ends(n: isize) -> isize {
    if n <= 0 {
        return 0;
    }
    if n == 1 {
        return 1; // only '1' satisfies the condition for a single-digit
    }

    // Consider numbers starting with '1' (1XXXX...)
    let start_with_one = 9isize.pow((n-1) as u32);

    // Consider numbers ending with '1' (...XXXX1)
    let end_with_one = 9isize.pow((n-1) as u32);
    
    // Consider numbers both starting and ending with '1' and check overlaps (1XXX1)
    let both_start_end_one = 9isize.pow((n-2) as u32);

    // Total numbers starting or ending with '1'
    start_with_one + end_with_one - both_start_end_one
}

fn main() {
    // Example usage:
    let n = 3;
    println!(""Count of n-digit numbers starting or ending with 1: {}"", starts_one_ends(n));
}","}

fn main() {
    let candidate = starts_one_ends;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(2), 18);
    assert_eq!(candidate(3), 180);
    assert_eq!(candidate(4), 1800);
    assert_eq!(candidate(5), 18000);
}
"
HumanEval_84,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ /// ⴷⴰⵜ ⵏ ⵢⴰⵏ ⵉⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ N, ⵙⵙⵓⴼⵖ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⵙ ⵜⴱⵉⵏⴰⵔⵉⵜ. /// >>> solve(1000)
/// String::from(""1"")
/// >>> solve(150)
/// String::from(""110"")
/// >>> solve(147)
/// String::from(""1100"")
/// Variables:
/// @N integer
/// Constraints: 0 ≤ N ≤ 10000.
/// Output:
/// a string of binary number
fn solve(N: isize) -> String {
","fn solve(N: isize) -> String {
    let sum_of_digits: isize = N
        .to_string()
        .chars()
        .map(|c| c.to_digit(10).unwrap() as isize)
        .sum();
    
    format!(""{:b}"", sum_of_digits)
}","}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(1000), String::from(""1""));
    assert_eq!(candidate(150), String::from(""110""));
    assert_eq!(candidate(147), String::from(""1100""));
    assert_eq!(candidate(333), String::from(""1001""));
    assert_eq!(candidate(963), String::from(""10010""));
}
"
HumanEval_85,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⴰⵛⴽⵓ ⵏⵙⴽⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵓⵔ ⵉⴳⵉ ⴰⵣⴳⵣⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵔⵏⵓⵏ ⵉⵎⵔⵙⵉⵢⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⴳⴰⵏⵉⵏ ⴳ ⵉⵙⵓⴹⴰⴼ ⵉⵎⵣⴰⵔⴰⵢⵏ.. /// >>> add(vec![4, 2, 6, 7])
/// 2
fn add(lst: Vec<isize>) -> isize {
","fn add(lst: Vec<isize>) -> isize {
    lst.iter()
        .enumerate()
        .filter(|(i, _)| i % 2 == 1) // select odd indices
        .map(|(_, &x)| x) // get the values at odd indices
        .filter(|&x| x % 2 == 0) // filter even values
        .sum() // sum the values
}","}

fn main() {
    let candidate = add;
    assert_eq!(candidate(vec![4, 88]), 88);
    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);
    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);
    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);
}
"
HumanEval_86,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⵜⴰⵏⵏⴰⵢⵜ: ⵔⴰⴷ ⵜⵃⴹⵓ ⵜⴰⴼⵔⴰⵔⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⵡⴰⵏⵙⴰ ⴳ ⵜⴳⵓⵔⵉ. /// ⴰⴹⴼⴼⵓⵕ ⴰⵎⵇⵔⴰⵏ ⵅⴼ ⵡⴰⵜⵉⴳ ⵏ ascii. /// ⴷⴰ ⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⵙ ⵜⴳⵓⵔⵉ ⵜⴰⵎⴰⵢⵏⵓⵜ ⴳ ⵔⴰⴷ ⵙⵙⵓⴷⵙⵏ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ /// ⵜⴰⵡⵍⴰⴼⵜ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵜⴳⴰ ⵜⵉⴼⵉⵏⴰⵖ ⴳ ⵍⵍⴰⵏⵜ ⴽⵓⵍⵍⵓ ⵜⴳⵓⵔⵉⵡⵉⵏ (ⵉⴱⴹⴰⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ) /// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵎⴰⵍ ⴷ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵜ ⵜⵓⵏⵖⵉⵍⵜ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⵏ. /// >>> anti_shuffle(String::from(""Hi""))
/// String::from(""Hi"")
/// >>> anti_shuffle(String::from(""hello""))
/// String::from(""ehllo"")
/// >>> anti_shuffle(String::from(""Hello World!!!""))
/// String::from(""Hello !!!Wdlor"")
fn anti_shuffle(s: String) -> String {
","fn anti_shuffle(s: String) -> String {
    let mut result = String::new();
    let mut word = String::new();

    for c in s.chars() {
        if c.is_whitespace() {
            if !word.is_empty() {
                let mut chars: Vec<char> = word.chars().collect();
                chars.sort_unstable();
                result.push_str(&chars.into_iter().collect::<String>());
                word.clear();
            }
            result.push(c);
        } else {
            word.push(c);
        }
    }

    if !word.is_empty() {
        let mut chars: Vec<char> = word.chars().collect();
        chars.sort_unstable();
        result.push_str(&chars.into_iter().collect::<String>());
    }

    result
}

fn main() {
    // Example usages:
    println!(""{}"", anti_shuffle(String::from(""Hi"")));              // ""Hi""
    println!(""{}"", anti_shuffle(String::from(""hello"")));           // ""ehllo""
    println!(""{}"", anti_shuffle(String::from(""Hello World!!!"")));  // ""Hello !!!Wdlor""
}","}

fn main() {
    let candidate = anti_shuffle;
    assert_eq!(candidate(String::from(""Hi"")), String::from(""Hi""));
    assert_eq!(candidate(String::from(""hello"")), String::from(""ehllo""));
    assert_eq!(candidate(String::from(""number"")), String::from(""bemnru""));
    assert_eq!(candidate(String::from(""abcd"")), String::from(""abcd""));
    assert_eq!(candidate(String::from(""Hello World!!!"")), String::from(""Hello !!!Wdlor""));
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""Hi. My name is Mister Robot. How are you?"")), String::from("".Hi My aemn is Meirst .Rboot How aer ?ouy""));
}
"
HumanEval_87,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⴰⵡⴷ, ⵙⵙⵓⴷⵙ ⴰⴽⵓⵓⵔⴷⵉⴰⵜⵏ ⵏ ⵜⵉⵙⴳⵉⵡⵉⵏ ⵙ ⵜⵔⵙⴰⵍ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⴷⴰⵔ. /// ⵙⵙⵓⴷⵙ ⴰⴽⵓⵓⵔⴷⵉⴰⵜⵏ ⴳ ⵜⵉⵣⵡⵉⵔⵉ ⵙ ⵜⵉⴼⵔⵉⵙⵉⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⵏ ⵓⴽⵛⵛⵓⵎ. /// ⴽⵓ ⵜⴰⴱⵍⵓⵜ ⵜⴳⴰ ⴽⵓⵓⵔⴷⵉⴷⴰⵜ - (ⵜⵉⵔⵉⵜ, ⵜⵉⵔⵙⴰⵍ), ⴰⵔ ⵜⴱⴷⴰⴷ ⵙ 0. /// ⴷ ⵓⵎⵙⵙⵓⵜⵍ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⴱⵔⵔⵉⵜⵉⵏ, [(x1, y1), (x2, y2) ...] ⵣⵓⵏⴷ ⵎⴰⵙ /// ⵙ ⵓⵙⴽⴽⵉⵍ lst, ⴷ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ x, ⵥⵕ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ x ⴳ ⵓⴱⴰⵢⵢⵓⵕ, /// ⴽⵓ ⵜⴰⵡⵔⵉⵔⵜ ⵜⵣⵎⵔ ⴰⴷ ⵜⴰⴽⴽⴰ ⵉⵎⴹⴰⵏⵏ ⵏ ⵜⵔⵙⴰⵍ./// ⵏⵏⴰ ⵢⴰⴽⵙⵓⵍⵏ ⴷ ⵎⴰⵜⵔⵉⴽⵙ, ⵎⴰⵛⴰ, ⵓⵔ ⵢⴰⴽⵙⵓⵍⵏ ⴷ ⵎⴰⵜⵔⵉⴽⵙ, /// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡⵏ ⵏ ⵙⵉⵏ ⵡⵓⴳⴳⵓⴳⵏ, ⵙ ⵡⴰⵏⴰⵡ ⵏ ⵉⵎⵙⵙⵓⴷⵙⵏ ⵉⵜⵜⵓⵙⵎⵓⵏⵏ, /// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)
/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(vec![], 1)
/// Vec::<(isize, isize)>::new()
/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)
/// vec![(2, 2)]
fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {
","fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {
    let mut result = Vec::new();

    for (row_index, row) in lst.iter().enumerate() {
        let mut found_indices: Vec<isize> = row.iter()
            .enumerate()
            .filter(|&(_, &value)| value == x)
            .map(|(col_index, _)| col_index as isize)
            .collect();

        found_indices.sort_by(|a, b| b.cmp(a)); // Sort column indices in descending order

        for col_index in found_indices {
            result.push((row_index as isize, col_index));
        }
    }

    result
}","}

fn main() {
    let candidate = get_row;
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);
    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);
}
"
HumanEval_88,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// * ⵓⵔ ⴷⴰ ⵏⵙⵙⵏⴼⵍ ⴰⴱⴽⴽⵉⴹ ⵉⵜⵜⵓⴼⴽⴰⵏ. /// ⵜⴰⵏⵏⴰⵢⵜ: /// ⵏⵖ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⴷⴰⵔⵓ ⵎⴽ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵓⴷⵙ ⴰⵎⴳⴳⴰⵔⵓ) ⴰⵎⵎ ⵓⵎⵉⴹⴰⵏ./// ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵉⴽⵜⵓⵔⵏ ⵉⵜⵜⵓⵢⴰⴼⴰⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵇⵔⴰⵏ ⵎⴽ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⵡⴰⵔⵓ, ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵓⴷⵙ ⴰⵎⴳⴳⴰⵔⵓ) ⵓⵔ ⵉⵎⵢⴰⵏⴰⵡⵏ, /// ⴷⴼⴼⵉⵔ ⵏ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵔⵉⵏ, ⵔⵎⵙⵏ ⵢⴰⵜ ⵜⴽⵔⵓⵙⵜ ⵏ ⵓⴽⵜⵓⵔ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵎⵙⴰⵙⴰ, /// >>> sort_array(vec![])
/// Vec::<isize>::new()
/// >>> sort_array(vec![5])
/// vec![5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])
/// vec![0, 1, 2, 3, 4, 5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])
/// vec![6, 5, 4, 3, 2, 1, 0]
fn sort_array(array: Vec<isize>) -> Vec<isize> {
","fn sort_array(array: Vec<isize>) -> Vec<isize> {
    if array.is_empty() {
        return Vec::<isize>::new();
    }

    let first = array.first().unwrap_or(&0);
    let last = array.last().unwrap_or(&0);
    let sum = first + last;

    let mut sorted_array = array.clone();
    if sum % 2 == 0 {
        sorted_array.sort_by(|a, b| b.cmp(a)); // Descending order
    } else {
        sorted_array.sort(); // Ascending order
    }

    sorted_array
}

fn main() {
    // Test cases
    println!(""{:?}"", sort_array(vec![])); // Vec::<isize>::new()
    println!(""{:?}"", sort_array(vec![5])); // vec![5]
    println!(""{:?}"", sort_array(vec![2, 4, 3, 0, 1, 5])); // vec![0, 1, 2, 3, 4, 5]
    println!(""{:?}"", sort_array(vec![2, 4, 3, 0, 1, 5, 6])); // vec![6, 5, 4, 3, 2, 1, 0]
}","}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5]), vec![5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);
    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);
    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);
    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);
}
"
HumanEval_89,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⵙⵙⵉⴼⵜ ⵙ ⵙⵉⵏ ⵙ ⵙⵏⴰⵜ ⵜⴷⴰⵍⵉⵡⵉⵏ. /// ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵏⵙⵙⵏⴼⵍ ⴰⴱⵢⵢⵢⵉ ⵙ ⵢⴰⵜ ⵜⵖⴰⵔⴰⵙⵜ ⵏⵏⴰ ⵔⴰⴷ ⵔⴰⵔⵏⵜ ⵜⵓⵍⵍⵉⵙⵉⵏ /// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵉⵜⵜⵓⵣⵎⵎⴻⵎⵏ ⵙ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⴼⵉⵏⴰⵖ. /// ⵙⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏ ⵓⵙⵉⴳⴳⵍ ⵏⵏⴰ ⵉⵙⴽⴰⵔⵏ ⴰⵙⴽⴽⵉⵍ ⴰⵎⵎ ⵓⵎⵏⵣⴰⵖ ⴷ /// >>> encrypt(String::from(""hi""))
/// String::from(""lm"")
/// >>> encrypt(String::from(""asdfghjkl""))
/// String::from(""ewhjklnop"")
/// >>> encrypt(String::from(""gf""))
/// String::from(""kj"")
/// >>> encrypt(String::from(""et""))
/// String::from(""ix"")
fn encrypt(s: String) -> String {
","fn encrypt(s: String) -> String {
    s.chars()
        .map(|c| {
            if c.is_ascii_lowercase() {
                let offset = (c as u8 - b'a' + 4) % 26;
                (b'a' + offset) as char
            } else {
                c
            }
        })
        .collect()
}","}

fn main() {
    let candidate = encrypt;
    assert_eq!(candidate(String::from(""hi"")), String::from(""lm""));
    assert_eq!(candidate(String::from(""asdfghjkl"")), String::from(""ewhjklnop""));
    assert_eq!(candidate(String::from(""gf"")), String::from(""kj""));
    assert_eq!(candidate(String::from(""et"")), String::from(""ix""));
    assert_eq!(candidate(String::from(""faewfawefaewg"")), String::from(""jeiajeaijeiak""));
    assert_eq!(candidate(String::from(""hellomyfriend"")), String::from(""lippsqcjvmirh""));
    assert_eq!(candidate(String::from(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")), String::from(""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""));
    assert_eq!(candidate(String::from(""a"")), String::from(""e""));
}
"
HumanEval_90,tzm_Tfng,rs,"/// ⵓⵔ ⴷⴰ ⵉⵜⵜⵓⴽⴽⴰ ⴽⵔⴰ ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵓⵏⴰⵡ ⴰⴷ. /// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ next_smallest (() ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴽⴽⵍⵜ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⴳ ⵉⵎⵥⵥⵢⴰⵏⵏ ⵏ ⵓⵡⵉⴽⵜⵓⵔ. /// ⴰⵖ ⴷ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. /// >>> next_smallest(vec![1, 2, 3, 4, 5])
/// Some(2)
/// >>> next_smallest(vec![5, 1, 4, 3, 2])
/// Some(2)
/// >>> next_smallest(vec![])
/// None
/// >>> next_smallest(vec![1, 1])
/// None
fn next_smallest(lst: Vec<isize>) -> Option<isize> {
","fn next_smallest(lst: Vec<isize>) -> Option<isize> {
    if lst.len() < 2 {
        return None;
    }
    let mut unique_elements: Vec<isize> = lst.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect();
    if unique_elements.len() < 2 {
        return None;
    }
    unique_elements.sort();
    Some(unique_elements[1])
}

fn main() {
    println!(""{:?}"", next_smallest(vec![1, 2, 3, 4, 5])); // Some(2)
    println!(""{:?}"", next_smallest(vec![5, 1, 4, 3, 2])); // Some(2)
    println!(""{:?}"", next_smallest(vec![])); // None
    println!(""{:?}"", next_smallest(vec![1, 1])); // None
}","}

fn main() {
    let candidate = next_smallest;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));
    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));
}
"
HumanEval_91,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⴷⴰ ⵜⵜⵓⵙⴳⵣⵏ ⵜⵉⴳⵓⵔⵉⵡⵉⵏ ⵙ '.', '?' ⵏⵖ '!'. /// ⵏ ⵜⵔⴳⴰⵍⵉⵏ. ⵜⴰⵔⴳⴰⵍⵜ ⵜⴳⴰ ⵜⴰⴳⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵙ ⵜⴳⵓⵔⵉ ""ⵉ""./// ⴰⴷ ⴽⴽⵙⴷ ⴽⵔⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ, ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⴰⴷ ⵜⵙⵙⵉⴹⵏ ⴰⵎⴹⴰⵏ /// >>> is_bored(String::from(""Hello world""))
/// 0
/// >>> is_bored(String::from(""The sky is blue. The sun is shining. I love this weather""))
/// 1
fn is_bored(S: String) -> isize {
","fn is_bored(S: String) -> isize {
    S.split(|c| c == '.' || c == '?' || c == '!')
        .filter(|sentence| sentence.trim_start().starts_with(""I""))
        .count() as isize
}","}

fn main() {
    let candidate = is_bored;
    assert_eq!(candidate(String::from(""Hello world"")), 0);
    assert_eq!(candidate(String::from(""Is the sky blue?"")), 0);
    assert_eq!(candidate(String::from(""I love It !"")), 1);
    assert_eq!(candidate(String::from(""bIt"")), 0);
    assert_eq!(candidate(String::from(""I feel good today. I will be productive. will kill It"")), 2);
    assert_eq!(candidate(String::from(""You and I are going for a walk"")), 0);
}
"
HumanEval_92,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ /// ⴰⵔ ⵉⵜⵜⵔ ⵜⵉⴼⵍⵡⵉⵜ ⴳ ⴽⵔⴰ ⵏ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏⵉⵏ. /// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵢⴰⵏ ⵙⴳ ⵉⵎⴹⴰⵏⵏ ⴰⵎⵎ ⵓⴳⵣⵓⵎ ⵏ ⵙⵉⵏ ⵢⴰⴹⵏⵉⵏ, ⴷ ⵎⴰⵕⵕⴰ ⵉⵎⴹⴰⵏⵏ ⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. /// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏ. /// >>> any_int(5, 2, 7)
/// true
/// >>> any_int(3, 2, 2)
/// false
/// >>> any_int(3, -2, 1)
/// true
/// >>> any_int(3.6, -2.2, 2)
/// false
fn any_int(x: f64, y: f64, z: f64) -> bool {
","fn any_int(x: f64, y: f64, z: f64) -> bool {
    // Check if all the numbers are integers
    if x.fract() == 0.0 && y.fract() == 0.0 && z.fract() == 0.0 {
        // Convert f64 to i64 because they are integers
        let xi = x as i64;
        let yi = y as i64;
        let zi = z as i64;

        // Check if any one of the numbers is equal to the sum of the other two
        xi == yi + zi || yi == xi + zi || zi == xi + yi
    } else {
        false
    }
}

fn main() {
    // Examples
    println!(""{}"", any_int(5.0, 2.0, 7.0)); // true
    println!(""{}"", any_int(3.0, 2.0, 2.0)); // false
    println!(""{}"", any_int(3.0, -2.0, 1.0)); // true
    println!(""{}"", any_int(3.6, -2.2, 2.0)); // false
}","}

fn main() {
    let candidate = any_int;
    assert_eq!(candidate(2.0, 3.0, 1.0), true);
    assert_eq!(candidate(2.5, 2.0, 3.0), false);
    assert_eq!(candidate(1.5, 5.0, 3.5), false);
    assert_eq!(candidate(2.0, 6.0, 2.0), false);
    assert_eq!(candidate(4.0, 2.0, 2.0), true);
    assert_eq!(candidate(2.2, 2.2, 2.2), false);
    assert_eq!(candidate(-4.0, 6.0, 2.0), true);
    assert_eq!(candidate(2.0, 1.0, 1.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), false);
}
"
HumanEval_93,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵙⵙⵓⵎⵔ ⴷⴰⵢ ⵉⵙⴽⴽⵉⵍⵏ. /// ⴰⵖⵔⵉ ⴳ ⵓⴳⵎⵎⴰⵢ ⴰⴱⵔⵍⴰⵎⴰⵏⵉ. /// ⵜⴰⴱⵔⴰⵜ ⵙ ⵜⴱⵔⴰⵜ ⵏⵏⴰ ⵢⴰⴷ ⵉⵍⵍⴰⵏ ⵙⵏⴰⵜ ⵜⴷⵖⴰⵔⵉⵏ ⴷⴰⵜ ⵏ ⵜⴱⵔⴰⵜ /// ⵙ ⵜⵖⴰⵔⴰⵙⵜ ⵏⵏⴰ ⵉⵙⵏⴼⵍⵏ ⵜⵉⴽⴽⵍⵜ ⵏ ⴽⵓⵍⵍⵓ ⵜⵉⵔⵔⴰ, ⵉⵙⵏⴼⵍ ⴽⵓⵍⵍⵓ ⵉⵎⵙⵍⵉ ⴳ /// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⴷ ⵉⵜⵜⵓⵢⵙⴽⵔ ⴳ /// >>> encode(String::from(""test""))
/// String::from(""TGST"")
/// >>> encode(String::from(""This is a message""))
/// String::from(""tHKS KS C MGSSCGG"")
fn encode(message: String) -> String {
","fn encode(message: String) -> String {
    message.chars().map(|c| {
        match c {
            'a' => 'C',
            'e' => 'G',
            'i' => 'K',
            'o' => 'Q',
            'u' => 'W',
            'A' => 'c',
            'E' => 'g',
            'I' => 'k',
            'O' => 'q',
            'U' => 'w',
            'a'..='z' => c.to_ascii_uppercase(),
            'A'..='Z' => c.to_ascii_lowercase(),
            _ => c,
        }
    }).collect()
}","}

fn main() {
    let candidate = encode;
    assert_eq!(candidate(String::from(""TEST"")), String::from(""tgst""));
    assert_eq!(candidate(String::from(""Mudasir"")), String::from(""mWDCSKR""));
    assert_eq!(candidate(String::from(""YES"")), String::from(""ygs""));
    assert_eq!(candidate(String::from(""This is a message"")), String::from(""tHKS KS C MGSSCGG""));
    assert_eq!(candidate(String::from(""I DoNt KnOw WhAt tO WrItE"")), String::from(""k dQnT kNqW wHcT Tq wRkTg""));
}
"
HumanEval_94,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⴰⴼⴷ ⴰⵜⵉⴳ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ ⴷ ⴰⴷ ⵜⵔⴰⵔⴷ ⵜⴰⴳⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ. /// ⴰⵖ ⴷ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. /// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])
/// 7
fn skjkasdkd(lst: Vec<isize>) -> isize {
","fn is_prime(n: isize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn digit_sum(n: isize) -> isize {
    n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum()
}

fn skjkasdkd(lst: Vec<isize>) -> isize {
    match lst.into_iter().filter(is_prime).max() {
        Some(max_prime) => digit_sum(max_prime),
        None => 0,
    }
}","}

fn main() {
    let candidate = skjkasdkd;
    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);
    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);
    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);
    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);
    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);
    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);
    assert_eq!(candidate(vec![8191]), 19);
    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);
    assert_eq!(candidate(vec![127, 97, 8192]), 10);
}
"
HumanEval_95,tzm_Tfng,rs,"use std::collections::HashMap;

/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵔⴰⵔ false ⵉⴳ ⴷⴰⵔⵙ HashMap ⵉⵍⵍⴰ. /// case ⵏⵖ ⴽⵓⵍⵍⵓ ⵜⵉⴼⵍⵓⵙⵉⵏ ⴳⴰⵏ ⵜⵉⴼⵍⵓⵙⵉⵏ ⴳ ⵜⵉⴼⵍⵓⵙⵉⵏ ⵜⵉⵎⵇⵔⴰⵏⵉⵏ, ⵎⴽⵍⵍⵉ ⵓⵔ ⵉⴳⵉ return false. /// ⴳ ⵓⴽⵓⴷ ⵏ HashMap, ⴰⵔ ⵏⵙⵙⴽⵛⵎ true ⵎⴽ ⴷⴰ ⴳⴰⵏ ⴽⵓⵍⵍⵓ ⵜⵉⵔⵙⴰⵍ ⵜⵉⵙⵉⴹⴼⴰⵏⵉⵏ ⴳ ⵍⵉⵙⵜⵔⵉⵏ /// >>> check_dict_case(HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""b""), String::from(""banana""))]))
/// true
/// >>> check_dict_case(HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""A""), String::from(""banana"")), (String::from(""B""), String::from(""banana""))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from(""a""), String::from(""apple"")), (8, String::from(""banana"")), (String::from(""a""), String::from(""apple""))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from(""Name""), String::from(""John"")), (String::from(""Age""), String::from(""36"")), (String::from(""City""), String::from(""Houston""))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from(""STATE""), String::from(""NC"")), (String::from(""ZIP""), String::from(""12345""))]))
/// true
fn check_dict_case(dict: HashMap<String, String>) -> bool {
","use std::collections::HashMap;

fn check_dict_case(dict: HashMap<String, String>) -> bool {
    if dict.is_empty() {
        return false;
    }

    let mut lowercase = true;
    let mut uppercase = true;

    for key in dict.keys() {
        if !key.chars().all(|c| c.is_lowercase()) {
            lowercase = false;
        }
        if !key.chars().all(|c| c.is_uppercase()) {
            uppercase = false;
        }
    }

    lowercase || uppercase
}

fn main() {
    let dict1 = HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""b""), String::from(""banana""))]);
    assert_eq!(check_dict_case(dict1), true);

    let dict2 = HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""A""), String::from(""banana"")), (String::from(""B""), String::from(""banana""))]);
    assert_eq!(check_dict_case(dict2), false);

    let dict3 = HashMap::from([(String::from(""STATE""), String::from(""NC"")), (String::from(""ZIP""), String::from(""12345""))]);
    assert_eq!(check_dict_case(dict3), true);

    let dict4 = HashMap::from([(String::from(""Name""), String::from(""John"")), (String::from(""Age""), String::from(""36"")), (String::from(""City""), String::from(""Houston""))]);
    assert_eq!(check_dict_case(dict4), false);
}","}

fn main() {
    let candidate = check_dict_case;
    assert_eq!(candidate(HashMap::from([(String::from(""p""), String::from(""pineapple"")), (String::from(""b""), String::from(""banana""))])), true);
    assert_eq!(candidate(HashMap::from([(String::from(""p""), String::from(""pineapple"")), (String::from(""A""), String::from(""banana"")), (String::from(""B""), String::from(""banana""))])), false);
    assert_eq!(candidate(HashMap::from([(String::from(""p""), String::from(""pineapple"")), (String::from(""5""), String::from(""banana"")), (String::from(""a""), String::from(""apple""))])), false);
    assert_eq!(candidate(HashMap::from([(String::from(""Name""), String::from(""John"")), (String::from(""Age""), String::from(""36"")), (String::from(""City""), String::from(""Houston""))])), false);
    assert_eq!(candidate(HashMap::from([(String::from(""STATE""), String::from(""NC"")), (String::from(""ZIP""), String::from(""12345""))])), true);
    assert_eq!(candidate(HashMap::from([(String::from(""fruit""), String::from(""Orange"")), (String::from(""taste""), String::from(""Sweet""))])), true);
    assert_eq!(candidate(HashMap::from([])), false);
}
"
HumanEval_96,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴷ ⵉⵎⵥⵥⵉⵏ ⵙⴳ n. /// ⵙⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⵔⵉⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ n ⴰⵎⵣⵡⴰⵔⵓ /// >>> count_up_to(5)
/// vec![2, 3]
/// >>> count_up_to(11)
/// vec![2, 3, 5, 7]
/// >>> count_up_to(0)
/// Vec::<isize>::new()
/// >>> count_up_to(20)
/// vec![2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(1)
/// Vec::<isize>::new()
/// >>> count_up_to(18)
/// vec![2, 3, 5, 7, 11, 13, 17]
fn count_up_to(n: isize) -> Vec<isize> {
","fn count_up_to(n: isize) -> Vec<isize> {
    let mut primes = Vec::new();

    for num in 2..n {
        let mut is_prime = true;

        for divisor in 2..=((num as f64).sqrt() as isize) {
            if num % divisor == 0 {
                is_prime = false;
                break;
            }
        }

        if is_prime {
            primes.push(num);
        }
    }

    primes
}

fn main() {
    println!(""{:?}"", count_up_to(5)); // vec![2, 3]
    println!(""{:?}"", count_up_to(11)); // vec![2, 3, 5, 7]
    println!(""{:?}"", count_up_to(0)); // Vec::<isize>::new()
    println!(""{:?}"", count_up_to(20)); // vec![2, 3, 5, 7, 11, 13, 17, 19]
    println!(""{:?}"", count_up_to(1)); // Vec::<isize>::new()
    println!(""{:?}"", count_up_to(18)); // vec![2, 3, 5, 7, 11, 13, 17]
}","}

fn main() {
    let candidate = count_up_to;
    assert_eq!(candidate(5), vec![2, 3]);
    assert_eq!(candidate(6), vec![2, 3, 5]);
    assert_eq!(candidate(7), vec![2, 3, 5]);
    assert_eq!(candidate(10), vec![2, 3, 5, 7]);
    assert_eq!(candidate(0), Vec::<isize>::new());
    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);
    assert_eq!(candidate(1), Vec::<isize>::new());
    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}
"
HumanEval_97,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵙⵙⵓⵎⵔ ⴰⵙⴽⵛⵎ ⴰⵀⴰ ⵉⴳⴰ ⵡⴰⵍⵍⵉ ⵉⵇⵇⴰⵏ. /// ⴰⵖⴰⵔⴰⵙ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴰⴳⵣⵣⵓⵎⵜ ⵏⵏⵙⵏ. /// ⵙⵎⵓⵜⵜⴳ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⴰⵔ ⵉⵜⵜⵔ /// >>> multiply(148, 412)
/// 16
/// >>> multiply(19, 28)
/// 72
/// >>> multiply(2020, 1851)
/// 0
/// >>> multiply(14, -15)
/// 20
fn multiply(a: isize, b: isize) -> isize {
","fn multiply(a: isize, b: isize) -> isize {
    let unit_digit_a = (a % 10).abs();
    let unit_digit_b = (b % 10).abs();
    unit_digit_a * unit_digit_b
}","}

fn main() {
    let candidate = multiply;
    assert_eq!(candidate(148, 412), 16);
    assert_eq!(candidate(19, 28), 72);
    assert_eq!(candidate(2020, 1851), 0);
    assert_eq!(candidate(14, -15), 20);
    assert_eq!(candidate(76, 67), 42);
    assert_eq!(candidate(17, 27), 49);
    assert_eq!(candidate(0, 1), 0);
    assert_eq!(candidate(0, 0), 0);
}
"
HumanEval_98,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⵙ ⵓⴽⵓⴷ ⵏ ⵜⵉⴼⵉⵏⴰⵖ s, ⵙⵉⴹⵏ ⴰⵎⴹⴰⵏ ⵏ ⵉⵎⵙⵍⵉⵢⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴳ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵎⵓⵟⵟⵓⵏⵏ. /// >>> count_upper(String::from(""aBCdEf""))
/// 1
/// >>> count_upper(String::from(""abcdefg""))
/// 0
/// >>> count_upper(String::from(""dBBE""))
/// 0
fn count_upper(s: String) -> isize {
","fn count_upper(s: String) -> isize {
    s.chars().enumerate().filter(|(i, c)| {
        *i % 2 == 0 && matches!(c, 'A' | 'E' | 'I' | 'O' | 'U')
    }).count() as isize
}","}

fn main() {
    let candidate = count_upper;
    assert_eq!(candidate(String::from(""aBCdEf"")), 1);
    assert_eq!(candidate(String::from(""abcdefg"")), 0);
    assert_eq!(candidate(String::from(""dBBE"")), 0);
    assert_eq!(candidate(String::from(""B"")), 0);
    assert_eq!(candidate(String::from(""U"")), 1);
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""EEEE"")), 2);
}
"
HumanEval_99,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ /// ⵙⴳ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴷⵓⵏ-ⵜ ⵙⴳ ⵓⵎⵢⴰ. /// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⴽⴽⵡ ⵉⵎⵉⵣⴰⵔ ⵏⵏⵙ. ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⴷ ⴰⵎⴹⴰⵏ ⵉⵎⵉⵣⴰⵔ ⵏⵏⵙ /// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵡⴰⵜⵉⴳ (ⵜⴰⵏⴳⴰⵍⵜ) ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵏ ⵓⵟⵟⵓⵏ /// >>> closest_integer(String::from(""10""))
/// 10
/// >>> closest_integer(String::from(""15.3""))
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer(""14.5"") should
/// return 15 and closest_integer(""-14.5"") should return -15.
fn closest_integer(value: String) -> isize {
","fn closest_integer(value: String) -> isize {
    let num: f64 = value.parse().expect(""Invalid number format"");
    if num.fract().abs() == 0.5 {
        if num.is_sign_positive() {
            num.ceil() as isize
        } else {
            num.floor() as isize
        }
    } else {
        num.round() as isize
    }
}

// Example usage
fn main() {
    println!(""{}"", closest_integer(String::from(""10"")));   // Output: 10
    println!(""{}"", closest_integer(String::from(""15.3""))); // Output: 15
    println!(""{}"", closest_integer(String::from(""14.5""))); // Output: 15
    println!(""{}"", closest_integer(String::from(""-14.5""))); // Output: -15
}","}

fn main() {
    let candidate = closest_integer;
    assert_eq!(candidate(String::from(""10"")), 10);
    assert_eq!(candidate(String::from(""14.5"")), 15);
    assert_eq!(candidate(String::from(""-15.5"")), -16);
    assert_eq!(candidate(String::from(""15.3"")), 15);
    assert_eq!(candidate(String::from(""0"")), 0);
}
"
HumanEval_100,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// i ⴷⴰ ⵉⵙⵎⴷⵢⴰ ⵓⵟⵟⵓⵏ ⵏ ⵉⵔⵖⴰⵏ ⴳ ⵓⵙⵡⵉⵔ (i+1). /// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵓⵟⵟⵓⵏ ⵏ ⵉⵊⴷⴷⵉⴳⵏ ⴳ ⴽⵓ ⴰⵙⵡⵉⵔ ⴳ ⵢⴰⵏ ⵓⴽⵜⵓⵔ, ⴳ ⵉⵍⵍⴰ ⵓⵏⴰⵎⴽ ⴳ ⵓⵙⵏⵎⵍ /// - ⴰⵎⴹⴰⵏ ⴰⵎⵎⵓⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵉⴳ n ⵉⴳⴰ ⴰⵎⵎⵓⴹⴰⵏ. /// - ⴰⵎⴹⴰⵏ ⴰⵎⵢⵉⵡⵏ ⴰⴹⵏⵉⵏ ⵎⴽ n ⵉⴳⴰ ⴰⵎⵢⵉⵡⵏ. /// ⴰⵎⴹⴰⵏ ⵏ ⵉⵔⵖⴰⵏ ⴳ ⵓⵙⵡⵉⵔ ⵢⴰⴹⵏ ⵉⴳⴰ ⵜ: /// ⴰⵙⵡⵉⵔ ⴰⵎⵣⵡⴰⵔⵓ ⴷⴰⵔⵙ n ⵉⵔⵖⴰⵏ. /// ⴰⵛⴽⵓ ⵏⵜⵜⴰⵜ ⴷ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ n, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔⵎ ⵢⴰⵜ ⵜⵔⴱⴰⵜ ⵏ n ⵉⵙⵡⵉⵔⵏ ⵏ ⵉⵔⵖⴰⵏ. /// >>> make_a_pile(3)
/// vec![3, 5, 7]
fn make_a_pile(n: isize) -> Vec<isize> {
","fn make_a_pile(n: isize) -> Vec<isize> {
    let mut pile = Vec::new();
    let mut current = n;
    
    for _ in 0..n {
        pile.push(current);
        current = if n % 2 == 1 {
            current + 2
        } else {
            current + 2
        };
    }
    
    pile
}

fn main() {
    let level = make_a_pile(3);
    println!(""{:?}"", level);
}","}

fn main() {
    let candidate = make_a_pile;
    assert_eq!(candidate(3), vec![3, 5, 7]);
    assert_eq!(candidate(4), vec![4, 6, 8, 10]);
    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);
    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);
    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);
}
"
HumanEval_101,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⴰⴷ ⵏⴱⴹⵓ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴼ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⴰⴷ ⵏⵔⴰⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ. /// ⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵜ ⵜⵍⴳⴰⵎⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⴱⴹⴰⵏ ⵙ ⵜⴽⵓⵎⵉⵏ ⵏⵖ ⴷ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ /// >>> words_string(String::from(""Hi, my name is John""))
/// vec![String::from(""Hi""), String::from(""my""), String::from(""name""), String::from(""is""), String::from(""John"")]
/// >>> words_string(String::from(""One, two, three, four, five, six""))
/// vec![String::from(""One""), String::from(""two""), String::from(""three""), String::from(""four""), String::from(""five""), String::from(""six"")]
fn words_string(s: String) -> Vec<String> {
","fn words_string(s: String) -> Vec<String> {
    s.split(|c: char| c.is_whitespace() || c == ',')
        .filter(|word| !word.is_empty())
        .map(String::from)
        .collect()
}","}

fn main() {
    let candidate = words_string;
    assert_eq!(candidate(String::from(""Hi, my name is John"")), vec![String::from(""Hi""), String::from(""my""), String::from(""name""), String::from(""is""), String::from(""John"")]);
    assert_eq!(candidate(String::from(""One, two, three, four, five, six"")), vec![String::from(""One""), String::from(""two""), String::from(""three""), String::from(""four""), String::from(""five""), String::from(""six"")]);
    assert_eq!(candidate(String::from(""Hi, my name"")), vec![String::from(""Hi""), String::from(""my""), String::from(""name"")]);
    assert_eq!(candidate(String::from(""One,, two, three, four, five, six,"")), vec![String::from(""One""), String::from(""two""), String::from(""three""), String::from(""four""), String::from(""five""), String::from(""six"")]);
    assert_eq!(candidate(String::from("""")), Vec::<String>::new());
    assert_eq!(candidate(String::from(""ahmed     , gamal"")), vec![String::from(""ahmed""), String::from(""gamal"")]);
}
"
HumanEval_102,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⵓⵔ ⵉⵍⵍⵉ ⵡⵓⵟⵟⵓⵏ ⴰⴷ, ⵔⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ -1./// ⴰⵎⴹⴰⵏ ⴰⵎⵇⵇⵔⴰⵏ ⴰⵎⴷⴷⵓⴽⴽⵍ ⴳ ⵓⵙⵏⴼⵍ [x, y] ⴳ ⵜⵓⵎⵣⵉⵏ. ⵎⴽ /// ⴷⴰ ⵜⵙⵙⵓⵎⵓⵔ ⵜⵎⵔⵙⵍⵜ ⴰⴷ ⵙⵉⵏ ⵉⵎⴹⴰⵏⵏ ⵉⴽⵙⵡⴰⵜⵏ x ⴷ y ⴰⵔ ⵜⵔⴰⵔ /// >>> choose_num(12, 15)
/// 14
/// >>> choose_num(13, 12)
/// -1
fn choose_num(x: isize, y: isize) -> isize {
","fn choose_num(x: isize, y: isize) -> isize {
    let (start, end) = if x < y { (x, y) } else { (y, x) };
    for n in (start..=end).rev() {
        if n % 2 == 0 {
            return n;
        }
    }
    -1
}

fn main() {
    println!(""{}"", choose_num(12, 15)); // 14
    println!(""{}"", choose_num(13, 12)); // -1
}","}

fn main() {
    let candidate = choose_num;
    assert_eq!(candidate(12, 15), 14);
    assert_eq!(candidate(13, 12), -1);
    assert_eq!(candidate(33, 12354), 12354);
    assert_eq!(candidate(5234, 5233), -1);
    assert_eq!(candidate(6, 29), 28);
    assert_eq!(candidate(27, 10), -1);
    assert_eq!(candidate(7, 7), -1);
    assert_eq!(candidate(546, 546), 546);
}
"
HumanEval_104,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⵜⴰⵏⵏⴰⵢⵜ: ⵉⵇⵇⴰⵏ ⴰⴷ ⵏⵙⵎⵓⵏ ⵉⵎⵙⵙⵓⴷⵙⵏ ⵉⵜⵜⵓⵣⵎⵎⴻⵎⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵔⵏⵉⵡ./// ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵓⵟⵟⵓⵏ ⴰⵡⴷ ⵢⴰⵏ. /// ⴰⵛⴽⵓ ⵏⵙⴽⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⴷⵉⵢⵏ x. ⵏⵙⴽⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵏ ⴽⵓⵍⵍⵓ /// >>> unique_digits(vec![15, 33, 1422, 1])
/// vec![1, 15, 33]
/// >>> unique_digits(vec![152, 323, 1422, 10])
/// Vec::<isize>::new()
fn unique_digits(x: Vec<isize>) -> Vec<isize> {
","fn unique_digits(x: Vec<isize>) -> Vec<isize> {
    let mut result: Vec<isize> = x.into_iter()
        .filter(|&num| {
            num.to_string().chars().all(|c| {
                match c {
                    '0' | '2' | '4' | '6' | '8' => false,
                    _ => true,
                }
            })
        })
        .collect();
    result.sort();
    result
}","}

fn main() {
    let candidate = unique_digits;
    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);
    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());
    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);
    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);
}
"
HumanEval_105,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ""ⵢⵉⵡⵏ"", "" ⵙⵉⵏ"", "" ⴽⵕⴰⴹ"", "" ⴽⴽⵓⵥ"", "" ⵙⵎⵎⵓⵙ"", "" ⵙⴹⵉⵙ"", "" ⵙⴰ"", "" ⵜⴰⵎ"", "" ⵜⵥⴰ"". /// ⵏⵙⵙⵏⴼⵍ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⵢⴰⴼⵓⵜ, ⴷ ⵏⵙⵎⵓⵜⵜⴳ ⴽⵓ ⵓⵟⵟⵓⵏ ⵙ ⵉⵙⵎ ⵏⵏⵙ ⵙⴳ /// ⵙ ⵓⵙⵙⴽⵏ ⵏ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴷⵙ ⵉⵎⴹⴰⵏⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵍⵍⴰⵏ ⴳⵔ 1 ⴷ 9 ⴳ ⵜⴰⵎⵎ ⵏⵙⵏ, /// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])
/// vec![String::from(""Eight""), String::from(""Five""), String::from(""Four""), String::from(""Three""), String::from(""Two""), String::from(""Two""), String::from(""One""), String::from(""One"")]
/// If the vector is empty, return an empty vector:
/// >>> by_length(vec![])
/// Vec::<String>::new()
/// If the vector has any strange number ignore it:
/// >>> by_length(vec![1, -1, 55])
/// vec![String::from(""One"")]
fn by_length(arr: Vec<isize>) -> Vec<String> {
","fn by_length(arr: Vec<isize>) -> Vec<String> {
    let digit_names = [
        ""One"", ""Two"", ""Three"", ""Four"", ""Five"", 
        ""Six"", ""Seven"", ""Eight"", ""Nine"",
    ];

    let mut filtered: Vec<isize> = arr.into_iter()
        .filter(|&x| x >= 1 && x <= 9)
        .collect();

    filtered.sort();
    filtered.reverse();

    filtered.into_iter()
        .map(|x| String::from(digit_names[(x - 1) as usize]))
        .collect()
}","}

fn main() {
    let candidate = by_length;
    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(""Eight""), String::from(""Five""), String::from(""Four""), String::from(""Three""), String::from(""Two""), String::from(""Two""), String::from(""One""), String::from(""One"")]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(""One"")]);
    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(""Three""), String::from(""Two""), String::from(""One"")]);
    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(""Nine""), String::from(""Eight""), String::from(""Four"")]);
}
"
HumanEval_106,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// ⵉⴳⴰ ⵓⴼⴰⴽⵜⵓⵔⵢⴰⵍ ⵏ i ⴰⵙⴼⵓⴽⵍⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ 1 ⴰⵔ i (1 * 2 * ... * i). /// ⵔⴰⴷ ⵉⴱⴷⵓ ⵙⴳ 1. /// ⵏⵖ ⴷ ⵓⴳⵎⵎⴰⵢ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵙⴳ 1 ⴰⵔ i ⵎⴽ ⵓⵔ ⵢⴰⴷ ⵉⴳⵉ. /// ⴷ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⵉⴷⴷⵉ n, ⵣⵓⵏⴷ ⴰⵜⵉⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵙⵖⵍ ⵏ i ⵉⴳⴰ ⵜⴰⴳⴳⴰⵢⵜ ⵏ i ⵎⴽ ⵜⴳⴰ i ⴰⵡⴷ /// ⵙⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ f ⵏⵏⴰ ⵢⵓⵎⵥⵏ n ⴰⵎⵎ ⵓⵎⵙⴽⴰⵔ, /// >>> f(5)
/// vec![1, 2, 6, 24, 15]
fn f(n: isize) -> Vec<isize> {
","fn f(n: isize) -> Vec<isize> {
    fn factorial(x: isize) -> isize {
        (1..=x).product()
    }

    fn sum_up_to(x: isize) -> isize {
        (1..=x).sum()
    }

    (1..=n)
        .map(|i| if i % 2 == 0 { factorial(i) } else { sum_up_to(i) })
        .collect()
}","}

fn main() {
    let candidate = f;
    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);
    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);
    assert_eq!(candidate(1), vec![1]);
    assert_eq!(candidate(3), vec![1, 2, 6]);
}
"
HumanEval_107,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ 1: /// ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⴳ ⴳⴰⵏ ⴳ ⵓⵎⵏⵉⴷ ((1, n), ⵙ ⵓⴽⵛⵛⵓⵎ. /// ⵙ ⵓⴹⴼⵓⵕ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ n, ⵙⴽⵔ ⵜⴰⵡⴰⵍⵜ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵉⴹⵏ ⵉⵎⵎⵔⵉⵏⵏ ⴷ ⵉⵎⵣⴰⵔⴰⵢⵏⵏ /// >>> even_odd_palindrome(3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
fn even_odd_palindrome(n: isize) -> (isize, isize) {
","fn is_palindrome(x: isize) -> bool {
    let s = x.to_string();
    s == s.chars().rev().collect::<String>()
}

fn even_odd_palindrome(n: isize) -> (isize, isize) {
    let mut even_count = 0;
    let mut odd_count = 0;
    
    for i in 1..=n {
        if is_palindrome(i) {
            if i % 2 == 0 {
                even_count += 1;
            } else {
                odd_count += 1;
            }
        }
    }
    
    (even_count, odd_count)
}","}

fn main() {
    let candidate = even_odd_palindrome;
    assert_eq!(candidate(123), (8, 13));
    assert_eq!(candidate(12), (4, 6));
    assert_eq!(candidate(3), (1, 2));
    assert_eq!(candidate(63), (6, 8));
    assert_eq!(candidate(25), (5, 6));
    assert_eq!(candidate(19), (4, 6));
    assert_eq!(candidate(9), (4, 5));
    assert_eq!(candidate(1), (0, 1));
}
"
HumanEval_108,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ -123 ⵖⵓⵔⵙ ⵉⵎⵉⴹⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ -1, 2, ⴷ 3. /// ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⵎⴳⵓⵔⴰⵏ, ⵔⴰⴷ ⵉⴳ ⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵏ ⵜⵍⴳⴰⵎⵜ ⵏⵏⵙ ⴰⵎⴳⵓⵔⴰⵏ: /// ⴰⵎⴹⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ > 0. /// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ count_nums ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⴰⵔ ⵉⵜⵜⵔ /// >>> count_nums(vec![])
/// 0
/// >>> count_nums(vec![-1, 11, -11])
/// 1
/// >>> count_nums(vec![1, 1, 2])
/// 3
fn count_nums(arr: Vec<isize>) -> isize {
","fn count_nums(arr: Vec<isize>) -> isize {
    arr.into_iter()
        .filter(|&num| {
            let mut n = num;
            let mut sum = 0;
            let mut is_first_digit = true;

            while n != 0 {
                let digit = if is_first_digit {
                    is_first_digit = false;
                    n % 10
                } else {
                    (n % 10).abs()
                };
                sum += digit;
                n /= 10;
            }
            sum > 0
        })
        .count() as isize
}","}

fn main() {
    let candidate = count_nums;
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![-1, -2, 0]), 0);
    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);
    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);
    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);
    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);
    assert_eq!(candidate(vec![0, 1]), 1);
    assert_eq!(candidate(vec![1]), 1);
}
"
HumanEval_109,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⵜⴰⵏⵏⴰⵢⵜ: ⴰⵙⴽⴽⵉⵍ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ ⵔⴰⴷ ⵢⵉⵍⵉ ⵖⵓⵔⵙ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⵉⵡⴰⵏⵏ./// ⵎⴽ ⵉⴳⴰ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵉⵍⵍⴰ, ⵔⴰⴷ ⵏⵔⴰⵔ ⵜⵉⴷⵜ./// ⴰⴷ ⵏⴰⵔⵉ true ⵎⴽⵍⵍⵉ ⵏⴰⵔⵉ false. /// ⵎⴽ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⴰⵡⵉ ⵜⴱⵔⵉⴷⵜ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵙ ⵜⵎⵙⴽⵔⵜ ⵏ ⴰⴼⵍⵍⴰ /// ⴰⴷⵖⴰⵔ ⵏ ⵓⵣⵡⵓ ⴳ ⵓⴱⴰⵢⵢⵓⵕ, ⴰ'ⵏⵏⴰ ⵉⴳⴰⵏ ⴰⵏⵎⵎⴰⵍ ⵡⵉⵙⵙ 0./// ⴰⴷⵖⴰⵔ ⴳ ⵓⴱⵔⵉⴷ ⵏ ⵓⵣⵔⴼ. ⵔⴰⴷ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⵓ ⵓⵏⴰⵡ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵓⵡⵉⴽⵜⵓⵔ /// ⵢⴰⵏ ⵓⵙⵙⵉⴼ ⵏ ⵓⵣⵔⴼ ⴰⵎⵎⴰⵍ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵙ ⵢⴰⵏ /// ⴰⴷ ⵜⵙⵙⴽⵔⴷ ⵜⵉⵡⵓⵔⵉⵡⵉⵏ ⵏ ⵓⵙⵏⴼⵍ ⵙ ⵓⵣⵔⴼ ⴽⵉⴳⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ. /// ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵅⴼ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⵢⴰⴽⴽⴰⵏ: /// ⵏⵣⵎⵔ ⴰⴷ ⵏⵙⵎⵓⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵙ ⵓⴱⵔⵉⴷ ⵓⵔ ⵢⴰⴽⴽⴰⵏ ⴰⵙⵏⴼⵍ ⵙ ⵜⵣⵎⵎⴰⵔ ⵏ ⵓⵙⴽⴰⵔ ⵏ /// ⵔⴰⴷ ⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ ⵡⵓⵟⵟⵓⵏ ⴳ ⵓⴱⵉⴽⵜⵓⵔ ⵙ ⵜⴱⵔⵉⴷⵜ ⵏ ⵓⵙⴽⵙⵍ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⵎ ⵎⴰ ⵔⴰⴷ ⵔⵡⵍⵏ ⴹⴰⵕⵜ ⵓⴱⵉⴽⵜⵓⵔ./// ⵏⵍⵍⴰ ⴷⴰⵔⵙ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ 'ⴰⵔⵔ' ⵏ N ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ arr[1], arr[2], ..., arr[N]./// >>> move_one_ball(vec![3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given vector.
/// >>> move_one_ball(vec![3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// vector by performing any number of right shift operations.
fn move_one_ball(arr: Vec<isize>) -> bool {
","fn move_one_ball(arr: Vec<isize>) -> bool {
    if arr.is_empty() {
        return true; // An empty array is already considered sorted.
    }
    
    let mut break_point = 0;
    let mut break_found = false;
    let len = arr.len();

    for i in 0..len {
        if arr[i] > arr[(i + 1) % len] {
            if break_found {
                return false;  // Found more than one break point, not possible.
            }
            break_point = i + 1;
            break_found = true;
        }
    }
    
    // After finding a single break point, simulate the right shift by 'break_point'
    for i in 0..len {
        if arr[(break_point + i) % len] > arr[(break_point + i + 1) % len] {
            return false; // Not sorted in non-decreasing order with this shift.
        }
    }
    
    true
}

// Example usages:

// This will return true, as we can shift twice to sort it.
assert_eq!(move_one_ball(vec![3, 4, 5, 1, 2]), true);

// This will return false, as we can't sort this by any number of shifts.
assert_eq!(move_one_ball(vec![3, 5, 4, 1, 2]), false);","}

fn main() {
    let candidate = move_one_ball;
    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);
    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);
    assert_eq!(candidate(vec![4, 3, 1, 2]), false);
    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
}
"
HumanEval_110,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⵙ ⵡⴰⵏⴰⵡ ⵏⵏⵉⴹⵏ, ⵙⵓⵍ ""ⵓⵅⴰ"". /// ⴰⴷ ⴳⵉⵏ ⴰⴽⴽⵡ ⵉⴼⵔⴷⵉⵙⵏ ⵏ lst1 ⵉⵎⵎⵔⵡⴰⵙⵏ, ⵙⵙⵓⴼⵖ ""YES"". /// ⵉⵖ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵏⴼⵍⴷ ⵉⴼⵔⴷⵉⵙⵏ ⴳⵔ lst1 ⴷ lst2 ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⴽⵔⴷ /// ⵓⵔ ⵉⵍⵍⵉ ⵓⵡⵜⵜⵓ ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴳⵔ lst1 ⴷ lst2. /// ⴳⵔⵙⵏ ⵃⵎⴰ ⴰⴷ ⵉⴳ lst1 ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵎⵔⴽⵙⵏ ⵅⴰⵙ./// ⴷ ⴰⵔ ⵉⵜⵜⵉⵔⵉ ⵎⴰⵙⴷ ⵉⵖⵉⵢ ⴰⴷ ⵉⵙⴽⵔ ⵢⴰⵏ ⵓⵙⵏⴼⵍ ⵏ ⵉⴼⵔⴷⵉⵙⵏ /// ⴳ ⵜⵎⵙⴰⵔⵜ ⴰⴷ, ⵔⴰⴷ ⵜⵙⵙⴽⵔⵎ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵏ ⵡⵓⵟⵟⵓⵏ, /// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])
/// String::from(""YES"")
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])
/// String::from(""NO"")
/// It is assumed that the input vectors will be non-empty.
fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {
","fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {
    let mut even_in_lst2 = false;
    for &num in &lst2 {
        if num % 2 == 0 {
            even_in_lst2 = true;
            break;
        }
    }

    if even_in_lst2 {
        for &num in &lst1 {
            if num % 2 != 0 {
                return String::from(""YES"");
            }
        }
        return String::from(""YES"");
    }

    String::from(""NO"")
}

fn main() {
    // Example cases
    println!(""{}"", exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])); // ""YES""
    println!(""{}"", exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])); // ""NO""
}","}

fn main() {
    let candidate = exchange;
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(""YES""));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(""NO""));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(""YES""));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(""YES""));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(""NO""));
    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(""NO""));
    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from(""YES""));
}
"
HumanEval_111,tzm_Tfng,rs,"use std::collections::HashMap;

/// ⴰⵎⴷⵢⴰ: /// ⵎⴽ ⴷⴰⵔ ⴽⵉⴳⴰⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵢⴰⵏ ⵡⴰⴷⴷⴰⴷ, ⵙⵙⵓⴼⵖ-ⵜ ⴽⵓⵍⵍⵓ. /// ⵏ ⵜⴱⵔⴰⵜ ⵏⵏⴰ ⴳ ⵢⵓⴳⴳⴰⵔ ⵓⵙⴽⴽⵉⵍ ⴷ ⵉⵍⵍⴰ ⴳⵉⵙ ⵓⵟⵟⵓⵏ ⵏ ⵜⴱⵔⴰⵜⵉⵏ ⵏⵏⴰ ⴷ ⵢⵓⴳⴳⴰⵔ. /// ⵙ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵉⵔⵔⴰ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏ ⵜⵉⵔⵔⴰ ⵜⵉⵎⵥⵢⴰⵏⵉⵏ ⵉⵜⵜⵓⵢⵙⴱⴹⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ, ⵙⵙⵓⴼⵖ ⵜⴰⴽⴰⵕⴹⴰ ⵏ ⵓⴱⵟⵟⵓ /// >>> histogram(String::from(""a b c""))
/// HashMap::from([(String::from(""a""), 1), (String::from(""b""), 1), (String::from(""c""), 1)])
/// >>> histogram(String::from(""a b b a""))
/// HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])
/// >>> histogram(String::from(""a b c a b""))
/// HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])
/// >>> histogram(String::from(""b b b b a""))
/// HashMap::from([(String::from(""b""), 4)])
/// >>> histogram(String::from(""""))
/// HashMap::from([])
fn histogram(test: String) -> HashMap<String, isize> {
","use std::collections::HashMap;

fn histogram(test: String) -> HashMap<String, isize> {
    let mut counts: HashMap<String, isize> = HashMap::new();
    let mut max_count = 0;

    for letter in test.split_whitespace() {
        let count = counts.entry(letter.to_string()).or_insert(0);
        *count += 1;
        if *count > max_count {
            max_count = *count;
        }
    }

    counts.retain(|_, &mut val| val == max_count);
    counts
}

fn main() {
    let result = histogram(String::from(""a b c""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""a""), 1), (String::from(""b""), 1), (String::from(""c""), 1)])

    let result = histogram(String::from(""a b b a""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])

    let result = histogram(String::from(""a b c a b""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])

    let result = histogram(String::from(""b b b b a""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""b""), 4)])

    let result = histogram(String::from(""""));
    println!(""{:?}"", result); // HashMap::from([])
}","}

fn main() {
    let candidate = histogram;
    assert_eq!(candidate(String::from(""a b b a"")), HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)]));
    assert_eq!(candidate(String::from(""a b c a b"")), HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)]));
    assert_eq!(candidate(String::from(""a b c d g"")), HashMap::from([(String::from(""a""), 1), (String::from(""b""), 1), (String::from(""c""), 1), (String::from(""d""), 1), (String::from(""g""), 1)]));
    assert_eq!(candidate(String::from(""r t g"")), HashMap::from([(String::from(""r""), 1), (String::from(""t""), 1), (String::from(""g""), 1)]));
    assert_eq!(candidate(String::from(""b b b b a"")), HashMap::from([(String::from(""b""), 4)]));
    assert_eq!(candidate(String::from(""r t g"")), HashMap::from([(String::from(""r""), 1), (String::from(""t""), 1), (String::from(""g""), 1)]));
    assert_eq!(candidate(String::from("""")), HashMap::from([]));
    assert_eq!(candidate(String::from(""a"")), HashMap::from([(String::from(""a""), 1)]));
}
"
HumanEval_112,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ /// ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵔⵉⵜ ⵢⴰⵜ ⵜⴱⵔⵔⵉⵜ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵢⴰⴼⵓⵜ ⴷ true/false ⵉ ⵓⵣⵣⵔⴰⵢ. ///ⵜⵜⵜⵓⵙⵎⵔⴰⵙ ⵜⵉⴼⵉⵏⴰⵖ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ ⵎⴽ ⴷⴰ ⵜⴻⵜⵜⵢⴰⵔⴰ ⵙ ⵓⵎⵏⵉⴷ ⴰⵎⵎ ⵓⵎⵏⵉⴷ. /// ⴹⴰⵕⵜ ⵓⵢⴰ, ⵥⵕⵖ ⵉⵙ ⵜⴳⴰ ⵜⵢⴰⴼⵓⵜ ⵏ ⵓⵖⵉⵍⵓⴼ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉⵜ. /// ⵏⵜⵜⴰⴽⴽⴰ ⵙⵉⵏ ⵉⵙⴽⴽⵉⵍⵏ s ⴷ c, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵏⵙⵙⴽⵛⵎ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ s ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ ⴷ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ c /// ⵜⴰⵡⵓⵔⵉ /// >>> reverse_delete(String::from(""abcde""), String::from(""ae""))
/// (String::from(""bcd""), false)
/// >>> reverse_delete(String::from(""abcdef""), String::from(""b""))
/// (String::from(""acdef""), false)
/// >>> reverse_delete(String::from(""abcdedcba""), String::from(""ab""))
/// (String::from(""cdedc""), true)
fn reverse_delete(s: String, c: String) -> (String, bool) {
","fn reverse_delete(s: String, c: String) -> (String, bool) {
    // Create a set of characters to delete for quick lookup
    let delete_chars: std::collections::HashSet<char> = c.chars().collect();
    
    // Filter the string, keeping only characters not in the delete set
    let filtered: String = s.chars().filter(|ch| !delete_chars.contains(ch)).collect();
    
    // Check if the filtered string is a palindrome
    let is_palindrome = filtered == filtered.chars().rev().collect::<String>();
    
    // Return the filtered string and whether it's a palindrome
    (filtered, is_palindrome)
}","}

fn main() {
    let candidate = reverse_delete;
    assert_eq!(candidate(String::from(""abcde""), String::from(""ae"")), (String::from(""bcd""), false));
    assert_eq!(candidate(String::from(""abcdef""), String::from(""b"")), (String::from(""acdef""), false));
    assert_eq!(candidate(String::from(""abcdedcba""), String::from(""ab"")), (String::from(""cdedc""), true));
    assert_eq!(candidate(String::from(""dwik""), String::from(""w"")), (String::from(""dik""), false));
    assert_eq!(candidate(String::from(""a""), String::from(""a"")), (String::from(""""), true));
    assert_eq!(candidate(String::from(""abcdedcba""), String::from("""")), (String::from(""abcdedcba""), true));
    assert_eq!(candidate(String::from(""abcdedcba""), String::from(""v"")), (String::from(""abcdedcba""), true));
    assert_eq!(candidate(String::from(""vabba""), String::from(""v"")), (String::from(""abba""), true));
    assert_eq!(candidate(String::from(""mamma""), String::from(""mia"")), (String::from(""""), true));
}
"
HumanEval_113,tzm_Tfng,rs,"/// ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵜⵔⴳⴰⵍⵜ ⵜⵉⵙⵙ i ⵏ ⵓⵙⴽⵛⵎ. ///ⵜⴰⵏⴳⴰⵍⵜ i ⵏ ⵓⵙⴽⴽⵉⵍ ⵏ ⵓⵙⴽⵛⵎ. "" ⴳ ⵎⴰⵏⵉ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴽⵓⵍⵍⵓ i ⵙ ⵓⵟⵟⵓⵏ /// ⴽⵓ ⵉⴼⵔⴷⵉⵙ i ⵏ ⵜⵏⴰⴼⵓⵜ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ""ⵉⴹ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ /// ⴷⴰⵜ ⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵙⴽⴽⵉⵍⵏ, ⴳ ⴽⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳⴰⵏ ⵡⵓⵟⵟⵓⵏⵏ, ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ. /// >>> odd_count(vec![String::from(""1234567"")])
/// vec![String::from(""the number of odd elements 4n the str4ng 4 of the 4nput."")]
/// >>> odd_count(vec![String::from(""3""), String::from(""11111111"")])
/// vec![String::from(""the number of odd elements 1n the str1ng 1 of the 1nput.""), String::from(""the number of odd elements 8n the str8ng 8 of the 8nput."")]
fn odd_count(lst: Vec<String>) -> Vec<String> {
","fn odd_count(lst: Vec<String>) -> Vec<String> {
    lst.iter()
        .map(|s| {
            let odd_count = s.chars().filter(|&c| {
                match c {
                    '1' | '3' | '5' | '7' | '9' => true,
                    _ => false,
                }
            }).count();
            format!(""the number of odd elements {0}n the str{0}ng {0} of the {0}nput."", odd_count)
        })
        .collect()
}

// Example usage:
// fn main() {
//     let result = odd_count(vec![String::from(""1234567"")]);
//     println!(""{:?}"", result);
// 
//     let result = odd_count(vec![String::from(""3""), String::from(""11111111"")]);
//     println!(""{:?}"", result);
// }","}

fn main() {
    let candidate = odd_count;
    assert_eq!(candidate(vec![String::from(""1234567"")]), vec![String::from(""the number of odd elements 4n the str4ng 4 of the 4nput."")]);
    assert_eq!(candidate(vec![String::from(""3""), String::from(""11111111"")]), vec![String::from(""the number of odd elements 1n the str1ng 1 of the 1nput.""), String::from(""the number of odd elements 8n the str8ng 8 of the 8nput."")]);
    assert_eq!(candidate(vec![String::from(""271""), String::from(""137""), String::from(""314"")]), vec![String::from(""the number of odd elements 2n the str2ng 2 of the 2nput.""), String::from(""the number of odd elements 3n the str3ng 3 of the 3nput.""), String::from(""the number of odd elements 2n the str2ng 2 of the 2nput."")]);
}
"
HumanEval_114,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ /// ⵏ ⵉⵎⴹⴰⵏⵏ. /// ⴰⵖ ⴷ ⵢⵓⴼⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵉⴼⵔⴰⵢ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵜⴰⴷⵔⵓⵙⵜ ⵏ ⴽⵓ ⵓⵡⵉⴽⵜⵓⵔ ⴰⵎⵥⵥⵢⴰⵏ ⵓⵔ ⵉⴳⵉⵏ ⵡⴰⴹⵓ /// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(vec![-1, -2, -3])
/// -6
fn minSubArraySum(nums: Vec<isize>) -> isize {
","fn minSubArraySum(nums: Vec<isize>) -> isize {
    let mut min_sum = nums[0];
    let mut current_sum = nums[0];

    for &num in nums.iter().skip(1) {
        current_sum = current_sum.min(current_sum + num);
        min_sum = min_sum.min(current_sum);
    }

    min_sum
}","}

fn main() {
    let candidate = minSubArraySum;
    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);
    assert_eq!(candidate(vec![-1, -2, -3]), -6);
    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);
    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);
    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);
    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);
    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);
    assert_eq!(candidate(vec![-10]), -10);
    assert_eq!(candidate(vec![7]), 7);
    assert_eq!(candidate(vec![1, -1]), -1);
}
"
HumanEval_115,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ 1: /// ⵙⵙⵓⴼⵖ ⴰⵎⴹⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵜⵔⴰⵎ ⴰⴷ ⵜⵙⵙⵉⴷⴼⵎ ⵉⴽⵛⵛⵓⵎⵏ. /// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵎⵔⵙⴷ ⵉⴽⵛⵛⵓⵎⵏ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵏⴷ ⵉⴳⴳⵉ. /// ⴷ ⴽⵓⵍⵍⵓ ⵉⴽⵛⵛⵓⵎⵏ ⵖⵓⵔⵙⵏ ⵢⴰⵜ ⵜⵣⵎⵔⵜ. /// ⴽⵓ ⵜⵓⵏⵙ ⵖⵓⵔⵙ ⵢⴰⵏ ⵍⴱⵉⴽⴰⵜ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⵏⵏⴰ ⵉⵖⵢ ⴰⴷ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⴳ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵡⴰⵎⴰⵏ ⵙⴳ ⵜⵓⵏⵙ, /// ⴷ ⴽⵓ 1 ⴳ ⵢⴰⵏ ⵓⵡⵔⵉⴽ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵜ ⵜⴰⵢⵎⵓⵏⵜ ⵏ ⵡⴰⵎⴰⵏ. ///ⵜⵜⵜⵢⴰⴽⴽⴰ ⵢⴰⵜ ⵜⴽⵔⵔⴰⵢⵜ ⵏ ⵉⵔⴳⴰⵢⵏ ⵏ ⵓⵥⵍⴰⵢ. ⴽⵓ ⵜⴰⵡⵔⵉⵔⵜ ⵜⵙⵙⵎⴷⵢⴰ ⵢⴰⵏ ⵉⵔⴳⴰⵢⵏ, /// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)
/// 6
/// Example 2:
/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)
/// 5
/// Example 3:
/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {
","fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {
    let mut total_water_units = 0;

    for row in grid.iter() {
        for &unit in row.iter() {
            total_water_units += unit;
        }
    }

    // Calculate how many times we need to lower the bucket to extract all water units
    (total_water_units + capacity - 1) / capacity
}

fn main() {
    println!(""{}"", max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)); // 6
    println!(""{}"", max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)); // 5
    println!(""{}"", max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)); // 0
}","}

fn main() {
    let candidate = max_fill;
    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);
    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);
    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);
}
"
HumanEval_116,tzm_Tfng,rs,"/// ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⴽⴰⵔ ⵣⵓⵏⴷ ⴰⴷ: /// ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵢⴰⴳⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ, ⵙⵙⵓⴷⵙ ⵅⴼ ⵡⴰⵜⵉⴳ ⴰⵎⵔⴰⵡ. /// ⴰⵎⴹⴰⵏ ⵏ ⵉⵎⵢⴰⴳⵏ ⴳ ⵓⵙⵎⴷⵢⴰ ⵏⵏⵙⵏ ⴰⵎⵉⵏⴰⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵇⵔⴰⵏ. /// ⴳ ⴽⴰⵜⴰ ⴰⴷ, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵔⵉⵏ ⴹⴰⵕⵜ /// >>> sort_array(vec![1, 5, 2, 3, 4])
/// vec![1, 2, 3, 4, 5]
/// >>> sort_array(vec![-2, -3, -4, -5, -6])
/// vec![-6, -5, -4, -3, -2]
/// >>> sort_array(vec![1, 0, 2, 3, 4])
/// vec![0, 1, 2, 3, 4]
fn sort_array(arr: Vec<isize>) -> Vec<isize> {
","fn sort_array(arr: Vec<isize>) -> Vec<isize> {
    let mut arr = arr;
    arr.sort_by(|&a, &b| {
        let ones_a = a.count_ones();
        let ones_b = b.count_ones();
        if ones_a == ones_b {
            a.cmp(&b)
        } else {
            ones_a.cmp(&ones_b)
        }
    });
    arr
}

fn main() {
    println!(""{:?}"", sort_array(vec![1, 5, 2, 3, 4])); // Output: [1, 2, 3, 4, 5]
    println!(""{:?}"", sort_array(vec![-2, -3, -4, -5, -6])); // Output: [-6, -5, -4, -3, -2]
    println!(""{:?}"", sort_array(vec![1, 0, 2, 3, 4])); // Output: [0, 1, 2, 3, 4]
}","}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);
    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);
    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
}
"
HumanEval_117,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵜⴰⵏⵏⴰⵢⵜ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴷ ⵉⵙ ⴳ ⵜⵊⵎⵉⵍⵜ ⵏ ⵓⵙⴽⵛⵎ ⵍⵍⴰⵏⵜ ⵜⵉⵔⵔⴰ ⴷ ⵉⵎⵣⴰⵔⴰⵢⵏ. /// ⵎⴽ ⵜⴳⴰ ⵜⵉⴼⵉⵏⴰⵖ s ⵜⴰⵍⵍⵉⵜ, ⵔⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵍⵍⵓⵍⵏ. ///n ⵉⵎⵙⵍⵉ, ⵙ ⵓⵍⵖⵓ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴷ ⴳ ⵜⵣⴳⵉⵍⵜ s. /// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴽⴽⵡ ⵙⴳ ⵜⵉⴼⵉⵏⴰⵖ s ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⴽⵙⴰⵢ /// ⵙ ⵓⵙⴽⴽⵉⵍ s ⴷ ⵓⵟⵟⵓⵏ ⴰⴳⴰⵎⴰⵏ n, ⵔⴰⴷ ⵜⵙⵙⴽⵔⴷ /// >>> select_words(String::from(""Mary had a little lamb""), 4)
/// vec![String::from(""little"")]
/// >>> select_words(String::from(""Mary had a little lamb""), 3)
/// vec![String::from(""Mary""), String::from(""lamb"")]
/// >>> select_words(String::from(""simple white space""), 2)
/// Vec::<String>::new()
/// >>> select_words(String::from(""Hello world""), 4)
/// vec![String::from(""world"")]
/// >>> select_words(String::from(""Uncle sam""), 3)
/// vec![String::from(""Uncle"")]
fn select_words(s: String, n: isize) -> Vec<String> {
","fn select_words(s: String, n: isize) -> Vec<String> {
    let consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"";
    let mut result = Vec::new();

    for word in s.split_whitespace() {
        let consonant_count = word.chars().filter(|c| consonants.contains(*c)).count();
        if consonant_count == n as usize {
            result.push(word.to_string());
        }
    }

    result
}","}

fn main() {
    let candidate = select_words;
    assert_eq!(candidate(String::from(""Mary had a little lamb""), 4), vec![String::from(""little"")]);
    assert_eq!(candidate(String::from(""Mary had a little lamb""), 3), vec![String::from(""Mary""), String::from(""lamb"")]);
    assert_eq!(candidate(String::from(""simple white space""), 2), Vec::<String>::new());
    assert_eq!(candidate(String::from(""Hello world""), 4), vec![String::from(""world"")]);
    assert_eq!(candidate(String::from(""Uncle sam""), 3), vec![String::from(""Uncle"")]);
    assert_eq!(candidate(String::from(""""), 4), Vec::<String>::new());
    assert_eq!(candidate(String::from(""a b c d e f""), 1), vec![String::from(""b""), String::from(""c""), String::from(""d""), String::from(""f"")]);
}
"
HumanEval_118,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// ⴰⴷ ⵜⵙⵙⵏⵎ ⵉⵙ ⴷⴰⵔⵙ ⵜⵉⵔⵔⴰ ⵏ ⵜⵓⵜⵍⴰⵢⵜ ⵜⴰⵎⴰⵣⵉⵖⵜ ⵅⴰⵙ ⵜⵉⵔⵔⴰ ⵏ ⵜⵓⵜⵍⴰⵢⵜ ⵜⴰⵎⴰⵣⵉⵖⵜ.///ⴰⴼ ⴽⵔⴰ ⵏ ⵓⵖⵔⵉ ⵏⵏⴰ ⵉⵙⵎⵓⵏⵏ ⵜⴰⵍⵖⴰ ⵏⵏⵉⴳ ⵏ ⵓⵢⴰ. /// ⵓⵔ ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⵎⵙⵍⵉ ⴳ ⵍⴱⴷⵓ ⴷ ⵜⴳⵉⵔⴰ. ⵔⵎⵙⵏ ⵜⴰⵡⴰⵍⵜ ⵜⵓⵎⵥⵜ ⵎⴽ ⵓⵔ ⵜⵔⵎⵙⵏ./// ⵙⵉⵏ ⵉⵎⵙⵍⵉⵢⵏ ⵙⴳ ⵜⵙⴳⴰ ⵏ ⵓⵣⵔⴼ ⵏ ⵜⴳⵓⵔⵉ (ⴰⵙⵙⴰⵖ ⵏ ⵓⵙⴽⴽⵉⵍ). ///ⵜⵢⴰⴽⴽⴰ ⵜ ⵢⴰⵜ ⵜⴳⵓⵔⵉ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴰⴼⴷ ⵓⵡⵉⴽⵉⵍ ⴰⵎⵉⴽⴽⵙⵓ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳⵔ /// >>> get_closest_vowel(String::from(""yogurt""))
/// String::from(""u"")
/// >>> get_closest_vowel(String::from(""FULL""))
/// String::from(""U"")
/// >>> get_closest_vowel(String::from(""quick""))
/// String::from("""")
/// >>> get_closest_vowel(String::from(""ab""))
/// String::from("""")
fn get_closest_vowel(word: String) -> String {
","fn get_closest_vowel(word: String) -> String {
    let vowels = ""aeiouAEIOU"";
    let chars: Vec<char> = word.chars().collect();
    if chars.len() < 3 {
        return String::from("""");
    }

    for i in (1..chars.len() - 1).rev() {
        if vowels.contains(chars[i]) && !vowels.contains(chars[i-1]) && !vowels.contains(chars[i+1]) {
            return chars[i].to_string();
        }
    }
    String::from("""")
}","}

fn main() {
    let candidate = get_closest_vowel;
    assert_eq!(candidate(String::from(""yogurt"")), String::from(""u""));
    assert_eq!(candidate(String::from(""full"")), String::from(""u""));
    assert_eq!(candidate(String::from(""easy"")), String::from(""""));
    assert_eq!(candidate(String::from(""eAsy"")), String::from(""""));
    assert_eq!(candidate(String::from(""ali"")), String::from(""""));
    assert_eq!(candidate(String::from(""bad"")), String::from(""a""));
    assert_eq!(candidate(String::from(""most"")), String::from(""o""));
    assert_eq!(candidate(String::from(""ab"")), String::from(""""));
    assert_eq!(candidate(String::from(""ba"")), String::from(""""));
    assert_eq!(candidate(String::from(""quick"")), String::from(""""));
    assert_eq!(candidate(String::from(""anime"")), String::from(""i""));
    assert_eq!(candidate(String::from(""Asia"")), String::from(""""));
    assert_eq!(candidate(String::from(""Above"")), String::from(""o""));
}
"
HumanEval_119,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⴰⴷ ⵏⵔⴰⵔ ""ⵉⵀ"" ⵎⴽ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴱⵔⵉⴷ ⵉ ⵓⵙⴽⴰⵔ ⵏ ⵢⴰⵏ ⵓⵖⵉⵍⵓⴼ ⵉⵖⵓⴷⴰⵏ, ⴷ ⴰⴷ ⵏⵔⴰⵔ ""ⵓⵄ"" ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ./// ""()) "" ⵓⵔ ⵉⴳⵉ. /// ⴳⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ. ⵙ ⵓⵎⴷⵢⴰ: ⵜⵉⴼⵉⵏⴰⵖ ""(()))) "" ⵜⴳⴰ ⵜⵣⵔⴼⴰⵏⵜ, ⵎⴰⵛⴰ ⵜⵉⴼⵉⵏⴰⵖ /// ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙ ⵜⵉⴼⵉⵏⴰⵖ S ⴰⴷ ⵜⴳ ⵜⵣⴷⵉⴳⵜ ⵎⴽ ⴷ ⴽⵓⵍⵍⵓ ⵜⵉⵙⴳⵏⵓⵜⵉⵏ ⴳ S /// ⴽⵔⴰ ⵏ ⵓⴽⵓⴷ, ⵎⴰⵙⴷ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⵔⴰⴷ ⵉⴳ ⵉⵖⵓⴷⴰⵏ./// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵥⵕⵎ ⵎⴽ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴽⴷⴷⴷ ⵙⵏⴰⵜ ⵏ ⵜⵉⴼⵉⵏⴰⵖ  ⴳ /// ⵜⴰⴳⵔⵓⵎⵎⴰ "" (() "" ⵏⵖ ⵜⴰⴳⵔⵓⵎⵎⴰ "") "" ⵅⵙ./// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ ⵏ ⵙⵉⵏ ⵉⵙⵓⴳⴰⵎ, ⵙⵉⵏ ⵉⵙⵓⴳⴰⵎ ⴳⴰⵏ ⵉⵕⵥⵎⵏ /// >>> match_parens(vec![String::from(""()(""), String::from("")"")])
/// String::from(""Yes"")
/// >>> match_parens(vec![String::from("")""), String::from("")"")])
/// String::from(""No"")
fn match_parens(lst: Vec<String>) -> String {
","fn match_parens(lst: Vec<String>) -> String {
    fn is_balanced(s: &str) -> bool {
        let mut balance = 0;
        for ch in s.chars() {
            if ch == '(' {
                balance += 1;
            } else {
                balance -= 1;
            }
            if balance < 0 {
                return false;
            }
        }
        balance == 0
    }

    if lst.len() != 2 {
        return ""No"".to_string();
    }

    let s1 = &lst[0];
    let s2 = &lst[1];

    let combined1 = format!(""{}{}"", s1, s2);
    let combined2 = format!(""{}{}"", s2, s1);

    if is_balanced(&combined1) || is_balanced(&combined2) {
        ""Yes"".to_string()
    } else {
        ""No"".to_string()
    }
}","}

fn main() {
    let candidate = match_parens;
    assert_eq!(candidate(vec![String::from(""()(""), String::from("")"")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from("")""), String::from("")"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from(""(()(())""), String::from(""())())"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from("")())""), String::from(""(()()("")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from(""(())))""), String::from(""(()())(("")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from(""()""), String::from(""())"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from(""(()(""), String::from(""()))()"")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from(""((((""), String::from(""((())"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from("")(()""), String::from(""(()("")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from("")(""), String::from("")("")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from(""(""), String::from("")"")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from("")""), String::from(""("")]), String::from(""Yes""));
}
"
HumanEval_120,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ 1: /// ⵏ ⵜⵉⵖⵣⵉ k ⵙ ⵓⴳⴳⴰⵔ ⵏ k ⵉⵎⴹⴰⵏⵏ ⴳ arr. /// ⴷⴰⵔⵙ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ k, ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ /// >>> maximum(vec![-3, -4, 5], 3)
/// vec![-4, -3, 5]
/// Example 2:
/// >>> maximum(vec![4, -4, 4], 2)
/// vec![4, 4]
/// Example 3:
/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)
/// vec![2]
/// Note:
/// 1. The length of the vector will be in the range of [1, 1000].
/// 2. The elements in the vector will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {
","fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {
    let mut arr = arr;
    arr.sort_unstable_by(|a, b| b.cmp(a));
    let k = k as usize;
    let mut result: Vec<isize> = arr.into_iter().take(k).collect();
    result.sort_unstable();
    result
}

fn main() {
    assert_eq!(maximum(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(maximum(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
}","}

fn main() {
    let candidate = maximum;
    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);
    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);
    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);
    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);
    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);
    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);
    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);
    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());
}
"
HumanEval_121,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ /// ⴷⴰⵜ ⵏ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵓⵔ ⵉⴳⵉ ⵡⴰⴹⵓ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⵜⴰⴳⵓⵜ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵜⵣⴷⵓⵖⵉⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ. /// >>> solution(vec![5, 8, 7, 1])
/// 12
/// >>> solution(vec![3, 3, 3, 3, 3])
/// 9
/// >>> solution(vec![30, 13, 24, 321])
/// 0
fn solution(lst: Vec<isize>) -> isize {
","fn solution(lst: Vec<isize>) -> isize {
    lst.iter()
        .enumerate()
        .filter(|(i, &x)| i % 2 == 0 && x % 2 != 0)
        .map(|(_, &x)| x)
        .sum()
}","}

fn main() {
    let candidate = solution;
    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);
    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);
    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);
    assert_eq!(candidate(vec![5, 9]), 5);
    assert_eq!(candidate(vec![2, 4, 8]), 0);
    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);
    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);
}
"
HumanEval_122,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵙⵏⴰⵜ ⵜⵓⵙⴽⵉⵡⵉⵏ ⵙⴳ k ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ arr. /// ⴷⴰⵔⵙ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵓⵔ ⵉⴳⵍⵍⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ arr ⴷ ⵢⴰⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ k, return /// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
fn add_elements(arr: Vec<isize>, k: isize) -> isize {
","fn add_elements(arr: Vec<isize>, k: isize) -> isize {
    arr.iter()
        .take(k as usize)
        .filter(|&&x| x > -100 && x < 100)
        .sum()
}

fn main() {
    let result = add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4);
    println!(""{}"", result);  // Output: 24
}","}

fn main() {
    let candidate = add_elements;
    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);
    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);
    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);
    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);
    assert_eq!(candidate(vec![1], 1), 1);
}
"
HumanEval_123,tzm_Tfng,rs,"/// get_odd_collatz(5) ⴰⵔ ⵉⵜⵜⵔⴰⵔ [1, 5] # ⵜⴰⵔⵔⴰ ⵏ ⴽⵓⵍⵍⴰⵜⵣ ⵉ 5 ⵜⴳⴰ [5, 16, 8, 4, 2, 1], ⴰⵢⴰⴷ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ ⴳⴰⵏ 1, ⴷ 5. /// ⵙ ⵓⵎⴷⵢⴰ: /// 2. ⵉⵙⴽⵉⵍⵏ ⵉⵜⵜⵓⵣⵎⵎⴻⵎⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵔⵏⵉⵡ./// 1. ⴽⵓⵍⵍⴰⵜⵣ ((1) ⵉⴳⴰ [1]. /// ⵜⴰⵏⵏⴰⵢⵜ: ///ⵜⵉⵔⵎ ⵓⴳⴳⴰⵔ 1. ⵜⴰⵡⵏⴳⵉⵎⵜ ⵜⴳⴰ ⵜⵜ ⵎⴰⵙ ⵓⵔ ⵜⵅⵙ ⴰⵜⵉⴳ ⵏ n, ⵔⴰⴷ ⵜⵍⴽⵎ ⵜⵉⴼⵔⴽⵜ ⴰⵀⴰ 1. /// ⴰⵖⵓⵔⵉ ⵉⵣⵔⵉⵏ. ⵎⴽ ⵉⴳⴰ ⵓⵖⵓⵔⵉ ⵉⵣⵔⵉⵏ ⴰⵎⵣⴳⵓⵏ, ⴷⴰ ⵉⵜⵜⴳⴳⴰ ⵓⵖⵓⵔⵉ ⵢⴰⴹⵏ 3 ⵏ ⵜⵉⴽⴽⴰⵍ ⵏ ⵓⵖⵓⵔⵉ ⵉⵣⵔⵉⵏ /// ⴰⵜⵉⴳ ⵉⵣⵔⵉⵏ ⵙ ⵓⵎⴽ ⴰⴷ: ⵎⴽ ⵉⴳⴰ ⵓⵜⵉⴳ ⵉⵣⵔⵉⵏ ⴰⵎⵙⴳⴷⴰⵍ, ⴰⵜⵉⴳ ⴰⴹⴼⴰⵕ ⵉⴳⴰ ⵓⵣⴳⵏ ⵏ /// ⵙ ⵡⴰⵏⴰⵡ ⴰⴷ: ⵔⴰⴷ ⵜⴱⴷⵓ ⵙ ⴽⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ n. ⵔⴰⴷ ⵢⵉⵍⵉ ⴽⵓ ⵉⵎⵉⴹ ⵙⴳ /// ⵜⴰⵖⵏⵙⴰ ⵏ ⴽⵓⵍⵍⴰⵣ ⵜⴳⴰ ⵢⴰⵜ ⵜⵖⵏⵙⴰ ⴳ ⵜⵓⵙⵏⴰⴽⵜ ⵏⵏⴰ ⵉⵥⵍⵉⵏ ⵙ ⵢⴰⵜ ⵜⵣⵍⵉⵜ ⵉⵜⵜⵓⵙⵙⴰⵏⵏ /// ⴷⴰⵜ ⵏ ⵢⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵥⴰⵢⵏ n, ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ ⴳ ⵓⵙⵓⵔⵙ ⵏ ⴽⵓⵍⴰⵜⵣ. /// >>> get_odd_collatz(5)
/// vec![1, 5]
fn get_odd_collatz(n: isize) -> Vec<isize> {
","fn get_odd_collatz(n: isize) -> Vec<isize> {
    let mut sequence = Vec::new();
    let mut current = n;

    while current != 1 {
        if current % 2 != 0 {
            sequence.push(current);
        }

        if current % 2 == 0 {
            current /= 2;
        } else {
            current = 3 * current + 1;
        }
    }
    
    // Add the final odd number 1 if n is 1
    sequence.push(1);

    sequence.sort();
    sequence
}

fn main() {
    let result = get_odd_collatz(5);
    println!(""{:?}"", result); // Outputs: [1, 5]
}","}

fn main() {
    let candidate = get_odd_collatz;
    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(5), vec![1, 5]);
    assert_eq!(candidate(12), vec![1, 3, 5]);
    assert_eq!(candidate(1), vec![1]);
}
"
HumanEval_124,tzm_Tfng,rs,"/// 4. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵢⵉⵍⵉ ⵓⵙⵖⵍ ⵏ ⵡⴰⵙⵙ ⴳ ⵜⵍⵖⴰ: ⵎⵎ-ⴷⵉ-ⵢⵢⴰⵢⵢⴰ /// 3. ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵉⴳ ⵡⴰⵢⵢⵓⵔ ⴷⴷⵖ 1 ⵏⵖ ⵓⴳⴳⴰⵔ ⵏ 12./// 2. ⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⵓⵔ ⴷⵔⵓⵙⵏ ⵙⴳ 1 ⵏⵖ ⵓⴳⴳⴰⵔ ⵏ 31 ⵏ ⵡⵓⵙⵙⴰⵏ ⵉ ⵡⴰⵢⵢⵓⵔⵏ 1,3,5,7,8,10,12. ⴷ ⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⵓⵔ ⴷⵔⵓⵙⵏ ⵙⴳ 1 ⵏⵖ ⵓⴳⴳⴰⵔ ⵏ 30 ⵏ ⵡⵓⵙⵙⴰⵏ ⵉ ⵡⴰⵢⵢⵓⵔⵏ 4,6,9,11. ⴷ, ⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⵓⵔ ⴷⵔⵓⵙⵏ ⵙⴳ 1 ⵏⵖ ⵓⴳⴳⴰⵔ ⵏ 29 ⵉ ⵡⴰⵢⵢⵓⵔ 2./// 1. ⵓⵔ ⵜⵍⵍⵉ ⵜⵣⴳⵍⵜ ⵏ ⵡⴰⵙⵙ ⵅⴷⴷⴰ./// ⵉⴳⴰ ⵡⴰⵙⵙ ⴰⴷ ⴰⵣⵔⴼⴰⵏ ⵎⴽⵍⵍⵉ ⵜⵜⵓⵙⵎⵔⵏ ⴽⵓⵍⵍⵓ ⵉⵍⵓⴳⵏⵏ ⴰⴷ: /// ⴰⵔ ⵉⵜⵜⵔ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⴰⵙⵙ ⵢⴰⵜ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵜⵉⴷⵜ. /// ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵔⵉⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵙⵎⴷⵏ ⵜⴰⵡⵓⵔⵉ ⵏ ⵓⵣⵎⵣ ⴷ /// >>> valid_date(String::from(""03-11-2000""))
/// true
/// >>> valid_date(String::from(""15-01-2012""))
/// false
/// >>> valid_date(String::from(""04-0-2040""))
/// false
/// >>> valid_date(String::from(""06-04-2020""))
/// true
/// >>> valid_date(String::from(""06/04/2020""))
/// false
fn valid_date(date: String) -> bool {
","fn valid_date(date: String) -> bool {
    if date.is_empty() {
        return false;
    }

    let parts: Vec<&str> = date.split('-').collect();
    if parts.len() != 3 {
        return false;
    }

    let maybe_month = parts[0].parse::<u32>();
    let maybe_day = parts[1].parse::<u32>();
    let maybe_year = parts[2].parse::<u32>();

    if maybe_month.is_err() || maybe_day.is_err() || maybe_year.is_err() {
        return false;
    }

    let month = maybe_month.unwrap();
    let day = maybe_day.unwrap();

    if month < 1 || month > 12 {
        return false;
    }

    match month {
        1 | 3 | 5 | 7 | 8 | 10 | 12 => {
            if day < 1 || day > 31 {
                return false;
            }
        }
        4 | 6 | 9 | 11 => {
            if day < 1 || day > 30 {
                return false;
            }
        }
        2 => {
            if day < 1 || day > 29 {
                return false;
            }
        }
        _ => return false, // This case should never be reached
    }

    true
}","}

fn main() {
    let candidate = valid_date;
    assert_eq!(candidate(String::from(""03-11-2000"")), true);
    assert_eq!(candidate(String::from(""15-01-2012"")), false);
    assert_eq!(candidate(String::from(""04-0-2040"")), false);
    assert_eq!(candidate(String::from(""06-04-2020"")), true);
    assert_eq!(candidate(String::from(""01-01-2007"")), true);
    assert_eq!(candidate(String::from(""03-32-2011"")), false);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""04-31-3000"")), false);
    assert_eq!(candidate(String::from(""06-06-2005"")), true);
    assert_eq!(candidate(String::from(""21-31-2000"")), false);
    assert_eq!(candidate(String::from(""04-12-2003"")), true);
    assert_eq!(candidate(String::from(""04122003"")), false);
    assert_eq!(candidate(String::from(""20030412"")), false);
    assert_eq!(candidate(String::from(""2003-04"")), false);
    assert_eq!(candidate(String::from(""2003-04-12"")), false);
    assert_eq!(candidate(String::from(""04-2003"")), false);
}
"
HumanEval_126,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ /// number, return false. ⵓⵔ ⴷⴰ ⵏⵜⵜⴰⴼⴰ ⵉⵎⴹⴰⵏ ⵉⵔⵉⵏⵉⵢⵏ ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. /// ⵙ ⵓⵙⵙⵓⴷⵓ ⵏ ⵓⴽⴼⴼⴰⵢ. ⵎⴽ ⵜⵍⵍⴰ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵓⴳⴳⴰⵔ ⵏ 1 ⵜⴰⵡⵉⴽⵜⵓⵔⵜ ⵏ ⵢⴰⵏ /// ⴷⴰⵜ ⵏ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏⵏ, ⵔⴰⴷ ⵏⵔⴰⵔ ⵙ ⵎⴽⵏⵏⴰ ⵜⵜⵓⵙⵎⵉⵍⵏ ⵏⵖⴷ ⵓⵔ ⵜⵜⵓⵙⵎⵉⵍⵏ /// >>> is_sorted(vec![5])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])
/// false
fn is_sorted(lst: Vec<isize>) -> bool {
","fn is_sorted(lst: Vec<isize>) -> bool {
    if lst.is_empty() || lst.len() == 1 {
        return true;
    }
    
    let mut previous = lst[0];
    let mut repeat_count = 0;

    for &current in &lst[1..] {
        if current < previous {
            return false;
        }
        if current == previous {
            repeat_count += 1;
            if repeat_count >= 2 {
                return false;
            }
        } else {
            repeat_count = 0;
        }
        previous = current;
    }

    true
}","}

fn main() {
    let candidate = is_sorted;
    assert_eq!(candidate(vec![5]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
    assert_eq!(candidate(vec![1]), true);
    assert_eq!(candidate(vec![3, 2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4]), true);
}
"
HumanEval_127,tzm_Tfng,rs,"/// [input/output] ⵉⵎⴷⵢⴰⵣⵏ: /// ⵎⴽ ⵓⵔ ⴷⴰ ⵜⵜⵎⵙⴰⵙⴰⵏ ⵙⵏⴰⵜ ⵜⴽⵍⵢⵉⵏ, ⵙⵙⵓⴼⵖ ""ⵓⵅⴰ"". /// ⵎⴽ ⵓⵔ ⵜⵍⵍⵉ, ⵔⵎⵙ ""ⵓⵀⵓ""./// ⵎⴽ ⵜⴳⴰ ⵜⵉⵖⵣⵉ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⴰⵎⵉⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⵙⵙⴽⵛⵎ ""YES"", /// ⵏⵏⴰ ⴷⴰⵔ ⵜⵉⵖⵣⵉ ⵏⵏⵙ 1 ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ. /// ⴰⵎⴷⵢⴰ, ⴰⵙⵎⵓⵜⵜⴳ ⵏ ⵉⵎⵣⴳⵓⵏⵏ (1, 3), (2, 4) ⵉⴳⴰ (2, 3) ///ⵜⴰⵏⴳⵔⵓⵎⵎⴰ ⵜⴳⴰ ⴰⵎⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ. /// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⵎ ⵎⴰⵙ ⴷ ⵜⵉⵖⵣⵉ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵙⵏⴰⵜ /// ⵉ ⴽⵓ ⵢⴰⵏ ⵓⵣⵎⵣ, ⴷⴰ ⵏⵙⵡⵉⵏⴳⵉⵎ ⵎⴰⵙⴷ ⴰⵙⵏⵜⵉ ⵏⵏⵙ ⵉⴳⴰ ⵡⵉⵏ ⵜⴳⵉⵔⴰ ⵏⵏⵙ ⵏⵖⴷ ⵉⵎⴽⵉⵏⵏⴰ ⵉⴳⴰ. /// ⴷⴰ ⵉⵙⵎⵓⵏ ⵜⵉⵣⵡⵉⵔⵉ ⴷ ⵜⴳⵉⵔⴰ. /// ⵜⵉⵣⵉ ⵏ ⵜⵉⴽⴽⵍⵜ ⵉⵜⵜⵢⴰⵙⵏ ⵜⵜⵓⵎⵍⴰⵏ ⴰⵢⵏⵏⴰ ⵎⵉ ⵉⴳⴰ ⵓⴽⵓⴷ (ⵜⴰⵎⵣⵡⴰⵔⵓⵜ, ⵜⴳⵉⵔⴰ) /// ⴳ ⴽⵓ ⵢⴰⵏ ⴳ ⵉⵏⴱⵔⴰⵣⵏ ⵉⴳⴰ ⵢⴰⵏ ⵓⵣⴳⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙ ⵓⵎⴷⵢⴰ, ⵉⵏⴱⵔⴰⵣ = (ⵜⴱⴷⴰ, ⵜⴳⵉⵔⴰ) = (1, 2).///ⵜⵏⵢⴰⵜ ⵙⵏⴰⵜ ⵜⵉⵔⵎⵉⵏ, /// >>> intersection((1, 2), (2, 3))
/// String::from(""NO"")
/// >>> intersection((-1, 1), (0, 4))
/// String::from(""NO"")
/// >>> intersection((-3, -1), (-5, 5))
/// String::from(""YES"")
fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {
","fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {
    let (start1, end1) = interval1;
    let (start2, end2) = interval2;
    let start_intersection = std::cmp::max(start1, start2);
    let end_intersection = std::cmp::min(end1, end2);

    if start_intersection <= end_intersection {
        let length = (end_intersection - start_intersection + 1) as usize;
        if is_prime(length) {
            return String::from(""YES"");
        }
    }
    String::from(""NO"")
}

// Example usage
fn main() {
    println!(""{}"", intersection((1, 2), (2, 3))); // ""NO""
    println!(""{}"", intersection((-1, 1), (0, 4))); // ""NO""
    println!(""{}"", intersection((-3, -1), (-5, 5))); // ""YES""
}","}

fn main() {
    let candidate = intersection;
    assert_eq!(candidate((1, 2), (2, 3)), String::from(""NO""));
    assert_eq!(candidate((-1, 1), (0, 4)), String::from(""NO""));
    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(""YES""));
    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(""YES""));
    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(""NO""));
    assert_eq!(candidate((1, 2), (3, 5)), String::from(""NO""));
    assert_eq!(candidate((1, 2), (1, 2)), String::from(""NO""));
    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(""NO""));
}
"
HumanEval_128,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// Note: return None ⵉ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵅⵡⴰⵏⵏ. /// ⵏ ⴽⵓ ⵓⵟⵟⵓⵏ ⴳ ⵓⴱⵉⴽⵜⵓⵔ, ⵉⵜⵜⵓⵢⵙⵎⴷⵢⴰ ⵙ 1, -1 ⵏⵖⴷ 0. /// ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵜⵉⵙⴽⴼⴰⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙ ⵜⵢⴰⴼⵓⵜ ⵏ ⵉⵙⵎⴰⵡⵏ /// ⴰⵖ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵔⴰⴷ ⵜⵔⵉⵜ /// >>> prod_signs(vec![1, 2, 2, -4])
/// Some(9)
/// >>> prod_signs(vec![0, 1])
/// Some(0)
/// >>> prod_signs(vec![])
/// None
fn prod_signs(arr: Vec<isize>) -> Option<isize> {
","fn prod_signs(arr: Vec<isize>) -> Option<isize> {
    if arr.is_empty() {
        return None;
    }

    let mut sum_of_magnitudes = 0;
    let mut product_of_signs = 1;

    for &num in &arr {
        sum_of_magnitudes += num.abs();
        if num == 0 {
            product_of_signs = 0;
            break;
        } else if num > 0 {
            product_of_signs *= 1;
        } else {
            product_of_signs *= -1;
        }
    }

    Some(sum_of_magnitudes * product_of_signs)
}","}

fn main() {
    let candidate = prod_signs;
    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));
    assert_eq!(candidate(vec![0, 1]), Some(0));
    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));
    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));
    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));
    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));
}
"
HumanEval_129,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⴱⴰⵢⵢⵓⵕ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ ⵏ ⵡⴰⵜⵉⴳⵏ ⵏ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⵙ ⵉⴳⴳⵡⴰⵔ ⴰⴱⵔⵉⴷ ⵏ ⵓⴷⵔⴰⵔ. /// ⴰⵖ-ⴷ-ⵜⵏⵏⴰⵖ ⵉⵙ ⴷ ⵜⴰⵔⴰⵔⵓⵜ-ⵏⵏⵖ ⵜⴰⵢⵎⵎⴰⵜ. /// lst_A[j] = lst_B[j] /// ⵣⵓⵏⴷ lst_A[i] < lst_B[i] ⴷ ⵉ ⴽⵓ j (1 <= j < i) ⵖⵓⵔⵖ /// ⵓⴳⴳⴰⵔ ⵏ lst_B, ⵙ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵢⴰⴹⵏ, ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ i (1 <= i <= k) /// ⵙ (ⴰⴷ ⵏⵉⵏⵉ ⴰⵙⵏ lst_A ⴷ lst_B), lst_A ⵉⴳⴰ ⵡⵉⵏ ⵓⴷⵔⴰⵔ /// ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⴽⴰⵔ ⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ ⵏ ⵡⴰⵜⵉⴳⵏ ⵏ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⴳ A ⴷ B ⵔⴰⴷ ⵙⴽⵔⵏ /// ⴰⴱⵔⵉⴷ A (ⵙ ⵜⵉⵖⵣⵉ k) ⵉⴳⴰ ⵡⵉⵏ ⵓⴷⵔⴰⵔ ⵏ ⵓⴱⵔⵉⴷ B (ⵙ ⵜⵉⵖⵣⵉ k) ⵎⴽ /// ⵓⵔ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵣⵔⵉⴷ ⵙⴳ ⵜⵔⴰⴱⴱⵓⵜ. /// ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵏⵣⴰⵢⴷ)./// ⵙⵙⴽⵜⵉ ⵎⴰⵙⴷ ⴰⴱⵔⵉⴷ ⵏ ⵜⵉⵖⵣⵉ k ⵉⴳⴰ ⴰⵙⵔⵔⵓⵙ ⵏ k ⵏ ⵜⵖⵔⴰⵙⵉⵏ (ⵓⵔ ⵉⴳⵉ /// ⵜⴰⵖⵔⴰⵙⵜ. //ⵙ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵢⴰⴹⵏ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵣⵔⴷ ⵉ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⴷⴰⵔ ⵢⴰⵏ ⵓⴽⴼⴼⴰⵢ ⴰⴽⴷ ⵡⴰⵙⵙⴰⵢ ⵏⵏⴽ./// ⵙⴳ ⴽⵔⴰ ⵏ ⵜⵖⵔⴰⵙⵜ, ⴷ ⴳ ⴽⵓ ⵜⴰⵙⵓⵔⵉⴼⵜ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵖⵔ ⴽⵔⴰ ⵏ ⵜⵖⵔⴰⵙⵜ ⵜⴰⴷⴷⴰⵔⵜ ⵜⵓⵎⵍⵉⵍⵜ, /// ⴰⴷ ⵜⵙⵙⴼⵔⴰⵙⴷ ⴰⴱⵔⵉⴷ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵜⵉⵣⵉ k ⴳ ⵜⵊⵎⵉⵍⵜ. ⵥⴹⴰⵕⴷ ⴰⴷ ⵜⵙⵙⵏⵜⵉ /// inclusive ⴷⴰ ⵢⴰⴷⴼ ⵢⴰⵏ ⵓⴽⵓⴷ ⵖ ⵜⵖⵔⴰⵙⵉⵏ ⵏ ⵜⵊⵎⵉⵍⵜ. /// ⴽⵓ ⵜⴰⵖⵔⴰⵙⵜ ⵏ ⵜⴽⵔⵟⴰ ⵜⵍⴰ ⵢⴰⵏ ⵡⴰⵜⵉⴳ. ⴽⵓ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵙⵏⴼⵍ [1, N * N] /// ⴳ ⵢⴰⵜ ⵜⴽⵔⵔⴰⵢⵜ ⴷ N ⵏ ⵜⵉⵙⴳⵓⵔⵉⵡⵉⵏ ⴷ N ⵏ ⵜⵉⵔⵙⴰⵍ (N >= 2) ⴷ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ k, /// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)
/// vec![1, 2, 1]
/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)
/// vec![1]
fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {
","fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {
    let n = grid.len();
    let mut best_path = vec![];
    let mut best_values = vec![isize::MAX; k as usize];
    
    fn dfs(
        grid: &Vec<Vec<isize>>, 
        row: usize, 
        col: usize, 
        path: &mut Vec<(usize, usize)>, 
        values: &mut Vec<isize>, 
        k: isize, 
        best_values: &mut Vec<isize>
    ) {
        if path.len() == k as usize {
            if values < best_values {
                best_values.clone_from(values);
            }
            return;
        }
        
        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];
        for &(dr, dc) in directions.iter() {
            let new_row = row as isize + dr;
            let new_col = col as isize + dc;
            if new_row >= 0 && new_row < grid.len() as isize && new_col >= 0 && new_col < grid.len() as isize {
                path.push((new_row as usize, new_col as usize));
                values.push(grid[new_row as usize][new_col as usize]);
                dfs(grid, new_row as usize, new_col as usize, path, values, k, best_values);
                values.pop();
                path.pop();
            }
        }
    }

    for r in 0..n {
        for c in 0..n {
            let mut path = vec![(r, c)];
            let mut values = vec![grid[r][c]];
            dfs(&grid, r, c, &mut path, &mut values, k, &mut best_values);
        }
    }

    best_values
}","}

fn main() {
    let candidate = minPath;
    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);
    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);
    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);
    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);
    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);
    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);
    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}
"
HumanEval_130,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵉⵎⴹⴰⵏⵏ ⵏ ⵜⵔⴱⵓⵏⴰⵛⵛⵉ ⵏ n + 1 ⴰⵎⵣⵡⴰⵔⵓ. /// ⴰⵖ ⵜⵜⵓⴼⴽⴰ ⵉⴽ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⵏⴳⵓ n, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⵉⵜⵔⵓⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ /// = 2 + 3 + 3 = 8 ///tri(3) = tri(2) + tri(1) + tri(4) ///tri(4) = 3 ///tri(2) = 1 + (2 / 2) = 2 /// ⵙ ⵓⵎⴷⵢⴰ: ///tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ⵎⴽ n ⵉⴳⴰ ⴰⵎⵣⴳⵓⵏ. ///tri{n}=1 + n /2, ⵉⴳ n ⵉⴳⴰ ⴰⵎⵎ. ///tri(1) = 3 /// ⴷⴰ ⵜⵜⵓⵙⵏⵎⵍ ⵜⴹⴰ ⵏ ⵜⵔⵉⴱⵓⵏⴰⵛⵉ ⵙ ⵓⵙⵏⵓⵍⴼⵓ: //ⵎⴰⵛⴰ, ⵎⴰ ⵓⵔ ⵉⵙⵙⵏ ⵓⴳⴷⵓⴷ ⵉⴳⴰ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⵔⵉⴱⵓⵏⴰⵛⵉ./// ⴽⵓ ⵢⴰⵏ ⵉⵙⵙⵏ ⵜⴰⵔⵔⴰⵢⵜ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ, ⵜⵜⵓⵙⵖⵔⴰⵏ ⵙ ⵓⴳⴳⴰⵔ ⵙⴳ ⵉⵎⵓⵙⵏⴰⵡⵏ ⵏ ⵜⵓⵙⵏⴰⴽⵜ ⴳ /// >>> tri(3)
/// vec![1, 3, 2, 8]
fn tri(n: isize) -> Vec<isize> {
","fn tri(n: isize) -> Vec<isize> {
    fn tribonacci(n: isize, memo: &mut Vec<isize>) -> isize {
        if n < memo.len() as isize {
            return memo[n as usize];
        }

        let result = if n == 1 {
            3
        } else if n % 2 == 0 {
            1 + n / 2
        } else {
            tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n + 1, memo)
        };

        if n as usize >= memo.len() {
            memo.resize(n as usize + 1, 0);
        }
        memo[n as usize] = result;
        result
    }

    let mut sequence = Vec::new();
    let mut memo = Vec::new();

    for i in 0..=n {
        sequence.push(tribonacci(i, &mut memo));
    }

    sequence
}","}

fn main() {
    let candidate = tri;
    assert_eq!(candidate(3), vec![1, 3, 2, 8]);
    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);
    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);
    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);
    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);
    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);
    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
    assert_eq!(candidate(0), vec![1]);
    assert_eq!(candidate(1), vec![1, 3]);
}
"
HumanEval_131,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⴰⵔ ⵏⵜⵜⵔⴰⵔ 0 ⵎⴽ ⴳⴰⵏ ⴰⴽⴽⵡ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ. /// ⴷⴰⵜ ⵏ ⵢⴰⵏ ⵉⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⴽⵔ ⴰⵙⵢⴰⴼⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ. /// >>> digits(1)
/// 1
/// >>> digits(4)
/// 0
/// >>> digits(235)
/// 15
fn digits(n: isize) -> isize {
","fn digits(n: isize) -> isize {
    let mut product = 1;
    let mut has_odd = false;
    let mut num = n;

    while num > 0 {
        let digit = num % 10;
        if digit % 2 != 0 {
            product *= digit;
            has_odd = true;
        }
        num /= 10;
    }

    if has_odd {
        product
    } else {
        0
    }
}

fn main() {
    println!(""{}"", digits(1));  // 1
    println!(""{}"", digits(4));  // 0
    println!(""{}"", digits(235)); // 15
}","}

fn main() {
    let candidate = digits;
    assert_eq!(candidate(5), 5);
    assert_eq!(candidate(54), 5);
    assert_eq!(candidate(120), 1);
    assert_eq!(candidate(5014), 5);
    assert_eq!(candidate(98765), 315);
    assert_eq!(candidate(5576543), 2625);
    assert_eq!(candidate(2468), 0);
}
"
HumanEval_132,tzm_Tfng,rs,"/// ⴳ ⵉⵍⵍⴰ ⴽⵔⴰ ⵏ ⵢⴰⵏ ⴳ ⵜⵔⴳⴰⵍⵉⵏ ⵏ ⵜⴹⴼⵉⵕⵜ. /// ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵔⴰⵔ true ⵎⴽ ⴷ ⵖⴰⵙ ⵎⴽ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴹⴼⴼⵓⵕ ⵏ ⵜⴷⵔⴰⵡⵜ ⵏ ⵜⴷⵔⴰⵡⵉⵏ /// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵎⵎ ⵉⵏⴽⵛⵓⵎⵏ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⵓⵙⴽⵉⵡⵉⵏ ⵜⵉⴽⵓⵢⵔⵉⵏ ⵅⴰⵙ./// >>> is_nested(String::from(""[[]]""))
/// true
/// >>> is_nested(String::from(""[]]]]]]][[[[[]""))
/// false
/// >>> is_nested(String::from(""[][]""))
/// false
/// >>> is_nested(String::from(""[]""))
/// false
/// >>> is_nested(String::from(""[[][]]""))
/// true
/// >>> is_nested(String::from(""[[]][[""))
/// true
fn is_nested(string: String) -> bool {
","fn is_nested(string: String) -> bool {
    let mut stack = Vec::new();
    let mut nested = false;

    for bracket in string.chars() {
        if bracket == '[' {
            stack.push(bracket);
        } else if bracket == ']' {
            if let Some(_) = stack.pop() {
                if !stack.is_empty() {
                    nested = true;
                }
            } else {
                return false;
            }
        }
    }

    nested
}

fn main() {
    println!(""{}"", is_nested(String::from(""[[]]""))); // true
    println!(""{}"", is_nested(String::from(""[]]]]]]][[[[[]""))); // false
    println!(""{}"", is_nested(String::from(""[][]""))); // false
    println!(""{}"", is_nested(String::from(""[]""))); // false
    println!(""{}"", is_nested(String::from(""[[][]]""))); // true
    println!(""{}"", is_nested(String::from(""[[]][[""))); // true
}","}

fn main() {
    let candidate = is_nested;
    assert_eq!(candidate(String::from(""[[]]"")), true);
    assert_eq!(candidate(String::from(""[]]]]]]][[[[[]"")), false);
    assert_eq!(candidate(String::from(""[][]"")), false);
    assert_eq!(candidate(String::from(""[]"")), false);
    assert_eq!(candidate(String::from(""[[[[]]]]"")), true);
    assert_eq!(candidate(String::from(""[]]]]]]]]]]"")), false);
    assert_eq!(candidate(String::from(""[][][[]]"")), true);
    assert_eq!(candidate(String::from(""[[]"")), false);
    assert_eq!(candidate(String::from(""[]]"")), false);
    assert_eq!(candidate(String::from(""[[]][["")), true);
    assert_eq!(candidate(String::from(""[[][]]"")), true);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""[[[[[[[["")), false);
    assert_eq!(candidate(String::from(""]]]]]]]]"")), false);
}
"
HumanEval_133,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵙⵙⵓⵜⵍ ⴽⵓ ⵢⴰⵏ ⴳ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⴱⵉⴽⵜⵓⵔ ⵙ ⵓⴼⵍⵍⴰ ⵏ int ((ⴰⴳⵏⴰⵔ) ⴳ ⵓⵎⵣⵡⴰⵔⵓ. /// ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔⴷ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵉⵎⴹⴰⵏ ⵏ ⵓⴽⵓⵥ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⴼⴽⴰⵏ, /// ⴰⴽⴽⵡ ⵏⵜⵜⴰⴼ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ. /// >>> lst(vec![1.0, 2.0, 3.0])
/// 14
/// >>> lst(vec![1.0, 4.0, 9.0])
/// 98
/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> lst(vec![1.4, 4.2, 0.0])
/// 29
/// >>> lst(vec![-2.4, 1.0, 1.0])
/// 6
fn sum_squares(lst: Vec<f64>) -> isize {
","fn sum_squares(lst: Vec<f64>) -> isize {
    lst.iter()
        .map(|&x| x.ceil() as isize)  // Round each element to the nearest upper integer
        .map(|x| x * x)               // Square each element
        .sum()                        // Sum all the squared elements
}

fn main() {
    println!(""{}"", sum_squares(vec![1.0, 2.0, 3.0])); // 14
    println!(""{}"", sum_squares(vec![1.0, 4.0, 9.0])); // 98
    println!(""{}"", sum_squares(vec![1.0, 3.0, 5.0, 7.0])); // 84
    println!(""{}"", sum_squares(vec![1.4, 4.2, 0.0])); // 29
    println!(""{}"", sum_squares(vec![-2.4, 1.0, 1.0])); // 6
}","}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);
    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);
    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);
    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);
    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);
    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);
    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);
    assert_eq!(candidate(vec![0.0]), 0);
    assert_eq!(candidate(vec![-1.0]), 1);
    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);
}
"
HumanEval_134,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵜⴰⵏⵏⴰⵢⵜ: ""ⴰⵡⴰⵍ"" ⵉⴳⴰ ⵜ ⵢⴰⵏ ⵓⴳⵔⴰⵡ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵜⵜⵓⵢⵙⴱⴹⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ. /// ⵢⴰⵏ ⵓⴳⵣⵣⵓⵎ ⵏ ⵜⴳⵓⵔⵉ, ⴷ ⵡⴰⵍⴰ ⵏⵉⵜⵏⵉ ⵓⵔ ⵉⴳⵉ. /// ⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵍⴰⵏ ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵍⴼⴰⵚⵜⵉⴽⵉ ⵓⵔ ⵉⴳⵉ /// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵎⵓⵖ ⴰⵎⴳⴳⴰⵔⵓ /// >>> check_if_last_char_is_a_letter(String::from(""apple pie""))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""apple pi e""))
/// true
/// >>> check_if_last_char_is_a_letter(String::from(""apple pi e ""))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""""))
/// false
fn check_if_last_char_is_a_letter(txt: String) -> bool {
","fn check_if_last_char_is_a_letter(txt: String) -> bool {
    if let Some(c) = txt.trim().chars().rev().next() {
        if c.is_alphabetic() {
            if let Some(prev_char) = txt.chars().rev().skip_while(|&ch| ch.is_whitespace()).nth(1) {
                return !prev_char.is_alphabetic();
            }
        }
    }
    false
}

fn main() {
    println!(""{}"", check_if_last_char_is_a_letter(String::from(""apple pie"")));  // false
    println!(""{}"", check_if_last_char_is_a_letter(String::from(""apple pi e""))); // true
    println!(""{}"", check_if_last_char_is_a_letter(String::from(""apple pi e ""))); // false
    println!(""{}"", check_if_last_char_is_a_letter(String::from("""")));           // false
}","}

fn main() {
    let candidate = check_if_last_char_is_a_letter;
    assert_eq!(candidate(String::from(""apple"")), false);
    assert_eq!(candidate(String::from(""apple pi e"")), true);
    assert_eq!(candidate(String::from(""eeeee"")), false);
    assert_eq!(candidate(String::from(""A"")), true);
    assert_eq!(candidate(String::from(""Pumpkin pie "")), false);
    assert_eq!(candidate(String::from(""Pumpkin pie 1"")), false);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""eeeee e "")), false);
    assert_eq!(candidate(String::from(""apple pie"")), false);
    assert_eq!(candidate(String::from(""apple pi e "")), false);
}
"
HumanEval_135,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⴰⵜⵉⴳⵏ ⵉⵎⵢⴰⵍⵍⴰⵏ. /// ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵉⴼⵔⴷⵉⵙ ⴰⴷ, ⵔⴰⴷ ⵏⵔⴰⵔ -1. ⵓⵔ ⵔⴰⴷ ⵉⵟⵟⴰⴼ ⵓⵡⵉⴽⵜⵓⵔ ⴰⴷ /// ⵓⵔ ⵢⴰⴷ ⵢⵓⴳⴰⵔ ⵏⵖ ⵓⵔ ⵢⴰⴽⵙⵓⵍ ⴷ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ./// ⵙⴽⵔ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⴰⵙⵖⵍ ⴰⵎⵇⵔⴰⵏ ⵏ ⵢⴰⵏ ⵉⴼⵔⴷⵉⵙ ⵏⵏⴰ /// >>> can_arrange(vec![1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(vec![1, 2, 3])
/// -1
fn can_arrange(arr: Vec<isize>) -> isize {
","fn can_arrange(arr: Vec<isize>) -> isize {
    for i in (1..arr.len()).rev() {
        if arr[i] < arr[i - 1] {
            return i as isize;
        }
    }
    -1
}

// Example usage:
// fn main() {
//     println!(""{}"", can_arrange(vec![1, 2, 4, 3, 5])); // Outputs: 3
//     println!(""{}"", can_arrange(vec![1, 2, 3])); // Outputs: -1
// }","}

fn main() {
    let candidate = can_arrange;
    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);
    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);
    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);
    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);
    assert_eq!(candidate(Vec::<isize>::new()), -1);
}
"
HumanEval_136,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴳⴳⵓⵜⵏ ⵏⵖⴷ ⵉⵔⵡⵉⵏ, ⵙⵙⵓⴼⵖ-ⴰⵙ None. /// ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵢⴰⵏ ⵓⴱⴰⵢⵢⵓⵕ. /// ⵉⴳⴰ ⴰⵎⵇⵇⵔⴰⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵔⴳⴳⵏ, ⴷ ""ⴱ"" ⵉⴳⴰ ⴰⵎⵥⵥⵢⴰⵏ /// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⴰⵔⵔⴰⵢⵜ ⵏ ⵜⴱⵔⴳⴰⵍⵜ (a, b), ⴳ ⵉⵍⵍⴰ 'a' /// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])
/// (None, Some(1))
/// >>> largest_smallest_integers(vec![])
/// (None, None)
/// >>> largest_smallest_integers(vec![0])
/// (None, None)
fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {
","fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {
    let mut largest_negative: Option<isize> = None;
    let mut smallest_positive: Option<isize> = None;

    for &num in &lst {
        if num < 0 {
            largest_negative = match largest_negative {
                Some(largest) => Some(largest.max(num)),
                None => Some(num),
            };
        } else if num > 0 {
            smallest_positive = match smallest_positive {
                Some(smallest) => Some(smallest.min(num)),
                None => Some(num),
            };
        }
    }

    (largest_negative, smallest_positive)
}

fn main() {
    println!(""{:?}"", largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])); // (None, Some(1))
    println!(""{:?}"", largest_smallest_integers(vec![])); // (None, None)
    println!(""{:?}"", largest_smallest_integers(vec![0])); // (None, None)
    println!(""{:?}"", largest_smallest_integers(vec![-5, -1, -3, 0, 2, 3])); // (Some(-1), Some(2))
}","}

fn main() {
    let candidate = largest_smallest_integers;
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));
    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));
    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));
    assert_eq!(candidate(Vec::<isize>::new()), (None, None));
    assert_eq!(candidate(vec![0]), (None, None));
    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));
    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));
    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));
    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));
}
"
HumanEval_138,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ /// ⵙⵙⴼⵔⴰⵢ ⵎⴽ ⵜⵣⵎⵔⵎ ⴰⴷ ⵜⵔⴰⵔⴷ ⴰⵎⴹⴰⵏ n ⴰⵎⵎ ⵓⴳⵣⵓⵎ ⵏ 4 ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵎⵓⴹⴰⵏⵏ ⵉⴽⵙⵡⴰⵜⵏ /// >>> is_equal_to_sum_even(4)
/// false
/// >>> is_equal_to_sum_even(6)
/// false
/// >>> is_equal_to_sum_even(8)
/// true
fn is_equal_to_sum_even(n: isize) -> bool {
","fn is_equal_to_sum_even(n: isize) -> bool {
    // A number n can be expressed as the sum of 4 positive even numbers if and only if
    // it is greater than or equal to 8 and even
    n >= 8 && n % 2 == 0
}

// Test cases
fn main() {
    println!(""{}"", is_equal_to_sum_even(4));  // false
    println!(""{}"", is_equal_to_sum_even(6));  // false
    println!(""{}"", is_equal_to_sum_even(8));  // true
}","}

fn main() {
    let candidate = is_equal_to_sum_even;
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), true);
    assert_eq!(candidate(11), false);
    assert_eq!(candidate(12), true);
    assert_eq!(candidate(13), false);
    assert_eq!(candidate(16), true);
}
"
HumanEval_139,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⴳ ⵉⵍⵍⴰ n > 0 /// brazilian_factorial{n} = n! * (n-1)! * (n-2)! * ... * 1! /// ⴷⴰ ⵉⵜⵜⵓⵙⵏⵎⵍ ⵓⴼⴰⴽⵜⵓⵔⵉⴰⵍ ⴰⴱⵕⴰⵣⵉⵍⵉ ⵙ: /// >>> special_factorial(4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
fn special_factorial(n: isize) -> isize {
","fn factorial(n: isize) -> isize {
    (1..=n).product()
}

fn special_factorial(n: isize) -> isize {
    (1..=n).map(factorial).product()
}

fn main() {
    let result = special_factorial(4);
    println!(""{}"", result);
}","}

fn main() {
    let candidate = special_factorial;
    assert_eq!(candidate(4), 288);
    assert_eq!(candidate(5), 34560);
    assert_eq!(candidate(7), 125411328000);
    assert_eq!(candidate(1), 1);
}
"
HumanEval_140,tzm_Tfng,rs,"/// ⴹⴰⵕⵜ ⵓⵢⴰ, ⵙⵙⵓⵜⵍ ⴰⴽⴽⵡ ⵉⵎⵙⴷⴷⴰⵔⵏ ⵙ - /// ⴷ ⵎⴽ ⴷⴰⵔ ⵢⴰⵏ ⵓⵖⵉⵍⴰⵍ ⵓⴳⴳⴰⵔ ⵏ 2 ⵏ ⵡⴰⵏⵙⴰ ⵉⵎⴹⴼⴰⵕⵏ, /// ⴷⴰⵜ ⵏ ⵢⴰⵏ ⵓⴹⵕⵉⵚ ⵏ ⵓⵥⵟⵟⴰ, ⵙⵏⴼⵍ ⴰⴽⴽⵡ ⵉⴷⵖⴰⵔⵏ ⴳⵉⵙ ⵙ ⵉⵙⵡⵉⵔⴰ, /// >>> fix_spaces(String::from("" Example""))
/// String::from(""Example"")
/// >>> fix_spaces(String::from("" Example 1""))
/// String::from(""Example_1"")
/// >>> fix_spaces(String::from("" Example 2""))
/// String::from(""_Example_2"")
/// >>> fix_spaces(String::from("" Example 3""))
/// String::from(""_Example-3"")
fn fix_spaces(text: String) -> String {
","fn fix_spaces(text: String) -> String {
    let mut result = String::new();
    let mut space_count = 0;

    for c in text.chars() {
        if c == ' ' {
            space_count += 1;
        } else {
            if space_count > 2 {
                result.push('-');
            } else if space_count > 0 {
                result.push_str(&""_"".repeat(space_count));
            }
            result.push(c);
            space_count = 0;
        }
    }

    if space_count > 2 {
        result.push('-');
    } else if space_count > 0 {
        result.push_str(&""_"".repeat(space_count));
    }
    
    result
}","}

fn main() {
    let candidate = fix_spaces;
    assert_eq!(candidate(String::from(""Example"")), String::from(""Example""));
    assert_eq!(candidate(String::from(""Mudasir Hanif "")), String::from(""Mudasir_Hanif_""));
    assert_eq!(candidate(String::from(""Yellow Yellow  Dirty  Fellow"")), String::from(""Yellow_Yellow__Dirty__Fellow""));
    assert_eq!(candidate(String::from(""Exa   mple"")), String::from(""Exa-mple""));
    assert_eq!(candidate(String::from(""   Exa 1 2 2 mple"")), String::from(""-Exa_1_2_2_mple""));
}
"
HumanEval_141,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// - ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵓⵙⴽⴽⵉⵍ ⵏ ⴷⴼⴼⵉⵔ ⵏ ⵜⵓⵙⴷⵉⴷⵜ ⵢⴰⵏ ⵙⴳ ⵡⵉⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ: ['txt', 'exe', 'dll'] /// ⴰⵍⴰⴼⵉⴱⵉⵜ ⴰⵍⴰⵜⵉⵏⵉ ('a'-'z' ⴷ 'A'-'Z'). /// - ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵢⵉⵍⵉ ⵡⴰⵏⵙⴰ ⴷⴰⵜ ⵏ ⵜⵓⵙⴷⵉⴷⵜ, ⴰⵔ ⵜⴱⴷⴰⴷ ⵙ ⵓⴱⵔⴰⵜ ⵙⴳ /// - ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⵉⵍⵍⴰ ⴳⵉⵙ ⵢⴰⵏ ⵓⴱⵔⵛⴽ '.' /// - ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵉⵍⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⴽⵕⴰⴹ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ('0'-'9') ⴳ ⵉⵙⵎ ⵏ ⵓⴷⵍⵉⵙ. /// ⵜⵜⵓⵙⵎⵓⵏ: /// ⴷⴰ ⵉⵜⵜⵓⵙⵎⴳⴰⵍ ⵢⵉⵙⵎ ⵏ ⵓⴷⵍⵉⵙ ⵙ ⵉⵙⵎ ⵉⵖ ⵉⵖ ⴷⴰⵔⵙ ⴽⵓⵍⵍⵓ ⵜⵎⵙⴰⵔⵉⵏ ⴰⴷ /// ""ⴰⵢⵢⵉ"" ⵎⴽ ⵉⴳⴰ ⵢⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⴰⵣⵔⴼⴰⵏ, ⴰⵔ ⵉⵙⵙⴼⵍⴷ ""ⵓⵀⵓ"" ⵎⴽ ⵓⵔ ⵉⴳⵉ. /// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏ ⵉⵙⵎ ⵏ ⵓⵡⵉⴽⵉ, ⴰⵔ ⵉⵜⵜⵔ /// >>> file_name_check(String::from(""example.txt""))
/// String::from(""Yes"")
/// >>> file_name_check(String::from(""1example.dll""))
/// String::from(""No"")
fn file_name_check(file_name: String) -> String {
","fn file_name_check(file_name: String) -> String {
    let parts: Vec<&str> = file_name.split('.').collect();

    if parts.len() != 2 {
        return String::from(""No"");
    }

    let before_dot = parts[0];
    let after_dot = parts[1];

    if before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic() {
        return String::from(""No"");
    }

    let digit_count = before_dot.chars().filter(|c| c.is_digit(10)).count();
    if digit_count > 3 {
        return String::from(""No"");
    }

    match after_dot {
        ""txt"" | ""exe"" | ""dll"" => String::from(""Yes""),
        _ => String::from(""No""),
    }
}","}

fn main() {
    let candidate = file_name_check;
    assert_eq!(candidate(String::from(""example.txt"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""1example.dll"")), String::from(""No""));
    assert_eq!(candidate(String::from(""s1sdf3.asd"")), String::from(""No""));
    assert_eq!(candidate(String::from(""K.dll"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""MY16FILE3.exe"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""His12FILE94.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""_Y.txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""?aREYA.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""/this_is_valid.dll"")), String::from(""No""));
    assert_eq!(candidate(String::from(""this_is_valid.wow"")), String::from(""No""));
    assert_eq!(candidate(String::from(""this_is_valid.txt"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""this_is_valid.txtexe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""#this2_i4s_5valid.ten"")), String::from(""No""));
    assert_eq!(candidate(String::from(""@this1_is6_valid.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""this_is_12valid.6exe4.txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""all.exe.txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""I563_No.exe"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""Is3youfault.txt"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""no_one#knows.dll"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""1I563_Yes3.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""I563_Yes3.txtt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""final..txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""final132"")), String::from(""No""));
    assert_eq!(candidate(String::from(""_f4indsartal132."")), String::from(""No""));
    assert_eq!(candidate(String::from("".txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""s."")), String::from(""No""));
}
"
HumanEval_142,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⴰⴷ ⵉⵙⵏⴼⵍ ⵉⵙⴽⴽⵉⵍⵏ ⴳ ⵓⴱⴰⵢⵢⵓⵕ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵉⵏⵓⴹⵏ ⵏⵏⵙ ⴰⵎⵎ ⴽⵉⴳⴰⵏ ⵏ 3 ⵏⵖ 4. ⵔⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⴰⴽⴽⵡ./// ⴰⴳⴳⵓ ⵏ 3 ⴷ ⵔⴰⴷ ⵉⵙⴽⵔ ⵜⴰⴽⴰⴱⴰⵔⵜ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⴳⴳⵓ ⵏ 4 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⴳⴳⵓ ⵏ 3. ⵓⵔ ⵔⴰⴷ ⵜⴽⴽⵉ ⵜⵎⵔⵙⵍⵜ /// ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⴽⴽⵉ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵉ ⴽⵓⵍⵍⵓ ⵉⵎⴷⵢⴰⵡⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ, ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⴽⴽⵉ ⴰⵎⴽⴽⵓⵥ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ /// ""  ⴰⴱⵔⴱⵔⵉⴷ/// >>> lst
/// vec![1, 2, 3]
/// >>> lst
/// vec![]
/// >>> lst
/// vec![-1, -5, 2, -1, -5]
fn sum_squares(lst: Vec<isize>) -> isize {
","fn sum_squares(lst: Vec<isize>) -> isize {
    lst.into_iter()
        .enumerate()
        .map(|(i, value)| {
            if i % 3 == 0 {
                value * value
            } else if i % 4 == 0 {
                value * value * value
            } else {
                value
            }
        })
        .sum()
}

fn main() {
    let lst = vec![1, 2, 3];
    println!(""{}"", sum_squares(lst)); // Outputs: 14

    let lst = vec![];
    println!(""{}"", sum_squares(lst)); // Outputs: 0

    let lst = vec![-1, -5, 2, -1, -5];
    println!(""{}"", sum_squares(lst)); // Outputs: 112
}","}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1, 2, 3]), 6);
    assert_eq!(candidate(vec![1, 4, 9]), 14);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);
    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);
    assert_eq!(candidate(vec![0]), 0);
    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);
    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);
    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);
    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);
    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);
}
"
HumanEval_143,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ 1: /// ⴰⴷ ⵜⴳ ⵜⴳⵓⵔⵉ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴳ ⵜⵣⵍⵉⵜ ⵜⴰⵎⴰⵢⵏⵓⵜ ⴰⵎⵎ ⵜⵉⵣⵍⵉⵜ ⵏ ⵓⵣⵡⵍ. /// ⵉⴳⴰⵏ ⵜⵉⵖⵣⵉ ⵏⵏⵙ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ, /// ⴷ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵔⵉⵜ ⵙ ⵜⵙⵏⵜⴰⵢⵜ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵜⴳⵓⵔⵉ ⵜⴰⵢⵎⵎⴰⵜ, /// ⵜⴰⴳⵓⵔⵉ ⵜⵍⴰ ⴽⵔⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵜⵜⵓⵣⵍⴰⵢⵏ ⵙ ⵢⴰⵏ ⵓⵙⴰⵢⵔⴰⵔ, ///ⵜⵜⵜⵢⴰⴽⴽⴰ ⵢⴰⵜ ⵜⵍⴳⴰⵎⵜ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵜ ⵜⵡⵏⴳⵉⵎⵜ, /// >>> words_in_sentence(String::from(""This is a test""))
/// String::from(""is"")
/// Example 2:
/// >>> words_in_sentence(String::from(""lets go for swimming""))
/// String::from(""go for"")
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
fn words_in_sentence(sentence: String) -> String {
","fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn words_in_sentence(sentence: String) -> String {
    let words: Vec<&str> = sentence.split_whitespace().collect();
    let prime_length_words: Vec<&str> = words
        .iter()
        .filter(|&&word| is_prime(word.len()))
        .cloned()
        .collect();
    prime_length_words.join("" "")
}

fn main() {
    assert_eq!(
        words_in_sentence(String::from(""This is a test"")),
        String::from(""is"")
    );
    assert_eq!(
        words_in_sentence(String::from(""lets go for swimming"")),
        String::from(""go for"")
    );
}","}

fn main() {
    let candidate = words_in_sentence;
    assert_eq!(candidate(String::from(""This is a test"")), String::from(""is""));
    assert_eq!(candidate(String::from(""lets go for swimming"")), String::from(""go for""));
    assert_eq!(candidate(String::from(""there is no place available here"")), String::from(""there is no place""));
    assert_eq!(candidate(String::from(""Hi I am Hussein"")), String::from(""Hi am Hussein""));
    assert_eq!(candidate(String::from(""go for it"")), String::from(""go for it""));
    assert_eq!(candidate(String::from(""here"")), String::from(""""));
    assert_eq!(candidate(String::from(""here is"")), String::from(""is""));
}
"
HumanEval_144,tzm_Tfng,rs,"/// ⴰⴷ ⵜⵙⵙⵏⵎ ⵉⵙ ⴳⴰⵏ x, ⴷ n ⵉⵙⴽⵍⴰⵢⵏ ⵉⵣⵔⴼⴰⵏ, ⴷ ⵓⵔ ⵖⵓⵔⵙⵏ ⴰⵔⴰ ⴰⵎⵢⴰ ⴰⵎ ⵉⵎⵙⵙⴰⵖⵏ. /// <numerator>/<denominator> ⴳⴰⵏ ⵉⵎⵉⴹⴰⵏ ⴷ ⵉⵎⵙⵙⴰⵖⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵓⴼⴰⵢⵏ. /// ⵙ ⵡⵉⵢⵢⴰⴹ. x ⴷ n, ⴳⴰⵏ ⴰⵙⵎⴷⵢⴰ ⵏ ⵜⵉⴼⵔⴽⵜ, ⴷ ⵖⵓⵔⵙⵏ ⵜⴰⵍⵖⴰ ⴷ ⵢⵓⵛⴽⴰⵏ, /// x * n. ⴷⴰ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ true ⵎⴽ ⵜⵙⵙⵎⵔⴰⵙ x * n ⵉ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴷ false /// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵔⵎ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵔⴰⴷ ⵉⵙⴱⴷⴷⴰⴷ ⵜⴰⴳⵓⵔⵉ /// >>> simplify(String::from(""1/5""), String::from(""5/1""))
/// true
/// >>> simplify(String::from(""1/6""), String::from(""2/1""))
/// false
/// >>> simplify(String::from(""7/10""), String::from(""10/2""))
/// false
fn simplify(x: String, n: String) -> bool {
","fn gcd(a: u32, b: u32) -> u32 {
    if b == 0 {
        a
    } else {
        gcd(b, a % b)
    }
}

fn simplify(x: String, n: String) -> bool {
    let x_parts: Vec<&str> = x.split('/').collect();
    let n_parts: Vec<&str> = n.split('/').collect();
    
    let x_num: u32 = x_parts[0].parse().unwrap();
    let x_den: u32 = x_parts[1].parse().unwrap();
    let n_num: u32 = n_parts[0].parse().unwrap();
    let n_den: u32 = n_parts[1].parse().unwrap();
    
    let result_num = x_num * n_num;
    let result_den = x_den * n_den;
    
    let gcd_value = gcd(result_num, result_den);
    
    result_den / gcd_value == 1
}","}

fn main() {
    let candidate = simplify;
    assert_eq!(candidate(String::from(""1/5""), String::from(""5/1"")), true);
    assert_eq!(candidate(String::from(""1/6""), String::from(""2/1"")), false);
    assert_eq!(candidate(String::from(""5/1""), String::from(""3/1"")), true);
    assert_eq!(candidate(String::from(""7/10""), String::from(""10/2"")), false);
    assert_eq!(candidate(String::from(""2/10""), String::from(""50/10"")), true);
    assert_eq!(candidate(String::from(""7/2""), String::from(""4/2"")), true);
    assert_eq!(candidate(String::from(""11/6""), String::from(""6/1"")), true);
    assert_eq!(candidate(String::from(""2/3""), String::from(""5/2"")), false);
    assert_eq!(candidate(String::from(""5/2""), String::from(""3/5"")), false);
    assert_eq!(candidate(String::from(""2/4""), String::from(""8/4"")), true);
    assert_eq!(candidate(String::from(""2/4""), String::from(""4/2"")), true);
    assert_eq!(candidate(String::from(""1/5""), String::from(""5/1"")), true);
    assert_eq!(candidate(String::from(""1/5""), String::from(""1/5"")), false);
}
"
HumanEval_145,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⵙⵙⵓⴷⵙⵏⵜ ⵅⴼ ⵓⵙⵏⵎⵍ ⵏⵏⵙⵏⵜ ⴳ ⵓⴱⴰⵢⵢⵓⵕ ⴰⵎⵣⵡⴰⵔⵓ. /// ⴰⵖⵏⵏⵉⵊ: ⵎⴽ ⵍⵍⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵙ ⵓⵖⵣⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ, /// ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ. /// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵙⵎⵓⵏⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ /// >>> order_by_points(vec![1, 11, -1, -11, -12])
/// vec![-1, -11, 1, -12, 11]
/// >>> order_by_points(vec![])
/// Vec::<isize>::new()
fn order_by_points(nums: Vec<isize>) -> Vec<isize> {
","fn order_by_points(nums: Vec<isize>) -> Vec<isize> {
    let mut nums_with_indices: Vec<(isize, usize)> = nums.iter().cloned().enumerate().collect();

    nums_with_indices.sort_by_key(|&(num, index)| {
        let sum_of_digits = num.abs().to_string().chars().map(|c| c.to_digit(10).unwrap_or(0) as isize).sum::<isize>();
        (sum_of_digits, index)
    });

    nums_with_indices.iter().map(|&(num, _)| num).collect()
}

fn main() {
    // Example usage
    let sorted = order_by_points(vec![1, 11, -1, -11, -12]);
    println!(""{:?}"", sorted); // Output: [-1, -11, 1, -12, 11]
}","}

fn main() {
    let candidate = order_by_points;
    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);
    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);
}
"
HumanEval_146,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⴷ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⵓⴳⴳⴰⵔⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵓⵔ ⵉⵎⵢⴰⵏⴰⵡⵏ (1, 3, 5, 7, 9). /// ⴰⵎⴹⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵎⵓⴷⴷⵓ ⵏⵏⴰ ⵢⵓⴳⵔⵏ 10 ⴷ ⵙⵏⴰⵜ /// ⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏⵏ ⴰⵎⵎ ⵉⵏⴽⵛⵓⵎⵏ ⴷ ⵉⵙⵏⴼⴰⵍⵏ /// >>> specialFilter(vec![15, -73, 14, -15])
/// 1
/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])
/// 2
fn specialFilter(nums: Vec<isize>) -> isize {
","fn specialFilter(nums: Vec<isize>) -> isize {
    nums.into_iter().filter(|&num| {
        let abs_num = num.abs();
        abs_num > 10 && {
            let digits: Vec<u8> = abs_num.to_string().bytes().map(|b| b - b'0').collect();
            let first_digit = digits.first().unwrap();
            let last_digit = digits.last().unwrap();
            first_digit % 2 == 1 && last_digit % 2 == 1
        }
    }).count() as isize
}

// Example usage:
// fn main() {
//     let result1 = specialFilter(vec![15, -73, 14, -15]);
//     println!(""{}"", result1); // Output: 1

//     let result2 = specialFilter(vec![33, -2, -3, 45, 21, 109]);
//     println!(""{}"", result2); // Output: 2
// }","}

fn main() {
    let candidate = specialFilter;
    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);
    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);
    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);
    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);
    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
}
"
HumanEval_147,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// ⴷ a[i] + a[j] + a[k] ⴷ ⴰⵎⵔⴽⵙ ⵏ 3. /// ⴰⵔ ⵏⵜⵜⴰⴼⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵔⴱⴰⵜⵉⵏ (a[i], a[j], a[k]) ⵏ a ⴳ i < j < k, /// ⵉ ⴽⵓ i (1 ≤ i ≤ n), ⴰⵜⵉⴳ ⵏ a[i] = i * i - i + 1. /// ⴰⵖ ⵜⵜⵓⴼⴽⴰ ⵉⴽ ⵢⴰⵏ ⵉⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n. ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⵙⴽⵔⴷ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⴰⵎⴷⴷⴰⴷ a ⵏ ⵜⵉⵖⵣⵉ n. /// >>> get_max_triples(5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
fn get_max_triples(n: isize) -> isize {
","fn get_max_triples(n: isize) -> isize {
    let mut a = Vec::new();
    for i in 1..=n {
        a.push(i * i - i + 1);
    }
    
    let mut count = 0;
    for i in 0..n {
        for j in i+1..n {
            for k in j+1..n {
                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {
                    count += 1;
                }
            }
        }
    }
    count
}

fn main() {
    println!(""{}"", get_max_triples(5)); // Output: 1
}","}

fn main() {
    let candidate = get_max_triples;
    assert_eq!(candidate(5), 1);
    assert_eq!(candidate(6), 4);
    assert_eq!(candidate(10), 36);
    assert_eq!(candidate(100), 53361);
}
"
HumanEval_149,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⴰⴷ ⵜⵙⵙⵏⵎ ⵉⵙ ⴽⵓⵍⵍⵓ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵔⴰⴷ ⵖⵓⵔⵙⵏ ⵜⵉⵖⵣⵉ ⵜⴰⵣⴳⵣⴰⵡⵜ. /// ⵔⴰⴷ ⵜⵕⵜⵓⵔⵏ ⵜⵡⵡⵓⵔⵉ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵓⵙⵙⵓⴷⵙ. /// ⵎⴽ ⴷⴰⵔ ⵙⵏⴰⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵜⵉⵖⵣⵉ ⵜⴰⵣⴳⵣⴰⵡⵜ, ⵙⵙⵓⴷⵙ ⵓⵡⵉⴽⵜⵓⵔ ⵙ ⵜⴰⵍⵖⴰ ⵜⴰⵡⴰⵍⴰⵏⵜ. /// ⴰⴷ ⵢⴰⴽⵣ ⵉ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵓⵍⵓⴳ. /// ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵜⴰⵡⵡⵓⵔⵜ ⵏ ⵓⴽⵜⵓⵔ ⵙ ⵓⵖⵣⵓ ⵏ ⴽⵓ ⵜⴳⵓⵔⵉ, ⴷ ⵔⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ /// ⴰⴷ ⵖⵓⵔⵙ ⵉⵍⵉⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⴰⵍⵍⴰⵏ. /// ⵉⴳⴰ ⵓⵡⵉⴽⵜⵓⵔ ⴰⵀⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵓⵔ ⵉⴳⵉ ⴰⵀⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏⵏ, /// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⴰⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⴳⵏ ⵙ ⵢⴰⵜ ⵜⵙⵏⵙⵉ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⴳⵏ, /// ⴷⴰ ⵉⵙⴽⵙⵉⵡ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵓⵣⵣⵉⴳⵣ ⴰⵎⵢⵉⵡⵏ ⵙⴳ ⵜ, /// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴰⵎⵎ ⵓⴱⴰⵔⴰⵣ, /// >>> list_sort(vec![String::from(""aa""), String::from(""a""), String::from(""aaa"")])
/// vec![String::from(""aa"")]
/// >>> list_sort(vec![String::from(""ab""), String::from(""a""), String::from(""aaa""), String::from(""cd"")])
/// vec![String::from(""ab""), String::from(""cd"")]
fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {
","fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {
    let mut even_length_strings: Vec<String> = lst
        .into_iter()
        .filter(|s| s.len() % 2 == 0)
        .collect();
    
    even_length_strings.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));
    
    even_length_strings
}

fn main() {
    let result = sorted_list_sum(vec![
        String::from(""aa""),
        String::from(""a""),
        String::from(""aaa""),
    ]);
    println!(""{:?}"", result); // Should print: [""aa""]

    let result = sorted_list_sum(vec![
        String::from(""ab""),
        String::from(""a""),
        String::from(""aaa""),
        String::from(""cd""),
    ]);
    println!(""{:?}"", result); // Should print: [""ab"", ""cd""]
}","}

fn main() {
    let candidate = sorted_list_sum;
    assert_eq!(candidate(vec![String::from(""aa""), String::from(""a""), String::from(""aaa"")]), vec![String::from(""aa"")]);
    assert_eq!(candidate(vec![String::from(""school""), String::from(""AI""), String::from(""asdf""), String::from(""b"")]), vec![String::from(""AI""), String::from(""asdf""), String::from(""school"")]);
    assert_eq!(candidate(vec![String::from(""d""), String::from(""b""), String::from(""c""), String::from(""a"")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""d""), String::from(""dcba""), String::from(""abcd""), String::from(""a"")]), vec![String::from(""abcd""), String::from(""dcba"")]);
    assert_eq!(candidate(vec![String::from(""AI""), String::from(""ai""), String::from(""au"")]), vec![String::from(""AI""), String::from(""ai""), String::from(""au"")]);
    assert_eq!(candidate(vec![String::from(""a""), String::from(""b""), String::from(""b""), String::from(""c""), String::from(""c""), String::from(""a"")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""aaaa""), String::from(""bbbb""), String::from(""dd""), String::from(""cc"")]), vec![String::from(""cc""), String::from(""dd""), String::from(""aaaa""), String::from(""bbbb"")]);
}
"
HumanEval_150,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵔⴰⴷ ⵢⴰⴽⴽⴰ ⴰⵜⵉⴳ ⵏ y ⵎⴽ ⵓⵔ ⵉⴳⵉ. /// ⴰⵖⴰⵡⴰⵙ ⴰⵎⵢⵉⵡⵏ ⵏⵏⴰ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⴰ ⴰⵜⵉⴳ ⵏ x ⵎⴽ ⵜⴳⴰ n /// >>> x_or_y(7, 34, 12)
/// 34
/// >>> x_or_y(15, 8, 5)
/// 5
fn x_or_y(n: isize, x: isize, y: isize) -> isize {
","fn x_or_y(n: isize, x: isize, y: isize) -> isize {
    fn is_prime(num: isize) -> bool {
        if num <= 1 {
            return false;
        }
        for i in 2..=((num as f64).sqrt() as isize) {
            if num % i == 0 {
                return false;
            }
        }
        true
    }
    
    if is_prime(n) {
        x
    } else {
        y
    }
}

fn main() {
    println!(""{}"", x_or_y(7, 34, 12)); // Output: 34
    println!(""{}"", x_or_y(15, 8, 5)); // Output: 5
}","}

fn main() {
    let candidate = x_or_y;
    assert_eq!(candidate(7, 34, 12), 34);
    assert_eq!(candidate(15, 8, 5), 5);
    assert_eq!(candidate(3, 33, 5212), 33);
    assert_eq!(candidate(1259, 3, 52), 3);
    assert_eq!(candidate(7919, -1, 12), -1);
    assert_eq!(candidate(3609, 1245, 583), 583);
    assert_eq!(candidate(91, 56, 129), 129);
    assert_eq!(candidate(6, 34, 1234), 1234);
    assert_eq!(candidate(1, 2, 0), 0);
    assert_eq!(candidate(2, 2, 0), 2);
}
"
HumanEval_151,tzm_Tfng,rs,"/// ⴳ ⵓⴱⴰⵢⵢⵓⵕ ⵏⵏⴰ ⵓⵔ ⵉⵎⵢⴰⵏⴰⵡⵏ. ⵔⴰⴷ ⵏⵙⵙⵏ ⵉⵎⴹⴰⵏⵏ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⴷⴷⴰⴷⵏ./// ⴰⵛⴽⵓ ⵏⵙⴽⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏⵏ, ⵏⵙⵙⴽⵔ ⴰⵙⵖⵍ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵏ ⵡⵓⵟⵟⵓⵏⵏ /// >>> double_the_difference(vec![1, 3, 2, 0])
/// 10
/// >>> double_the_difference(vec![-1, -2, 0])
/// 0
/// >>> double_the_difference(vec![9, -2])
/// 81
/// >>> double_the_difference(vec![0])
/// 0
/// If the input vector is empty, return 0.
fn double_the_difference(lst: Vec<f64>) -> isize {
","fn double_the_difference(lst: Vec<f64>) -> isize {
    lst.iter()
        .filter(|&&x| x.fract() == 0.0 && x > 0.0 && x as isize % 2 != 0)
        .map(|&x| (x as isize).pow(2))
        .sum()
}

fn main() {
    println!(""{}"", double_the_difference(vec![1.0, 3.0, 2.0, 0.0])); // 10
    println!(""{}"", double_the_difference(vec![-1.0, -2.0, 0.0])); // 0
    println!(""{}"", double_the_difference(vec![9.0, -2.0])); // 81
    println!(""{}"", double_the_difference(vec![0.0])); // 0
    println!(""{}"", double_the_difference(vec![])); // 0
}","}

fn main() {
    let candidate = double_the_difference;
    assert_eq!(candidate(Vec::<f64>::new()), 0);
    assert_eq!(candidate(vec![5.0, 4.0]), 25);
    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);
    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);
    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);
    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);
    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);
}
"
HumanEval_152,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// ⴰⵜⵉⴳ ⵏⵏⴻⵙ ⵉⴳⴰ 0, ⵎⴽ ⵓⵔ ⵉⴳⵉ, ⴰⵜⵉⴳ ⵏⵏⴻⵙ ⵉⴳⴰ ⵜ ⵓⴱⴻⵣⵣⵉⵣⵍ ⴰⴱⴻⵍⴰⵡⵏ ⴳⴻⵔ ⵓⵙⵏⵓⵎⵎⵍ ⴷ ⵓⴽⵜⵓⵎ./// ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⵉⵖⵣⵉ ⵏⵏⴰ ⴷ ⵢⴰⴽⴽⴰⵏ ⵜⴰⵖⵣⵉ ⵏ ⴽⵓ ⴰⵙⵏⵓⵎⵎⵍ. ⵎⴽ ⵜⵔⵎⵙⴷ ⵙ ⵜⴷⵓⵙⵉ, /// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵏ ⵜⵏⵇⵇⵉⵟⵉⵏ ⴷ ⵉⵙⵏⵓⵎⵎⴰⵍⵏ ⵏ ⵜⵉⵖⵣⵉ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⴳ ⴽⵓ ⵢⴰⵏ ⵏ ⵉⵙⵏⵎⵍⵏ ⴷⴰ ⵉⵙⵙⴼⵔⴰⵢ ⵢⴰⵏ ⵓⵎⵙⴰⵙⴰ. /// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⵎ ⵎⴽ ⵜⵙⵙⵏ ⵢⴰⵏ ⵓⴼⴳⴰⵏ ⵙ ⵜⴷⵓⵙⵉ ⵜⵢⴰⴼⵓⵜⵉⵏ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵎⵃⵉⵣⵡⴰⵔⵏ. /// ⵙ ⵡⴰⴷⴷⴰⴷ ⵉⵖⵓⴷⴰⵏ ⴰⴷ ⵏⵙⵙⴽⵜⵉ ⴷ ⴰⴷ ⵏⵙⵎⵣⴰⵣⴰⵍ. /// ⴰⵖⴰⵡⴰⵙ ⵉⵜⵜⵓⵙⵙⴰⵏ ⴳ ⵜⴳⵉⵔⴰ. ⵥⴹⴰⵕⵏ ⵉⵙⵏⴼⵍⵏ ⴷ ⵜⵡⵏⴳⵉⵎⵉⵏ ⵏⵏⴰ ⵖⵓⵔⴽ ⴳ ⵜⵉⵣⵉ ⴰⴷ ⴰⴷ ⴳⵉⵏ /// ⵀⴰⵜ ⵓⵔ ⵏⵏⵉⵖ ⴰⴽⴽⵡ ⵎⴰⵙ ⵏⵙⵙⵏ ⵉⵙ ⵉⴳⴰ ⵡⵏⵏⵓ ⵏ ⴽⵔⴰ ⵏ ⵓⵙⵓⵔⵙ ⵉⵜⵜⵓⵣⵎⵎⴰⵔⵏ ⵣⵉ ⵣⵉⴽⴽ /// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])
/// vec![0, 0, 0, 0, 3, 3]
/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])
/// vec![4, 4, 1, 0, 0, 6]
fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {
","fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {
    game.iter()
        .zip(guess.iter())
        .map(|(g, gss)| (g - gss).abs())
        .collect()
}

fn main() {
    let result1 = compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]);
    let result2 = compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2]);
    println!(""{:?}"", result1); // Output: [0, 0, 0, 0, 3, 3]
    println!(""{:?}"", result2); // Output: [4, 4, 1, 0, 0, 6]
}","}

fn main() {
    let candidate = compare;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);
    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);
    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);
    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);
}
"
HumanEval_153,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// (ⵜⵓⵙⴷⵉⴷⵜ ⵏⵏⵙ ⵜⴳⴰ -1). /// return 'Slices.SErviNGSliCes' ⴰⵛⴽⵓ 'SErviNGSliCes' ⵉⴳⴰ ⴰⵙⵖⵣⵣⵉⴼ ⴰⴽⴽⵡ ⵉⴷⵓⵙⵏ /// extensions: ['SERVINGSliCes', 'Cheese', 'StuFfed'] ⵀⴰⵜ ⵔⴰⴷ ⵜⵙⵙⵏⴷ /// ⵙ ⵓⵎⴷⵢⴰ, ⵎⴽ ⵜⵜⵓⴼⴽⴰ ""Slices"" ⴰⵎⵎ ⵜⵔⵎⵜ ⴷ ⵓⵎⵙⵙⵓⴷⵙ ⵏ /// ⵙⵜⴰⵢ ⵢⴰⵜ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⴳ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ. /// ⵎⴽ ⵍⵍⴰⵏⵜ ⵙⵏⴰⵜ ⵏⵖ ⵓⴳⴳⴰⵔ ⵏ ⵜⵣⵣⵉⴳⵣⵉⵏ ⵙ ⵢⴰⵜ ⵜⵣⵎⵔⵜ, ⵔⴰⴷ ⵜⵙⵙⵏⵎ /// format: ClassName.StrongestExtensionName.  ⴰⵖⴰⵡⴰⵙ ⵏ ⵓⵙⵎⵓⵜⵜⴳ/// ⵅⵙⴷ ⴰⴷ ⵜⴰⴼⴷ ⴰⵙⵖⵣⵣⵉⴼ ⵉⴷⵓⵙⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔⴷ ⵢⴰⵜ ⵜⵉⵔⵔⴰ ⴳ ⵓⵢⴰ /// ⴳ ⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵣⵉⴼ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵣⵎⵔⵜ ⵙ ⵜⴽⵔⵔⴰⵢⵜ CAP - SM. /// ⵜⵉⵔⵔⴰ ⴳ ⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵣⵉⴼ, ⴷ ⴰⴷ ⵜⴳ SM ⴰⵎⴹⴰⵏ ⵏ ⵜⵉⵔⵔⴰ ⵜⵉⵎⵥⵢⴰⵏⵉⵏ /// ⵜⴰⴷⵓⵙⵉ ⵏ ⵓⵙⵙⵖⵣⵣⵉⴼ ⵜⴳⴰ ⵣⵓⵏⴷ ⴰⴷ: ⴰⴷ ⵜⴳ CAP ⴰⵎⴹⴰⵏ ⵏ ⵓⵡⵔⵉⴽ ⴰⵎⵇⵔⴰⵏ /// ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏⵜ ⵜⵔⵏⵓⵜⵉⵏ ⵃⵎⴰ ⴰⴷ ⵜⵜⵓⵣⵎⵔⵏ ⵜⵔⵎⵉⵡⵉⵏ ⵢⴰⴹⵏⵉⵏ ⵉ ⵜⵔⵎⵜ./// ⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵡⵍⴰⵏ ⵏ ⵓⵙⵎⵉⵍ (ⵜⴰⵙⵉⵔⵜ) ⴷ ⵓⵎⵙⵓⵖⵍ ⵏ ⵉⵙⵖⵣⵏ. /// >>> Strongest_Extension(String::from(""my_class""), vec![String::from(""AA""), String::from(""Be""), String::from(""CC"")])
/// String::from(""my_class.AA"")
fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {
","fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {
    let mut strongest_extension = String::new();
    let mut max_strength = i32::MIN;

    for extension in extensions {
        let cap_count = extension.chars().filter(|c| c.is_uppercase()).count() as i32;
        let sm_count = extension.chars().filter(|c| c.is_lowercase()).count() as i32;
        let strength = cap_count - sm_count;

        if strength > max_strength {
            max_strength = strength;
            strongest_extension = extension;
        }
    }

    format!(""{}.{}"", class_name, strongest_extension)
}","}

fn main() {
    let candidate = Strongest_Extension;
    assert_eq!(candidate(String::from(""Watashi""), vec![String::from(""tEN""), String::from(""niNE""), String::from(""eIGHt8OKe"")]), String::from(""Watashi.eIGHt8OKe""));
    assert_eq!(candidate(String::from(""Boku123""), vec![String::from(""nani""), String::from(""NazeDa""), String::from(""YEs.WeCaNe""), String::from(""32145tggg"")]), String::from(""Boku123.YEs.WeCaNe""));
    assert_eq!(candidate(String::from(""__YESIMHERE""), vec![String::from(""t""), String::from(""eMptY""), String::from(""nothing""), String::from(""zeR00""), String::from(""NuLl__""), String::from(""123NoooneB321"")]), String::from(""__YESIMHERE.NuLl__""));
    assert_eq!(candidate(String::from(""K""), vec![String::from(""Ta""), String::from(""TAR""), String::from(""t234An""), String::from(""cosSo"")]), String::from(""K.TAR""));
    assert_eq!(candidate(String::from(""__HAHA""), vec![String::from(""Tab""), String::from(""123""), String::from(""781345""), String::from(""-_-"")]), String::from(""__HAHA.123""));
    assert_eq!(candidate(String::from(""YameRore""), vec![String::from(""HhAas""), String::from(""okIWILL123""), String::from(""WorkOut""), String::from(""Fails""), String::from(""-_-"")]), String::from(""YameRore.okIWILL123""));
    assert_eq!(candidate(String::from(""finNNalLLly""), vec![String::from(""Die""), String::from(""NowW""), String::from(""Wow""), String::from(""WoW"")]), String::from(""finNNalLLly.WoW""));
    assert_eq!(candidate(String::from(""_""), vec![String::from(""Bb""), String::from(""91245"")]), String::from(""_.Bb""));
    assert_eq!(candidate(String::from(""Sp""), vec![String::from(""671235""), String::from(""Bb"")]), String::from(""Sp.671235""));
}
"
HumanEval_154,tzm_Tfng,rs,"/// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵏⴰⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵅⵙ ⴰⴷ ⵜⵔⵉⵜⵔⵓⵏ true ⵎⴽ ⵜⴳⴰ ⵜⴳⵓⵔⵉ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⵏⵖ ⴽⵔⴰ ⵏ ⵜⵙⵓⵜⵍⵜ ⵏⵏⵙ ⵢⴰⵜ ⵜⵉⵔⵔⴰ ⵏ ⵜⴳⵓⵔⵉ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ /// >>> cycpattern_check(String::from(""abcd""), String::from(""abd""))
/// false
/// >>> cycpattern_check(String::from(""hello""), String::from(""ell""))
/// true
/// >>> cycpattern_check(String::from(""whassup""), String::from(""psus""))
/// false
/// >>> cycpattern_check(String::from(""abab""), String::from(""baa""))
/// true
/// >>> cycpattern_check(String::from(""efef""), String::from(""eeff""))
/// false
/// >>> cycpattern_check(String::from(""himenss""), String::from(""simen""))
/// true
fn cycpattern_check(a: String, b: String) -> bool {
","fn cycpattern_check(a: String, b: String) -> bool {
    let len_b = b.len();
    if len_b == 0 {
        return true;
    }
    let doubled_b = b.clone() + &b;
    for i in 0..len_b {
        if let Some(sub) = doubled_b.get(i..i + len_b) {
            if a.contains(sub) {
                return true;
            }
        }
    }
    false
}","}

fn main() {
    let candidate = cycpattern_check;
    assert_eq!(candidate(String::from(""xyzw""), String::from(""xyw"")), false);
    assert_eq!(candidate(String::from(""yello""), String::from(""ell"")), true);
    assert_eq!(candidate(String::from(""whattup""), String::from(""ptut"")), false);
    assert_eq!(candidate(String::from(""efef""), String::from(""fee"")), true);
    assert_eq!(candidate(String::from(""abab""), String::from(""aabb"")), false);
    assert_eq!(candidate(String::from(""winemtt""), String::from(""tinem"")), true);
}
"
HumanEval_155,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// ⴷⴰⵜ ⵏ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ. ⵔⴰⴷ ⵏⵔⴰⵔ ⵜⴰⵡⴰⵍⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ ⴷ ⵡⵉⵏ ⵡⴰⵔ ⵉⵎⵎⵔⵡⴰⵙⵏ ⵙ ⵓⵎⵣⴰⵔⴰⵢ. /// >>> even_odd_count(-12)
/// (1, 1)
/// >>> even_odd_count(123)
/// (1, 2)
fn even_odd_count(num: isize) -> (isize, isize) {
","fn even_odd_count(num: isize) -> (isize, isize) {
    let mut even_count = 0;
    let mut odd_count = 0;
    let num_str = num.abs().to_string();
    
    for ch in num_str.chars() {
        if let Some(digit) = ch.to_digit(10) {
            if digit % 2 == 0 {
                even_count += 1;
            } else {
                odd_count += 1;
            }
        }
    }
    
    (even_count, odd_count)
}","}

fn main() {
    let candidate = even_odd_count;
    assert_eq!(candidate(7), (0, 1));
    assert_eq!(candidate(-78), (1, 1));
    assert_eq!(candidate(3452), (2, 2));
    assert_eq!(candidate(346211), (3, 3));
    assert_eq!(candidate(-345821), (3, 3));
    assert_eq!(candidate(-2), (1, 0));
    assert_eq!(candidate(-45347), (2, 3));
    assert_eq!(candidate(0), (1, 0));
}
"
HumanEval_156,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ: /// ⵜⵉⵎⵥⴰ: 1 <= num <= 1000 /// ⴷ ⵙⵙⵓⴼⵖ-ⵉⵜ ⵙ ⵜⵉⵔⵔⴰ ⵜⵉⵎⵥⵢⴰⵏⵉⵏ. /// ⴷⴰⵜ ⵏ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ, ⵙⵙⵓⵜⵔ ⴰⵎⵢⴰⵡⴰⵙ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵔⵓⵎⴰⵏ ⵙ ⵢⴰⵜ ⵜⵔⴳⴰⵍⵜ, /// >>> int_to_mini_roman(19)
/// String::from(""xix"")
/// >>> int_to_mini_roman(152)
/// String::from(""clii"")
/// >>> int_to_mini_roman(426)
/// String::from(""cdxxvi"")
fn int_to_mini_roman(number: isize) -> String {
","fn int_to_mini_roman(mut number: isize) -> String {
    let roman_numerals = [
        (1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
        (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
        (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""),
        (1, ""i""),
    ];
    
    let mut result = String::new();
    
    for &(value, symbol) in roman_numerals.iter() {
        while number >= value {
            number -= value;
            result.push_str(symbol);
        }
    }
    
    result
}","}

fn main() {
    let candidate = int_to_mini_roman;
    assert_eq!(candidate(19), String::from(""xix""));
    assert_eq!(candidate(152), String::from(""clii""));
    assert_eq!(candidate(251), String::from(""ccli""));
    assert_eq!(candidate(426), String::from(""cdxxvi""));
    assert_eq!(candidate(500), String::from(""d""));
    assert_eq!(candidate(1), String::from(""i""));
    assert_eq!(candidate(4), String::from(""iv""));
    assert_eq!(candidate(43), String::from(""xliii""));
    assert_eq!(candidate(90), String::from(""xc""));
    assert_eq!(candidate(94), String::from(""xciv""));
    assert_eq!(candidate(532), String::from(""dxxxii""));
    assert_eq!(candidate(900), String::from(""cm""));
    assert_eq!(candidate(994), String::from(""cmxciv""));
    assert_eq!(candidate(1000), String::from(""m""));
}
"
HumanEval_157,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// 90 ⵜⵉⵙⴽⴼⴰⵍ. /// ⵉⴳⴰ ⵓⴽⵏⴰⵔⵉ ⵏ ⵓⵥⵍⴰⵢ ⵏ ⵓⵥⵍⴰⵢ ⵢⴰⵏ ⵓⴽⵏⴰⵔⵉ ⴳ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⵥⵍⴰⵢ ⵏ ⵓⵥⵍⴰⵢ ⵏⵖ /// ⴷⴰ ⵙⴽⴰⵔⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵢⴰⵜ ⵜⵔⴳⴰⵍⵜ ⵜⴰⵎⴷⴷⴰⴽⴽⵡⵍⵜ, ⵎⴰⵛⴰ ⵓⵔ ⵉⴳⵉ ⵡⴰⵍⴰ. /// ⵙ ⵓⵙⴽⵙⵍ ⵏ ⵜⵉⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⵢⴰⵏ ⵓⴽⵕⴰⴹ. ⵔⵡⵍ ⵜⵉⴷⵜ ⵎⴽ ⵀⴰⵏ ⴽⵕⴰⴹ /// >>> right_angle_triangle(3, 4, 5)
/// true
/// >>> right_angle_triangle(1, 2, 3)
/// false
fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {
","fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {
    let mut sides = [a, b, c];
    sides.sort_unstable();

    let [x, y, z] = sides;
    x * x + y * y == z * z
}","}

fn main() {
    let candidate = right_angle_triangle;
    assert_eq!(candidate(3, 4, 5), true);
    assert_eq!(candidate(1, 2, 3), false);
    assert_eq!(candidate(10, 6, 8), true);
    assert_eq!(candidate(2, 2, 2), false);
    assert_eq!(candidate(7, 24, 25), true);
    assert_eq!(candidate(10, 5, 7), false);
    assert_eq!(candidate(5, 12, 13), true);
    assert_eq!(candidate(15, 8, 17), true);
    assert_eq!(candidate(48, 55, 73), true);
    assert_eq!(candidate(1, 1, 1), false);
    assert_eq!(candidate(2, 2, 10), false);
}
"
HumanEval_158,tzm_Tfng,rs,"/// ⵉⵙⴽⴽⵉⵍⵏ, ⵔⴰⴷ ⴷ-ⵔⵡⵍⵏ ⵡⵉ-ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵓⵎⵣⵡⴰⵔⵓ ⴳ ⵓⵍⵓⴳ ⵏ ⵓⵙⴽⴽⵉⵍ. /// ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⵉⵡⵏ. ⵎⴽ ⴷⴰⵔ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⵉⵡⵏ /// ⵉⵍⵍⴰ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⴽⵉⴳⴰⵏ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵔⵎⵙⵏ ⵜⴰⴳⵓⵔⵉ ⵙ ⵓⵟⵟⵓⵏ ⴰⵎⵇⵔⴰⵏ /// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵙⵉⵔⵎⵏ. /// >>> find_max(vec![String::from(""name""), String::from(""of""), String::from(""string"")])
/// String::from(""string"")
/// >>> find_max(vec![String::from(""name""), String::from(""enam""), String::from(""game"")])
/// String::from(""enam"")
/// >>> find_max(vec![String::from(""aaaaaaa""), String::from(""bb""), String::from(""cc"")])
/// String::from(""aaaaaaa"")
fn find_max(words: Vec<String>) -> String {
","fn find_max(words: Vec<String>) -> String {
    fn unique_char_count(s: &str) -> usize {
        let mut chars: std::collections::HashSet<char> = std::collections::HashSet::new();
        for c in s.chars() {
            chars.insert(c);
        }
        chars.len()
    }

    words
        .into_iter()
        .max_by(|a, b| {
            let count_a = unique_char_count(a);
            let count_b = unique_char_count(b);
            count_a.cmp(&count_b).then_with(|| a.cmp(b))
        })
        .unwrap()
}","}

fn main() {
    let candidate = find_max;
    assert_eq!(candidate(vec![String::from(""name""), String::from(""of""), String::from(""string"")]), String::from(""string""));
    assert_eq!(candidate(vec![String::from(""name""), String::from(""enam""), String::from(""game"")]), String::from(""enam""));
    assert_eq!(candidate(vec![String::from(""aaaaaaa""), String::from(""bb""), String::from(""cc"")]), String::from(""aaaaaaa""));
    assert_eq!(candidate(vec![String::from(""abc""), String::from(""cba"")]), String::from(""abc""));
    assert_eq!(candidate(vec![String::from(""play""), String::from(""this""), String::from(""game""), String::from(""of""), String::from(""footbott"")]), String::from(""footbott""));
    assert_eq!(candidate(vec![String::from(""we""), String::from(""are""), String::from(""gonna""), String::from(""rock"")]), String::from(""gonna""));
    assert_eq!(candidate(vec![String::from(""we""), String::from(""are""), String::from(""a""), String::from(""mad""), String::from(""nation"")]), String::from(""nation""));
    assert_eq!(candidate(vec![String::from(""this""), String::from(""is""), String::from(""a""), String::from(""prrk"")]), String::from(""this""));
    assert_eq!(candidate(vec![String::from(""b"")]), String::from(""b""));
    assert_eq!(candidate(vec![String::from(""play""), String::from(""play""), String::from(""play"")]), String::from(""play""));
}
"
HumanEval_159,tzm_Tfng,rs,"/// ⴰⵎⴷⵢⴰ: /// ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⵉⵇⵇⵉⵎⵏ ⵏ ⵜⵔⵖⵉ, ⵔⴰⴷ ⵜⵙⵙⵓⵜⵎ ⴰⴽⴽⵡ ⵜⵔⵖⵉ ⵢⴰⴷⵏ, ⵎⴰⵛⴰ ⵔⴰⴷ ⵜⵇⵇⵉⵎ ⵜⵔⵖⵉ. /// ⴰⵟⵟⴰⵙ ⵏ ⵉⵔⵖⴰⵏ ⵇⵇⵉⵎⵏ ⴷⴼⴼⵉⵔ ⵏ ⵡⵓⵜⵛⵉ ⵏⵏⴽ ] /// ⴰⴷ ⵜⵔⵣⴼⴷ ⵢⴰⵏ ⵓⴽⵛⵛⵓⵎ ⵏ [ ⵓⵟⵟⵓⵏ ⴰⵖⵓⵍⴰⵏ ⵏ ⵜⵔⵖⵉ ⵍⵍⵉ ⵜⵙⵙⵓⵜⵎ ⴷⴼⴼⵉⵔ ⵏ ⵜⴷⴰⵍⴰ ⵏⵏⴽ, //ⵎⴰⵛⴰ ⵖⵉⵍⴰⴷ, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⵙⵓⵜⵎ ⵓⴳⴳⴰⵔ ⵏ ⵉⴽⴰⵔⴰⵡⵏ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵎⵓⵔⵎ ⵜⴰⵙⵙⵓⵜⵍⵜ ⵏ ⵡⴰⵙⵙ.///ⵜⴳⴰⴷ ⵢⴰⵜ ⵜⵔⴱⴰⵜ ⵉⵔⵖⴰⵏ, ⴷ ⵜⵙⵙⵓⵜⵎ ⴽⵔⴰ ⵏ ⵜⴽⴰⵔⴹⵉⵡⵉⵏ, /// >>> eat(5, 6, 10)
/// vec![11, 4]
/// >>> eat(4, 8, 9)
/// vec![12, 1]
/// >>> eat(1, 10, 10)
/// vec![11, 0]
/// >>> eat(2, 11, 5)
/// vec![7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {
","fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {
    let to_eat = if need <= remaining { need } else { remaining };
    vec![number + to_eat, remaining - to_eat]
}","}

fn main() {
    let candidate = eat;
    assert_eq!(candidate(5, 6, 10), vec![11, 4]);
    assert_eq!(candidate(4, 8, 9), vec![12, 1]);
    assert_eq!(candidate(1, 10, 10), vec![11, 0]);
    assert_eq!(candidate(2, 11, 5), vec![7, 0]);
    assert_eq!(candidate(4, 5, 7), vec![9, 2]);
    assert_eq!(candidate(4, 5, 1), vec![5, 0]);
}
"
HumanEval_160,tzm_Tfng,rs,"///ⴰⵔ ⵉⵜⵜⵉⵍⵉ ⴳ ⵓⵎⵙⵙⵓⴷⵙ ⵏ ⵓⵎⵙⵙⵓⴷⵙ ⵢⴰⵏ ⵓⵎⵙⵙⵓⴷⵙ, ⴷ ⵓⵎⵙⵙⵓⴷⵙ ⵏ ⵓⵎⵙⵙⵓⴷⵙ ⵏ ⵓⵎⵙⵙⵓⴷⵙ ⵙⵉⵏ ⵉⵎⵙⵙⵓⴷⵙⵏ./// Oⴱⵉⵔⴰⵏⴷ ⴷ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵔⵉⵏ. /// ⵜⵉⵖⵣⵉ ⵏ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⵓⵎⵙⵡⵓⵔⵉ ⵜⴳⴰ ⵜⵜ ⵜⵉⵖⵣⵉ ⵏ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⵓⵙⵡⵓⵔⵉ ⵎⵉⵏⵓⵙ ⵢⴰⵏ. /// ⵜⴰⵏⵏⴰⵢⵜ: /// => ⵜⴰⵢⴰⴼⵓⵜ = 9 /// ⵜⴰⵢⴰⴼⵓⵜ = 2 + 3 * 4 - 5 /// ⵓⴽⵜⵓⵔ = [2, 3, 4, 5] /// ⴰⵎⵙⵙⵎⵔⵙⴰⵍ['+', '*', '-'] /// ⴰⵎⴷⵢⴰ: /// ⴰⵙⵎⵓⵜⵜⴳ (**) /// ⴰⴱⵟⵟⵓ ⵏ ⵓⵙⵡⵉⵔ ( //) /// ⴰⵎⵔⴰⵔⵓ (*) /// ⴰⵙⵏⵓⵎⵔ ( - ) /// ⴰⵙⵎⵓⵏ ( +) /// ⵜⵉⵎⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ ⵜⵉⵙⵍⴽⵉⵎⵉⵏ: /// ⴰⵙⵏⵓⵎⵎⵍ ⴷ ⵓⵙⵡⴰⵍⴰ ⵏ ⵓⵙⵏⵓⵎⵎⵍ ⴰⴷ. /// ⴷ ⵓⵎⵙⵙⵓⴷⵙ ⵡⵉⵙⵙ ⵙⵉⵏ ⵉⴳⴰ ⴰⵎⵙⵙⵓⴷⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙⵎⵔⵙⵏ ⵉⵎⵙⵙⵓⴷⵙⵏ ⴰⴷ ⵙⵉⵏ ⴰⴼⴰⴷ ⴰⴷ ⵙⵙⴽⵔⵏ ⵜⴰⵍⵖⴰ ⵏ ⵍⵊⵉⴱⵔ /// ⵙ ⵡⴰⵏⵏⴰⵢ ⵏ ⵙⵉⵏ ⵉⵎⵙⵙⵓⴷⵙⵏ, ⴷ ⵓⵎⵙⵡⵓⵔⵉ. ⵉⵎⵙⵙⵓⴷⵙⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵖⵓⵔⵙⵏ ⵜⵉⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ ⵜⵉⵙⵍⴽⵎⴰⵏⵉⵏ, ⴷ fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {
","fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {
    let mut result = operand[0];
    
    for i in 0..operator.len() {
        match operator[i].as_str() {
            ""+"" => result += operand[i+1],
            ""-"" => result -= operand[i+1],
            ""*"" => result *= operand[i+1],
            ""//"" => result /= operand[i+1],
            ""**"" => result = result.pow(operand[i+1] as u32),
            _ => panic!(""Unexpected operator""),
        }
    }
    
    result
}

fn main() {
    let operators = vec![""+"",""*"",""-""].iter().map(|s| s.to_string()).collect();
    let operands = vec![2, 3, 4, 5];
    let result = do_algebra(operators, operands);
    println!(""Result: {}"", result);
}","}

fn main() {
    let candidate = do_algebra;
    assert_eq!(candidate(vec![String::from(""**""), String::from(""*""), String::from(""+"")], vec![2, 3, 4, 5]), 37);
    assert_eq!(candidate(vec![String::from(""+""), String::from(""*""), String::from(""-"")], vec![2, 3, 4, 5]), 9);
    assert_eq!(candidate(vec![String::from(""//""), String::from(""*"")], vec![7, 3, 4]), 8);
}
"
HumanEval_161,tzm_Tfng,rs,"/// ⵉⵎⴷⵢⴰⵜⵏ /// ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ. /// ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴳ ⵓⵖⵉⵍⴰⵍ ⴽⵔⴰ ⵏ ⵡⴰⵔⵔⴰⵜⵏ, ⵙⵙⵓⵜⵍ ⵜⴰⵖⵉⵍⴰⵍⵜ. /// ⵎⴽ ⵓⵔ ⵜⵍⵍⴰ, ⵃⴹⵓ ⵜⵜ ⴰⵎⵎ ⵎⴰⴷ ⵜⴳⴰ./// ⵎⴽ ⵜⴳⴰ s[i] ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⵔⴰⴷ ⵜⵙⵙⵏⴼⵍ ⵙⴳ ⴷⴷⴰⵡ ⴰⵔ ⴰⴼⵍⵍⴰ ⵏⵖⴷ ⵙ ⵓⵎⵣⴰⵔⴰⵢ, /// ⴰⵜⵏⵢⴰⵜ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵜ ⵜⵣⵍⵉⵜ s. /// >>> solve(String::from(""1234""))
/// String::from(""4321"")
/// >>> solve(String::from(""ab""))
/// String::from(""AB"")
/// >>> solve(String::from(""#a@C""))
/// String::from(""#A@c"")
fn solve(s: String) -> String {
","fn solve(s: String) -> String {
    if s.chars().all(|c| !c.is_alphabetic()) {
        s.chars().rev().collect()
    } else {
        s.chars()
            .map(|c| {
                if c.is_lowercase() {
                    c.to_ascii_uppercase()
                } else if c.is_uppercase() {
                    c.to_ascii_lowercase()
                } else {
                    c
                }
            })
            .collect()
    }
}","}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(String::from(""AsDf"")), String::from(""aSdF""));
    assert_eq!(candidate(String::from(""1234"")), String::from(""4321""));
    assert_eq!(candidate(String::from(""ab"")), String::from(""AB""));
    assert_eq!(candidate(String::from(""#a@C"")), String::from(""#A@c""));
    assert_eq!(candidate(String::from(""#AsdfW^45"")), String::from(""#aSDFw^45""));
    assert_eq!(candidate(String::from(""#6@2"")), String::from(""2@6#""));
    assert_eq!(candidate(String::from(""#$a^D"")), String::from(""#$A^d""));
    assert_eq!(candidate(String::from(""#ccc"")), String::from(""#CCC""));
}
"
HumanEval_162,tzm_Tfng,rs,"/// ⵎⴽ ⵜⴳⴰ 'text' ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ ⵜⵓⵎⵍⵉⵍⵜ, ⵙⵡⵓⵜⵜⵔ None. /// ⴷⴰⵜ ⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ 'text', ⵙⴽⵔ ⵜⴰⵡⵉⴽⵉ ⵏⵏⵙ md5 hash equivalent. /// >>> string_to_md5(String::from(""Hello world""))
/// Some(String::from(""3e25960a79dbc69b674cd4ec67a72c62""))
fn string_to_md5(text: String) -> Option<String> {
","use md5;

fn string_to_md5(text: String) -> Option<String> {
    if text.is_empty() {
        return None;
    }
    let digest = md5::compute(text);
    Some(format!(""{:x}"", digest))
}","}

fn main() {
    let candidate = string_to_md5;
    assert_eq!(candidate(String::from(""Hello world"")), Some(String::from(""3e25960a79dbc69b674cd4ec67a72c62"")));
    assert_eq!(candidate(String::from("""")), None);
    assert_eq!(candidate(String::from(""A B C"")), Some(String::from(""0ef78513b0cb8cef12743f5aeb35f888"")));
    assert_eq!(candidate(String::from(""password"")), Some(String::from(""5f4dcc3b5aa765d61d8327deb882cf99"")));
}
"
HumanEval_163,tzm_Tfng,rs,"/// ⵙ ⵓⵎⴷⵢⴰ: /// ⴷ b, ⴳ ⵓⵍⵓⴳ ⵏ ⵓⵙⵙⴰⵔⵓ. /// ⴷⴰⵜ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ a ⴷ b, ⵙⴽⵔ ⵜⵉⴼⵔⵉⵙⵜ ⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ ⴳⵔ a /// >>> generate_integers(2, 8)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(8, 2)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(10, 14)
/// Vec::<isize>::new()
fn generate_integers(a: isize, b: isize) -> Vec<isize> {
","fn generate_integers(a: isize, b: isize) -> Vec<isize> {
    let (start, end) = if a < b { (a, b) } else { (b, a) };
    (start..=end).filter(|&x| x % 2 == 0).collect()
}

fn main() {
    let result1 = generate_integers(2, 8);
    println!(""{:?}"", result1); // Output: vec![2, 4, 6, 8]

    let result2 = generate_integers(8, 2);
    println!(""{:?}"", result2); // Output: vec![2, 4, 6, 8]

    let result3 = generate_integers(10, 14);
    println!(""{:?}"", result3); // Output: vec![10, 12, 14]
}","}

fn main() {
    let candidate = generate_integers;
    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);
    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(17, 89), Vec::<isize>::new());
}
"
