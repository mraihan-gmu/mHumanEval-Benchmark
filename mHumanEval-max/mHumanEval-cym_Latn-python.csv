task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,cym_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Gwiriwch a oes unrhyw ddau rif yn agosach at ei gilydd na'r trothwy.""""""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,cym_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Mae'r swyddogaeth hon yn mewnbwn i llinell sy'n cynnwys sawl grŵp o barendys wedi'u rhestru. Eich nod yw gwahanu'r grwpiau hynny yn llinellau ar wahân a dychwelyd rhestr y rhai hynny. Mae'r grwpiau ar wahân yn cydbwys (mae pob braced agored wedi'i gau'n iawn) ac nid yn rhestru o fewn ei gilydd Ignore unrhyw leoliadau yn y llinell mewnbwn.""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,cym_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Gan fod rhif pwynt symudol positif, gellir ei ddad-ddylunio i ran rhif cyfan (y rhif cyfan mwyaf sy'n llai na'r rhif a roddir) a decimals (y rhan sy'n weddill bob amser yn llai na 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,cym_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Mae rhestr o weithrediadau adneuo a thynnu ar gyfrif banc yn cael ei roi i chi sy'n dechrau gyda chwistrell sero. Eich tasg yw canfod os yw cyfyngiad y cyfrif yn disgyn o dan sero ar unrhyw adeg, ac ar y pwynt hwnnw dylai swyddogaeth ddychwelyd True. Fel arall dylai ddychwelyd False.""""""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,cym_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Ar gyfer rhestr benodol o rifau mewnbwn, cyfrifo Canlyniad Absoliwt Canolradd o gwmpas canolradd y set ddata hwn. Canlyniad Absoliwt Canolradd yw'r gwahaniaeth cyfartalog absoliwt rhwng pob elfen a phwynt canol (canolradd yn yr achos hwn): MAD = canolradd. x - x_mean.""""""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,cym_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Ychwanegwch rhif 'delimedydd' rhwng pob dau elfen gyfartal o restr mewnbwn `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,cym_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Mae mewnbwn i'r swyddogaeth hon yn llinyn sy'n cynrychioli grwpiau lluosog ar gyfer parentesi gwersyllwyd wedi'u gwahanu gan leoliadau. Ar gyfer pob un o'r grŵp, ewch â'r lefel dwfn uchaf o gwersyllwyd o'r parentesi. Er enghraifft, mae gan (() (()) uchafswm o ddwy lefel o gwersyllyd tra bod gan ((())) dri. >>> parse_nested_parens('((()) ((())) () ((()) (((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,cym_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Ffiltrwch rhestr mewnbwn o strings dim ond ar gyfer rhai sy'n cynnwys isstring penodol >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,cym_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Ar gyfer rhestr benodol o integrau, dychwelyd tuple sy'n cynnwys cyfanswm a chynhyrchiad o'r holl integrau mewn rhestr. Dylai cyfanswm gwag fod yn hafal i 0 a dylai cynhyrchiad gwag fod yn hafal i 1. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,cym_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""O restr o integrau, deillia rhestr o elfennau uchafswm cylch a ddarganfuwyd tan bryd penodol yn y dilyniant. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,cym_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Dewch o hyd i'r palindrom byrraf sy'n dechrau gyda chadernid wedi'i ddarparu. Mae syniad yr algorithm yn syml: - Dewch o hyd i'r postfix hiraf o chadernid wedi'i ddarparu sy'n palindrom. - Ychwanegwch wrth gefn y chadernid o ragorchadernid sy'n dod cyn y ddeilys palindromig i ddiwedd y chadernid. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('catac') ' >>> make_palindrome ((('catac') ' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Profi os yw'r llinyn a roddir yn palindrom """"""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,cym_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Mae mewnbwn yn ddau llinyn a a b sy'n cynnwys 1s a 0s yn unig. Perfformiwch XOR ddeuaidd ar y mewnbwn hyn a dychwelwch y canlyniad hefyd fel llinyn. >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,cym_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""O'r rhestr o ryseitiau, dychwelyd yr un hiraf. dychwelyd yr un cyntaf os oes sawl ryseitiau o'r un hyd. dychwelyd dim os yw'r rhestr mewnbwn yn wag. >>> hir (([]) >>> hir ((['a', 'b', 'c']) 'a' >>> hir ((['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,cym_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Dychwelyd y rhan fwyaf cyffredin mwyaf o ddau rhif cyflawn a a b >>> y rhan fwyaf cyffredin mwyaf ((3, 5) 1 >>> y rhan fwyaf cyffredin mwyaf ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,cym_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Mae'n dychwelyd rhestr o'r holl flaen-ddyfeisiau o'r cyfres isaf i'r cyfres hiraf o'r llinell mewnbwn >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,cym_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Yn dychwelyd llinell sy'n cynnwys rhifau wedi'u terfynnu gan ofod gan ddechrau o 0 hyd at n yn cynnwys. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,cym_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Gan roi llinell, darganfyddwch faint o gymeriadau gwahanol (yn ddibynnol ar achos) y mae'n cynnwys >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,cym_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Mae'r swyddogaeth hon yn cynnwys llinyn sy'n cynrychioli nodiadau cerddorol mewn fformat arbennig ASCII. Eich tasg yw dadansoddi rhestr llinyn o integrau sy'n cyfateb i lawer o beats. Dyma chwedl: 'o' note, lasts beats 'o,doi' - hanner nodyn. lasts two beats' - quater note, lasts one beat >>> parse_music. 'o o.doi o.doi o.doi o.doi o.doi o.doi o.doi o.doi o.doi o.doi o.doi o.' [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,cym_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Darganfyddwch faint o weithiau y gellir dod o hyd i is-string penodol yn y string gwreiddiol. Cyfriwch achosion sy'n gorgyffwrdd. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,cym_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Mae mewnbwn yn gyfres o rhifau wedi'u hamlinellu gan le o 'sero' i 'nawr'. Y dewisiadau dilys yw 'sero', 'un', 'dau', 'tri', 'ffy', ' pum', 'sydd', 'saith', 'ach' a 'nawr'. Dychwelyd y gyfres gyda rhifau wedi'u sortio o'r lleiaf i'r mwyaf >>> sort_numbers (('three one five') 'one three five' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,cym_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""O restr o rifau a ddarperir (o hyd o leiaf dau) dewiswch a dychwelwch ddau sy'n agosach at ei gilydd a dychwelwch nhw yn ôl yn yr ordrefn (rhif llai, rhif mwy). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,cym_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Gan roi rhestr o rifau (o o leiaf dau elfen), cymhwyso trawsnewidydd llinol i'r rhestr honno, fel y bydd y rhif lleiaf yn dod yn 0 a'r mwyaf yn dod yn 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,cym_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filter given list of any python values only for integers >>> filter_integers(['a', 3.14, 5]) [5] >>> filter_integers([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,cym_Latn,python,"

def strlen(string: str) -> int:
    """"""Dychwelyd hyd y llinell a roddwyd >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,cym_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Ar gyfer rhif n, ceisiwch y rhif mwyaf sy'n rhannu n yn gyfartal, sy'n llai na n >>> largest_divisor ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,cym_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Dylai pob un o'r ffactorau gael eu rhestru nifer o weithiau sy'n cyfateb i faint o weithiau y mae'n ymddangos mewn ffactoriad. Dylai rhif mewnbwn fod yn hafal i gynnyrch yr holl ffactorau >>> ffactoriad ((8) [2, 2, 2] >>> ffactoriad ((25) [5, 5] >>> ffactoriad ((70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,cym_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""O restr o integrau, dileu'r holl elfennau sy'n digwydd mwy nag unwaith. Cadwch drefn yr elfennau ar gau yr un fath â'r mewnbwn. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,cym_Latn,python,"

def flip_case(string: str) -> str:
    """"""Ar gyfer llinyn penodol, trowch gymeriadau lleiafrif i lythyren fawr a lythyren fawr i lythyren fach. >>> flip_case ((('Hello') 'hELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,cym_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Rhestr o ryseitiau mewn llinell sengl >>> concatenate (([]) '' >>> concatenate ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,cym_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Ffiltrwch rhestr mewnbwn o llinynnau dim ond ar gyfer rhai sy'n dechrau gyda chyn-fyndod penodol. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,cym_Latn,python,"

def get_positive(l: list):
    """"""Dychwelyd dim ond rhifau cadarnhaol yn y rhestr. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,cym_Latn,python,"

def is_prime(n):
    """"""Dychwelyd gwir os yw rhif penodol yn brif, ac yn ffug fel arall. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,cym_Latn,python,"import math


def poly(xs: list, x: float):
    """"""xs yw coeffisiyntau polynom. find_zero find x fel bod poly(x) = 0. find_zero yn dychwelyd dim ond dim ond pwynt sero, hyd yn oed os oes llawer. Yn ogystal, mae find_zero dim ond yn cymryd rhestr xs sydd â nifer hyd yn oed o gydrannau a'r gydran nad yw'n sero mwyaf gan ei fod yn gwarantu ateb. >>> rownd ((find_zero[(1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> rownd ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Mae'n gwerthuso polynom gyda chydweithwyr xs ar y pwynt x. dychwelyd xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,cym_Latn,python,"

def sort_third(l: list):
    """"""Mae'r swyddogaeth hon yn cymryd rhestr l ac yn dychwelyd rhestr l' fel bod l' yn union yr un fath â l yn y nodweddion nad ydynt yn rhanadwy gan dri, tra bod ei werthoedd yn y nodweddion sy'n rhanadwy gan dri yn gyfartal i werthoedd y nodweddion cyfatebol o l, ond wedi'u sortio. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,cym_Latn,python,"

def unique(l: list):
    """"""Dychwelyd elfennau unigryw a sortiwyd mewn rhestr >>> unigryw (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,cym_Latn,python,"

def max_element(l: list):
    """"""Dychwelyd yr elfen uchaf yn y rhestr. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,cym_Latn,python,"

def fizz_buzz(n: int):
    """"""Dychwelyd nifer y cyfnodau y mae'r rhif 7 yn ymddangos mewn rhifau cyfan llai na n sy'n rhanadwy i 11 neu 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,cym_Latn,python,"

def sort_even(l: list):
    """"""Mae'r swyddogaeth hon yn cymryd rhestr l ac yn dychwelyd rhestr l' fel bod l' yn union yr un fath â l yn y nodweddion anhygoel, tra bod ei werthoedd yn y nodweddion hyd yn oed yn gyfartal i werthoedd y nodweddion hyd yn oed o l, ond wedi'u sortio. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,cym_Latn,python,"

def encode_cyclic(s: str):
    """"""yn cymryd fel llinell mewnbwn wedi'i chodi gyda swyddogaeth encode_cyclic. Yn dychwelyd llinell wedi'i ddad-godi. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""yn dychwelyd llinyn wedi'i chodio gan grwpiau cylchrog o dri cymeriad. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,cym_Latn,python,"

def prime_fib(n: int):
    """"""Mae prime_fib yn dychwelyd rhif n-ed sydd yn rhif Fibonacci ac mae hefyd yn brif. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,cym_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""Mae triples_sum_to_zero yn cymryd rhestr o integers fel mewnbwn. mae'n dychwelyd True os oes tair elfen wahanol yn y rhestr sy'n cyfanswm i sero, a False fel arall. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,cym_Latn,python,"

def car_race_collision(n: int):
    """"""Dychmygwch ffordd sy'n llinell ddi-ffin o hyd yn berffaith syth. n ceir yn gyrru'n chwith i'r dde; ar yr un pryd, mae set arall o n ceir yn gyrru'n dde i'r chwith. Mae'r ddau set o geir yn dechrau'n bell iawn oddi wrth ei gilydd. Mae'r holl geir yn symud yn yr un cyflymder. Dywedir bod dau gar yn gwrthdrawiad pan fydd car sy'n symud o chwith i'r dde yn taro car sy'n symud o dde i'r chwith. Fodd bynnag, mae'r ceir yn ddi-ffin o gadarn a chryf; o ganlyniad, maent yn parhau i symud yn eu traetorydd fel pe na bai'n gwrthdrafod. Mae'r swyddogaeth hon yn cyhoeddi nifer y gwrthdrawiadau o'r fath. """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,cym_Latn,python,"

def incr_list(l: list):
    """"""Mae'r rhestr yn dychwelyd gyda elfennau wedi'u cynyddu gan 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,cym_Latn,python,"

def pairs_sum_to_zero(l):
    """"""Mae pairs_sum_to_zero yn cymryd rhestr o integers fel mewnbwn. mae'n dychwelyd True os oes dau elfen wahanol yn y rhestr sy'n cyfanswm i sero, ac False fel arall. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,cym_Latn,python,"

def change_base(x: int, base: int):
    """"""Newid sylfaen rhifol rhif mewnbwn x i sylfaen. dychwelyd cynrychiolaeth llinyn ar ôl y trawsnewid. mae rhifau sylfaen yn llai na 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,cym_Latn,python,"

def triangle_area(a, h):
    """"""Gan roi hyd ochr a man dychwelyd uchel ar gyfer triongl. >>> triongl_lefel ((5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,cym_Latn,python,"

def fib4(n: int):
    """"""Mae dilyniant rhifau Fib4 yn ddilyniant tebyg i ddilyniant Fibbonacci a ddiffiniwyd fel a ganlyn: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Ysgrifennwch swyddogaeth i gyfrifo'r elfen n-fed o ddilyniant rhifau fib4. Peidiwch â defnyddio ailgyfeirio. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,cym_Latn,python,"

def median(l: list):
    """"""Mae'r cyfrwng draddodiadol o elfennau yn y rhestr l. >>> cyfrwng draddodiadol (([3, 1, 2, 4, 5]) 3 >>> cyfrwng draddodiadol (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,cym_Latn,python,"

def is_palindrome(text: str):
    """"""Gwirio a yw'r llinyn a roddir yn palindrom >>> is_palindrome (('') True >>> is_palindrome (('aba') True >>> is_palindrome (('aaaaa') True >>> is_palindrome (('zbcd') False """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,cym_Latn,python,"

def modp(n: int, p: int):
    """"""Dychwelwch 2^n modulo p (gwyliwch y rhifau). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,cym_Latn,python,"

def encode_shift(s: str):
    """"""yn cymryd fel llinell mewnbwn wedi'i chodi gyda swyddogaeth encode_shift. Yn dychwelyd llinell wedi'i ddad-godi. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""yn dychwelyd llinyn wedi'i chodio trwy symud pob cymeriad gan 5 yn yr wyddor.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,cym_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels yw swyddogaeth sy'n cymryd llinyn ac yn dychwelyd llinyn heb wlawnau. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,cym_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Dychwelyd True os yw pob rhif yn y rhestr l o dan y trothwy t. >>> below_threshold([1, 2, 4, 10], 100) True >>> below_threshold([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,cym_Latn,python,"

def add(x: int, y: int):
    """"""Ychwanegwch ddau rhif x ac y >>> ychwanegu ((2, 3) 5 >>> ychwanegu ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,cym_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Gwiriwch a oes gan ddau air yr un cymeriadau. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') Gwir >>> same_chars (('abcd', 'dddddddddabc') Gwir >>> same_chars (('dddddddabc', 'abcd') Gwir >>> same_chars (('eabcd', 'dddddddddabc') False >>> same_chars (('abcdd', 'dddddddabddce') False >>> same_chars (('eabcdzzzz', 'dddzzzzzzdddabc') False """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,cym_Latn,python,"

def fib(n: int):
    """"""Dychwelyd rhif Fibonacci n-ed. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,cym_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets yn gyfres o ""<"" a "">"". return True os oes gan bob bracket agoriadol bracket cau cyfatebol. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,cym_Latn,python,"

def monotonic(l: list):
    """"""Dychwelyd True yw bod elfennau'r rhestr yn cynyddu neu'n lleihau'n unfforddus. >>> unfforddus (([1, 2, 4, 20]) True >>> unfforddus (([1, 20, 4, 10]) False >>> unfforddus (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,cym_Latn,python,"

def common(l1: list, l2: list):
    """"""Dychwelyd elfennau cyffredin unigryw a sortiwyd ar gyfer dau restr. >>> cyffredin (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> cyffredin (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,cym_Latn,python,"

def largest_prime_factor(n: int):
    """"""Dychwelyd y ffactor prif fwyaf o n. Gwiriwch fod n > 1 ac nad yw'n brif. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,cym_Latn,python,"

def sum_to_n(n: int):
    """"""Mae sum_to_n yn swyddogaeth sy'n cyfanswm rhifau o 1 i n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,cym_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets is a string of ""("" and "")"". return True if every opening bracket has a corresponding closing bracket. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() True >>> correct_bracketing("") True >>> correct_bracketing("") False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,cym_Latn,python,"

def derivative(xs: list):
    """"""xs yn cynrychioli coeffisiyntau polynom. xs[0] + xs[1] * x + xs[2] * x^2 + .... Trowch dderivat y polynom hwn yn yr un ffurf. >>> derivat (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivat[(1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,cym_Latn,python,"

def fibfib(n: int):
    """"""Mae'r dilyniant rhifau FibFib yn ddilyniant tebyg i ddilyniant Fibbonacci a ddiffiniwyd fel a ganlyn: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Ysgrifennwch swyddogaeth i gyfrifo'r elfen n-ed o'r dilyniant rhifau fibfib yn effeithlon. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,cym_Latn,python,"
FIX = """"""Ysgrifennwch swyddogaeth vowels_count sy'n cymryd llinyn sy'n cynrychioli gair fel mewnbwn ac yn dychwelyd nifer y llafuriau yn y llinyn. Llawnau yn yr achos hwn yw 'a', 'e', 'i', 'o', 'u'. Yma, 'y' hefyd yw llawr, ond dim ond pan fydd yn ddiwedd y gair a roddwyd.""""""

def vowels_count(s):
    """"""Ychwanegwch mwy o achosion profi. """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,cym_Latn,python,"
def circular_shift(x, shift):
    """"""Cyfeirw symud digidau'r rhif cyfan x, symud y digidau i'r dde trwy symud a dychwelyd y canlyniad fel llinyn. Os symud > nifer o digidau, dychwelyd digidau'n gwrthdroi. >>> circular_shift(12, 1) ""21"" >>> circular_shift(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,cym_Latn,python,"
def digitSum(s):
    """"""Tasg Ysgrifennu swyddogaeth sy'n cymryd llinyn fel mewnbwn ac yn dychwelyd cyfanswm y cymeriadau uchaf yn unig' codau ASCII.""""""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,cym_Latn,python,"
def fruit_distribution(s,n):
    """"""Yn y dasg hwn, byddwch yn cael llinell sy'n cynrychioli nifer o afal a pherthiniaid sy'n cael eu dosbarthu mewn basged ffrwythau mae'r basged hwn yn cynnwys afal, oren, a ffrwythau mango. Wedi rhoi'r llinell sy'n cynrychioli cyfanswm y oren a pherthiniaid a rhif gyfan sy'n cynrychioli cyfanswm y ffrwythau yn y basged dychwelyd nifer y ffrwythau mango yn y basged. er enghraifft: fruit_distribution""5(afal a 6 oren"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 afal a 1 oren"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 afal a 3 oren"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 afal a 120) "",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,cym_Latn,python,"
def pluck(arr):
    """"""""Gyda fwrdd sy'n cynrychioli cangen o goeden sydd â nodiau cyfan rhif di-negyddol, eich tasg yw tynnu un o'r nodiau a'i ddychwelyd. Dylai'r nod a dynwyd fod yn nod sydd â'r gwerth pari lleiaf. Os ceir sawl nod sydd â'r un gwerth pari lleiaf, dychwelyd y nod sydd â'r index lleiaf. Dylai'r nod a dynwyd gael ei ddychwelyd mewn rhestr, [small_value, ei index] , Os nad oes unrhyw werthoedd pari neu bod y fwrdd penodol yn wag, dychwelyd []. Er enghraifft 1: mewnbwn: [4,2,3] Allbwn: [2, 1] Egluriaeth: 2 sydd â'r gwerth pari lleiaf, a 2 sydd â'r index lleiaf. Er enghraifft 2: mewnbwn: [1,2,3] Allbwn: [2, 1] Egluriaeth: 2 sydd â'r gwerth lleiaf, a 2 sydd â'r index lleiaf. Er enghraifft 3: mewnbwn: [] Allbwn: [4:] Allbwn: [5, 3, 4,] Allbwn: [0, 2] Allbwn: 0 Allbwn: Allbwn: Allbwn: Mae'r nod lleiaf yn lleiaf, ond mae'r nodyn lleiaf yn lleiaf, felly byddwn yn dewis y nod lleiaf lleiaf lleiaf, ond mae'r nod nod lleiaf yn lleiaf.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,cym_Latn,python,"
def search(lst):
    '''Mae rhestr o integrau cadarnhaol wedi'i roi i chi. Dychwelwch y rhif cyfan mwyaf sy'n fwy na sero, ac sydd â chydraddoldeb mwy na neu gyfartal â gwerth y rhif cyfan ei hun. Cyfradd rhif cyfan yw nifer y weithiau y mae'n ymddangos yn y rhestr. Os nad oes gwerth o'r fath, dychwelwch -1.'''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,cym_Latn,python,"
def strange_sort_list(lst):
    '''Mae'r rhestr o integrau yn cael ei ddychwelyd mewn trefn anghyffredin. Mae'r trefn anghyffredin yn digwydd pan fyddwch yn dechrau gyda'r gwerth lleiaf, yna'r uchafswm o'r integrau sy'n weddill, yna'r lleiaf ac yn y blaen.'''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,cym_Latn,python,"
def triangle_area(a, b, c):
    '''Gan fod hyd y tri ochr triongl. Dychwelyd ardal y triongl wedi'i gyllio i 2 pwynt deciwmal os yw'r tri ochr yn ffurfio triongl dilys. Fel arall dychwelyd -1 Mae tri ochr yn gwneud triongl dilys pan fydd cyfanswm unrhyw ddwy ochr yn fwy na'r trydydd ochr.'''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,cym_Latn,python,"
def will_it_fly(q,w):
    '''Ysgrifennwch swyddogaeth sy'n dychwelyd True os bydd yr gwrthrych q yn hedfan, a False fel arall. Bydd yr wrthrych q yn hedfan os yw'n gydbwys (mae'n rhestr palindromig) ac mae cyfanswm ei elfennau yn llai na neu'n hafal i'r pwysau mwyaf posibl w. Enghraifft: will_it_fly([1, 2], 5) â -> False # 1+2 yn llai na'r pwysau mwyaf posibl, ond mae'n anymgas. will_it_fly([3, 2, 3], 1) â -> False # mae'n gydbwys, ond mae 3+2+3 yn fwy na'r pwysau mwyaf posibl. will_it_fly[3, 2, 3], 9) â -> True # 3+23 yn llai na'r pwysau mwyaf posibl, ac mae'n gydbwys. will_it_fly([3], â 5) -> True # 3 yn llai na'r pwysau uchaf posibl, ac mae'n gydbwys '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,cym_Latn,python,"
def smallest_change(arr):
    """"""Mae'r broses o'r broses hon yn cynnwys y broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r broses o'r gwaith o'r gwaith o'r gwaith o'r gwaith o'r gwaith o'r gwaith o'r gwaith o'r gwaith o'r gwaith o'r gwaith o'r gwaith""""""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,cym_Latn,python,"
def total_match(lst1, lst2):
    '''Ysgrifennwch swyddogaeth sy'n derbyn dau restr o ryseitiau ac yn dychwelyd y rhestr sydd â chyfanswm o gymeriadau yn y holl ryseitiau'r rhestr yn llai na'r llall. os oes gan y ddau restr yr un nifer o gymeriadau, dychwelyd y rhestr gyntaf.'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,cym_Latn,python,"
def is_multiply_prime(a):
    """"""Ysgrifennwch swyddogaeth sy'n dychwelyd gwir os yw'r rhif a roddir yn aml-droedigaeth o 3 rhif prif ac yn ffug fel arall. Gan wybod bod (a) yn llai na 100.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,cym_Latn,python,"
def is_simple_power(x, n):
    """"""Eich tasg yw ysgrifennu swyddogaeth sy'n dychwelyd gwir os yw rhif x yn grym syml o n ac yn ffug mewn achosion eraill. x yn grym syml o n os yw n**int=x Er enghraifft: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,cym_Latn,python,"
def iscube(a):
    '''Ysgrifennwch swyddogaeth sy'n cymryd rhif cyfan a ac yn dychwelyd True os yw'r rhif hwn yn gywb o ryw rhif cyfan. Nodyn: gallwch gymryd yn ganiataol bod y mewnbwn bob amser yn ddilys.'''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,cym_Latn,python,"
def hex_key(num):
    """"""Mae'r swm yn cynnwys rhifau hecsadesimal (ar gyfer rhifau hecsadesimal, mae rhifau hecsadesimal yn rhifau cynta). Mae rhifau hecsadesimal yn cynnwys 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Mae rhifau cynta'n cynnwys 2, 3, 5, 7, 11, 13, 17,... Felly mae'n rhaid i chi benderfynu ar nifer o'r rhifau canlynol: 2, 3, 5, 7, B (= decimal 11), D (= decimal 13). Nodyn: gallwch gymryd yn ganiataol bod y cyfraddau mewnol bob amser yn gywir neu'n wag, a bod symbolau A,B,C,D,E,F bob amser yn llythyren.""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,cym_Latn,python,"
def decimal_to_binary(decimal):
    """"""Bydd y ffynhonnell yn dychwelyd llinyn, gyda phob cymeriad yn cynrychioli rhif ddwyieithog. Bydd pob cymeriad yn y llinyn yn '0' neu '1'. Bydd cwpl ychwanegol o gymeriadau 'db' ar ddechrau a diwedd y llinyn. Mae'r cymeriadau ychwanegol yno i helpu gyda'r fformat.""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,cym_Latn,python,"
def is_happy(s):
    """"""Mae'n rhaid i chi wirio a yw'r llinyn yn hapus neu beidio. Mae llinyn yn hapus os yw ei hyd yn 3 o leiaf ac mae pob 3 llythyren yn olynol yn wahanol Er enghraifft: is_happy ((a) => False is_happy ((aa) => False is_happy ((abcd) => True is_happy ((aabb) => False is_happy ((adb) => True is_happy ((xyy) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,cym_Latn,python,"
def numerical_letter_grade(grades):
    """"""Mae'n wythnos olaf y semester ac mae'r athro yn rhaid rhoi'r graddau i fyfyrwyr. Mae'r athro wedi bod yn gwneud ei algorithm ei hun ar gyfer graddau. Yr unig broblem yw ei bod wedi colli'r cod a ddefnyddiodd ar gyfer graddau. Mae hi wedi rhoi rhestr o GPAs i rai myfyrwyr i chi ac mae'n rhaid i chi ysgrifennu swyddogaeth a all all all all allforio rhestr o raddau llythyren gan ddefnyddio'r tabl ganlynol: GPA.""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,cym_Latn,python,"
def prime_length(string):
    """"""Ysgrifennwch swyddogaeth sy'n cymryd llinyn ac yn dychwelyd True os yw hyd y llinyn yn rhif cynta neu False fel arall Enghreifftiau prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,cym_Latn,python,"
def starts_one_ends(n):
    """"""Gan fod gan rhif cyfan bositif n, dychwelyd y cyfrif o rifau o rhifau cyfan bositif n-digit sy'n dechrau neu'n dod i ben gyda 1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,cym_Latn,python,"
def solve(N):
    """"""Os yw'r rhif cyfartal yn gyfanswm o'i ddifri yn binar, rhowch y cyfanswm o'i ddifri yn binar.""""""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,cym_Latn,python,"
def add(lst):
    """"""Gan roi rhestr an-gwag o integers lst. ychwanegu'r elfennau hyd yn oed sydd ar indices anhygoel..""""""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,cym_Latn,python,"
def anti_shuffle(s):
    """"""Ysgrifennwch swyddogaeth sy'n cymryd llinyn ac yn dychwelyd fersiwn orchymynedig ohono. Mae fersiwn orchymynedig o llinyn, yn llinyn lle caiff yr holl eiriau (a wahanwyd gan leoliad) eu disodli gan air newydd lle caiff yr holl gymeriadau eu trefnu mewn trefn gynyddol yn seiliedig ar werth ascii. Nodyn: Dylech gadw trefn y geiriau a'r lleoedd gwag yn y brawddeg. Er enghraifft: anti_shuffle ((('Hi') yn dychwelyd 'Hi' anti_shuffle ((('hello') yn dychwelyd 'ehllo' anti_shuffle (('Hello World!!!') yn dychwelyd 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,cym_Latn,python,"
def get_row(lst, x):
    """"""Mae data 2 dimensiwn yn cael ei roi i chi, fel rhestrau wedi'u rhestru, sy'n debyg i matris, fodd bynnag, yn wahanol i matris, gall pob rhes gynnwys nifer gwahanol o gololau. O dan lst, a rhif cyfan x, ceisiwch integers x yn y rhestr, a dychwelyd rhestr o tuples, [(x1, y1), (x2, y2) ...] fel bod pob tuple yn gyfeirnod - (rhws, cologau), gan ddechrau gyda 0. Trefnwch gyfeirnoddau yn gyntaf gan rai yn y rhwymyn. Hefyd, trefnwch gyfeirnoddau'r rhes gan gololau yn y rhwymyn.""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,cym_Latn,python,"
def sort_array(array):
    """"""Gan fod array o integrau an-negyddol, dychwelwch gopïau o'r array wedi'i ddosbarthu, byddwch yn trefnu'r array wedi'i roi mewn trefn godiadol os yw'r gyfanswm ((ar werth y gyfradd gyntaf, ar werth y gyfradd olaf) yn anhygoel, neu'n ei threfnu mewn trefn gostyngol os yw'r cyfanswm ((ar werth y cyfradd gyntaf, ar werth y cyfradd olaf) yn hyd yn oed. Nodyn: * peidiwch â newid y array a roddwyd.""""""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,cym_Latn,python,"
def encrypt(s):
    """"""Creu swyddogaeth encrypt sy'n cymryd llinyn fel argwment ac yn dychwelyd llinyn wedi'i amgryptio gyda'r alfabet yn cael ei droi. Dylai'r alfabet gael ei droi mewn modd fel bod y llythrennau'n symud i lawr gan ddau wedi'u lluosi i ddwy le. Er enghraifft: encrypt('hi') yn dychwelyd 'lm' encrypt('asdfghjkl') yn dychwelyd 'ewhjklnop' encrypt('gf') yn dychwelyd 'kj' encrypt('et') yn dychwelyd 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,cym_Latn,python,"
def next_smallest(lst):
    """"""Mae rhestr o gyfnodau cyfan wedi'i roi i chi. Ysgrifennwch swyddogaeth next_smallest (() sy'n dychwelyd yr elfen 2ydd lleiaf yn y rhestr. Yn dychwelyd None os nad oes yr elfen hwnnw. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,cym_Latn,python,"
def is_bored(S):
    """"""Bydd yn cael ei roi i chi ddirwyn o eiriau, a'ch tasg yw cyfrif nifer y boreoedd. Mae boreoedd yn frawddeg sy'n dechrau gyda'r gair ""I"". Mae frawddegau'n cael eu terfynnu gan '.', '?' neu '!'. Er enghraifft: >>> is_bored(""Hello world"") 0 >>> is_bored(""The sky is blue. The sun is shining. I love this weather"") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,cym_Latn,python,"
def any_int(x, y, z):
    '''Creu swyddogaeth sy'n cymryd 3 rhif. Mae'n dychwelyd True os yw un o'r rhifau'n gyfartal â chyfanswm y ddau arall, ac mae'r holl rifau'n rhifau cyfan. Mae'n dychwelyd False mewn unrhyw achosion eraill.'''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,cym_Latn,python,"
def encode(message):
    """"""Ysgrifennwch swyddogaeth sy'n cymryd neges, ac yn ei chodi mewn modd fel ei fod yn newid achos pob llythyren, yn disodli pob llafar yn y neges gyda'r llythyren sy'n ymddangos 2 lle o flaen y llafar hwnnw yn yr alfabet Saesneg.""""""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,cym_Latn,python,"

def skjkasdkd(lst):
    """"""Mae rhestr o integrau wedi'i roi i chi. Mae angen i chi ddod o hyd i'r gwerth prif fwyaf a dychwelyd cyfanswm ei digidiau. Enghreifftiau: Am lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] dylai'r allbwn fod yn 10 Am lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] dylai'r allbwn fod yn 25 Am lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] dylai'r allbwn fod yn 13 Am lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] dylai'r allbwn fod yn 11 Am lst = [0,81,12,31,21] dylai'r allbwn fod yn 3 Am lst = [0,1,8,2,1,7] dylai'r allbwn fod yn 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,cym_Latn,python,"
def check_dict_case(dict):
    """"""Gan fod eiriau yn cael eu rhoi mewn eiriau, dychwelyd True os yw'r holl allweddi yn llinellau mewn llythyren fach neu'r holl allweddi yn llinellau mewn llythyren fawr, fel arall dychwelyd False. Dylai'r swyddogaeth ddychwelyd False os yw'r eiriau a roddir yn wag.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,cym_Latn,python,"
def count_up_to(n):
    """"""Defnyddiwch swyddogaeth sy'n cymryd rhif cyfan nad yw'n negyddol ac yn dychwelyd llu o'r n rhif cyfan cyntaf sy'n rhifau cynta a llai na n. er enghraifft: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,cym_Latn,python,"
def multiply(a, b):
    """"""Mae'r ffynhonnell yn cymryd dau ddigid sy'n dychwelyd y cynhyrchiad o'u digid uned.""""""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,cym_Latn,python,"
def count_upper(s):
    """"""Gan roi llinell s, cyfrifwch nifer y llaisiau llafar mawr mewn indices hyd yn oed. Er enghraifft: count_upper (('aBCdEf') yn dychwelyd 1 count_upper (('abcdefg') yn dychwelyd 0 count_upper (('dBBE') yn dychwelyd 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,cym_Latn,python,"
def closest_integer(value):
    '''Creu swyddogaeth sy'n cymryd gwerth (string) sy'n cynrychioli rhif ac yn dychwelyd y rhif cyfan agosaf iddo. Os yw'r rhif yn gyfartal o ddau rhif cyfan, crynhoi'n bell oddi wrth sero. Enghreifftiau >>> closest_integer ((""10"") 10 >>> closest_integer ((""15.3"") 15 Nodyn: Mae crynhoi i ffwrdd oddi wrth sero yn golygu, os yw'r rhif a roddir yn gyfartal o ddau rhif cyfan, y rhif y dylech ei ddychwelyd yw'r un sydd fwyaf pell oddi wrth sero. Er enghraifft, dylai nearest_integer "" ((14.5"") ddychwelyd 15 a dylai nearest_integer "" ((-14.5"") ddychwelyd -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,cym_Latn,python,"
def make_a_pile(n):
    """"""Gan fod rhif cyfan bositif n, mae'n rhaid i chi wneud pentyr o n lefel o gerrig. Mae gan y lefel gyntaf n gerrig. Y nifer o gerrig yn y lefel nesaf yw: - y rhif anhygoel nesaf os yw n yn anhygoel. - y rhif hyd yn oed nesaf os yw n yn hyd yn oed. Dychwelwch nifer y gerrig ym mhob lefel mewn rhestr, lle mae elfen yn y canllaw i'n cynrychioli nifer y gerrig yn y lefel (i+1).""""""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,cym_Latn,python,"
def words_string(s):
    """"""Bydd yn cael ei roi i chi llinell o eiriau wedi'u gwahanu gan gomi neu leoliadau. Eich tasg yw rhannu'r llinell i mewn i eiriau a dychwelyd llu o'r geiriau. Er enghraifft: words_string ((""Hi, fy enw i yw John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""] words_string ((""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,cym_Latn,python,"
def choose_num(x, y):
    """"""Mae'r swyddogaeth hon yn cymryd dau rif cadarnhaol x ac y ac yn dychwelyd y rhif cyfan mwyaf hyd yn oed sy'n y ystod [x, y] yn cynnwys. Os nad oes unrhyw rif o'r fath, yna dylai'r swyddogaeth ddychwelyd -1. Er enghraifft: dewis_rhif (_num) 12, 15) = 14 dewis_rhif (_num) 13, 12) = -1 """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,cym_Latn,python,"
def rounded_avg(n, m):
    """"""Mae gennych ddau integwr cadarnhaol n ac m, a'ch tasg yw cyfrifo cyfartalog y rhifau cyfan o n hyd at m (gan gynnwys n ac m). Cerddwch yr ateb i'r rhif cyfan agosaf a'i drosi i ddeuaidd. Os yw n yn fwy na m, dychwelyd -1.""""""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,cym_Latn,python,"
def unique_digits(x):
    """"""Gan gael rhestr o integrau cadarnhaol x. dychwelyd rhestr drefnus o'r holl elfennau nad oes ganddo unrhyw ddifrod hyd yn oed. Nodyn: Dylid trefnu'r rhestr a ddychwelwyd mewn trefn gynyddol. Er enghraifft: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,cym_Latn,python,"
def by_length(arr):
    """"""O dan fwrdd o gyfanswm o gyfanswmiau, sortio'r cyfanswmiau sy'n rhwng 1 a 9 yn cynnwys, gwrthdroi'r fwrdd a ddaw o hynny, ac yna disodli pob rhif gan ei enw cyfatebol o ""Un"", ""Dwy"", ""Thro"", ""Bum"", ""Bum"", ""Sex"", ""Saith"", ""Saith"", ""Saith"", ""Dwy"". Er enghraifft: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sortio arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> gwrthdroi arr -> [8, 5, 4, 3, 2, 2, 1, 1] dychwelyd ["" wyth"", ""Bum"", ""Dwy"", ""Dwy"", ""Dwy"", ""Dwy"", ""Un""] Os yw'r fwrdd yn wag, dychwelyd fwrdd: arr = [] dychwelyd [] Os oes unrhyw rif rhyfedd yn y fwrdd, esgeulwch ef: arr = [1, -1 , 55] -> arr -> [1, 55] -> gwrthdroi [55, arr -> return = 1] - ['One'] """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,cym_Latn,python,"
def f(n):
    """"""Mae'r swyddogaeth f yn cymryd n fel paramedr, ac yn dychwelyd rhestr o faint n, fel bod gwerth yr elfen yn y mynegai i yn ffactoriol i os yw i'n hyd yn oed neu gyfanswm y rhifau o 1 i i fel arall. i yn dechrau o 1. y ffactoriol o i yw lluosiad y rhifau o 1 i i (1 * 2 * ... * i).""""""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,cym_Latn,python,"
def even_odd_palindrome(n):
    """"""Gan fod rhif cyfan positif n, dychwelwch tupl sy'n cynnwys nifer y palindromau rhif cyfan pari a phari sy'n dod o fewn y ystod ((1, n), gan gynnwys. enghraifft1: mewnbwn: 3 allbwn: (1, 2) esboniad: palindromau rhif cyfan yw 1, 2, 3. un ohonynt yn pari, a dau ohonynt yn paidd. enghraifft2: mewnbwn: 12 allbwn: (4, 6) esboniad: palindromau rhif cyfan yw 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. mae pedwar ohonynt yn pari, a 6 ohonynt yn paidd. nodyn: 1. 1 <= n <= 10^3 2. dychwelodd tupl nifer y palindromau rhif cyfan pari a phari yn y cyfres. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,cym_Latn,python,"
def count_nums(arr):
    """"""Ysgrifennwch swyddogaeth count_nums sy'n cymryd llu o integrau ac yn dychwelyd nifer yr elfennau sydd â chyfanswm o ddigwyddiadau > 0. Os yw rhif yn negyddol, yna bydd ei ddiffyg cyntaf wedi'i lofnodi yn negyddol: e.e. -123 wedi lofnodi digwyddiadau -1, 2, a 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,cym_Latn,python,"
def move_one_ball(arr):
    """"""Mae gennym ni 'arr' o N rhifau cyfanrhyth arr[1], arr[2], ..., arr[N].Bydd y rhifau yn y llu yn cael eu trefnu'n ddamweiniol. Eich tasg yw penderfynu a yw'n bosibl cael llu wedi'u trefnu mewn trefn nad yw'n gostwng trwy gyflawni'r weithrediad canlynol ar y llu: Mae'n bosibl gwneud gweithrediad symud i'r dde unrhyw nifer o weithiau. Un gweithrediad symud i'r dde yn golygu symud holl elfennau'r llu am un sefyllfa yn y cyfeiriad cywir. Bydd elfen olaf y llu yn cael ei symud i'r sefyllfa ddechrau yn y llu ie 0th. Os yw'n bosibl cael y llu wedi'i trefnu trwy gyflawni'r weithrediad uchod yna dychwelyd True fel arall dychwelyd False. Os yw'r llu wedi'i roi'n wag yna dychwelyd True. Nodyn: Mae'n sicr bod yr rhestr wedi'i roi yn cynnwys elfennau unigryw. Er enghraifft: move_one_(ball[3, 4, 5, 2]=== True Explan: By performin 2 right, non-decreasing operations can be achieved for the array.""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,cym_Latn,python,"
def exchange(lst1, lst2):
    """"""Yn y broblem hon, byddwch yn gweithredu swyddogaeth sy'n cymryd dau restr o rifau, ac yn penderfynu a yw'n bosibl cynnal cyfnewid elfennau rhyngddynt i wneud lst1 yn restr o rifau hyd yn oed yn unig. Nid oes terfyn ar nifer yr elfennau a gyfnewidir rhwng lst1 a lst2. Os yw'n bosibl cyfnewid elfennau rhwng y lst1 a lst2 i wneud yr holl elfennau o lst1 i fod hyd yn oed, dychwelyd ""YES"". Fel arall, dychwelyd ""NO"". Er enghraifft: cyfnewid [1, 2, 3, 4], [1, 2, 3, 4]) => ""YES"" cyfnewid [1, 2, 3, 4], [1, 5, 3, 4]) => ""NO"" Mae'n cael ei dybio y bydd y rhestr mewnbwn yn an-gwag. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,cym_Latn,python,"
def histogram(test):
    """"""Os yw'r llythyren yn cynnwys nifer o lythrennau sy'n digwydd yr un fath, rhowch eu holl yn ôl. Er enghraifft: histogram ((('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram ((('a b b a') == {'a': 2, 'b': 2} histogram ((('a b c a b') == {'a': 2, 'b': 2} histogram ((('b b a') == {'b 4}: histogram ((('a') == {'b 4}) == {} """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,cym_Latn,python,"
def reverse_delete(s,c):
    """"""Tasg Mae gennym ddau llinyn s a c, mae'n rhaid i chi ddileu'r holl gymeriadau yn s sy'n gyfartal i unrhyw gymeriad yn c yna gwirio a yw'r llinyn canlyniad yn palindrom. Gelwir llinyn yn palindrom os yw'n darllen yr un ffordd yn ôl ac ymlaen. Dylech ddychwelyd tuple sy'n cynnwys y llinyn canlyniad a True/False ar gyfer y gwiriad. Er enghraifft ar gyfer s = ""abcde"", c = ""ae"", dylai'r canlyniad fod ('bcd', False) Ar gyfer s = ""abcdef"", c = ""b"" dylai'r canlyniad fod ('acdef', False) Ar gyfer s = ""abcdedcba"", c = ""ab"", dylai'r canlyniad fod ('cdedc', True)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,cym_Latn,python,"
def odd_count(lst):
    """"""Gan gael rhestr o ryseitiau, lle mae pob llinyn yn cynnwys digidau yn unig, dychwelwch restr. Dylai pob elfen i o'r allbwn fod yn ""y nifer o elfennau anhygoel yn y llinyn i o'r mewnbwn. "" lle dylid disodli'r holl i gan nifer y digidau anhygoel yn y i'th llinyn o'r mewnbwn. >>> odd_count['1234567']) [""y nifer o elfennau anhygoel 4n y str4ng 4 o'r 4nput.""] >>> odd_count['3',""111111""]) [""y nifer o elfennau anhygoel 1n y str1ng 1 o'r 1nput."", ""y nifer o elfennau anhygoel 8n y str8ng 8 o'r 8nput.""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,cym_Latn,python,"
def minSubArraySum(nums):
    """"""O dan fwrdd o gyfres o enillion cyfan, ceisiwch ddod o hyd i gyfanswm lleiaf unrhyw is-fwrdd o enillion nad yw'n wag.""""""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,cym_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Mae gan bob ffynnon bwthyn sy'n gallu cael dŵr o'r ffynnon, ac mae pob bwthyn yn gallu cael dŵr o'r bwthyn. Eich tasg yw defnyddio'r bwthyn i golchi'r bwthyn. Pwrpas y bwthyn yw gollwng y bwthyn. Pwrpas y bwthyn yw gollwng y bwthyn. Pwrpas y bwthyn yw gollwng y bwthyn.""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,cym_Latn,python,"
def sort_array(arr):
    """"""Yn y Kata hwn, mae'n rhaid i chi drefnu llu o integrau an-negyddol yn ôl nifer y rhai yn eu cynrychiolaeth ddeuaidd mewn trefn gynyddol. Ar gyfer nifer tebyg o rai, sortio yn seiliedig ar werth decimaidd. Rhaid ei weithredu fel hyn: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,cym_Latn,python,"
def select_words(s, n):
    """"""O dan gyfres s a rhif naturiol n, mae'n rhaid i chi weithredu swyddogaeth sy'n dychwelyd rhestr o'r holl eiriau o gyfres s sy'n cynnwys union n o gwnsonetau, er mwyn i'r geiriau hyn ymddangos yn y gyfres s. Os yw'r gyfres s yn wag, dylai'r swyddogaeth ddychwelyd rhestr wag. Nodyn: efallai y byddwch yn tybio bod y cyfres mewnol yn cynnwys llythrennau a gofod yn unig.""""""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,cym_Latn,python,"
def get_closest_vowel(word):
    """"""Mae'r gair yn cael ei roi i chi. Eich tasg yw dod o hyd i'r llafar agosach sy'n sefyll rhwng dau gonsonant o ochr dde'r gair (cyfyngedig i lythyren). Nid yw llafar yn y dechrau a'r diwedd yn cyfrif. Dychwelyd llinell wag os nad ydych wedi dod o hyd i unrhyw llafar yn cwrdd â'r amod uchod. Gallwch gymryd yn ganiataol bod y llinell a roddwyd yn cynnwys llythyren Saesneg yn unig.""""""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,cym_Latn,python,"
def match_parens(lst):
    '''Mae rhestr o ddau llinyn yn cael ei roi i chi, mae'r ddau llinyn yn cynnwys parentesi agored '(' neu parentesi cau ') ' yn unig. Eich swydd chi yw gwirio a yw'n bosibl cyd-gynnwys y ddau llinyn mewn rhywfaint o drefn, y bydd y llinyn sy'n deillio yn dda. Mae llinyn S yn cael ei ystyried yn dda os ac dim ond os yw'r holl parentesi yn S yn gydbwys. Er enghraifft: mae'r llinyn '((()) ' yn dda, tra nad yw'r llinyn '()) '. Trowch 'Ie' os oes ffordd o wneud llinyn da, a dychwelyd 'Na' fel arall.'''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,cym_Latn,python,"
def maximum(arr, k):
    """"""Gan roi argraff o integerau ac integwr cadarnhaol k, dychwelwch restr sortio o hyd k gyda'r uchafswm o k o rifau yn arr.""""""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,cym_Latn,python,"
def solution(lst):
    """"""Gan fod rhestr o integrau heb fod yn wag, dychwelyd cyfanswm yr holl elfennau anhygoel sydd mewn sefyllfaoedd hyd yn oed.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,cym_Latn,python,"
def add_elements(arr, k):
    """"""Gan fod array o integrau arr ac integro k, dychwelwch gyfanswm yr elfennau sydd â dau ddiffyg o'r k elfennau cyntaf arr.""""""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,cym_Latn,python,"
def get_odd_collatz(n):
    """"""Os yw'r term blaenorol yn gyfartal, mae'r term nesaf yn hanner y term blaenorol. Os yw'r term blaenorol yn anghysbell, mae'r term nesaf yn 3 gwaith y term blaenorol ynghyd â 1. Y dyfalu yw, ni waeth pa werth o n, bydd y dilyniant bob amser yn cyrraedd 1. Nodyn: 1. Collatz (((1) yw [1]. 2. Llwystysgodd y dilyniant yn gynyddol. Er enghraifft: get_odd_collatz ((5) yn dychwelyd [1, 5] # Mae dilyniant Collatz ar gyfer 5 yn [5, 8, 16, 4, 2, 1], felly dim ond 1, a 5 yw'r rhifau anghysbell.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,cym_Latn,python,"
def valid_date(date):
    """"""Mae'n rhaid i chi ysgrifennu swyddogaeth sy'n dilysu llinyn dyddiad a dychwelyd True os yw'r dyddiad yn ddilys fel arall False. Mae'r dyddiad yn ddilys os yw'r holl reolau canlynol yn cael eu bodloni: 1. Nid yw'r llinyn dyddiad yn wag. 2. Nid yw'r nifer o ddyddiau yn llai na 1 na'n uwch na 31 diwrnod ar gyfer misoedd 1,3,5,7,8,10,12. Ac nid yw'r nifer o ddyddiau yn llai na 1 na'n uwch na 30 diwrnod ar gyfer misoedd 4,6,9,11. Ac, nid yw'r nifer o ddyddiau yn llai na 1 na'n uwch na 29 ar gyfer mis 2. 3. Ni ddylai'r misoedd fod yn llai na 1 na'n uwch na 12. 4. Dylai'r dyddiad fod yn y fformat: mm-dddd-yyyy er enghraifft: valid_date (('03-11-2000') => True_date (('15-01-2012') => False valid_date (('04-040') => False_date (('06-04-2020') => True_date (('06-04/2020')""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,cym_Latn,python,"
def split_words(txt):
    '''Gan roi llinell o eiriau, dychwelyd rhestr o eiriau wedi'u rhannu ar leoliadau, os nad oes lleoliadau yn y testun dylech ei rannu ar gomion ',' os nad oes gomion dylech ddychwelyd nifer y llythrennau bach gyda threfn afreolus yn yr wyddor, ord('a') = 0, ord'(b') = 1, ... ord('z') = 25 Enghreifftiau split_words ((""Hello world!"") â -> [""Hello"", ""world!""] split_words ((""Hello,world!"") â -> [""Hello"", ""world!"" split_words"")'''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,cym_Latn,python,"
def is_sorted(lst):
    '''Os oes rhestr o rifau, dychwelyd os ydynt wedi'u sortio mewn trefn gynyddol. Os oes mwy na 1 dyblyg o'r un rhif yn y rhestr, dychwelyd False. Dylai dim rhifau negyddol a dim ond rhifau cyfan.'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,cym_Latn,python,"
def intersection(interval1, interval2):
    """"""Mae dau gyfres o gyfres yn cael eu rhoi i chi, lle mae pob cyfres yn pâr o gyfresiau cyfartalog. Er enghraifft, cyfres = (gan ddechrau, diwedd) = (1, 2). Mae'r cyfres wedi'i gau, sy'n golygu bod y cyfres (gan ddechrau, diwedd) yn cynnwys y ddau ddechrau a'r diwedd. Ar gyfer pob cyfres, mae'n debyg bod ei ddechrau yn llai na neu'n hafal i'w diwedd. Eich tasg yw penderfynu a yw hyd y groesfan y ddau gyfres hwn yn rhif cynta. Er enghraifft, mae croesfan y cyfres (1, 3), (2, 4) yn (2, 3) sydd â hyd yn 1, nad yw'n rhif cynta. Os yw hyd y groesfan yn rhif cynta, dychwelwch ""YES"", fel arall, dychwelwch ""NO"". Os nad yw'r ddau gyfres yn croesi, dychwelwch ""NO"".""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,cym_Latn,python,"
def prod_signs(arr):
    """"""Mae'n rhaid i chi ddychwelyd cyfanswm y nifer o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o gyfrannau o""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,cym_Latn,python,"
def minPath(grid, k):
    """"""Os oes grid gyda N o linellau a N o golofn (N >= 2) ac un rhif cyfan cadarnhaol k, mae pob celloedd y grid yn cynnwys gwerth. Mae pob rhif cyfan yn y ystod [1, N * N] yn ymddangos yn union unwaith ar y celloedd y grid. Mae'n rhaid i chi ddod o hyd i'r llwybr lleiaf o hyd k yn y grid. Gallwch ddechrau o unrhyw gelyn, ac ym mhob cam gallwch symud i unrhyw un o'r celloedd cyfagos, mewn geiriau eraill, gallwch fynd i gelloedd sy'n rhannu ymyl gyda'ch celloedd presennol. Sylwch fod llwybr o hyd k yn golygu ymweld â k o gelloedd yn union (nid yn ofynnol yn wahanol). NI ALLwch fynd allan o'r grid. Gellir ystyried llwybr A (o hyd k) yn llai na llwybr B (o hyd k) os ar ôl gwneud y rhestrau ordeiniedig o'r gwerthoedd ar y celloedd sy'n mynd trwy A a B (gwelsom nhw yn l_Ast a l_Ast), mae'r llwybr lleiaf yn llai na'r llwybr lleiaf yn llesiograffig, yn lleiaidd arall, mae'n gyfrif cyfartal i'r cyfredol gyda chi.""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,cym_Latn,python,"
def tri(n):
    """"""Mae pawb yn gwybod am olrhain Fibonacci, fe'i hastudwyd yn ddwfn gan mathemategiaid yn y ddwy ganrif diwethaf. Fodd bynnag, yr hyn nad yw pobl yn ei wybod yw olrhain Tribonacci. Mae olrhain Tribonacci yn cael ei ddiffinio gan yr ailgyfeirio: tri(1) = 3 tri(n) = 1 + n / 2, os yw n yn hyd yn oed. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), os yw n yn afreolaidd. Er enghraifft: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Mae rhiflen gyfan an-negyddol yn cael ei roi i chi, mae'n rhaid i chi ddychwelyd rhestr o'r rhifau cyntaf n + 1 o olr olrhain Tribonacci.""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,cym_Latn,python,"
def digits(n):
    """"""Gan roi rhif cyfan bositif n, dychwelyd y cynnyrch o'r rhifau anhygoel. dychwelyd 0 os yw'r holl rhifau yn hyd yn oed. Er enghraifft: rhifau ((1) == 1 rhif ((4) == 0 rhif ((235) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,cym_Latn,python,"
def is_nested(string):
    '''Creu swyddogaeth sy'n cymryd llinyn fel mewnbwn sy'n cynnwys braced sgwâr yn unig. Dylai'r swyddogaeth ddychwelyd True os ac dim ond os oes is-gyfres ddilys o braced lle mae o leiaf un braced yn y is-gyfres wedi'i neidio. is_nested (('[[]]') â -> True is_nested (('[]]]]]]]] [[[[[[[]') â -> False is_nested (('[][]') â -> False is_nested (('[]') â -> False is_nested (('[[]]') â -> True is_nested (('[[]]') â -> True'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,cym_Latn,python,"

def sum_squares(lst):
    """"""Mae rhestr o rifau wedi'i roi i chi. Mae angen i chi ddychwelyd cyfanswm y rhifau wedi'u cymhwyso'n sgwâr yn y rhestr a roddwyd, a chyrraedd pob elfen yn y rhestr i'r int uchaf ((Cefn) yn gyntaf.""""""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,cym_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Creu swyddogaeth sy'n dychwelyd True os yw cymeriad olaf llinell benodol yn gymeriad alfabetaidd ac nid yw'n rhan o air, ac False fel arall. Nodyn: ""word"" yw grŵp o gymeriadau wedi'u gwahanu gan leoliad.'''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,cym_Latn,python,"
def can_arrange(arr):
    """"""Creu swyddogaeth sy'n dychwelyd y mynegai mwyaf o elfen nad yw'n fwy na neu'n hafal i'r elfen sy'n ei flaen yn syth. Os nad oes unrhyw elfen o'r fath yna dychwelyd -1. Ni fydd y fwrdd a roddir yn cynnwys gwerthoedd dyblyg.""""""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,cym_Latn,python,"
def largest_smallest_integers(lst):
    '''Creu swyddogaeth sy'n dychwelyd tupl (a, b), lle mae 'a' yn y mwyaf o integrau negyddol, a 'b' yn y lleiaf o integrau cadarnhaol mewn rhestr. Os nad oes unrhyw integrau negyddol neu gadarnhaol, dychwelwch nhw fel None.'''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,cym_Latn,python,"
def compare_one(a, b):
    """"""Creu swyddogaeth sy'n cymryd rhifau cyfan, flotiaid, neu llinynnau sy'n cynrychioli rhifau go iawn, ac yn dychwelyd y newidyn mwyaf yn ei math newidyn penodol. Nid yw'n dychwelyd os yw'r gwerthoedd yn gyfartal. Nodyn: Os yw rhif go iawn yn cael ei gynrychioli fel llinyn, gallai'r pwynt symudol fod yn . neu , compare_one(1, 2.5) â -> 2.5 compare_one(1, ""2,3"") â -> ""2,3"" compare_one(""5,1"", ""6"") â -> ""6"" compare_one(""1"", 1) â -> Dim """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,cym_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Asesu a ellir ysgrifennu'r rhif n a roddwyd fel cyfanswm o union 4 rhif cyfyng cadarnhaol.""""""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,cym_Latn,python,"
def special_factorial(n):
    """"""Mae'r ffactoriol Brasil yn cael ei ddiffinio fel: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! lle mae n > 0 Er enghraifft: >>> special_factorial ((4) 288 Bydd y swyddogaeth yn derbyn rhif cyfan fel mewnbwn a dylai ddychwelyd y ffactoriol arbennig o'r rhif cyfan hwn. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,cym_Latn,python,"
def fix_spaces(text):
    """"""_Dangosfa-3inell, disodli'r holl leoliadau ynddo â is-gwelynnau, ac os oes gan llinell fwy na 2 leoliad cyflym, yna disodli'r holl leoliadau cyflym â - fix_spaces ((""Esemell"") == ""Esemell"" fix_spaces ((""Esemell1"") == ""Esemell_1"" fix_spaces (((""Esemell2"") == ""_Esemell_2"" fix_spaces ((""Esemell 3"") == ""_Esemell-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,cym_Latn,python,"
def file_name_check(file_name):
    """"""Creu swyddogaeth sy'n cymryd llinyn sy'n cynrychioli enw ffeil, ac yn dychwelyd 'Ie' os yw enw'r ffeil yn ddilys, ac yn dychwelyd 'Na' fel arall. Dylid ystyried enw ffeil yn ddilys os ac yn unig os bod yr holl amodau canlynol yn cael eu bodloni: - Ni ddylai fod mwy na thri digid ('0'-'9') yn enw'r ffeil. - Dylai enw'r ffeil gynnwys un dot '.' - Ni ddylai'r is-ryn cyn y dot fod yn wag, ac mae'n dechrau gyda llythyren o'r alffa latin ('a'-'z' a 'A'Z'). - Dylai'r is-ryn ar ôl y dot fod yn un o'r canlynol: ['txt', 'exe', 'lld'] Enghreifftiau: file_name_check""(example.txt"") # => 'Yes' file_name_check""(example.dll1"") => 'Na' # => ' (dylai'r enw ddechrau gyda llythyren alffa latin)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,cym_Latn,python,"


def sum_squares(lst):
    """""""" Bydd y swyddogaeth hon yn cymryd rhestr o integrau. Ar gyfer yr holl gofnodion yn y rhestr, bydd y swyddogaeth yn ail-gyfeirio'r cofnod rhif cyfan os yw ei index yn amlwaith o 3 ac yn ei chwblhau'r cofnod rhif cyfan os yw ei index yn amlwaith o 4 ac nid amlwaith o 3. Ni fydd y swyddogaeth yn newid y cofnodion yn y rhestr nad yw eu hanfodion yn amlwaith o 3 neu 4. Bydd y swyddogaeth wedyn yn dychwelyd cyfanswm yr holl gofnodion.""""""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,cym_Latn,python,"
def words_in_sentence(sentence):
    """"""Mae'n rhaid i chi ddychwelyd llinell sy'n cynnwys geiriau o'r frawddeg wreiddiol, y mae eu hyd yn rhifau cynta, dylai trefn y geiriau yn y llinell newydd fod yr un fath â'r un wreiddiol.""""""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,cym_Latn,python,"
def simplify(x, n):
    """"""Eich tasg yw gweithredu swyddogaeth a fydd yn symleiddio'r ymadrodd x * n. Mae'r swyddogaeth yn dychwelyd True os yw x * n yn gwerthuso i rhif cyfan ac False fel arall. Mae'r ddau x ac n, yn gynrychiolaeth llinyn o ffracsiwn, ac mae ganddynt y fformat canlynol, <numerator>/<denominator> lle mae'r rhifydd a'r enwau yn rhifau cyfan cadarnhaol. Gallwch gymryd yn ganiataol bod x, a n yn ffracsiynau dilys, ac nad oes ganddynt sero fel enwau. symleiddio "" 1/5 "", ""5/1"") = True symleiddio "" 1/6 "", ""2/1"") = False symleiddio "" 7/10 "", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,cym_Latn,python,"
def order_by_points(nums):
    """"""Ysgrifennwch swyddogaeth sy'n sortio'r rhestr o gyfanswm o ddegiau mewn trefn gynyddol yn ôl cyfanswm eu digiau. Nodyn: os oes sawl eitem gyda chyfanswm tebyg o'u digiau, gorchymyn nhw yn seiliedig ar eu haenod yn y rhestr wreiddiol. Er enghraifft: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,cym_Latn,python,"
def specialFilter(nums):
    """"""Ysgrifennwch swyddogaeth sy'n cymryd llu o rifau fel mewnbwn ac yn dychwelyd nifer yr elfennau yn y llu sy'n fwy na 10 ac mae'r rhifau cyntaf a'r olaf o rifau rhif yn anhygoel (1, 3, 5, 7, 9). Er enghraifft: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,cym_Latn,python,"
def get_max_triples(n):
    """"""Mae rhif cyfartal positif n wedi'i roi i chi. Mae'n rhaid i chi greu llu o rhifau cyfartal a o hyd n. Ar gyfer pob i (1 ‰¤ i ‰¤ n), gwerth a[i] = i * i - i + 1. Trowch yn ôl nifer y tripl (a[i], a[j], a[k]) o a lle mae i < j < k, ac a[i] + a[j] + a[k] yn amlwaith o 3.""""""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,cym_Latn,python,"
def bf(planet1, planet2):
    '''Mae wyth o blanediau yn ein system solar: y mwyaf agos at yr Haul yw Mercur, y nesaf yw Venus, yna Ddaear, Mars, Jupiter, Saturn, Uranus, Neptun. Ysgrifennwch swyddogaeth sy'n cymryd dau enw planed fel llinynnau planet1 a planet2. Dylai'r swyddogaeth ddychwelyd tuple sy'n cynnwys yr holl blanediau y mae eu cyrbeidiaeth yn cael eu lleoli rhwng orbit planed1 a orbit planed2, wedi'u threfnu yn ôl y agosrwydd at yr haul. Dylai'r swyddogaeth ddychwelyd tuple gwag os nad yw planet1 neu planet2 yn enwau planed cywir.'''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,cym_Latn,python,"
def sorted_list_sum(lst):
    """"""Ysgrifennwch swyddogaeth sy'n derbyn rhestr o ryseitiau fel paramedr, yn dileu'r ryseitiau sydd â hydiau anhygoel ohono, ac yn dychwelyd y rhestr a ganlyniad gyda threfn drefnus. Y rhestr bob amser yn rhestr o ryseitiau ac nid yw'n fwrdd o rifau, ac efallai y bydd yn cynnwys dyblygiadau. Dylai trefn y rhestr fod yn codi gan hyd pob gair, a dylech ddychwelyd y rhestr wedi'i drefnu gan y rheol honno. Os oes gan ddau air yr un hyd, trefnu'r rhestr yn ôl yr wyddor. Dylai'r swyddogaeth ddychwelyd rhestr o ryseitiau mewn trefn drefnus. Gallwch gymryd yn ganiataol y bydd gan bob gair yr un hyd. Er enghraifft: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => [""ab"", ""cd""]""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,cym_Latn,python,"
def x_or_y(n, x, y):
    """"""Rhaglen syml a ddylai ddychwelyd gwerth x os yw n yn rhif cynta a ddylai ddychwelyd gwerth y fel arall.""""""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,cym_Latn,python,"
def double_the_difference(lst):
    '''O dan restr o rifau, dychwelyd cyfanswm craddodiadau'r rhifau yn y rhestr sy'n anhygoel. esgeuluso rhifau sy'n negyddol neu nad ydynt yn integrau. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Os yw'r rhestr mewnbwn yn wag, dychwelyd 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,cym_Latn,python,"
def compare(game,guess):
    """"""Mae'n debyg ein bod i gyd yn cofio'r teimlad hwnnw pan fydd canlyniad rhai digwyddiadau hir-ddisgwyliedig yn cael ei wybod yn y pen draw. Mae'r teimladau a'r meddyliau sydd gennych ar y funud hwnnw yn bendant yn werth nodi a chymharu. Eich tasg yw penderfynu a yw person wedi dyfalu canlyniadau nifer o gyfatebion yn gywir. Rhoddir i chi ddau fwrdd o sgorau a dyfalu o hyd yr un fath, lle mae pob tynnwys yn dangos cyfatebiad. Dychwelwch â fwrdd o'r un hyd yn nodi pa mor bell oedd pob dyfalu. Os ydynt wedi dyfalu'n gywir, y gwerth yw 0, ac os nad yw, y gwerth yw'r gwahaniaeth absoliwt rhwng y dyfalu a'r sgôr. enghraifft: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare ((([0,5,0,0,4],[4,1,0,2,]) -> [4,0,1,0,6]""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,cym_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Bydd enw dosbarth (string) a rhestr o estyniadau yn cael eu rhoi i chi. Bydd y estyniadau'n cael eu defnyddio i lwytho dosbarthiadau ychwanegol i'r dosbarth. Y cryfder yr estyniad yw fel a ganlyn: Gadewch i CAP fod yn nifer y llythrennau mawr yn enw'r estyniad, a gadewch i SM fod yn nifer y llythrennau bach yn enw'r estyniad, rhoddir y cryfder gan y darn CAP - SM. Dylech ddod o hyd i'r estyniad cryf a dychwelyd llinyn yn y fformat hwn: ClassName.StrongestExtensionName. Os oes dau neu fwy o estyniadau gyda'r un cryfder, dylech ddewis yr un sy'n dod gyntaf yn y rhestr. Er enghraifft, os ydych yn cael ""Slices"" fel y dosbarth a rhestr o'r estyniadau: ['SEviviSliNGCes', 'Cheese', 'StuFfed'] yna dylech ddychwelyd 'Slices.SEviSliNGCes' gan fod 'SliviSliNGCes' yn 'myliviSliNG' (mySliSEviCes' is the strongest extension) ', yr estyniad yn cael ei roi gan y fracsiad CAP - SM.""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,cym_Latn,python,"
def cycpattern_check(a , b):
    """"""Mae gennych 2 gair. Mae angen i chi ddychwelyd True os yw'r ail gair neu unrhyw un o'i droedigaethau yn is-string yn y gair cyntaf cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,cym_Latn,python,"
def even_odd_count(num):
    """"""Gan fod rhif cyfan, dychwelyd tupl sy'n cynnwys nifer y rhifau pari a'r digid yn y drefn honno.""""""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,cym_Latn,python,"
def int_to_mini_roman(number):
    """"""Gan fod rhif cyfan bositif, dewch o hyd i'w gyfatebol rhif Rhufeinig fel llinyn, a'i dychwelyd mewn llythyren fach.""""""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,cym_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Mae triongl gywir yn driongl lle mae un o'r onglau yn ongl dde neu 90 gradd.'''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,cym_Latn,python,"
def find_max(words):
    """"""Ysgrifennwch swyddogaeth sy'n derbyn rhestr o ryseitiau. Mae'r rhestr yn cynnwys geiriau gwahanol. Dychwelyd y gair gyda'r uchafswm o gymeriadau unigryw. Os oes gan ryseitiau lluosog y uchafswm o gymeriadau unigryw, dychwelyd yr un sy'n dod yn gyntaf yn yr ordrefn eiregyddol. find_max (([""enw"", ""o"", ""string""]) == ""string"" find_max (([""enw"", ""enam"", ""gêm""]) == ""enam"" find_max (([""aaaaaaa"", ""bb"" , ""cc""]) == """"aaaaaaa"" """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,cym_Latn,python,"
def eat(number, need, remaining):
    """"""Rydych yn fwrdd newynog, ac rydych eisoes wedi bwyta nifer penodol o garwts, ond nawr mae angen i chi fwyta mwy o garwts i gwblhau prydau'r dydd. dylech ddychwelyd llu o [y nifer cyfanswm o garwts wedi'u bwyta ar ôl eich prydau, nifer y garwts sydd ar ôl eich prydau ] os nad oes digon o garwts sy'n weddill, byddwch yn bwyta'r holl garwts sy'n weddill, ond byddwch yn dal i fod yn newynog. Er enghraifft: * bwyta ((5, 6, 10) -> [11, 4] * bwyta ((4, 8, 9) -> [12, 1] * bwyta ((1, 10, 10) -> [11, 0] * bwyta ((2, 11, 5) -> [7, 0] Amrywiol: @number: rhif gyfan y nifer o garwts rydych wedi'u bwyta. @need: rhif gyfan y nifer o garwts sydd angen i chi eu bwyta. @remaining: rhif gyfan y nifer o garwts sy'n weddill yn y stoc Constrain: *= 0 <= 0 * 1000 <= 0 * 1000 <= 0 = 1000 = 1000 = <= 1000 = 1000 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,cym_Latn,python,"
def do_algebra(operator, operand):
    """"""Mae'r rhestr gyntaf yn cynnwys gweithrediadau algebra sylfaenol, a'r ail rhestr yn cynnwys rhestr o integrau. Defnyddiwch y ddau restr a roddir i adeiladu'r mynegiad algebraidd a dychwelyd gwerthusiad yr ymadrodd hwn. Y gweithrediadau algebra sylfaenol: Cyfansoddiad (+) Gwrthod ( - ) Multiplikiaeth ( *) Rhannu llawr ( //) Exponentiation ( **) Er enghraifft: operator['+', '*', '-'] array = [2, 3, 4, 5] result = 2 + 3 * 4 - 5 => result = 9 Nodyn: Mae hyd y rhestr o weithredwyr yn hafal i hyd y rhestr o weithredwyr minus un. Mae'r operand yn rhestr o integrau an-negyddol. Mae gan y gweithredwr o leiaf un rhestr o weithredwyr, ac mae gan y rhestr o weithredwyr o leiaf ddau weithredwr. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,cym_Latn,python,"
def solve(s):
    """"""Mae'r swyddogaeth yn dychwelyd y swyddogaeth a gafwyd o ganlyniad.""""""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,cym_Latn,python,"
def string_to_md5(text):
    """"""Os yw'r ddolen 'text' yn ddolen wag, dychwel None. >>> string_to_md5 (('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,cym_Latn,python,"
def generate_integers(a, b):
    """"""Gan roi dau gyfrif cyflawn cadarnhaol a a b, dychwelyd y rhifau hyd yn oed rhwng a a b, mewn trefn godiadol. Er enghraifft: generate_integers(2, 8) => [2, 4, 6, 8] generate_integers(8, 2) => [2, 4, 6, 8] generate_integers(10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
