[{"task_id":"HumanEval_0","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 주어진 임계. \/\/\/ 주어진 숫자의 벡터에서, 보다 두 개의 숫자가 서로 더 가깝는지 확인합니다.\/\/\/ >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)\n\/\/\/ false\n\/\/\/ >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n\/\/\/ true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n","canonical_solution":"fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n                return true;\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"},{"task_id":"HumanEval_1","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 입력 문자열에 있는 모든 공백을 무시합니다. \/\/\/ 개별 그룹은 균형 잡힌 (각 오픈 브레이크는 적절하게 닫힌) 그리고 서로 안쪽에 둥지를 짓지 않습니다.\/\/\/ 그 그룹을 별도의 문자열로 분리하고 그 벡터를 반환합니다. \/\/\/ 이 함수의 입력은 둥글게 된 괄호의 여러 그룹을 포함하는 문자열입니다. 당신의 목표는 \/\/\/ >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n\/\/\/ vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n","canonical_solution":"fn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut groups = Vec::new();\n    let mut current_group = String::new();\n    let mut open_count = 0;\n\n    for char in paren_string.chars() {\n        if char == '(' {\n            open_count += 1;\n            current_group.push(char);\n        } else if char == ')' {\n            open_count -= 1;\n            current_group.push(char);\n        }\n\n        if open_count == 0 && !current_group.is_empty() {\n            groups.push(current_group.clone());\n            current_group.clear();\n        }\n    }\n\n    groups\n}","tests":"}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n"},{"task_id":"HumanEval_2","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 숫자의 소수점을 반환합니다. \/\/\/ (남은 부분은 항상 1보다 작습니다.)\/\/\/ 그리고 정수 부분 (주기된 숫자보다 작은 최대 정수) 과 소수점 \/\/\/ 양수 부동 소수점을 주어, 로 분해될 수 있습니다.\/\/\/ >>> truncate_number(3.5)\n\/\/\/ 0.5\nfn truncate_number(number: f64) -> f64 {\n","canonical_solution":"fn truncate_number(number: f64) -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    println!(\"{}\", truncate_number(3.5)); \/\/ 0.5\n}","tests":"}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"},{"task_id":"HumanEval_3","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 이 지점에서 함수는 true를 반환해야 합니다. 그렇지 않으면 false를 반환해야 합니다.\/\/\/ 0 잔액. 당신의 임무는 어떤 시점에서 계좌 잔액이 0 이하로 떨어지는지 감지하는 것입니다. 그리고 \/\/\/ 은행 계좌에 입금 및 인출 작업의 벡터가 주어집니다.\/\/\/ >>> below_zero(vec![1, 2, 3])\n\/\/\/ false\n\/\/\/ >>> below_zero(vec![1, 2, -4, 5])\n\/\/\/ true\nfn below_zero(operations: Vec<isize>) -> bool {\n","canonical_solution":"fn below_zero(operations: Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations {\n        balance += operation;\n        if balance < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", below_zero(vec![1, 2, 3])); \/\/ false\n    println!(\"{}\", below_zero(vec![1, 2, -4, 5])); \/\/ true\n    println!(\"{}\", below_zero(vec![1, -1, -1, 2])); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"},{"task_id":"HumanEval_4","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ MAD = 평균 ∙ x - x_mean ∙\/\/\/ 요소와 중심점 (이 경우 평균): \/\/\/ 평균 절대 오차는 각  사이의 평균 절대 차이입니다.\/\/\/ 이 데이터 세트의 평균에 가깝습니다. \/\/\/ 입력 숫자의 주어진 벡터에 대해, 평균 절대 오차를 계산합니다.\/\/\/ >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])\n\/\/\/ 1.0\nfn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n","canonical_solution":"fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n    let n = numbers.len() as f64;\n    if n == 0.0 {\n        return 0.0;\n    }\n\n    let mean: f64 = numbers.iter().sum::<f64>() \/ n;\n    let mad: f64 = numbers.iter().map(|&x| (x - mean).abs()).sum::<f64>() \/ n;\n    \n    mad\n}\n\nfn main() {\n    let numbers = vec![1.0, 2.0, 3.0, 4.0];\n    println!(\"{}\", mean_absolute_deviation(numbers)); \/\/ Output: 1.0\n}","tests":"}\n\nfn main() {\n    let candidate = mean_absolute_deviation;\n    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);\n}\n"},{"task_id":"HumanEval_5","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 입력 벡터 `numbers'의 2개의 연속적인 요소들 사이에 'delimeter'라는 숫자를 삽입한다.\/\/\/ >>> intersperse(vec![], 4)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> intersperse(vec![1, 2, 3], 4)\n\/\/\/ vec![1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {\n","canonical_solution":"fn intersperse(numbers: Vec<isize>, delimiter: isize) -> Vec<isize> {\n    if numbers.is_empty() {\n        return Vec::new();\n    }\n    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);\n    for (i, &num) in numbers.iter().enumerate() {\n        result.push(num);\n        if i != numbers.len() - 1 {\n            result.push(delimiter);\n        }\n    }\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", intersperse(vec![], 4)); \/\/ Output: Vec::<isize>::new()\n    println!(\"{:?}\", intersperse(vec![1, 2, 3], 4)); \/\/ Output: vec![1, 4, 2, 4, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"},{"task_id":"HumanEval_6","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어 (() (()) 은 최대 2개의 둥지 층을 가지고 있고 ((())) 은 3개의 둥지 층을 가지고 있습니다. \/\/\/ 각 그룹에 대해 가장 깊은 괄호의 둥지를 입력합니다.\/\/\/ 이 함수의 입력값은 스펙으로 분리된 둥글게 된 괄호를 위한 여러 그룹을 나타내는 문자열입니다. \/\/\/ >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n\/\/\/ vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n","canonical_solution":"fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n    paren_string.split_whitespace().map(|group| {\n        let mut max_depth = 0;\n        let mut current_depth = 0;\n        for char in group.chars() {\n            match char {\n                '(' => {\n                    current_depth += 1;\n                    if current_depth > max_depth {\n                        max_depth = current_depth;\n                    }\n                },\n                ')' => {\n                    current_depth -= 1;\n                },\n                _ => {}\n            }\n        }\n        max_depth\n    }).collect()\n}\n\nfn main() {\n    let result = parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"));\n    println!(\"{:?}\", result); \/\/ Output: [2, 3, 1, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n"},{"task_id":"HumanEval_7","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 입력 벡터에서 주어진 하위 문자열을 포함하고 있는 문자열을 필터링합니다.\/\/\/ >>> filter_by_substring(vec![], String::from(\"a\"))\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> filter_by_substring(vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n\/\/\/ vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"array\")]\nfn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n","canonical_solution":"fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n    strings.into_iter().filter(|s| s.contains(&substring)).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\")), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"},{"task_id":"HumanEval_8","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 빈 합은 0과 빈 곱은 1이 되어야 합니다.\/\/\/ 주어진 정수 벡터에 대해, 벡터 내의 모든 정수의 합과 곱으로 이루어진 튜플을 반환합니다. \/\/\/ >>> sum_product(vec![])\n\/\/\/ (0, 1)\n\/\/\/ >>> sum_product(vec![1, 2, 3, 4])\n\/\/\/ (10, 24)\nfn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n","canonical_solution":"fn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n}\n\nfn main() {\n    println!(\"{:?}\", sum_product(vec![])); \/\/ (0, 1)\n    println!(\"{:?}\", sum_product(vec![1, 2, 3, 4])); \/\/ (10, 24)\n}","tests":"}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"},{"task_id":"HumanEval_9","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 순서대로. \/\/\/ 주어진 정수 벡터에서 주어진 순간까지 발견된 롤링 최대 요소의 벡터를 생성합니다.\/\/\/ >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n\/\/\/ vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max = isize::MIN;\n    for &num in &numbers {\n        if num > current_max {\n            current_max = num;\n        }\n        result.push(current_max);\n    }\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"},{"task_id":"HumanEval_10","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ - 줄의 끝부분에 팔린드로믹 접두사 앞에 있는 줄 접두사를 붙여주십시오. \/\/\/ - 제공된 문자열의 가장 긴 포스트픽스를 찾아서 팔린드로마를 구합니다. \/\/\/ 알고리즘 아이디어는 간단합니다: \/\/\/ 주어진 문자열로 시작하는 가장 짧은 팔린드로임을 찾아보세요. \/\/\/ >>> make_palindrome(String::from(\"\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> make_palindrome(String::from(\"cat\"))\n\/\/\/ String::from(\"catac\")\n\/\/\/ >>> make_palindrome(String::from(\"cata\"))\n\/\/\/ String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n","canonical_solution":"fn make_palindrome(string: String) -> String {\n    fn is_palindrome(s: &str) -> bool {\n        s.chars().eq(s.chars().rev())\n    }\n\n    if string.is_empty() || is_palindrome(&string) {\n        return string;\n    }\n\n    for i in (0..string.len()).rev() {\n        if is_palindrome(&string[i..]) {\n            let prefix = &string[..i];\n            let reversed_prefix: String = prefix.chars().rev().collect();\n            return string + &reversed_prefix;\n        }\n    }\n\n    string\n}\n\nfn main() {\n    println!(\"{:?}\", make_palindrome(String::from(\"\"))); \/\/ String::from(\"\")\n    println!(\"{:?}\", make_palindrome(String::from(\"cat\"))); \/\/ String::from(\"catac\")\n    println!(\"{:?}\", make_palindrome(String::from(\"cata\"))); \/\/ String::from(\"catac\")\n}","tests":"}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n}\n"},{"task_id":"HumanEval_11","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 이진 XOR을 이 입력에 수행하고 결과를 문자열로 반환합니다. \/\/\/ 입력값은 a와 b가 1과 0으로만 구성된 두 개의 문자열입니다.\/\/\/ >>> string_xor(String::from(\"010\"), String::from(\"110\"))\n\/\/\/ String::from(\"100\")\nfn string_xor(a: String, b: String) -> String {\n","canonical_solution":"fn string_xor(a: String, b: String) -> String {\n    a.chars()\n     .zip(b.chars())\n     .map(|(char_a, char_b)| if char_a == char_b { '0' } else { '1' })\n     .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"},{"task_id":"HumanEval_12","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 같은 길이의 문자열. 입력 벡터가 비어 있는 경우 None를 반환합니다. \/\/\/ 문자열의 벡터에서 가장 긴 문자열을 반환합니다. 복수의 경우 첫 번째 문자열을 반환합니다.\/\/\/ >>> longest(vec![])\n\/\/\/ None\n\/\/\/ >>> longest(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n\/\/\/ Some(String::from(\"a\"))\n\/\/\/ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"ccc\")])\n\/\/\/ Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) -> Option<String> {\n","canonical_solution":"fn longest(strings: Vec<String>) -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len())\n}","tests":"}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"},{"task_id":"HumanEval_13","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 두 정수 a와 b의 최대공분수를 반환합니다 .\/\/\/ >>> greatest_common_divisor(3, 5)\n\/\/\/ 1\n\/\/\/ >>> greatest_common_divisor(25, 15)\n\/\/\/ 5\nfn greatest_common_divisor(a: isize, b: isize) -> isize {\n","canonical_solution":"fn greatest_common_divisor(mut a: isize, mut b: isize) -> isize {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}","tests":"}\n\nfn main() {\n    let candidate = greatest_common_divisor;\n    assert_eq!(candidate(3, 7), 1);\n    assert_eq!(candidate(10, 15), 5);\n    assert_eq!(candidate(49, 14), 7);\n    assert_eq!(candidate(144, 60), 12);\n}\n"},{"task_id":"HumanEval_14","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 입력 문자열의 가장 짧고 가장 긴 모든 접두어의 반환 벡터\/\/\/ >>> all_prefixes(String::from(\"abc\"))\n\/\/\/ vec![String::from(\"a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String) -> Vec<String> {\n","canonical_solution":"fn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for i in 1..=string.len() {\n        prefixes.push(string[..i].to_string());\n    }\n    prefixes\n}\n\n\/\/ Example usage\nfn main() {\n    let prefixes = all_prefixes(String::from(\"abc\"));\n    println!(\"{:?}\", prefixes);\n}","tests":"}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\")]);\n}\n"},{"task_id":"HumanEval_15","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 0부터 n까지의 공간으로 정의된 숫자를 포함하는 문자열을 반환합니다. \/\/\/ >>> string_sequence(0)\n\/\/\/ String::from(\"0\")\n\/\/\/ >>> string_sequence(5)\n\/\/\/ String::from(\"0 1 2 3 4 5\")\nfn string_sequence(n: isize) -> String {\n","canonical_solution":"fn string_sequence(n: isize) -> String {\n    (0..=n).map(|num| num.to_string()).collect::<Vec<String>>().join(\" \")\n}","tests":"}\n\nfn main() {\n    let candidate = string_sequence;\n    assert_eq!(candidate(0), String::from(\"0\"));\n    assert_eq!(candidate(3), String::from(\"0 1 2 3\"));\n    assert_eq!(candidate(10), String::from(\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"},{"task_id":"HumanEval_16","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 문자열을 주어, 얼마나 많은 다른 문자를 (대문자와는 상관없이) 로 구성되어 있는지 알아보십시오.\/\/\/ >>> count_distinct_characters(String::from(\"xyzXYZ\"))\n\/\/\/ 3\n\/\/\/ >>> count_distinct_characters(String::from(\"Jerry\"))\n\/\/\/ 4\nfn count_distinct_characters(string: String) -> isize {\n","canonical_solution":"use std::collections::HashSet;\n\nfn count_distinct_characters(string: String) -> isize {\n    let lowercase_string = string.to_lowercase();\n    let distinct_chars: HashSet<char> = lowercase_string.chars().collect();\n    distinct_chars.len() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_distinct_characters;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"abcde\")), 5);\n    assert_eq!(candidate(String::from(\"abcdecadeCADE\")), 5);\n    assert_eq!(candidate(String::from(\"aaaaAAAAaaaa\")), 1);\n    assert_eq!(candidate(String::from(\"Jerry jERRY JeRRRY\")), 5);\n}\n"},{"task_id":"HumanEval_17","nl":"kor_Hang","pl":"rs","prompt":"\/\/' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\/\/'오 이' - 반노트, 두 박수를 다\/\/\/ 'o' - 전체 음, 4박을 지속 \/\/\/ 전설이 있습니다: \/\/\/ 마지막이 아니죠.\/\/\/ 당신의 임무는 이 문자열을 분석하고 각 벡터마다 얼마나 많은 박자를 는지에 대응하는 정수의 벡터를 반환하는 것입니다.\/\/\/ 이 함수의 입력값은 특별한 ASCII 형식으로 음악 음을 나타내는 문자열입니다. \/\/\/ >>> parse_music(String::from(\"o o| .| o| o| .| .| .| .| o o\"))\n\/\/\/ vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string: String) -> Vec<isize> {\n","canonical_solution":"fn parse_music(music_string: String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let notes: Vec<&str> = music_string.split_whitespace().collect();\n\n    for note in notes {\n        match note {\n            \"o\" => result.push(4),\n            \"o|\" => result.push(2),\n            \".|\" => result.push(1),\n            _ => (),\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let music_string = String::from(\"o o| .| o| o| .| .| .| .| o o\");\n    let beats = parse_music(music_string);\n    println!(\"{:?}\", beats); \/\/ Outputs: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n}","tests":"}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"},{"task_id":"HumanEval_18","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 주어진 하위 문자열이 원래 문자열에서 몇 번 찾을 수 있는지 알아보십시오. 겹치는 경우를 계산하십시오.\/\/\/ >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n\/\/\/ 0\n\/\/\/ >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n\/\/\/ 3\n\/\/\/ >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n\/\/\/ 3\nfn how_many_times(string: String, substring: String) -> isize {\n","canonical_solution":"fn how_many_times(string: String, substring: String) -> isize {\n    if substring.is_empty() || string.is_empty() {\n        return 0;\n    }\n\n    let mut count = 0;\n    let mut position = 0;\n\n    while let Some(pos) = string[position..].find(&substring) {\n        count += 1;\n        position += pos + 1; \/\/ Move to the start of the next potential substring\n    }\n\n    count\n}\n\nfn main() {\n    println!(\"{}\", how_many_times(String::from(\"\"), String::from(\"a\"))); \/\/ 0\n    println!(\"{}\", how_many_times(String::from(\"aaa\"), String::from(\"a\"))); \/\/ 3\n    println!(\"{}\", how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))); \/\/ 3\n}","tests":"}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n"},{"task_id":"HumanEval_19","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 숫자가 가장 작은 것에서 가장 큰 것까지 정렬된 문자열을 반환합니다 .\/\/\/ 유효한 선택은 '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'입니다. \/\/\/ 입력값은 '0'에서 '9'까지의 숫자들로 이루어진 공간으로 구분된 문자열입니다.\/\/\/ >>> sort_numbers(String::from(\"three one five\"))\n\/\/\/ String::from(\"one three five\")\nfn sort_numbers(numbers: String) -> String {\n","canonical_solution":"fn sort_numbers(numbers: String) -> String {\n    let word_to_number = |word: &str| -> u32 {\n        match word {\n            \"zero\" => 0,\n            \"one\" => 1,\n            \"two\" => 2,\n            \"three\" => 3,\n            \"four\" => 4,\n            \"five\" => 5,\n            \"six\" => 6,\n            \"seven\" => 7,\n            \"eight\" => 8,\n            \"nine\" => 9,\n            _ => panic!(\"Invalid input\"),\n        }\n    };\n\n    let words: Vec<&str> = numbers.split_whitespace().collect();\n    let mut number_words: Vec<(&str, u32)> = words.iter().map(|&w| (w, word_to_number(w))).collect();\n\n    number_words.sort_by_key(|&(_, number)| number);\n\n    number_words.iter().map(|&(word, _)| word).collect::<Vec<&str>>().join(\" \")\n}","tests":"}\n\nfn main() {\n    let candidate = sort_numbers;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"three\")), String::from(\"three\"));\n    assert_eq!(candidate(String::from(\"three five nine\")), String::from(\"three five nine\"));\n    assert_eq!(candidate(String::from(\"five zero four seven nine eight\")), String::from(\"zero four five seven eight nine\"));\n    assert_eq!(candidate(String::from(\"six five four three two one zero\")), String::from(\"zero one two three four five six\"));\n}\n"},{"task_id":"HumanEval_20","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 다른 것을 찾아서 순서대로 돌려주십시오 (작은 숫자, 큰 숫자)\/\/\/ 제공된 숫자의 벡터에서 (최소 길이 2개) 각 숫자에 가장 가까운 두 개를 선택하고 반환합니다.\/\/\/ >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/\/ (2.0, 2.2)\n\/\/\/ >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/\/ (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n","canonical_solution":"fn find_closest_elements(mut numbers: Vec<f64>) -> (f64, f64) {\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut min_diff = f64::INFINITY;\n    let mut result = (0.0, 0.0);\n\n    for i in 0..(numbers.len() - 1) {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff {\n            min_diff = diff;\n            result = (numbers[i], numbers[i + 1]);\n        }\n    }\n    \n    result\n}\n\nfn main() {\n    \/\/ Example usage\n    let vec1 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2];\n    let res1 = find_closest_elements(vec1);\n    println!(\"{:?}\", res1); \/\/ (2.0, 2.2)\n\n    let vec2 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0];\n    let res2 = find_closest_elements(vec2);\n    println!(\"{:?}\", res2); \/\/ (2.0, 2.0)\n}","tests":"}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"},{"task_id":"HumanEval_21","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 가장 작은 숫자가 0이 되고 가장 큰 숫자는 1이 됩니다.\/\/\/ 주어진 숫자의 벡터 (최소 두 개의 요소), 그 벡터에 선형 변환을 적용합니다.\/\/\/ >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/\/ vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n","canonical_solution":"fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let min_value = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max_value = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\n    numbers.into_iter().map(|x| (x - min_value) \/ (max_value - min_value)).collect()\n}\n\nfn main() {\n    let numbers = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let rescaled = rescale_to_unit(numbers);\n    println!(\"{:?}\", rescaled);\n}","tests":"}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"},{"task_id":"HumanEval_23","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 주어진 문자열의 반환 길이 \/\/\/ >>> strlen(String::from(\"\"))\n\/\/\/ 0\n\/\/\/ >>> strlen(String::from(\"abc\"))\n\/\/\/ 3\nfn strlen(string: String) -> isize {\n","canonical_solution":"fn strlen(string: String) -> isize {\n    string.chars().count() as isize\n}\n\nfn main() {\n    println!(\"{}\", strlen(String::from(\"\"))); \/\/ Output: 0\n    println!(\"{}\", strlen(String::from(\"abc\"))); \/\/ Output: 3\n}","tests":"}\n\nfn main() {\n    let candidate = strlen;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"x\")), 1);\n    assert_eq!(candidate(String::from(\"asdasnakj\")), 9);\n}\n"},{"task_id":"HumanEval_24","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 주어진 숫자 n에 대해 n보다 작은, n을 균등하게 나누는 가장 큰 숫자를 찾아봅시다\/\/\/ >>> largest_divisor(15)\n\/\/\/ 5\nfn largest_divisor(n: isize) -> isize {\n","canonical_solution":"fn largest_divisor(n: isize) -> isize {\n    for i in (1..n).rev() {\n        if n % i == 0 {\n            return i;\n        }\n    }\n    1 \/\/ If no other divisor is found, return 1\n}\n\nfn main() {\n    println!(\"{}\", largest_divisor(15)); \/\/ Output: 5\n}","tests":"}\n\nfn main() {\n    let candidate = largest_divisor;\n    assert_eq!(candidate(3), 1);\n    assert_eq!(candidate(7), 1);\n    assert_eq!(candidate(10), 5);\n    assert_eq!(candidate(100), 50);\n    assert_eq!(candidate(49), 7);\n}\n"},{"task_id":"HumanEval_25","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 입력 번호는 모든 인자의 곱과 같아야 합니다.\/\/\/ 각 인수는 인수분해에서 나타나는 수에 대응하는 벡터 수를 가져야 합니다. \/\/\/ 소수에서 대수 순서로 주어진 정수의 소수 인수의 반환 벡터. \/\/\/ >>> factorize(8)\n\/\/\/ vec![2, 2, 2]\n\/\/\/ >>> factorize(25)\n\/\/\/ vec![5, 5]\n\/\/\/ >>> factorize(70)\n\/\/\/ vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n","canonical_solution":"fn factorize(mut n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut divisor = 2;\n    while n >= divisor * divisor {\n        while n % divisor == 0 {\n            factors.push(divisor);\n            n \/= divisor;\n        }\n        divisor += 1;\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", factorize(8));  \/\/ Should print: [2, 2, 2]\n    println!(\"{:?}\", factorize(25)); \/\/ Should print: [5, 5]\n    println!(\"{:?}\", factorize(70)); \/\/ Should print: [2, 5, 7]\n}","tests":"}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"},{"task_id":"HumanEval_26","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 입력과 같은 요소의 순서를 유지합니다. \/\/\/ 정수의 벡터에서 한 번 이상 나타나는 모든 요소를 제거합니다. \/\/\/ >>> remove_duplicates(vec![1, 2, 3, 2, 4])\n\/\/\/ vec![1, 3, 4]\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"use std::collections::HashMap;\n\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    let mut occurrences = HashMap::new();\n    \n    \/\/ Count occurrences of each number\n    for &number in &numbers {\n        *occurrences.entry(number).or_insert(0) += 1;\n    }\n\n    \/\/ Filter out numbers that occur more than once\n    numbers.into_iter()\n        .filter(|&number| occurrences[&number] == 1)\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = remove_duplicates;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);\n}\n"},{"task_id":"HumanEval_27","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 주어진 문자열에 대해 소문자를 대문자로, 대문자를 소문자로 바꾸세요. \/\/\/ >>> flip_case(String::from(\"Hello\"))\n\/\/\/ String::from(\"hELLO\")\nfn flip_case(string: String) -> String {\n","canonical_solution":"fn flip_case(string: String) -> String {\n    string.chars().map(|c| {\n        if c.is_lowercase() {\n            c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = flip_case;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hello!\")), String::from(\"hELLO!\"));\n    assert_eq!(candidate(String::from(\"These violent delights have violent ends\")), String::from(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"},{"task_id":"HumanEval_28","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 문자열의 벡터를 하나의 문자열로 연결합니다.\/\/\/ >>> concatenate(vec![])\n\/\/\/ String::from(\"\")\n\/\/\/ >>> concatenate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n\/\/\/ String::from(\"abc\")\nfn concatenate(strings: Vec<String>) -> String {\n","canonical_solution":"fn concatenate(strings: Vec<String>) -> String {\n    strings.concat()\n}","tests":"}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n}\n"},{"task_id":"HumanEval_29","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 주어진 접두사에서 시작하는 문자열의 입력 벡터를 필터링합니다. \/\/\/ >>> filter_by_prefix(vec![], String::from(\"a\"))\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> filter_by_prefix(vec![String::from(\"abc\"), String::from(\"bcd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n\/\/\/ vec![String::from(\"abc\"), String::from(\"array\")]\nfn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n","canonical_solution":"fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n    strings.into_iter()\n        .filter(|s| s.starts_with(&prefix))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = filter_by_prefix;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n}\n"},{"task_id":"HumanEval_30","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 벡터에서 양수만 반환합니다. \/\/\/ >>> get_positive(vec![-1, 2, -4, 5, 6])\n\/\/\/ vec![2, 5, 6]\n\/\/\/ >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ vec![5, 3, 2, 3, 9, 123, 1]\nfn get_positive(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn get_positive(l: Vec<isize>) -> Vec<isize> {\n    l.into_iter().filter(|&x| x > 0).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = get_positive;\n    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);\n    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_31","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 주어진 숫자가 소수라면 true를 반환하고, 그렇지 않으면 false를 반환합니다. \/\/\/ >>> is_prime(6)\n\/\/\/ false\n\/\/\/ >>> is_prime(101)\n\/\/\/ true\n\/\/\/ >>> is_prime(11)\n\/\/\/ true\n\/\/\/ >>> is_prime(13441)\n\/\/\/ true\n\/\/\/ >>> is_prime(61)\n\/\/\/ true\n\/\/\/ >>> is_prime(4)\n\/\/\/ false\n\/\/\/ >>> is_prime(1)\n\/\/\/ false\nfn is_prime(n: isize) -> bool {\n","canonical_solution":"fn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n}\n"},{"task_id":"HumanEval_33","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ l의 대응 인덱스의 값에, 하지만 정렬.\/\/\/ l'는 3으로 나눌 수 없는 지수에서 l와 동일하지만, 3으로 나눌 수 있는 지수에서 그 값은 같습니다.\/\/\/ 이 함수는 벡터 l를 가져다가 벡터 l'를 반환합니다.\/\/\/ >>> sort_third(vec![1, 2, 3])\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n\/\/\/ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut divisible_by_three: Vec<(usize, isize)> = l.iter()\n        .enumerate()\n        .filter(|&(i, _)| i % 3 == 0)\n        .map(|(i, &value)| (i, value))\n        .collect();\n\n    \/\/ Sort the values that are at indices divisible by 3\n    divisible_by_three.sort_by_key(|&(_, value)| value);\n\n    let mut result = l.clone();\n    for (sorted_index, (original_index, _)) in divisible_by_three.iter().enumerate() {\n        result[*original_index] = divisible_by_three[sorted_index].1;\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"},{"task_id":"HumanEval_34","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 벡터에서 정렬된 고유 요소를 반환합니다.\/\/\/ >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ vec![0, 2, 3, 5, 9, 123]\nfn unique(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn unique(mut l: Vec<isize>) -> Vec<isize> {\n    l.sort_unstable();\n    l.dedup();\n    l\n}\n\nfn main() {\n    let result = unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]);\n    println!(\"{:?}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = unique;\n    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);\n}\n"},{"task_id":"HumanEval_35","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 벡터에서 최대 요소를 반환합니다. \/\/\/ >>> max_element(vec![1, 2, 3])\n\/\/\/ 3\n\/\/\/ >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ 123\nfn max_element(l: Vec<isize>) -> isize {\n","canonical_solution":"fn max_element(l: Vec<isize>) -> isize {\n    l.into_iter().max().unwrap()\n}","tests":"}\n\nfn main() {\n    let candidate = max_element;\n    assert_eq!(candidate(vec![1, 2, 3]), 3);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);\n}\n"},{"task_id":"HumanEval_36","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 11 또는 13로 나누어지는 n보다 작은 정수에서 7이 나타나는 횟수를 반환합니다. \/\/\/ >>> fizz_buzz(50)\n\/\/\/ 0\n\/\/\/ >>> fizz_buzz(78)\n\/\/\/ 2\n\/\/\/ >>> fizz_buzz(79)\n\/\/\/ 3\nfn fizz_buzz(n: isize) -> isize {\n","canonical_solution":"fn fizz_buzz(n: isize) -> isize {\n    (0..n)\n        .filter(|&x| x % 11 == 0 || x % 13 == 0)\n        .flat_map(|x| x.to_string().chars())\n        .filter(|&c| c == '7')\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = fizz_buzz;\n    assert_eq!(candidate(50), 0);\n    assert_eq!(candidate(78), 2);\n    assert_eq!(candidate(79), 3);\n    assert_eq!(candidate(100), 3);\n    assert_eq!(candidate(200), 6);\n    assert_eq!(candidate(4000), 192);\n    assert_eq!(candidate(10000), 639);\n    assert_eq!(candidate(100000), 8026);\n}\n"},{"task_id":"HumanEval_37","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ l의 짝수 지수의 값에, 하지만 정렬. \/\/\/ l'는 홀수 지수에서 l와 동일하지만, 짝수 지수에서 그 값은 같습니다.\/\/\/ 이 함수는 벡터 l를 가져다가 벡터 l'를 반환합니다.\/\/\/ >>> sort_even(vec![1, 2, 3])\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> sort_even(vec![5, 6, 3, 4])\n\/\/\/ vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_even(l: Vec<isize>) -> Vec<isize> {\n    \/\/ Collect even indexed elements and sort them\n    let mut even_elements: Vec<isize> = l.iter().enumerate()\n        .filter(|&(i, _)| i % 2 == 0)\n        .map(|(_, &val)| val)\n        .collect();\n    even_elements.sort();\n\n    \/\/ Reconstruct the vector `l'`\n    let mut result = l.clone();\n    let mut even_index = 0;\n\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n            result[i] = even_elements[even_index];\n            even_index += 1;\n        }\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"},{"task_id":"HumanEval_39","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ prime_fib 는 n번째 숫자를 반환합니다. 이는 피보나치 수이고 또한 소수입니다.\/\/\/ >>> prime_fib(1)\n\/\/\/ 2\n\/\/\/ >>> prime_fib(2)\n\/\/\/ 3\n\/\/\/ >>> prime_fib(3)\n\/\/\/ 5\n\/\/\/ >>> prime_fib(4)\n\/\/\/ 13\n\/\/\/ >>> prime_fib(5)\n\/\/\/ 89\nfn prime_fib(n: isize) -> isize {\n","canonical_solution":"fn prime_fib(n: isize) -> isize {\n    fn is_prime(num: isize) -> bool {\n        if num <= 1 {\n            return false;\n        }\n        if num <= 3 {\n            return true;\n        }\n        if num % 2 == 0 || num % 3 == 0 {\n            return false;\n        }\n        let mut i = 5;\n        while i * i <= num {\n            if num % i == 0 || num % (i + 2) == 0 {\n                return false;\n            }\n            i += 6;\n        }\n        true\n    }\n\n    fn fibonacci() -> impl Iterator<Item = isize> {\n        let mut a: isize = 0;\n        let mut b: isize = 1;\n        std::iter::from_fn(move || {\n            let next = a + b;\n            a = b;\n            b = next;\n            Some(a)\n        })\n    }\n\n    let mut count = 0;\n    for fib_num in fibonacci() {\n        if is_prime(fib_num) {\n            count += 1;\n            if count == n {\n                return fib_num;\n            }\n        }\n    }\n    -1\n}","tests":"}\n\nfn main() {\n    let candidate = prime_fib;\n    assert_eq!(candidate(1), 2);\n    assert_eq!(candidate(2), 3);\n    assert_eq!(candidate(3), 5);\n    assert_eq!(candidate(4), 13);\n    assert_eq!(candidate(5), 89);\n    assert_eq!(candidate(6), 233);\n    assert_eq!(candidate(7), 1597);\n    assert_eq!(candidate(8), 28657);\n    assert_eq!(candidate(9), 514229);\n    assert_eq!(candidate(10), 433494437);\n}\n"},{"task_id":"HumanEval_40","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 0을 합하고, 그렇지 않으면 거짓입니다. \/\/\/ 벡터 안에 3개의 다른 요소가 있다면 true를 반환합니다.\/\/\/ triples_sum_to_zero는 정수의 벡터를 입력으로 사용합니다.\/\/\/ >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(vec![1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(vec![1])\n\/\/\/ false\nfn triples_sum_to_zero(l: Vec<isize>) -> bool {\n","canonical_solution":"fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    let n = l.len();\n    if n < 3 {\n        return false;\n    }\n\n    let mut sorted_l = l.clone();\n    sorted_l.sort();\n\n    for i in 0..n-2 {\n        let a = sorted_l[i];\n        let mut left = i + 1;\n        let mut right = n - 1;\n\n        while left < right {\n            let sum = a + sorted_l[left] + sorted_l[right];\n            if sum == 0 {\n                return true;\n            } else if sum < 0 {\n                left += 1;\n            } else {\n                right -= 1;\n            }\n        }\n    }\n\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n}\n"},{"task_id":"HumanEval_41","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 이 함수는 이러한 충돌의 수를 출력합니다. \/\/\/ 그들의 궤도에 충돌하지 않은 것처럼. \/\/하지만, 이 차들은 무한히 견고하고 강합니다. 그래서 계속 움직입니다.\/\/\/ 왼쪽에서 오른쪽으로 움직이는 차가 오른쪽에서 왼쪽으로 움직이는 차를 치면. \/\/모든 차는 같은 속도로 움직입니다. 두 차가 충돌한다고 합니다.\/\/두 쌍의 차가 아주 멀리 떨어져서 출발합니다.\/\/n개의 차가 왼쪽에서 오른쪽으로 움직이고, 동시에 다른 n개의 차가 움직이고,\/\/\/ 무한히 긴 완벽하게 직선으로 된 길을 상상해 보세요.fn car_race_collision(n: isize) -> isize {\n","canonical_solution":"fn car_race_collision(n: isize) -> isize {\n    \/\/ Since every car moving left to right will collide exactly once\n    \/\/ with every car moving right to left, the number of collisions is n * n\n    n * n\n}\n\nfn main() {\n    let n = 5;\n    println!(\"Number of collisions: {}\", car_race_collision(n));\n}","tests":"}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"},{"task_id":"HumanEval_42","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 1으로 증가된 요소를 가진 반환 벡터. \/\/\/ >>> incr_list(vec![1, 2, 3])\n\/\/\/ vec![2, 3, 4]\n\/\/\/ >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ vec![6, 4, 6, 3, 4, 4, 10, 1, 124]\nfn incr_list(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn incr_list(l: Vec<isize>) -> Vec<isize> {\n    l.iter().map(|&x| x + 1).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = incr_list;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);\n    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);\n}\n"},{"task_id":"HumanEval_43","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 0을 합하고, 그렇지 않으면 거짓입니다. \/\/\/ 벡터 안에 두 개의 다른 요소가 있다면 true를 반환합니다.\/\/\/ pairs_sum_to_zero는 정수의 벡터를 입력으로 사용합니다.\/\/\/ >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n\/\/\/ true\n\/\/\/ >>> pairs_sum_to_zero(vec![1])\n\/\/\/ false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n","canonical_solution":"fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    use std::collections::HashSet;\n    let mut seen = HashSet::new();\n    \n    for &num in &l {\n        if seen.contains(&-num) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 3, 5, 0])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 3, -2, 1])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 2, 3, 7])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])); \/\/ true\n    println!(\"{}\", pairs_sum_to_zero(vec![1])); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"},{"task_id":"HumanEval_44","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 기지수는 10보다 작습니다.\/\/\/ 변환 후 문자열 표현을 반환합니다. \/\/\/ 입력 번호 x의 숫자 기지를 기지로 변경합니다. \/\/\/ >>> change_base(8, 3)\n\/\/\/ String::from(\"22\")\n\/\/\/ >>> change_base(8, 2)\n\/\/\/ String::from(\"1000\")\n\/\/\/ >>> change_base(7, 2)\n\/\/\/ String::from(\"111\")\nfn change_base(x: isize, base: isize) -> String {\n","canonical_solution":"fn change_base(x: isize, base: isize) -> String {\n    if base < 2 || base > 9 {\n        panic!(\"Base must be between 2 and 9\");\n    }\n    \n    if x == 0 {\n        return String::from(\"0\");\n    }\n    \n    let mut result = String::new();\n    let mut number = x;\n    \n    while number > 0 {\n        let remainder = number % base;\n        result.push_str(&remainder.to_string());\n        number \/= base;\n    }\n    \n    result.chars().rev().collect()\n}","tests":"}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"},{"task_id":"HumanEval_45","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 삼각형의 변 길이를 보고 높은 반환 영역을 \/\/\/ >>> triangle_area(5, 3)\n\/\/\/ 7.5\nfn triangle_area(a: isize, h: isize) -> f64 {\n","canonical_solution":"fn triangle_area(a: isize, h: isize) -> f64 {\n    (a as f64 * h as f64) \/ 2.0\n}\n\nfn main() {\n    let area = triangle_area(5, 3);\n    println!(\"{}\", area);\n}","tests":"}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(5, 3), 7.5);\n    assert_eq!(candidate(2, 2), 2.0);\n    assert_eq!(candidate(10, 8), 40.0);\n}\n"},{"task_id":"HumanEval_46","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ fib4 수열의 n번째 요소를 효율적으로 계산하는 함수를 작성하십시오. 재귀를 사용하지 마십시오. \/\/\/ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\/\/\/ fib4(3) -> 0 \/\/\/ fib4(2) -> 2 \/\/\/ fib4(1) -> 0 \/\/\/ fib4(0) -> 0 \/\/\/ Fib4 수열은 다음과 같이 정의되는 피보나치 수열과 유사한 수열입니다: \/\/\/ >>> fib4(5)\n\/\/\/ 4\n\/\/\/ >>> fib4(6)\n\/\/\/ 8\n\/\/\/ >>> fib4(7)\n\/\/\/ 14\nfn fib4(n: isize) -> isize {\n","canonical_solution":"fn fib4(n: isize) -> isize {\n    if n < 0 {\n        return 0; \/\/ Define behavior for negative input\n    }\n\n    let mut sequence = vec![0, 0, 2, 0];\n\n    if n < 4 {\n        return sequence[n as usize];\n    }\n\n    for i in 4..=n {\n        let next_value = sequence[(i - 1) as usize] \n                       + sequence[(i - 2) as usize] \n                       + sequence[(i - 3) as usize] \n                       + sequence[(i - 4) as usize];\n        sequence.push(next_value);\n    }\n\n    sequence[n as usize]\n}\n\nfn main() {\n    println!(\"{}\", fib4(5)); \/\/ 4\n    println!(\"{}\", fib4(6)); \/\/ 8\n    println!(\"{}\", fib4(7)); \/\/ 14\n}","tests":"}\n\nfn main() {\n    let candidate = fib4;\n    assert_eq!(candidate(5), 4);\n    assert_eq!(candidate(8), 28);\n    assert_eq!(candidate(10), 104);\n    assert_eq!(candidate(12), 386);\n}\n"},{"task_id":"HumanEval_47","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 벡터 l의 요소들의 반환 중간값. \/\/\/ >>> median(vec![3, 1, 2, 4, 5])\n\/\/\/ 3.0\n\/\/\/ >>> median(vec![-10, 4, 6, 1000, 10, 20])\n\/\/\/ 15.0\nfn median(l: Vec<isize>) -> f64 {\n","canonical_solution":"fn median(l: Vec<isize>) -> f64 {\n    let mut l = l.clone();\n    l.sort();\n    let len = l.len();\n\n    if len % 2 == 0 {\n        let mid1 = len \/ 2;\n        let mid2 = mid1 - 1;\n        ((l[mid1] as f64) + (l[mid2] as f64)) \/ 2.0\n    } else {\n        l[len \/ 2] as f64\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6, 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n"},{"task_id":"HumanEval_48","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 주어진 문자열이 팔린드로임인지 확인합니다 \/\/\/ >>> is_palindrome(String::from(\"\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"aba\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"aaaaa\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"zbcd\"))\n\/\/\/ false\nfn is_palindrome(text: String) -> bool {\n","canonical_solution":"fn is_palindrome(text: String) -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    let len = chars.len();\n    for i in 0..len \/ 2 {\n        if chars[i] != chars[len - 1 - i] {\n            return false;\n        }\n    }\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"},{"task_id":"HumanEval_49","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 2^n p p를 반환합니다 (수적값을 기억하세요).\/\/\/ >>> modp(3, 5)\n\/\/\/ 3\n\/\/\/ >>> modp(1101, 101)\n\/\/\/ 2\n\/\/\/ >>> modp(0, 101)\n\/\/\/ 1\n\/\/\/ >>> modp(3, 11)\n\/\/\/ 8\n\/\/\/ >>> modp(100, 101)\n\/\/\/ 1\nfn modp(n: isize, p: isize) -> isize {\n","canonical_solution":"fn modp(n: isize, p: isize) -> isize {\n    if p == 1 {\n        return 0;\n    }\n    let mut result = 1;\n    let mut base = 2 % p;\n    let mut exponent = n;\n    \n    while exponent > 0 {\n        if exponent % 2 == 1 {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        exponent \/= 2;\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"},{"task_id":"HumanEval_51","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ remove_vowels는 문자열을 가져다가 음절 없는 문자열을 반환하는 함수입니다. \/\/\/ >>> remove_vowels(String::from(\"\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> remove_vowels(String::from(\"abcdef\"))\n\/\/\/ String::from(\"bcdf\")\n\/\/\/ >>> remove_vowels(String::from(\"aaaaa\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> remove_vowels(String::from(\"aaBAA\"))\n\/\/\/ String::from(\"B\")\n\/\/\/ >>> remove_vowels(String::from(\"zbcd\"))\n\/\/\/ String::from(\"zbcd\")\nfn remove_vowels(text: String) -> String {\n","canonical_solution":"fn remove_vowels(text: String) -> String {\n    text.chars()\n        .filter(|&c| !\"aeiouAEIOU\".contains(c))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = remove_vowels;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"abcdef\nghijklm\")), String::from(\"bcdf\nghjklm\"));\n    assert_eq!(candidate(String::from(\"fedcba\")), String::from(\"fdcb\"));\n    assert_eq!(candidate(String::from(\"eeeee\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"acBAA\")), String::from(\"cB\"));\n    assert_eq!(candidate(String::from(\"EcBOO\")), String::from(\"cB\"));\n    assert_eq!(candidate(String::from(\"ybcd\")), String::from(\"ybcd\"));\n}\n"},{"task_id":"HumanEval_52","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 벡터 l의 모든 숫자가 임계 t 이하인 경우 true를 반환합니다. \/\/\/ >>> below_threshold(vec![1, 2, 4, 10], 100)\n\/\/\/ true\n\/\/\/ >>> below_threshold(vec![1, 20, 4, 10], 5)\n\/\/\/ false\nfn below_threshold(l: Vec<isize>, t: isize) -> bool {\n","canonical_solution":"fn below_threshold(l: Vec<isize>, t: isize) -> bool {\n    l.iter().all(|&x| x < t)\n}\n\nfn main() {\n    println!(\"{}\", below_threshold(vec![1, 2, 4, 10], 100)); \/\/ true\n    println!(\"{}\", below_threshold(vec![1, 20, 4, 10], 5));  \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = below_threshold;\n    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);\n    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);\n    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);\n}\n"},{"task_id":"HumanEval_53","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 두 개의 숫자를 더해 x와 y \/\/\/ >>> add(2, 3)\n\/\/\/ 5\n\/\/\/ >>> add(5, 7)\n\/\/\/ 12\nfn add(x: isize, y: isize) -> isize {\n","canonical_solution":"fn add(x: isize, y: isize) -> isize {\n    x + y\n}","tests":"}\n\nfn main() {\n    let candidate = add;\n    assert_eq!(candidate(0, 1), 1);\n    assert_eq!(candidate(1, 0), 1);\n    assert_eq!(candidate(2, 3), 5);\n    assert_eq!(candidate(5, 7), 12);\n    assert_eq!(candidate(7, 5), 12);\n}\n"},{"task_id":"HumanEval_54","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 두 단어의 문자들이 같는지 확인해 보세요. \/\/\/ >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))\n\/\/\/ false\n\/\/\/ >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))\n\/\/\/ false\n\/\/\/ >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))\n\/\/\/ false\nfn same_chars(s0: String, s1: String) -> bool {\n","canonical_solution":"use std::collections::HashSet;\n\nfn same_chars(s0: String, s1: String) -> bool {\n    let set0: HashSet<char> = s0.chars().collect();\n    let set1: HashSet<char> = s1.chars().collect();\n    set0 == set1\n}\n\nfn main() {\n    println!(\"{}\", same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))); \/\/ false\n    println!(\"{}\", same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))); \/\/ false\n    println!(\"{}\", same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"aabb\"), String::from(\"aaccc\")), false);\n}\n"},{"task_id":"HumanEval_55","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ n번째 피보나치 수를 반환합니다. \/\/\/ >>> fib(10)\n\/\/\/ 55\n\/\/\/ >>> fib(1)\n\/\/\/ 1\n\/\/\/ >>> fib(8)\n\/\/\/ 21\nfn fib(n: isize) -> isize {\n","canonical_solution":"fn fib(n: isize) -> isize {\n    match n {\n        0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }\n}\n\nfn main() {\n    println!(\"{}\", fib(10)); \/\/ 55\n    println!(\"{}\", fib(1));  \/\/ 1\n    println!(\"{}\", fib(8));  \/\/ 21\n}","tests":"}\n\nfn main() {\n    let candidate = fib;\n    assert_eq!(candidate(10), 55);\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(8), 21);\n    assert_eq!(candidate(11), 89);\n    assert_eq!(candidate(12), 144);\n}\n"},{"task_id":"HumanEval_56","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 모든 개시 브래킷이 해당하는 닫기 브래킷을 가지고 있다면 true를 반환합니다. \/\/\/ parentheses는 \"<\"와 \">\"의 문자열입니다.\/\/\/ >>> correct_bracketing(String::from(\"<\"))\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(String::from(\"<>\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"<<><>>\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"><<>\"))\n\/\/\/ false\nfn correct_bracketing(brackets: String) -> bool {\n","canonical_solution":"fn correct_bracketing(brackets: String) -> bool {\n    let mut balance = 0;\n    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n            balance += 1;\n        } else if bracket == '>' {\n            balance -= 1;\n            if balance < 0 {\n                return false;\n            }\n        }\n    }\n    \n    balance == 0\n}","tests":"}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n}\n"},{"task_id":"HumanEval_57","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ true를 반환하면 벡터 요소가 단조롭게 증가하거나 감소합니다. \/\/\/ >>> monotonic(vec![1, 2, 4, 20])\n\/\/\/ true\n\/\/\/ >>> monotonic(vec![1, 20, 4, 10])\n\/\/\/ false\n\/\/\/ >>> monotonic(vec![4, 1, 0, -10])\n\/\/\/ true\nfn monotonic(l: Vec<isize>) -> bool {\n","canonical_solution":"fn monotonic(l: Vec<isize>) -> bool {\n    if l.len() <= 1 {\n        return true;\n    }\n    \n    let mut increasing = true;\n    let mut decreasing = true;\n    \n    for i in 0..l.len() - 1 {\n        if l[i] < l[i + 1] {\n            decreasing = false;\n        }\n        if l[i] > l[i + 1] {\n            increasing = false;\n        }\n    }\n    \n    increasing || decreasing\n}\n\nfn main() {\n    println!(\"{}\", monotonic(vec![1, 2, 4, 20])); \/\/ true\n    println!(\"{}\", monotonic(vec![1, 20, 4, 10])); \/\/ false\n    println!(\"{}\", monotonic(vec![4, 1, 0, -10])); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = monotonic;\n    assert_eq!(candidate(vec![1, 2, 4, 10]), true);\n    assert_eq!(candidate(vec![1, 2, 4, 20]), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10]), false);\n    assert_eq!(candidate(vec![4, 1, 0, -10]), true);\n    assert_eq!(candidate(vec![4, 1, 1, 0]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);\n    assert_eq!(candidate(vec![9, 9, 9, 9]), true);\n}\n"},{"task_id":"HumanEval_58","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 두 벡터에 대해 정렬된 고유한 공통 요소를 반환합니다. \/\/\/ >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n\/\/\/ vec![1, 5, 653]\n\/\/\/ >>> common(vec![5, 3, 2, 8], vec![3, 2])\n\/\/\/ vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"use std::collections::HashSet;\n\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    \/\/ Convert both vectors to hash sets to remove duplicates and allow set operations\n    let set1: HashSet<_> = l1.into_iter().collect();\n    let set2: HashSet<_> = l2.into_iter().collect();\n\n    \/\/ Find the intersection of both sets\n    let intersection: HashSet<_> = set1.intersection(&set2).cloned().collect();\n\n    \/\/ Convert the intersection set to a sorted vector\n    let mut result: Vec<_> = intersection.into_iter().collect();\n    result.sort();\n\n    result\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])); \/\/ Should print: [1, 5, 653]\n    println!(\"{:?}\", common(vec![5, 3, 2, 8], vec![3, 2])); \/\/ Should print: [2, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_59","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ n의 가장 큰 소수인수를 반환합니다. n>1이 소수인수가 아닌 것으로 가정합니다. \/\/\/ >>> largest_prime_factor(13195)\n\/\/\/ 29\n\/\/\/ >>> largest_prime_factor(2048)\n\/\/\/ 2\nfn largest_prime_factor(n: isize) -> isize {\n","canonical_solution":"fn largest_prime_factor(mut n: isize) -> isize {\n    let mut largest_factor = 1;\n\n    \/\/ Check for number of twos that divide n\n    while n % 2 == 0 {\n        largest_factor = 2;\n        n \/= 2;\n    }\n\n    \/\/ n must be odd at this point, so we can skip even numbers\n    let mut factor = 3;\n    while factor * factor <= n {\n        while n % factor == 0 {\n            largest_factor = factor;\n            n \/= factor;\n        }\n        factor += 2;\n    }\n\n    \/\/ If n becomes a prime number greater than 2\n    if n > 2 {\n        largest_factor = n;\n    }\n\n    largest_factor\n}\n\nfn main() {\n    println!(\"{}\", largest_prime_factor(13195));\n    println!(\"{}\", largest_prime_factor(2048));\n}","tests":"}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n"},{"task_id":"HumanEval_60","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ sum_to_n는 1부터 n까지의 숫자를 합하는 함수입니다. \/\/\/ >>> sum_to_n(30)\n\/\/\/ 465\n\/\/\/ >>> sum_to_n(100)\n\/\/\/ 5050\n\/\/\/ >>> sum_to_n(5)\n\/\/\/ 15\n\/\/\/ >>> sum_to_n(10)\n\/\/\/ 55\n\/\/\/ >>> sum_to_n(1)\n\/\/\/ 1\nfn sum_to_n(n: isize) -> isize {\n","canonical_solution":"fn sum_to_n(n: isize) -> isize {\n    n * (n + 1) \/ 2\n}","tests":"}\n\nfn main() {\n    let candidate = sum_to_n;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(6), 21);\n    assert_eq!(candidate(11), 66);\n    assert_eq!(candidate(30), 465);\n    assert_eq!(candidate(100), 5050);\n}\n"},{"task_id":"HumanEval_61","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 모든 개시 브래킷이 해당하는 닫기 브래킷을 가지고 있다면 true를 반환합니다. \/\/\/ parentheses는 \"(\"와 \"\") 의 문자열입니다.\/\/\/ >>> correct_bracketing(String::from(\"(\"))\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(String::from(\"()\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"(()())\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\")(()\"))\n\/\/\/ false\nfn correct_bracketing(brackets: String) -> bool {\n","canonical_solution":"fn correct_bracketing(brackets: String) -> bool {\n    let mut balance = 0;\n    \n    for c in brackets.chars() {\n        if c == '(' {\n            balance += 1;\n        } else if c == ')' {\n            balance -= 1;\n        }\n\n        if balance < 0 {\n            return false;\n        }\n    }\n    \n    balance == 0\n}","tests":"}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n}\n"},{"task_id":"HumanEval_62","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 이 다항식의 같은 형태의 파생값을 반환합니다. \/\/\/ xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/\/ xs는 다항식의 계수를 나타냅니다.\/\/\/ >>> derivative(vec![3, 1, 2, 4, 5])\n\/\/\/ vec![1, 4, 12, 20]\n\/\/\/ >>> derivative(vec![1, 2, 3])\n\/\/\/ vec![2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, &coeff) in xs.iter().enumerate().skip(1) {\n        result.push(coeff * i as isize);\n    }\n    result\n}\n\nfn main() {\n    let poly1 = vec![3, 1, 2, 4, 5];\n    let poly2 = vec![1, 2, 3];\n    println!(\"{:?}\", derivative(poly1)); \/\/ Output: [1, 4, 12, 20]\n    println!(\"{:?}\", derivative(poly2)); \/\/ Output: [2, 6]\n}","tests":"}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_63","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ fibfib 수열의 n번째 요소를 효율적으로 계산하는 함수를 작성해 주세요. \/\/\/ fibfib (n) == fibfib (n-1) + fibfib (n-2) + fibfib (n-3).\/\/\/ fib fib () == 1 \/\/\/ fib fib () == 0 \/\/\/ fib fib () == 0 \/\/\/ FibFib 수열은 다음과 같이 정의되는 피보나치 수열과 유사한 수열입니다: \/\/\/ >>> fibfib(1)\n\/\/\/ 0\n\/\/\/ >>> fibfib(5)\n\/\/\/ 4\n\/\/\/ >>> fibfib(8)\n\/\/\/ 24\nfn fibfib(n: isize) -> isize {\n","canonical_solution":"fn fibfib(n: isize) -> isize {\n    if n < 0 {\n        \/\/ Optionally handle negative indices as an error or specific value\n        return -1; \/\/ Example error indicator\n    }\n    match n {\n        0 => 0,\n        1 => 0,\n        2 => 1,\n        _ => {\n            let mut a = 0;\n            let mut b = 0;\n            let mut c = 1;\n            let mut result = 0;\n            for _ in 3..=n {\n                result = a + b + c;\n                a = b;\n                b = c;\n                c = result;\n            }\n            result\n        }\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = fibfib;\n    assert_eq!(candidate(2), 1);\n    assert_eq!(candidate(1), 0);\n    assert_eq!(candidate(5), 4);\n    assert_eq!(candidate(8), 24);\n    assert_eq!(candidate(10), 81);\n    assert_eq!(candidate(12), 274);\n    assert_eq!(candidate(14), 927);\n}\n"},{"task_id":"HumanEval_64","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 음절, 하지만 주어진 단어의 끝에 있을 때만.\/\/\/ 이 경우의 모음은 'a', 'e', 'i', 'o', 'u'입니다. 여기, 'y'는 또한 a 입니다.\/\/\/ 입력으로 단어를 입력하고 문자열의 음절 수를 반환합니다. \/\/\/ 함수 vowels_count를 쓰면 라는 문자열을 사용한다.\/\/\/ >>> vowels_count(String::from(\"abcde\"))\n\/\/\/ 2\n\/\/\/ >>> vowels_count(String::from(\"ACEDY\"))\n\/\/\/ 3\nfn vowels_count(s: String) -> isize {\n","canonical_solution":"fn vowels_count(s: String) -> isize {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let s = s.to_lowercase();\n    let mut count = 0;\n\n    for (i, c) in s.chars().enumerate() {\n        if vowels.contains(&c) || (c == 'y' && i == s.len() - 1) {\n            count += 1;\n        }\n    }\n    \n    count\n}\n\nfn main() {\n    println!(\"{}\", vowels_count(String::from(\"abcde\"))); \/\/ Output: 2\n    println!(\"{}\", vowels_count(String::from(\"ACEDY\"))); \/\/ Output: 3\n}","tests":"}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"},{"task_id":"HumanEval_65","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ shift > 숫자, 반환 숫자는 역전. \/\/\/ 그리고 결과를 문자열로 반환합니다. \/\/\/ 순환적으로 x의 숫자를 이동시켜, 숫자를 오른쪽으로 이동시켜\/\/\/ >>> circular_shift(12, 1)\n\/\/\/ String::from(\"21\")\n\/\/\/ >>> circular_shift(12, 2)\n\/\/\/ String::from(\"12\")\nfn circular_shift(x: isize, shift: isize) -> String {\n","canonical_solution":"fn circular_shift(x: isize, shift: isize) -> String {\n    let mut digits: Vec<char> = x.abs().to_string().chars().collect();\n    let len = digits.len() as isize;\n    \n    if shift > len {\n        digits.reverse();\n    } else {\n        digits.rotate_right(shift as usize % len as usize);\n    }\n    \n    digits.into_iter().collect()\n}","tests":"}\n\nfn main() {\n    let candidate = circular_shift;\n    assert_eq!(candidate(100, 2), String::from(\"001\"));\n    assert_eq!(candidate(12, 2), String::from(\"12\"));\n    assert_eq!(candidate(97, 8), String::from(\"79\"));\n    assert_eq!(candidate(12, 1), String::from(\"21\"));\n    assert_eq!(candidate(11, 101), String::from(\"11\"));\n}\n"},{"task_id":"HumanEval_66","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ ASCII 코드. \/\/\/ 입력으로 문자열을 받아 상위 문자들의 합만을 반환하는 함수를 작성합니다' \/\/\/ 임무 \/\/\/ >>> digitSum(String::from(\"\"))\n\/\/\/ 0\n\/\/\/ >>> digitSum(String::from(\"abAB\"))\n\/\/\/ 131\n\/\/\/ >>> digitSum(String::from(\"abcCd\"))\n\/\/\/ 67\n\/\/\/ >>> digitSum(String::from(\"helloE\"))\n\/\/\/ 69\n\/\/\/ >>> digitSum(String::from(\"woArBld\"))\n\/\/\/ 131\n\/\/\/ >>> digitSum(String::from(\"aAaaaXa\"))\n\/\/\/ 153\nfn digitSum(s: String) -> isize {\n","canonical_solution":"fn digitSum(s: String) -> isize {\n    s.chars()\n     .filter(|c| c.is_uppercase())\n     .map(|c| c as isize)\n     .sum()\n}","tests":"}\n\nfn main() {\n    let candidate = digitSum;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"abAB\")), 131);\n    assert_eq!(candidate(String::from(\"abcCd\")), 67);\n    assert_eq!(candidate(String::from(\"helloE\")), 69);\n    assert_eq!(candidate(String::from(\"woArBld\")), 131);\n    assert_eq!(candidate(String::from(\"aAaaaXa\")), 153);\n    assert_eq!(candidate(String::from(\" How are yOu?\")), 151);\n    assert_eq!(candidate(String::from(\"You arE Very Smart\")), 327);\n}\n"},{"task_id":"HumanEval_67","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ examble를 위해: \/\/\/ 바구니에 바구니에 있는 망고 열매의 숫자를 반환합니다. \/\/\/ 오렌지와 사과와 과일의 총수를 나타내는 정수 \/\/\/ 사과, 오렌지, 그리고 망고 과일. 전체 숫자를 나타내는 문자열을 \/\/\/ 과일을 담은 바구니에 배포됩니다 이 바구니에는 \/\/\/ 이 작업에서, 당신은 사과와 오렌지를 나타내는 문자열을 받게 될 것입니다.\/\/\/ >>> fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19)\n\/\/\/ 8\n\/\/\/ >>> fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3)\n\/\/\/ 2\n\/\/\/ >>> fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100)\n\/\/\/ 95\n\/\/\/ >>> fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120)\n\/\/\/ 19\nfn fruit_distribution(s: String, n: isize) -> isize {\n","canonical_solution":"fn fruit_distribution(s: String, n: isize) -> isize {\n    let mut parts = s.split_whitespace();\n    let apples: isize = parts.next().unwrap().parse().unwrap();\n    parts.next(); \/\/ skip \"apples\"\n    parts.next(); \/\/ skip \"and\"\n    let oranges: isize = parts.next().unwrap().parse().unwrap();\n    \n    n - (apples + oranges)\n}\n\nfn main() {\n    assert_eq!(fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19), 8);\n    assert_eq!(fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3), 2);\n    assert_eq!(fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100), 95);\n    assert_eq!(fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120), 19);\n    println!(\"All test cases passed!\");\n}","tests":"}\n\nfn main() {\n    let candidate = fruit_distribution;\n    assert_eq!(candidate(String::from(\"5 apples and 6 oranges\"), 19), 8);\n    assert_eq!(candidate(String::from(\"5 apples and 6 oranges\"), 21), 10);\n    assert_eq!(candidate(String::from(\"0 apples and 1 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"1 apples and 0 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"2 apples and 3 oranges\"), 100), 95);\n    assert_eq!(candidate(String::from(\"2 apples and 3 oranges\"), 5), 0);\n    assert_eq!(candidate(String::from(\"1 apples and 100 oranges\"), 120), 19);\n}\n"},{"task_id":"HumanEval_68","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 1: \/\/\/ 짝값이 없거나 주어진 벡터가 비어 있다면, []를 반환합니다. \/\/\/ 아진 노드는 벡터, [ smalest_value, its index ], 로 반환되어야 합니다.\/\/\/ 같은 가장 작은 짝값을 가진 여러 개의 노드가 발견되면 가장 작은 인덱스를 가진 노드를 반환합니다. \/\/\/ 뽑은 노드는 가장 작은 짝값을 가진 노드여야 합니다. \/\/\/ 당신의 임무는 노드 중 하나를 뜯어내고 그것을 반환하는 것입니다. \/\/\/ \"비 음수 정수 노드를 가진 나무의 지점을 나타내는 벡터를 주어 \/\/\/ >>> pluck(vec![4, 2, 3])\n\/\/\/ vec![2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 2:\n\/\/\/ >>> pluck(vec![1, 2, 3])\n\/\/\/ vec![2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 3:\n\/\/\/ >>> pluck(vec![])\n\/\/\/ Vec::<isize>::new()\n\/\/\/ Example 4:\n\/\/\/ >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\/\/\/ vec![0, 1]\n\/\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/\/ so we will choose the first zero, which has the smallest index.\n\/\/\/ Constraints:\n\/\/\/ * 1 <= nodes.length <= 10000\n\/\/\/ * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even: Option<(isize, usize)> = None;\n\n    for (index, &value) in arr.iter().enumerate() {\n        if value % 2 == 0 {\n            match smallest_even {\n                None => smallest_even = Some((value, index)),\n                Some((smallest_value, _)) if value < smallest_value => smallest_even = Some((value, index)),\n                _ => {}\n            }\n        }\n    }\n\n    match smallest_even {\n        Some((value, index)) => vec![value, index as isize],\n        None => Vec::new(),\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_69","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 만약 그런 값이 존재하지 않는다면 -1을 반환합니다.\/\/\/ 정수의 빈도는 벡터에 나타나는 횟수입니다.\/\/\/ 0이고, 그 값이 정수 자체보다 크거나 같다는 주파수를 가지고 있습니다.\/\/\/ 양수 정수의 비공개 벡터를 주어 보다 큰 정수를 반환합니다.\/\/\/ >>> search(vec![4, 1, 2, 2, 3, 1])\n\/\/\/ 2\n\/\/\/ >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/\/ 3\n\/\/\/ >>> search(vec![5, 5, 4, 4, 4])\n\/\/\/ -1\nfn search(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn search(lst: Vec<isize>) -> isize {\n    use std::collections::HashMap;\n    \n    let mut frequency_map = HashMap::new();\n    \n    \/\/ Count the frequency of each integer in the vector\n    for &num in &lst {\n        *frequency_map.entry(num).or_insert(0) += 1;\n    }\n    \n    let mut result = -1;\n    \n    \/\/ Iterate over the map to find the greatest integer with a frequency\n    \/\/ greater than or equal to its value\n    for (&num, &freq) in &frequency_map {\n        if freq >= num && num > result {\n            result = num;\n        }\n    }\n    \n    result\n}\n\n\/\/ Test cases\nfn main() {\n    assert_eq!(search(vec![4, 1, 2, 2, 3, 1]), 2);\n    assert_eq!(search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4]), 3);\n    assert_eq!(search(vec![5, 5, 4, 4, 4]), -1);\n}","tests":"}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);\n    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);\n    assert_eq!(candidate(vec![3, 3]), -1);\n    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);\n    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);\n    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);\n    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);\n    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);\n    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);\n    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);\n    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);\n    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);\n    assert_eq!(candidate(vec![1]), 1);\n    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);\n    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);\n    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);\n    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);\n    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);\n    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);\n    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);\n    assert_eq!(candidate(vec![10]), -1);\n    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);\n    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);\n    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);\n    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);\n}\n"},{"task_id":"HumanEval_70","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 나머지 정수의 최대, 최소 등등\/\/\/ 이상한 정렬, 당신이 최소 값으로 시작하면, \/\/\/ 정수의 벡터를 주어, 이상한 순서로 벡터를 반환합니다.\/\/\/ >>> strange_sort_list(vec![1, 2, 3, 4])\n\/\/\/ vec![1, 4, 2, 3]\n\/\/\/ >>> strange_sort_list(vec![5, 5, 5, 5])\n\/\/\/ vec![5, 5, 5, 5]\n\/\/\/ >>> strange_sort_list(vec![])\n\/\/\/ Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn strange_sort_list(mut lst: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(lst.len());\n    lst.sort();\n\n    while !lst.is_empty() {\n        \/\/ Take the smallest element\n        if let Some(min) = lst.first().cloned() {\n            result.push(min);\n            lst.remove(0);\n        }\n        \/\/ Take the largest element\n        if let Some(max) = lst.last().cloned() {\n            result.push(max);\n            lst.pop();\n        }\n    }\n\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", strange_sort_list(vec![1, 2, 3, 4])); \/\/ Output: vec![1, 4, 2, 3]\n    println!(\"{:?}\", strange_sort_list(vec![5, 5, 5, 5])); \/\/ Output: vec![5, 5, 5, 5]\n    println!(\"{:?}\", strange_sort_list(vec![])); \/\/ Output: Vec::<isize>::new()\n}","tests":"}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n"},{"task_id":"HumanEval_71","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 세 번째 측면보다. \/\/\/ 세 변이 유효한 삼각형은 어떤 두 변의 합이 더 크면 됩니다.\/\/\/ 그렇지 않으면 -1 로 돌려보내\/\/\/ 삼각형의 세 변이 유효한 삼각형이라면 삼각형은 소수점 2점으로 둥글게 됩니다. \/\/\/ 삼각형의 세 변의 길이를 주어 의 넓이를 반환합니다.\/\/\/ >>> triangle_area(3, 4, 5)\n\/\/\/ 6.0\n\/\/\/ >>> triangle_area(1, 2, 10)\n\/\/\/ -1.0\nfn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n","canonical_solution":"fn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 \/ 2.0;\n        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n        (area * 100.0).round() \/ 100.0\n    } else {\n        -1.0\n    }\n}\n\nfn main() {\n    println!(\"{}\", triangle_area(3, 4, 5)); \/\/ 6.0\n    println!(\"{}\", triangle_area(1, 2, 10)); \/\/ -1.0\n}","tests":"}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(3, 4, 5), 6.0);\n    assert_eq!(candidate(1, 2, 10), -1.0);\n    assert_eq!(candidate(4, 8, 5), 8.18);\n    assert_eq!(candidate(2, 2, 2), 1.73);\n    assert_eq!(candidate(1, 2, 3), -1.0);\n    assert_eq!(candidate(10, 5, 7), 16.25);\n    assert_eq!(candidate(2, 6, 3), -1.0);\n    assert_eq!(candidate(1, 1, 1), 0.43);\n    assert_eq!(candidate(2, 2, 10), -1.0);\n}\n"},{"task_id":"HumanEval_72","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 물체 q는 균형이 잡혀 있고, 그 요소들의 합이 가능한 최대 무게 w보다 작거나 같다면 날아갈 것입니다.\/\/\/ 객체 q가 날면 true, 그렇지 않으면 false를 반환하는 함수를 작성합니다. \/\/\/ >>> will_it_fly(vec![1, 2], 5)\n\/\/\/ false\n\/\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/\/ >>> will_it_fly(vec![3, 2, 3], 1)\n\/\/\/ false\n\/\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/\/ >>> will_it_fly(vec![3, 2, 3], 9)\n\/\/\/ true\n\/\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/\/ >>> will_it_fly(vec![3], 5)\n\/\/\/ true\n\/\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n","canonical_solution":"fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let is_palindromic = q.iter().eq(q.iter().rev());\n\n    is_palindromic && sum <= w\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{}\", will_it_fly(vec![1, 2], 5)); \/\/ false\n    println!(\"{}\", will_it_fly(vec![3, 2, 3], 1)); \/\/ false\n    println!(\"{}\", will_it_fly(vec![3, 2, 3], 9)); \/\/ true\n    println!(\"{}\", will_it_fly(vec![3], 5)); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"},{"task_id":"HumanEval_73","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/는 앞뒤로 똑같이 읽히고 한 번 변경하면 한 요소를 다른 요소로 변경할 수 있습니다.\/\/\/를 변경해야 벡터가 팔린드로믹하게 됩니다. 팔린드로믹 벡터는 벡터입니다.\/\/\/ 벡터 arr의 정수를 주어, 벡터 arr의 정수를 가진 최소 원소 수를 찾아봅시다\/\/\/ >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])\n\/\/\/ 4\n\/\/\/ >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])\n\/\/\/ 1\n\/\/\/ >>> smallest_change(vec![1, 2, 3, 2, 1])\n\/\/\/ 0\nfn smallest_change(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn smallest_change(arr: Vec<isize>) -> isize {\n    let mut changes = 0;\n    let n = arr.len();\n    \n    for i in 0..n\/2 {\n        if arr[i] != arr[n - i - 1] {\n            changes += 1;\n        }\n    }\n    \n    changes\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result = smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6]);\n\/\/     println!(\"{}\", result); \/\/ Outputs: 4\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"},{"task_id":"HumanEval_74","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 \/\/\/ 두 벡터가 같은 숫자의 칸을 가지고 있다면 첫 번째 벡터를 반환합니다. \/\/\/ 벡터의 모든 문자열에 있는 칸의 총 수는 다른 벡터보다 작습니다. \/\/\/ 두 개의 문자열의 벡터를 받아서 벡터를 가진 벡터를 반환하는 함수를 쓰세요.\/\/\/ >>> total_match(vec![], vec![])\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")])\n\/\/\/ vec![String::from(\"hI\"), String::from(\"Hi\")]\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")])\n\/\/\/ vec![String::from(\"hi\"), String::from(\"admin\")]\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\/\/\/ vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n\/\/\/ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n\/\/\/ vec![String::from(\"4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n    let char_count = |lst: &Vec<String>| lst.iter().map(|s| s.len()).sum::<usize>();\n\n    if char_count(&lst1) <= char_count(&lst2) {\n        lst1\n    } else {\n        lst2\n    }\n}\n\n\/\/ Example usage\nfn main() {\n    let result1 = total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    println!(\"{:?}\", result1);\n\n    let result2 = total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")]);\n    println!(\"{:?}\", result2);\n}","tests":"}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\")]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(), vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"},{"task_id":"HumanEval_75","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/100보다 작다는 것을 알고 있습니다.\/\/\/ 거짓이라고 생각하면. \/\/\/ 주어진 숫자가 3개의 소수 곱하기라면 true를 반환하는 함수를 쓰세요.\/\/\/ >>> is_multiply_prime(30)\n\/\/\/ true\n\/\/\/ 30 = 2 * 3 * 5\nfn is_multiply_prime(a: isize) -> bool {\n","canonical_solution":"fn is_multiply_prime(a: isize) -> bool {\n    fn is_prime(n: isize) -> bool {\n        if n <= 1 {\n            return false;\n        }\n        if n <= 3 {\n            return true;\n        }\n        if n % 2 == 0 || n % 3 == 0 {\n            return false;\n        }\n        let mut i = 5;\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 {\n                return false;\n            }\n            i += 6;\n        }\n        true\n    }\n\n    if a < 2 {\n        return false;\n    }\n\n    let mut primes = Vec::new();\n    for i in 2..a {\n        if is_prime(i) {\n            primes.push(i);\n        }\n    }\n\n    let p_len = primes.len();\n    for i in 0..p_len {\n        for j in i..p_len {\n            for k in j..p_len {\n                if primes[i] * primes[j] * primes[k] == a {\n                    return true;\n                }\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = is_multiply_prime;\n    assert_eq!(candidate(5), false);\n    assert_eq!(candidate(30), true);\n    assert_eq!(candidate(8), true);\n    assert_eq!(candidate(10), false);\n    assert_eq!(candidate(125), true);\n    assert_eq!(candidate(105), true);\n    assert_eq!(candidate(126), false);\n    assert_eq!(candidate(729), false);\n    assert_eq!(candidate(891), false);\n    assert_eq!(candidate(1001), true);\n}\n"},{"task_id":"HumanEval_76","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/x는 n의 단순 제곱이 됩니다. 만약 n**int=x 라면\/\/\/ n의 제곱이고 다른 경우에는 false입니다.\/\/\/ 여러분의 임무는 x가 단순한 일 경우 true를 반환하는 함수를 작성하는 것입니다.\/\/\/ >>> is_simple_power(1, 4)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(2, 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(8, 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(3, 2)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(3, 1)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(5, 3)\n\/\/\/ false\nfn is_simple_power(x: isize, n: isize) -> bool {\n","canonical_solution":"fn is_simple_power(x: isize, n: isize) -> bool {\n    if x <= 0 || n <= 0 {\n        return false;\n    } else if x == 1 {\n        return true;\n    } else if n == 1 {\n        return x == 1;\n    }\n\n    let mut power_n = n;\n    while power_n < x {\n        power_n *= n;\n    }\n    power_n == x\n}\n\nfn main() {\n    println!(\"{}\", is_simple_power(1, 4)); \/\/ true\n    println!(\"{}\", is_simple_power(2, 2)); \/\/ true\n    println!(\"{}\", is_simple_power(8, 2)); \/\/ true\n    println!(\"{}\", is_simple_power(3, 2)); \/\/ false\n    println!(\"{}\", is_simple_power(3, 1)); \/\/ false\n    println!(\"{}\", is_simple_power(5, 3)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"},{"task_id":"HumanEval_77","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 참고: 입력값이 항상 유효하다고 가정할 수 있습니다. \/\/\/ 만약 이 ingeger가 어떤 정수 큐브라면. \/\/\/ a를 전수로 가져다가 true를 반환하는 함수를 작성합니다 .\/\/\/ >>> iscube(1)\n\/\/\/ true\n\/\/\/ >>> iscube(2)\n\/\/\/ false\n\/\/\/ >>> iscube(-1)\n\/\/\/ true\n\/\/\/ >>> iscube(64)\n\/\/\/ true\n\/\/\/ >>> iscube(0)\n\/\/\/ true\n\/\/\/ >>> iscube(180)\n\/\/\/ false\nfn iscube(a: isize) -> bool {\n","canonical_solution":"fn iscube(a: isize) -> bool {\n    if a < 0 {\n        \/\/ For negative numbers, take the cube root of the absolute value.\n        let cube_root = (-a as f64).cbrt();\n        let rounded_cube = cube_root.round() as isize;\n        rounded_cube * rounded_cube * rounded_cube == a\n    } else {\n        let cube_root = (a as f64).cbrt();\n        let rounded_cube = cube_root.round() as isize;\n        rounded_cube * rounded_cube * rounded_cube == a\n    }\n}\n\nfn main() {\n    println!(\"{}\", iscube(1));   \/\/ true\n    println!(\"{}\", iscube(2));   \/\/ false\n    println!(\"{}\", iscube(-1));  \/\/ true\n    println!(\"{}\", iscube(64));  \/\/ true\n    println!(\"{}\", iscube(0));   \/\/ true\n    println!(\"{}\", iscube(180)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n"},{"task_id":"HumanEval_78","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 그리고 기호 A,B,C,D,E,F는 항상 대문자로 되어있습니다. \/\/\/ 참고: 입력값이 항상 정확하거나 빈 문자열이라고 가정할 수 있습니다.\/\/\/ B (= 십진수 11), D (= 십진수 13). \/\/\/ 그래서 다음 숫자의 숫자를 정해야 합니다: 2, 3, 5, 7, \/\/\/ 소수는 2, 3, 5, 7, 11, 13, 17...\/\/\/  십진 기호는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\/\/\/ 1보다 크지만 두 개의 더 작은 자연수의 곱이 아닌 경우)\/\/\/ 소수인 숫자를  수 (prime number, 또는 prime는 자연수입니다.\/\/\/  십진수 숫자를 문자열로 만들고  십진수의 숫자를 계산합니다\/\/\/ 당신은 수신하는 함수를 작성하는 임무를 받았습니다.\/\/\/ >>> hex_key(String::from(\"AB\"))\n\/\/\/ 1\n\/\/\/ >>> hex_key(String::from(\"1077E\"))\n\/\/\/ 2\n\/\/\/ >>> hex_key(String::from(\"ABED1A33\"))\n\/\/\/ 4\n\/\/\/ >>> hex_key(String::from(\"123456789ABCDEF0\"))\n\/\/\/ 6\n\/\/\/ >>> hex_key(String::from(\"2020\"))\n\/\/\/ 2\nfn hex_key(num: String) -> isize {\n","canonical_solution":"fn hex_key(num: String) -> isize {\n    let prime_hex_chars = vec!['2', '3', '5', '7', 'B', 'D'];\n    num.chars()\n        .filter(|c| prime_hex_chars.contains(c))\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"},{"task_id":"HumanEval_79","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 추가 문자는 형식을 돕기 위해 있습니다. \/\/\/ 문자열의 시작과 끝에 추가 문자 'db'가 있을 것입니다. \/\/\/ number. 문자열의 각 문자는 '0' 또는 '1'이 됩니다.\/\/\/ 이진 형식. 함수는 각 문자가 이진 을 나타내는 문자열을 반환해야 합니다.\/\/\/ 당신은 십진수 형태로 번호를 제공 될 것입니다 그리고 당신의 임무는 로 변환하는 것입니다\/\/\/ >>> decimal_to_binary(15)\n\/\/\/ String::from(\"db1111db\")\n\/\/\/ >>> decimal_to_binary(32)\n\/\/\/ String::from(\"db100000db\")\nfn decimal_to_binary(decimal: isize) -> String {\n","canonical_solution":"fn decimal_to_binary(decimal: isize) -> String {\n    let binary_string = format!(\"{:b}\", decimal);\n    format!(\"db{}db\", binary_string)\n}\n\nfn main() {\n    \/\/ Example usage\n    let binary_15 = decimal_to_binary(15);\n    let binary_32 = decimal_to_binary(32);\n    println!(\"{}\", binary_15); \/\/ Outputs: db1111db\n    println!(\"{}\", binary_32); \/\/ Outputs: db100000db\n}","tests":"}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n}\n"},{"task_id":"HumanEval_80","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 문자열은 길이가 최소 3개이고 3개의 연속 문자마다 다른 경우 haprs입니다.\/\/\/ 당신의 임무는 문자열이 haprs 또는 아닌지 확인하는 것입니다. \/\/\/ 당신은 문자열 s를 부여됩니다. \/\/\/ >>> is_happy(String::from(\"a\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"aa\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"abcd\"))\n\/\/\/ true\n\/\/\/ >>> is_happy(String::from(\"aabb\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"adb\"))\n\/\/\/ true\n\/\/\/ >>> is_happy(String::from(\"xyy\"))\n\/\/\/ false\nfn is_happy(s: String) -> bool {\n","canonical_solution":"fn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n\n    let chars: Vec<char> = s.chars().collect();\n    for i in 0..(chars.len() - 2) {\n        if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] || chars[i + 1] == chars[i + 2] {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    println!(\"{}\", is_happy(String::from(\"a\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"aa\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"abcd\"))); \/\/ true\n    println!(\"{}\", is_happy(String::from(\"aabb\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"adb\"))); \/\/ true\n    println!(\"{}\", is_happy(String::from(\"xyy\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"},{"task_id":"HumanEval_81","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 0.0 E \/\/\/ > 0.0 D- \/\/\/ > 0.7 D \/\/\/ > 1.0 D+ \/\/\/ > 1.3 C- \/\/\/ > 1.7 C \/\/\/ > 2.0 C+ \/\/\/ > 2.3 B- \/\/\/ > 2.7 B \/\/\/ > 3.0 B+ \/\/\/ > 3.3 A- \/\/\/ > 3.7 A \/\/\/ 4.0 A+ \/\/GPA, 글자 등급\/\/\/ 다음 표를 사용하여 문자 등급의 벡터를 출력할 수 있는 함수입니다: \/\/\/ 그녀는 당신에게 GPA의 벡터를 몇 학생에게 줬고 당신은 쓰기  있습니다.\/\/\/ 유일한 문제는, 그녀는 그녀가 등급을 위해 사용 된 코드를 잃었다는 것입니다. \/\/\/ 학생에게. 교사는 자신의 알고리즘을 만들어 평가를 하고 있습니다.\/\/\/ 학기 마지막 주이고 선생님께서 점수를 주셔야 합니다.\/\/\/ >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])\n\/\/\/ vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n","canonical_solution":"fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    grades.into_iter().map(|gpa| {\n        match gpa {\n            4.0 => String::from(\"A+\"),\n            v if v > 3.7 => String::from(\"A\"),\n            v if v > 3.3 => String::from(\"A-\"),\n            v if v > 3.0 => String::from(\"B+\"),\n            v if v > 2.7 => String::from(\"B\"),\n            v if v > 2.3 => String::from(\"B-\"),\n            v if v > 2.0 => String::from(\"C+\"),\n            v if v > 1.7 => String::from(\"C\"),\n            v if v > 1.3 => String::from(\"C-\"),\n            v if v > 1.0 => String::from(\"D+\"),\n            v if v > 0.7 => String::from(\"D\"),\n            v if v > 0.0 => String::from(\"D-\"),\n            _ => String::from(\"E\"),\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = numerical_letter_grade;\n    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]);\n    assert_eq!(candidate(vec![1.2]), vec![String::from(\"D+\")]);\n    assert_eq!(candidate(vec![0.5]), vec![String::from(\"D-\")]);\n    assert_eq!(candidate(vec![0.0]), vec![String::from(\"E\")]);\n    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from(\"D\"), String::from(\"D-\"), String::from(\"C-\"), String::from(\"B\"), String::from(\"B+\")]);\n    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from(\"E\"), String::from(\"D-\")]);\n}\n"},{"task_id":"HumanEval_82","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 \/\/\/ length가 소수인지 아니면 false인지\/\/\/ 문자열을 가져다가 문자열이 라면 true를 반환하는 함수를 작성합니다.\/\/\/ >>> prime_length(String::from(\"Hello\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"abcdcba\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"kittens\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"orange\"))\n\/\/\/ false\nfn prime_length(string: String) -> bool {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn prime_length(string: String) -> bool {\n    let length = string.len();\n    is_prime(length)\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", prime_length(String::from(\"Hello\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"abcdcba\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"kittens\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"orange\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n    assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")), false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"},{"task_id":"HumanEval_83","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 1으로 시작하거나 끝나는 양수 정수입니다. \/\/\/ 양수 n을 주어, n자리의 숫자의 수를 반환합니다.fn starts_one_ends(n: isize) -> isize {\n","canonical_solution":"fn starts_one_ends(n: isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    if n == 1 {\n        return 1; \/\/ only '1' satisfies the condition for a single-digit\n    }\n\n    \/\/ Consider numbers starting with '1' (1XXXX...)\n    let start_with_one = 9isize.pow((n-1) as u32);\n\n    \/\/ Consider numbers ending with '1' (...XXXX1)\n    let end_with_one = 9isize.pow((n-1) as u32);\n    \n    \/\/ Consider numbers both starting and ending with '1' and check overlaps (1XXX1)\n    let both_start_end_one = 9isize.pow((n-2) as u32);\n\n    \/\/ Total numbers starting or ending with '1'\n    start_with_one + end_with_one - both_start_end_one\n}\n\nfn main() {\n    \/\/ Example usage:\n    let n = 3;\n    println!(\"Count of n-digit numbers starting or ending with 1: {}\", starts_one_ends(n));\n}","tests":"}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"},{"task_id":"HumanEval_84","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 \/\/\/ 양수 N을 주어, 이진수에서 그 숫자의 총합을 반환합니다. \/\/\/ >>> solve(1000)\n\/\/\/ String::from(\"1\")\n\/\/\/ >>> solve(150)\n\/\/\/ String::from(\"110\")\n\/\/\/ >>> solve(147)\n\/\/\/ String::from(\"1100\")\n\/\/\/ Variables:\n\/\/\/ @N integer\n\/\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/\/ Output:\n\/\/\/ a string of binary number\nfn solve(N: isize) -> String {\n","canonical_solution":"fn solve(N: isize) -> String {\n    let sum_of_digits: isize = N\n        .to_string()\n        .chars()\n        .map(|c| c.to_digit(10).unwrap() as isize)\n        .sum();\n    \n    format!(\"{:b}\", sum_of_digits)\n}","tests":"}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(1000), String::from(\"1\"));\n    assert_eq!(candidate(150), String::from(\"110\"));\n    assert_eq!(candidate(147), String::from(\"1100\"));\n    assert_eq!(candidate(333), String::from(\"1001\"));\n    assert_eq!(candidate(963), String::from(\"10010\"));\n}\n"},{"task_id":"HumanEval_85","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 비공백 벡터로 정수를 주어 lst. 짝수 인덱스를 더합니다.. \/\/\/ >>> add(vec![4, 2, 6, 7])\n\/\/\/ 2\nfn add(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn add(lst: Vec<isize>) -> isize {\n    lst.iter()\n        .enumerate()\n        .filter(|(i, _)| i % 2 == 1) \/\/ select odd indices\n        .map(|(_, &x)| x) \/\/ get the values at odd indices\n        .filter(|&x| x % 2 == 0) \/\/ filter even values\n        .sum() \/\/ sum the values\n}","tests":"}\n\nfn main() {\n    let candidate = add;\n    assert_eq!(candidate(vec![4, 88]), 88);\n    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);\n    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);\n    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);\n}\n"},{"task_id":"HumanEval_86","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 참고: 문장 내의 단어 순서와 빈 공간을 유지해야 합니다. \/\/\/ ASCII 값에 따라 상승 순서로.\/\/\/ 는 새로운 단어로 대체되며, 모든 문자는 로 배열됩니다.\/\/\/ 문자열의 순서 버전, 모든 단어 (공간으로 분리) 가 있는 문자열입니다.\/\/\/ 문자열을 가져다가 순서대로 된 버전을 반환하는 함수를 작성합니다. \/\/\/ >>> anti_shuffle(String::from(\"Hi\"))\n\/\/\/ String::from(\"Hi\")\n\/\/\/ >>> anti_shuffle(String::from(\"hello\"))\n\/\/\/ String::from(\"ehllo\")\n\/\/\/ >>> anti_shuffle(String::from(\"Hello World!!!\"))\n\/\/\/ String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String) -> String {\n","canonical_solution":"fn anti_shuffle(s: String) -> String {\n    let mut result = String::new();\n    let mut word = String::new();\n\n    for c in s.chars() {\n        if c.is_whitespace() {\n            if !word.is_empty() {\n                let mut chars: Vec<char> = word.chars().collect();\n                chars.sort_unstable();\n                result.push_str(&chars.into_iter().collect::<String>());\n                word.clear();\n            }\n            result.push(c);\n        } else {\n            word.push(c);\n        }\n    }\n\n    if !word.is_empty() {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort_unstable();\n        result.push_str(&chars.into_iter().collect::<String>());\n    }\n\n    result\n}\n\nfn main() {\n    \/\/ Example usages:\n    println!(\"{}\", anti_shuffle(String::from(\"Hi\")));              \/\/ \"Hi\"\n    println!(\"{}\", anti_shuffle(String::from(\"hello\")));           \/\/ \"ehllo\"\n    println!(\"{}\", anti_shuffle(String::from(\"Hello World!!!\")));  \/\/ \"Hello !!!Wdlor\"\n}","tests":"}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"},{"task_id":"HumanEval_87","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 또한 줄의 좌표를 열에 따라 순서대로 정렬하세요.\/\/\/ 좌표들을 순서대로 순서대로 정렬해\/\/\/ 각 튜플은 좌표 - (줄, 열) 입니다. 0으로 시작됩니다.\/\/\/ 그리고 튜플의 반환 벡터, [(x1, y1), (x2, y2) ...] 즉 \/\/lst와 정수 x를 주어 벡터에서 정수 x를 찾아봅시다\/\/\/ 각 행에는 다른 수의 열이 있을 수 있습니다.\/\/\/ 매트릭스와 비슷하지만, 매트릭스와는 다릅니다,\/\/\/ 당신은 2 차원 데이터를 주어집니다, 둥글게 벡터, \/\/\/ >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n\/\/\/ vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\/\/\/ >>> get_row(vec![], 1)\n\/\/\/ Vec::<(isize, isize)>::new()\n\/\/\/ >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n\/\/\/ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n","canonical_solution":"fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut result = Vec::new();\n\n    for (row_index, row) in lst.iter().enumerate() {\n        let mut found_indices: Vec<isize> = row.iter()\n            .enumerate()\n            .filter(|&(_, &value)| value == x)\n            .map(|(col_index, _)| col_index as isize)\n            .collect();\n\n        found_indices.sort_by(|a, b| b.cmp(a)); \/\/ Sort column indices in descending order\n\n        for col_index in found_indices {\n            result.push((row_index as isize, col_index));\n        }\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"},{"task_id":"HumanEval_88","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ * 주어진 벡터를 변경하지 마십시오. \/\/\/ 참고: \/\/\/ 또는 수 (첫 번째 인덱스 값, 마지막 인덱스 값) 가 짝수라면 그 순서를 가분수로 정렬합니다.\/\/\/ 주어진 벡터를 상승 순서로 정렬합니다. 만약  (첫 번째 인덱스 값, 마지막 인덱스 값) 이 홀수라면,\/\/\/ 음이 아닌 정수의 벡터를 주어, 정렬 후 주어진 벡터의 코르스를 반환합니다, \/\/\/ >>> sort_array(vec![])\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> sort_array(vec![5])\n\/\/\/ vec![5]\n\/\/\/ >>> sort_array(vec![2, 4, 3, 0, 1, 5])\n\/\/\/ vec![0, 1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])\n\/\/\/ vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n        return Vec::<isize>::new();\n    }\n\n    let first = array.first().unwrap_or(&0);\n    let last = array.last().unwrap_or(&0);\n    let sum = first + last;\n\n    let mut sorted_array = array.clone();\n    if sum % 2 == 0 {\n        sorted_array.sort_by(|a, b| b.cmp(a)); \/\/ Descending order\n    } else {\n        sorted_array.sort(); \/\/ Ascending order\n    }\n\n    sorted_array\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", sort_array(vec![])); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", sort_array(vec![5])); \/\/ vec![5]\n    println!(\"{:?}\", sort_array(vec![2, 4, 3, 0, 1, 5])); \/\/ vec![0, 1, 2, 3, 4, 5]\n    println!(\"{:?}\", sort_array(vec![2, 4, 3, 0, 1, 5, 6])); \/\/ vec![6, 5, 4, 3, 2, 1, 0]\n}","tests":"}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"},{"task_id":"HumanEval_89","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 2 곱하기 2 자리로 아래로 이동합니다. \/\/\/ 알파벳은 글자가 \/\/\/ 는 알파벳을 회전하는 방식으로 암호화된 문자열을 반환합니다. \/\/\/ 함수를 인수로 가져가는 함수 인프라를 생성하고 \/\/\/ >>> encrypt(String::from(\"hi\"))\n\/\/\/ String::from(\"lm\")\n\/\/\/ >>> encrypt(String::from(\"asdfghjkl\"))\n\/\/\/ String::from(\"ewhjklnop\")\n\/\/\/ >>> encrypt(String::from(\"gf\"))\n\/\/\/ String::from(\"kj\")\n\/\/\/ >>> encrypt(String::from(\"et\"))\n\/\/\/ String::from(\"ix\")\nfn encrypt(s: String) -> String {\n","canonical_solution":"fn encrypt(s: String) -> String {\n    s.chars()\n        .map(|c| {\n            if c.is_ascii_lowercase() {\n                let offset = (c as u8 - b'a' + 4) % 26;\n                (b'a' + offset) as char\n            } else {\n                c\n            }\n        })\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"},{"task_id":"HumanEval_90","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 그런 요소가 없으면 아무 것도 반환하지 않습니다. \/\/\/ next_smallest () 함수를 쓰면 벡터의 2번째 가장 작은 원소를 반환합니다.\/\/\/ 당신은 정수의 벡터를 부여받습니다. \/\/\/ >>> next_smallest(vec![1, 2, 3, 4, 5])\n\/\/\/ Some(2)\n\/\/\/ >>> next_smallest(vec![5, 1, 4, 3, 2])\n\/\/\/ Some(2)\n\/\/\/ >>> next_smallest(vec![])\n\/\/\/ None\n\/\/\/ >>> next_smallest(vec![1, 1])\n\/\/\/ None\nfn next_smallest(lst: Vec<isize>) -> Option<isize> {\n","canonical_solution":"fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    if lst.len() < 2 {\n        return None;\n    }\n    let mut unique_elements: Vec<isize> = lst.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect();\n    if unique_elements.len() < 2 {\n        return None;\n    }\n    unique_elements.sort();\n    Some(unique_elements[1])\n}\n\nfn main() {\n    println!(\"{:?}\", next_smallest(vec![1, 2, 3, 4, 5])); \/\/ Some(2)\n    println!(\"{:?}\", next_smallest(vec![5, 1, 4, 3, 2])); \/\/ Some(2)\n    println!(\"{:?}\", next_smallest(vec![])); \/\/ None\n    println!(\"{:?}\", next_smallest(vec![1, 1])); \/\/ None\n}","tests":"}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n}\n"},{"task_id":"HumanEval_91","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 문장에는 '.', '?' 또는 '!'로 구분됩니다. \/\/지루함은 \"I\"로 시작하는 문장입니다.\/\/\/ 당신은 단어의 줄이 주어질 것입니다, 그리고 당신의 임무는 숫자를 세는 것입니다 \/\/\/ >>> is_bored(String::from(\"Hello world\"))\n\/\/\/ 0\n\/\/\/ >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n\/\/\/ 1\nfn is_bored(S: String) -> isize {\n","canonical_solution":"fn is_bored(S: String) -> isize {\n    S.split(|c| c == '.' || c == '?' || c == '!')\n        .filter(|sentence| sentence.trim_start().starts_with(\"I\"))\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n"},{"task_id":"HumanEval_92","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 \/\/\/ 다른 경우 모두 false를 반환합니다. \/\/\/ 숫자의 하나가 다른 두 숫자의 합과 같고 모든 숫자가 정수인 경우 true를 반환합니다. \/\/\/ 3개의 숫자를 가지고 있는 함수를 만들어. \/\/\/ >>> any_int(5, 2, 7)\n\/\/\/ true\n\/\/\/ >>> any_int(3, 2, 2)\n\/\/\/ false\n\/\/\/ >>> any_int(3, -2, 1)\n\/\/\/ true\n\/\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/\/ false\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n","canonical_solution":"fn any_int(x: f64, y: f64, z: f64) -> bool {\n    \/\/ Check if all the numbers are integers\n    if x.fract() == 0.0 && y.fract() == 0.0 && z.fract() == 0.0 {\n        \/\/ Convert f64 to i64 because they are integers\n        let xi = x as i64;\n        let yi = y as i64;\n        let zi = z as i64;\n\n        \/\/ Check if any one of the numbers is equal to the sum of the other two\n        xi == yi + zi || yi == xi + zi || zi == xi + yi\n    } else {\n        false\n    }\n}\n\nfn main() {\n    \/\/ Examples\n    println!(\"{}\", any_int(5.0, 2.0, 7.0)); \/\/ true\n    println!(\"{}\", any_int(3.0, 2.0, 2.0)); \/\/ false\n    println!(\"{}\", any_int(3.0, -2.0, 1.0)); \/\/ true\n    println!(\"{}\", any_int(3.6, -2.2, 2.0)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"},{"task_id":"HumanEval_93","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 글자만 가정해. \/\/\/ 영어 알파벳의 음절. \/\/\/\/ 그보다 2 자리 앞쪽에 있는 글자를 가진 메시지\/\/\/ 모든 글자의 대문자를 바꿔서 모든 음절을 로 바꿔서\/\/\/ 메시지를 받아서 라는 식으로 암호화하는 함수를 쓰세요.\/\/\/ >>> encode(String::from(\"test\"))\n\/\/\/ String::from(\"TGST\")\n\/\/\/ >>> encode(String::from(\"This is a message\"))\n\/\/\/ String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String) -> String {\n","canonical_solution":"fn encode(message: String) -> String {\n    message.chars().map(|c| {\n        match c {\n            'a' => 'C',\n            'e' => 'G',\n            'i' => 'K',\n            'o' => 'Q',\n            'u' => 'W',\n            'A' => 'c',\n            'E' => 'g',\n            'I' => 'k',\n            'O' => 'q',\n            'U' => 'w',\n            'a'..='z' => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"},{"task_id":"HumanEval_94","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 가장 큰 소수값을 찾아서 숫자의 합을 반환해야 합니다.\/\/\/ 당신은 정수의 벡터를 부여받습니다. \/\/\/ >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/\/ 10\n\/\/\/ >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/\/ 25\n\/\/\/ >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/\/ 13\n\/\/\/ >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/\/ 11\n\/\/\/ >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n\/\/\/ 3\n\/\/\/ >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n\/\/\/ 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn digit_sum(n: isize) -> isize {\n    n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum()\n}\n\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n    match lst.into_iter().filter(is_prime).max() {\n        Some(max_prime) => digit_sum(max_prime),\n        None => 0,\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n"},{"task_id":"HumanEval_95","nl":"kor_Hang","pl":"rs","prompt":"use std::collections::HashMap;\n\n\/\/\/ 예: \/\/\/ 함수는 false를 반환해야 주어진 HashMap은 비어 있습니다. \/\/\/ case 또는 모든 키가 대문자로 된 문자열이 되거나 false를 반환합니다.\/\/\/ HashMap를 주어 모든 키가 하위 에서 문자열이라면 true를 반환합니다.\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n\/\/\/ true\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n\/\/\/ true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n","canonical_solution":"use std::collections::HashMap;\n\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return false;\n    }\n\n    let mut lowercase = true;\n    let mut uppercase = true;\n\n    for key in dict.keys() {\n        if !key.chars().all(|c| c.is_lowercase()) {\n            lowercase = false;\n        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            uppercase = false;\n        }\n    }\n\n    lowercase || uppercase\n}\n\nfn main() {\n    let dict1 = HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]);\n    assert_eq!(check_dict_case(dict1), true);\n\n    let dict2 = HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]);\n    assert_eq!(check_dict_case(dict2), false);\n\n    let dict3 = HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]);\n    assert_eq!(check_dict_case(dict3), true);\n\n    let dict4 = HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]);\n    assert_eq!(check_dict_case(dict4), false);\n}","tests":"}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"},{"task_id":"HumanEval_96","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ n보다 작은 소수인 정수들. \/\/\/ 음이 아닌 정수를 가져다가 첫 n의 벡터를 반환하는 함수를 구현합니다 .\/\/\/ >>> count_up_to(5)\n\/\/\/ vec![2, 3]\n\/\/\/ >>> count_up_to(11)\n\/\/\/ vec![2, 3, 5, 7]\n\/\/\/ >>> count_up_to(0)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> count_up_to(20)\n\/\/\/ vec![2, 3, 5, 7, 11, 13, 17, 19]\n\/\/\/ >>> count_up_to(1)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> count_up_to(18)\n\/\/\/ vec![2, 3, 5, 7, 11, 13, 17]\nfn count_up_to(n: isize) -> Vec<isize> {\n","canonical_solution":"fn count_up_to(n: isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n\n    for num in 2..n {\n        let mut is_prime = true;\n\n        for divisor in 2..=((num as f64).sqrt() as isize) {\n            if num % divisor == 0 {\n                is_prime = false;\n                break;\n            }\n        }\n\n        if is_prime {\n            primes.push(num);\n        }\n    }\n\n    primes\n}\n\nfn main() {\n    println!(\"{:?}\", count_up_to(5)); \/\/ vec![2, 3]\n    println!(\"{:?}\", count_up_to(11)); \/\/ vec![2, 3, 5, 7]\n    println!(\"{:?}\", count_up_to(0)); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", count_up_to(20)); \/\/ vec![2, 3, 5, 7, 11, 13, 17, 19]\n    println!(\"{:?}\", count_up_to(1)); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", count_up_to(18)); \/\/ vec![2, 3, 5, 7, 11, 13, 17]\n}","tests":"}\n\nfn main() {\n    let candidate = count_up_to;\n    assert_eq!(candidate(5), vec![2, 3]);\n    assert_eq!(candidate(6), vec![2, 3, 5]);\n    assert_eq!(candidate(7), vec![2, 3, 5]);\n    assert_eq!(candidate(10), vec![2, 3, 5, 7]);\n    assert_eq!(candidate(0), Vec::<isize>::new());\n    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);\n    assert_eq!(candidate(1), Vec::<isize>::new());\n    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);\n    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n}\n"},{"task_id":"HumanEval_97","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 입력값이 항상 유효하다고 가정합니다. \/\/\/ 단위 숫자의 곱을 \/\/\/ 두 개의 정수를 가져다가 반환하는 함수를 완료합니다.\/\/\/ >>> multiply(148, 412)\n\/\/\/ 16\n\/\/\/ >>> multiply(19, 28)\n\/\/\/ 72\n\/\/\/ >>> multiply(2020, 1851)\n\/\/\/ 0\n\/\/\/ >>> multiply(14, -15)\n\/\/\/ 20\nfn multiply(a: isize, b: isize) -> isize {\n","canonical_solution":"fn multiply(a: isize, b: isize) -> isize {\n    let unit_digit_a = (a % 10).abs();\n    let unit_digit_b = (b % 10).abs();\n    unit_digit_a * unit_digit_b\n}","tests":"}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"},{"task_id":"HumanEval_98","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 문자열 s를 주어, 대문자 모음의 숫자를 짝수 인덱스에서 계산해 보세요. \/\/\/ >>> count_upper(String::from(\"aBCdEf\"))\n\/\/\/ 1\n\/\/\/ >>> count_upper(String::from(\"abcdefg\"))\n\/\/\/ 0\n\/\/\/ >>> count_upper(String::from(\"dBBE\"))\n\/\/\/ 0\nfn count_upper(s: String) -> isize {\n","canonical_solution":"fn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(i, c)| {\n        *i % 2 == 0 && matches!(c, 'A' | 'E' | 'I' | 'O' | 'U')\n    }).count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"},{"task_id":"HumanEval_99","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 \/\/\/ 두 개의 정수에서 0에서 더 멀리 둥글게 니다.\/\/\/ 그리고 가장 가까운 정수를 반환합니다. 숫자가 동등한 거리에 있다면\/\/\/ 숫자를 나타내는 값 (스링) 을 가져오는 함수를 생성합니다.\/\/\/ >>> closest_integer(String::from(\"10\"))\n\/\/\/ 10\n\/\/\/ >>> closest_integer(String::from(\"15.3\"))\n\/\/\/ 15\n\/\/\/ Note:\n\/\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/\/ from two integers, the one you should return is the one that is the\n\/\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n","canonical_solution":"fn closest_integer(value: String) -> isize {\n    let num: f64 = value.parse().expect(\"Invalid number format\");\n    if num.fract().abs() == 0.5 {\n        if num.is_sign_positive() {\n            num.ceil() as isize\n        } else {\n            num.floor() as isize\n        }\n    } else {\n        num.round() as isize\n    }\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", closest_integer(String::from(\"10\")));   \/\/ Output: 10\n    println!(\"{}\", closest_integer(String::from(\"15.3\"))); \/\/ Output: 15\n    println!(\"{}\", closest_integer(String::from(\"14.5\"))); \/\/ Output: 15\n    println!(\"{}\", closest_integer(String::from(\"-14.5\"))); \/\/ Output: -15\n}","tests":"}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"},{"task_id":"HumanEval_100","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ i는 레벨 (i+1) 에 있는 돌의 수를 나타냅니다.\/\/\/ 각 레벨의 돌 수를 벡터로 반환합니다.\/\/\/ - n이 짝수라면 다음 짝수입니다. \/\/\/ - n이 홀수라면 다음 홀수\/\/\/ 다음 층의 돌의 수는: \/\/\/ 첫 번째 레벨에는 n개의 돌이 있습니다. \/\/\/ 양수 n을 주어, n개의 층의 돌을 쌓아야 합니다.\/\/\/ >>> make_a_pile(3)\n\/\/\/ vec![3, 5, 7]\nfn make_a_pile(n: isize) -> Vec<isize> {\n","canonical_solution":"fn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n    let mut current = n;\n    \n    for _ in 0..n {\n        pile.push(current);\n        current = if n % 2 == 1 {\n            current + 2\n        } else {\n            current + 2\n        };\n    }\n    \n    pile\n}\n\nfn main() {\n    let level = make_a_pile(3);\n    println!(\"{:?}\", level);\n}","tests":"}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"},{"task_id":"HumanEval_101","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 문자열을 단어로 나누고 단어의 벡터를 반환합니다. \/\/\/ 당신은 코마 또는 공간으로 분리 된 단어의 문자열을 제공 될 것입니다. 당신의 임무는 입니다\/\/\/ >>> words_string(String::from(\"Hi, my name is John\"))\n\/\/\/ vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]\n\/\/\/ >>> words_string(String::from(\"One, two, three, four, five, six\"))\n\/\/\/ vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]\nfn words_string(s: String) -> Vec<String> {\n","canonical_solution":"fn words_string(s: String) -> Vec<String> {\n    s.split(|c: char| c.is_whitespace() || c == ',')\n        .filter(|word| !word.is_empty())\n        .map(String::from)\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = words_string;\n    assert_eq!(candidate(String::from(\"Hi, my name is John\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]);\n    assert_eq!(candidate(String::from(\"One, two, three, four, five, six\")), vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"Hi, my name\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\")]);\n    assert_eq!(candidate(String::from(\"One,, two, three, four, five, six,\")), vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"ahmed     , gamal\")), vec![String::from(\"ahmed\"), String::from(\"gamal\")]);\n}\n"},{"task_id":"HumanEval_102","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 그런 숫자가 없으므로 함수는 -1을 반환해야 합니다.\/\/\/ 최대 정수인 경우 [x, y] 범위 안에 있습니다.\/\/\/ 이 함수는 양수 x와 y를 두 개 가지고 를 반환합니다.\/\/\/ >>> choose_num(12, 15)\n\/\/\/ 14\n\/\/\/ >>> choose_num(13, 12)\n\/\/\/ -1\nfn choose_num(x: isize, y: isize) -> isize {\n","canonical_solution":"fn choose_num(x: isize, y: isize) -> isize {\n    let (start, end) = if x < y { (x, y) } else { (y, x) };\n    for n in (start..=end).rev() {\n        if n % 2 == 0 {\n            return n;\n        }\n    }\n    -1\n}\n\nfn main() {\n    println!(\"{}\", choose_num(12, 15)); \/\/ 14\n    println!(\"{}\", choose_num(13, 12)); \/\/ -1\n}","tests":"}\n\nfn main() {\n    let candidate = choose_num;\n    assert_eq!(candidate(12, 15), 14);\n    assert_eq!(candidate(13, 12), -1);\n    assert_eq!(candidate(33, 12354), 12354);\n    assert_eq!(candidate(5234, 5233), -1);\n    assert_eq!(candidate(6, 29), 28);\n    assert_eq!(candidate(27, 10), -1);\n    assert_eq!(candidate(7, 7), -1);\n    assert_eq!(candidate(546, 546), 546);\n}\n"},{"task_id":"HumanEval_104","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 참고: 반환 벡터는 증가 순서로 정렬되어야 합니다. \/\/\/ 어떤 짝수 숫자가 없는 요소들. \/\/\/ 양수 정수 x의 벡터를 주어 모든 벡터의 정렬 벡터를 반환합니다.\/\/\/ >>> unique_digits(vec![15, 33, 1422, 1])\n\/\/\/ vec![1, 15, 33]\n\/\/\/ >>> unique_digits(vec![152, 323, 1422, 10])\n\/\/\/ Vec::<isize>::new()\nfn unique_digits(x: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn unique_digits(x: Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = x.into_iter()\n        .filter(|&num| {\n            num.to_string().chars().all(|c| {\n                match c {\n                    '0' | '2' | '4' | '6' | '8' => false,\n                    _ => true,\n                }\n            })\n        })\n        .collect();\n    result.sort();\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = unique_digits;\n    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);\n    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());\n    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);\n    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);\n}\n"},{"task_id":"HumanEval_105","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ \"하나\", \"두\", \"세\", \"네\", \"다섯\", \"여섯\", \"일곱\", \"여덟\", \"아홉\".\/\/\/ 벡터를 반전하고 각 숫자를 벡터에서 벡터로 바꾸어 벡터 이름을 벡터로 바꾸어\/\/\/ 정수의 벡터를 주어 1과 9 사이의 정수를 정렬합니다.\/\/\/ >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])\n\/\/\/ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]\n\/\/\/ If the vector is empty, return an empty vector:\n\/\/\/ >>> by_length(vec![])\n\/\/\/ Vec::<String>::new()\n\/\/\/ If the vector has any strange number ignore it:\n\/\/\/ >>> by_length(vec![1, -1, 55])\n\/\/\/ vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n","canonical_solution":"fn by_length(arr: Vec<isize>) -> Vec<String> {\n    let digit_names = [\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \n        \"Six\", \"Seven\", \"Eight\", \"Nine\",\n    ];\n\n    let mut filtered: Vec<isize> = arr.into_iter()\n        .filter(|&x| x >= 1 && x <= 9)\n        .collect();\n\n    filtered.sort();\n    filtered.reverse();\n\n    filtered.into_iter()\n        .map(|x| String::from(digit_names[(x - 1) as usize]))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"},{"task_id":"HumanEval_106","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ i의 인수는 1에서 i까지의 숫자의 곱입니다 (1 * 2 * ... * i).\/\/\/ i 1부터 시작됩니다. \/\/\/ 또는 1에서 i까지의 숫자의 합입니다.\/\/\/ 그리고 크기가 n인 벡터를 반환합니다. 즉, i의 인덱스 i의 값은 i의 팩토리얼이 됩니다.\/\/\/ n을 파라미터로 사용하는 함수 f를 구현합니다.\/\/\/ >>> f(5)\n\/\/\/ vec![1, 2, 6, 24, 15]\nfn f(n: isize) -> Vec<isize> {\n","canonical_solution":"fn f(n: isize) -> Vec<isize> {\n    fn factorial(x: isize) -> isize {\n        (1..=x).product()\n    }\n\n    fn sum_up_to(x: isize) -> isize {\n        (1..=x).sum()\n    }\n\n    (1..=n)\n        .map(|i| if i % 2 == 0 { factorial(i) } else { sum_up_to(i) })\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = f;\n    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);\n    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);\n    assert_eq!(candidate(1), vec![1]);\n    assert_eq!(candidate(3), vec![1, 2, 6]);\n}\n"},{"task_id":"HumanEval_107","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 1: \/\/\/ n을 포함한 범위 안에 있는 정수 팔린드로미스. \/\/\/ 양수 n을 주어, 짝수와 홀수의 수를 가진 튜플을 반환합니다\/\/\/ >>> even_odd_palindrome(3)\n\/\/\/ (1, 2)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/\/ Example 2:\n\/\/\/ >>> even_odd_palindrome(12)\n\/\/\/ (4, 6)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/\/ Note:\n\/\/\/ 1. 1 <= n <= 10^3\n\/\/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n","canonical_solution":"fn is_palindrome(x: isize) -> bool {\n    let s = x.to_string();\n    s == s.chars().rev().collect::<String>()\n}\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n    \n    for i in 1..=n {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n    \n    (even_count, odd_count)\n}","tests":"}\n\nfn main() {\n    let candidate = even_odd_palindrome;\n    assert_eq!(candidate(123), (8, 13));\n    assert_eq!(candidate(12), (4, 6));\n    assert_eq!(candidate(3), (1, 2));\n    assert_eq!(candidate(63), (6, 8));\n    assert_eq!(candidate(25), (5, 6));\n    assert_eq!(candidate(19), (4, 6));\n    assert_eq!(candidate(9), (4, 5));\n    assert_eq!(candidate(1), (0, 1));\n}\n"},{"task_id":"HumanEval_108","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어 -123은 -1, 2, 3의 자릿수를 가지고 있습니다.\/\/\/ 만약 숫자가 음수라면, 첫 번째 기호된 숫자는 음수입니다: \/\/\/ 숫자 합이 0이 넘는 요소의 수\/\/\/ 함수 count_nums를 작성하여 벡터로 정수를 가져다가 벡터를 반환합니다.\/\/\/ >>> count_nums(vec![])\n\/\/\/ 0\n\/\/\/ >>> count_nums(vec![-1, 11, -11])\n\/\/\/ 1\n\/\/\/ >>> count_nums(vec![1, 1, 2])\n\/\/\/ 3\nfn count_nums(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn count_nums(arr: Vec<isize>) -> isize {\n    arr.into_iter()\n        .filter(|&num| {\n            let mut n = num;\n            let mut sum = 0;\n            let mut is_first_digit = true;\n\n            while n != 0 {\n                let digit = if is_first_digit {\n                    is_first_digit = false;\n                    n % 10\n                } else {\n                    (n % 10).abs()\n                };\n                sum += digit;\n                n \/= 10;\n            }\n            sum > 0\n        })\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n"},{"task_id":"HumanEval_109","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 참고: 주어진 벡터는 고유한 요소를 가지고 있다는 것이 보장됩니다. \/\/\/ 주어진 벡터가 빈다면 true를 반환합니다. \/\/\/ 그럼 true를 반환한다 아니면 false를 반환한다. \/\/\/ 위의 연산을 수행하여 정렬 된 벡터를 얻을 수 있다면 \/\/\/ 벡터에서의 시작 위치 즉 0th 인덱스. \/\/\/ 위치에서 올바른 방향으로 벡터의 마지막 요소는 이동됩니다\/\/\/ 한 번 오른쪽으로 이동하면 벡터의 모든 요소를 한 번 이동합니다.\/\/\/ 당신은 몇 번이나 오른쪽 이동 작업을 수행 할 수 있습니다. \/\/\/ 주어진 벡터에 대한 다음 연산: \/\/\/ 를 수행하여 벡터를 감소하지 않는 순서로 정렬 할 수 있습니다.\/\/\/ 벡터 내의 숫자는 무작위로 순서로 배치됩니다. 당신의 임무는 \/\/\/ 우리는 N개의 정수 arr[1], arr[2], ..., arr[N]의 벡터 'arr'을 가지고 있다.\/\/\/ >>> move_one_ball(vec![3, 4, 5, 1, 2])\n\/\/\/ true\n\/\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/\/ be achieved for the given vector.\n\/\/\/ >>> move_one_ball(vec![3, 5, 4, 1, 2])\n\/\/\/ false\n\/\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/\/ vector by performing any number of right shift operations.\nfn move_one_ball(arr: Vec<isize>) -> bool {\n","canonical_solution":"fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.is_empty() {\n        return true; \/\/ An empty array is already considered sorted.\n    }\n    \n    let mut break_point = 0;\n    let mut break_found = false;\n    let len = arr.len();\n\n    for i in 0..len {\n        if arr[i] > arr[(i + 1) % len] {\n            if break_found {\n                return false;  \/\/ Found more than one break point, not possible.\n            }\n            break_point = i + 1;\n            break_found = true;\n        }\n    }\n    \n    \/\/ After finding a single break point, simulate the right shift by 'break_point'\n    for i in 0..len {\n        if arr[(break_point + i) % len] > arr[(break_point + i + 1) % len] {\n            return false; \/\/ Not sorted in non-decreasing order with this shift.\n        }\n    }\n    \n    true\n}\n\n\/\/ Example usages:\n\n\/\/ This will return true, as we can shift twice to sort it.\nassert_eq!(move_one_ball(vec![3, 4, 5, 1, 2]), true);\n\n\/\/ This will return false, as we can't sort this by any number of shifts.\nassert_eq!(move_one_ball(vec![3, 5, 4, 1, 2]), false);","tests":"}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"},{"task_id":"HumanEval_110","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 그렇지 않으면 \"NO\"를 돌려주십시오.\/\/\/ lst1의 모든 요소가 짝수인 경우, \"YES\"를 반환합니다.\/\/\/ lst1과 lst2 사이의 요소를 교환하는 것이 가능하다면\/\/\/ lst1과 lst2 사이에 교환되는 요소의 수에 제한이 없습니다.\/\/\/ 사이에 lst1을 짝수 벡터로 만들 수 있습니다.\/\/\/ 그리고 요소 교환을 수행 할 수 있는지 여부를 결정합니다.\/\/\/ 이 문제에서, 당신은 두 개의 숫자의 벡터를 가져가는 함수를 구현할 것입니다, \/\/\/ >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])\n\/\/\/ String::from(\"YES\")\n\/\/\/ >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])\n\/\/\/ String::from(\"NO\")\n\/\/\/ It is assumed that the input vectors will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n","canonical_solution":"fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n    let mut even_in_lst2 = false;\n    for &num in &lst2 {\n        if num % 2 == 0 {\n            even_in_lst2 = true;\n            break;\n        }\n    }\n\n    if even_in_lst2 {\n        for &num in &lst1 {\n            if num % 2 != 0 {\n                return String::from(\"YES\");\n            }\n        }\n        return String::from(\"YES\");\n    }\n\n    String::from(\"NO\")\n}\n\nfn main() {\n    \/\/ Example cases\n    println!(\"{}\", exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])); \/\/ \"YES\"\n    println!(\"{}\", exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])); \/\/ \"NO\"\n}","tests":"}\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from(\"YES\"));\n}\n"},{"task_id":"HumanEval_111","nl":"kor_Hang","pl":"rs","prompt":"use std::collections::HashMap;\n\n\/\/\/ 예: \/\/\/ 여러 글자가 같은 경우, 그들 모두를 반환합니다. \/\/\/ 가장 많이 반복되는 글자 중 하나이며, 해당 숫자를 포함합니다. \/\/\/ 공간으로 분리된 소문자를 나타내는 문자열을 주어 HashMap을 반환합니다.\/\/\/ >>> histogram(String::from(\"a b c\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n\/\/\/ >>> histogram(String::from(\"a b b a\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\/\/\/ >>> histogram(String::from(\"a b c a b\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\/\/\/ >>> histogram(String::from(\"b b b b a\"))\n\/\/\/ HashMap::from([(String::from(\"b\"), 4)])\n\/\/\/ >>> histogram(String::from(\"\"))\n\/\/\/ HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize> {\n","canonical_solution":"use std::collections::HashMap;\n\nfn histogram(test: String) -> HashMap<String, isize> {\n    let mut counts: HashMap<String, isize> = HashMap::new();\n    let mut max_count = 0;\n\n    for letter in test.split_whitespace() {\n        let count = counts.entry(letter.to_string()).or_insert(0);\n        *count += 1;\n        if *count > max_count {\n            max_count = *count;\n        }\n    }\n\n    counts.retain(|_, &mut val| val == max_count);\n    counts\n}\n\nfn main() {\n    let result = histogram(String::from(\"a b c\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n\n    let result = histogram(String::from(\"a b b a\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\n    let result = histogram(String::from(\"a b c a b\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\n    let result = histogram(String::from(\"b b b b a\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"b\"), 4)])\n\n    let result = histogram(String::from(\"\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([])\n}","tests":"}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")), HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"a\"), 1)]));\n}\n"},{"task_id":"HumanEval_112","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 \/\/\/ 당신은 결과 문자열과 확인을 위해 true\/false를 포함하는 튜플을 반환해야 합니다. \/\/\/ 문자열은 앞과 뒤로 똑같이 읽으면 팔린드로마라고 불립니다.\/\/\/ 그러면 결과 문자열이 팔린드로임인지 확인합니다. \/\/\/ 우리는 두 개의 문자열 s와 c를 가지고 있습니다. 당신은 c의 모든 문자와 같은 s의 모든 문자를 삭제해야 합니다.\/\/\/ 임무 \/\/\/ >>> reverse_delete(String::from(\"abcde\"), String::from(\"ae\"))\n\/\/\/ (String::from(\"bcd\"), false)\n\/\/\/ >>> reverse_delete(String::from(\"abcdef\"), String::from(\"b\"))\n\/\/\/ (String::from(\"acdef\"), false)\n\/\/\/ >>> reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n\/\/\/ (String::from(\"cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n","canonical_solution":"fn reverse_delete(s: String, c: String) -> (String, bool) {\n    \/\/ Create a set of characters to delete for quick lookup\n    let delete_chars: std::collections::HashSet<char> = c.chars().collect();\n    \n    \/\/ Filter the string, keeping only characters not in the delete set\n    let filtered: String = s.chars().filter(|ch| !delete_chars.contains(ch)).collect();\n    \n    \/\/ Check if the filtered string is a palindrome\n    let is_palindrome = filtered == filtered.chars().rev().collect::<String>();\n    \n    \/\/ Return the filtered string and whether it's a palindrome\n    (filtered, is_palindrome)\n}","tests":"}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"},{"task_id":"HumanEval_113","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 입력의 i'th 문자열에 홀수 숫자의. \/\/\/ 입력의 문자열 i. \" 모든 i가 숫자 로 대체되어야 합니다.\/\/\/ 출력 i의 각 요소는 에 있는 홀수 요소의 수여야 합니다\/\/\/ 문자열의 벡터를 주어, 각 문자열은 단지 숫자로 구성되어, 벡터를 반환합니다.\/\/\/ >>> odd_count(vec![String::from(\"1234567\")])\n\/\/\/ vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]\n\/\/\/ >>> odd_count(vec![String::from(\"3\"), String::from(\"11111111\")])\n\/\/\/ vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]\nfn odd_count(lst: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn odd_count(lst: Vec<String>) -> Vec<String> {\n    lst.iter()\n        .map(|s| {\n            let odd_count = s.chars().filter(|&c| {\n                match c {\n                    '1' | '3' | '5' | '7' | '9' => true,\n                    _ => false,\n                }\n            }).count();\n            format!(\"the number of odd elements {0}n the str{0}ng {0} of the {0}nput.\", odd_count)\n        })\n        .collect()\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result = odd_count(vec![String::from(\"1234567\")]);\n\/\/     println!(\"{:?}\", result);\n\/\/ \n\/\/     let result = odd_count(vec![String::from(\"3\"), String::from(\"11111111\")]);\n\/\/     println!(\"{:?}\", result);\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = odd_count;\n    assert_eq!(candidate(vec![String::from(\"1234567\")]), vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]);\n    assert_eq!(candidate(vec![String::from(\"3\"), String::from(\"11111111\")]), vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]);\n    assert_eq!(candidate(vec![String::from(\"271\"), String::from(\"137\"), String::from(\"314\")]), vec![String::from(\"the number of odd elements 2n the str2ng 2 of the 2nput.\"), String::from(\"the number of odd elements 3n the str3ng 3 of the 3nput.\"), String::from(\"the number of odd elements 2n the str2ng 2 of the 2nput.\")]);\n}\n"},{"task_id":"HumanEval_114","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 \/\/\/ 숫자의. \/\/\/ 정수 n의 벡터를 주어, 비공백 하위 벡터의 최소 합을 찾아 \/\/\/ >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])\n\/\/\/ 1\n\/\/\/ >>> minSubArraySum(vec![-1, -2, -3])\n\/\/\/ -6\nfn minSubArraySum(nums: Vec<isize>) -> isize {\n","canonical_solution":"fn minSubArraySum(nums: Vec<isize>) -> isize {\n    let mut min_sum = nums[0];\n    let mut current_sum = nums[0];\n\n    for &num in nums.iter().skip(1) {\n        current_sum = current_sum.min(current_sum + num);\n        min_sum = min_sum.min(current_sum);\n    }\n\n    min_sum\n}","tests":"}\n\nfn main() {\n    let candidate = minSubArraySum;\n    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);\n    assert_eq!(candidate(vec![-1, -2, -3]), -6);\n    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);\n    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);\n    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);\n    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);\n    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);\n    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);\n    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);\n    assert_eq!(candidate(vec![-10]), -10);\n    assert_eq!(candidate(vec![7]), 7);\n    assert_eq!(candidate(vec![1, -1]), -1);\n}\n"},{"task_id":"HumanEval_115","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 1: \/\/\/ 버킷을 내려놓을 수 있는 횟수를 입력합니다.\/\/\/ 당신의 임무는 우물을 비우는 데 버킷을 사용하는 것입니다. \/\/\/ 모든 버킷은 같은 용량을 가지고 있습니다. \/\/\/ 각 우물은 물 빼기 위해 사용할 수 있는 수동이 있습니다, \/\/\/ 그리고 각 1은 물의 단위를 나타냅니다.\/\/각 행은 하나의 우물을 나타냅니다.\/\/\/ >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)\n\/\/\/ 6\n\/\/\/ Example 2:\n\/\/\/ >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n\/\/\/ 5\n\/\/\/ Example 3:\n\/\/\/ >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n\/\/\/ 0\n\/\/\/ Constraints:\n\/\/\/ * all wells have the same length\n\/\/\/ * 1 <= grid.length <= 10^2\n\/\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/\/ * grid[i][j] -> 0 | 1\n\/\/\/ * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n","canonical_solution":"fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut total_water_units = 0;\n\n    for row in grid.iter() {\n        for &unit in row.iter() {\n            total_water_units += unit;\n        }\n    }\n\n    \/\/ Calculate how many times we need to lower the bucket to extract all water units\n    (total_water_units + capacity - 1) \/ capacity\n}\n\nfn main() {\n    println!(\"{}\", max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)); \/\/ 6\n    println!(\"{}\", max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)); \/\/ 5\n    println!(\"{}\", max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)); \/\/ 0\n}","tests":"}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"},{"task_id":"HumanEval_116","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 이 방법은 다음과 같습니다: \/\/\/ 같은 수의 1을 위해 소수점을 기준으로 정렬합니다.\/\/\/ 1의 숫자가 2진법으로 올라가는 순서로 나타납니다.\/\/이 카타에서, 여러분은 에 따라 비 음의 정수의 벡터를 정렬해야 합니다.\/\/\/ >>> sort_array(vec![1, 5, 2, 3, 4])\n\/\/\/ vec![1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(vec![-2, -3, -4, -5, -6])\n\/\/\/ vec![-6, -5, -4, -3, -2]\n\/\/\/ >>> sort_array(vec![1, 0, 2, 3, 4])\n\/\/\/ vec![0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr = arr;\n    arr.sort_by(|&a, &b| {\n        let ones_a = a.count_ones();\n        let ones_b = b.count_ones();\n        if ones_a == ones_b {\n            a.cmp(&b)\n        } else {\n            ones_a.cmp(&ones_b)\n        }\n    });\n    arr\n}\n\nfn main() {\n    println!(\"{:?}\", sort_array(vec![1, 5, 2, 3, 4])); \/\/ Output: [1, 2, 3, 4, 5]\n    println!(\"{:?}\", sort_array(vec![-2, -3, -4, -5, -6])); \/\/ Output: [-6, -5, -4, -3, -2]\n    println!(\"{:?}\", sort_array(vec![1, 0, 2, 3, 4])); \/\/ Output: [0, 1, 2, 3, 4]\n}","tests":"}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"},{"task_id":"HumanEval_117","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 참고: 입력 문자열에는 문자와 공백만 포함된다고 가정할 수 있습니다. \/\/\/ 만약 문자열 s가 빈다면 함수는 빈 벡터를 반환해야 합니다.\/\/\/ n 자음, 이 단어들이 문자열 s에 나타나는 순서로. \/\/\/ 함수는 string s에서 정확히 를 포함하는 모든 단어의 벡터를 반환합니다.\/\/\/ 문자열 s와 자연수 n을 주어, 당신은 실행하는 일을 맡았습니다.\/\/\/ >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\/\/\/ vec![String::from(\"little\")]\n\/\/\/ >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n\/\/\/ vec![String::from(\"Mary\"), String::from(\"lamb\")]\n\/\/\/ >>> select_words(String::from(\"simple white space\"), 2)\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> select_words(String::from(\"Hello world\"), 4)\n\/\/\/ vec![String::from(\"world\")]\n\/\/\/ >>> select_words(String::from(\"Uncle sam\"), 3)\n\/\/\/ vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n","canonical_solution":"fn select_words(s: String, n: isize) -> Vec<String> {\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let mut result = Vec::new();\n\n    for word in s.split_whitespace() {\n        let consonant_count = word.chars().filter(|c| consonants.contains(*c)).count();\n        if consonant_count == n as usize {\n            result.push(word.to_string());\n        }\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"},{"task_id":"HumanEval_118","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 주어진 문자열은 영어 문자만 포함한다고 가정할 수 있습니다. \/\/\/ 위의 조건을 만족하는 음절을 찾아내십시오. \/\/\/ 시작과 끝의 모음은 계산되지 않습니다. 당신이하지 않은 경우 빈 문자열을 반환 \/\/\/ 두 개의 자음 (case sensitive) 을 단어의 오른쪽에서 씁니다.\/\/\/ 당신은 단어 주어집니다. 당신의 임무는 사이에 서있는 가장 가까운 모음을 찾는 것입니다.\/\/\/ >>> get_closest_vowel(String::from(\"yogurt\"))\n\/\/\/ String::from(\"u\")\n\/\/\/ >>> get_closest_vowel(String::from(\"FULL\"))\n\/\/\/ String::from(\"U\")\n\/\/\/ >>> get_closest_vowel(String::from(\"quick\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> get_closest_vowel(String::from(\"ab\"))\n\/\/\/ String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n","canonical_solution":"fn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let chars: Vec<char> = word.chars().collect();\n    if chars.len() < 3 {\n        return String::from(\"\");\n    }\n\n    for i in (1..chars.len() - 1).rev() {\n        if vowels.contains(chars[i]) && !vowels.contains(chars[i-1]) && !vowels.contains(chars[i+1]) {\n            return chars[i].to_string();\n        }\n    }\n    String::from(\"\")\n}","tests":"}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"},{"task_id":"HumanEval_119","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 좋은 문자열을 만들 수 있는 방법이 있다면 '예'를 반환하고, 그렇지 않으면 '아니오'를 반환합니다.\/\/\/ '()) '는 아닙니다.\/\/\/는 균형이 잡힌다. 예를 들어: 문자열 '(()))) '는 좋고, 문자열 은\/\/\/ 문자열 S는 모든 괄호가 S 안에 있는 경우에만 좋은 것으로 간주됩니다.\/\/\/ 어떤 순서, 그 결과 문자열이 좋을 것입니다. \/\/\/ 당신의 일은 두 개의 문자열을 연결할 수 있는지 확인하는 것입니다.\/\/\/ 괄호 '(' 또는 괄호 ') '만 붙여집니다.\/\/\/ 두 개의 문자열의 벡터가 주어집니다, 두 문자열 모두 오픈으로 구성됩니다.\/\/\/ >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n\/\/\/ String::from(\"Yes\")\n\/\/\/ >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n\/\/\/ String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n","canonical_solution":"fn match_parens(lst: Vec<String>) -> String {\n    fn is_balanced(s: &str) -> bool {\n        let mut balance = 0;\n        for ch in s.chars() {\n            if ch == '(' {\n                balance += 1;\n            } else {\n                balance -= 1;\n            }\n            if balance < 0 {\n                return false;\n            }\n        }\n        balance == 0\n    }\n\n    if lst.len() != 2 {\n        return \"No\".to_string();\n    }\n\n    let s1 = &lst[0];\n    let s2 = &lst[1];\n\n    let combined1 = format!(\"{}{}\", s1, s2);\n    let combined2 = format!(\"{}{}\", s2, s1);\n\n    if is_balanced(&combined1) || is_balanced(&combined2) {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"},{"task_id":"HumanEval_120","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 1: \/\/\/ 길이가 k이고, 최대 k개의 숫자가 arr에 들어있죠.\/\/\/ 정수 arr과 양수 k의 벡터를 주어 정렬 벡터를 반환합니다.\/\/\/ >>> maximum(vec![-3, -4, 5], 3)\n\/\/\/ vec![-4, -3, 5]\n\/\/\/ Example 2:\n\/\/\/ >>> maximum(vec![4, -4, 4], 2)\n\/\/\/ vec![4, 4]\n\/\/\/ Example 3:\n\/\/\/ >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)\n\/\/\/ vec![2]\n\/\/\/ Note:\n\/\/\/ 1. The length of the vector will be in the range of [1, 1000].\n\/\/\/ 2. The elements in the vector will be in the range of [-1000, 1000].\n\/\/\/ 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n","canonical_solution":"fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let mut arr = arr;\n    arr.sort_unstable_by(|a, b| b.cmp(a));\n    let k = k as usize;\n    let mut result: Vec<isize> = arr.into_iter().take(k).collect();\n    result.sort_unstable();\n    result\n}\n\nfn main() {\n    assert_eq!(maximum(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(maximum(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n}","tests":"}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_121","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 \/\/\/ 비공백이 아닌 정수 벡터를 주어, 짝수 위치에 있는 모든 홀수들의 합을 반환합니다. \/\/\/ >>> solution(vec![5, 8, 7, 1])\n\/\/\/ 12\n\/\/\/ >>> solution(vec![3, 3, 3, 3, 3])\n\/\/\/ 9\n\/\/\/ >>> solution(vec![30, 13, 24, 321])\n\/\/\/ 0\nfn solution(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn solution(lst: Vec<isize>) -> isize {\n    lst.iter()\n        .enumerate()\n        .filter(|(i, &x)| i % 2 == 0 && x % 2 != 0)\n        .map(|(_, &x)| x)\n        .sum()\n}","tests":"}\n\nfn main() {\n    let candidate = solution;\n    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);\n    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);\n    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);\n    assert_eq!(candidate(vec![5, 9]), 5);\n    assert_eq!(candidate(vec![2, 4, 8]), 0);\n    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);\n    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);\n}\n"},{"task_id":"HumanEval_122","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ arr의 첫 번째 k 요소에서 최대 두 자릿수를 가진 요소의 합입니다. \/\/\/ 정수 arr과 정수 k의 비공백 벡터를 주어, return 를 반환합니다.\/\/\/ >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n\/\/\/ 24\n\/\/\/ Constraints:\n\/\/\/ 1. 1 <= len(arr) <= 100\n\/\/\/ 2. 1 <= k <= len(arr)\nfn add_elements(arr: Vec<isize>, k: isize) -> isize {\n","canonical_solution":"fn add_elements(arr: Vec<isize>, k: isize) -> isize {\n    arr.iter()\n        .take(k as usize)\n        .filter(|&&x| x > -100 && x < 100)\n        .sum()\n}\n\nfn main() {\n    let result = add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4);\n    println!(\"{}\", result);  \/\/ Output: 24\n}","tests":"}\n\nfn main() {\n    let candidate = add_elements;\n    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);\n    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);\n    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);\n    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);\n    assert_eq!(candidate(vec![1], 1), 1);\n}\n"},{"task_id":"HumanEval_123","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ get_odd_collatz(5) 는 [1, 5] # 5의 collatz 순서는 [5, 16, 8, 4, 2, 1], 그래서 홀수들은 1과 5일 뿐입니다.\/\/\/ 예를 들어: \/\/\/ 2. 반환 벡터는 증가 순서로 정렬. \/\/\/ 1. Collatz(1) 은 [1] 입니다.\/\/\/ 참고: \/\/\/term+1 의 추측은 n의 값이 무엇이든, 순서는 항상 1에 도달한다는 것입니다.\/\/\/ 이전 항을 니다. 이전 항이 홀수라면 다음 항은 3배입니다.\/\/\/ 이전 항은 다음과 같습니다. 이전 항이 짝이면 다음 항은 의 절반입니다.\/\/\/ 다음으로: 어떤 양수 n으로 시작해 각 항은 에서 얻는다.\/\/\/ 콜라츠 추측은 수학에서 정의된 순서에 관한 추측입니다 \/\/\/ 양수 n을 주어, 트즈 순서에서 홀수들을 가진 정렬 벡터를 반환합니다. \/\/\/ >>> get_odd_collatz(5)\n\/\/\/ vec![1, 5]\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n","canonical_solution":"fn get_odd_collatz(n: isize) -> Vec<isize> {\n    let mut sequence = Vec::new();\n    let mut current = n;\n\n    while current != 1 {\n        if current % 2 != 0 {\n            sequence.push(current);\n        }\n\n        if current % 2 == 0 {\n            current \/= 2;\n        } else {\n            current = 3 * current + 1;\n        }\n    }\n    \n    \/\/ Add the final odd number 1 if n is 1\n    sequence.push(1);\n\n    sequence.sort();\n    sequence\n}\n\nfn main() {\n    let result = get_odd_collatz(5);\n    println!(\"{:?}\", result); \/\/ Outputs: [1, 5]\n}","tests":"}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"},{"task_id":"HumanEval_124","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 4. 날짜는 다음과 같은 형식으로 표시되어야 합니다: mm-dd-yyyy \/\/\/ 3. 달은 1보다 작거나 12보다 높지 않아야 합니다.\/\/\/ 2. 달 1,3,5,7,8,10,12에 대한 날의 수는 1보다 작거나 31일보다 높지 않습니다. 그리고 달 4,6,9,11에 대한 날의 수는 1보다 작거나 30일보다 높지 않습니다. 그리고, 달 2에 대한 날의 수는 1보다 작거나 29일보다 높지 않습니다.\/\/\/ 1. 날짜 문자열은 비어 있지 않습니다.\/\/\/ 날짜는 다음 규칙이 모두 충족되는 경우 유효합니다: \/\/\/ 날짜가 유효하다면 true를 반환한다 그렇지 않으면 false를 반환한다. \/\/\/ 주어진 날짜 문자열을 검증하는 함수를 작성해야 합니다. 그리고 \/\/\/ >>> valid_date(String::from(\"03-11-2000\"))\n\/\/\/ true\n\/\/\/ >>> valid_date(String::from(\"15-01-2012\"))\n\/\/\/ false\n\/\/\/ >>> valid_date(String::from(\"04-0-2040\"))\n\/\/\/ false\n\/\/\/ >>> valid_date(String::from(\"06-04-2020\"))\n\/\/\/ true\n\/\/\/ >>> valid_date(String::from(\"06\/04\/2020\"))\n\/\/\/ false\nfn valid_date(date: String) -> bool {\n","canonical_solution":"fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return false;\n    }\n\n    let parts: Vec<&str> = date.split('-').collect();\n    if parts.len() != 3 {\n        return false;\n    }\n\n    let maybe_month = parts[0].parse::<u32>();\n    let maybe_day = parts[1].parse::<u32>();\n    let maybe_year = parts[2].parse::<u32>();\n\n    if maybe_month.is_err() || maybe_day.is_err() || maybe_year.is_err() {\n        return false;\n    }\n\n    let month = maybe_month.unwrap();\n    let day = maybe_day.unwrap();\n\n    if month < 1 || month > 12 {\n        return false;\n    }\n\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day < 1 || day > 31 {\n                return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if day < 1 || day > 30 {\n                return false;\n            }\n        }\n        2 => {\n            if day < 1 || day > 29 {\n                return false;\n            }\n        }\n        _ => return false, \/\/ This case should never be reached\n    }\n\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"},{"task_id":"HumanEval_126","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 \/\/\/ number, return false. 음수와 정수만 가정한다.\/\/\/ 상승 순서로. 벡터가 동일한 1 개 이상의 복제본을 가지고 있다면 \/\/\/ 숫자의 벡터를 주어, 정렬되었는지 아닌지를 반환합니다.\/\/\/ >>> is_sorted(vec![5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 3, 2, 4, 5])\n\/\/\/ false\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5, 6])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n\/\/\/ false\n\/\/\/ >>> is_sorted(vec![1, 2, 2, 3, 3, 4])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n\/\/\/ false\nfn is_sorted(lst: Vec<isize>) -> bool {\n","canonical_solution":"fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.is_empty() || lst.len() == 1 {\n        return true;\n    }\n    \n    let mut previous = lst[0];\n    let mut repeat_count = 0;\n\n    for &current in &lst[1..] {\n        if current < previous {\n            return false;\n        }\n        if current == previous {\n            repeat_count += 1;\n            if repeat_count >= 2 {\n                return false;\n            }\n        } else {\n            repeat_count = 0;\n        }\n        previous = current;\n    }\n\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n}\n"},{"task_id":"HumanEval_127","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ [입출력] 샘플: \/\/\/ 두 간격이 교차하지 않으면 \"NO\"를 반환합니다. \/\/\/ 그렇지 않으면 \"NO\"를 반환합니다.\/\/\/ 교차선의 길이 소수라면 \"YES\"를 반환합니다.\/\/\/ 그 길이가 1인 소수 아닌 숫자입니다.\/\/\/ 예를 들어, 간격 (1, 3), (2, 4) 의 교차점은 (2, 3) 입니다.\/\/\/ 간격은 소수입니다. \/\/\/ 당신의 임무는 이 두 칸의 교차선의 길이가\/\/\/ 각 주어진 간격에 대해, 그것의 시작은 그것의 끝보다 작거나 같다고 가정합니다. \/\/\/ 시작과 끝을 모두 포함합니다. \/\/\/ 주어진 간격은 닫혀있다는 것을 의미하며, 간격은 (시작, 끝)\/\/\/ 각 간격이 정수 쌍인 경우. 예를 들어, 간격 = (시작, 끝) = (1, 2).\/\/\/ 두 개의 간격이 주어집니다, \/\/\/ >>> intersection((1, 2), (2, 3))\n\/\/\/ String::from(\"NO\")\n\/\/\/ >>> intersection((-1, 1), (0, 4))\n\/\/\/ String::from(\"NO\")\n\/\/\/ >>> intersection((-3, -1), (-5, 5))\n\/\/\/ String::from(\"YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    let start_intersection = std::cmp::max(start1, start2);\n    let end_intersection = std::cmp::min(end1, end2);\n\n    if start_intersection <= end_intersection {\n        let length = (end_intersection - start_intersection + 1) as usize;\n        if is_prime(length) {\n            return String::from(\"YES\");\n        }\n    }\n    String::from(\"NO\")\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", intersection((1, 2), (2, 3))); \/\/ \"NO\"\n    println!(\"{}\", intersection((-1, 1), (0, 4))); \/\/ \"NO\"\n    println!(\"{}\", intersection((-3, -1), (-5, 5))); \/\/ \"YES\"\n}","tests":"}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"},{"task_id":"HumanEval_128","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 참고: 빈 arr 에 대해 None 를 반환합니다. \/\/\/ 벡터 내의 각 숫자의 1, -1 또는 0으로 표현됩니다. \/\/\/ 모든 기호의 곱으로 곱한 정수의 크기의 합 \/\/\/ 당신은 정수의 벡터 arr을 주어지고 당신은 반환해야합니다 \/\/\/ >>> prod_signs(vec![1, 2, 2, -4])\n\/\/\/ Some(9)\n\/\/\/ >>> prod_signs(vec![0, 1])\n\/\/\/ Some(0)\n\/\/\/ >>> prod_signs(vec![])\n\/\/\/ None\nfn prod_signs(arr: Vec<isize>) -> Option<isize> {\n","canonical_solution":"fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n    let mut sum_of_magnitudes = 0;\n    let mut product_of_signs = 1;\n\n    for &num in &arr {\n        sum_of_magnitudes += num.abs();\n        if num == 0 {\n            product_of_signs = 0;\n            break;\n        } else if num > 0 {\n            product_of_signs *= 1;\n        } else {\n            product_of_signs *= -1;\n        }\n    }\n\n    Some(sum_of_magnitudes * product_of_signs)\n}","tests":"}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n}\n"},{"task_id":"HumanEval_129","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 최소 경로가 통과하는 셀의 값의 순서 벡터를 반환합니다. \/\/\/ 그 답이 독특하다는 게 보장됩니다.\/\/\/ lst_A[j] = lst_B[j] \/\/\/ lst_A[i] < lst_B[i]와 모든 j (1 <= j <i) 에 대해 우리는 \/\/\/ lst_B보다 더 많다는 뜻입니다. 즉, i (1 <= i <= k) 라는 정수 인덱스가 존재한다는 뜻입니다.\/\/\/를 통해 (lst_A와 lst_B라고 부르겠습니다), lst_A는 사전적으로 덜 \/\/\/ A와 B가 가는 셀의 값의 순서 벡터를 만든 후\/\/\/ 길이 A (길이 k) 는 길이 B (길이 k) 보다 작다고 간주됩니다.\/\/\/ 당신은 그리드 밖으로 갈 수 없습니다. \/\/\/ 반드시 구별되는)\/\/\/ 길이 k의 경로는 정확히 k개의 세포를 방문하는 것을 의미합니다 (아니면 \/\/\/ 셀. \/\/다른 말로 하면, 여러분은 현재와 가장자리를 공유하는 세포로 갈 수 있습니다.\/\/\/ 어떤 세포에서, 그리고 각 단계에 당신은 이웃 세포의 어느 이동할 수 있습니다, \/\/그리드에서 길이 k의 최소 경로를 찾아내야 합니다. 시작하실 수 있습니다.\/\/\/ inclusive는 그리드의 셀에 정확히 한 번 나타납니다.\/\/\/ 그리드의 각 셀에는 값이 들어있습니다. [1, N * N] 범위의 모든 정수\/\/\/ N 행과 N 열 (N >=2) 과 양수 k를 가진 격자를 주어, \/\/\/ >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)\n\/\/\/ vec![1, 2, 1]\n\/\/\/ >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)\n\/\/\/ vec![1]\nfn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n","canonical_solution":"fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n    let n = grid.len();\n    let mut best_path = vec![];\n    let mut best_values = vec![isize::MAX; k as usize];\n    \n    fn dfs(\n        grid: &Vec<Vec<isize>>, \n        row: usize, \n        col: usize, \n        path: &mut Vec<(usize, usize)>, \n        values: &mut Vec<isize>, \n        k: isize, \n        best_values: &mut Vec<isize>\n    ) {\n        if path.len() == k as usize {\n            if values < best_values {\n                best_values.clone_from(values);\n            }\n            return;\n        }\n        \n        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];\n        for &(dr, dc) in directions.iter() {\n            let new_row = row as isize + dr;\n            let new_col = col as isize + dc;\n            if new_row >= 0 && new_row < grid.len() as isize && new_col >= 0 && new_col < grid.len() as isize {\n                path.push((new_row as usize, new_col as usize));\n                values.push(grid[new_row as usize][new_col as usize]);\n                dfs(grid, new_row as usize, new_col as usize, path, values, k, best_values);\n                values.pop();\n                path.pop();\n            }\n        }\n    }\n\n    for r in 0..n {\n        for c in 0..n {\n            let mut path = vec![(r, c)];\n            let mut values = vec![grid[r][c]];\n            dfs(&grid, r, c, &mut path, &mut values, k, &mut best_values);\n        }\n    }\n\n    best_values\n}","tests":"}\n\nfn main() {\n    let candidate = minPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);\n    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);\n    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);\n    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);\n    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);\n    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);\n    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n"},{"task_id":"HumanEval_130","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 트리보나치 수열의 첫 번째 n + 1 숫자들. \/\/\/ 음이 아닌 정수 n을 주어, 의 벡터를 반환해야 합니다\/\/\/ = 2 + 3 + 3 = 8\/\/\/ tri(3) = tri(2) + tri(1) + tri(4)\/\/\/ tri(4) = 3 \/\/\/ tri(2) = 1 + (2 \/ 2) = 2 \/\/\/ 예를 들어: \/\/\/ tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1) 이므로 n은 홀수입니다.\/\/\/ tri (n) = 1 + n \/ 2 이고, n이 짝수라면\/\/\/ tri(1) = 3 \/\/\/ 트리보나치 염기서열은 다음과 같은 반복으로 정의됩니다: \/\/하지만 사람들이 모르는 것은 트리보나치 염기서열입니다.\/\/\/ 모두가 피보나치 수열을 알고 있습니다, 그것은 깊이 수학자에 의해 연구되었습니다 \/\/\/ >>> tri(3)\n\/\/\/ vec![1, 3, 2, 8]\nfn tri(n: isize) -> Vec<isize> {\n","canonical_solution":"fn tri(n: isize) -> Vec<isize> {\n    fn tribonacci(n: isize, memo: &mut Vec<isize>) -> isize {\n        if n < memo.len() as isize {\n            return memo[n as usize];\n        }\n\n        let result = if n == 1 {\n            3\n        } else if n % 2 == 0 {\n            1 + n \/ 2\n        } else {\n            tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n + 1, memo)\n        };\n\n        if n as usize >= memo.len() {\n            memo.resize(n as usize + 1, 0);\n        }\n        memo[n as usize] = result;\n        result\n    }\n\n    let mut sequence = Vec::new();\n    let mut memo = Vec::new();\n\n    for i in 0..=n {\n        sequence.push(tribonacci(i, &mut memo));\n    }\n\n    sequence\n}","tests":"}\n\nfn main() {\n    let candidate = tri;\n    assert_eq!(candidate(3), vec![1, 3, 2, 8]);\n    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);\n    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);\n    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);\n    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);\n    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);\n    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);\n    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);\n    assert_eq!(candidate(0), vec![1]);\n    assert_eq!(candidate(1), vec![1, 3]);\n}\n"},{"task_id":"HumanEval_131","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 모든 숫자가 짝수인 경우 0을 반환합니다. \/\/\/ 양수 n을 주어 홀수들의 곱을 반환합니다. \/\/\/ >>> digits(1)\n\/\/\/ 1\n\/\/\/ >>> digits(4)\n\/\/\/ 0\n\/\/\/ >>> digits(235)\n\/\/\/ 15\nfn digits(n: isize) -> isize {\n","canonical_solution":"fn digits(n: isize) -> isize {\n    let mut product = 1;\n    let mut has_odd = false;\n    let mut num = n;\n\n    while num > 0 {\n        let digit = num % 10;\n        if digit % 2 != 0 {\n            product *= digit;\n            has_odd = true;\n        }\n        num \/= 10;\n    }\n\n    if has_odd {\n        product\n    } else {\n        0\n    }\n}\n\nfn main() {\n    println!(\"{}\", digits(1));  \/\/ 1\n    println!(\"{}\", digits(4));  \/\/ 0\n    println!(\"{}\", digits(235)); \/\/ 15\n}","tests":"}\n\nfn main() {\n    let candidate = digits;\n    assert_eq!(candidate(5), 5);\n    assert_eq!(candidate(54), 5);\n    assert_eq!(candidate(120), 1);\n    assert_eq!(candidate(5014), 5);\n    assert_eq!(candidate(98765), 315);\n    assert_eq!(candidate(5576543), 2625);\n    assert_eq!(candidate(2468), 0);\n}\n"},{"task_id":"HumanEval_132","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 하위 계열의 적어도 한 개의 괄호가 둥글게 되어 있습니다. \/\/\/ 함수는 유효한 괄호의 하위열이 존재할 경우에만 true를 반환해야 합니다.\/\/\/ 사각형 괄호만 포함된 문자열을 입력으로 사용하는 함수를 생성합니다. \/\/\/ >>> is_nested(String::from(\"[[]]\"))\n\/\/\/ true\n\/\/\/ >>> is_nested(String::from(\"[]]]]]]][[[[[]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[][]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[[][]]\"))\n\/\/\/ true\n\/\/\/ >>> is_nested(String::from(\"[[]][[\"))\n\/\/\/ true\nfn is_nested(string: String) -> bool {\n","canonical_solution":"fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let mut nested = false;\n\n    for bracket in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n        } else if bracket == ']' {\n            if let Some(_) = stack.pop() {\n                if !stack.is_empty() {\n                    nested = true;\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n\n    nested\n}\n\nfn main() {\n    println!(\"{}\", is_nested(String::from(\"[[]]\"))); \/\/ true\n    println!(\"{}\", is_nested(String::from(\"[]]]]]]][[[[[]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[][]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[[][]]\"))); \/\/ true\n    println!(\"{}\", is_nested(String::from(\"[[]][[\"))); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"},{"task_id":"HumanEval_133","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 벡터에서 각 요소를 먼저 상위 int (~ 천장) 로 둥글게 니다.\/\/\/ 주어진 벡터에서 제곱된 숫자의 합을 반환해야 합니다, \/\/\/ 숫자의 벡터를 주어집니다. \/\/\/ >>> lst(vec![1.0, 2.0, 3.0])\n\/\/\/ 14\n\/\/\/ >>> lst(vec![1.0, 4.0, 9.0])\n\/\/\/ 98\n\/\/\/ >>> lst(vec![1.0, 3.0, 5.0, 7.0])\n\/\/\/ 84\n\/\/\/ >>> lst(vec![1.4, 4.2, 0.0])\n\/\/\/ 29\n\/\/\/ >>> lst(vec![-2.4, 1.0, 1.0])\n\/\/\/ 6\nfn sum_squares(lst: Vec<f64>) -> isize {\n","canonical_solution":"fn sum_squares(lst: Vec<f64>) -> isize {\n    lst.iter()\n        .map(|&x| x.ceil() as isize)  \/\/ Round each element to the nearest upper integer\n        .map(|x| x * x)               \/\/ Square each element\n        .sum()                        \/\/ Sum all the squared elements\n}\n\nfn main() {\n    println!(\"{}\", sum_squares(vec![1.0, 2.0, 3.0])); \/\/ 14\n    println!(\"{}\", sum_squares(vec![1.0, 4.0, 9.0])); \/\/ 98\n    println!(\"{}\", sum_squares(vec![1.0, 3.0, 5.0, 7.0])); \/\/ 84\n    println!(\"{}\", sum_squares(vec![1.4, 4.2, 0.0])); \/\/ 29\n    println!(\"{}\", sum_squares(vec![-2.4, 1.0, 1.0])); \/\/ 6\n}","tests":"}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);\n    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);\n    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);\n    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);\n    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);\n    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);\n    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);\n    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);\n    assert_eq!(candidate(vec![0.0]), 0);\n    assert_eq!(candidate(vec![-1.0]), 1);\n    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);\n}\n"},{"task_id":"HumanEval_134","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 참고: \"word\"는 공간으로 분리된 문자 그룹입니다.\/\/\/ 단어의 일부, 그리고 거짓 그렇지 않으면. \/\/\/ 는 알파벳 문자이며, 는 아닙니다.\/\/\/ 마지막 문자가 라면 true를 반환하는 함수를 생성합니다.\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pie\"))\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pi e\"))\n\/\/\/ true\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pi e \"))\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"\"))\n\/\/\/ false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n","canonical_solution":"fn check_if_last_char_is_a_letter(txt: String) -> bool {\n    if let Some(c) = txt.trim().chars().rev().next() {\n        if c.is_alphabetic() {\n            if let Some(prev_char) = txt.chars().rev().skip_while(|&ch| ch.is_whitespace()).nth(1) {\n                return !prev_char.is_alphabetic();\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pie\")));  \/\/ false\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pi e\"))); \/\/ true\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pi e \"))); \/\/ false\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"\")));           \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n}\n"},{"task_id":"HumanEval_135","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 두 번 반복되는 값.\/\/\/ 그런 요소가 존재하지 않는다면 -1을 반환합니다. 주어진 벡터는 를 포함하지 않습니다.\/\/\/는 바로 앞의 요소보다 크거나 같지는 않습니다. 만약 \/\/\/ 가장 큰 인덱스를 반환하는 함수를 생성합니다.\/\/\/ >>> can_arrange(vec![1, 2, 4, 3, 5])\n\/\/\/ 3\n\/\/\/ >>> can_arrange(vec![1, 2, 3])\n\/\/\/ -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn can_arrange(arr: Vec<isize>) -> isize {\n    for i in (1..arr.len()).rev() {\n        if arr[i] < arr[i - 1] {\n            return i as isize;\n        }\n    }\n    -1\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     println!(\"{}\", can_arrange(vec![1, 2, 4, 3, 5])); \/\/ Outputs: 3\n\/\/     println!(\"{}\", can_arrange(vec![1, 2, 3])); \/\/ Outputs: -1\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"},{"task_id":"HumanEval_136","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 음수나 양수 पू수가 없으면 None로 반환합니다. \/\/\/ 벡터에서 양수 정수를  수 있습니다.\/\/\/ 음수 중 가장 큰 숫자이고, 'b'는 가장 작은 숫자입니다.\/\/\/ 함수를 생성하여 튜플 (a, b) 을 반환합니다.\/\/\/ >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n\/\/\/ (None, Some(1))\n\/\/\/ >>> largest_smallest_integers(vec![])\n\/\/\/ (None, None)\n\/\/\/ >>> largest_smallest_integers(vec![0])\n\/\/\/ (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n","canonical_solution":"fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative: Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\n    for &num in &lst {\n        if num < 0 {\n            largest_negative = match largest_negative {\n                Some(largest) => Some(largest.max(num)),\n                None => Some(num),\n            };\n        } else if num > 0 {\n            smallest_positive = match smallest_positive {\n                Some(smallest) => Some(smallest.min(num)),\n                None => Some(num),\n            };\n        }\n    }\n\n    (largest_negative, smallest_positive)\n}\n\nfn main() {\n    println!(\"{:?}\", largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])); \/\/ (None, Some(1))\n    println!(\"{:?}\", largest_smallest_integers(vec![])); \/\/ (None, None)\n    println!(\"{:?}\", largest_smallest_integers(vec![0])); \/\/ (None, None)\n    println!(\"{:?}\", largest_smallest_integers(vec![-5, -1, -3, 0, 2, 3])); \/\/ (Some(-1), Some(2))\n}","tests":"}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));\n}\n"},{"task_id":"HumanEval_138","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 \/\/\/ 주어진 숫자 n이 정확히 4개의 양수 짝수의 합으로 쓸 수 있는지 평가해 보겠습니다.\/\/\/ >>> is_equal_to_sum_even(4)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(6)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(8)\n\/\/\/ true\nfn is_equal_to_sum_even(n: isize) -> bool {\n","canonical_solution":"fn is_equal_to_sum_even(n: isize) -> bool {\n    \/\/ A number n can be expressed as the sum of 4 positive even numbers if and only if\n    \/\/ it is greater than or equal to 8 and even\n    n >= 8 && n % 2 == 0\n}\n\n\/\/ Test cases\nfn main() {\n    println!(\"{}\", is_equal_to_sum_even(4));  \/\/ false\n    println!(\"{}\", is_equal_to_sum_even(6));  \/\/ false\n    println!(\"{}\", is_equal_to_sum_even(8));  \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = is_equal_to_sum_even;\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(8), true);\n    assert_eq!(candidate(10), true);\n    assert_eq!(candidate(11), false);\n    assert_eq!(candidate(12), true);\n    assert_eq!(candidate(13), false);\n    assert_eq!(candidate(16), true);\n}\n"},{"task_id":"HumanEval_139","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ n > 0 \/\/\/ brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! \/\/\/ 브라질의 인수는 다음과 같이 정의됩니다: \/\/\/ >>> special_factorial(4)\n\/\/\/ 288\n\/\/\/ The function will receive an integer as input and should return the special\n\/\/\/ factorial of this integer.\nfn special_factorial(n: isize) -> isize {\n","canonical_solution":"fn factorial(n: isize) -> isize {\n    (1..=n).product()\n}\n\nfn special_factorial(n: isize) -> isize {\n    (1..=n).map(factorial).product()\n}\n\nfn main() {\n    let result = special_factorial(4);\n    println!(\"{}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"},{"task_id":"HumanEval_140","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 다음으로 모든 연속적인 공백을 - 로 대체합니다.\/\/\/ 그리고 문자열이 2개 이상의 연속적인 스페이스를 가지고 있다면, \/\/\/ 문자열을 주어, 모든 공백을 밑줄로 대체합니다.\/\/\/ >>> fix_spaces(String::from(\" Example\"))\n\/\/\/ String::from(\"Example\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 1\"))\n\/\/\/ String::from(\"Example_1\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 2\"))\n\/\/\/ String::from(\"_Example_2\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 3\"))\n\/\/\/ String::from(\"_Example-3\")\nfn fix_spaces(text: String) -> String {\n","canonical_solution":"fn fix_spaces(text: String) -> String {\n    let mut result = String::new();\n    let mut space_count = 0;\n\n    for c in text.chars() {\n        if c == ' ' {\n            space_count += 1;\n        } else {\n            if space_count > 2 {\n                result.push('-');\n            } else if space_count > 0 {\n                result.push_str(&\"_\".repeat(space_count));\n            }\n            result.push(c);\n            space_count = 0;\n        }\n    }\n\n    if space_count > 2 {\n        result.push('-');\n    } else if space_count > 0 {\n        result.push_str(&\"_\".repeat(space_count));\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = fix_spaces;\n    assert_eq!(candidate(String::from(\"Example\")), String::from(\"Example\"));\n    assert_eq!(candidate(String::from(\"Mudasir Hanif \")), String::from(\"Mudasir_Hanif_\"));\n    assert_eq!(candidate(String::from(\"Yellow Yellow  Dirty  Fellow\")), String::from(\"Yellow_Yellow__Dirty__Fellow\"));\n    assert_eq!(candidate(String::from(\"Exa   mple\")), String::from(\"Exa-mple\"));\n    assert_eq!(candidate(String::from(\"   Exa 1 2 2 mple\")), String::from(\"-Exa_1_2_2_mple\"));\n}\n"},{"task_id":"HumanEval_141","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ - 점 뒤에 있는 하위 문자열은 다음 중 하나여야 합니다: ['txt', 'exe', 'dll'] \/\/\/ 라틴어 알파벳 ('a'-'z' 및 'A'-'Z'). \/\/\/ - 점 앞의 하위 문자열은 빈 것이 되어서는 안되며, 에서 시작됩니다.\/\/\/ - 파일 이름에는 정확히 한 점 '.' \/\/\/ - 파일 이름에는 3자리 이상 ('0'-'9') 이 없어야 합니다. \/\/\/ 충족 되 니까: \/\/\/ 파일의 이름은 다음 조건이 모두 충족된 경우에만 유효하다고 간주됩니다.\/\/\/ 파일 이름이 유효하다면 '예'를, 그렇지 않으면 '아니오'를 반환합니다.\/\/\/ 파일의 이름을 나타내는 문자열을 가져다가 를 반환하는 함수를 생성합니다.\/\/\/ >>> file_name_check(String::from(\"example.txt\"))\n\/\/\/ String::from(\"Yes\")\n\/\/\/ >>> file_name_check(String::from(\"1example.dll\"))\n\/\/\/ String::from(\"No\")\nfn file_name_check(file_name: String) -> String {\n","canonical_solution":"fn file_name_check(file_name: String) -> String {\n    let parts: Vec<&str> = file_name.split('.').collect();\n\n    if parts.len() != 2 {\n        return String::from(\"No\");\n    }\n\n    let before_dot = parts[0];\n    let after_dot = parts[1];\n\n    if before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic() {\n        return String::from(\"No\");\n    }\n\n    let digit_count = before_dot.chars().filter(|c| c.is_digit(10)).count();\n    if digit_count > 3 {\n        return String::from(\"No\");\n    }\n\n    match after_dot {\n        \"txt\" | \"exe\" | \"dll\" => String::from(\"Yes\"),\n        _ => String::from(\"No\"),\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\/this_is_valid.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"No\"));\n}\n"},{"task_id":"HumanEval_142","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 벡터에서 3 또는 4의 배수가 아닌 항목을 변경합니다. 함수는 모든 항목의 합을 반환합니다.\/\/\/ 곱하기 3 이 되고, 인덱스가 3의 곱이 아닌 4의 곱이라면 정수 엔트리를 세로화합니다. 함수는 \/\/\/ 이 함수는 정수의 벡터를 취한다. 벡터 내의 모든 항목에 대해 함수는 벡터 지수가 a라면 정수 항목을 제곱한다.\/\/\/ \" \/\/\/ >>> lst\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> lst\n\/\/\/ vec![]\n\/\/\/ >>> lst\n\/\/\/ vec![-1, -5, 2, -1, -5]\nfn sum_squares(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn sum_squares(lst: Vec<isize>) -> isize {\n    lst.into_iter()\n        .enumerate()\n        .map(|(i, value)| {\n            if i % 3 == 0 {\n                value * value\n            } else if i % 4 == 0 {\n                value * value * value\n            } else {\n                value\n            }\n        })\n        .sum()\n}\n\nfn main() {\n    let lst = vec![1, 2, 3];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 14\n\n    let lst = vec![];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 0\n\n    let lst = vec![-1, -5, 2, -1, -5];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 112\n}","tests":"}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1, 2, 3]), 6);\n    assert_eq!(candidate(vec![1, 4, 9]), 14);\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);\n    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);\n    assert_eq!(candidate(vec![0]), 0);\n    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);\n    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);\n    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);\n    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);\n    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);\n}\n"},{"task_id":"HumanEval_143","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 1: \/\/\/ 새로운 문자열의 단어들의 순서는 원래의 것과 같아야 합니다. \/\/\/ 그 길이는 소수입니다, \/\/\/ 그리고 당신은 원래 문장의 단어들을 포함 한 문자열을 반환해야 합니다, \/\/\/ 문장에는 공백으로 분리된 단어들이 들어있습니다.\/\/\/ 당신은 문장을 나타내는 문자열을 주어집니다, \/\/\/ >>> words_in_sentence(String::from(\"This is a test\"))\n\/\/\/ String::from(\"is\")\n\/\/\/ Example 2:\n\/\/\/ >>> words_in_sentence(String::from(\"lets go for swimming\"))\n\/\/\/ String::from(\"go for\")\n\/\/\/ Constraints:\n\/\/\/ * 1 <= len(sentence) <= 100\n\/\/\/ * sentence contains only letters\nfn words_in_sentence(sentence: String) -> String {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn words_in_sentence(sentence: String) -> String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n    let prime_length_words: Vec<&str> = words\n        .iter()\n        .filter(|&&word| is_prime(word.len()))\n        .cloned()\n        .collect();\n    prime_length_words.join(\" \")\n}\n\nfn main() {\n    assert_eq!(\n        words_in_sentence(String::from(\"This is a test\")),\n        String::from(\"is\")\n    );\n    assert_eq!(\n        words_in_sentence(String::from(\"lets go for swimming\")),\n        String::from(\"go for\")\n    );\n}","tests":"}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"));\n}\n"},{"task_id":"HumanEval_144","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ x, n가 유효 분수이고, 분모가 0이 아닌 것으로 가정할 수 있습니다.\/\/\/ <분수>\/<분모> 분자와 분모가 양수 정수일 때\/\/\/ 그렇지 않으면. x와 n 둘 다 분수의 문자열 표현이고, 다음과 같은 형식을 가지고 있습니다.\/\/\/ x * n. 함수는 x * n이 정수이고 false 라면 true를 반환합니다.\/\/\/ 당신의 임무는 표현식을 단순화할 함수를 구현하는 것입니다.\/\/\/ >>> simplify(String::from(\"1\/5\"), String::from(\"5\/1\"))\n\/\/\/ true\n\/\/\/ >>> simplify(String::from(\"1\/6\"), String::from(\"2\/1\"))\n\/\/\/ false\n\/\/\/ >>> simplify(String::from(\"7\/10\"), String::from(\"10\/2\"))\n\/\/\/ false\nfn simplify(x: String, n: String) -> bool {\n","canonical_solution":"fn gcd(a: u32, b: u32) -> u32 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nfn simplify(x: String, n: String) -> bool {\n    let x_parts: Vec<&str> = x.split('\/').collect();\n    let n_parts: Vec<&str> = n.split('\/').collect();\n    \n    let x_num: u32 = x_parts[0].parse().unwrap();\n    let x_den: u32 = x_parts[1].parse().unwrap();\n    let n_num: u32 = n_parts[0].parse().unwrap();\n    let n_den: u32 = n_parts[1].parse().unwrap();\n    \n    let result_num = x_num * n_num;\n    let result_den = x_den * n_den;\n    \n    let gcd_value = gcd(result_num, result_den);\n    \n    result_den \/ gcd_value == 1\n}","tests":"}\n\nfn main() {\n    let candidate = simplify;\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"5\/1\")), true);\n    assert_eq!(candidate(String::from(\"1\/6\"), String::from(\"2\/1\")), false);\n    assert_eq!(candidate(String::from(\"5\/1\"), String::from(\"3\/1\")), true);\n    assert_eq!(candidate(String::from(\"7\/10\"), String::from(\"10\/2\")), false);\n    assert_eq!(candidate(String::from(\"2\/10\"), String::from(\"50\/10\")), true);\n    assert_eq!(candidate(String::from(\"7\/2\"), String::from(\"4\/2\")), true);\n    assert_eq!(candidate(String::from(\"11\/6\"), String::from(\"6\/1\")), true);\n    assert_eq!(candidate(String::from(\"2\/3\"), String::from(\"5\/2\")), false);\n    assert_eq!(candidate(String::from(\"5\/2\"), String::from(\"3\/5\")), false);\n    assert_eq!(candidate(String::from(\"2\/4\"), String::from(\"8\/4\")), true);\n    assert_eq!(candidate(String::from(\"2\/4\"), String::from(\"4\/2\")), true);\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"5\/1\")), true);\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"1\/5\")), false);\n}\n"},{"task_id":"HumanEval_145","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 원래 벡터에서의 인덱스에 따라 순서로 나열합니다.\/\/\/ 참고: 몇 개의 항목이 있으면 숫자의 합이 비슷합니다.\/\/\/ 숫자의 합에 따라 순서대로 올라갑니다.\/\/\/ 주어진 정수의 벡터를 정렬하는 함수를 쓰세요.\/\/\/ >>> order_by_points(vec![1, 11, -1, -11, -12])\n\/\/\/ vec![-1, -11, 1, -12, 11]\n\/\/\/ >>> order_by_points(vec![])\n\/\/\/ Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut nums_with_indices: Vec<(isize, usize)> = nums.iter().cloned().enumerate().collect();\n\n    nums_with_indices.sort_by_key(|&(num, index)| {\n        let sum_of_digits = num.abs().to_string().chars().map(|c| c.to_digit(10).unwrap_or(0) as isize).sum::<isize>();\n        (sum_of_digits, index)\n    });\n\n    nums_with_indices.iter().map(|&(num, _)| num).collect()\n}\n\nfn main() {\n    \/\/ Example usage\n    let sorted = order_by_points(vec![1, 11, -1, -11, -12]);\n    println!(\"{:?}\", sorted); \/\/ Output: [-1, -11, 1, -12, 11]\n}","tests":"}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"},{"task_id":"HumanEval_146","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 숫자의 처음과 마지막 숫자는 홀수 (1, 3, 5, 7, 9) 입니다.\/\/\/ 벡터에서 10보다 큰 원소들의 수와 둘 다 \/\/\/ 숫자의 벡터를 입력으로 받아 반환하는 함수를 작성합니다.\/\/\/ >>> specialFilter(vec![15, -73, 14, -15])\n\/\/\/ 1\n\/\/\/ >>> specialFilter(vec![33, -2, -3, 45, 21, 109])\n\/\/\/ 2\nfn specialFilter(nums: Vec<isize>) -> isize {\n","canonical_solution":"fn specialFilter(nums: Vec<isize>) -> isize {\n    nums.into_iter().filter(|&num| {\n        let abs_num = num.abs();\n        abs_num > 10 && {\n            let digits: Vec<u8> = abs_num.to_string().bytes().map(|b| b - b'0').collect();\n            let first_digit = digits.first().unwrap();\n            let last_digit = digits.last().unwrap();\n            first_digit % 2 == 1 && last_digit % 2 == 1\n        }\n    }).count() as isize\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result1 = specialFilter(vec![15, -73, 14, -15]);\n\/\/     println!(\"{}\", result1); \/\/ Output: 1\n\n\/\/     let result2 = specialFilter(vec![33, -2, -3, 45, 21, 109]);\n\/\/     println!(\"{}\", result2); \/\/ Output: 2\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = specialFilter;\n    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);\n    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);\n    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);\n    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);\n    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n}\n"},{"task_id":"HumanEval_147","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예시: \/\/\/ 그리고 a[i] + a[j] + a[k]은 3의 배수입니다. \/\/\/ a의 세 번 번 수 (a[i], a[j], a[k]) 를 반환합니다.\/\/\/ 각 i (1 ≤ i ≤ n) 에 대해 a[i] = i * i - i + 1의 값은\/\/\/ 당신은 양수 n을 주어집니다. 당신은 길이 n의 정수 벡터를 만들어야합니다.\/\/\/ >>> get_max_triples(5)\n\/\/\/ 1\n\/\/\/ Explanation: \n\/\/\/ a = [1, 3, 7, 13, 21]\n\/\/\/ The only valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n","canonical_solution":"fn get_max_triples(n: isize) -> isize {\n    let mut a = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    \n    let mut count = 0;\n    for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n                    count += 1;\n                }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    println!(\"{}\", get_max_triples(5)); \/\/ Output: 1\n}","tests":"}\n\nfn main() {\n    let candidate = get_max_triples;\n    assert_eq!(candidate(5), 1);\n    assert_eq!(candidate(6), 4);\n    assert_eq!(candidate(10), 36);\n    assert_eq!(candidate(100), 53361);\n}\n"},{"task_id":"HumanEval_149","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 모든 단어들이 같은 길이일 것이라고 가정할 수 있습니다. \/\/\/ 함수는 정렬된 순서로 문자열의 벡터를 반환해야 합니다. \/\/\/ 두 단어의 길이가 같다면, 벡터를 알파벳 순으로 정렬하세요. \/\/\/ 이 규칙에 따라 정렬된 벡터를 반환해야 합니다. \/\/\/ 벡터의 순서는 각 단어의 길이에 따라 상승해야 합니다, 그리고 당신은 \/\/\/ 그리고 이중이 있을 수도 있습니다.\/\/\/ 벡터는 항상 문자열의 벡터이며 결코 숫자의 벡터가 아닙니다, \/\/\/ 그리고 정렬된 순서를 가진 결과 벡터를 반환합니다, \/\/\/ 이 홀수 길이의 문자열을 삭제합니다, \/\/\/ 문자열의 벡터를 파라미터로 받아들이는 함수를 쓰세요, \/\/\/ >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")])\n\/\/\/ vec![String::from(\"aa\")]\n\/\/\/ >>> list_sort(vec![String::from(\"ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n\/\/\/ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    let mut even_length_strings: Vec<String> = lst\n        .into_iter()\n        .filter(|s| s.len() % 2 == 0)\n        .collect();\n    \n    even_length_strings.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));\n    \n    even_length_strings\n}\n\nfn main() {\n    let result = sorted_list_sum(vec![\n        String::from(\"aa\"),\n        String::from(\"a\"),\n        String::from(\"aaa\"),\n    ]);\n    println!(\"{:?}\", result); \/\/ Should print: [\"aa\"]\n\n    let result = sorted_list_sum(vec![\n        String::from(\"ab\"),\n        String::from(\"a\"),\n        String::from(\"aaa\"),\n        String::from(\"cd\"),\n    ]);\n    println!(\"{:?}\", result); \/\/ Should print: [\"ab\", \"cd\"]\n}","tests":"}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]), vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"bbbb\")]);\n}\n"},{"task_id":"HumanEval_150","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 소수이고 y의 값을 반환해야 합니다. 그렇지 않으면\/\/\/ n이 라면 x의 값을 반환하는 간단한 프로그램\/\/\/ >>> x_or_y(7, 34, 12)\n\/\/\/ 34\n\/\/\/ >>> x_or_y(15, 8, 5)\n\/\/\/ 5\nfn x_or_y(n: isize, x: isize, y: isize) -> isize {\n","canonical_solution":"fn x_or_y(n: isize, x: isize, y: isize) -> isize {\n    fn is_prime(num: isize) -> bool {\n        if num <= 1 {\n            return false;\n        }\n        for i in 2..=((num as f64).sqrt() as isize) {\n            if num % i == 0 {\n                return false;\n            }\n        }\n        true\n    }\n    \n    if is_prime(n) {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    println!(\"{}\", x_or_y(7, 34, 12)); \/\/ Output: 34\n    println!(\"{}\", x_or_y(15, 8, 5)); \/\/ Output: 5\n}","tests":"}\n\nfn main() {\n    let candidate = x_or_y;\n    assert_eq!(candidate(7, 34, 12), 34);\n    assert_eq!(candidate(15, 8, 5), 5);\n    assert_eq!(candidate(3, 33, 5212), 33);\n    assert_eq!(candidate(1259, 3, 52), 3);\n    assert_eq!(candidate(7919, -1, 12), -1);\n    assert_eq!(candidate(3609, 1245, 583), 583);\n    assert_eq!(candidate(91, 56, 129), 129);\n    assert_eq!(candidate(6, 34, 1234), 1234);\n    assert_eq!(candidate(1, 2, 0), 0);\n    assert_eq!(candidate(2, 2, 0), 2);\n}\n"},{"task_id":"HumanEval_151","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 벡터에서 홀수인 숫자를 무시하고, 음수나 정수 아닌 숫자를 무시합니다.\/\/\/ 숫자의 벡터를 주어, 숫자의 제곱의 합을 반환합니다.\/\/\/ >>> double_the_difference(vec![1, 3, 2, 0])\n\/\/\/ 10\n\/\/\/ >>> double_the_difference(vec![-1, -2, 0])\n\/\/\/ 0\n\/\/\/ >>> double_the_difference(vec![9, -2])\n\/\/\/ 81\n\/\/\/ >>> double_the_difference(vec![0])\n\/\/\/ 0\n\/\/\/ If the input vector is empty, return 0.\nfn double_the_difference(lst: Vec<f64>) -> isize {\n","canonical_solution":"fn double_the_difference(lst: Vec<f64>) -> isize {\n    lst.iter()\n        .filter(|&&x| x.fract() == 0.0 && x > 0.0 && x as isize % 2 != 0)\n        .map(|&x| (x as isize).pow(2))\n        .sum()\n}\n\nfn main() {\n    println!(\"{}\", double_the_difference(vec![1.0, 3.0, 2.0, 0.0])); \/\/ 10\n    println!(\"{}\", double_the_difference(vec![-1.0, -2.0, 0.0])); \/\/ 0\n    println!(\"{}\", double_the_difference(vec![9.0, -2.0])); \/\/ 81\n    println!(\"{}\", double_the_difference(vec![0.0])); \/\/ 0\n    println!(\"{}\", double_the_difference(vec![])); \/\/ 0\n}","tests":"}\n\nfn main() {\n    let candidate = double_the_difference;\n    assert_eq!(candidate(Vec::<f64>::new()), 0);\n    assert_eq!(candidate(vec![5.0, 4.0]), 25);\n    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);\n    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);\n    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);\n    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);\n    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);\n}\n"},{"task_id":"HumanEval_152","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 값은 0이고, 그렇지 않다면, 값은 추측과 점수 사이의 절대적인 차이입니다.\/\/\/ 각 추측이 얼마나 멀리 떨어져 있는지 나타내는 같은 길이의 벡터를 반환합니다.\/\/\/ 당신은 두 개의 벡터 점수와 추측을 주어집니다. 각 지수는 일치하는 것을 보여줍니다.\/\/\/ 당신의 임무는 사람이 여러 경기의 결과를 정확하게 추측했는지 결정하는 것입니다. \/\/\/ 확실히 기록하고 비교할 가치가 있습니다. \/\/그 순간의 생각과 감정은\/\/\/ 우리 모두 그 느낌을 기억한다고 생각합니다 어떤 오랫동안 기다린 결과 때 \/\/\/ >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])\n\/\/\/ vec![0, 0, 0, 0, 3, 3]\n\/\/\/ >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])\n\/\/\/ vec![4, 4, 1, 0, 0, 6]\nfn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n    game.iter()\n        .zip(guess.iter())\n        .map(|(g, gss)| (g - gss).abs())\n        .collect()\n}\n\nfn main() {\n    let result1 = compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]);\n    let result2 = compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2]);\n    println!(\"{:?}\", result1); \/\/ Output: [0, 0, 0, 0, 3, 3]\n    println!(\"{:?}\", result2); \/\/ Output: [4, 4, 1, 0, 0, 6]\n}","tests":"}\n\nfn main() {\n    let candidate = compare;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);\n    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);\n    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);\n    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);\n}\n"},{"task_id":"HumanEval_153","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ (그 강도는 -1) 입니다.\/\/\/ 'Slices.SErviNGSliCes'를 반환합니다. 왜냐하면 'SErviNGSliCes'가 가장 강력한 확장자이기 때문입니다.\/\/\/ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] 그러면 당신은 \/\/\/ 예를 들어, 만약 \"Slices\"가 의 클래스와 벡터로 주어졌다면\/\/\/ 벡터에서 먼저 나오는 것을 선택합니다.\/\/\/ 같은 강도 두 개 이상의 확장자가 있다면, 당신은\/\/\/ format: ClassName.StrongestExtensionName.  클래스 이름. 가장 강력한 확장 이름. \/\/\/ 가장 강력한 확장자를 찾아서 여기에 문자열을 반환해야 합니다.\/\/\/ 확장 이름에서, 강도는 CAP - SM 분수로 주어집니다. \/\/\/ 확장자의 이름의 글자, 그리고 SM는 소문자 의 숫자입니다.\/\/\/ 확장자의 강도는 다음과 같습니다: CAP가 대문자의 숫자 로 둡니다.\/\/\/ 확장자는 클래스에 추가 클래스를 로드하는 데 사용된다.\/\/\/ 클래스의 이름 (스트링) 과 확장 벡터를 얻게 됩니다.\/\/\/ >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n\/\/\/ String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n","canonical_solution":"fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let mut strongest_extension = String::new();\n    let mut max_strength = i32::MIN;\n\n    for extension in extensions {\n        let cap_count = extension.chars().filter(|c| c.is_uppercase()).count() as i32;\n        let sm_count = extension.chars().filter(|c| c.is_lowercase()).count() as i32;\n        let strength = cap_count - sm_count;\n\n        if strength > max_strength {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    format!(\"{}.{}\", class_name, strongest_extension)\n}","tests":"}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"},{"task_id":"HumanEval_154","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 두 단어 주어져 있습니다. 두 번째 단어 또는 그 회전 중 하나가 첫 번째 단어의 하위 문자열이라면 true를 반환해야 합니다.\/\/\/ >>> cycpattern_check(String::from(\"abcd\"), String::from(\"abd\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"hello\"), String::from(\"ell\"))\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(String::from(\"whassup\"), String::from(\"psus\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"abab\"), String::from(\"baa\"))\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(String::from(\"efef\"), String::from(\"eeff\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"himenss\"), String::from(\"simen\"))\n\/\/\/ true\nfn cycpattern_check(a: String, b: String) -> bool {\n","canonical_solution":"fn cycpattern_check(a: String, b: String) -> bool {\n    let len_b = b.len();\n    if len_b == 0 {\n        return true;\n    }\n    let doubled_b = b.clone() + &b;\n    for i in 0..len_b {\n        if let Some(sub) = doubled_b.get(i..i + len_b) {\n            if a.contains(sub) {\n                return true;\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = cycpattern_check;\n    assert_eq!(candidate(String::from(\"xyzw\"), String::from(\"xyw\")), false);\n    assert_eq!(candidate(String::from(\"yello\"), String::from(\"ell\")), true);\n    assert_eq!(candidate(String::from(\"whattup\"), String::from(\"ptut\")), false);\n    assert_eq!(candidate(String::from(\"efef\"), String::from(\"fee\")), true);\n    assert_eq!(candidate(String::from(\"abab\"), String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"winemtt\"), String::from(\"tinem\")), true);\n}\n"},{"task_id":"HumanEval_155","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 정수를 주어. 각각 짝수와 홀수 숫자를 가진 튜플을 반환합니다. \/\/\/ >>> even_odd_count(-12)\n\/\/\/ (1, 1)\n\/\/\/ >>> even_odd_count(123)\n\/\/\/ (1, 2)\nfn even_odd_count(num: isize) -> (isize, isize) {\n","canonical_solution":"fn even_odd_count(num: isize) -> (isize, isize) {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n    let num_str = num.abs().to_string();\n    \n    for ch in num_str.chars() {\n        if let Some(digit) = ch.to_digit(10) {\n            if digit % 2 == 0 {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n    \n    (even_count, odd_count)\n}","tests":"}\n\nfn main() {\n    let candidate = even_odd_count;\n    assert_eq!(candidate(7), (0, 1));\n    assert_eq!(candidate(-78), (1, 1));\n    assert_eq!(candidate(3452), (2, 2));\n    assert_eq!(candidate(346211), (3, 3));\n    assert_eq!(candidate(-345821), (3, 3));\n    assert_eq!(candidate(-2), (1, 0));\n    assert_eq!(candidate(-45347), (2, 3));\n    assert_eq!(candidate(0), (1, 0));\n}\n"},{"task_id":"HumanEval_156","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 제한: 1 <= num <= 1000\/\/\/ 그리고 작은 글자로 돌려주죠. \/\/\/ 양수 정수를 주어, 그 로마자 수를 문자열로 얻습니다, \/\/\/ >>> int_to_mini_roman(19)\n\/\/\/ String::from(\"xix\")\n\/\/\/ >>> int_to_mini_roman(152)\n\/\/\/ String::from(\"clii\")\n\/\/\/ >>> int_to_mini_roman(426)\n\/\/\/ String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n","canonical_solution":"fn int_to_mini_roman(mut number: isize) -> String {\n    let roman_numerals = [\n        (1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n        (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n        (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"),\n        (1, \"i\"),\n    ];\n    \n    let mut result = String::new();\n    \n    for &(value, symbol) in roman_numerals.iter() {\n        while number >= value {\n            number -= value;\n            result.push_str(symbol);\n        }\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"},{"task_id":"HumanEval_157","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/90도.\/\/\/ 직각삼각형은 한 각이 직각인 삼각형 또는 \/\/\/ 변이 직각 삼각형을 이루고, 그렇지 않으면 틀린 것입니다. \/\/삼각형의 세 변의 길이를 주어, 3 칸의 길이가 0 이면 true를 반환합니다.\/\/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/\/ true\n\/\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/\/ false\nfn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n","canonical_solution":"fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n    let mut sides = [a, b, c];\n    sides.sort_unstable();\n\n    let [x, y, z] = sides;\n    x * x + y * y == z * z\n}","tests":"}\n\nfn main() {\n    let candidate = right_angle_triangle;\n    assert_eq!(candidate(3, 4, 5), true);\n    assert_eq!(candidate(1, 2, 3), false);\n    assert_eq!(candidate(10, 6, 8), true);\n    assert_eq!(candidate(2, 2, 2), false);\n    assert_eq!(candidate(7, 24, 25), true);\n    assert_eq!(candidate(10, 5, 7), false);\n    assert_eq!(candidate(5, 12, 13), true);\n    assert_eq!(candidate(15, 8, 17), true);\n    assert_eq!(candidate(48, 55, 73), true);\n    assert_eq!(candidate(1, 1, 1), false);\n    assert_eq!(candidate(2, 2, 10), false);\n}\n"},{"task_id":"HumanEval_158","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 문자, 사전적 순서에서 먼저 나오는 것을 반환합니다. \/\/\/의 고유 한 문자를. 여러 문자열이 고유 한 최대 수를 가지고 있다면 \/\/\/ 벡터는 다른 단어를 포함합니다. 최대 숫자를 가진 단어를 반환합니다.\/\/\/ 문자열의 벡터를 받아들이는 함수를 쓰세요. \/\/\/ >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n\/\/\/ String::from(\"string\")\n\/\/\/ >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n\/\/\/ String::from(\"enam\")\n\/\/\/ >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n\/\/\/ String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n","canonical_solution":"fn find_max(words: Vec<String>) -> String {\n    fn unique_char_count(s: &str) -> usize {\n        let mut chars: std::collections::HashSet<char> = std::collections::HashSet::new();\n        for c in s.chars() {\n            chars.insert(c);\n        }\n        chars.len()\n    }\n\n    words\n        .into_iter()\n        .max_by(|a, b| {\n            let count_a = unique_char_count(a);\n            let count_b = unique_char_count(b);\n            count_a.cmp(&count_b).then_with(|| a.cmp(b))\n        })\n        .unwrap()\n}","tests":"}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n"},{"task_id":"HumanEval_159","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예: \/\/\/ 만약 남은 당근이 충분하지 않다면, 남은 당근을 다 먹지만, 여전히 배고프게 될 것입니다. \/\/\/ 식사 후 남은 당근의 수 ] \/\/\/ 당신은 [ 식사 후 먹은 당근의 총 수, \/\/\/ 하지만 이제 하루의 식사를 완료하기 위해 더 많은 당근을 먹어야 합니다. \/\/당신은 배고픈 토끼이고 이미 많은 양의 당근을 먹었습니다.\/\/\/ >>> eat(5, 6, 10)\n\/\/\/ vec![11, 4]\n\/\/\/ >>> eat(4, 8, 9)\n\/\/\/ vec![12, 1]\n\/\/\/ >>> eat(1, 10, 10)\n\/\/\/ vec![11, 0]\n\/\/\/ >>> eat(2, 11, 5)\n\/\/\/ vec![7, 0]\n\/\/\/ Variables:\n\/\/\/ @number : integer\n\/\/\/ the number of carrots that you have eaten.\n\/\/\/ @need : integer\n\/\/\/ the number of carrots that you need to eat.\n\/\/\/ @remaining : integer\n\/\/\/ the number of remaining carrots thet exist in stock\n\/\/\/ Constrain:\n\/\/\/ * 0 <= number <= 1000\n\/\/\/ * 0 <= need <= 1000\n\/\/\/ * 0 <= remaining <= 1000\n\/\/\/ Have fun :)\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n","canonical_solution":"fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let to_eat = if need <= remaining { need } else { remaining };\n    vec![number + to_eat, remaining - to_eat]\n}","tests":"}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"},{"task_id":"HumanEval_160","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 연산자 벡터는 적어도 하나의 연산자를 가지고 있고, 연산자 벡터는 적어도 두 개의 연산자를 가지고 있습니다. \/\/\/ 오퍼랜드는 음이 아닌 정수의 벡터입니다.\/\/\/ 연산자 벡터의 길이는 연산자 벡터의 길이가 1 빼기 같다는 것을 알 수 있습니다.\/\/\/ 참고: \/\/\/ => 결과 = 9\/\/\/ 결과 = 2 + 3 * 4 - 5 \/\/\/ 벡터 = [2, 3, 4, 5] \/\/\/ operator['+', '*', '-'] \/\/\/ 예: \/\/\/ 기하급수 (**)\/\/\/ 층 분할 ( \/\/ ) \/\/\/ 곱하기 (*) \/\/\/ 빼기 ( - ) \/\/\/ 추가 (+) \/\/\/ 기본적인 대수 연산: \/\/\/ 표현식과 이 표현식의 평가를 반환합니다.\/\/\/ 두 번째 벡터는 정수의 벡터입니다. 주어진 두 벡터를 사용하여 대수학을 구성하십시오.\/\/\/ 두 벡터 연산자와 연산자를 주어 첫 번째 벡터는 기본적인 대수 연산을 하고, fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n","canonical_solution":"fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n    let mut result = operand[0];\n    \n    for i in 0..operator.len() {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i+1],\n            \"-\" => result -= operand[i+1],\n            \"*\" => result *= operand[i+1],\n            \"\/\/\" => result \/= operand[i+1],\n            \"**\" => result = result.pow(operand[i+1] as u32),\n            _ => panic!(\"Unexpected operator\"),\n        }\n    }\n    \n    result\n}\n\nfn main() {\n    let operators = vec![\"+\",\"*\",\"-\"].iter().map(|s| s.to_string()).collect();\n    let operands = vec![2, 3, 4, 5];\n    let result = do_algebra(operators, operands);\n    println!(\"Result: {}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = do_algebra;\n    assert_eq!(candidate(vec![String::from(\"**\"), String::from(\"*\"), String::from(\"+\")], vec![2, 3, 4, 5]), 37);\n    assert_eq!(candidate(vec![String::from(\"+\"), String::from(\"*\"), String::from(\"-\")], vec![2, 3, 4, 5]), 9);\n    assert_eq!(candidate(vec![String::from(\"\/\/\"), String::from(\"*\")], vec![7, 3, 4]), 8);\n}\n"},{"task_id":"HumanEval_161","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예제 \/\/\/ 함수는 결과 문자열을 반환해야 합니다. \/\/\/ 문자열에 문자가 없다면, 문자열을 역으로 돌려보냅니다.\/\/\/ 그렇지 않으면 그대로 유지합니다. \/\/\/ s[i]가 글자라면, 밑에서 위로 또는 그 반대 방향으로, \/\/\/ 당신은 문자열 s를 부여됩니다. \/\/\/ >>> solve(String::from(\"1234\"))\n\/\/\/ String::from(\"4321\")\n\/\/\/ >>> solve(String::from(\"ab\"))\n\/\/\/ String::from(\"AB\")\n\/\/\/ >>> solve(String::from(\"#a@C\"))\n\/\/\/ String::from(\"#A@c\")\nfn solve(s: String) -> String {\n","canonical_solution":"fn solve(s: String) -> String {\n    if s.chars().all(|c| !c.is_alphabetic()) {\n        s.chars().rev().collect()\n    } else {\n        s.chars()\n            .map(|c| {\n                if c.is_lowercase() {\n                    c.to_ascii_uppercase()\n                } else if c.is_uppercase() {\n                    c.to_ascii_lowercase()\n                } else {\n                    c\n                }\n            })\n            .collect()\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n"},{"task_id":"HumanEval_162","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 'text'가 빈 문자열이라면 None를 반환합니다. \/\/\/ 문자열 'text'을 주어 md5 해시 동등한 문자열을 반환합니다. \/\/\/ >>> string_to_md5(String::from(\"Hello world\"))\n\/\/\/ Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\"))\nfn string_to_md5(text: String) -> Option<String> {\n","canonical_solution":"use md5;\n\nfn string_to_md5(text: String) -> Option<String> {\n    if text.is_empty() {\n        return None;\n    }\n    let digest = md5::compute(text);\n    Some(format!(\"{:x}\", digest))\n}","tests":"}\n\nfn main() {\n    let candidate = string_to_md5;\n    assert_eq!(candidate(String::from(\"Hello world\")), Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\")));\n    assert_eq!(candidate(String::from(\"\")), None);\n    assert_eq!(candidate(String::from(\"A B C\")), Some(String::from(\"0ef78513b0cb8cef12743f5aeb35f888\")));\n    assert_eq!(candidate(String::from(\"password\")), Some(String::from(\"5f4dcc3b5aa765d61d8327deb882cf99\")));\n}\n"},{"task_id":"HumanEval_163","nl":"kor_Hang","pl":"rs","prompt":"\/\/\/ 예를 들어: \/\/\/ 그리고 b, 상승 순서로.\/\/\/ 양수 a와 b를 두 개로 나누어 a와 b 사이의 짝수 숫자를 반환합니다.\/\/\/ >>> generate_integers(2, 8)\n\/\/\/ vec![2, 4, 6, 8]\n\/\/\/ >>> generate_integers(8, 2)\n\/\/\/ vec![2, 4, 6, 8]\n\/\/\/ >>> generate_integers(10, 14)\n\/\/\/ Vec::<isize>::new()\nfn generate_integers(a: isize, b: isize) -> Vec<isize> {\n","canonical_solution":"fn generate_integers(a: isize, b: isize) -> Vec<isize> {\n    let (start, end) = if a < b { (a, b) } else { (b, a) };\n    (start..=end).filter(|&x| x % 2 == 0).collect()\n}\n\nfn main() {\n    let result1 = generate_integers(2, 8);\n    println!(\"{:?}\", result1); \/\/ Output: vec![2, 4, 6, 8]\n\n    let result2 = generate_integers(8, 2);\n    println!(\"{:?}\", result2); \/\/ Output: vec![2, 4, 6, 8]\n\n    let result3 = generate_integers(10, 14);\n    println!(\"{:?}\", result3); \/\/ Output: vec![10, 12, 14]\n}","tests":"}\n\nfn main() {\n    let candidate = generate_integers;\n    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(17, 89), Vec::<isize>::new());\n}\n"}]