[{"task_id":"HumanEval_0","nl":"bod_Tibt","pl":"rb","prompt":"ཚད་གཞི་གཏན་འབེབས་བྱས་ཡོད།ཇི་ཡོད་གྲངས་སུ་གྲངས་གཉིས་ ཇི་ཡོད་གྲངས་སུ་ ཇི་ཡོད་གྲངས་སུ་ ཇི་ཡོད་གྲངས་སུ་ ཇི་ཡོད་གྲངས་སུ་ ཇི་ཡོད་གྲངས་སུ་ ཇི་ཡོད་གྲངས་སུ་ ཇི་ཡོད་གྲངས་སུ་ ཇི་ཡོད་གྲངས་སུ་ ཇི་ཡོད་གྲངས་སུ་# >>> has_close_elements.call([1.0, 2.0, 3.0], 0.5)\n# false\n# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# true\ndef has_close_elements(numbers, threshold)\n","canonical_solution":"def has_close_elements(numbers, threshold)\n  numbers.combination(2).any? { |a, b| (a - b).abs < threshold }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_has_close_elements\n    candidate = method(:has_close_elements)\n    assert_equal(true, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))\n    assert_equal(false, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))\n    assert_equal(true, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95))\n    assert_equal(false, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8))\n    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1))\n    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0))\n    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))\n  end\nend\n"},{"task_id":"HumanEval_1","nl":"bod_Tibt","pl":"rb","prompt":"ནང་འཇུག་ཐིག་ནང་ཡོད་པའི་བར་སྟོང་ལ་དོ་སྣང་མ་བྱེད།སྡེ་ཚན་སོ་སོར་ཆ་སྙོམ་ (སྒོ་ཕྱེས་པའི་རྒྱབ་ལག་རེ་རེ་བཞིན་ལེགས་པར་རྒྱབ་) བྱས་ཡོད་པ་དང་ཕན་ཚུན་དབར་སྦྲེལ་མེད་པ།ཚོ་ཚོ་སོ་སོར་དབྱེ་ནས་ཚོ་ཚོ་ཚོ་གི་རིམ་པ་ཕྱིར་ལོག་བྱེད་པ།ལས་འགན་འདི་ནང་ནང་འཇུག་བྱེད་དེ་ སྦྲེལ་ཡོད་པའི་སྒམ་ཚིགས་ཀྱི་སྡེ་ཚན་མང་པོ་བསྡུས་པའི་ཐིག་ཡིག་ཡིན། ཁྱོད་ཀྱི་དམིགས་ཡུལ་ནི་ # >>> separate_paren_groups.call(\"( ) (( )) (( )( ))\")\n# [\"()\", \"(())\", \"(()())\"]\ndef separate_paren_groups(paren_string)\n","canonical_solution":"def separate_paren_groups(paren_string)\n  # Remove spaces from the string\n  paren_string = paren_string.gsub(\" \", \"\")\n  \n  result = []\n  current_group = \"\"\n  balance = 0\n\n  paren_string.each_char do |char|\n    current_group += char\n    balance += 1 if char == '('\n    balance -= 1 if char == ')'\n\n    if balance == 0 && !current_group.empty?\n      result << current_group\n      current_group = \"\"\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_separate_paren_groups\n    candidate = method(:separate_paren_groups)\n    assert_equal([\"(()())\", \"((()))\", \"()\", \"((())()())\"], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([\"()\", \"(())\", \"((()))\", \"(((())))\"], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([\"(()(())((())))\"], candidate.call(\"(()(())((())))\"))\n    assert_equal([\"()\", \"(())\", \"(()())\"], candidate.call(\"( ) (( )) (( )( ))\"))\n  end\nend\n"},{"task_id":"HumanEval_2","nl":"bod_Tibt","pl":"rb","prompt":"གྲངས་ཀའི་བཅུ་ཆ་ཕྱིར་ལོག་བྱེད།(ལྷག་ལུས་ཆ་ཤས་ནི་ 1 ལས་ཆུང་བ་རེད།)གྲངས་ཆ་ཧྲིལ་པོ་ (གྲངས་ཆ་ཆེ་ཤོས་ནི་གྲངས་ཆ་ཉུང་བ་ལས་ཆུང་བ་) བཅུ་ཚིགས་ཀྱི་གྲངས་ཆ་ ཤོག་གྲངས་ལྡོག་པའི་ཐིག་ཁྲམ་ནང་ ཤོག་གྲངས་ལྡོག་པའི་ཐིག་ཁྲམ་ནང་ # >>> truncate_number.call(3.5)\n# 0.5\ndef truncate_number(number)\n","canonical_solution":"def truncate_number(number)\n  number - number.to_i\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_truncate_number\n    candidate = method(:truncate_number)\n    assert_equal(0.5, candidate.call(3.5))\n    assert_equal(0.25, candidate.call(1.25))\n    assert_equal(0.0, candidate.call(123.0))\n  end\nend\n"},{"task_id":"HumanEval_3","nl":"bod_Tibt","pl":"rb","prompt":"ཚད་འདི་ནས་ function དེ་ true སླར་ལོག་བྱེད་དགོས། དེ་མིན་ false སླར་ལོག་བྱེད་དགོས།ཤོག་ངོས་འདི་ཡི་བཟོ་བཅོས་མཐའ་མ་༢༩ ལ་མཐའ་འབྲས་ཀྱི་འགྲེལ་བརྗོད་བྱས་འདུགཤོག་ངོས་འདི་ནང་ \"གླ་དངུལ་གྱི་ལག་ལེན་དང་དངུལ་ཁུག་ཕྱིར་འཐེན་གྱི་ལས་འགུལ་\" ཟེར་བའི་ཡི་གེ་ཡོད་པ་རེད།# >>> below_zero.call([1, 2, 3])\n# false\n# >>> below_zero.call([1, 2, -4, 5])\n# true\ndef below_zero(operations)\n","canonical_solution":"def below_zero(operations)\n  balance = 0\n  operations.each do |operation|\n    balance += operation\n    return true if balance < 0\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_zero\n    candidate = method(:below_zero)\n    assert_equal(false, candidate.call([]))\n    assert_equal(false, candidate.call([1, 2, -3, 1, 2, -3]))\n    assert_equal(true, candidate.call([1, 2, -4, 5, 6]))\n    assert_equal(false, candidate.call([1, -1, 2, -2, 5, -5, 4, -4]))\n    assert_equal(true, candidate.call([1, -1, 2, -2, 5, -5, 4, -5]))\n    assert_equal(true, candidate.call([1, -2, 2, -2, 5, -5, 4, -4]))\n  end\nend\n"},{"task_id":"HumanEval_4","nl":"bod_Tibt","pl":"rb","prompt":"MAD = average ཟེར་བ་ཡིན། x - x_mean ཟེར་བ་ཡིན།ཚད་གཞི་དང་བར་གྱི་ཆ་ཤས་ (གནས་འདི་ནང་གི་བར་གྱི་ཆ་ཤས་) དང་།ཚད་ལྡན་བར་ཁྱད་པར་གྱི་བར་ཁྱད་པར་གྱི་ཚད་ནི་ ཚད་ལྡན་བར་ཁྱད་པར་གྱི་ཚད་ཡིན།ཚད་གཞི་འདི་ནང་གི་བར་མའི་གྲངས་ ཀྱི་ཉེ་འཁོར་དུ་ཡོད།ནང་འཇུག་གྲངས་ཀྱི་རིམ་པ་སྤྲོད་པའི་ཆེད་དུ་ Mean Absolute Deviation ཟེར་བ་དེ་རྩིས་པར་བྱའོ།# >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])\n# 1.0\ndef mean_absolute_deviation(numbers)\n","canonical_solution":"def mean_absolute_deviation(numbers)\n  mean = numbers.sum.to_f \/ numbers.size\n  deviations = numbers.map { |num| (num - mean).abs }\n  deviations.sum \/ numbers.size\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_mean_absolute_deviation\n    candidate = method(:mean_absolute_deviation)\n    assert_equal(0.5, candidate.call([1.0, 2.0]))\n    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))\n    assert_equal(1.2, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n  end\nend\n"},{"task_id":"HumanEval_5","nl":"bod_Tibt","pl":"rb","prompt":"ནང་འཇུག་རིམ་པའི་རིམ་པ་གཉིས་བར་གྲངས་ \"ཚད་མཚམས་\" ཞིག་བཙུགས་དགོས།# >>> intersperse.call([], 4)\n# []\n# >>> intersperse.call([1, 2, 3], 4)\n# [1, 4, 2, 4, 3]\ndef intersperse(numbers, delimeter)\n","canonical_solution":"def intersperse(numbers, delimeter)\n  return numbers if numbers.empty?\n  result = []\n  numbers.each_with_index do |num, index|\n    result << num\n    result << delimeter unless index == numbers.size - 1\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersperse\n    candidate = method(:intersperse)\n    assert_equal([], candidate.call([], 7))\n    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))\n    assert_equal([2, 2, 2, 2, 2], candidate.call([2, 2, 2], 2))\n  end\nend\n"},{"task_id":"HumanEval_6","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན། (() (()) ནི་ཚང་གི་ཚད་གཉིས་ལས་མང་བ་མེད་ལ། ((())) ནི་ཚང་གི་ཚད་གསུམ་ལས་མང་བ་མེད་ལ།སྡེ་ཚན་རེ་རེའི་ཆེད་དུ་ཚིགས་སུ་བསྡུར་བའི་ཚད་མཐོའི་ཚད་གཞི་ཕྱིར་འདོན་བྱ་དགོས།ལས་འགན་འདི་ནང་ནང་འཇུག་བྱེད་པ་དེ་ནི་ སྦྲེལ་ཡོད་པའི་སྒམ་ཚིགས་ཀྱི་ཆེད་དུ་སྡེ་ཚན་མང་པོ་བཞིན་པའི་ string ཞིག་ཡིན།# >>> parse_nested_parens.call(\"(()()) ((())) () ((())()())\")\n# [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n","canonical_solution":"def parse_nested_parens(paren_string)\n  paren_string.split.map do |group|\n    max_depth = current_depth = 0\n    group.chars.each do |char|\n      if char == '('\n        current_depth += 1\n        max_depth = [max_depth, current_depth].max\n      elsif char == ')'\n        current_depth -= 1\n      end\n    end\n    max_depth\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"))\n  end\nend\n"},{"task_id":"HumanEval_7","nl":"bod_Tibt","pl":"rb","prompt":"ནང་འཇུག་ཐིག་ནང་འཇུག་ཐིག་འོག་གི་ཐིག་ཚུའི་ནང་འཇུག་ཐིག་ ཞིག་ཡོད་ན་རྐྱང་པ་སེལ་འཐུ་འབད།# >>> filter_by_substring.call([], \"a\")\n# []\n# >>> filter_by_substring.call([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"bacd\", \"array\"]\ndef filter_by_substring(strings, substring)\n","canonical_solution":"def filter_by_substring(strings, substring)\n  strings.select { |string| string.include?(substring) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_substring\n    candidate = method(:filter_by_substring)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n    assert_equal([\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"))\n    assert_equal([\"grunt\", \"prune\"], candidate.call([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"))\n  end\nend\n"},{"task_id":"HumanEval_8","nl":"bod_Tibt","pl":"rb","prompt":"སྟོང་པའི་བསྡོམས་ནི་ 0 དང་སྟོང་པའི་ཐོན་རིམ་ནི་ 1 འདྲ་མཉམ་དགོས་པ་ཡིན།ཨང་གྲངས་ཧྲིལ་པོ་གྲངས་ལྡན་གྱི་གཞི་རིམ་ཤིག་གི་ཆེད་དུ་གཞི་རིམ་ནང་གི་ཨང་གྲངས་ཧྲིལ་པོ་ཐམས་ཅད་ཀྱི་བསྡོམས་དང་འབྲས་བུ་ཡོད་པའི་གཞི་རིམ་ཤིག་ཕྱིར་ལོག་བྱེད་པ།# >>> sum_product.call([])\n# [0, 1]\n# >>> sum_product.call([1, 2, 3, 4])\n# [10, 24]\ndef sum_product(numbers)\n","canonical_solution":"def sum_product(numbers)\n  sum = numbers.reduce(0, :+)\n  product = numbers.reduce(1, :*)\n  [sum, product]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_product\n    candidate = method(:sum_product)\n    assert_equal([0, 1], candidate.call([]))\n    assert_equal([3, 1], candidate.call([1, 1, 1]))\n    assert_equal([100, 0], candidate.call([100, 0]))\n    assert_equal([15, 105], candidate.call([3, 5, 7]))\n    assert_equal([10, 10], candidate.call([10]))\n  end\nend\n"},{"task_id":"HumanEval_9","nl":"bod_Tibt","pl":"rb","prompt":"རིམ་བཞིན་ཇི་ཡོད་ཨང་གྲངས་ཀྱི་རིམ་པ་ནས་ ཇི་ཡོད་དུས་ཡུན་བར་ཐོབ་པའི་ ཚད་མཐོའི་རིམ་པ་ཐོན་པའི་རིམ་པ་ཐོན་དགོས།# >>> rolling_max.call([1, 2, 3, 2, 3, 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\ndef rolling_max(numbers)\n","canonical_solution":"def rolling_max(numbers)\n  max_so_far = numbers.first\n  numbers.map do |num|\n    max_so_far = [max_so_far, num].max\n  end\nend\n\n# Example usage:\n# puts rolling_max([1, 2, 3, 2, 3, 4, 2]).inspect","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rolling_max\n    candidate = method(:rolling_max)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([4, 4, 4, 4], candidate.call([4, 3, 2, 1]))\n    assert_equal([3, 3, 3, 100, 100], candidate.call([3, 2, 3, 100, 3]))\n  end\nend\n"},{"task_id":"HumanEval_10","nl":"bod_Tibt","pl":"rb","prompt":"- string reverse གི་མཇུག་ཏུ་ palindromic suffix གི་སྔོན་དུ་ string prefix ཞིག་སྣོན་དགོས།- ཇི་འདྲ་ཡིན་ན་ palindrome ཡོད་པའི་ string གི་ postfix ཡི་རིང་ཤོས་འཚོལ་དགོས།ཚད་འཛིན་གྱི་བསམ་ཚུལ་ནི་དྭངས་མ་ཡིན།ཚད་ལྡན་ཡིག་འབྲུ་ནང་འཇུག་པའི་སྔོན་རྟགས་ཆུང་ཤོས་འཚོལ་དགོས།# >>> make_palindrome.call(\"\")\n# \"\"\n# >>> make_palindrome.call(\"cat\")\n# \"catac\"\n# >>> make_palindrome.call(\"cata\")\n# \"catac\"\ndef make_palindrome(string)\n","canonical_solution":"def make_palindrome(string)\n  return string if string.empty?\n\n  def is_palindrome?(s)\n    s == s.reverse\n  end\n\n  (0...string.length).reverse_each do |i|\n    if is_palindrome?(string[i..-1])\n      return string + string[0...i].reverse\n    end\n  end\n\n  string\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\", candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"},{"task_id":"HumanEval_11","nl":"bod_Tibt","pl":"rb","prompt":"ཌའི་ལོག་ནང་ binary XOR བྱེད་ནས་འབྲས་བུ་ཡང་ string གྱི་ཚུལ་དུ་ཕྱིར་ལོག་བྱེད་པ།ནང་འཇུག་ནི་ a དང་ b གཉིས་ནི་ 1 དང་ 0 ཙམ་ལས་གྲུབ་པའི་ཡིག་འབྲུ་གཉིས་ཡིན།# >>> string_xor.call(\"010\", \"110\")\n# \"100\"\ndef string_xor(a, b)\n","canonical_solution":"def string_xor(a, b)\n  result = \"\"\n  a.length.times do |i|\n    result << (a[i] == b[i] ? \"0\" : \"1\")\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"},{"task_id":"HumanEval_12","nl":"bod_Tibt","pl":"rb","prompt":"ནང་འཇུག་ཐིག་སྟོང་ཡོད་ན་ null སླར་ལོག་བྱེད།ཚིག་ཡིག་གི་རིམ་པ་ལས་ ཚིག་ཡིག་རིང་ཤོས་ཕྱིར་ལོག་བྱེད། ཚིག་ཡིག་མང་པོ་ཡོད་ན་ ཚིག་ཡིག་དང་པོ་ཕྱིར་ལོག་བྱེད།# >>> longest.call([])\n# nil\n# >>> longest.call([\"a\", \"b\", \"c\"])\n# \"a\"\n# >>> longest.call([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\ndef longest(strings)\n","canonical_solution":"def longest(strings)\n  return nil if strings.empty?\n  strings.max_by(&:length)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n    assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n  end\nend\n"},{"task_id":"HumanEval_13","nl":"bod_Tibt","pl":"rb","prompt":"གྲངས་ཆ་ a དང་ b གཉིས་ཀྱི་ཆེ་མཐོའི་སྤྱིར་བཏང་ཆ་བགོས་ཕྱིར་ལོག་བྱེད་པ།# >>> greatest_common_divisor.call(3, 5)\n# 1\n# >>> greatest_common_divisor.call(25, 15)\n# 5\ndef greatest_common_divisor(a, b)\n","canonical_solution":"def greatest_common_divisor(a, b)\n  while b != 0\n    a, b = b, a % b\n  end\n  a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_greatest_common_divisor\n    candidate = method(:greatest_common_divisor)\n    assert_equal(1, candidate.call(3, 7))\n    assert_equal(5, candidate.call(10, 15))\n    assert_equal(7, candidate.call(49, 14))\n    assert_equal(12, candidate.call(144, 60))\n  end\nend\n"},{"task_id":"HumanEval_14","nl":"bod_Tibt","pl":"rb","prompt":"ནང་འཇུག་ཐིག་གི་སྔོན་འཇུག་ཚུའི་རིང་ཐུང་ནས་ཆུང་ཤོས་བར་གྱི་རིམ་པ་ཚང་མ་ཕྱིར་སློག་བྱེད།# >>> all_prefixes.call(\"abc\")\n# [\"a\", \"ab\", \"abc\"]\ndef all_prefixes(string)\n","canonical_solution":"def all_prefixes(string)\n  (1..string.length).map { |i| string[0, i] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_all_prefixes\n    candidate = method(:all_prefixes)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"], candidate.call(\"asdfgh\"))\n    assert_equal([\"W\", \"WW\", \"WWW\"], candidate.call(\"WWW\"))\n  end\nend\n"},{"task_id":"HumanEval_15","nl":"bod_Tibt","pl":"rb","prompt":"0 ནས་ n བར་གྱི་བར་གྱི་གོ་རིམ་བར་མཚམས་གྲངས་ཡོད་པའི་ string སླར་ལོག་བྱེད།# >>> string_sequence.call(0)\n# \"0\"\n# >>> string_sequence.call(5)\n# \"0 1 2 3 4 5\"\ndef string_sequence(n)\n","canonical_solution":"def string_sequence(n)\n  (0..n).to_a.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_sequence\n    candidate = method(:string_sequence)\n    assert_equal(\"0\", candidate.call(0))\n    assert_equal(\"0 1 2 3\", candidate.call(3))\n    assert_equal(\"0 1 2 3 4 5 6 7 8 9 10\", candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_16","nl":"bod_Tibt","pl":"rb","prompt":"string ཞིག་ཡོད་ན། དེའི་ནང་ཡིག་འབྲུ་ཁྱད་པར་ཅན་ཇི་ཙམ་ཡོད་མེད་འཚོལ་དགོས།# >>> count_distinct_characters.call(\"xyzXYZ\")\n# 3\n# >>> count_distinct_characters.call(\"Jerry\")\n# 4\ndef count_distinct_characters(string)\n","canonical_solution":"def count_distinct_characters(string)\n  string.downcase.chars.uniq.count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5, candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"},{"task_id":"HumanEval_17","nl":"bod_Tibt","pl":"rb","prompt":"' ' ' ' ' ' ' ' ' ' ' ཟེར་བའི་སྒྲ་བཞི་ཅན་གྱི་སྒྲ་ཞིག་ལ།'o Sa Ra' - ཟློག་ཕྱེད་པ། ཐུབ་ཐེངས་གཉིས་པ།'o' - སྒྲ་ཆ་ཚང་ཞིག་ལ། སྒྲ་ཐེངས་བཞི་རིང་དུ་གནས་པ།འདི་ལྟ་སྟེ།མཐའ་མའི་དུས་མིན་རེད།ཁྱོད་ཀྱི་ལས་འགན་ནི་ string འདི་ལ་དཔྱད་ཞིབ་བྱས་རྗེས་ ཇི་ཙམ་རེ་ཐེངས་རེ་འགོར་བ་དང་མཚུངས་པའི་གྲངས་ཐང་གི་རིམ་པ་ཕྱིར་ལོག་བྱེད་པ་ཡིན།ལས་འགན་འདི་ལ་ཨེན་ཊི་ཨེས་སི་ཨི་ཨི་ (ASCII) གྱི་རྣམ་པ་སོ་སོར་སྒྲ་དབྱངས་ཀྱི་སྒྲ་དབྱངས་ཀྱི་སྒྲ་དབྱངས་ཀྱི་སྒྲ་དབྱངས་ཀྱི་སྒྲ་དབྱངས་ཤིག་རྩིས་སྤྲོད་བྱེད།# >>> parse_music.call(\"o o| .| o| o| .| .| .| .| o o\")\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\ndef parse_music(music_string)\n","canonical_solution":"def parse_music(music_string)\n  # Split the input string into individual notes.\n  notes = music_string.split\n\n  # Map each note to its corresponding number of beats.\n  notes.map do |note|\n    case note\n    when 'o'\n      4\n    when 'o|'\n      2\n    when '.|'\n      1\n    else\n      0\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_music\n    candidate = method(:parse_music)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([4, 4, 4, 4], candidate.call(\"o o o o\"))\n    assert_equal([1, 1, 1, 1], candidate.call(\".| .| .| .|\"))\n    assert_equal([2, 2, 1, 1, 4, 4, 4, 4], candidate.call(\"o| o| .| .| o o o o\"))\n    assert_equal([2, 1, 2, 1, 4, 2, 4, 2], candidate.call(\"o| .| o| .| o o| o o|\"))\n  end\nend\n"},{"task_id":"HumanEval_18","nl":"bod_Tibt","pl":"rb","prompt":"ཚད་གཞི་ཐོག་མའི་ནང་ནང་གཞི་གྲངས་ཇི་ཙམ་ཡོད་མེད་འཚོལ་བ། ཚད་གཞི་གཉིས་སུ་ཐབ་པའི་གྲངས་རྩིས་རྒྱག་པ།# >>> how_many_times.call(\"\", \"a\")\n# 0\n# >>> how_many_times.call(\"aaa\", \"a\")\n# 3\n# >>> how_many_times.call(\"aaaa\", \"aa\")\n# 3\ndef how_many_times(string, substring)\n","canonical_solution":"def how_many_times(string, substring)\n  return 0 if substring.empty?\n  count = 0\n  i = 0\n  while i <= string.length - substring.length\n    if string[i, substring.length] == substring\n      count += 1\n    end\n    i += 1\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_how_many_times\n    candidate = method(:how_many_times)\n    assert_equal(0, candidate.call(\"\", \"x\"))\n    assert_equal(4, candidate.call(\"xyxyxyx\", \"x\"))\n    assert_equal(4, candidate.call(\"cacacacac\", \"cac\"))\n    assert_equal(1, candidate.call(\"john doe\", \"john\"))\n  end\nend\n"},{"task_id":"HumanEval_19","nl":"bod_Tibt","pl":"rb","prompt":"ཆུང་ཤོས་ནས་ཆེ་བར་རིམ་སྒྲིག་བྱས་པའི་གྲངས་ཀྱི་ཐིག་ཡིག་སླར་ལོག་བྱེད།འདྲ་མིན་གྱི་གདམ་ཁ་ནི། ༠། ༡། ༢། ༣། ༤། ༥། ༦། ༧། ༨། ༩ བཅས་ཡིན།ནང་འཇུག་ནི་ས་སྟོང་གི་ཚད་མཚམས་ཡོད་པའི་གྲངས་ཀྱི་ཐིག་ལེ་ཞིག་ཡིན་ཏེ། \"ཟི་ལོ\"ནས་ \"དགུ་\"བར་ཡིན།# >>> sort_numbers.call(\"three one five\")\n# \"one three five\"\ndef sort_numbers(numbers)\n","canonical_solution":"def sort_numbers(numbers)\n  numeral_map = {\n    'zero' => 0,\n    'one' => 1,\n    'two' => 2,\n    'three' => 3,\n    'four' => 4,\n    'five' => 5,\n    'six' => 6,\n    'seven' => 7,\n    'eight' => 8,\n    'nine' => 9\n  }\n\n  number_words = numbers.split\n  sorted_numbers = number_words.sort_by { |word| numeral_map[word] }\n  sorted_numbers.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_numbers\n    candidate = method(:sort_numbers)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"three\", candidate.call(\"three\"))\n    assert_equal(\"three five nine\", candidate.call(\"three five nine\"))\n    assert_equal(\"zero four five seven eight nine\", candidate.call(\"five zero four seven nine eight\"))\n    assert_equal(\"zero one two three four five six\", candidate.call(\"six five four three two one zero\"))\n  end\nend\n"},{"task_id":"HumanEval_20","nl":"bod_Tibt","pl":"rb","prompt":"གཞན་དང་རིམ་བཞིན་ལོག་འཇུག་ (གྲངས་ཉུང་། གྲངས་མང་།)ཤོག་གྲངས་གྲངས་ (ཉུང་མཐར་གཉིས་) ཡོད་པའི་གྲངས་ཐང་ནས་ཤོག་གྲངས་རེ་རེ་ལ་ཉེ་བའི་ཤོག་གྲངས་གཉིས་འདེམས་ནས་ཕྱིར་ལོག་བྱེད་པ།# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n","canonical_solution":"def find_closest_elements(numbers)\n  sorted_numbers = numbers.sort\n  closest_pair = [sorted_numbers[0], sorted_numbers[1]]\n  min_difference = (sorted_numbers[1] - sorted_numbers[0]).abs\n\n  (1...(sorted_numbers.length - 1)).each do |i|\n    current_difference = (sorted_numbers[i + 1] - sorted_numbers[i]).abs\n    if current_difference < min_difference\n      min_difference = current_difference\n      closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]\n    end\n  end\n\n  closest_pair\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n"},{"task_id":"HumanEval_21","nl":"bod_Tibt","pl":"rb","prompt":"གྲངས་ཆུང་ཤོས་ནི་ 0 དང་གྲངས་ཆེ་བ་ནི་ 1 ཡིན་པའི་ངེས་པ་ཡོད།གྲངས་ཀྱི་རིམ་པ་ (ཉུང་མཐར་ཆ་ཤས་གཉིས་) ཞིག་ཡོད་ན། གྲལ་གཞི་དེར་ཐིག་ལེ་སྒྱུར་བཅོས་བྱེད་པ།# >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\ndef rescale_to_unit(numbers)\n","canonical_solution":"def rescale_to_unit(numbers)\n  min = numbers.min\n  max = numbers.max\n  range = max - min\n  return numbers.map { |num| (num - min) \/ range.to_f }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rescale_to_unit\n    candidate = method(:rescale_to_unit)\n    assert_equal([0.0, 1.0], candidate.call([2.0, 49.9]))\n    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))\n    assert_equal([0.0, 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))\n  end\nend\n"},{"task_id":"HumanEval_22","nl":"bod_Tibt","pl":"rb","prompt":"ཨང་གྲངས་ཧྲིལ་པོ་ལ་འཇུག་པའི་ rbthon ཚད་གཞི་གང་རུང་གི་ཨང་གྲངས་འདེམས་པའི་འདེམས་གཞི་དེ་སེལ་འཐུ་འབད།# >>> filter_integers.call([\"a\", 3.14, 5])\n# [5]\n# >>> filter_integers.call([1, 2, 3, \"abc\", {}, []])\n# [1, 2, 3]\ndef filter_integers(values)\n","canonical_solution":"def filter_integers(values)\n  values.select { |value| value.is_a?(Integer) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_integers\n    candidate = method(:filter_integers)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, \"adasd\"]))\n    assert_equal([3, 3, 3], candidate.call([3, \"c\", 3, 3, \"a\", \"b\"]))\n  end\nend\n"},{"task_id":"HumanEval_23","nl":"bod_Tibt","pl":"rb","prompt":"string གྱི་ཚད་གཞི་སླར་ལོག་བྱེད།# >>> strlen.call(\"\")\n# 0\n# >>> strlen.call(\"abc\")\n# 3\ndef strlen(string)\n","canonical_solution":"strlen = lambda do |string|\n  string.length\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strlen\n    candidate = method(:strlen)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(1, candidate.call(\"x\"))\n    assert_equal(9, candidate.call(\"asdasnakj\"))\n  end\nend\n"},{"task_id":"HumanEval_24","nl":"bod_Tibt","pl":"rb","prompt":"གྲངས་ n ཤིག་ཡོད་ན། n ལས་ཆུང་བའི་གྲངས་ཆེན་ཤོས་ n ཀྱིས་ཆ་བགོས་བྱེད་དེ་འཚོལ་དགོས།# >>> largest_divisor.call(15)\n# 5\ndef largest_divisor(n)\n","canonical_solution":"def largest_divisor(n)\n  (n - 1).downto(1) do |i|\n    return i if n % i == 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_divisor\n    candidate = method(:largest_divisor)\n    assert_equal(1, candidate.call(3))\n    assert_equal(1, candidate.call(7))\n    assert_equal(5, candidate.call(10))\n    assert_equal(50, candidate.call(100))\n    assert_equal(7, candidate.call(49))\n  end\nend\n"},{"task_id":"HumanEval_25","nl":"bod_Tibt","pl":"rb","prompt":"ནང་འཇུག་གྲངས་ནི་གཞི་གྲངས་ཚང་མའི་འབྲས་བུ་དང་མཚུངས་པར་ངེས་པ་དགོས།ཇི་འདྲ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་ཆེ་ཆུང་ནས་ཆེ་ཆུང་བར་རིམ་བཞིན་གྲངས་ཀྱི་གྲངས་གཞི་གྲངས་དང་པོ་གྲངས་ཀྱི་རིམ་པ་སླར་ལོག་བྱེད།# >>> factorize.call(8)\n# [2, 2, 2]\n# >>> factorize.call(25)\n# [5, 5]\n# >>> factorize.call(70)\n# [2, 5, 7]\ndef factorize(n)\n","canonical_solution":"def factorize(n)\n  factors = []\n  divisor = 2\n  while n > 1\n    while n % divisor == 0\n      factors << divisor\n      n \/= divisor\n    end\n    divisor += 1\n  end\n  factors\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_factorize\n    candidate = method(:factorize)\n    assert_equal([2], candidate.call(2))\n    assert_equal([2, 2], candidate.call(4))\n    assert_equal([2, 2, 2], candidate.call(8))\n    assert_equal([3, 19], candidate.call(57))\n    assert_equal([3, 3, 19, 19], candidate.call(3249))\n    assert_equal([3, 3, 3, 19, 19, 19], candidate.call(185193))\n    assert_equal([3, 19, 19, 19], candidate.call(20577))\n    assert_equal([2, 3, 3], candidate.call(18))\n  end\nend\n"},{"task_id":"HumanEval_26","nl":"bod_Tibt","pl":"rb","prompt":"ནང་འཇུག་བྱ་ཡུལ་ནང་ཡོད་པའི་རིམ་པ་འདྲ་མཚུངས་རང་འཇོག་དགོས།ཨང་གྲངས་ཧྲིལ་པོ་གི་རིམ་པ་ལས་ ཚར་གཅིག་ལས་མང་བ་བྱུང་བའི་ཆ་ཤས་ཚང་མ་ཕྱིར་འབུད་བྱེད།# >>> remove_duplicates.call([1, 2, 3, 2, 4])\n# [1, 3, 4]\ndef remove_duplicates(numbers)\n","canonical_solution":"def remove_duplicates(numbers)\n  numbers.select { |num| numbers.count(num) == 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_duplicates\n    candidate = method(:remove_duplicates)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([1, 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))\n  end\nend\n"},{"task_id":"HumanEval_27","nl":"bod_Tibt","pl":"rb","prompt":"ཚད་ལྡན་ཡིག་འབྲུ་ཚུའི་ནང་ཡིག་ཆུང་ཡིག་ཆུང་དང་ཡིག་ཆུང་ཡིག་ཆུང་ལ་བསྒྱུར་དགོས།# >>> flip_case.call(\"Hello\")\n# \"hELLO\"\ndef flip_case(string)\n","canonical_solution":"def flip_case(string)\n  string.swapcase\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_flip_case\n    candidate = method(:flip_case)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"hELLO!\", candidate.call(\"Hello!\"))\n    assert_equal(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\", candidate.call(\"These violent delights have violent ends\"))\n  end\nend\n"},{"task_id":"HumanEval_28","nl":"bod_Tibt","pl":"rb","prompt":"string ཀྱི་རིམ་པ་གཅིག་ཏུ་བསྡོམས་པ།# >>> concatenate.call([])\n# \"\"\n# >>> concatenate.call([\"a\", \"b\", \"c\"])\n# \"abc\"\ndef concatenate(strings)\n","canonical_solution":"def concatenate(strings)\n  strings.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_concatenate\n    candidate = method(:concatenate)\n    assert_equal(\"\", candidate.call([]))\n    assert_equal(\"xyz\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"xyzwk\", candidate.call([\"x\", \"y\", \"z\", \"w\", \"k\"]))\n  end\nend\n"},{"task_id":"HumanEval_29","nl":"bod_Tibt","pl":"rb","prompt":"ནང་འཇུག་ཐིག་གི་རིམ་པ་གཅིག་པུ་ནང་ prefix དང་འགོ་འཛུགས་ཀྱི་རིམ་པ་འདེམས་དགོས།# >>> filter_by_prefix.call([], \"a\")\n# []\n# >>> filter_by_prefix.call([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"array\"]\ndef filter_by_prefix(strings, prefix)\n","canonical_solution":"def filter_by_prefix(strings, prefix)\n  strings.select { |string| string.start_with?(prefix) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_prefix\n    candidate = method(:filter_by_prefix)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n  end\nend\n"},{"task_id":"HumanEval_30","nl":"bod_Tibt","pl":"rb","prompt":"གྲལ་ཐིག་ནང་གྲངས་ཆ་མཐུན་པ་ཁོ་ན་ཕྱིར་ལོག་བྱེད་པ།# >>> get_positive.call([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\ndef get_positive(l)\n","canonical_solution":"get_positive = lambda do |l|\n  l.select { |num| num > 0 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_positive\n    candidate = method(:get_positive)\n    assert_equal([4, 5, 6], candidate.call([-1, -2, 4, 5, 6]))\n    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([], candidate.call([-1, -2]))\n    assert_equal([], candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_31","nl":"bod_Tibt","pl":"rb","prompt":"གྲངས་ཤིག་སྔོན་གྲངས་ཡིན་ན་ true སླར་ལོག་བྱེད། དེ་མིན་ན་ false སླར་ལོག་བྱེད།# >>> is_prime.call(6)\n# false\n# >>> is_prime.call(101)\n# true\n# >>> is_prime.call(11)\n# true\n# >>> is_prime.call(13441)\n# true\n# >>> is_prime.call(61)\n# true\n# >>> is_prime.call(4)\n# false\n# >>> is_prime.call(1)\n# false\ndef is_prime(n)\n","canonical_solution":"is_prime = lambda do |n|\n  return false if n <= 1\n  return true if n == 2\n  return false if n.even?\n\n  max_divisor = Math.sqrt(n).to_i\n  (3..max_divisor).step(2).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_prime\n    candidate = method(:is_prime)\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(101))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(13441))\n    assert_equal(true, candidate.call(61))\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(1))\n    assert_equal(true, candidate.call(5))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(17))\n    assert_equal(false, candidate.call(85))\n    assert_equal(false, candidate.call(77))\n    assert_equal(false, candidate.call(255379))\n  end\nend\n"},{"task_id":"HumanEval_33","nl":"bod_Tibt","pl":"rb","prompt":"ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པ་རེད་ཀྱང་། ཚད་གཞི་སོ་སོར་དབྱེ་བ་བྱས་ཡོད།l' ནི་ 3 ལ་བགོས་མི་ཐུབ་པའི་རྟགས་གྲངས་ནང་ l དང་མཚུངས་པ་དང་། དེའི་ཐང་ནི་ 3 ལ་བགོས་ཐུབ་པའི་རྟགས་གྲངས་ནང་འདྲ་མཉམ་ཡིན།ལས་འགན་འདི་གིས་ array l དང་ array l' འདི་ལྟ་བུ་ཕྱིར་ལོག་བྱེད་དེ།# >>> sort_third.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])\n# [2, 6, 3, 4, 8, 9, 5]\ndef sort_third(l)\n","canonical_solution":"def sort_third(l)\n  divisible_by_three = l.each_with_index.select { |_, idx| idx % 3 == 0 }.map(&:first).sort\n  l.each_with_index.map { |val, idx| idx % 3 == 0 ? divisible_by_three.shift : val }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_third\n    candidate = method(:sort_third)\n    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5, 6, 3, 4, 8, 9, 2]))\n    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5, 8, 3, 4, 6, 9, 2]))\n    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5, 6, 9, 4, 8, 3, 2]))\n    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5, 6, 3, 4, 8, 9, 2, 1]))\n  end\nend\n"},{"task_id":"HumanEval_34","nl":"bod_Tibt","pl":"rb","prompt":"གྲལ་ཐིག་ནང་དབྱེ་བ་ཕྱེ་བའི་ཆ་ཤས་རྐྱང་པ་སླར་ལོག་བྱེད།# >>> unique.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\ndef unique(l)\n","canonical_solution":"def unique(l)\n  l.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique\n    candidate = method(:unique)\n    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5, 3, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_35","nl":"bod_Tibt","pl":"rb","prompt":"གྲལ་ཐིག་ནང་གི་ཆ་ཤས་ཆེ་ཆུང་ཕྱིར་ལོག་བྱེད།# >>> max_element.call([1, 2, 3])\n# 3\n# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\ndef max_element(l)\n","canonical_solution":"def max_element(l)\n  l.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_element\n    candidate = method(:max_element)\n    assert_equal(3, candidate.call([1, 2, 3]))\n    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]))\n  end\nend\n"},{"task_id":"HumanEval_36","nl":"bod_Tibt","pl":"rb","prompt":"གྲངས་ 7 ནི་ 11 དང་ 13 ཀྱིས་ཆ་བགོས་ཐུབ་པའི་ n ལས་ཆུང་བའི་ཧྲིལ་གྲངས་ནང་ཐེངས་གྲངས་ཕྱིར་ལོག་བྱེད་པ།# >>> fizz_buzz.call(50)\n# 0\n# >>> fizz_buzz.call(78)\n# 2\n# >>> fizz_buzz.call(79)\n# 3\ndef fizz_buzz(n)\n","canonical_solution":"def fizz_buzz(n)\n  count = 0\n  (1...n).each do |i|\n    if i % 11 == 0 || i % 13 == 0\n      count += i.to_s.count('7')\n    end\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fizz_buzz\n    candidate = method(:fizz_buzz)\n    assert_equal(0, candidate.call(50))\n    assert_equal(2, candidate.call(78))\n    assert_equal(3, candidate.call(79))\n    assert_equal(3, candidate.call(100))\n    assert_equal(6, candidate.call(200))\n    assert_equal(192, candidate.call(4000))\n    assert_equal(639, candidate.call(10000))\n    assert_equal(8026, candidate.call(100000))\n  end\nend\n"},{"task_id":"HumanEval_37","nl":"bod_Tibt","pl":"rb","prompt":"ཚད་གཞི་དང་མཚུངས་པའི་གྲངས་ཀ་ཡིན་ཀྱང་། ཚད་གཞི་དང་མཚུངས་པའི་གྲངས་ཀ་ཡིན་ཀྱང་།l' འདི་ l དང་མཚུངས་པ་ཉེར་མཁོ་ཅན་གྱི་གནས་ཚད་ནང་ཡིན་པའི་སྐབས་དང་ དེའི་གནས་ཚད་དེ་ཉེར་མཁོ་ཅན་གྱི་གནས་ཚད་ནང་འདྲ་མཉམ་ཡིན།ལས་འགན་འདི་གིས་ array l དང་ array l' འདི་ལྟ་བུ་ཕྱིར་ལོག་བྱེད་དེ།# >>> sort_even.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_even.call([5, 6, 3, 4])\n# [3, 6, 5, 4]\ndef sort_even(l)\n","canonical_solution":"def sort_even(l)\n  even_indices = l.each_index.select { |i| i.even? }\n  even_values = even_indices.map { |i| l[i] }.sort\n  \n  even_index = 0\n  l.each_with_index.map do |value, index|\n    if index.even?\n      even_values[even_index].tap { even_index += 1 }\n    else\n      value\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_even\n    candidate = method(:sort_even)\n    assert_equal([1, 2, 3], candidate.call([1, 2, 3]))\n    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n  end\nend\n"},{"task_id":"HumanEval_39","nl":"bod_Tibt","pl":"rb","prompt":"prime_fib དེ་ནི་ཨང་གྲངས་ n-th དེ་ནི་ཕི་བྷོ་ན་ཅིའི་གྲངས་ཀ་ཞིག་ཡིན་པ་དང་དེ་ཡང་ཨང་གྲངས་ prime ཡིན་པ་ཕྱིར་སློག་བྱེད་པ་ཡིན།# >>> prime_fib.call(1)\n# 2\n# >>> prime_fib.call(2)\n# 3\n# >>> prime_fib.call(3)\n# 5\n# >>> prime_fib.call(4)\n# 13\n# >>> prime_fib.call(5)\n# 89\ndef prime_fib(n)\n","canonical_solution":"def prime_fib(n)\n  require 'prime'\n  \n  fibs = Enumerator.new do |y|\n    a, b = 0, 1\n    loop do\n      a, b = b, a + b\n      y << b\n    end\n  end\n  \n  prime_fibs = fibs.lazy.select { |fib| Prime.prime?(fib) }\n  prime_fibs.first(n).last\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_fib\n    candidate = method(:prime_fib)\n    assert_equal(2, candidate.call(1))\n    assert_equal(3, candidate.call(2))\n    assert_equal(5, candidate.call(3))\n    assert_equal(13, candidate.call(4))\n    assert_equal(89, candidate.call(5))\n    assert_equal(233, candidate.call(6))\n    assert_equal(1597, candidate.call(7))\n    assert_equal(28657, candidate.call(8))\n    assert_equal(514229, candidate.call(9))\n    assert_equal(433494437, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_40","nl":"bod_Tibt","pl":"rb","prompt":"སྟོང་པ་ཉིད་དུ་བསྡོམས་ནས་གཞན་དུ་རྫུས་མ་ཡིན།གལ་ཏེ་ array ནང་ཁྱད་པར་ཅན་གྱི་ཆ་ཤས་གསུམ་ཡོད་ན་ true སླར་ལོག་བྱེད།triple_sum_to_zero ནང་འཇུག་ལྟར་ཨང་གྲངས་ཧྲིལ་པོ་གྲངས་ལྡན་ཞིག་ལེན་ཡོད།# >>> triples_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> triples_sum_to_zero.call([1, 3, -2, 1])\n# true\n# >>> triples_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])\n# true\n# >>> triples_sum_to_zero.call([1])\n# false\ndef triples_sum_to_zero(l)\n","canonical_solution":"def triples_sum_to_zero(l)\n  n = l.length\n  (0...n-2).each do |i|\n    ((i+1)...n-1).each do |j|\n      ((j+1)...n).each do |k|\n        return true if l[i] + l[j] + l[k] == 0\n      end\n    end\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false, candidate.call([100, 3, 5, -100]))\n  end\nend\n"},{"task_id":"HumanEval_41","nl":"bod_Tibt","pl":"rb","prompt":"ལས་འགན་འདི་ནས་གློག་རྡུལ་འདི་འདྲ་མང་པོ་བྱུང་བའི་གྲངས་ཐོར་ཐིག་བཏོན་ཡོད།འདྲ་བ་དེ་དག་གིས་མ་བརྡུང་བར་རང་རང་གི་ལམ་དུ་འགྲོ་བ་རེད།ཡིན་ན་ཡང་ཤིང་རྟ་ཚོ་ཧ་ཅང་བརྟན་པོ་དང་ཤུགས་ཆེན་པོ་ཡོད་སྟབས་དུས་རྒྱུན་དུ་འགྲོ་གི་འདུགཕྱོགས་གང་ནས་འགྲོ་བའི་ཤིང་རྟ་ཞིག་གཡས་གཡོན་ནས་འགྲོ་བའི་ཤིང་རྟ་ཞིག་དང་ཐུག་སྐབས།སྣུམ་འཁོར་ཚང་མ་མྱུར་ཚད་གཅིག་མཚུངས་ལ་འགྲོ་གི་ཡོད། སྣུམ་འཁོར་གཉིས་བརྡབ་སྐྱོན་བྱུང་ཞེས་བརྗོད་ཀྱི་ཡོད།ཕྱོགས་གཡས་གཡོན་ལ་འགྲོ་གི་འདུག སྣུམ་འཁོར་གཉིས་ཀ་འདི་ནས་ཧ་ཅང་ཐག་རིང་ནས་འགྲོ་གི་འདུགཕྱོགས་གཅིག་ཏུ་ n པོ་འཁོར་ལམ་གྱི་ཁ་ཕྱོགས་ནས་གཡོན་ཕྱོགས་སུ་འགྲོ་གི་ཡོད་པ་དང་། ཕྱོགས་གཅིག་ཏུ་ n པོ་འཁོར་ལམ་གྱི་ཁ་ཕྱོགས་ནས་ཁ་ཕྱོགས་ལ་འགྲོ་གི་ཡོད།ཚད་མེད་རིང་བའི་ཕྲེང་བ་དྲང་པོ་ཞིག་ཡིན་པ་བསམ་བློ་བཏང་ཞིགdef car_race_collision(n)\n","canonical_solution":"def car_race_collision(n)\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_car_race_collision\n    candidate = method(:car_race_collision)\n    assert_equal(4, candidate.call(2))\n    assert_equal(9, candidate.call(3))\n    assert_equal(16, candidate.call(4))\n    assert_equal(64, candidate.call(8))\n    assert_equal(100, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_42","nl":"bod_Tibt","pl":"rb","prompt":"ཚད་གཞི་ 1 ཀྱིས་ཡར་སེང་བྱས་པའི་ཆ་ཤས་ཡོད་པའི་རིམ་པ་ཕྱིར་ལོག་བྱེད།# >>> incr_list.call([1, 2, 3])\n# [2, 3, 4]\n# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6, 4, 6, 3, 4, 4, 10, 1, 124]\ndef incr_list(l)\n","canonical_solution":"def incr_list(l)\n  l.map { |x| x + 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_incr_list\n    candidate = method(:incr_list)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))\n    assert_equal([6, 3, 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_43","nl":"bod_Tibt","pl":"rb","prompt":"སྟོང་པ་ཉིད་དུ་བསྡོམས་ནས་གཞན་དུ་རྫུས་མ་ཡིན།གལ་ཏེ་ array ནང་ཁྱད་པར་ཅན་གྱི་ཆ་ཤས་གཉིས་ཡོད་ན་ true སླར་ལོག་བྱེད།pairs_sum_to_zero ནང་འཇུག་ལྟར་ཨང་གྲངས་ཧྲིལ་པོ་གྲངས་ལྡན་ཞིག་ལེན་པ།# >>> pairs_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> pairs_sum_to_zero.call([1, 3, -2, 1])\n# false\n# >>> pairs_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\n# true\n# >>> pairs_sum_to_zero.call([1])\n# false\ndef pairs_sum_to_zero(l)\n","canonical_solution":"def pairs_sum_to_zero(l)\n  num_set = l.to_set\n  l.each do |num|\n    return true if num != 0 && num_set.include?(-num)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"},{"task_id":"HumanEval_44","nl":"bod_Tibt","pl":"rb","prompt":"གཞི་གྲངས་ནི་ ༡༠ ལས་ཉུང་བ་རེད།ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ནང་འཇུག་གྲངས་ x གི་གྲངས་གཞི་གཞི་བསྒྱུར་བ།# >>> change_base.call(8, 3)\n# \"22\"\n# >>> change_base.call(8, 2)\n# \"1000\"\n# >>> change_base.call(7, 2)\n# \"111\"\ndef change_base(x, base)\n","canonical_solution":"def change_base(x, base)\n  return '0' if x == 0\n  digits = []\n  while x > 0\n    digits << (x % base).to_s\n    x \/= base\n  end\n  digits.reverse.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_change_base\n    candidate = method(:change_base)\n    assert_equal(\"22\", candidate.call(8, 3))\n    assert_equal(\"100\", candidate.call(9, 3))\n    assert_equal(\"11101010\", candidate.call(234, 2))\n    assert_equal(\"10000\", candidate.call(16, 2))\n    assert_equal(\"1000\", candidate.call(8, 2))\n    assert_equal(\"111\", candidate.call(7, 2))\n    assert_equal(\"2\", candidate.call(2, 3))\n    assert_equal(\"3\", candidate.call(3, 4))\n    assert_equal(\"4\", candidate.call(4, 5))\n    assert_equal(\"5\", candidate.call(5, 6))\n    assert_equal(\"6\", candidate.call(6, 7))\n    assert_equal(\"7\", candidate.call(7, 8))\n  end\nend\n"},{"task_id":"HumanEval_45","nl":"bod_Tibt","pl":"rb","prompt":"ཟུར་གསུམ་གྱི་རིང་ཚད་དང་མཐོ་ཚད་ཀྱི་ལོག་ཕྱོགས་ཀྱི་ས་ཆ་# >>> triangle_area.call(5, 3)\n# 7.5\ndef triangle_area(a, h)\n","canonical_solution":"def triangle_area(a, h)\n  (a * h) \/ 2.0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(7.5, candidate.call(5, 3))\n    assert_equal(2.0, candidate.call(2, 2))\n    assert_equal(40.0, candidate.call(10, 8))\n  end\nend\n"},{"task_id":"HumanEval_46","nl":"bod_Tibt","pl":"rb","prompt":"fib4གྲངས་རིམ་གྱི་ n-th ཆ་ཤས་ངེས་གཏན་ཆེད་ལས་འགན་ཞིག་བྲིས་རོགས་གནང་། སླར་ལོག་མི་འཇུག་རོགས་གནང་།མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད།fib4(3) -> 0 fib4 (((2) -> 2 fib4(1) -> 0 fib4 ((0)) -> 0 Fib4 ནི་ Fibbonacci གི་རིམ་པ་དང་འདྲ་བའི་རིམ་པ་ཞིག་ཡིན་ཏེ། དེའི་འགྲེལ་བཤད་ནི་གཤམ་གསལ་ལྟར་ཡིན།# >>> fib4.call(5)\n# 4\n# >>> fib4.call(6)\n# 8\n# >>> fib4.call(7)\n# 14\ndef fib4(n)\n","canonical_solution":"def fib4(n)\n  return 0 if n == 0 || n == 1 || n == 3\n  return 2 if n == 2\n\n  fib4_seq = [0, 0, 2, 0]\n  (4..n).each do |i|\n    fib4_seq[i] = fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]\n  end\n  fib4_seq[n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib4\n    candidate = method(:fib4)\n    assert_equal(4, candidate.call(5))\n    assert_equal(28, candidate.call(8))\n    assert_equal(104, candidate.call(10))\n    assert_equal(386, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_47","nl":"bod_Tibt","pl":"rb","prompt":"ཚད་གཞི་ནང་ཡོད་པའི་ཆ་ཤས་ཀྱི་བར་མཚམས་སླར་ལོག་འབད། l# >>> median.call([3, 1, 2, 4, 5])\n# 3\n# >>> median.call([-10, 4, 6, 1000, 10, 20])\n# 15.0\ndef median(l)\n","canonical_solution":"def median(l)\n  sorted = l.sort\n  len = sorted.length\n  if len.odd?\n    sorted[len \/ 2]\n  else\n    (sorted[len \/ 2 - 1] + sorted[len \/ 2]) \/ 2.0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_median\n    candidate = method(:median)\n    assert_equal(3, candidate.call([3, 1, 2, 4, 5]))\n    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))\n    assert_equal(5, candidate.call([5]))\n    assert_equal(5.5, candidate.call([6, 5]))\n    assert_equal(7, candidate.call([8, 1, 3, 9, 9, 2, 7]))\n  end\nend\n"},{"task_id":"HumanEval_48","nl":"bod_Tibt","pl":"rb","prompt":"string དེ་ palindrome ཡིན་མིན་ལ་བརྟག་དཔྱད་བྱེད།# >>> is_palindrome.call(\"\")\n# true\n# >>> is_palindrome.call(\"aba\")\n# true\n# >>> is_palindrome.call(\"aaaaa\")\n# true\n# >>> is_palindrome.call(\"zbcd\")\n# false\ndef is_palindrome(text)\n","canonical_solution":"is_palindrome = lambda do |text|\n  text == text.reverse\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_palindrome\n    candidate = method(:is_palindrome)\n    assert_equal(true, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"aba\"))\n    assert_equal(true, candidate.call(\"aaaaa\"))\n    assert_equal(false, candidate.call(\"zbcd\"))\n    assert_equal(true, candidate.call(\"xywyx\"))\n    assert_equal(false, candidate.call(\"xywyz\"))\n    assert_equal(false, candidate.call(\"xywzx\"))\n  end\nend\n"},{"task_id":"HumanEval_49","nl":"bod_Tibt","pl":"rb","prompt":"ཕྱིར་ལོག་ 2^n modulo p (གྲངས་ཀ་ལ་དོ་སྣང་བྱ་དགོས།)# >>> modp.call(3, 5)\n# 3\n# >>> modp.call(1101, 101)\n# 2\n# >>> modp.call(0, 101)\n# 1\n# >>> modp.call(3, 11)\n# 8\n# >>> modp.call(100, 101)\n# 1\ndef modp(n, p)\n","canonical_solution":"def modp(n, p)\n  return 1 if p == 1\n  2.pow(n, p)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"},{"task_id":"HumanEval_51","nl":"bod_Tibt","pl":"rb","prompt":"remove_vowels ནི་ལས་འགན་ཞིག་ཡིན་པས་ string དང་ vowels མེད་པའི་ string སླར་ལོག་བྱེད།# >>> remove_vowels.call(\"\")\n# \"\"\n# >>> remove_vowels.call(\"abcdef\")\n# \"bcdf\"\n# >>> remove_vowels.call(\"aaaaa\")\n# \"\"\n# >>> remove_vowels.call(\"aaBAA\")\n# \"B\"\n# >>> remove_vowels.call(\"zbcd\")\n# \"zbcd\"\ndef remove_vowels(text)\n","canonical_solution":"def remove_vowels(text)\n  text.delete('aeiouAEIOU')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_vowels\n    candidate = method(:remove_vowels)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"bcdf\nghjklm\", candidate.call(\"abcdef\nghijklm\"))\n    assert_equal(\"fdcb\", candidate.call(\"fedcba\"))\n    assert_equal(\"\", candidate.call(\"eeeee\"))\n    assert_equal(\"cB\", candidate.call(\"acBAA\"))\n    assert_equal(\"cB\", candidate.call(\"EcBOO\"))\n    assert_equal(\"ybcd\", candidate.call(\"ybcd\"))\n  end\nend\n"},{"task_id":"HumanEval_52","nl":"bod_Tibt","pl":"rb","prompt":"གྲངས་ཐང་ l ནང་གི་གྲངས་ཐང་ཚང་མ་ཚད་མཐའི་ཚད་ t ལས་དམའ་བ་ཡིན་ན་ true སླར་ལོག་བྱེད།# >>> below_threshold.call([1, 2, 4, 10], 100)\n# true\n# >>> below_threshold.call([1, 20, 4, 10], 5)\n# false\ndef below_threshold(l, t)\n","canonical_solution":"def below_threshold(l, t)\n  l.all? { |num| num < t }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_threshold\n    candidate = method(:below_threshold)\n    assert_equal(true, candidate.call([1, 2, 4, 10], 100))\n    assert_equal(false, candidate.call([1, 20, 4, 10], 5))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 21))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 22))\n    assert_equal(true, candidate.call([1, 8, 4, 10], 11))\n    assert_equal(false, candidate.call([1, 8, 4, 10], 10))\n  end\nend\n"},{"task_id":"HumanEval_53","nl":"bod_Tibt","pl":"rb","prompt":"གྲངས་གཉིས་ x དང་ y བསྡུས་པ།# >>> add.call(2, 3)\n# 5\n# >>> add.call(5, 7)\n# 12\ndef add(x, y)\n","canonical_solution":"add = ->(x, y) { x + y }","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(1, candidate.call(0, 1))\n    assert_equal(1, candidate.call(1, 0))\n    assert_equal(5, candidate.call(2, 3))\n    assert_equal(12, candidate.call(5, 7))\n    assert_equal(12, candidate.call(7, 5))\n  end\nend\n"},{"task_id":"HumanEval_54","nl":"bod_Tibt","pl":"rb","prompt":"ཚིག་གཉིས་ནང་ཡིག་འབྲུ་འདྲ་མཚུངས་ཡོད་མེད་བརྟག་དཔྱད་བྱེད་དགོས།# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n# true\n# >>> same_chars.call(\"abcd\", \"dddddddabc\")\n# true\n# >>> same_chars.call(\"dddddddabc\", \"abcd\")\n# true\n# >>> same_chars.call(\"eabcd\", \"dddddddabc\")\n# false\n# >>> same_chars.call(\"abcd\", \"dddddddabce\")\n# false\n# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n# false\ndef same_chars(s0, s1)\n","canonical_solution":"def same_chars(s0, s1)\n  s0.chars.uniq.all? { |char| s1.include?(char) } &&\n  s1.chars.uniq.all? { |char| s0.include?(char) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_same_chars\n    candidate = method(:same_chars)\n    assert_equal(true, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"))\n    assert_equal(true, candidate.call(\"abcd\", \"dddddddabc\"))\n    assert_equal(true, candidate.call(\"dddddddabc\", \"abcd\"))\n    assert_equal(false, candidate.call(\"eabcd\", \"dddddddabc\"))\n    assert_equal(false, candidate.call(\"abcd\", \"dddddddabcf\"))\n    assert_equal(false, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n    assert_equal(false, candidate.call(\"aabb\", \"aaccc\"))\n  end\nend\n"},{"task_id":"HumanEval_55","nl":"bod_Tibt","pl":"rb","prompt":"ཕི་བོ་ན་ཅིའི་གྲངས་ n སླར་ལོག་བྱ་དགོས།# >>> fib.call(10)\n# 55\n# >>> fib.call(1)\n# 1\n# >>> fib.call(8)\n# 21\ndef fib(n)\n","canonical_solution":"def fib(n)\n  return n if n <= 1\n  fib(n - 1) + fib(n - 2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib\n    candidate = method(:fib)\n    assert_equal(55, candidate.call(10))\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(8))\n    assert_equal(89, candidate.call(11))\n    assert_equal(144, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_56","nl":"bod_Tibt","pl":"rb","prompt":"return true གལ་ཏེ་ཁ་ཕྱེས་པའི་ bracket ནང་འཇུག་པའི་ bracket ཞིག་ཡོད་ན་ true སླར་ལོག་བྱེད།brackets ནི་ \"<\" དང་ \">\" ཀྱི་ཡིག་འབྲུ་ཡིན།# >>> correct_bracketing.call(\"<\")\n# false\n# >>> correct_bracketing.call(\"<>\")\n# true\n# >>> correct_bracketing.call(\"<<><>>\")\n# true\n# >>> correct_bracketing.call(\"><<>\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.chars.each do |char|\n    if char == '<'\n      balance += 1\n    elsif char == '>'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"<>\"))\n    assert_equal(true, candidate.call(\"<<><>>\"))\n    assert_equal(true, candidate.call(\"<><><<><>><>\"))\n    assert_equal(true, candidate.call(\"<><><<<><><>><>><<><><<>>>\"))\n    assert_equal(false, candidate.call(\"<<<><>>>>\"))\n    assert_equal(false, candidate.call(\"><<>\"))\n    assert_equal(false, candidate.call(\"<\"))\n    assert_equal(false, candidate.call(\"<<<<\"))\n    assert_equal(false, candidate.call(\">\"))\n    assert_equal(false, candidate.call(\"<<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>><<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>>><>\"))\n  end\nend\n"},{"task_id":"HumanEval_57","nl":"bod_Tibt","pl":"rb","prompt":"Return true ནི་གཞི་རིམ་གྱི་ཆ་ཤས་རྣམས་གཅིག་མཚུངས་དུ་ཡར་འཕར་བའམ་མར་ཕབ་བྱེད་སྟངས།# >>> monotonic.call([1, 2, 4, 20])\n# true\n# >>> monotonic.call([1, 20, 4, 10])\n# false\n# >>> monotonic.call([4, 1, 0, -10])\n# true\ndef monotonic(l)\n","canonical_solution":"def monotonic(l)\n  increasing = true\n  decreasing = true\n\n  (0...l.length - 1).each do |i|\n    if l[i] < l[i + 1]\n      decreasing = false\n    elsif l[i] > l[i + 1]\n      increasing = false\n    end\n  end\n\n  increasing || decreasing\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2, 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false, candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1, 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false, candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\nend\n"},{"task_id":"HumanEval_58","nl":"bod_Tibt","pl":"rb","prompt":"གྲལ་ཐིག་གཉིས་སུ་དབྱེ་བ་བཏང་བའི་རང་བཞིན། དངོས་པོ་ལོག་འཇུག་བྱེད།# >>> common.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common.call([5, 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2)\n","canonical_solution":"def common(l1, l2)\n  (l1 & l2).uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5, 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3, 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"},{"task_id":"HumanEval_59","nl":"bod_Tibt","pl":"rb","prompt":"n གི་གྲངས་ཐང་ཆེ་ཤོས་ཕྱིར་ལོག་བྱེད་པ། n > 1 དང་གྲངས་ཐང་ཆེ་མིན་པའི་ངེས་ཚིག་ཡིན།# >>> largest_prime_factor.call(13195)\n# 29\n# >>> largest_prime_factor.call(2048)\n# 2\ndef largest_prime_factor(n)\n","canonical_solution":"def largest_prime_factor(n)\n  factor = 2\n  while factor * factor <= n\n    if n % factor == 0\n      n \/= factor\n    else\n      factor += 1\n    end\n  end\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n  end\nend\n"},{"task_id":"HumanEval_60","nl":"bod_Tibt","pl":"rb","prompt":"sum_to_n ནི་ 1 ནས་ n བར་གྱི་གྲངས་གྲངས་བསྡོམས་པའི་ལས་འགན་ཡིན།# >>> sum_to_n.call(30)\n# 465\n# >>> sum_to_n.call(100)\n# 5050\n# >>> sum_to_n.call(5)\n# 15\n# >>> sum_to_n.call(10)\n# 55\n# >>> sum_to_n.call(1)\n# 1\ndef sum_to_n(n)\n","canonical_solution":"def sum_to_n(n)\n  (1..n).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_to_n\n    candidate = method(:sum_to_n)\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(6))\n    assert_equal(66, candidate.call(11))\n    assert_equal(465, candidate.call(30))\n    assert_equal(5050, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_61","nl":"bod_Tibt","pl":"rb","prompt":"return true གལ་ཏེ་ཁ་ཕྱེས་པའི་ bracket ནང་འཇུག་པའི་ bracket ཞིག་ཡོད་ན་ true སླར་ལོག་བྱེད།brackets ནི་ \"(\" དང་ \"\") ཀྱི་ཡིག་འབྲུ་ཡིན།# >>> correct_bracketing.call(\"(\")\n# false\n# >>> correct_bracketing.call(\"()\")\n# true\n# >>> correct_bracketing.call(\"(()())\")\n# true\n# >>> correct_bracketing.call(\")(()\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.each_char do |char|\n    if char == '('\n      balance += 1\n    elsif char == ')'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"()\"))\n    assert_equal(true, candidate.call(\"(()())\"))\n    assert_equal(true, candidate.call(\"()()(()())()\"))\n    assert_equal(true, candidate.call(\"()()((()()())())(()()(()))\"))\n    assert_equal(false, candidate.call(\"((()())))\"))\n    assert_equal(false, candidate.call(\")(()\"))\n    assert_equal(false, candidate.call(\"(\"))\n    assert_equal(false, candidate.call(\"((((\"))\n    assert_equal(false, candidate.call(\")\"))\n    assert_equal(false, candidate.call(\"(()\"))\n    assert_equal(false, candidate.call(\"()()(()())())(()\"))\n    assert_equal(false, candidate.call(\"()()(()())()))()\"))\n  end\nend\n"},{"task_id":"HumanEval_62","nl":"bod_Tibt","pl":"rb","prompt":"འདྲ་བའི་རྣམ་གྲངས་ཀྱི་ཟུར་གྲངས་ཕྱིར་ལོག་བྱེད་པ།xs[0] + xs[1] * x + xs[2] * x^2 + .... xs ནི་མང་ཚུའི་མཚོན་རྟགས་ཡིན་ཏེ།# >>> derivative.call([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative.call([1, 2, 3])\n# [2, 6]\ndef derivative(xs)\n","canonical_solution":"def derivative(xs)\n  return [] if xs.length < 2\n  xs.each_with_index.map { |coef, index| coef * index }[1..-1]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_derivative\n    candidate = method(:derivative)\n    assert_equal([1, 4, 12, 20], candidate.call([3, 1, 2, 4, 5]))\n    assert_equal([2, 6], candidate.call([1, 2, 3]))\n    assert_equal([2, 2], candidate.call([3, 2, 1]))\n    assert_equal([2, 2, 0, 16], candidate.call([3, 2, 1, 0, 4]))\n    assert_equal([], candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_63","nl":"bod_Tibt","pl":"rb","prompt":"ཤོག་གྲངས་རིམ་པའི་ n-th ནང་གི་ཆ་ཤས་ལེགས་པར་རྩིས་ཐུབ་པའི་ལས་འགན་ཞིག་བྲིས་རོགས།fib fib (n) == fib (n-1) + fib (n-2) + fib (n-3)མཆིན་པ་གཉིས།སྦྲེལ་རྟགས་:fib fib    FibFib ཨང་རིམ་ནི་ Fibbonacci sequence དང་འདྲ་བའི་རིམ་པ་ཞིག་ཡིན་ཏེ། དེའི་འགྲེལ་བཤད་ནི་གཤམ་གསལ་ལྟར་ཡིན།# >>> fibfib.call(1)\n# 0\n# >>> fibfib.call(5)\n# 4\n# >>> fibfib.call(8)\n# 24\ndef fibfib(n)\n","canonical_solution":"def fibfib(n)\n  return 0 if n == 0 || n == 1\n  return 1 if n == 2\n\n  a, b, c = 0, 0, 1\n  (3..n).each do\n    a, b, c = b, c, a + b + c\n  end\n  c\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fibfib\n    candidate = method(:fibfib)\n    assert_equal(1, candidate.call(2))\n    assert_equal(0, candidate.call(1))\n    assert_equal(4, candidate.call(5))\n    assert_equal(24, candidate.call(8))\n    assert_equal(81, candidate.call(10))\n    assert_equal(274, candidate.call(12))\n    assert_equal(927, candidate.call(14))\n  end\nend\n"},{"task_id":"HumanEval_64","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། vowel ཟེར་བ་འདི། འོན་ཀྱང་ཚིག་གི་མཐའ་མ་ལ་ཡོད་ན་ཁོ་ན་ཡིན།འདིར་སྒྲ་དབྱངས་ཀྱི་རྣམ་པ་ནི་ \"a\", \"e\", \"i\", \"o\", \"u\" རྣམས་ཡིན། འདིར་ \"y\" ཀྱང་ a ཡིན་ཚིག་ཡིག་འདི་ནི་ནང་འཇུག་བྱེད་སྟངས་དང་ string ནང་གི་སྒྲ་སྒྲ་གྲངས་ཕྱིར་ལོག་བྱེད་སྟངས་ཡིན།ཤོག་གྲངས་ཀྱི་རྣམ་གྲངས་ལ་མཚོན་པའི་ཡིག་འབྲུ་ཞིག་བྲིས་ན།# >>> vowels_count.call(\"abcde\")\n# 2\n# >>> vowels_count.call(\"ACEDY\")\n# 3\ndef vowels_count(s)\n","canonical_solution":"def vowels_count(s)\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  count = 0\n  \n  s.chars.each_with_index do |char, index|\n    if vowels.include?(char.downcase)\n      count += 1\n    elsif char.downcase == 'y' && index == s.length - 1\n      count += 1\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_vowels_count\n    candidate = method(:vowels_count)\n    assert_equal(2, candidate.call(\"abcde\"))\n    assert_equal(3, candidate.call(\"Alone\"))\n    assert_equal(2, candidate.call(\"key\"))\n    assert_equal(1, candidate.call(\"bye\"))\n    assert_equal(2, candidate.call(\"keY\"))\n    assert_equal(1, candidate.call(\"bYe\"))\n    assert_equal(3, candidate.call(\"ACEDY\"))\n  end\nend\n"},{"task_id":"HumanEval_65","nl":"bod_Tibt","pl":"rb","prompt":"shift > digits ཟེར་བ་ཡོད་ན་ return digits བསྒྱུར་ནས་ཨང་གྲངས་འདེམས་དགོས།འབྲས་བུ་ནི་ string སྦེ་སླར་ལོག་འབདཝ་ཨིན།འབོར་གྲངས་ x གི་ཨང་གྲངས་རྣམས་འཁོར་ལམ་དུ་སྤོ་བཤུད་བྱེད་པ། ཨང་གྲངས་རྣམས་གཡས་སུ་སྤོ་བཤུད་བྱེད་པ།# >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12, 2)\n# \"12\"\ndef circular_shift(x, shift)\n","canonical_solution":"def circular_shift(x, shift)\n  digits = x.to_s.chars\n  num_digits = digits.length\n\n  if shift > num_digits\n    return digits.reverse.join\n  else\n    shift = shift % num_digits\n    shifted_digits = digits.rotate(-shift)\n    return shifted_digits.join\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100, 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\", candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"11\", candidate.call(11, 101))\n  end\nend\n"},{"task_id":"HumanEval_66","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཨཱ་སི་ཀི་ཨི་ཨང་ཀོཌ།ནང་འཇུག་ལྟར་ string དང་སྟེང་གི་ཡིག་རྟགས་ཀྱི་བསྡོམས་གྲངས་ཕྱིར་ལོག་བྱེད་ function ཞིག་འབྲི་དགོས།ལས་འགན་ # >>> digitSum.call(\"\")\n# 0\n# >>> digitSum.call(\"abAB\")\n# 131\n# >>> digitSum.call(\"abcCd\")\n# 67\n# >>> digitSum.call(\"helloE\")\n# 69\n# >>> digitSum.call(\"woArBld\")\n# 131\n# >>> digitSum.call(\"aAaaaXa\")\n# 153\ndef digitSum(s)\n","canonical_solution":"def digitSum(s)\n  s.chars.select { |char| char =~ \/[A-Z]\/ }.map(&:ord).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digitSum\n    candidate = method(:digitSum)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(131, candidate.call(\"abAB\"))\n    assert_equal(67, candidate.call(\"abcCd\"))\n    assert_equal(69, candidate.call(\"helloE\"))\n    assert_equal(131, candidate.call(\"woArBld\"))\n    assert_equal(153, candidate.call(\"aAaaaXa\"))\n    assert_equal(151, candidate.call(\" How are yOu?\"))\n    assert_equal(327, candidate.call(\"You arE Very Smart\"))\n  end\nend\n"},{"task_id":"HumanEval_67","nl":"bod_Tibt","pl":"rb","prompt":"ཆེད་སྒྲིགཙེལ་པོ་ནང་ཡོད་པའི་མན་གྷོའི་འབྲས་བུ་གྲངས་ཕྱིར་ལོག་བྱེད་པ།འབྲས་བུའི་གྲངས་ཐང་མཚོན་པའི་ཨང་གྲངས་ཧྲིལ་པོ་དང་ཁམ་བུ་དང་ཁམ་བུ་བཅས་ཡིན།འབྲས་བུའི་གྲངས་རྩིས་ཀྱི་ཐིག་ཁྲམ་འདི་ལ།འབྲས་བུ་ཡོད་པའི་ཙེལ་པོ་ཞིག་ལ་བགོས་པའི་ཤིང་འབྲས་ཡིན།ལས་འགན་འདིའི་ནང་ཁྱོད་ཚོར་ apple དང་ orange གྱི་གྲངས་ཐང་མཚོན་པའི་ string ཞིག་ཐོབ་ངེས་ཡིན།# >>> fruit_distribution.call(\"5 apples and 6 oranges\", 19)\n# 8\n# >>> fruit_distribution.call(\"0 apples and 1 oranges\", 3)\n# 2\n# >>> fruit_distribution.call(\"2 apples and 3 oranges\", 100)\n# 95\n# >>> fruit_distribution.call(\"100 apples and 1 oranges\", 120)\n# 19\ndef fruit_distribution(s, n)\n","canonical_solution":"def fruit_distribution(s, n)\n  numbers = s.scan(\/\\d+\/).map(&:to_i)\n  apples = numbers[0]\n  oranges = numbers[1]\n  total_fruits = n\n  mangos = total_fruits - (apples + oranges)\n  mangos\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fruit_distribution\n    candidate = method(:fruit_distribution)\n    assert_equal(8, candidate.call(\"5 apples and 6 oranges\", 19))\n    assert_equal(10, candidate.call(\"5 apples and 6 oranges\", 21))\n    assert_equal(2, candidate.call(\"0 apples and 1 oranges\", 3))\n    assert_equal(2, candidate.call(\"1 apples and 0 oranges\", 3))\n    assert_equal(95, candidate.call(\"2 apples and 3 oranges\", 100))\n    assert_equal(0, candidate.call(\"2 apples and 3 oranges\", 5))\n    assert_equal(19, candidate.call(\"1 apples and 100 oranges\", 120))\n  end\nend\n"},{"task_id":"HumanEval_68","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཞི་དང་པོ།གལ་ཏེ་གྲངས་ཆ་མཚུངས་མེད་པའམ་གྲངས་ཐང་སྟོང་པ་ཡོད་ན་ return [] ཟེར་བ་འདེམས་དགོས།ཕྱིར་བཏོན་པའི་ཨང་གྲངས་ནི་གཞི་རིམ་ནང་ཕྱིར་ལོག་བྱེད་པ། [smallest_value, its index], གལ་ཏེ་ཕྲ་གྲངས་ཆུང་ཤོས་དང་ཕྲ་གྲངས་ཉུང་ཤོས་འདྲ་མཉམ་ཡོད་པའི་ཕྲ་གྲངས་མང་པོ་བསྡུས་ན་ཕྲ་གྲངས་ཆུང་ཤོས་ཡོད་པའི་ཕྲ་གྲངས་ཕྱིར་ལོག་བྱེད།ཕྱིར་འཐེན་བྱས་པའི་ཨང་རྟགས་ནི་ཨང་རྟགས་ཆུང་ཤོས་དང་མཚུངས་པའི་ཨང་རྟགས་ཡིན་དགོས།ཁྱོད་ཀྱི་ལས་འགན་ནི་ཨང་རྟགས་གཅིག་བཏོན་ནས་ཕྱིར་ལོག་བྱེད་རྒྱུ་དེ་ཡིན།\"ཨེ་རེ་དེ་ཤིང་སྡོང་གི་ཡལ་ག་གང་ཞིག་ལ་མཚོན་ན་ འབྲས་བུ་མེད་པའི་ཧྲིལ་གྲངས་ཀྱི་ཨང་གྲངས་ཡོད་པ།# >>> pluck.call([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck.call([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck.call([])\n# []\n# Example 4:\n# >>> pluck.call([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n","canonical_solution":"def pluck(arr)\n  smallest_even = nil\n  smallest_index = nil\n  \n  arr.each_with_index do |value, index|\n    if value.even?\n      if smallest_even.nil? || value < smallest_even\n        smallest_even = value\n        smallest_index = index\n      end\n    end\n  end\n\n  smallest_even.nil? ? [] : [smallest_even, smallest_index]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"},{"task_id":"HumanEval_69","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།གལ་ཏེ་གོང་ཚད་དེ་མེད་ན་ -1 སླར་ལོག་བྱེད།ཨང་གྲངས་ཧྲིལ་པོ་ཞིག་གི་འཕྲལ་ཆ། དེ་ནི་ཨང་གྲངས་ཧྲིལ་པོ་ཞིག་ཐིག་ཁྲམ་ནང་ཇི་ཙམ་ཐེངས་མངོན་པ་ཡིན།ནུས་པ་ 0 དང་འཕྲལ་དུ་མང་བ་ཡང་ན་ འདྲ་མཉམ་གྲངས་ཆ་རང་གི་རིན་ཐང་དང་མཚུངས་པ་ཡོད།ཁྱོད་ཀྱིས་ཁ་སྐོང་གྲངས་ཆ་མེད་ཀྱི་གྲངས་ཐང་མེད་པའི་གྲངས་ཐང་ཐོབ་ཡོད། ལས་མང་བའི་གྲངས་ཐང་ཆེན་ཤོས་ཕྱིར་ལོག་བྱོས།# >>> search.call([4, 1, 2, 2, 3, 1])\n# 2\n# >>> search.call([1, 2, 2, 3, 3, 3, 4, 4, 4])\n# 3\n# >>> search.call([5, 5, 4, 4, 4])\n# -1\ndef search(lst)\n","canonical_solution":"def search(lst)\n  freq_hash = lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }\n  valid_numbers = freq_hash.select { |num, freq| freq >= num }.keys\n  valid_numbers.empty? ? -1 : valid_numbers.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_search\n    candidate = method(:search)\n    assert_equal(1, candidate.call([5, 5, 5, 5, 1]))\n    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))\n    assert_equal(-1, candidate.call([3, 3]))\n    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8, 8, 8]))\n    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))\n    assert_equal(1, candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]))\n    assert_equal(2, candidate.call([3, 2, 8, 2]))\n    assert_equal(1, candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))\n    assert_equal(-1, candidate.call([8, 8, 3, 6, 5, 6, 4]))\n    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))\n    assert_equal(1, candidate.call([1, 9, 10, 1, 3]))\n    assert_equal(5, candidate.call([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))\n    assert_equal(1, candidate.call([1]))\n    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))\n    assert_equal(2, candidate.call([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))\n    assert_equal(1, candidate.call([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))\n    assert_equal(4, candidate.call([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]))\n    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))\n    assert_equal(2, candidate.call([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))\n    assert_equal(-1, candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]))\n    assert_equal(-1, candidate.call([10]))\n    assert_equal(2, candidate.call([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))\n    assert_equal(1, candidate.call([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))\n    assert_equal(1, candidate.call([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))\n    assert_equal(-1, candidate.call([3, 10, 10, 9, 2]))\n  end\nend\n"},{"task_id":"HumanEval_70","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།དེའི་རྗེས་ལ་ལྷག་ལུས་ཧྲིལ་གྲངས་ཀྱི་ཆེ་མཐར། དེའི་རྗེས་ལ་ཉུང་མཐར། ཟེར་བ་ལྟ་བུ།ཇི་ཙམ་གལ་ཆེ་བས་གལ་ཆེ་བ་ཡིན་པའི་ཚད་གཞི་ནས་འགོ་འཛུགས་པ།ཇི་ཡོད་ཨང་གྲངས་ཀྱི་རིམ་པ་ཡོད་ན། རིམ་པ་དལ་འབྱོར་དུ་ལོག་དགོས།# >>> strange_sort_list.call([1, 2, 3, 4])\n# [1, 4, 2, 3]\n# >>> strange_sort_list.call([5, 5, 5, 5])\n# [5, 5, 5, 5]\n# >>> strange_sort_list.call([])\n# []\ndef strange_sort_list(lst)\n","canonical_solution":"def strange_sort_list(lst)\n  result = []\n  lst.sort!\n  until lst.empty?\n    result << lst.shift\n    result << lst.pop unless lst.empty?\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strange_sort_list\n    candidate = method(:strange_sort_list)\n    assert_equal([1, 4, 2, 3], candidate.call([1, 2, 3, 4]))\n    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))\n    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))\n    assert_equal([1, 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))\n    assert_equal([5, 5, 5, 5], candidate.call([5, 5, 5, 5]))\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7, 8]))\n    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2, 5, 5, -5, -5]))\n    assert_equal([111111], candidate.call([111111]))\n  end\nend\n"},{"task_id":"HumanEval_71","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། ཤོག་ངོས་གསུམ་པ་ལས་ལྷག་པ་མེད།གཡོན་པ་གསུམ་གྱིས་རྣམ་གསུམ་གྲུབ་པའི་སྐབས་ཀྱི་གྲངས་ཐང་ནི་གཞན་གྱི་ཟུར་པ་གཉིས་ལས་མང་བ་ཡིན་ཏེ།དེ་མིན་ལོག་ -1 ཕྱོགས་གསུམ་གྱི་རྣམ་པ་གསུམ་ལྡན་པ་ཞིག་ཡིན་ན། ཟུར་གསུམ་གྱི་མཐའ་འཁོར་གྱི་ཟུར་གྲངས་ནི་བཅུ་ཆ་གཉིས་སུ་བསྡུ་དགོས།ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་རིང་ཚད་ལ་གཞི་བྱས་ན། གྱི་ཁྱབ་ཚད་ཕྱིར་ལོག་བྱེད་པ།# >>> triangle_area.call(3, 4, 5)\n# 6.0\n# >>> triangle_area.call(1, 2, 10)\n# -1\ndef triangle_area(a, b, c)\n","canonical_solution":"def triangle_area(a, b, c)\n  # Check for valid triangle\n  if a + b > c && a + c > b && b + c > a\n    # Calculate the semi-perimeter\n    s = (a + b + c) \/ 2.0\n    # Calculate the area using Heron's formula\n    area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n    # Round to 2 decimal points\n    return area.round(2)\n  else\n    return -1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(6.0, candidate.call(3, 4, 5))\n    assert_equal(-1, candidate.call(1, 2, 10))\n    assert_equal(8.18, candidate.call(4, 8, 5))\n    assert_equal(1.73, candidate.call(2, 2, 2))\n    assert_equal(-1, candidate.call(1, 2, 3))\n    assert_equal(16.25, candidate.call(10, 5, 7))\n    assert_equal(-1, candidate.call(2, 6, 3))\n    assert_equal(0.43, candidate.call(1, 1, 1))\n    assert_equal(-1, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_72","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། དངོས་པོ་ q དེ་ཚད་ལྡན་ཡིན་ན་འཕུར་ཐུབ། (དེ་ནི་པཱ་ལིན་ཌོ་མིག་ཨར་རི་ཡིན་) དེའི་ཆ་ཤས་ཀྱི་བསྡོམས་ནི་ནུས་ལྡན་ལྗིད་ཚད་ w ལས་ཆུང་བ་ཡང་ན་དེའི་འདྲ་མཉམ་ཡིན་ན།དངོས་པོ་ q འཕུར་ནས་འགྲོ་ཐུབ་ན་ true སླར་ལོག་བྱེད་པ་དང་གཞན་ན་ false སླར་ལོག་བྱེད་པའི་ལས་འགན་ཞིག་བྲིས་ཤིག# >>> will_it_fly.call([1, 2], 5)\n# false\n# # 1+2 is less than the maximum possible weight, but it's unbalanced.\n# >>> will_it_fly.call([3, 2, 3], 1)\n# false\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n# >>> will_it_fly.call([3, 2, 3], 9)\n# true\n# # 3+2+3 is less than the maximum possible weight, and it's balanced.\n# >>> will_it_fly.call([3], 5)\n# true\n# # 3 is less than the maximum possible weight, and it's balanced.\ndef will_it_fly(q, w)\n","canonical_solution":"def will_it_fly(q, w)\n  is_palindrome = q == q.reverse\n  total_weight = q.sum\n  is_balanced_and_under_weight = is_palindrome && total_weight <= w\n  is_balanced_and_under_weight\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_will_it_fly\n    candidate = method(:will_it_fly)\n    assert_equal(true, candidate.call([3, 2, 3], 9))\n    assert_equal(false, candidate.call([1, 2], 5))\n    assert_equal(true, candidate.call([3], 5))\n    assert_equal(false, candidate.call([3, 2, 3], 1))\n    assert_equal(false, candidate.call([1, 2, 3], 6))\n    assert_equal(true, candidate.call([5], 5))\n  end\nend\n"},{"task_id":"HumanEval_73","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: ཕྱོགས་གཉིས་སུ་འདྲ་མཚུངས་ཀློག་ཐུབ། འགྱུར་བ་གཅིག་གི་ནང་ཁྱེད་རང་ཚོས་ཆ་ཤས་གཅིག་ལ་ཆ་ཤས་གཞན་ཞིག་ཏུ་བསྒྱུར་ཐུབ།ཚད་ལྡན་རིམ་པ་ (palindromic array) ནི་རིམ་པ་ཞིག་ཡིན་ཏེ།སྐར་མ་གྲངས་ཆ་མཉམ་གྱི་རིམ་པ་ arr ཞིག་ཡོད་ན། ཇི་འདྲ་ཡིན་པའི་ཉུང་མཐའི་གྲངས་ཀ་འཚོལ་དགོས།# >>> smallest_change.call([1, 2, 3, 5, 4, 7, 9, 6])\n# 4\n# >>> smallest_change.call([1, 2, 3, 4, 3, 2, 2])\n# 1\n# >>> smallest_change.call([1, 2, 3, 2, 1])\n# 0\ndef smallest_change(arr)\n","canonical_solution":"def smallest_change(arr)\n  changes = 0\n  left = 0\n  right = arr.length - 1\n\n  while left < right\n    if arr[left] != arr[right]\n      changes += 1\n    end\n    left += 1\n    right -= 1\n  end\n\n  changes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_smallest_change\n    candidate = method(:smallest_change)\n    assert_equal(4, candidate.call([1, 2, 3, 5, 4, 7, 9, 6]))\n    assert_equal(1, candidate.call([1, 2, 3, 4, 3, 2, 2]))\n    assert_equal(1, candidate.call([1, 4, 2]))\n    assert_equal(1, candidate.call([1, 4, 4, 2]))\n    assert_equal(0, candidate.call([1, 2, 3, 2, 1]))\n    assert_equal(0, candidate.call([3, 1, 1, 3]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(1, candidate.call([0, 1]))\n  end\nend\n"},{"task_id":"HumanEval_74","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།གལ་ཏེ་གཞི་གྲངས་གཉིས་ནང་ཡིག་རྟགས་གྲངས་འདྲ་མཚུངས་ཡོད་ན་གཞི་གྲངས་དང་པོ་ཕྱིར་ལོག་བྱེད་པ།སྐར་མ་གྲངས་ནི་གཞན་སྐར་མ་ལས་ཉུང་བ་ཡིན།ཚད་གཞི་གཉིས་དང་ཚད་གཞི་ཡོད་ཚད་ཕྱིར་ལོག་བྱེད་ནུས་པའི་ལས་འགན་ཞིག་བྲིས་ཤིག# >>> total_match.call([], [])\n# []\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n# [\"hI\", \"Hi\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n# [\"hi\", \"admin\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n# [\"hI\", \"hi\", \"hi\"]\n# >>> total_match.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n# [\"4\"]\ndef total_match(lst1, lst2)\n","canonical_solution":"def total_match(lst1, lst2)\n  total_chars1 = lst1.map(&:length).sum\n  total_chars2 = lst2.map(&:length).sum\n\n  if total_chars1 < total_chars2\n    lst1\n  elsif total_chars2 < total_chars1\n    lst2\n  else\n    lst1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_total_match\n    candidate = method(:total_match)\n    assert_equal([], candidate.call([], []))\n    assert_equal([\"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]))\n    assert_equal([\"4\"], candidate.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]))\n    assert_equal([\"hI\", \"Hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"]))\n    assert_equal([\"hI\", \"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]))\n    assert_equal([], candidate.call([], [\"this\"]))\n    assert_equal([], candidate.call([\"this\"], []))\n  end\nend\n"},{"task_id":"HumanEval_75","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། (a) ནི་ 100 ལས་ཆུང་བ་ཡིན་པར་ཤེས་པ་དགོས།འདྲ་མིན་ལ་རྫུན་བཤད་ཀྱི་ཡོད།གྲངས་གཞི་གྲངས་ནི་ 3 ཀྱི་གྲངས་གཞི་གྲངས་དང་མཚུངས་པ་ཡིན་ན་ true སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་བྲིས་ཤིག# >>> is_multiply_prime.call(30)\n# true\n# 30 = 2 * 3 * 5\ndef is_multiply_prime(a)\n","canonical_solution":"require 'prime'\n\ndef is_multiply_prime(a)\n  return false if a >= 100\n  prime_factors = a.prime_division\n  return true if prime_factors.size == 3 && prime_factors.all? { |_, exponent| exponent == 1 }\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_multiply_prime\n    candidate = method(:is_multiply_prime)\n    assert_equal(false, candidate.call(5))\n    assert_equal(true, candidate.call(30))\n    assert_equal(true, candidate.call(8))\n    assert_equal(false, candidate.call(10))\n    assert_equal(true, candidate.call(125))\n    assert_equal(true, candidate.call(105))\n    assert_equal(false, candidate.call(126))\n    assert_equal(false, candidate.call(729))\n    assert_equal(false, candidate.call(891))\n    assert_equal(true, candidate.call(1001))\n  end\nend\n"},{"task_id":"HumanEval_76","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: x ནི་ n གི་རྣམ་གྲངས་གཅིག་པུ་ཡིན་ན། n**int=x ཤུགས་ n དང་ false གཞན་གྱི་གནས་སྟངས་ནང་ཁྱོད་ཀྱི་ལས་འགན་ནི་གྲངས་ x ནི་གྲངས་རྐྱང་པ་ཡིན་ན་ true སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་འབྲི་དགོས་པ་ཡིན།# >>> is_simple_power.call(1, 4)\n# true\n# >>> is_simple_power.call(2, 2)\n# true\n# >>> is_simple_power.call(8, 2)\n# true\n# >>> is_simple_power.call(3, 2)\n# false\n# >>> is_simple_power.call(3, 1)\n# false\n# >>> is_simple_power.call(5, 3)\n# false\ndef is_simple_power(x, n)\n","canonical_solution":"def is_simple_power(x, n)\n  return false if x <= 0 || n <= 1\n  return true if x == 1\n\n  power = n\n  while power <= x\n    return true if power == x\n    power *= n\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_simple_power\n    candidate = method(:is_simple_power)\n    assert_equal(true, candidate.call(16, 2))\n    assert_equal(false, candidate.call(143214, 16))\n    assert_equal(true, candidate.call(4, 2))\n    assert_equal(true, candidate.call(9, 3))\n    assert_equal(true, candidate.call(16, 4))\n    assert_equal(false, candidate.call(24, 2))\n    assert_equal(false, candidate.call(128, 4))\n    assert_equal(false, candidate.call(12, 6))\n    assert_equal(true, candidate.call(1, 1))\n    assert_equal(true, candidate.call(1, 12))\n  end\nend\n"},{"task_id":"HumanEval_77","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།Note: ཁྱོད་ཀྱིས་གཏན་ནས་གཏན་ལ་ཕབ་པའི་ངེས་དོན་གཏན་ལ་ཕབ་ཐུབ།གལ་ཏེ་འདི་ནི་ཨེན་ཇི་ཇར་ནི་ཨང་གྲངས་ཧྲིལ་པོ་ཅིག་གི་གྲུ་བཞི་ཡིན་ན།གྲངས་ཧྲིལ་ a དང་ true སླར་ལོག་བྱེད་པའི་ལས་འགན་ཞིག་བྲིས་ཤིག# >>> iscube.call(1)\n# true\n# >>> iscube.call(2)\n# false\n# >>> iscube.call(-1)\n# true\n# >>> iscube.call(64)\n# true\n# >>> iscube.call(0)\n# true\n# >>> iscube.call(180)\n# false\ndef iscube(a)\n","canonical_solution":"def iscube(a)\n  cube_root = a.abs**(1.0\/3)\n  cube_root.round**3 == a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_iscube\n    candidate = method(:iscube)\n    assert_equal(true, candidate.call(1))\n    assert_equal(false, candidate.call(2))\n    assert_equal(true, candidate.call(-1))\n    assert_equal(true, candidate.call(64))\n    assert_equal(false, candidate.call(180))\n    assert_equal(true, candidate.call(1000))\n    assert_equal(true, candidate.call(0))\n    assert_equal(false, candidate.call(1729))\n  end\nend\n"},{"task_id":"HumanEval_78","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཚོས་གཞི་ A,B,C,D,E,F འདི་ཚོ་རྒྱུན་དུ་ཡིག་ཆུང་ཡིན།དྲན་གསོ། ཁྱོད་ཀྱིས་གཏན་ནས་ནང་འཇུག་དེ་བདེན་པའམ་སྟོང་པ་རེད་བསམ་ཐུབ།B (= བཅུ་ཚིགས་ཀྱི་གྲངས་ཀ་ ༡༡) D (= བཅུ་ཚིགས་ཀྱི་གྲངས་ཀ་ ༡༣) ཡིན།ཁྱོད་ཀྱིས་གཤམ་གསལ་ཨང་གྲངས་ཀྱི་གྲངས་ཀ་འདེམས་དགོས། ༢། ༣། ༥། ༧། ཕྲ་གྲངས་ནི་ ༢། ༣། ༥། ༧། ༡༡། ༡༣། ༡༧། ...༦གོང་མའི་ཨང་གྲངས་ནི་ ༠། ༡། ༢། ༣། ༤། ༥། ༦། ༧། ༨། ༩། A། B། C། D། E། F།1ལས་མང་བ་འདི་ནི་གྲངས་ཆུང་བ་གཉིས་ལས་མང་བ་མ་ཡིན་)གྲངས་ཆེན་ནི་རང་བྱུང་གྲངས་ཡིན།༦ ཕྲེང་གྲངས་ནི་ string དང་གྲངས་རྩིས་ཀྱི་གྲངས་ཀ་ཡིན།ཁྱོད་ཚོར་ཐོབ་པའི་ལས་འགན་ཞིག་འབྲི་དགོས་པའི་འགན་ཁུར་སྤྲད་ཡོད།# >>> hex_key.call(\"AB\")\n# 1\n# >>> hex_key.call(\"1077E\")\n# 2\n# >>> hex_key.call(\"ABED1A33\")\n# 4\n# >>> hex_key.call(\"123456789ABCDEF0\")\n# 6\n# >>> hex_key.call(\"2020\")\n# 2\ndef hex_key(num)\n","canonical_solution":"def hex_key(num)\n  prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']\n  num.chars.count { |digit| prime_hex_digits.include?(digit) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_hex_key\n    candidate = method(:hex_key)\n    assert_equal(1, candidate.call(\"AB\"))\n    assert_equal(2, candidate.call(\"1077E\"))\n    assert_equal(4, candidate.call(\"ABED1A33\"))\n    assert_equal(2, candidate.call(\"2020\"))\n    assert_equal(6, candidate.call(\"123456789ABCDEF0\"))\n    assert_equal(12, candidate.call(\"112233445566778899AABBCCDDEEFF00\"))\n  end\nend\n"},{"task_id":"HumanEval_79","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཤོག་གྲངས་ཁ་སྐོང་ནི་ཡིག་གཟུགས་སྒྲིག་སྟངས་ལ་ཕན་ཐོགས་ཀྱི་ཆེད་དུ་ཡིན།string གི་ཐོག་དང་མཇུག་ཏུ་ 'db' ཡིག་རྟགས་གཉིས་རེ་ལྷག་ཡོད།string ནང་གི་ཡིག་འབྲུ་རེ་རེར་ '0' ཡང་ན་ '1' ཟེར་བ་ཡོད།binary format. function གྱིས་ string སླར་ལོག་བྱེད་དགོས། ཕྲེང་བ་རེ་རེས་ binary  ཟེར་བ་མཚོན་དགོས།ཁྱོད་ཚོར་བཅུ་གྲངས་ཀྱི་རྣམ་པ་ནས་གྲངས་ཤིག་ཐོབ་རྒྱུ་དང་ཁྱོད་ཀྱི་ལས་འགན་ནི་དེ་ ལ་བསྒྱུར་རྒྱུ་དེ་ཡིན།# >>> decimal_to_binary.call(15)\n# \"db1111db\"\n# >>> decimal_to_binary.call(32)\n# \"db100000db\"\ndef decimal_to_binary(decimal)\n","canonical_solution":"def decimal_to_binary(decimal)\n  \"db\" + decimal.to_s(2) + \"db\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_decimal_to_binary\n    candidate = method(:decimal_to_binary)\n    assert_equal(\"db0db\", candidate.call(0))\n    assert_equal(\"db100000db\", candidate.call(32))\n    assert_equal(\"db1100111db\", candidate.call(103))\n    assert_equal(\"db1111db\", candidate.call(15))\n  end\nend\n"},{"task_id":"HumanEval_80","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: string ནི་ haprb ཡིན་པ་དེའི་རིང་ཚད་ནི་ 3 ཡིན། ཡང་ 3 ཡི་གེ་རེ་རེ་ནི་སོ་སོར་ཁྱད་པར་ཡོད།ཁྱོད་ཀྱི་ལས་འགན་ནི་ string དེ་ haprb ཡིན་མིན་ལ་བརྟག་དཔྱད་བྱ་རྒྱུ་རེད།ཚད་གཞི་དེ་ཁྱོད་ལ་ཐོབ་ཡོད།# >>> is_happy.call(\"a\")\n# false\n# >>> is_happy.call(\"aa\")\n# false\n# >>> is_happy.call(\"abcd\")\n# true\n# >>> is_happy.call(\"aabb\")\n# false\n# >>> is_happy.call(\"adb\")\n# true\n# >>> is_happy.call(\"xyy\")\n# false\ndef is_happy(s)\n","canonical_solution":"def is_happy(s)\n  return false if s.length < 3\n  \n  (0..s.length - 3).each do |i|\n    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]\n  end\n  \n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_happy\n    candidate = method(:is_happy)\n    assert_equal(false, candidate.call(\"a\"))\n    assert_equal(false, candidate.call(\"aa\"))\n    assert_equal(true, candidate.call(\"abcd\"))\n    assert_equal(false, candidate.call(\"aabb\"))\n    assert_equal(true, candidate.call(\"adb\"))\n    assert_equal(false, candidate.call(\"xyy\"))\n    assert_equal(true, candidate.call(\"iopaxpoi\"))\n    assert_equal(false, candidate.call(\"iopaxioi\"))\n  end\nend\n"},{"task_id":"HumanEval_81","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། 0.0 E > 0.0 D- > 0.7 D > ༡.༠ D+ > 1.3 C- > 1.7 C > 2.0 C+ > 2.3 B- > 2.7 B > 3.0 B+ > 3.3 A- > 3.7 A 4.0 A+ GPA སྐུགས་ཚད་ཨང་གྲངས་འོག་གི་ཐིག་ཁྲམ་འདི་ལག་ལེན་ཐོག་ཡིག་རྟགས་ཀྱི་ཚད་གཞི་ཕྱིར་ཐོན་བྱེད་ནུས་པའི་ function: ཕྲུག་གི་སློབ་ཕྲུག་འགའ་ཤས་ཀྱི་ GPA ཚད་གཞི་མང་པོ་ཞིག་ཁྱོད་ལ་སྤྲད་ཡོད། ཁྱོད་ཀྱིས་དེ་བྲིས་དགོས་ཀྱི་འདུགསྐྱོན་ནི་མོ་ལ་རྟགས་རྒྱག་སྐབས་བེད་སྤྱོད་བྱེད་པའི་ཡིག་རྟགས་དེ་ཤོར་སོང་བ་རེད།སློབ་དཔོན་གྱིས་རང་རང་གི་ཚད་གཞི་བཟོ་བཞིན་ཡོད།སློབ་དུས་ཀྱི་བདུན་ཕྲག་མཇུག་གི་ཉིན་མོ་ཡིན་པས་སློབ་དཔོན་གྱིས་སློབ་ཚན་གྱི་རྟགས་མ་སྤྲོད་དགོས་ཀྱི་འདུག# >>> grade_equation.call([4.0, 3, 1.7, 2, 3.5])\n# [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\ndef numerical_letter_grade(grades)\n","canonical_solution":"def numerical_letter_grade(grades)\n  grades.map do |gpa|\n    case \n    when gpa == 4.0\n      \"A+\"\n    when gpa > 3.7\n      \"A\"\n    when gpa > 3.3\n      \"A-\"\n    when gpa > 3.0\n      \"B+\"\n    when gpa > 2.7\n      \"B\"\n    when gpa > 2.3\n      \"B-\"\n    when gpa > 2.0\n      \"C+\"\n    when gpa > 1.7\n      \"C\"\n    when gpa > 1.3\n      \"C-\"\n    when gpa > 1.0\n      \"D+\"\n    when gpa > 0.7\n      \"D\"\n    when gpa > 0.0\n      \"D-\"\n    else\n      \"E\"\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_numerical_letter_grade\n    candidate = method(:numerical_letter_grade)\n    assert_equal([\"A+\", \"B\", \"C-\", \"C\", \"A-\"], candidate.call([4.0, 3, 1.7, 2, 3.5]))\n    assert_equal([\"D+\"], candidate.call([1.2]))\n    assert_equal([\"D-\"], candidate.call([0.5]))\n    assert_equal([\"E\"], candidate.call([0.0]))\n    assert_equal([\"D\", \"D-\", \"C-\", \"B\", \"B+\"], candidate.call([1.0, 0.3, 1.5, 2.8, 3.3]))\n    assert_equal([\"E\", \"D-\"], candidate.call([0.0, 0.7]))\n  end\nend\n"},{"task_id":"HumanEval_82","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།length ནི་གྲངས་དང་པོ་ཡིན་པའམ་གཞན་ན་ false ཡིན་པ་ངེས་པ་མེད།string ཞིག་ལེན་ནས་ true སླར་ལོག་བྱེད་རྒྱུའི་ལས་འགན་ཞིག་བྲིས་ན།# >>> prime_length.call(\"Hello\")\n# true\n# >>> prime_length.call(\"abcdcba\")\n# true\n# >>> prime_length.call(\"kittens\")\n# true\n# >>> prime_length.call(\"orange\")\n# false\ndef prime_length(string)\n","canonical_solution":"def prime_length(string)\n  length = string.length\n  return false if length < 2\n\n  (2..Math.sqrt(length)).each do |i|\n    return false if length % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_length\n    candidate = method(:prime_length)\n    assert_equal(true, candidate.call(\"Hello\"))\n    assert_equal(true, candidate.call(\"abcdcba\"))\n    assert_equal(true, candidate.call(\"kittens\"))\n    assert_equal(false, candidate.call(\"orange\"))\n    assert_equal(true, candidate.call(\"wow\"))\n    assert_equal(true, candidate.call(\"world\"))\n    assert_equal(true, candidate.call(\"MadaM\"))\n    assert_equal(true, candidate.call(\"Wow\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"HI\"))\n    assert_equal(true, candidate.call(\"go\"))\n    assert_equal(false, candidate.call(\"gogo\"))\n    assert_equal(false, candidate.call(\"aaaaaaaaaaaaaaa\"))\n    assert_equal(true, candidate.call(\"Madam\"))\n    assert_equal(false, candidate.call(\"M\"))\n    assert_equal(false, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_83","nl":"bod_Tibt","pl":"rb","prompt":"འབྲས་བུ་ནི་ 1 དང་འགོ་བཟུང་བའམ་མཇུག་བསྡོམས་པའི་ཧྲིལ་གྲངས་ཡིན།འབྲས་བུ་ལྡན་གྲངས་ n ཞིག་ཡོད་ན། ཨང་གྲངས་ n-digit གྱི་གྲངས་རྩིས་ཕྱིར་ལོག་བྱོས།def starts_one_ends(n)\n","canonical_solution":"def starts_one_ends(n)\n  return 0 if n <= 0\n\n  # Count numbers starting with 1\n  start_with_1 = 9 ** (n - 1)\n\n  # Count numbers ending with 1\n  end_with_1 = 9 ** (n - 1)\n\n  # Adjust for double counting the number that both starts and ends with 1\n  both_start_and_end_with_1 = 9 ** (n - 2) if n > 1\n  \n  start_with_1 + end_with_1 - (both_start_and_end_with_1 || 0)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_starts_one_ends\n    candidate = method(:starts_one_ends)\n    assert_equal(1, candidate.call(1))\n    assert_equal(18, candidate.call(2))\n    assert_equal(180, candidate.call(3))\n    assert_equal(1800, candidate.call(4))\n    assert_equal(18000, candidate.call(5))\n  end\nend\n"},{"task_id":"HumanEval_84","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།འབྲས་བུ་ཆ་མཉམ་ N བྱིན་ནས་དེའི་ཨང་གྲངས་ཀྱི་བསྡོམས་གྲངས་ཉིས་ལྡན་དུ་ཕྱིར་ལོག་འབད།# >>> solve.call(1000)\n# \"1\"\n# >>> solve.call(150)\n# \"110\"\n# >>> solve.call(147)\n# \"1100\"\n# Variables:\n# @N integer\n# Constraints: 0 ≤ N ≤ 10000.\n# Output:\n# a string of binary number\ndef solve(n)\n","canonical_solution":"def solve(n)\n  sum_of_digits = n.to_s.chars.map(&:to_i).sum\n  sum_of_digits.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"1\", candidate.call(1000))\n    assert_equal(\"110\", candidate.call(150))\n    assert_equal(\"1100\", candidate.call(147))\n    assert_equal(\"1001\", candidate.call(333))\n    assert_equal(\"10010\", candidate.call(963))\n  end\nend\n"},{"task_id":"HumanEval_85","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།སྟོང་པ་མིན་པའི་གྲངས་ཐང་གི་རིམ་པ་ཡོད་ན། ཐོག་མར་གྲངས་ཐང་གི་ཆ་ཤས་གྲངས་ཐང་མིན་པའི་ཆ་ཤས་གྲངས་ཐང་དུ་རྩིས་དགོས།# >>> add.call([4, 2, 6, 7])\n# 2\ndef add(lst)\n","canonical_solution":"def add(lst)\n  lst.each_with_index.select { |num, index| index.odd? && num.even? }.map(&:first).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(88, candidate.call([4, 88]))\n    assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))\n    assert_equal(0, candidate.call([4, 0, 6, 7]))\n    assert_equal(12, candidate.call([4, 4, 6, 8]))\n  end\nend\n"},{"task_id":"HumanEval_86","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: དྲན་གསོ། ཁྱོད་ཀྱིས་ཚིག་དང་སྟོང་པ་རིམ་བཞིན་བཞག་དགོས་པ་ཡིན།ཚད་གཞི་གཞི་ཐོག་ཡར་འགྲོ་གི་རིམ་པ་ཀྱི་ནང་ཡོད་པའི་ཡིག་འབྲུ་ཚང་མ་འདེམས་པའི་ཚིག་གསར་པ་ཞིག་གིས་ཚབ་ཏུ་འཇུག་དགོས།ordered version of string འདི་ནང་ཚིག་ཆ་ཚང་མ་ (བར་སྟོང་གིས་སོ་སོར་དབྱེ་) ཡོད་པའི་ string ཞིག་ཡིན།ཚད་གཞི་ཅིག་ལེན་ཏེ་ དེའི་རིམ་པ་སྒྲིག་པའི་རྣམ་པ་ཅིག་སླར་ལོག་འབད་ནིའི་ལས་འགན་ཅིག་འབྲི་དགོས།# >>> anti_shuffle.call(\"Hi\")\n# \"Hi\"\n# >>> anti_shuffle.call(\"hello\")\n# \"ehllo\"\n# >>> anti_shuffle.call(\"Hello World!!!\")\n# \"Hello !!!Wdlor\"\ndef anti_shuffle(s)\n","canonical_solution":"def anti_shuffle(s)\n  s.split(\/(\\s+)\/).map { |word| word.chars.sort.join }.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_anti_shuffle\n    candidate = method(:anti_shuffle)\n    assert_equal(\"Hi\", candidate.call(\"Hi\"))\n    assert_equal(\"ehllo\", candidate.call(\"hello\"))\n    assert_equal(\"bemnru\", candidate.call(\"number\"))\n    assert_equal(\"abcd\", candidate.call(\"abcd\"))\n    assert_equal(\"Hello !!!Wdlor\", candidate.call(\"Hello World!!!\"))\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\".Hi My aemn is Meirst .Rboot How aer ?ouy\", candidate.call(\"Hi. My name is Mister Robot. How are you?\"))\n  end\nend\n"},{"task_id":"HumanEval_87","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།དེ་མིན་གྲལ་རིམ་གྱི་གོ་རིམ་རིམ་རིམ་བཞིན་གྲལ་རིམ་གྱི་གོ་རིམ་རིམ་སྒྲིག་དགོས།ཐོག་མར་གོ་རིམ་ཡར་རྒྱས་ཀྱི་རིམ་པ་བཞིན་གོ་རིམ་སྒྲིག་དགོས།གྲལ་ཐིག་རེ་རེར་ 0 ནས་འགོ་ཚུགས་པའི་གོ་རིམ་ (row, columns) ཞིག་ཡོད།ཚད་གཞི་ཀྱི་རིམ་པ་སླར་ལོག་བྱ་བ། [(x1, y1), (x2, y2) ...] འདི་ལྟར་ཡིན་ན། lst དང་ཧྲིལ་གྲངས་ x ཡོད་པ་ཚེ། ཐིག་ཁྲམ་ནང་ཧྲིལ་གྲངས་ x འཚོལ་དགོས།གྲལ་ཐིག་རེ་རེར་ཀ་བའི་གྲངས་མི་འདྲ་བ་ཡོད་སྲིད་དོ།ཇི་ནི་མ་ཊི་རེས་དང་འདྲ་བ་ཞིག་ཡིན། མ་ཊི་རེས་དང་མི་འདྲ་བ་ཞིག་ཡིན།ཁྱོད་ཚོར་ཚད་གཉིས་ཀྱི་ཡིག་ཆ་ཞིག་སྤྲོད་བཞིན་ཡོད། ཚད་གཉིས་ཀྱི་ཡིག་ཆ་ནི་སྦྲེལ་སྒྲིག་སྒྲིག་ (nested arrays) ཞིག་ཡིན།# >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n# >>> get_row.call([], 1)\n# []\n# >>> get_row.call([[], [1], [1, 2, 3]], 3)\n# [[2, 2]]\ndef get_row(lst, x)\n","canonical_solution":"def get_row(lst, x)\n  result = []\n\n  lst.each_with_index do |row, i|\n    row.each_with_index do |value, j|\n      result << [i, j] if value == x\n    end\n  end\n\n  result.sort_by { |coord| [coord[0], -coord[1]] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"},{"task_id":"HumanEval_88","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།* ཚད་གཞི་འདི་བསྒྱུར་མི་དགོས།དྲན་གསོ།ཡང་ན་བསྡོམས་ ((སྔོན་མའི་ཚད་གཞི་གནས་གོང་དང་རྗེས་མའི་ཚད་གཞི་གནས་གོང་) རྣམས་ཆ་སྙོམས་ཡིན་ན་རིམ་པ་མར་བབས་ནས་དབྱེ་བ་བྱེད་དགོས།ཁྱོད་ཀྱིས་གོ་རིམ་རིམ་བཞིན་གོ་རིམ་སྒྲིག་བྱེད་ན། སྐར་ཁུང་གི་གྲངས་ཐང་ནི་རྣམ་གྲངས་མེད་ན།འབྲས་བུ་མེད་པའི་ཧྲིལ་གྲངས་ཀྱི་རིམ་པ་ཐོབ་ན། རིམ་པ་སྒྲིག་རྗེས་རིམ་པ་ཐོབ་པའི་རིམ་པ་ཐོབ་པའི་རིམ་པ་སླར་ལོག་བྱ་དགོས།# >>> sort_array.call([])\n# []\n# >>> sort_array.call([5])\n# [5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5])\n# [0, 1, 2, 3, 4, 5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5, 6])\n# [6, 5, 4, 3, 2, 1, 0]\ndef sort_array(array)\n","canonical_solution":"def sort_array(array)\n  return array if array.empty? || array.size == 1\n\n  if (array.first + array.last).odd?\n    array.sort\n  else\n    array.sort.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([], candidate.call([]))\n    assert_equal([5], candidate.call([5]))\n    assert_equal([0, 1, 2, 3, 4, 5], candidate.call([2, 4, 3, 0, 1, 5]))\n    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2, 4, 3, 0, 1, 5, 6]))\n    assert_equal([1, 2], candidate.call([2, 1]))\n    assert_equal([0, 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))\n    assert_equal([23, 21, 14, 11], candidate.call([21, 14, 23, 11]))\n  end\nend\n"},{"task_id":"HumanEval_89","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: ཕྱོགས་གཉིས་སུ་སྤོ་དགོས།ཤོག་ངོས་འདི་ཡི་བཟོ་བཅོས་མཐའ་མ་༢༩༩༩ལ་འགྲུབ།ཕྱིར་ལོག་བྱེད་དེ་ཨང་ཡིག་བསྒྱུར་བའི་ནང་ཨང་ཡིག་སྦྲེལ་བ་ཞིག་ཡིན།ལས་འགན་ཞིག་བཟོ་ནས་རྟགས་མཚན་ལྟར་ཐིག་ཡིག་ཅིག་ལེན་ནས་ # >>> encrypt.call(\"hi\")\n# \"lm\"\n# >>> encrypt.call(\"asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt.call(\"gf\")\n# \"kj\"\n# >>> encrypt.call(\"et\")\n# \"ix\"\ndef encrypt(s)\n","canonical_solution":"def encrypt(s)\n  s.chars.map do |char|\n    if char =~ \/[a-z]\/\n      ((char.ord - 'a'.ord + 4) % 26 + 'a'.ord).chr\n    elsif char =~ \/[A-Z]\/\n      ((char.ord - 'A'.ord + 4) % 26 + 'A'.ord).chr\n    else\n      char\n    end\n  end.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\", candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"e\", candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_90","nl":"bod_Tibt","pl":"rb","prompt":"གལ་ཏེ་འདི་འདྲ་ཞིག་མེད་ན་ null སླར་ལོག་བྱེད།ཕྲད་གྲངས་གཉིས་པ་ཆུང་ཤོས་ཕྱིར་ལོག་བྱེད་ next_smallest () ལས་འགན་འབྲི་དགོས།ཁྱོད་ཚོར་ཧྲིལ་གྲངས་ཀྱི་རིམ་པ་ཐོབ་ཡོད།# >>> next_smallest.call([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest.call([5, 1, 4, 3, 2])\n# 2\n# >>> next_smallest.call([])\n# nil\n# >>> next_smallest.call([1, 1])\n# nil\ndef next_smallest(lst)\n","canonical_solution":"def next_smallest(lst)\n  unique_sorted = lst.uniq.sort\n  unique_sorted.length >= 2 ? unique_sorted[1] : nil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_next_smallest\n    candidate = method(:next_smallest)\n    assert_equal(2, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(1, candidate.call([1, 1, 1, 1, 0]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(-35, candidate.call([-35, 34, 12, -45]))\n  end\nend\n"},{"task_id":"HumanEval_91","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: ཚིག་ཡིག་ལ་མཐའ་མཚམས་སུ་ \"\", \"?\" ཡང་ན་ \"!\" ཟེར་བ་ཡོད།རྒྱུད་ཀྱི་འདུ་ཤེས་ནི་ \"ང་\" ཟེར་ནས་འགོ་འཛུགས་པའི་ཚིག་ཡིན།ཁྱོད་ཚོར་ཚིག་གྲངས་ཤིག་སྤྲད་ནས་ཁྱོད་རྣམས་ཀྱི་ལས་འགན་ནི་གྲངས་རྩིས་རྒྱག་རྒྱུ་རེད།# >>> is_bored.call(\"Hello world\")\n# 0\n# >>> is_bored.call(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\ndef is_bored(s)\n","canonical_solution":"def is_bored(s)\n  sentences = s.split(\/(?<=[.?!])\/)\n  sentences.count { |sentence| sentence.strip.start_with?('I') }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_bored\n    candidate = method(:is_bored)\n    assert_equal(0, candidate.call(\"Hello world\"))\n    assert_equal(0, candidate.call(\"Is the sky blue?\"))\n    assert_equal(1, candidate.call(\"I love It !\"))\n    assert_equal(0, candidate.call(\"bIt\"))\n    assert_equal(2, candidate.call(\"I feel good today. I will be productive. will kill It\"))\n    assert_equal(0, candidate.call(\"You and I are going for a walk\"))\n  end\nend\n"},{"task_id":"HumanEval_92","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།གཞན་གནས་སྟངས་གང་རུང་དུ་ false སླར་ལོག་བྱེད།གྲངས་ཆ་གཅིག་ནི་གཞན་གཉིས་གྱི་བསྡོམས་དང་མཚུངས་པ་ཡིན་ན་ true སླར་ལོག་བྱེད། གྲངས་ཆ་ཚང་མ་ནི་ཧྲིལ་པོ་ཡིན།གྲངས་ 3 ཅན་གྱི་ལས་འགན་ཞིག་བཟོས་པ།# >>> any_int.call(5, 2, 7)\n# true\n# >>> any_int.call(3, 2, 2)\n# false\n# >>> any_int.call(3, -2, 1)\n# true\n# >>> any_int.call(3.6, -2.2, 2)\n# false\ndef any_int(x, y, z)\n","canonical_solution":"def any_int(x, y, z)\n  if [x, y, z].all? { |n| n.is_a?(Integer) }\n    x == y + z || y == x + z || z == x + y\n  else\n    false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_any_int\n    candidate = method(:any_int)\n    assert_equal(true, candidate.call(2, 3, 1))\n    assert_equal(false, candidate.call(2.5, 2, 3))\n    assert_equal(false, candidate.call(1.5, 5, 3.5))\n    assert_equal(false, candidate.call(2, 6, 2))\n    assert_equal(true, candidate.call(4, 2, 2))\n    assert_equal(false, candidate.call(2.2, 2.2, 2.2))\n    assert_equal(true, candidate.call(-4, 6, 2))\n    assert_equal(true, candidate.call(2, 1, 1))\n    assert_equal(true, candidate.call(3, 4, 7))\n    assert_equal(false, candidate.call(3.0, 4, 7))\n  end\nend\n"},{"task_id":"HumanEval_93","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཡིག་འབྲུ་ཙམ་གྱིས་འཛིན་དགོས།ཨིང་ལིཤ་ཡི་གེ་ནང་གི་སྒྲ་སྒྲ་ཡིན།ཤོག་ངོས་འདི་ཡི་བཟོ་བཅོས་མཐའ་མ་༢ ནང་ལ་སྔར་གྱི་ནང་དོན་གསལ།ཀྱི་ནང་གི་སྒྲ་དབྱངས་ཚང་མ་བརྗེ་སྒྱུར་བྱེད་པ།འདྲ་བའི་འཕྲིན་ཡིག་ཞིག་ལེན་ནས་དེའི་ནང་ཡིག་རྟགས་བཀོད་པའི་ function ཞིག་འབྲི་དགོས།# >>> encode.call(\"test\")\n# \"TGST\"\n# >>> encode.call(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\ndef encode(message)\n","canonical_solution":"def encode(message)\n  vowels = 'aeiou'\n  swap_vowels = {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w'}\n  \n  encoded_message = message.chars.map do |char|\n    if vowels.include?(char.downcase)\n      new_char = swap_vowels[char.downcase]\n      char == char.upcase ? new_char.upcase : new_char.downcase\n    else\n      char == char.upcase ? char.downcase : char.upcase\n    end\n  end\n\n  encoded_message.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"},{"task_id":"HumanEval_94","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཁྱོད་ཀྱིས་ཆེ་མཐའི་སྔོན་གྲངས་འཚོལ་དགོས་པ་དང་དེའི་ཨང་གྲངས་ཀྱི་བསྡོམས་ཕྱིར་ལོག་དགོས།ཁྱོད་ཚོར་ཧྲིལ་གྲངས་ཀྱི་རིམ་པ་ཐོབ་ཡོད།# >>> skjkasdkd.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n# 10\n# >>> skjkasdkd.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n# 25\n# >>> skjkasdkd.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n# 13\n# >>> skjkasdkd.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n# 11\n# >>> skjkasdkd.call([0, 81, 12, 3, 1, 21])\n# 3\n# >>> skjkasdkd.call([0, 8, 1, 2, 1, 7])\n# 7\ndef skjkasdkd(lst)\n","canonical_solution":"def skjkasdkd(lst)\n  require 'prime'\n\n  # Find the largest prime number in the array\n  largest_prime = lst.select { |num| Prime.prime?(num) }.max\n  \n  # Return 0 if no prime number is found\n  return 0 if largest_prime.nil?\n\n  # Calculate the sum of digits of the largest prime number\n  largest_prime.to_s.chars.map(&:to_i).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_skjkasdkd\n    candidate = method(:skjkasdkd)\n    assert_equal(10, candidate.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))\n    assert_equal(25, candidate.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))\n    assert_equal(13, candidate.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))\n    assert_equal(11, candidate.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))\n    assert_equal(3, candidate.call([0, 81, 12, 3, 1, 21]))\n    assert_equal(7, candidate.call([0, 8, 1, 2, 1, 7]))\n    assert_equal(19, candidate.call([8191]))\n    assert_equal(19, candidate.call([8191, 123456, 127, 7]))\n    assert_equal(10, candidate.call([127, 97, 8192]))\n  end\nend\n"},{"task_id":"HumanEval_95","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ལས་འགན་འདི་ false སླར་ལོག་བྱེད་དགོས་པ་རེད་ན། བྱིན་ཡོད་པའི་ཧེཤ་ནི་སྟོང་པ་རེད།ཚད་ལྡན་ཡིག་རྟགས་གང་རུང་ནི་ string ཡིན། གལ་ཏེ་ཚད་ལྡན་ཡིག་རྟགས་གང་རུང་ནི་ string ཡིན། ཚད་ལྡན་ཡིག་རྟགས་གང་རུང་ནི་ string ཡིན། གལ་ཏེ་ཚད་ལྡན་ཡིག་རྟགས་གང་རུང་ནི་ string ཡིན། ཚད་ལྡན་ཡིག་རྟགས་གང་རུང་ནི་ string ཡིན།ཚད་ལྡན་ཧེཤ་ཐོབ་པ། གལ་ཏེ་ལྡེ་མིག་ཚང་མ་ནི་ lower  ནང་གི་ཐག་པ་ཡིན་ན་ true སླར་ལོག་བྱེད།# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n","canonical_solution":"def check_dict_case(dict)\n  return false if dict.empty?\n\n  lowercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.downcase }\n  uppercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.upcase }\n\n  lowercase_keys || uppercase_keys\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n"},{"task_id":"HumanEval_96","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: གྲངས་ཚོམ་དང་ n ལས་ཆུང་བ་དག་གི་གྲངས་ཚོམ་ཡིན།འབྲས་བུ་མེད་པའི་གྲངས་ཀ་ཧྲིལ་པོ་ལེན་ནས་སྔོན་གྱི་གྲངས་ཀ་ n  ཡོད་པའི་གྲངས་ཀ་གཞི་བསྟུན་ཕྱིར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་ལག་བསྟར་བྱ་དགོས།# >>> count_up_to.call(5)\n# [2, 3]\n# >>> count_up_to.call(11)\n# [2, 3, 5, 7]\n# >>> count_up_to.call(0)\n# []\n# >>> count_up_to.call(20)\n# [2, 3, 5, 7, 11, 13, 17, 19]\n# >>> count_up_to.call(1)\n# []\n# >>> count_up_to.call(18)\n# [2, 3, 5, 7, 11, 13, 17]\ndef count_up_to(n)\n","canonical_solution":"def count_up_to(n)\n  return [] if n <= 2\n  primes = []\n  (2...n).each do |num|\n    is_prime = true\n    (2..Math.sqrt(num)).each do |i|\n      if num % i == 0\n        is_prime = false\n        break\n      end\n    end\n    primes << num if is_prime\n  end\n  primes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_up_to\n    candidate = method(:count_up_to)\n    assert_equal([2, 3], candidate.call(5))\n    assert_equal([2, 3, 5], candidate.call(6))\n    assert_equal([2, 3, 5], candidate.call(7))\n    assert_equal([2, 3, 5, 7], candidate.call(10))\n    assert_equal([], candidate.call(0))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))\n    assert_equal([], candidate.call(1))\n    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))\n  end\nend\n"},{"task_id":"HumanEval_97","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ནང་འཇུག་གཏན་ལ་ཕབ་ནས་གཏན་ལ་ཕབ་དགོས།ཚད་ལྡན་ཨང་གྲངས་ཀྱི་འབྲས་བུ་ཡིན།འབྲས་བུ་གྲངས་ཆ་གཉིས་ལེན་པའི་ function ཆ་ཚང་སྒྲིལ་ནས་ཕྱིར་ལོག་བྱེད་པ།# >>> multiply.call(148, 412)\n# 16\n# >>> multiply.call(19, 28)\n# 72\n# >>> multiply.call(2020, 1851)\n# 0\n# >>> multiply.call(14, -15)\n# 20\ndef multiply(a, b)\n","canonical_solution":"def multiply(a, b)\n  a_unit_digit = a.abs % 10\n  b_unit_digit = b.abs % 10\n  a_unit_digit * b_unit_digit\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_multiply\n    candidate = method(:multiply)\n    assert_equal(16, candidate.call(148, 412))\n    assert_equal(72, candidate.call(19, 28))\n    assert_equal(0, candidate.call(2020, 1851))\n    assert_equal(20, candidate.call(14, -15))\n    assert_equal(42, candidate.call(76, 67))\n    assert_equal(49, candidate.call(17, 27))\n    assert_equal(0, candidate.call(0, 1))\n    assert_equal(0, candidate.call(0, 0))\n  end\nend\n"},{"task_id":"HumanEval_98","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: string s ཤིག་ཡོད་ན། ཆེ་ཆུང་གི་སྒྲ་སྒྲ་གྲངས་རྩིས་ཤིག# >>> count_upper.call(\"aBCdEf\")\n# 1\n# >>> count_upper.call(\"abcdefg\")\n# 0\n# >>> count_upper.call(\"dBBE\")\n# 0\ndef count_upper(s)\n","canonical_solution":"def count_upper(s)\n  vowels = ['A', 'E', 'I', 'O', 'U']\n  count = 0\n\n  s.chars.each_with_index do |char, index|\n    if index.even? && vowels.include?(char)\n      count += 1\n    end\n  end\n\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"EEEE\"))\n  end\nend\n"},{"task_id":"HumanEval_99","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།འབྲས་བུ་འདི་ནི་གྲངས་ཆ་གཉིས་ལས་ 0 ཀྱི་མཐའ་འཁོར་དུ་འཁོར་བ་ཡིན།གྲངས་ཀ་ཉེར་མཁོ་ཡོད་ན་ ཚད་ལྡན་གྲངས་ཀ་ཉེར་མཁོ་ཡོད་ན་ ཚད་ལྡན་གྲངས་ཀ་ཉེར་མཁོ་ཡོད་ན་ ཚད་ལྡན་གྲངས་ཀ་ཉེར་མཁོ་ཡོད་ན་གྲངས་ཐང་ (string) ཞིག་ངོས་འཛིན་བྱ་བའི་ལས་འགན་ཞིག་བཟོ།# >>> closest_integer.call(\"10\")\n# 10\n# >>> closest_integer.call(\"15.3\")\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\ndef closest_integer(value)\n","canonical_solution":"def closest_integer(value)\n  number = value.to_f\n  if number > 0\n    (number + 0.5).floor\n  else\n    (number - 0.5).ceil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_100","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།i ནི་ཚད་ (i+1) ནང་གི་རྡོ་གྲངས་མཚོན་པ་ཡིན།ཚད་གཞི་ནང་ཡོད་པའི་རྡོའི་གྲངས་ཁ་སླར་ལོག་འབདཝ་ཨིན།- རྗེས་སུ་ཡོད་པའི་གྲངས་ཆ་ཆ་ཡིན་ན། n ནི་ཆ་ཆ་ཡིན་ན།- རྗེས་སུ་ཡོད་པའི་གྲངས་ཆ་རྐྱང་པ་ n ནི་གྲངས་ཆ་རྐྱང་པ་ཡིན་ན་ཤུལ་མའི་གནས་ཚད་ནང་རྡོ་གྲངས་ནི་:ཐོག་མར་རྡོ་ n ཡིན།གྲངས་ཧྲིལ་པོ་ n ཞིག་ཡོད་ན། རྡོ་རིང་གི་ཚད་ n ཡི་རྡོ་བྲིས་དགོས།# >>> make_a_pile.call(3)\n# [3, 5, 7]\ndef make_a_pile(n)\n","canonical_solution":"def make_a_pile(n)\n  result = []\n  current_stones = n\n  n.times do\n    result << current_stones\n    current_stones += 2\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_a_pile\n    candidate = method(:make_a_pile)\n    assert_equal([3, 5, 7], candidate.call(3))\n    assert_equal([4, 6, 8, 10], candidate.call(4))\n    assert_equal([5, 7, 9, 11, 13], candidate.call(5))\n    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))\n    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))\n  end\nend\n"},{"task_id":"HumanEval_101","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: string འདི་ཚིག་གི་ཆ་ཤས་སུ་དབྱེ་ནས་ཚིག་གི་རིམ་པ་ཕྱིར་ལོག་བྱེད་པ།ཁྱོད་ཚོར་ཚིག་ཡིག་གི་རིམ་པ་སྤྲོད་རྒྱུ་རེད། རྒྱུན་དང་བར་སྟོང་གིས་སོ་སོར་དབྱེ་དགོས། ཁྱོད་ཀྱི་ལས་འགན་ནི་# >>> words_string.call(\"Hi, my name is John\")\n# [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# >>> words_string.call(\"One, two, three, four, five, six\")\n# [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\ndef words_string(s)\n","canonical_solution":"def words_string(s)\n  s.split(\/[\\s,]+\/)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_string\n    candidate = method(:words_string)\n    assert_equal([\"Hi\", \"my\", \"name\", \"is\", \"John\"], candidate.call(\"Hi, my name is John\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One, two, three, four, five, six\"))\n    assert_equal([\"Hi\", \"my\", \"name\"], candidate.call(\"Hi, my name\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One,, two, three, four, five, six,\"))\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"ahmed\", \"gamal\"], candidate.call(\"ahmed     , gamal\"))\n  end\nend\n"},{"task_id":"HumanEval_102","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: གྲངས་ཀ་དེ་མེད་ན་ function དེ་ -1 སླར་ལོག་བྱེད་དགོས།ཚད་ [x, y] ནང་གི་གྲངས་ཆ་ཚག་གྲངས་ཆེ་ཤོས་ཡིན་ན།ལས་འགན་འདི་ནི་གྲངས་ཆ་ལྡོག་པ་གཉིས་ x དང་ y དང་ཕྱིར་ལོག་བྱེད་གྲངས་ཐང་ཡིན།# >>> choose_num.call(12, 15)\n# 14\n# >>> choose_num.call(13, 12)\n# -1\ndef choose_num(x, y)\n","canonical_solution":"def choose_num(x, y)\n  return -1 if x > y\n  # Start looking from the largest number\n  max_even = y.even? ? y : y - 1\n  # Iterate downwards to find the biggest even number\n  max_even.downto(x) do |n|\n    return n if n.even?\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_choose_num\n    candidate = method(:choose_num)\n    assert_equal(14, candidate.call(12, 15))\n    assert_equal(-1, candidate.call(13, 12))\n    assert_equal(12354, candidate.call(33, 12354))\n    assert_equal(-1, candidate.call(5234, 5233))\n    assert_equal(28, candidate.call(6, 29))\n    assert_equal(-1, candidate.call(27, 10))\n    assert_equal(-1, candidate.call(7, 7))\n    assert_equal(546, candidate.call(546, 546))\n  end\nend\n"},{"task_id":"HumanEval_103","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། གལ་ཏེ་ n ནི་ m ལས་ཆེ་བ་ཡིན་ན་ -1 སླར་ལོག་བྱེད་དགོས།དེའི་ལན་དེ་ཉེར་མཁོ་པའི་གྲངས་ཆ་ཆ་ཚང་དང་ཉེར་མཁོ་གྲངས་ཆ་གཉིས་སུ་བསྒྱུར་དགོས།n ནས་ m བར་གྱི་གྲངས་ཐང་གི་བར་ནའི་བར་ནའི་གྲངས་ཐང་ (n དང་ m བཅས་ཀྱང་མཉམ་ཡོད།)ཁྱོད་ཚོར་ n དང་ m ཟེར་བའི་གྲངས་ཆ་ཧྲིལ་པོ་གཉིས་ཐོབ་ཡོད། ཁྱོད་ཀྱི་ལས་འགན་ནི་ # >>> rounded_avg.call(1, 5)\n# \"0b11\"\n# >>> rounded_avg.call(7, 5)\n# -1\n# >>> rounded_avg.call(10, 20)\n# \"0b1111\"\n# >>> rounded_avg.call(20, 33)\n# \"0b11010\"\ndef rounded_avg(n, m)\n","canonical_solution":"def rounded_avg(n, m)\n  return -1 if n > m\n\n  sum = (n..m).reduce(:+)\n  count = m - n + 1\n  average = (sum.to_f \/ count).round\n  \"0b\" + average.to_i.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1, 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996, 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362, 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7, 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5, 5))\n  end\nend\n"},{"task_id":"HumanEval_104","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: དྲན་གསོ། སླར་ལོག་བྱས་པའི་རིམ་པ་རིམ་བཞིན་རིམ་པ་སྒྲིག་དགོས།ཇི་ཡོད་ཆ་ཤས་ལ་ཆ་སྙོམ་གྲངས་མེད་པ།འབྲས་བུ་ཧྲིལ་གྲངས་ x གི་རིམ་པ་ཅན་གྱི་རིམ་པ་སླར་ལོག་བྱ་བ།# >>> unique_digits.call([15, 33, 1422, 1])\n# [1, 15, 33]\n# >>> unique_digits.call([152, 323, 1422, 10])\n# []\ndef unique_digits(x)\n","canonical_solution":"def unique_digits(x)\n  x.select { |num| num.to_s.chars.none? { |digit| digit.to_i.even? } }.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15, 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n    assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31, 135], candidate.call([135, 103, 31]))\n  end\nend\n"},{"task_id":"HumanEval_105","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: ༡། ༢། ༣། ༤། ༥། ༦། ༧། ༨། ༩།འབྲས་བུ་ཐོན་པའི་རིམ་པ་རྒྱབ་སྒྱུར་བྱེད་ནས་ ཤོག་གྲངས་རེ་རེར་དེའི་མིང་དང་འབྲེལ་བའི་མིང་ཚབ་སྤྲོད་དགོས།འདིར་གྲངས་ཆ་ཆ་ཚང་གྲངས་ཐང་ཞིག་ཡོད་ན། ༡ དང་ ༩ བར་གྱི་གྲངས་ཆ་ཚང་མ་དབྱེ་དགོས།# >>> by_length.call([2, 1, 1, 4, 5, 8, 2, 3])\n# [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n# If the array is empty, return an empty array:\n# >>> by_length.call([])\n# []\n# If the array has any strange number ignore it:\n# >>> by_length.call([1, -1, 55])\n# [\"One\"]\ndef by_length(arr)\n","canonical_solution":"def by_length(arr)\n  number_names = {\n    1 => \"One\",\n    2 => \"Two\",\n    3 => \"Three\",\n    4 => \"Four\",\n    5 => \"Five\",\n    6 => \"Six\",\n    7 => \"Seven\",\n    8 => \"Eight\",\n    9 => \"Nine\"\n  }\n\n  filtered_sorted_reversed = arr.select { |x| x.between?(1, 9) }.sort.reverse\n  filtered_sorted_reversed.map { |num| number_names[num] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_by_length\n    candidate = method(:by_length)\n    assert_equal([\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], candidate.call([2, 1, 1, 4, 5, 8, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([\"One\"], candidate.call([1, -1, 55]))\n    assert_equal([\"Three\", \"Two\", \"One\"], candidate.call([1, -1, 3, 2]))\n    assert_equal([\"Nine\", \"Eight\", \"Four\"], candidate.call([9, 4, 8]))\n  end\nend\n"},{"task_id":"HumanEval_106","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། i གི་ཕྲེང་བ་ནི་ 1 ནས་ i བར་གྱི་གྲངས་ཀྱི་ལྡབ་གྲངས་ཡིན། (1 * 2 * ... * i)i 1 ནས་འགོ་ཚུགས།ཡང་ན་ 1 ནས་ i བར་གྱི་གྲངས་ཐང་གི་བསྡོམས་ཡིན་ན།ཚད་ནི་ n ཡིན་པའི་གྲངས་ཐང་ཕྱིར་ལོག་བྱེད་ཅིང་། ཚད་གཞི་ i ནང་ཡོད་པའི་གྲངས་ཐང་ནི་ i གྱི་གྲངས་ཐང་ཡིན་པའི་ཆ་ཤས་ཡིན་པའི་ཆ་ཤས་ཡིན་པའི་ཆ་ཤས་ཡིན་པའི་ཆ་ཤས་ཡིན།ཚད་གཞི་ n སྦེ་ལེན་པའི་ function f འདི་ལག་ལེན་བསྟར་དགོས།# >>> f.call(5)\n# [1, 2, 6, 24, 15]\ndef f(n)\n","canonical_solution":"def f(n)\n  (1..n).map do |i|\n    if i.even?\n      (1..i).inject(:*) || 1\n    else\n      (1..i).inject(:+)\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_f\n    candidate = method(:f)\n    assert_equal([1, 2, 6, 24, 15], candidate.call(5))\n    assert_equal([1, 2, 6, 24, 15, 720, 28], candidate.call(7))\n    assert_equal([1], candidate.call(1))\n    assert_equal([1, 2, 6], candidate.call(3))\n  end\nend\n"},{"task_id":"HumanEval_107","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཞི་དང་པོ།སྐར་གྲངས་ཀྱི་ནང་པའི་ཧྲིལ་གྲངས་ཀྱི་ཚད་གཞི་ (n) དང་།འབྲས་བུ་གྲངས་ཆ་ཚག་ n ཞིག་ཡོད་ན། གྲངས་ཆ་ཚག་དང་གྲངས་ཆ་ཆ་མི་ཚག་ ཡོད་པའི་གྲངས་གཞི་ཅིག་ཕྱིར་སློག་བྱ་དགོས།# >>> even_odd_palindrome.call(3)\n# [1, 2]\n# Explanation:\n# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# >>> even_odd_palindrome.call(12)\n# [4, 6]\n# Explanation:\n# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n# 1. 1 <= n <= 10^3\n# 2. returned array has the number of even and odd integer palindromes respectively.\ndef even_odd_palindrome(n)\n","canonical_solution":"def even_odd_palindrome(n)\n  even_count = 0\n  odd_count = 0\n\n  (1..n).each do |num|\n    if num.to_s == num.to_s.reverse\n      if num.even?\n        even_count += 1\n      else\n        odd_count += 1\n      end\n    end\n  end\n\n  [even_count, odd_count]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_palindrome\n    candidate = method(:even_odd_palindrome)\n    assert_equal([8, 13], candidate.call(123))\n    assert_equal([4, 6], candidate.call(12))\n    assert_equal([1, 2], candidate.call(3))\n    assert_equal([6, 8], candidate.call(63))\n    assert_equal([5, 6], candidate.call(25))\n    assert_equal([4, 6], candidate.call(19))\n    assert_equal([4, 5], candidate.call(9))\n    assert_equal([0, 1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_108","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན། -123 ནང་གི་ཨང་རྟགས་ནི་ -1, 2, 3 ཡིན།གྲངས་ཆ་འདི་ཆ་མེད་ཡིན་ན། དེའི་སྔོན་གྱི་ཨང་རྟགས་ནི་ཆ་མེད་ཡིན་: ཤོག་གྲངས་ཀྱི་གྲངས་ཐང་ནི་ 0 སྟེང་གི་ཨང་གྲངས་ཀྱི་བསྡོམས་གྲངས་ཡིན།གྲངས་ཚིགས་གྲངས་ཐང་གི་རིམ་པ་ལེན་ནས་སླར་ལོག་བྱ་བའི་ལས་འགན་ count_nums ཡིག་སྒྱུར་བྱོས།# >>> count_nums.call([])\n# 0\n# >>> count_nums.call([-1, 11, -11])\n# 1\n# >>> count_nums.call([1, 1, 2])\n# 3\ndef count_nums(arr)\n","canonical_solution":"def count_nums(arr)\n  arr.count do |num|\n    num.to_s.chars.map(&:to_i).sum > 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_nums\n    candidate = method(:count_nums)\n    assert_equal(0, candidate.call([]))\n    assert_equal(0, candidate.call([-1, -2, 0]))\n    assert_equal(6, candidate.call([1, 1, 2, -2, 3, 4, 5]))\n    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))\n    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))\n    assert_equal(5, candidate.call([12, 23, 34, -45, -56, 0]))\n    assert_equal(1, candidate.call([0, 1]))\n    assert_equal(1, candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_109","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་མཚོན།: Note: འདིར་བཀོད་པའི་གཞི་རིམ་ལ་ཆ་རྐྱེན་གཅིག་པུ་ཡོད་ངེས་གཏན་འདུགགལ་ཏེ་ array འདིར་སྟོང་པ་ཡོད་ན་ true སླར་ལོག་བྱེད།དེ་ནས་ true སླར་ལོག་བྱེད། ཡང་ན་ false སླར་ལོག་བྱེད།གོང་གི་བྱ་རིམ་ལྟར་རིམ་སྒྲིག་བྱས་པའི་ཐིག་ཁྲམ་དེ་ཐོབ་ཐུབ་ན།ཚད་གཞི་ 0 པའི་ནང་གཞི་རྟེན་གྱི་གནས་བབ་ཚད་གཞི་མཐའ་མ་དེ་ ཕྱོགས་གང་སར་སྤོ་དགོས།གཡས་ཕྱོགས་བསྐྱོད་བྱ་རིམ་གཅིག་གིས་ array གི་ཆ་ཤས་ཚང་མ་ 1 ཀྱིས་བསྐྱོད་པར་བྱེད།ཁྱོད་ཀྱིས་གཡས་གཡོན་དུ་འགྲོ་བར་ཐེངས་ཇི་ཙམ་འགོར་རུང་།ཇི་བཞིན་ལག་ལེན་འདི་བཞིན་ array ནང་འཇུག་བྱེད་པ།བྱེད་ནུས་ཀྱིས་རིམ་པ་མི་ཉམས་པའི་རིམ་པ་བཞིན་རིམ་པ་སྒྲིག་ཐུབ་པ་ཡོད།ཚད་གཞི་ནང་གི་གྲངས་ནི་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་གཏན་ནས་གཏན་གཏན་ནས་གཏན་གཏན་ནས་གཏན་གཏན་ནས་གཏན་གཏན་ནས་གཏན་གཏན་ནས་གཏན་གཏན་ནས་གཏན་གཏན་ནས་གཏན་གཏན་ནས་གཏན་གཏན་ནས་གཏན་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་ནས་གཏན་གཏན་གཏན་འདིར་ 'arr' ཟེར་བའི་གྲངས་ཐང་ N ཡི་གྲངས་ཐང་ arr[1], arr[2], ..., arr[N] ཡོད་པ་རེད།# >>> move_one_ball.call([3, 4, 5, 1, 2])\n# true\n# Explanation: By performin 2 right shift operations, non-decreasing order can\n# be achieved for the given array.\n# >>> move_one_ball.call([3, 5, 4, 1, 2])\n# false\n# Explanation:It is not possible to get non-decreasing order for the given\n# array by performing any number of right shift operations.\ndef move_one_ball(arr)\n","canonical_solution":"def move_one_ball(arr)\n  return true if arr.empty?\n\n  n = arr.size\n  count_rotation_point = 0\n  rotation_index = -1\n\n  (0...n).each do |i|\n    next_index = (i + 1) % n\n    if arr[i] > arr[next_index]\n      count_rotation_point += 1\n      rotation_index = next_index\n    end\n  end\n\n  count_rotation_point <= 1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_move_one_ball\n    candidate = method(:move_one_ball)\n    assert_equal(true, candidate.call([3, 4, 5, 1, 2]))\n    assert_equal(true, candidate.call([3, 5, 10, 1, 2]))\n    assert_equal(false, candidate.call([4, 3, 1, 2]))\n    assert_equal(false, candidate.call([3, 5, 4, 1, 2]))\n    assert_equal(true, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_110","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: དེ་མིན་ \"NO\" ཕྱིར་སློག་བྱོས།lst1 ནང་གི་ཆ་ཤས་ཚང་མ་ཆ་སྙོམས་ཡིན་ན། \"YES\" སླར་ལོག་བྱེད་དགོས།ཕྱོགས་མཚུངས་ཀྱི་ཆ་རྐྱེན་ཞིག་ཡིན་ན།lst1 དང་ lst2 བར་བརྗེ་ལེན་བྱེད་རྒྱུའི་ཆ་ཤས་གྲངས་ཚད་མེད་ཡིན།ཇི་འདྲ་ཡིན་ན། ཇི་འདྲ་ཡིན་རུང་།འདྲ་པར་བརྗེ་ལེན་བྱེད་ཆོག་མིན་ལ་དཔྱད་པ།འདིར་ཁྱེད་ཚོས་གྲངས་ཀྱི་རིམ་པ་གཉིས་ལེན་པའི་ལས་འགན་ཞིག་ལག་ལེན་བྱེད་རྒྱུ་ཡིན།# >>> exchange.call([1, 2, 3, 4], [1, 2, 3, 4])\n# \"YES\"\n# >>> exchange.call([1, 2, 3, 4], [1, 5, 3, 4])\n# \"NO\"\n# It is assumed that the input arrays will be non-empty.\ndef exchange(lst1, lst2)\n","canonical_solution":"def exchange(lst1, lst2)\n  # Check if lst1 already consists solely of even numbers\n  return \"YES\" if lst1.all?(&:even?)\n\n  # Check if there are at least as many even numbers in lst2\n  # as there are odd numbers in lst1\n  odd_count_lst1 = lst1.count(&:odd?)\n  even_count_lst2 = lst2.count(&:even?)\n\n  odd_count_lst1 <= even_count_lst2 ? \"YES\" : \"NO\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_exchange\n    candidate = method(:exchange)\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [1, 2, 3, 4]))\n    assert_equal(\"NO\", candidate.call([1, 2, 3, 4], [1, 5, 3, 4]))\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [2, 1, 4, 3]))\n    assert_equal(\"YES\", candidate.call([5, 7, 3], [2, 6, 4]))\n    assert_equal(\"NO\", candidate.call([5, 7, 3], [2, 6, 3]))\n    assert_equal(\"NO\", candidate.call([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))\n    assert_equal(\"YES\", candidate.call([100, 200], [200, 200]))\n  end\nend\n"},{"task_id":"HumanEval_111","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། གལ་ཏེ་ཡིག་རྟགས་མང་པོ་ཞིག་འདྲ་མཚུངས་བྱུང་ན་ཡིག་རྟགས་ཚང་མ་ཕྱིར་སློག་བྱེད་དགོས།ཤོག་གྲངས་གང་ཞིག་ལ་ཨང་གྲངས་མང་ཤོས་དང་དེའི་ནང་གྲངས་རྩིས་ཡོད་ན་དེའི་ནང་ཡིག་འབྲུ་གང་ཞིག་ཡོད་ན་དེའི་ནང་འཇུག་དགོས།སྐར་ཁུང་གི་ཡིག་འབྲུ་ཆུང་ཆུང་གཉིས་སུ་དབྱེ་བའི་ཡིག་འབྲུ་ ཞིག་ཡོད་ན། ཧེཤ་ (hash) སླར་ལོག་བྱེད་དགོས།# >>> histogram.call(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" => 1}\n# >>> histogram.call(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"b b b b a\")\n# {\"b\" => 4}\n# >>> histogram.call(\"\")\n# {}\ndef histogram(test)\n","canonical_solution":"def histogram(test)\n  return {} if test.empty?\n\n  count = Hash.new(0)\n\n  test.split.each do |char|\n    count[char] += 1\n  end\n\n  max_count = count.values.max\n  count.select { |_, value| value == max_count }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1, \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4}, candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_112","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཚོད་ལྟ་བྱེད་སྐབས་འབྲས་བུ་ string དང་ true\/false ཡོད་པའི་ array སླར་ལོག་བྱེད་དགོས།string འདི་ལ་ palindrome ཞེས་ཟེར་བ་ནི། ཕྱིར་དང་མདུན་གྱི་གོ་དོན་འདྲ་མཚུངས་ཡིན་ན།འབྲས་བུ་ནི་ palindrome ཡིན་མིན་ལ་བརྟག་དཔྱད་བྱེད་དགོས།འདིར་ s དང་ c གཉིས་ཀྱི་ཡིག་འབྲུ་གཉིས་ཡོད། ཁྱོད་ཀྱིས་ s ནང་གི་ཡིག་འབྲུ་གང་འདྲ་ཞིག་ c ནང་གི་ཡིག་འབྲུ་གང་འདྲ་ཞིག་དང་མཚུངས་པ་ཚང་མ་སེལ་དགོས།ལས་འགན་ # >>> reverse_delete.call(\"abcde\", \"ae\")\n# [\"bcd\", false]\n# >>> reverse_delete.call(\"abcdef\", \"b\")\n# [\"acdef\", false]\n# >>> reverse_delete.call(\"abcdedcba\", \"ab\")\n# [\"cdedc\", true]\ndef reverse_delete(s, c)\n","canonical_solution":"def reverse_delete(s, c)\n  # Remove all characters in c from s\n  filtered_string = s.delete(c)\n  \n  # Check if the filtered string is a palindrome\n  is_palindrome = filtered_string == filtered_string.reverse\n  \n  # Return the result array\n  [filtered_string, is_palindrome]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_reverse_delete\n    candidate = method(:reverse_delete)\n    assert_equal([\"bcd\", false], candidate.call(\"abcde\", \"ae\"))\n    assert_equal([\"acdef\", false], candidate.call(\"abcdef\", \"b\"))\n    assert_equal([\"cdedc\", true], candidate.call(\"abcdedcba\", \"ab\"))\n    assert_equal([\"dik\", false], candidate.call(\"dwik\", \"w\"))\n    assert_equal([\"\", true], candidate.call(\"a\", \"a\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"v\"))\n    assert_equal([\"abba\", true], candidate.call(\"vabba\", \"v\"))\n    assert_equal([\"\", true], candidate.call(\"mamma\", \"mia\"))\n  end\nend\n"},{"task_id":"HumanEval_113","nl":"bod_Tibt","pl":"rb","prompt":"ཇི་ཇི་ཨང་གྲངས་ནང་ཐིག་གྲངས་གྲངས་ཀྱི་གྲངས་ཆ་མི་འདྲ་བ་ཡོད་ན།ནང་འཇུག་གི་ string i ཟེར་བའི་ནང་ i ཚང་མ་གྲངས་ཀ་ ཀྱིས་ཚབ་ཏུ་འཇུག་དགོས།ཕྱིར་ཐོན་གྱི་ཆ་ཤས་ i ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་string ཀྱི་གྲངས་ཐང་ཡིན་པའི་ནང་ string ཚང་མ་ནི་ཨང་གྲངས་ཀྱི་གྲངས་ཐང་ཡིན་པའི་གོ་རིམ་དེ་སླར་ལོག་བྱ་དགོས།# >>> odd_count.call([\"1234567\"])\n# [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n# >>> odd_count.call([\"3\", \"11111111\"])\n# [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\ndef odd_count(lst)\n","canonical_solution":"def odd_count(lst)\n  lst.map do |num_str|\n    count = num_str.count('13579')\n    \"the number of odd elements #{count}n the str#{count}ng #{count} of the #{count}nput.\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_odd_count\n    candidate = method(:odd_count)\n    assert_equal([\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], candidate.call([\"1234567\"]))\n    assert_equal([\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], candidate.call([\"3\", \"11111111\"]))\n    assert_equal([\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"], candidate.call([\"271\", \"137\", \"314\"]))\n  end\nend\n"},{"task_id":"HumanEval_114","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཀྱི་གྲངས་ཀ་ཡིན།སྐར་གྲངས་ n གི་རིམ་པ་ཐོབ་ན། སྟོང་པ་མིན་པའི་རིམ་པ་ཆུང་ཤོས་ཀྱི་བསྡོམས་གྲངས་འཚོལ་དགོས།# >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])\n# 1\n# >>> minSubArraySum.call([-1, -2, -3])\n# -6\ndef minSubArraySum(nums)\n","canonical_solution":"def minSubArraySum(nums)\n  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    if current_sum > 0\n      current_sum = num\n    else\n      current_sum += num\n    end\n    min_sum = [min_sum, current_sum].min\n  end\n  min_sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minSubArraySum\n    candidate = method(:minSubArraySum)\n    assert_equal(1, candidate.call([2, 3, 4, 1, 2, 4]))\n    assert_equal(-6, candidate.call([-1, -2, -3]))\n    assert_equal(-14, candidate.call([-1, -2, -3, 2, -10]))\n    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))\n    assert_equal(0, candidate.call([0, 10, 20, 1000000]))\n    assert_equal(-6, candidate.call([-1, -2, -3, 10, -5]))\n    assert_equal(-6, candidate.call([100, -1, -2, -3, 10, -5]))\n    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))\n    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))\n    assert_equal(-10, candidate.call([-10]))\n    assert_equal(7, candidate.call([7]))\n    assert_equal(-1, candidate.call([1, -1]))\n  end\nend\n"},{"task_id":"HumanEval_115","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཞི་དང་པོ།སྦ་སྒོར་ཕབ་དགོས་པའི་དུས་གྲངས་འདེམས་དགོས།ཁྱོད་ཚོར་ལས་འགན་ནི་ཆུ་མཛོད་རྣམས་ཆུ་ཟམ་ནས་ཆུ་བསྐོལ་བའི་ཆེད་དུ་སླ་པོ་རྣམས་བེད་སྤྱོད་བྱེད་རྒྱུ་དེ་ཡིན།ཚང་མ་ཁོར་ཡུག་འདྲ་མཉམ་ཡོད།ཆུ་དོང་རེ་རེར་ཆུ་རྫིང་རེ་ཡོད་དེ། ཆུ་དེ་ནས་ཆུ་བཏོན་པའི་ཆེད་དུ་བེད་སྤྱོད་བྱེད་ཆོགཤོག་ངོས་རེ་རེའི་ནང་ 1 ཟེར་བ་ནི་ཆུ་གི་ཆ་ཤས་གཅིག་ཡིན་པ་མཚོན་པ་ཡིན།ཁྱོད་ཚོར་ཆུ་རྐ་གྲུ་བཞི་ཅན་གྱི་དྲ་རྒྱ་ཞིག་སྤྲོད་ཡོད། རེའུ་མིག་རེ་རེར་ཆུ་རྐ་གཅིག་རང་ཡོད།# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example 2:\n# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill.call([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\ndef max_fill(grid, capacity)\n","canonical_solution":"def max_fill(grid, capacity)\n  total_water_units = grid.flatten.sum\n  (total_water_units.to_f \/ capacity).ceil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0, candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 9))\n  end\nend\n"},{"task_id":"HumanEval_116","nl":"bod_Tibt","pl":"rb","prompt":"འདྲ་བཤུས་འདི་བཞིན་ལག་ལེན་བྱ་དགོས།འདྲ་མཉམ་གྲངས་སུ་གཅིག་ཡོད་ན། བཅུ་ཚིགས་ཀྱི་རིན་ཐང་ཐོག་ནས་དབྱེ་བ་དགོས།ཤོག་གྲངས་གཉིས་པའི་ནང་གྲངས་གྲངས་ཡར་སེང་གི་རིམ་པ་བཞིན་ཡོད།འདིར་ཁྱོད་ཀྱིས་ ཤོག་གྲངས་ སྐྱོན་མེད་ཀྱི་གྲངས་ཐང་ ཇི་འདྲ་ཡིན་མིན་ལ་དབྱེ་དགོས།# >>> sort_array.call([1, 5, 2, 3, 4])\n# [1, 2, 3, 4, 5]\n# >>> sort_array.call([-2, -3, -4, -5, -6])\n# [-6, -5, -4, -3, -2]\n# >>> sort_array.call([1, 0, 2, 3, 4])\n# [0, 1, 2, 3, 4]\ndef sort_array(arr)\n","canonical_solution":"def sort_array(arr)\n  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([1, 2, 4, 3, 5], candidate.call([1, 5, 2, 3, 4]))\n    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3, -4, -5, -6]))\n    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))\n    assert_equal([], candidate.call([]))\n    assert_equal([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))\n    assert_equal([32, 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n  end\nend\n"},{"task_id":"HumanEval_117","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།Note: ཁྱོད་ཀྱིས་ནང་འཇུག་ string ནང་ཡིག་རྟགས་དང་བར་སྟོང་མ་གཏོགས་གཞན་མེད་ཟེར་ངེས་ཐུབ།གལ་ཏེ་ string s ནི་སྟོང་པ་ཡིན་ན་ function ཀྱིས་སྟོང་པའི་ array སླར་ལོག་བྱ་དགོས།n ཟུར་སྒྲ་རྣམས་རིམ་བཞིན་སོར་ལྡོག་བྱེད་ནས་ ཚིག་རྣམས་རིམ་བཞིན་སོར་ལྡོག་བྱེད་ནས་སོར་ལྡོག་བྱེད་ཡོད།ཚད་ལྡན་ཚིག་ཡིག་ s ནང་གི་ཚིག་ཡིག་ཚང་མ་ཡོད་པའི་ཡིག་གཟུགས་ཤིག་ཕྱིར་ལོག་བྱེད་པ།string s དང་ natural number n ཞིག་ཡོད་ན། ཁྱོད་ཚོར་ལག་ལེན་བྱེད་རྒྱུའི་འགན་ཁུར་ཡོད།# >>> select_words.call(\"Mary had a little lamb\", 4)\n# [\"little\"]\n# >>> select_words.call(\"Mary had a little lamb\", 3)\n# [\"Mary\", \"lamb\"]\n# >>> select_words.call(\"simple white space\", 2)\n# []\n# >>> select_words.call(\"Hello world\", 4)\n# [\"world\"]\n# >>> select_words.call(\"Uncle sam\", 3)\n# [\"Uncle\"]\ndef select_words(s, n)\n","canonical_solution":"def select_words(s, n)\n  vowels = \"aeiouAEIOU\"\n  words = s.split\n  words.select do |word|\n    consonant_count = word.chars.count { |char| !vowels.include?(char) }\n    consonant_count == n\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_select_words\n    candidate = method(:select_words)\n    assert_equal([\"little\"], candidate.call(\"Mary had a little lamb\", 4))\n    assert_equal([\"Mary\", \"lamb\"], candidate.call(\"Mary had a little lamb\", 3))\n    assert_equal([], candidate.call(\"simple white space\", 2))\n    assert_equal([\"world\"], candidate.call(\"Hello world\", 4))\n    assert_equal([\"Uncle\"], candidate.call(\"Uncle sam\", 3))\n    assert_equal([], candidate.call(\"\", 4))\n    assert_equal([\"b\", \"c\", \"d\", \"f\"], candidate.call(\"a b c d e f\", 1))\n  end\nend\n"},{"task_id":"HumanEval_118","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། ཁྱོད་ཀྱིས་བྱིན་ཡིག་ string ནང་དཔར་ཡིག་དབྱིན་ཡིག་ཁོ་ན་ཡོད་པར་ངེས་གཏན་བྱེད་དགོས།སྟེང་གི་གནས་སྟངས་ལ་བསྟུན་པའི་སྒྲ་སྒྲ་གང་ཞིག་འཚོལ་དགོས།ཐོག་དང་མཇུག་གི་སྒྲ་དབྱངས་ལ་རྩིས་མི་བྱེད། གལ་ཏེ་མེད་ན་སྟོང་པ་ཕྱིར་ལོག་བྱོས།ཚིག་གི་གཡས་ཕྱོགས་ནས་སྒྲ་གཉིས་བཏགས་པ། (case sensitive)ཁྱོད་ཚོར་ཚིག་ཅིག་སྤྲོད་ཡོད། ཁྱོད་ཀྱི་ལས་འགན་ནི་ ཇི་ཙམ་ཉེ་བར་ཡོད་པ་དང་དེའི་བར་གྱི་སྒྲ་དབྱངས་འཚོལ་རྒྱུ་དེ་ཡིན།# >>> get_closest_vowel.call(\"yogurt\")\n# \"u\"\n# >>> get_closest_vowel.call(\"FULL\")\n# \"U\"\n# >>> get_closest_vowel.call(\"quick\")\n# \"\"\n# >>> get_closest_vowel.call(\"ab\")\n# \"\"\ndef get_closest_vowel(word)\n","canonical_solution":"def get_closest_vowel(word)\n  vowels = \"aeiouAEIOU\"\n  (1...word.length - 1).reverse_each do |i|\n    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])\n      return word[i]\n    end\n  end\n  return \"\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_closest_vowel\n    candidate = method(:get_closest_vowel)\n    assert_equal(\"u\", candidate.call(\"yogurt\"))\n    assert_equal(\"u\", candidate.call(\"full\"))\n    assert_equal(\"\", candidate.call(\"easy\"))\n    assert_equal(\"\", candidate.call(\"eAsy\"))\n    assert_equal(\"\", candidate.call(\"ali\"))\n    assert_equal(\"a\", candidate.call(\"bad\"))\n    assert_equal(\"o\", candidate.call(\"most\"))\n    assert_equal(\"\", candidate.call(\"ab\"))\n    assert_equal(\"\", candidate.call(\"ba\"))\n    assert_equal(\"\", candidate.call(\"quick\"))\n    assert_equal(\"i\", candidate.call(\"anime\"))\n    assert_equal(\"\", candidate.call(\"Asia\"))\n    assert_equal(\"o\", candidate.call(\"Above\"))\n  end\nend\n"},{"task_id":"HumanEval_119","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།གལ་ཏེ་ string བཟོ་ཐབས་ཡོད་ན་ 'Yes' སླར་ལོག་བྱེད་དང་གཞན་ན་ 'No' སླར་ལོག་བྱེད་\" ((()) \"མི་འདུགཚད་ལྡན་ཡིན་པའི་དཔེར་ན། string '(((() 'ནི་ལེགས་པོ་ཡིན་པ་དང་། string string S འདི་ལེགས་པར་བརྩི་བའི་དོན་ནི་ S ནང་གི་ parentheses ཚང་མ་ལེགས་པ་ཡིན་ན་དེ་འདྲ་ཡིན་ན་མ་གཏོགས་གཞན་གང་ཡང་མེད།ཚད་གཞི་འདི་ནི་རིམ་པ་གང་རུང་ཞིག་ཡིན་ན། འབྲས་བུ་ནི་ string ཡི་ལེགས་པ་ངེས་ཅན་ཞིག་ཡིན།ཁྱོད་ཀྱི་ལས་འགན་ནི་ string གཉིས་ནང་འབྲེལ་མཐུད་བྱེད་ནུས་ཡོད་མེད་བརྟག་དཔྱད་བྱེད་རྒྱུ་རེད།ནང་འཇུག་བྱེད་ཚིག་ཡིག་ནང་ \" ((\") \" ཡང་ན་ \") \" ཟེར་བའི་ནང་འཇུག་བྱེད་ཚིག་ཡིག་དེ་མ་གཏོགས་གཞན་མེད།ཁྱོད་ཚོར་ string གཉིས་ཀྱི་གྲངས་ཐང་ཞིག་ཐོབ་ཡོད། string གཉིས་ཀ་ open ཟེར་བ་ལས་གྲུབ་པ་ཡིན།# >>> match_parens.call([\"()(\", \")\"])\n# \"Yes\"\n# >>> match_parens.call([\")\", \")\"])\n# \"No\"\ndef match_parens(lst)\n","canonical_solution":"def match_parens(lst)\n  a, b = lst\n\n  # Define a helper method to check if a string is balanced\n  def balanced?(s)\n    count = 0\n    s.each_char do |c|\n      count += 1 if c == '('\n      count -= 1 if c == ')'\n      return false if count < 0\n    end\n    count == 0\n  end\n\n  # Check if either concatenation forms a good string\n  if balanced?(a + b) || balanced?(b + a)\n    \"Yes\"\n  else\n    \"No\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_match_parens\n    candidate = method(:match_parens)\n    assert_equal(\"Yes\", candidate.call([\"()(\", \")\"]))\n    assert_equal(\"No\", candidate.call([\")\", \")\"]))\n    assert_equal(\"No\", candidate.call([\"(()(())\", \"())())\"]))\n    assert_equal(\"Yes\", candidate.call([\")())\", \"(()()(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(())))\", \"(()())((\"]))\n    assert_equal(\"No\", candidate.call([\"()\", \"())\"]))\n    assert_equal(\"Yes\", candidate.call([\"(()(\", \"()))()\"]))\n    assert_equal(\"No\", candidate.call([\"((((\", \"((())\"]))\n    assert_equal(\"No\", candidate.call([\")(()\", \"(()(\"]))\n    assert_equal(\"No\", candidate.call([\")(\", \")(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(\", \")\"]))\n    assert_equal(\"Yes\", candidate.call([\")\", \"(\"]))\n  end\nend\n"},{"task_id":"HumanEval_120","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཞི་དང་པོ།ཚད་ k དང་གྲངས་ k ཡི་རིང་ཚད་ arr ནང་ཡོད།སྐར་ཁུང་གི་དྲ་ངོས་ནས་ཨང་གྲངས་མཐའ་དག་དང་ k ཅན་གྲངས་མཐའ་དག་གི་རིམ་པ་སྒྲིག་པའི་རིམ་པ་སླར་ལོག་བྱེད།# >>> maximum.call([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum.call([4, -4, 4], 2)\n# [4, 4]\n# Example 3:\n# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1], 1)\n# [2]\n# Note:\n# 1. The length of the array will be in the range of [1, 1000].\n# 2. The elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\ndef maximum(arr, k)\n","canonical_solution":"def maximum(arr, k)\n  arr.sort.last(k).sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3, -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2], candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123, -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123, 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5, 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2, 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n    assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10], candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23, 243, -400, 0], 0))\n  end\nend\n"},{"task_id":"HumanEval_121","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།སྟོང་པ་མིན་པའི་གྲངས་ཐང་གི་རིམ་པ་ཐོབ་ན། གྱ་གྲངས་ཆ་མཉམ་གྱི་ཆ་ཤས་ཆ་སྙོམས་ཕྱིར་ལོག་བྱེད་པ།# >>> solution.call([5, 8, 7, 1])\n# 12\n# >>> solution.call([3, 3, 3, 3, 3])\n# 9\n# >>> solution.call([30, 13, 24, 321])\n# 0\ndef solution(lst)\n","canonical_solution":"def solution(lst)\n  lst.each_with_index.reduce(0) do |sum, (val, idx)|\n    (idx.even? && val.odd?) ? sum + val : sum\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solution\n    candidate = method(:solution)\n    assert_equal(12, candidate.call([5, 8, 7, 1]))\n    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))\n    assert_equal(0, candidate.call([30, 13, 24, 321]))\n    assert_equal(5, candidate.call([5, 9]))\n    assert_equal(0, candidate.call([2, 4, 8]))\n    assert_equal(23, candidate.call([30, 13, 23, 32]))\n    assert_equal(3, candidate.call([3, 13, 2, 9]))\n  end\nend\n"},{"task_id":"HumanEval_122","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། arr ནང་གི་ཆ་ཤས་ k ཐོག་མའི་ཆ་ཤས་ནས་ཨང་གྲངས་གཉིས་ལས་མང་བ་མེད་པའི་ཆ་ཤས་ཀྱི་བསྡོམས་ཡིན།ཨང་གྲངས་ཧྲིལ་པོ་ arr དང་ཨང་གྲངས་ཧྲིལ་པོ་ k ཡོད་པའི་སྟོང་པ་མིན་པའི་རིམ་པ་ཡོད་ན། return # >>> add_elements.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n# 24\n# Constraints:\n# 1. 1 <= len(arr) <= 100\n# 2. 1 <= k <= len(arr)\ndef add_elements(arr, k)\n","canonical_solution":"def add_elements(arr, k)\n  arr.first(k).select { |num| num.abs.to_s.length <= 2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add_elements\n    candidate = method(:add_elements)\n    assert_equal(-4, candidate.call([1, -2, -3, 41, 57, 76, 87, 88, 99], 3))\n    assert_equal(0, candidate.call([111, 121, 3, 4000, 5, 6], 2))\n    assert_equal(125, candidate.call([11, 21, 3, 90, 5, 6, 7, 8, 9], 4))\n    assert_equal(24, candidate.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))\n    assert_equal(1, candidate.call([1], 1))\n  end\nend\n"},{"task_id":"HumanEval_123","nl":"bod_Tibt","pl":"rb","prompt":"get_odd_collatz(5) སླར་ལོག་བྱས་ [1, 5] # 5 གི་ collatz ཐིག་ཁྲམ་ནི་ [5, 16, 8, 4, 2, 1] ཡིན་པས་གྲངས་ཆ་རྐྱང་ནི་ 1 དང་ 5 ཙམ་ཡིན།དཔེར་ན་: 2. return array sorted in increasing order. ཕྱིར་ལོག་བྱས་པའི་རིམ་པ་རིམ་བཞིན་གོ་སྒྲིག་བྱས་ཡོད།Collatz ((1) ནི་ [1]ཡིན།དྲན་གསོ།ཚིག་གྲངས་དང་ལྡན། 1 ཟེར་བ་དེའི་ནང་ n ཇི་འདྲ་ཡིན་རུང་རིམ་པ་ 1 ཏུ་ངེས་པ་རེད་འདུགགལ་ཏེ་སྔོན་གྱི་གྲངས་ནི་རྣམ་རྟོག་ཡིན་ན། རྗེས་མའི་གྲངས་ནི་སྔོན་གྱི་གྲངས་ལས་ 3 ཙམ་ཡིན།སྔོན་མའི་གྲངས་ནི་ཆ་སྙོམས་ཡིན་ན། རྗེས་མའི་གྲངས་ནི་ གྱི་ཕྱེད་ཀ་ཡིན།ཇི་འདྲ་ཡིན་རུང་ཨང་གྲངས་ཧྲིལ་པོ་ n ལས་འགོ་འཛུགས་དགོས། དེ་ནས་རིམ་པ་རེ་རེར་ ལས་ཐོབ་ཡོད།ཀོ་ལ་ཊི་ (Collaz) གི་རྣམ་གཞག་ནི་རྩིས་རིག་གི་རྣམ་གཞག་ཞིག་ཡིན་ཏེ། དེའི་ནང་གསལ་གྱི་རིམ་པ་ཞིག་ཡིན་ཏེ།འབྲས་བུ་གྲངས་ཆ་མཉམ་ n ཞིག་ཡོད་ན། ཚད་ལྡན་ཨང་གྲངས་ Collatz ནང་ཡོད་པའི་རིམ་པ་སྒྲིག་པའི་གྲངས་ཐང་ཕྱིར་ལོག་འབད།# >>> get_odd_collatz.call(5)\n# [1, 5]\ndef get_odd_collatz(n)\n","canonical_solution":"def get_odd_collatz(n)\n  collatz_sequence = []\n  while n != 1\n    collatz_sequence << n if n.odd?\n    if n.even?\n      n = n \/ 2\n    else\n      n = 3 * n + 1\n    end\n  end\n  collatz_sequence << 1 if n == 1\n\n  collatz_sequence.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_odd_collatz\n    candidate = method(:get_odd_collatz)\n    assert_equal([1, 5, 7, 11, 13, 17], candidate.call(14))\n    assert_equal([1, 5], candidate.call(5))\n    assert_equal([1, 3, 5], candidate.call(12))\n    assert_equal([1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_124","nl":"bod_Tibt","pl":"rb","prompt":"4. ཚེས་གྲངས་ནི་ཨང་རིམ་:ཨེམ་ཨེམ་-དི་-ཡཡཡ། ནང་དུ་བཀོད་དགོས།ཟླ་བ་ ༡ ལས་ཉུང་བ་མིན་པར་ ༡༢ ལས་མང་བ་མིན་པར་དགོས།ཟླ་བ་ ༡། ༣། ༥། ༧། ༨། ༡༠། ༡༢ ཀྱི་ཉིན་གྲངས་ནི་ ༡ ལས་ཉུང་བ་མིན་པ་དང་ ༣༡ ལས་མང་བ་མིན་པ་དང་། ཟླ་བ་ ༤། ༦། ༩། ༡༡ གྱི་ཉིན་གྲངས་ནི་ ༡ ལས་ཉུང་བ་མིན་པ་དང་ ༣༠ ལས་མང་བ་མིན་པ་དང་། ཟླ་བ་ ༢ གྱི་ཉིན་གྲངས་ནི་ ༡ ལས་ཉུང་བ་མིན་པ་དང་ ༢༩ ལས་མང་བ་མིན་པ་བཅས་ཡིན།1. ཚེས་གྲངས་ཀྱི་ཐིག་ཡིག་ནི་སྟོང་པ་མིན་ནོ།།ཚེས་གྲངས་དེ་གནས་ངེས་ཡིན་ན། འོག་གི་ཁྲིམས་ལུགས་ཚང་མ་སྲུང་དགོས།གལ་ཏེ་ཚེས་གྲངས་དེ་བདེན་པ་ཡིན་ན་ true སླར་ལོག་བྱེད། གལ་ཏེ་དེ་བདེན་མེད་ན་ false སླར་ལོག་བྱེད།ཁྱོད་ཀྱིས་དུས་གྲངས་ཀྱི་ཐིག་ཡིག་ལ་རྟགས་རྒྱག་པའི་ function ཞིག་འབྲི་དགོས།# >>> valid_date.call(\"03-11-2000\")\n# true\n# >>> valid_date.call(\"15-01-2012\")\n# false\n# >>> valid_date.call(\"04-0-2040\")\n# false\n# >>> valid_date.call(\"06-04-2020\")\n# true\n# >>> valid_date.call(\"06\/04\/2020\")\n# false\ndef valid_date(date)\n","canonical_solution":"def valid_date(date)\n  return false if date.nil? || date.empty?\n  \n  # Check if the date format is correct\n  match = date.match(\/^(\\d{2})-(\\d{2})-(\\d{4})$\/)\n  return false unless match\n  \n  month, day, year = match.captures.map(&:to_i)\n  \n  # Check if month is valid\n  return false if month < 1 || month > 12\n  \n  # Check if day is valid according to the month\n  case month\n  when 1, 3, 5, 7, 8, 10, 12\n    return day >= 1 && day <= 31\n  when 4, 6, 9, 11\n    return day >= 1 && day <= 30\n  when 2\n    return day >= 1 && day <= 29\n  else\n    return false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_valid_date\n    candidate = method(:valid_date)\n    assert_equal(true, candidate.call(\"03-11-2000\"))\n    assert_equal(false, candidate.call(\"15-01-2012\"))\n    assert_equal(false, candidate.call(\"04-0-2040\"))\n    assert_equal(true, candidate.call(\"06-04-2020\"))\n    assert_equal(true, candidate.call(\"01-01-2007\"))\n    assert_equal(false, candidate.call(\"03-32-2011\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"04-31-3000\"))\n    assert_equal(true, candidate.call(\"06-06-2005\"))\n    assert_equal(false, candidate.call(\"21-31-2000\"))\n    assert_equal(true, candidate.call(\"04-12-2003\"))\n    assert_equal(false, candidate.call(\"04122003\"))\n    assert_equal(false, candidate.call(\"20030412\"))\n    assert_equal(false, candidate.call(\"2003-04\"))\n    assert_equal(false, candidate.call(\"2003-04-12\"))\n    assert_equal(false, candidate.call(\"04-2003\"))\n  end\nend\n"},{"task_id":"HumanEval_125","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།དབྱེ་ཡིག་ ord (a) = 0 ord (b) = 1 ord (z) = 25ཚད་མ་ནང་ཡིག་ཆུང་ཆུང་གི་གྲངས་དང་གོ་རིམ་རྣམ་རྟོག་མེད་པ།ཚིག་ཡིག་གི་ཐིག་ཡིག་ཐོབ་ཡོད་ན། ཚིག་ཡིག་གི་གོ་རིམ་ནང་གོ་རིམ་མེད་ན་ ཡིག་འབྲུ་ནང་གོ་རིམ་མེད་ན་ སྟོང་པ་ཁ་ཕྱེ་ནས་གོ་རིམ་སྒྲིག་པའི་ཡིག་འབྲུ་སླར་ལོག་བྱེད།# >>> split_words.call(\"Hello world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"Hello,world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"abcdef\")\n# 3\ndef split_words(txt)\n","canonical_solution":"def split_words(txt)\n  if txt.include?(' ')\n    return txt.split(' ')\n  elsif txt.include?(',')\n    return txt.split(',')\n  else\n    odd_count = txt.chars.count { |char| ('a'..'z').include?(char) && (char.ord - 'a'.ord).odd? }\n    return odd_count\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_split_words\n    candidate = method(:split_words)\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello world!\"))\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello,world!\"))\n    assert_equal([\"Hello\", \"world,!\"], candidate.call(\"Hello world,!\"))\n    assert_equal([\"Hello,Hello,world\", \"!\"], candidate.call(\"Hello,Hello,world !\"))\n    assert_equal(3, candidate.call(\"abcdef\"))\n    assert_equal(2, candidate.call(\"aaabb\"))\n    assert_equal(1, candidate.call(\"aaaBb\"))\n    assert_equal(0, candidate.call(\"\"))\n  end\nend\n"},{"task_id":"HumanEval_126","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།གྲངས་ཆ་མེད་པ། ནུས་མེད་པ། འབྲས་བུ་ནི་ཆ་མཉམ་ཡིན་པ་ངེས་པ།གལ་ཏེ་ array ནང་འདྲ་མཚུངས་ 1 ལས་མང་བ་ཡོད་ན།གྲངས་ཀྱི་རིམ་པ་ཐོབ་ནས་རིམ་པ་སྒྲིག་ཡོད་མེད་ཕྱིར་ལོག་འཇུག་དགོས།# >>> is_sorted.call([5])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5])\n# false\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6, 7])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5, 6, 7])\n# false\n# >>> is_sorted.call([1, 2, 2, 3, 3, 4])\n# true\n# >>> is_sorted.call([1, 2, 2, 2, 3, 4])\n# false\ndef is_sorted(lst)\n","canonical_solution":"def is_sorted(lst)\n  lst.each_cons(2).with_index do |(a, b), index|\n    return false if a > b\n    return false if index < lst.length - 2 && a == b && lst[index + 2] == b\n  end\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_sorted\n    candidate = method(:is_sorted)\n    assert_equal(true, candidate.call([5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))\n    assert_equal(true, candidate.call([]))\n    assert_equal(true, candidate.call([1]))\n    assert_equal(false, candidate.call([3, 2, 1]))\n    assert_equal(false, candidate.call([1, 2, 2, 2, 3, 4]))\n    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 2, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_127","nl":"bod_Tibt","pl":"rb","prompt":"[input\/output] དཔེ་གཟུགས།གལ་ཏེ་བར་མཚམས་གཉིས་དེ་དང་མི་འདྲ་ན། \"NO\" སླར་ལོག་བྱེད།དེ་མིན་ \"NO\" ཟེར་བ་ཕྱིར་ལོག་བྱོས།གལ་ཏེ་ཕྲེང་བའི་རིང་ཚད་ནི་སྔོན་གྲངས་ཡིན་ན། \"YES\" ཕྱིར་སློག་བྱོས།དེའི་རིང་ཚད་ནི་ 1 ཡིན་ལ། དེ་ནི་སྔོན་གྲངས་མིན་པ་ཡིན།དཔེ་གཞི་འདི་ནི་བར་མཚམས་ (1, 3), (2, 4) གྱི་ཕྲ་རིང་ནི་ (2, 3) ཡིན།བར་མཚམས་ནི་གྲངས་དང་པོ་ཡིན།ཁྱོད་ཀྱི་ལས་འགན་ནི་འདི་གཉིས་ཀྱི་ཕྲད་ཚད་ ཇི་ཡིན་གཏན་འབེབས་བྱ་རྒྱུ་དེ་ཡིན།ཚད་གཞི་སོ་སོར་ཆ་བཞག་ན་དུས་ཡུན་གྱི་འགོ་ནི་མཐའ་མ་ལས་ཆུང་བའམ་མཚུངས་པ་རེད་ཟེར།ཀྱི་འགོ་དང་མཐའ་གཉིས་ཀ་ཚུད་ཡོད།ཇི་ཡོད་བར་མཚམས་ནི་བསྡམས་པ་རེད་ཟེར། དེའི་དོན་ནི་བར་མཚམས་ (འགོ་འཛུགས་དང་མཇུག་བསྡུ་) ཟེར་བ་རེད།ཚོད་མཚམས་རེ་རེ་ནི་གྲངས་ཆ་ཆ་ཚང་གཉིས་ཡིན། དཔེར་ན། ཚོད་མཚམས་ = (འགོ་འཛིན། མཇུག་) = (1, 2)ཁྱོད་ཚོར་དུས་ཡུན་གཉིས་ཐོབ་ཡོད།# >>> intersection.call([1, 2], [2, 3])\n# \"NO\"\n# >>> intersection.call([-1, 1], [0, 4])\n# \"NO\"\n# >>> intersection.call([-3, -1], [-5, 5])\n# \"YES\"\ndef intersection(interval1, interval2)\n","canonical_solution":"def intersection(interval1, interval2)\n  start1, end1 = interval1\n  start2, end2 = interval2\n\n  intersection_start = [start1, start2].max\n  intersection_end = [end1, end2].min\n\n  if intersection_start > intersection_end\n    return \"NO\"\n  end\n\n  intersection_length = intersection_end - intersection_start + 1\n\n  return \"YES\" if prime?(intersection_length)\n\n  \"NO\"\nend\n\ndef prime?(n)\n  return false if n <= 1\n  return true if n == 2 || n == 3\n\n  (2..Math.sqrt(n).to_i).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersection\n    candidate = method(:intersection)\n    assert_equal(\"NO\", candidate.call([1, 2], [2, 3]))\n    assert_equal(\"NO\", candidate.call([-1, 1], [0, 4]))\n    assert_equal(\"YES\", candidate.call([-3, -1], [-5, 5]))\n    assert_equal(\"YES\", candidate.call([-2, 2], [-4, 0]))\n    assert_equal(\"NO\", candidate.call([-11, 2], [-1, -1]))\n    assert_equal(\"NO\", candidate.call([1, 2], [3, 5]))\n    assert_equal(\"NO\", candidate.call([1, 2], [1, 2]))\n    assert_equal(\"NO\", candidate.call([-2, -2], [-3, -2]))\n  end\nend\n"},{"task_id":"HumanEval_128","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། Note: empty arr ཕྱིར་ལོག་བྱེད་ཐབས།ཚད་གཞི་ནང་ཡོད་པའི་གྲངས་རེ་རེ་ལ་ 1 དང་ -1 ཡང་ན་ 0 ཟེར་བ་ཡོད།འབྲས་བུ་ནི་ཨང་གྲངས་ཧྲིལ་པོ་གི་ཆེ་ཆུང་དང་རྟགས་ཐམས་ཅད་ཀྱི་འབྲས་བུ་ལ་སོགས་པའི་གྲངས་ཀ་ཡིན།ཁྱོད་ལ་ཧྲིལ་གྲངས་ཀྱི་རིམ་པ་ arr ཞིག་སྤྲད་ཡོད་པ་དང་ཁྱོད་ཀྱིས་ལོག་དགོས་པ་ཡིན།# >>> prod_signs.call([1, 2, 2, -4])\n# 9\n# >>> prod_signs.call([0, 1])\n# 0\n# >>> prod_signs.call([])\n# nil\ndef prod_signs(arr)\n","canonical_solution":"def prod_signs(arr)\n  return nil if arr.empty?\n  \n  product_signs = arr.reduce(1) { |prod, num| prod * num <=> 0 }\n  sum_magnitudes = arr.map(&:abs).sum\n  \n  product_signs * sum_magnitudes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"},{"task_id":"HumanEval_129","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཆུང་ཤོས་ཀྱི་ལམ་བརྒྱུད་པའི་ཐིག་ཁྲམ་ནང་འཇུག་པའི་གྲངས་ཐང་གི་རིམ་པ་སླར་ལོག་བྱེད།ཇི་འདྲ་ཡིན་ན་ལན་གཅིག་ཡོད་ངེས་རེད།lst_A[j] = lst_B[j] ཟེར་བ་ལྟ་བུ།འདྲ་བའི་ lst_A[i] < lst_B[i] དང་ j (1 <= j < i) ཇི་ཡོད་ཀྱི་ཆེད་དུ་འདྲ་མིན་གྱི་ཚིག་གཞན་ལ་ lst_B དང་བསྡུར་ན་གྲངས་ཚང་གི་གྲངས་ཐང་ i (1 <= i <= k) ཡོད་པ་རེད།རྒྱུད་ནས་ (ང་ཚོས་དེ་དག་ལ་ lst_A དང་ lst_B ཞེས་འབོད།) lst_A ནི་ཚིག་མཛོད་རིག་པའི་ཐོག་ནས་ཉུང་བ་རེད།སྐར་ཁུང་ A དང་ B ནང་གི་ཐང་རིམ་བཞིན་སྒྲིག་འཇུག་བྱས་རྗེས་འགྲོ་བཞིན་ཡོད།ཕྲང་ལམ་ A (རིང་ཚད་ k) ནི་ཕྲང་ལམ་ B (རིང་ཚད་ k) ལས་ཆུང་བ་ཡིན་པར་རྩིས་ན།ཁྱོད་ནི་གློག་ཀླད་ཀྱི་ལམ་ནས་འགྲོ་མི་ཐུབ།འདྲ་མིན་གྱི་ཆ་རྐྱེན་ལ་བརྟེན་པ་མིན་ནམ།ཚད་ k ཡོད་པའི་ལམ་གྱི་དོན་ནི་ k ཁང་མིག་ལ་ཐད་ཀར་འགྲོ་དགོས་ (མི་  cell  cell  cell  cellགཞན་སྐད་དུ་བཤད་ན། ཁྱོད་མིག་མིག་ལ་འགྲོ་ཐུབ། ཇི་ཞིག་ལ་ཁྱོད་དང་འདེམས་པའི་མཚམས་ཡོད་པ།ཇི་འདྲ་ཞིག་ནས་ཀྱང་ cell ཇི་འདྲ་ཞིག་ནས་ཀྱང་ step ཇི་འདྲ་ཞིག་ནས་ཀྱང་ neighbour cell ཇི་འདྲ་ཞིག་ནས་ཀྱང་ step ཇི་འདྲ་ཞིག་ནས་ཀྱང་ neighbour cell ཇི་འདྲ་ཞིག་ནས་ཀྱང་ step ཇི་འདྲ་ཞིག་ནས་ཀྱང་ neighbour cell ཇི་འདྲ་ཞིག་ནས་ཀྱང་ step ཇི་འདྲ་ཞིག་ནས་ཀྱང་ neighbour cellཁྱོད་ཀྱིས་དྲ་ལམ་ནང་གི་ཚད་ k ཡི་ཆུང་ཤོས་ཀྱི་ལམ་འཚོལ་དགོས། ཁྱོད་ཀྱིས་འགོ་ཚུགས་ཐུབ།ཕྱོགས་མཚུངས་ནི་ཐིག་ཁྲམ་ནང་གི་ཚགས་པར་ནང་ཐེངས་གཅིག་རང་མངོན་པར་བྱེད།ཕྲེང་བའི་སྒོ་མིག་རེ་རེར་ཐང་ཞིག་ཡོད། [1, N * N] ནང་གི་གྲངས་ཧྲིལ་པོ་རེ་རེགྲལ་ཐིག་དང་ཀ་བ་ N ཡོད་པའི་དྲ་རྒྱ་ཞིག་དང་ (N >= 2) དང་གྲངས་ཆ་ k ཅན་ཞིག་ཡོད་ན།# >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n# [1, 2, 1]\n# >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n# [1]\ndef minPath(grid, k)\n","canonical_solution":"def minPath(grid, k)\n  n = grid.size\n  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n  min_path = nil\n\n  n.times do |i|\n    n.times do |j|\n      queue = [[[i, j], [grid[i][j]]]]\n      until queue.empty?\n        position, path = queue.shift\n        if path.size == k\n          min_path = path if min_path.nil? || path < min_path\n          next\n        end\n        directions.each do |dx, dy|\n          x, y = position[0] + dx, position[1] + dy\n          if x.between?(0, n-1) && y.between?(0, n-1)\n            queue.push([[x, y], path + [grid[x][y]]])\n          end\n        end\n      end\n    end\n  end\n  min_path\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minPath\n    candidate = method(:minPath)\n    assert_equal([1, 2, 1], candidate.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))\n    assert_equal([1], candidate.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))\n    assert_equal([1, 2, 1, 2], candidate.call([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))\n    assert_equal([1, 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7))\n    assert_equal([1, 7, 1, 7, 1], candidate.call([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8))\n    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8))\n    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], candidate.call([[1, 2], [3, 4]], 10))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))\n  end\nend\n"},{"task_id":"HumanEval_130","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཐོག་མའི་ n+1 ནི་ Tribonacci sequence གྱི་གྲངས་ཀ་ཡིན།ཁྱོད་ཀྱིས་གྲངས་ཆ་མེད་མེད་གྲངས་ཆ་ n ཞིག་ཐོབ་ཡོད་ན། ཁྱོད་ཀྱིས་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་= 2 + 3 + 3 = 8tri(3) = tri(2) + tri(1) + tri(4) tri ((4) = 3 tri ((2) = 1 + (2 \/ 2) = 2དཔེར་ན་: tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1) ཡིན་ན། n ནི་གྲངས་ཆ་མ་ཡིན།tri (n) = 1 + n \/ 2 ཡིན་ན། n ནི་ཆ་སྙོམས་ཡིན་ན།tri ((1) = 3 Tribonacci sequence འདི་ཡང་བསྐྱར་དུ་བྱུང་བའི་སྒོ་ནས་གསལ་བཤད་བྱེད་པ།ཡིན་ན་ཡང་མི་ཚོས་མི་ཤེས་པ་ནི་ཏྲི་བོན་ཅེ་ (Tribonacci) གི་རིམ་པ་ཡིན།མི་ཚང་མས་ཕི་བོ་ན་ཅིའི་རིམ་པ་ཤེས་ཀྱི་ཡོད། ཕི་བོ་ན་ཅིའི་རིམ་པ་ནི་ ༡༩༥༠ ལོར་རིག་རྩལ་མཁས་པ་རྣམས་ཀྱིས་ཞིབ་ཏུ་ཞིབ་འཇུག་བྱས་པ་ཡིན།# >>> tri.call(3)\n# [1, 3, 2, 8]\ndef tri(n)\n","canonical_solution":"def tri(n)\n  sequence = [1, 3]\n  \n  (2..n).each do |i|\n    if i.even?\n      sequence[i] = 1 + i \/ 2\n    else\n      sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1] rescue 0\n    end\n  end\n  \n  sequence[0..n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_tri\n    candidate = method(:tri)\n    assert_equal([1, 3, 2, 8], candidate.call(3))\n    assert_equal([1, 3, 2, 8, 3], candidate.call(4))\n    assert_equal([1, 3, 2, 8, 3, 15], candidate.call(5))\n    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35], candidate.call(9))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))\n    assert_equal([1], candidate.call(0))\n    assert_equal([1, 3], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_131","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: གྲངས་ཀ་ཆ་མཉམ་ཉ་ན་ 0 སླར་ལོག་བྱེད།འབྲས་བུ་འདི་ནི་ཨང་གྲངས་ཧྲིལ་པོ་ n ཞིག་ཡོད་ན། ཨང་གྲངས་ཉེར་མཁོ་ཅན་གྱི་འབྲས་བུ་ཕྱིར་སློག་བྱ་དགོས།# >>> digits.call(1)\n# 1\n# >>> digits.call(4)\n# 0\n# >>> digits.call(235)\n# 15\ndef digits(n)\n","canonical_solution":"def digits(n)\n  odd_digits = n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }\n  return 0 if odd_digits.empty?\n  odd_digits.reduce(:*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5, candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5, candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625, candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"},{"task_id":"HumanEval_132","nl":"bod_Tibt","pl":"rb","prompt":"ཤུལ་རིམ་གྱི་ནང་ལ་ཉུང་ཤོས་དྲ་མིག་གཅིག་རང་སྦྲེལ་ཡོད།ལས་འགན་འདི་ true སླར་ལོག་བྱ་དགོས་ན། གལ་ཏེ་ brackets ཀྱི་རིམ་པ་ངེས་ཅན་ཞིག་ཡོད་ན་མ་གཏོགས་གཞན་མེད།ཤོག་གྲངས་ནང་ཡོད་པའི་ཟུར་ཟུར་གྱི་སྒམ་པང་གཅིག་པུ་ཡོད་པའི་ནང་འཇུག་གི་རིམ་པ་ལེན་པའི་ལས་འགན་ཞིག་བཟོ།# >>> is_nested.call(\"[[]]\")\n# true\n# >>> is_nested.call(\"[]]]]]]][[[[[]\")\n# false\n# >>> is_nested.call(\"[][]\")\n# false\n# >>> is_nested.call(\"[]\")\n# false\n# >>> is_nested.call(\"[[][]]\")\n# true\n# >>> is_nested.call(\"[[]][[\")\n# true\ndef is_nested(string)\n","canonical_solution":"def is_nested(string)\n  stack = []\n  has_nested = false\n\n  string.each_char do |char|\n    if char == '['\n      stack.push(char)\n    elsif char == ']'\n      if stack.empty?\n        return false\n      end\n      stack.pop\n      has_nested = true if stack.any?\n    end\n  end\n\n  has_nested\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_nested\n    candidate = method(:is_nested)\n    assert_equal(true, candidate.call(\"[[]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]][[[[[]\"))\n    assert_equal(false, candidate.call(\"[][]\"))\n    assert_equal(false, candidate.call(\"[]\"))\n    assert_equal(true, candidate.call(\"[[[[]]]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]]]]]\"))\n    assert_equal(true, candidate.call(\"[][][[]]\"))\n    assert_equal(false, candidate.call(\"[[]\"))\n    assert_equal(false, candidate.call(\"[]]\"))\n    assert_equal(true, candidate.call(\"[[]][[\"))\n    assert_equal(true, candidate.call(\"[[][]]\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"[[[[[[[[\"))\n    assert_equal(false, candidate.call(\"]]]]]]]]\"))\n  end\nend\n"},{"task_id":"HumanEval_133","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཐིག་ཁྲམ་ནང་གི་ཆ་ཤས་རེ་རེར་ཐོག་མར་སྟེང་གི་ int ((Ceiling) སྟེང་གི་མཐའ་འཁོར་དུ་འཁོར་དགོས།ཁྱོད་ཀྱིས་གྲངས་ཐང་གི་ཆ་སྙོམས་ལ་སླར་ལོག་བྱ་དགོས་ ཁྱོད་ཚོར་གྲངས་ཀྱི་རིམ་པ་ཐོབ་ཡོད།# >>> lst.call([1.0, 2.0, 3.0])\n# 14\n# >>> lst.call([1.0, 4.0, 9.0])\n# 98\n# >>> lst.call([1.0, 3.0, 5.0, 7.0])\n# 84\n# >>> lst.call([1.4, 4.2, 0.0])\n# 29\n# >>> lst.call([-2.4, 1.0, 1.0])\n# 6\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map { |num| (num.ceil)**2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(84, candidate.call([1.0, 3.0, 5.0, 7.0]))\n    assert_equal(29, candidate.call([1.4, 4.2, 0.0]))\n    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))\n    assert_equal(10230, candidate.call([100.0, 1.0, 15.0, 2.0]))\n    assert_equal(200000000, candidate.call([10000.0, 10000.0]))\n    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))\n    assert_equal(1086, candidate.call([-1.4, 17.9, 18.9, 19.9]))\n    assert_equal(0, candidate.call([0.0]))\n    assert_equal(1, candidate.call([-1.0]))\n    assert_equal(2, candidate.call([-1.0, 1.0, 0.0]))\n  end\nend\n"},{"task_id":"HumanEval_134","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།Note: \"word\" ནི་ཡིག་འབྲུ་ཁག་གི་སྡེ་ཚན་ཞིག་ཡིན་ཏེ། དེའི་བར་ལ་སྟོང་པ་གཉིས་ཡོད།ཕྱོགས་གཞན་ནས་རྫུན་བཤད་ཀྱི་ཡོད།string གྱི་ཡིག་འབྲུ་འདི་ alphabetical character ཡིན་པ་ལས་ མིན་པ་མཚོན་ཐུབ།གལ་ཏེ་མཐའ་མའི་ཡིག་འབྲུ་འདི་ trueཡིན་ན་ function དེ་སླར་ལོག་བྱ་དགོས།# >>> check_if_last_char_is_a_letter.call(\"apple pie\")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e\")\n# true\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e \")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\")\n# false\ndef check_if_last_char_is_a_letter(txt)\n","canonical_solution":"check_if_last_char_is_a_letter = ->(txt) {\n  return false if txt.strip.empty?\n  words = txt.strip.split(' ')\n  last_word = words.last\n  return false if last_word.empty?\n  last_char = last_word[-1]\n\n  last_char =~ \/[a-zA-Z]\/ && (words.size == 1 || txt[txt.rindex(last_char) - 1] == ' ')\n}","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_if_last_char_is_a_letter\n    candidate = method(:check_if_last_char_is_a_letter)\n    assert_equal(false, candidate.call(\"apple\"))\n    assert_equal(true, candidate.call(\"apple pi e\"))\n    assert_equal(false, candidate.call(\"eeeee\"))\n    assert_equal(true, candidate.call(\"A\"))\n    assert_equal(false, candidate.call(\"Pumpkin pie \"))\n    assert_equal(false, candidate.call(\"Pumpkin pie 1\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"eeeee e \"))\n    assert_equal(false, candidate.call(\"apple pie\"))\n    assert_equal(false, candidate.call(\"apple pi e \"))\n  end\nend\n"},{"task_id":"HumanEval_135","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།འདྲ་མཚུངས་ཀྱི་ཚད་གཞི་དེ་འདྲ་བའི་ཆ་ཤས་མེད་ན་ return - 1 སླར་ལོག་བྱེད། གྲལ་ཐིག་ནང་ ཡོད་པ་མི་འདུགཇི་འདྲ་ཞིག་ཡིན་རུང་དེ་སྔོན་གྱི་ཆ་ཤས་དང་འདྲན་པ་ཡང་ན་དེ་ལས་ཆེ་བ་མིན། གལ་ཏེ་ཚད་གཞི་ ཆེ་ཆུང་གི་ཚད་གཞི་སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་བཟོ་དགོས།# >>> can_arrange.call([1, 2, 4, 3, 5])\n# 3\n# >>> can_arrange.call([1, 2, 3])\n# -1\ndef can_arrange(arr)\n","canonical_solution":"def can_arrange(arr)\n  (1...arr.length).reverse_each do |i|\n    return i if arr[i] < arr[i - 1]\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_can_arrange\n    candidate = method(:can_arrange)\n    assert_equal(3, candidate.call([1, 2, 4, 3, 5]))\n    assert_equal(-1, candidate.call([1, 2, 4, 5]))\n    assert_equal(2, candidate.call([1, 4, 2, 5, 6, 7, 8, 9, 10]))\n    assert_equal(4, candidate.call([4, 8, 5, 7, 3]))\n    assert_equal(-1, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_136","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ནུས་མེད་དང་ཆ་མེད་གྲངས་ཆ་མེད་ཡིན་ན། null སྦེ་ཕྱིར་ལོག་བྱེད།སྐར་ཁུང་ནང་ཡོད་ཆ་ཆ་ཚང་མ་ཨང་གྲངས་ཀྱི་གྲངས་སུ་བཀོད་ཡོད།ཆུང་ཤོས་ནི་ b ཡིན་'a' ནི་ ཟེར་བའི་གནས་དེར་ array (a, b) སླར་ལོག་བྱེད་ function ཞིག་བཟོས་དགོས།# >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])\n# [nil, 1]\n# >>> largest_smallest_integers.call([])\n# [nil, nil]\n# >>> largest_smallest_integers.call([0])\n# [nil, nil]\ndef largest_smallest_integers(lst)\n","canonical_solution":"def largest_smallest_integers(lst)\n  largest_negative = nil\n  smallest_positive = nil\n  \n  lst.each do |num|\n    if num < 0\n      largest_negative = num if largest_negative.nil? || num > largest_negative\n    elsif num > 0\n      smallest_positive = num if smallest_positive.nil? || num < smallest_positive\n    end\n  end\n  \n  [largest_negative, smallest_positive]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_smallest_integers\n    candidate = method(:largest_smallest_integers)\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7]))\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7, 0]))\n    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5, 6, -2]))\n    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))\n    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))\n    assert_equal([nil, nil], candidate.call([]))\n    assert_equal([nil, nil], candidate.call([0]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6, 0]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, 1]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100, 1]))\n  end\nend\n"},{"task_id":"HumanEval_137","nl":"bod_Tibt","pl":"rb","prompt":"ཟུར་ཐོ་: གྲངས་ཆ་དངོས་ཡོད་ཅིག་ནི་ཐིག་ཡིག་ལྟར་མཚོན་ན། འཁྱགས་རིལ་གྱི་རྟགས་ནི་ . ཡང་ན་ , ཚད་ལྡན་ཆ་འདྲ་ཡིན་ན་ null སླར་ལོག་བྱེད།ཚད་ལྡན་གྲངས་སུ་འགྱུར་བའི་གྲངས་ཚད་ཆེན་པོའ ་ི ཚད་ལྡན་གྲངས་ཚད་ཀྱི་གྲངས་ཚད་སླར་ལོག་བྱེད།འདྲ་བཤུས་གྲངས་ཐང་དང་ float ཡང་ན་ string ཟེར་བ་སོགས་ལེན་པའི་ལས་འགན་ཞིག་བཟོས་པ།# >>> compare_one.call(1, 2.5)\n# 2.5\n# >>> compare_one.call(1, \"2,3\")\n# \"2,3\"\n# >>> compare_one.call(\"5,1\", \"6\")\n# \"6\"\n# >>> compare_one.call(\"1\", 1)\n# nil\ndef compare_one(a, b)\n","canonical_solution":"def compare_one(a, b)\n  a = a.to_s.tr(',', '.').to_f if a.is_a?(String) && a.include?(',')\n  b = b.to_s.tr(',', '.').to_f if b.is_a?(String) && b.include?(',')\n\n  if a.is_a?(String) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Float)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Float)\n    a = a.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Integer)\n    b = b.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Float)\n    b = b.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(String)\n    a = a.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  else\n    return nil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare_one\n    candidate = method(:compare_one)\n    assert_equal(2, candidate.call(1, 2))\n    assert_equal(2.5, candidate.call(1, 2.5))\n    assert_equal(3, candidate.call(2, 3))\n    assert_equal(6, candidate.call(5, 6))\n    assert_equal(\"2,3\", candidate.call(1, \"2,3\"))\n    assert_equal(\"6\", candidate.call(\"5,1\", \"6\"))\n    assert_equal(\"2\", candidate.call(\"1\", \"2\"))\n    assert_equal(nil, candidate.call(\"1\", 1))\n  end\nend\n"},{"task_id":"HumanEval_138","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།གྲངས་ n འདི་གྲངས་ཆ་རྐྱང་ 4 གི་རྩིས་གཞི་ལྟར་བྲིས་ཐུབ་མིན་ལ་དཔྱད་པ།# >>> is_equal_to_sum_even.call(4)\n# false\n# >>> is_equal_to_sum_even.call(6)\n# false\n# >>> is_equal_to_sum_even.call(8)\n# true\ndef is_equal_to_sum_even(n)\n","canonical_solution":"def is_equal_to_sum_even(n)\n  return false if n < 8\n  n.even?\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_equal_to_sum_even\n    candidate = method(:is_equal_to_sum_even)\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(8))\n    assert_equal(true, candidate.call(10))\n    assert_equal(false, candidate.call(11))\n    assert_equal(true, candidate.call(12))\n    assert_equal(false, candidate.call(13))\n    assert_equal(true, candidate.call(16))\n  end\nend\n"},{"task_id":"HumanEval_139","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: དེར་ n > 0 brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! བརཱ་ཛིལ་གྱི་གནས་ལུགས་ནི་གཤམ་གསལ་ལྟར་ངེས་གཏན་བྱས་ཡོད།# >>> special_factorial.call(4)\n# 288\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\ndef special_factorial(n)\n","canonical_solution":"def special_factorial(n)\n  return 1 if n <= 1\n  (1..n).inject(1) { |product, i| product * factorial(i) }\nend\n\ndef factorial(num)\n  return 1 if num <= 1\n  (2..num).inject(1, :*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_special_factorial\n    candidate = method(:special_factorial)\n    assert_equal(288, candidate.call(4))\n    assert_equal(34560, candidate.call(5))\n    assert_equal(125411328000, candidate.call(7))\n    assert_equal(1, candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_140","nl":"bod_Tibt","pl":"rb","prompt":"དེ་ནས་རིམ་བཞིན་གྱི་བར་སྟོང་རྣམས་ -   ཀྱིས་བརྗེ་བ།གལ་ཏེ་ string ནང་ space གཉིས་ལས་མང་བ་ཡོད་ན།ཚིག་ཡིག་ཡིག་སྣོད་ཅིག་ཡོད་ན་ ནང་གི་བར་སྟོང་ཆ་ཚང་མ་འོག་ཡིག་དང་ཚབ་བཙུགས་དགོས།# >>> fix_spaces.call(\" Example\")\n# \"Example\"\n# >>> fix_spaces.call(\" Example 1\")\n# \"Example_1\"\n# >>> fix_spaces.call(\" Example 2\")\n# \"_Example_2\"\n# >>> fix_spaces.call(\" Example 3\")\n# \"_Example-3\"\ndef fix_spaces(text)\n","canonical_solution":"def fix_spaces(text)\n  text.strip.gsub(\/\\s{3,}\/, '-').gsub(' ', '_')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fix_spaces\n    candidate = method(:fix_spaces)\n    assert_equal(\"Example\", candidate.call(\"Example\"))\n    assert_equal(\"Mudasir_Hanif_\", candidate.call(\"Mudasir Hanif \"))\n    assert_equal(\"Yellow_Yellow__Dirty__Fellow\", candidate.call(\"Yellow Yellow  Dirty  Fellow\"))\n    assert_equal(\"Exa-mple\", candidate.call(\"Exa   mple\"))\n    assert_equal(\"-Exa_1_2_2_mple\", candidate.call(\"   Exa 1 2 2 mple\"))\n  end\nend\n"},{"task_id":"HumanEval_141","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཕྲེང་བ་རྗེས་ཀྱི་ཡིག་འབྲུ་ནི་གཤམ་གསལ་གྱི་གཅིག་རེད། ['txt', 'exe', 'dll']ཤོག་གྲངས་ལ་དབྱིན་ཡིག་གི་ཡི་གེ་ (a-z, A-z) ཟེར་བ་ཡོད།- ཕྲེང་བ་སྔོན་གྱི་ནང་དོན་ནི་སྟོང་པ་མི་དགོས། ཕྲེང་བ་དེའི་ནང་ཡི་གེ་    ནས་འགོ་འཛུགས་དགོས།- ཡིག་སྣོད་མིང་གི་ནང་དོན་གཅིག་རང་ཡོད།- ཡིག་སྣོད་མིང་དུ་ཨང་གྲངས་ ༣ ལས་ལྷག་མི་ཆོག (༠-༩)ཚང་ཡོད་ན།གལ་ཏེ་གཤམ་གསལ་གནས་སྟངས་ཚང་མ་ཡོད་ན་ཡིག་སྣོད་མིང་དེ་བདེན་པ་ཡིན་པར་བརྩི་དགོས།གལ་ཏེ་ཡིག་སྣོད་མིང་གི་མིང་དེ་བདེན་པ་ཡིན་ན་ \"Yes\" དེ་ཡིན་ན་ \"No\" དེ་ཡིན་ན་ \"No\" ཟེར་བ་ཕྱིར་ལོག་བྱེད།ཡིག་སྣོད་མིང་རྟགས་ཀྱི་ཐིག་ཡིག་ལེན་ནས་སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་བཟོ།# >>> file_name_check.call(\"example.txt\")\n# \"Yes\"\n# >>> file_name_check.call(\"1example.dll\")\n# \"No\"\ndef file_name_check(file_name)\n","canonical_solution":"def file_name_check(file_name)\n  # Check if there's exactly one dot in the filename\n  return 'No' unless file_name.count('.') == 1\n  \n  # Split the filename into the name and extension\n  name, extension = file_name.split('.')\n  \n  # Check if the name part starts with a letter\n  return 'No' if name.empty? || !name[0].match?(\/[a-zA-Z]\/)\n  \n  # Check if the extension is valid\n  return 'No' unless ['txt', 'exe', 'dll'].include?(extension)\n  \n  # Count digits in the file name\n  digit_count = file_name.count(\"0-9\")\n  \n  # Check if digits are more than three\n  return 'No' if digit_count > 3\n  \n  'Yes'\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_file_name_check\n    candidate = method(:file_name_check)\n    assert_equal(\"Yes\", candidate.call(\"example.txt\"))\n    assert_equal(\"No\", candidate.call(\"1example.dll\"))\n    assert_equal(\"No\", candidate.call(\"s1sdf3.asd\"))\n    assert_equal(\"Yes\", candidate.call(\"K.dll\"))\n    assert_equal(\"Yes\", candidate.call(\"MY16FILE3.exe\"))\n    assert_equal(\"No\", candidate.call(\"His12FILE94.exe\"))\n    assert_equal(\"No\", candidate.call(\"_Y.txt\"))\n    assert_equal(\"No\", candidate.call(\"?aREYA.exe\"))\n    assert_equal(\"No\", candidate.call(\"\/this_is_valid.dll\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.wow\"))\n    assert_equal(\"Yes\", candidate.call(\"this_is_valid.txt\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.txtexe\"))\n    assert_equal(\"No\", candidate.call(\"#this2_i4s_5valid.ten\"))\n    assert_equal(\"No\", candidate.call(\"@this1_is6_valid.exe\"))\n    assert_equal(\"No\", candidate.call(\"this_is_12valid.6exe4.txt\"))\n    assert_equal(\"No\", candidate.call(\"all.exe.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"I563_No.exe\"))\n    assert_equal(\"Yes\", candidate.call(\"Is3youfault.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"no_one#knows.dll\"))\n    assert_equal(\"No\", candidate.call(\"1I563_Yes3.exe\"))\n    assert_equal(\"No\", candidate.call(\"I563_Yes3.txtt\"))\n    assert_equal(\"No\", candidate.call(\"final..txt\"))\n    assert_equal(\"No\", candidate.call(\"final132\"))\n    assert_equal(\"No\", candidate.call(\"_f4indsartal132.\"))\n    assert_equal(\"No\", candidate.call(\".txt\"))\n    assert_equal(\"No\", candidate.call(\"s.\"))\n  end\nend\n"},{"task_id":"HumanEval_142","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཚད་གཞི་ནི་ 3 དང་ 4 གི་ལྡབ་གྲངས་མིན་པའི་ཨང་གྲངས་ཀྱི་ནང་ཐིག་བསྒྱུར་དགོས། དེ་ནས་ལས་འགན་གྱིས་ཨང་གྲངས་ཚང་མའི་བསྡོམས་གྲངས་ཕྱིར་ལོག་བྱེད་དགོས།གྲངས་འབོར་ནི་ 3 ཀྱི་ལྡབ་གྲངས་ཡིན་པ་དང་དེའི་གཞི་གྲངས་ནི་ 4 ཀྱི་ལྡབ་གྲངས་ཡིན་ན་ ཧྲིལ་གྲངས་ཀྱི་གྲངས་འབོར་ནི་ 3 གྱི་ལྡབ་གྲངས་ཡིན་ན་ ཇི་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ལས་འགན་འདི་ནི་ཨང་གྲངས་ཧྲིལ་པོ་གྲངས་ལྡན་གྱི་རིམ་པ་ཞིག་ལེན་ངེས་ཡིན། གྲལ་ཐིག་ནང་གི་ནང་འཇུག་ཆ་མཉམ་གྱི་ཆེད་དུ་ལས་འགན་འདི་ནི་ཨང་གྲངས་ཧྲིལ་པོ་ནང་འཇུག་གི་རིམ་པ་གཉིས་སུ་རྩིས་དགོས་ན་དེའི་གཞི་གྲངས་ནི་ a ཡིན།\" # >>> lst\n# [1, 2, 3]\n# >>> lst\n# []\n# >>> lst\n# [-1, -5, 2, -1, -5]\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map.with_index do |num, index|\n    if index % 3 == 0\n      num ** 2\n    elsif index % 4 == 0\n      num ** 3\n    else\n      num\n    end\n  end.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(6, candidate.call([1, 2, 3]))\n    assert_equal(14, candidate.call([1, 4, 9]))\n    assert_equal(0, candidate.call([]))\n    assert_equal(9, candidate.call([1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    assert_equal(-3, candidate.call([-1, -1, -1, -1, -1, -1, -1, -1, -1]))\n    assert_equal(0, candidate.call([0]))\n    assert_equal(-126, candidate.call([-1, -5, 2, -1, -5]))\n    assert_equal(3030, candidate.call([-56, -99, 1, 0, -2]))\n    assert_equal(0, candidate.call([-1, 0, 0, 0, 0, 0, 0, 0, -1]))\n    assert_equal(-14196, candidate.call([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]))\n    assert_equal(-1448, candidate.call([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]))\n  end\nend\n"},{"task_id":"HumanEval_143","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཞི་དང་པོ།ཚིག་རིམ་གསར་པའི་ནང་ ཚིག་རིམ་སྔོན་མའི་ནང་ཡོད་པ་ལྟར་བྱ་དགོས།དེའི་རིང་ཚད་ནི་སྔོན་གྲངས་ཡིན།ཟེར་བའི་ཚིག་ཡིག་ཐོག་མ་དེ་ཡོད་པའི་ string སླར་ལོག་བྱ་དགོས།ཚིག་ཡིག་དེའི་ནང་ཡིག་འབྲུ་འགའ་ཤས་ཡོད་པའི་ནང་བར་སྟོང་བཞག་ཡོད་ན།ཇི་འདྲ་ཞིག་ཡིན་རུང་།# >>> words_in_sentence.call(\"This is a test\")\n# \"is\"\n# Example 2:\n# >>> words_in_sentence.call(\"lets go for swimming\")\n# \"go for\"\n# Constraints:\n# * 1 <= len(sentence) <= 100\n# * sentence contains only letters\ndef words_in_sentence(sentence)\n","canonical_solution":"def words_in_sentence(sentence)\n  def is_prime?(num)\n    return false if num <= 1\n    (2..Math.sqrt(num)).none? { |i| num % i == 0 }\n  end\n  \n  words = sentence.split(\" \")\n  prime_length_words = words.select { |word| is_prime?(word.length) }\n  prime_length_words.join(\" \")\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_in_sentence\n    candidate = method(:words_in_sentence)\n    assert_equal(\"is\", candidate.call(\"This is a test\"))\n    assert_equal(\"go for\", candidate.call(\"lets go for swimming\"))\n    assert_equal(\"there is no place\", candidate.call(\"there is no place available here\"))\n    assert_equal(\"Hi am Hussein\", candidate.call(\"Hi I am Hussein\"))\n    assert_equal(\"go for it\", candidate.call(\"go for it\"))\n    assert_equal(\"\", candidate.call(\"here\"))\n    assert_equal(\"is\", candidate.call(\"here is\"))\n  end\nend\n"},{"task_id":"HumanEval_144","nl":"bod_Tibt","pl":"rb","prompt":"ཁྱོད་ཀྱིས་ x དང་ n ནི་ཆ་ཤས་ངེས་ཅན་ཡིན་པར་ངེས་ཤིང་། གྲངས་སུ་ 0 མེད་པར་ངེས་པ་ཡོད།གྲངས་དང་གྲངས་འཛིན་གཉིས་ཆ་རང་ནི་ཧྲིལ་པོ་རྩིས་ལྡན་ཡིན།x དང་ n གཉིས་ནི་ཕྲེང་བའི་རྩིས་རྟགས་ཡིན་ཏེ། འདྲ་བཤུས་འདི་འདྲ་ཡིན་ཏེ།x * n གྲངས་ཀ་ཧྲིལ་པོ་ཡིན་པ་དང་ false ཡིན་ན་ལས་འགན་ true སླར་ལོག་བྱེད།ཁྱོད་ཀྱི་ལས་འགན་ནི་ function ཞིག་ལག་ལེན་དུ་འཇུག་ནས་ཚིག་བརྗོད་པ་དལ་བུར་བཟོ་བ།# >>> simplify.call(\"1\/5\", \"5\/1\")\n# true\n# >>> simplify.call(\"1\/6\", \"2\/1\")\n# false\n# >>> simplify.call(\"7\/10\", \"10\/2\")\n# false\ndef simplify(x, n)\n","canonical_solution":"def simplify(x, n)\n  # Convert x and n to numerators and denominators\n  num_x, den_x = x.split('\/').map(&:to_i)\n  num_n, den_n = n.split('\/').map(&:to_i)\n\n  # Multiply fractions: (num_x * num_n) \/ (den_x * den_n)\n  numerator = num_x * num_n\n  denominator = den_x * den_n\n\n  # Check if the result is a whole number\n  numerator % denominator == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_simplify\n    candidate = method(:simplify)\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/6\", \"2\/1\"))\n    assert_equal(true, candidate.call(\"5\/1\", \"3\/1\"))\n    assert_equal(false, candidate.call(\"7\/10\", \"10\/2\"))\n    assert_equal(true, candidate.call(\"2\/10\", \"50\/10\"))\n    assert_equal(true, candidate.call(\"7\/2\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"11\/6\", \"6\/1\"))\n    assert_equal(false, candidate.call(\"2\/3\", \"5\/2\"))\n    assert_equal(false, candidate.call(\"5\/2\", \"3\/5\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"8\/4\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/5\", \"1\/5\"))\n  end\nend\n"},{"task_id":"HumanEval_145","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: ཚོས་གཞི་ཐོག་གི་ནང་ཐིག་གཞི་བཟུང་ནས་རིམ་སྒྲིག་བྱེད་པ།དྲན་གསོ། གལ་ཏེ་ནང་དོན་ཁ་ཤས་ཀྱི་ཨང་གྲངས་བསྡོམས་འདྲ་མཚུངས་ཡོད་ན།ཤོག་གྲངས་ཀྱི་གོ་རིམ་ལྟར་ཡར་འཕར་གྱི་གོ་རིམ་ལྟར་ཡིན།འབྲས་བུ་གྲངས་ཚང་གི་རིམ་པ་སྒྲིག་པའི་ལས་འགན་ཞིག་བྲིས་ཤིག# >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1, -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n","canonical_solution":"def order_by_points(nums)\n  nums.sort_by.with_index do |num, index|\n    [num.to_s.chars.map(&:to_i).sum.abs, index]\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11], candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32, 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6], candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"},{"task_id":"HumanEval_146","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: གྲངས་ཀྱི་ཨང་གྲངས་དང་པོ་དང་མཐའ་མ་ནི་རྣམ་གྲངས་ཡིན། (1, 3, 5, 7, 9)ཨང་གྲངས་དེ་ 10 ལས་མང་བ་ཡིན་པའི་ཨང་གྲངས་དང་གཉིས་ཀ་ཡིན།གྲངས་རིམ་ཅིག་ནང་འཇུག་དང་ཕྱིར་ལོག་བྱེད་ function ཞིག་འབྲི་དགོས།# >>> specialFilter.call([15, -73, 14, -15])\n# 1\n# >>> specialFilter.call([33, -2, -3, 45, 21, 109])\n# 2\ndef specialFilter(nums)\n","canonical_solution":"def specialFilter(nums)\n  nums.count do |num|\n    num > 10 && num.to_s[0].to_i.odd? && num.to_s[-1].to_i.odd?\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_specialFilter\n    candidate = method(:specialFilter)\n    assert_equal(0, candidate.call([5, -2, 1, -5]))\n    assert_equal(1, candidate.call([15, -73, 14, -15]))\n    assert_equal(2, candidate.call([33, -2, -3, 45, 21, 109]))\n    assert_equal(4, candidate.call([43, -12, 93, 125, 121, 109]))\n    assert_equal(3, candidate.call([71, -2, -33, 75, 21, 19]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(0, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_147","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་མཚོན།:a[i] + a[j] + a[k] ནི་ 3 ཀྱི་ལྡབ་བའང་ཡིན།ཕྱིར་ལོག་བྱེད་གྲངས་ནི་ a གི་ triples (a[i], a[j], a[k]) གྱི་གྲངས་ཡིན། དེར་ i < j < k, i (1 ≤ i ≤ n) རེ་རེ་ལ་ a[i] = i * i - i + 1 གྱི་ཐང་ཡིན།ཁྱོད་ཀྱིས་གྲངས་ཆ་ཚིམས་ n ཞིག་ཐོབ་ཡོད། ཁྱོད་ཀྱིས་གྲངས་ཆ་ཚིམས་ a ཡི་རིམ་པ་ n ཞིག་བཟོ་བཞིན་ཡོད།# >>> get_max_triples.call(5)\n# 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7, 13).\ndef get_max_triples(n)\n","canonical_solution":"def get_max_triples(n)\n  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }\n  count = 0\n  \n  (0...n).each do |i|\n    (i+1...n).each do |j|\n      (j+1...n).each do |k|\n        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_max_triples\n    candidate = method(:get_max_triples)\n    assert_equal(1, candidate.call(5))\n    assert_equal(4, candidate.call(6))\n    assert_equal(36, candidate.call(10))\n    assert_equal(53361, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_148","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།སྐར་མ་མིང་ནི་དྲང་པོ་མིན་འདུགལས་འགན་འདི་ plan1 ཡང་ན་ plan2 ཡིན་ན་སྟོང་པའི་གཞི་རིམ་ཕྱིར་ལོག་བྱེད་དགོས།ཉི་མའི་ཉེ་འགྲམ་ལ།སྐར་ཆེན་1དང་སྐར་ཆེན་2ཀྱི་འཁོར་ལམ་བར་གྱི་ས་ཁུལ།ལས་འགན་འདི་གིས་ སྐར་མ་ ཚང་མ་ཡོད་པའི་སྐར་མ་གཞི་རིམ་སླར་ལོག་བྱ་དགོས།སྐར་མ་གཉིས་ཀྱི་མིང་ planet1 དང་ planet2 ཟེར་བའི་ཐིག་ཡིག་ནང་བཀོད་དགོས།ཨུ་རུ་ནུ། ནེ་པྲུན་བཅས་ཡིན།མུ་རུའི་སྟེང་གི་ས་བོན་ནི་ཝེ་ནེར་ཡིན། དེའི་རྗེས་ལ་འཛམ་གླིང་དང་། མཱར་སི་དང་། མུ་པི་ཊར་དང་། སཱ་ཏུར་ནེ།ཉི་མའི་ལམ་ལུགས་ནང་སྐར་ཆེན་བརྒྱད་ཡོད་ཅིང་། ཉི་མའི་ཉེ་འགྲམ་ཆགས་པའི་སྐར་ཆེན་ཡིན།# >>> bf.call(\"Jupiter\", \"Neptune\")\n# [\"Saturn\", \"Uranus\"]\n# >>> bf.call(\"Earth\", \"Mercury\")\n# \"Venus\"\n# >>> bf.call(\"Mercury\", \"Uranus\")\n# [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\ndef bf(planet1, planet2)\n","canonical_solution":"def bf(planet1, planet2)\n  planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  \n  idx1 = planets.index(planet1)\n  idx2 = planets.index(planet2)\n  \n  return [] if idx1.nil? || idx2.nil?\n\n  start_idx, end_idx = [idx1, idx2].sort\n  \n  planets[(start_idx + 1)...end_idx]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_bf\n    candidate = method(:bf)\n    assert_equal([\"Saturn\", \"Uranus\"], candidate.call(\"Jupiter\", \"Neptune\"))\n    assert_equal([\"Venus\"], candidate.call(\"Earth\", \"Mercury\"))\n    assert_equal([\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"], candidate.call(\"Mercury\", \"Uranus\"))\n    assert_equal([\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"], candidate.call(\"Neptune\", \"Venus\"))\n    assert_equal([], candidate.call(\"Earth\", \"Earth\"))\n    assert_equal([], candidate.call(\"Mars\", \"Earth\"))\n    assert_equal([], candidate.call(\"Jupiter\", \"Makemake\"))\n  end\nend\n"},{"task_id":"HumanEval_149","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: ཁྱོད་ཀྱིས་ཚིག་ཐམས་ཅད་རིང་ཚད་གཅིག་མཚུངས་ཡིན་པར་བསམ་ཐུབ།ལས་འགན་འདི་ནི་རིམ་བཞིན་རིམ་བཞིན་གྱི་ string ཀྱི་རིམ་པ་ཕྱིར་ལོག་བྱེད་དགོས།ཚིག་གཉིས་རིང་ཚད་གཅིག་མཚུངས་ཡོད་ན་ array འདི་ alphabetically ནང་རིམ་སྒྲིག་དགོས།ཚད་གཞི་དེ་ནས་རིམ་སྒྲིག་བྱས་པའི་གཞི་རིམ་སླར་ལོག་བྱ་དགོས།ཚིག་རེ་རེ་བཞིན་གྱི་རིང་ཚད་དང་བསྟུན་པའི་རིམ་པ་ཡར་འཕོ་དགོས་ཏེ།འདྲ་པར་གཉིས་པ་ཡང་ཡོད་སྲིད་ཀྱི་རེད།ཨང་གྲངས་ཀྱི་རིམ་པ་གཏན་ནས་མ་ཡིན།འབྲས་བུ་དེ་རིམ་བཞིན་ཕྱིར་ལོག་བྱ་བ།ཚད་མ་རྣམ་གྲངས་ཡོད་པའི་ string རྣམས་འདེམས་ནས་སེལ་བ།ཚད་གཞི་ལྟར་ string གི་རིམ་པ་ངོས་ལེན་བྱེད་པའི་ function ཞིག་འབྲི་དགོས།# >>> list_sort.call([\"aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort.call([\"ab\", \"a\", \"aaa\", \"cd\"])\n# [\"ab\", \"cd\"]\ndef sorted_list_sum(lst)\n","canonical_solution":"def list_sort(arr)\n  arr.select { |s| s.length.even? }\n     .sort_by { |s| [s.length, s] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sorted_list_sum\n    candidate = method(:sorted_list_sum)\n    assert_equal([\"aa\"], candidate.call([\"aa\", \"a\", \"aaa\"]))\n    assert_equal([\"AI\", \"asdf\", \"school\"], candidate.call([\"school\", \"AI\", \"asdf\", \"b\"]))\n    assert_equal([], candidate.call([\"d\", \"b\", \"c\", \"a\"]))\n    assert_equal([\"abcd\", \"dcba\"], candidate.call([\"d\", \"dcba\", \"abcd\", \"a\"]))\n    assert_equal([\"AI\", \"ai\", \"au\"], candidate.call([\"AI\", \"ai\", \"au\"]))\n    assert_equal([], candidate.call([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]))\n    assert_equal([\"cc\", \"dd\", \"aaaa\", \"bbbb\"], candidate.call([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]))\n  end\nend\n"},{"task_id":"HumanEval_150","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།གྲངས་ཚིག དང་ y གི་ཐང་ལོག་འཇུག་དགོས།གལ་ཏེ་ n ནི་ ཡིན་ན་ x གི་ཐང་ཕྱིར་ལོག་བྱ་རྒྱུའི་ལས་རིམ་དྭངས་མ་ཞིག་ཡིན།# >>> x_or_y.call(7, 34, 12)\n# 34\n# >>> x_or_y.call(15, 8, 5)\n# 5\ndef x_or_y(n, x, y)\n","canonical_solution":"def x_or_y(n, x, y)\n  require 'prime'\n  n.prime? ? x : y\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_x_or_y\n    candidate = method(:x_or_y)\n    assert_equal(34, candidate.call(7, 34, 12))\n    assert_equal(5, candidate.call(15, 8, 5))\n    assert_equal(33, candidate.call(3, 33, 5212))\n    assert_equal(3, candidate.call(1259, 3, 52))\n    assert_equal(-1, candidate.call(7919, -1, 12))\n    assert_equal(583, candidate.call(3609, 1245, 583))\n    assert_equal(129, candidate.call(91, 56, 129))\n    assert_equal(1234, candidate.call(6, 34, 1234))\n    assert_equal(0, candidate.call(1, 2, 0))\n    assert_equal(2, candidate.call(2, 2, 0))\n  end\nend\n"},{"task_id":"HumanEval_151","nl":"bod_Tibt","pl":"rb","prompt":"ཚད་ལྡན་གྲངས་མེད་དང་གྲངས་ཆ་མེད་ལ་སྣང་མེད་བྱེད་ཅིགགྲངས་ཀྱི་རིམ་པ་ཐོབ་ནས་གྲངས་ཀྱི་གྲུ་བཞི་གི་བསྡོམས་གྲངས་ཕྱིར་ལོག་བྱེད་པ།# >>> double_the_difference.call([1, 3, 2, 0])\n# 10\n# >>> double_the_difference.call([-1, -2, 0])\n# 0\n# >>> double_the_difference.call([9, -2])\n# 81\n# >>> double_the_difference.call([0])\n# 0\n# If the input array is empty, return 0.\ndef double_the_difference(lst)\n","canonical_solution":"def double_the_difference(lst)\n  lst.select { |n| n.is_a?(Integer) && n.odd? && n >= 0 }\n     .map { |n| n ** 2 }\n     .sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_double_the_difference\n    candidate = method(:double_the_difference)\n    assert_equal(0, candidate.call([]))\n    assert_equal(25, candidate.call([5.0, 4.0]))\n    assert_equal(0, candidate.call([0.1, 0.2, 0.3]))\n    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))\n    assert_equal(0, candidate.call([-1.0, -2.0, 8.0]))\n    assert_equal(34, candidate.call([0.2, 3.0, 5.0]))\n    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]))\n  end\nend\n"},{"task_id":"HumanEval_152","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། ཚད་ནི་ 0 ཡིན་པ་དང་། གལ་ཏེ་དེ་ 0 ཡིན་ན་ཚད་ནི་དཔེར་བརྗོད་དང་ཐིག་ཁྲམ་གཉིས་ཀྱི་བར་གྱི་ཁྱད་པར་གཏན་ནས་ཡིན།ཚད་མཚུངས་པའི་གྲངས་ཐང་ཕྱིར་ལོག་བྱེད། ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཙམ་ཡོད་ན་ཚོད་དཔག་གང་ཡོད་ན་ཚོད་དཔག་གང་ཡོད་ན་ཚོད་དཔག་གང་ཡོད་ན་ཚོད་དཔག་གང་ཡོད་ན་ཚོད་དཔག་དགོས།ཁྱོད་ཚོར་ཚད་གཞི་དང་ཚོད་དཔག་ཚད་འདྲ་མཉམ་གྱི་ཚད་གཞི་གཉིས་ཐོབ་ཡོད། ཚད་གཞི་རེ་རེར་ཆ་མཐུན་གྱི་ཚད་གཞི་ཡོད།ཁྱོད་ཀྱི་ལས་འགན་ནི་མི་ཞིག་གིས་འགྲན་བསྡུར་གྱི་གྲུབ་འབྲས་དེ་བདེན་པར་ཚོད་ལྟ་བྱས་ཡོད་མེད་ལ་བརྟག་དཔྱད་བྱེད་རྒྱུ་དེ་ཡིན།འདྲ་བཤུས་དང་བསྡུར་བྱེད་འོས་པ་ཞིག་རེད།བྱུང་རིམ་དེ་མཇུག་ཏུ་ཤེས་རྟོགས་བྱུང་ཡོད། དེ་དུས་ཁྱེད་རང་ཚོར་བའི་ཚོར་སྣང་དང་བསམ་བློ་རྣམས་ཚང་མས་དུས་ཡུན་རིང་པོར་སྒུག་པའི་རྐྱེན་གྱི་ཚོར་བ་དེ་དྲན་གྱི་རེད།# >>> compare.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n# [0, 0, 0, 0, 3, 3]\n# >>> compare.call([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n# [4, 4, 1, 0, 0, 6]\ndef compare(game, guess)\n","canonical_solution":"def compare(game, guess)\n  game.zip(guess).map { |score, prediction| (score - prediction).abs }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare\n    candidate = method(:compare)\n    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))\n    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))\n    assert_equal([2, 4, 6], candidate.call([1, 2, 3], [-1, -2, -3]))\n    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3, 5], [-1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_153","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། (དེའི་ཤུགས་ནི་ -༡) ཡིན།return \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension ཟེར་བ་འདི་ནི་ཁ་སྐོང་ཤུགས་ཆེ་ཤོས་ཡིན་པས་ཕྱིར་ལོག་བྱེད།རྒྱས་འགྲེལ། ['SERVINGSliCes', 'Cheese', 'StuFfed'] བྱས་ན་ཁྱེད་ཀྱིས་ དཔེར་ན་ \"Slices\" ཟེར་བའི་སློབ་ཚན་དང་ ཟེར་བའི་གཞི་རིམ་ཐོབ་ཡོད་ན།ཚད་གཞི་ནང་ཐོག་མར་ཐོན་པ་འདེམས་དགོས།གལ་ཏེ་ནུས་པ་གཅིག་མཚུངས་ཡོད་པའི་ extension གཉིས་སམ་དེ་ལས་མང་བ་ཡོད་ན།format: ClassName.StrongestExtensionName.   ཚད་འཛིན་མིང་། ཚད་འཛིན་མིང་། ཚད་འཛིན་མིང་། ཚད་འཛིན་མིང་། ཚད་འཛིན་མིང་། ཚད་འཛིན་མིང་།ཁྱོད་ཀྱིས་ཤུགས་ཆེ་ཤོས་ཀྱི་ extension འཚོལ་ནས་དེའི་ནང་ string སླར་ལོག་བྱེད་དགོས།ཤུགས་ཚད་ནི་ CAP-SM ཀྱི་ཆ་ཤས་ཀྱིས་སྟོན་ཡོད།ཡིག་འབྲུ་ཆུང་ཆུང་གི་མིང་དུ་ SM ཟེར་དགོས།ཚད་འཛིན་གྱི་ནུས་པ་འདི་འདྲ་ཡིན། CAP ནི་ཡིག་འབྲུ་ཆེན་པོའི་གྲངས་ཀ་ཡིན་པར་བྱའོ།རྒྱས་འགྲེལ། ཚད་མ་དེ་སློབ་ཚན་གྱི་ནང་འཇུག་བྱེད་ཆེད་བེད་སྤྱོད་བྱ་དགོས།ཁྱོད་ཚོར་ class གི་མིང་ (string) དང་ extension གི་རིམ་པ་ཐོབ་ངེས་ཡིན།# >>> Strongest_Extension.call(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n# \"my_class.AA\"\ndef Strongest_Extension(class_name, extensions)\n","canonical_solution":"def Strongest_Extension(class_name, extensions)\n  strongest_extension = extensions.max_by do |extension|\n    cap_count = extension.count('A-Z')\n    sm_count = extension.count('a-z')\n    cap_count - sm_count\n  end\n  \"#{class_name}.#{strongest_extension}\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_Strongest_Extension\n    candidate = method(:Strongest_Extension)\n    assert_equal(\"Watashi.eIGHt8OKe\", candidate.call(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]))\n    assert_equal(\"Boku123.YEs.WeCaNe\", candidate.call(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]))\n    assert_equal(\"__YESIMHERE.NuLl__\", candidate.call(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]))\n    assert_equal(\"K.TAR\", candidate.call(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]))\n    assert_equal(\"__HAHA.123\", candidate.call(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]))\n    assert_equal(\"YameRore.okIWILL123\", candidate.call(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]))\n    assert_equal(\"finNNalLLly.WoW\", candidate.call(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]))\n    assert_equal(\"_.Bb\", candidate.call(\"_\", [\"Bb\", \"91245\"]))\n    assert_equal(\"Sp.671235\", candidate.call(\"Sp\", [\"671235\", \"Bb\"]))\n  end\nend\n"},{"task_id":"HumanEval_154","nl":"bod_Tibt","pl":"rb","prompt":"ཁྱོད་ཀྱིས་ཚིག་གཉིས་ཐོབ་ཡོད། གལ་ཏེ་ཚིག་གཉིས་པ་ཡང་ན་དེའི་འཁོར་བ་གང་ཞིག་ནི་ཚིག་དང་པོའི་ནང་གི་འོག་རིམ་ཡིན་ན་ true སླར་ལོག་བྱེད་དགོས་པ་ཡིན།# >>> cycpattern_check.call(\"abcd\", \"abd\")\n# false\n# >>> cycpattern_check.call(\"hello\", \"ell\")\n# true\n# >>> cycpattern_check.call(\"whassup\", \"psus\")\n# false\n# >>> cycpattern_check.call(\"abab\", \"baa\")\n# true\n# >>> cycpattern_check.call(\"efef\", \"eeff\")\n# false\n# >>> cycpattern_check.call(\"himenss\", \"simen\")\n# true\ndef cycpattern_check(a, b)\n","canonical_solution":"def cycpattern_check(a, b)\n  (0...b.length).each do |i|\n    rotated_b = b[i..-1] + b[0...i]\n    return true if a.include?(rotated_b)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_cycpattern_check\n    candidate = method(:cycpattern_check)\n    assert_equal(false, candidate.call(\"xyzw\", \"xyw\"))\n    assert_equal(true, candidate.call(\"yello\", \"ell\"))\n    assert_equal(false, candidate.call(\"whattup\", \"ptut\"))\n    assert_equal(true, candidate.call(\"efef\", \"fee\"))\n    assert_equal(false, candidate.call(\"abab\", \"aabb\"))\n    assert_equal(true, candidate.call(\"winemtt\", \"tinem\"))\n  end\nend\n"},{"task_id":"HumanEval_155","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། ཨང་གྲངས་ཧྲིལ་པོ་ཡོད་ན། ཕྲེང་བ་དང་ཕྲེང་བ་མེད་པའི་ཨང་གྲངས་ཡོད་པའི་གྲངས་གཞི་ཅིག་ཕྱིར་སློག་བྱ་དགོས།# >>> even_odd_count.call(-12)\n# [1, 1]\n# >>> even_odd_count.call(123)\n# [1, 2]\ndef even_odd_count(num)\n","canonical_solution":"def even_odd_count(num)\n  num.to_s.chars.map(&:to_i).select { |digit| digit != 0 }.partition(&:even?).map(&:count)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_count\n    candidate = method(:even_odd_count)\n    assert_equal([0, 1], candidate.call(7))\n    assert_equal([1, 1], candidate.call(-78))\n    assert_equal([2, 2], candidate.call(3452))\n    assert_equal([3, 3], candidate.call(346211))\n    assert_equal([3, 3], candidate.call(-345821))\n    assert_equal([1, 0], candidate.call(-2))\n    assert_equal([2, 3], candidate.call(-45347))\n    assert_equal([1, 0], candidate.call(0))\n  end\nend\n"},{"task_id":"HumanEval_156","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ཚད་འཛིན་: 1 <= num <= 1000ཆེ་ཆུང་ཡིག་གཟུགས་ནང་ཕྱིར་ལོག་བྱེད་ཅིགའབྲས་བུ་ལྡན་གྲངས་ཤིག་ཡོད་ན། རོམ་གྲངས་ཀྱི་འདྲ་མཚུངས་དེ་ཐིག་ཡིག་ལྟར་ལེན་དགོས།# >>> int_to_mini_roman.call(19)\n# \"xix\"\n# >>> int_to_mini_roman.call(152)\n# \"clii\"\n# >>> int_to_mini_roman.call(426)\n# \"cdxxvi\"\ndef int_to_mini_roman(number)\n","canonical_solution":"def int_to_mini_roman(number)\n  values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n\n  result = ''\n  values.each_with_index do |value, index|\n    while number >= value\n      number -= value\n      result += numerals[index]\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"},{"task_id":"HumanEval_157","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། ཚད་མ་ ༩༠ ཡོད་པ་རེད།ཟུར་གསུམ་ཟུར་དྲང་པོ་ནི་ཟུར་གསུམ་གྱི་ཟུར་གཅིག་ཟུར་དྲང་པོ་ཡིན་པའམ། ཡང་ན་ཕྱོགས་གཉིས་ནི་ཟུར་དྲང་གསུམ་གྱི་དབྱིབས་ཡིན་ན། འདྲ་མིན་ན་རྫུན་རེད།ཚད་གསུམ་གྱི་ཟུར་གསུམ་གྱི་རིང་ཚད་ཡོད་ན། true སླར་ལོག་བྱེད།# >>> right_angle_triangle.call(3, 4, 5)\n# true\n# >>> right_angle_triangle.call(1, 2, 3)\n# false\ndef right_angle_triangle(a, b, c)\n","canonical_solution":"def right_angle_triangle(a, b, c)\n  sides = [a, b, c].sort\n  sides[0]**2 + sides[1]**2 == sides[2]**2\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_right_angle_triangle\n    candidate = method(:right_angle_triangle)\n    assert_equal(true, candidate.call(3, 4, 5))\n    assert_equal(false, candidate.call(1, 2, 3))\n    assert_equal(true, candidate.call(10, 6, 8))\n    assert_equal(false, candidate.call(2, 2, 2))\n    assert_equal(true, candidate.call(7, 24, 25))\n    assert_equal(false, candidate.call(10, 5, 7))\n    assert_equal(true, candidate.call(5, 12, 13))\n    assert_equal(true, candidate.call(15, 8, 17))\n    assert_equal(true, candidate.call(48, 55, 73))\n    assert_equal(false, candidate.call(1, 1, 1))\n    assert_equal(false, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_158","nl":"bod_Tibt","pl":"rb","prompt":"ཡིག་འབྲུ་ནང་ཚིག་མཛོད་ཀྱི་རིམ་པ་ཐོག་མར་ཐོན་པ་ཕྱིར་ལོག་བྱེད་པ།གལ་ཏེ་ string མང་པོ་ཡོད་ན་ unique  གྱི་གྲངས་མང་ཤོས་ཡོད་ན་གྲལ་ཐིག་ནང་ཚིག་ཚིག་མི་འདྲ་བ་ཡོད། ཚིག་ཚིག་མང་ཤོས་ཕྱིར་ལོག་བྱེད།ཚད་གཞི་ (string) གྱི་རིམ་པ་ (array) ཞིག་ལེན་པའི་ལས་འགན་ཞིག་བྲིས་དགོས།# >>> find_max.call([\"name\", \"of\", \"string\"])\n# \"string\"\n# >>> find_max.call([\"name\", \"enam\", \"game\"])\n# \"enam\"\n# >>> find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\ndef find_max(words)\n","canonical_solution":"def find_max(words)\n  # Helper function to count unique characters\n  def unique_char_count(word)\n    word.chars.uniq.size\n  end\n\n  words.max_by { |word| [unique_char_count(word), -word] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n  end\nend\n"},{"task_id":"HumanEval_159","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་ཆ། གལ་ཏེ་མར་ཀེ་རོ་ཊི་ལྷག་མ་གངམ་མེད་ན། ཁྱོད་ཀྱིས་མར་ཀེ་རོ་ཊི་ལྷག་མ་ཚང་མ་ཟ་ནའང་མུ་གེས་ལུས་པར་འགྱུར།ཟ་ཚར་རྗེས་ལྷག་པའི་ཀེ་རོ་ཊི་གྲངས་ ] ཟ་ཚར་བའི་རྗེས་ལ་ཟ་ཚར་བའི་ཀེ་རོ་ཊི་གྲངས་ ༦༠ ཙམ་ཕྱིར་ལོག་བྱེད་ཆོགད་ལྟའི་ཟས་རེའི་ནང་ག་ག་མང་ཟ་དགོས་པ་རེད།ཁྱོད་ནི་ལྟོ་བ་ཚ་བའི་བེའུ་ཞིག་རེད། ཁྱོད་ཀྱིས་ག་རེར་ག་རེར་ག་རེར་ཟ་ཚར་ཡོད།# >>> eat.call(5, 6, 10)\n# [11, 4]\n# >>> eat.call(4, 8, 9)\n# [12, 1]\n# >>> eat.call(1, 10, 10)\n# [11, 0]\n# >>> eat.call(2, 11, 5)\n# [7, 0]\n# Variables:\n# @number : integer\n# the number of carrots that you have eaten.\n# @need : integer\n# the number of carrots that you need to eat.\n# @remaining : integer\n# the number of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\ndef eat(number, need, remaining)\n","canonical_solution":"def eat(number, need, remaining)\n  total_eaten = number + [need, remaining].min\n  carrots_left = [remaining - need, 0].max\n  [total_eaten, carrots_left]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_eat\n    candidate = method(:eat)\n    assert_equal([11, 4], candidate.call(5, 6, 10))\n    assert_equal([12, 1], candidate.call(4, 8, 9))\n    assert_equal([11, 0], candidate.call(1, 10, 10))\n    assert_equal([7, 0], candidate.call(2, 11, 5))\n    assert_equal([9, 2], candidate.call(4, 5, 7))\n    assert_equal([5, 0], candidate.call(4, 5, 1))\n  end\nend\n"},{"task_id":"HumanEval_160","nl":"bod_Tibt","pl":"rb","prompt":"འབྲེལ་མཐུད་རིམ་པ་ཞིག་ལ་ཉུང་མཐར་འབྲེལ་མཐུད་རིམ་པ་གཅིག་དང་འབྲེལ་མཐུད་རིམ་པ་གཉིས་ཡོད་དགོས།ཨོ་པེ་རན་ཌི་ནི་ ནེ་གེ་རེ་ཊི་མེད་པའི་ཧྲིལ་གྲངས་ཀྱི་རིམ་པ་ཡིན།འབྲེལ་བའི་རིམ་པ་ཚུའི་རིང་ཚད་ནི་རིམ་པ་ཚུའི་རིང་ཚད་དང་མི་འདྲ་བ་གཅིག་ཡིན།དྲན་གསོ།= = གྲུབ་འབྲས་ = 9 འབྲས་བུ་ནི་ 2 + 3 * 4 - 5 ཡིན།array = [2, 3, 4, 5] ཟེར་བ་ལྟ་བུ།ལས་འཛིན་པ་['+', '*', '-'] དཔེ་ཆ། ཚད་འཛིན་གྱི་རིམ་པ། (**) གྱེན་གྱི་ཆ་ཤས་ (_ _) བསྐྱར་ལྡན། (*) ཕྱིར་བཏོན་ (--) བྱེད་པ།བསྡུར་ཐེངས། (+) ཚད་ལྡན་ཨང་རྩིས་ཀྱི་ལག་ལེན་ཚུ།expression དང་ expression གི་མཐའ་འབྲས་སླར་ལོག་བྱེད།ཐིག་ཁྲམ་གཉིས་པ་ནི་ཨང་གྲངས་ཧྲིལ་པོ་དག་གི་ཐིག་ཁྲམ་ཡིན། ཚད་ལྡན་ཨང་གྲངས་ཀྱི་ཐིག་ཁྲམ་གཉིས་བེད་སྤྱོད་བྱེད་ནས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཀྱི་ཐིག་ཁྲམ་བཟོ།ཨེ་རེ་གཉིས་ལྡན་གྱི་ཨོ་པེ་ཊར་དང་ཨོ་པེ་རན་ཌ་གཉིས་ཡོད་ན། ཨེ་རེ་དང་པོ་ལ་ཨལ་ཇི་བིར་གྱི་གཞི་རྟེན་གྱི་སྤྱོད་སྤྱད་ཡོད།def do_algebra(operator, operand)\n","canonical_solution":"def do_algebra(operator, operand)\n  expression = operand[0].to_s\n  operator.each_with_index do |op, index|\n    if op == '\/\/'\n      expression += ' \/ ' + operand[index + 1].to_s\n    else\n      expression += ' ' + op + ' ' + operand[index + 1].to_s\n    end\n  end\n  eval(expression)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_do_algebra\n    candidate = method(:do_algebra)\n    assert_equal(37, candidate.call([\"**\", \"*\", \"+\"], [2, 3, 4, 5]))\n    assert_equal(9, candidate.call([\"+\", \"*\", \"-\"], [2, 3, 4, 5]))\n    assert_equal(8, candidate.call([\"\/\/\", \"*\"], [7, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_161","nl":"bod_Tibt","pl":"rb","prompt":"དཔེ་གཟིགས།ལས་འགན་འདི་ནས་ཐིག་ལེ་ཐོན་པའི་འབྲས་བུ་ཕྱིར་ལོག་བྱ་དགོས།string ནང་ཡི་གེ་མེད་ན་ string ཕྱིར་ལྡོག་དགོས།དེ་མིན་དེ་འདྲ་བཞག་ན་ཡག་པོ་རེད།གལ་ཏེ་ s[i]ནི་ཡི་གེ་ཡིན་ན། དེའི་ཡིག་གཟུགས་འོག་ནས་གོང་དུ་སྒྱུར་བའམ་རྒྱབ་ཕྱོགས་ལ་བསྒྱུར་བ།ཚད་གཞི་དེ་ཁྱོད་ལ་ཐིག་ལེ་ s ཞིག་སྤྲད་ཡོད།# >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n","canonical_solution":"def solve(s)\n  if s =~ \/[a-zA-Z]\/\n    s.chars.map { |char| char =~ \/[a-zA-Z]\/ ? char.swapcase : char }.join\n  else\n    s.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\", candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"#$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"},{"task_id":"HumanEval_162","nl":"bod_Tibt","pl":"rb","prompt":"གལ་ཏེ་ 'text' ནི་སྟོང་པའི་ string ཡིན་ན་ null སླར་ལོག་བྱེད།string 'text' ཤིག་ཡོད་ན། md5 ཧེཤི་འདྲ་མཉམ་གྱི་ string དེ་ཕྱིར་སློག་དགོས།# >>> string_to_md5.call(\"Hello world\")\n# \"3e25960a79dbc69b674cd4ec67a72c62\"\ndef string_to_md5(text)\n","canonical_solution":"require 'digest'\n\ndef string_to_md5(text)\n  return nil if text.empty?\n  Digest::MD5.hexdigest(text)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_to_md5\n    candidate = method(:string_to_md5)\n    assert_equal(\"3e25960a79dbc69b674cd4ec67a72c62\", candidate.call(\"Hello world\"))\n    assert_equal(nil, candidate.call(\"\"))\n    assert_equal(\"0ef78513b0cb8cef12743f5aeb35f888\", candidate.call(\"A B C\"))\n    assert_equal(\"5f4dcc3b5aa765d61d8327deb882cf99\", candidate.call(\"password\"))\n  end\nend\n"},{"task_id":"HumanEval_163","nl":"bod_Tibt","pl":"rb","prompt":"དཔེར་ན་: b ཡར་རྒྱས་ཀྱི་རིམ་པ་བཞིན་འབྲས་བུ་ཆ་མཉམ་ a དང་ b གཉིས་ཡོད་ན། a དང་ b  གི་བར་གྱི་གྲངས་ཆ་ཆ་ཉེར་ལྡོག་ཕྱིར་ལོག་བྱོས།# >>> generate_integers.call(2, 8)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(8, 2)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(10, 14)\n# []\ndef generate_integers(a, b)\n","canonical_solution":"def generate_integers(a, b)\n  (a..b).to_a.concat((b..a).to_a).select { |num| num.even? }.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_generate_integers\n    candidate = method(:generate_integers)\n    assert_equal([2, 4, 6, 8], candidate.call(2, 10))\n    assert_equal([2, 4, 6, 8], candidate.call(10, 2))\n    assert_equal([2, 4, 6, 8], candidate.call(132, 2))\n    assert_equal([], candidate.call(17, 89))\n  end\nend\n"}]