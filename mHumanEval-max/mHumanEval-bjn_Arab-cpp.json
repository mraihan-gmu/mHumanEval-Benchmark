[
    {
        "task_id": "HumanEval/0",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤرچاي اڤابيلا دالم ۏيكتور ارق دبري، اد دوا ارق نڠ لابه كاي ڤد ساتو لاڬي دري تاهون ڤرتام دبري. >>> has_close_elements{(std::vector<float>{(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f)) (false) >>> has_close_elements{(std::vector<float>{(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f)) (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n",
        "canonical_solutions": "bool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order\n    for (size_t i = 1; i < numbers.size(); i++) {\n        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = has_close_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/1",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤانݢݢالاهان ڤانݢݢالاهان ݢاريس ݢاسان ݢاريس ݢاسان ݢاريس ݢاسان ڤانݢالاهان ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس ݢاريس \nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') continue;  // Ignore spaces\n\n        current_group += ch;\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n            if (balance == 0) {  // Found a balanced group\n                groups.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return groups;\n}",
        "test": "}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"(()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/2",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديباڠونكن سابوتيڠ نومبور ڤوسيتيف ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ ڤونچ\nfloat truncate_number(float number) {\n",
        "canonical_solutions": "float truncate_number(float number) {\n    return number - std::floor(number);\n}",
        "test": "}\nint main() {\n    auto candidate = truncate_number;\n    assert(candidate((3.5f)) == (0.5f));\n    assert(candidate((1.25f)) == (0.25f));\n    assert(candidate((123.0f)) == (0.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/3",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤاكتور ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤڠاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن ڤاجرن\nbool below_zero(std::vector<long> operations) {\n",
        "canonical_solutions": "bool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = below_zero;\n    assert(candidate((std::vector<long>())) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/4",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// باݢي ۏيکتور ڤڠمبيلن، مڠحساباكن ميسين ابسولوت ديبياوات دأوسيا داتا سيت اين. ميسين ابسولوت اداله ڤربيداان اوسها ابسولوت انتارا ستياڤ ايليمن وان تيتيق ڤوست (امڤت دالم حال اين): MAD = average ٠ x - x_mean ٠ >>> mean_absolute_deviation (((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n",
        "canonical_solutions": "float mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, \n                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) \n                / numbers.size();\n    return mad;\n}",
        "test": "}\nint main() {\n    auto candidate = mean_absolute_deviation;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));\n}\n"
    },
    {
        "task_id": "HumanEval/5",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠاندوڠاكن سابوءه ارقام 'ديليميتير' انتارا ستياڤ دوا ايليمن كونسيكوتيف `numbers `) >>> intersperse (((std::vector<long>()), (4)) (std::vector<long>()) >>> intersperse (((std::vector<long>({long) 1, (long) 2, (long) 3})), (4)) (std::vector<long>({long) 1, (long) 4, (long) 2, (long) 4, (long) 3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n",
        "canonical_solutions": "std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<long> result;\n    for (size_t i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = intersperse;\n    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));\n    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/6",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤانݢݢالان ڤانݢالان ݢاسان ڤانݢالان ݢاسان ڤانݢالان نانݢ ديڤاركاتان لاوان ڤاراكتىس نانݢ ديڤاراكاتان لاوان ڤاراكتىس. ݢاسان ستياڤ ڤانݢالان, ڤانݢالان ݢاسان ڤانݢالان نانݢ ديڤاراكاتان لاوان ڤاراكتىس نانݢ ڤاليڠ ديڤاراكتان. چونتوهڽ (() (()) باݢي ماكسىمىؤم دوا ڤانݢالان نانݢ ديڤاراكتان لاوان ((())) باݢي تاترى. >>> parse_nested_parens (((\"((()))) ((())) () (((()))))))) (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> depths;\n    long current_depth = 0, max_depth = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') {\n            if (max_depth > 0) {\n                depths.push_back(max_depth);\n                max_depth = 0;\n            }\n            current_depth = 0;\n        } else if (ch == '(') {\n            current_depth++;\n            max_depth = std::max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n\n    if (max_depth > 0) {\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
    },
    {
        "task_id": "HumanEval/7",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيلتر ڤيكتور ڤرماءينن ستريڠ هاڽ باڬي اورڠ-اورڠ نڠ ممڤوڽاءي سوبسترينگ >>> filter_by_substring(((std::vector<std::string>() ، (\"a\")) (std::vector<std::string>()) >>> filter_by_substring((((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bacd\", (std::string) \"cde\", (std::string) \"array\"}) ، (\"a\") (std::vector<std::string>(({(std::string) abc\", (std::string) \"bacd\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.find(substring) != std::string::npos) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_substring;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"aaaxxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"aaaxxy\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"grunt\", (std::string)\"trumpet\", (std::string)\"prune\", (std::string)\"gruesome\"})), (\"run\")) == (std::vector<std::string>({(std::string)\"grunt\", (std::string)\"prune\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/8",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// باݢي سابوءه ۏيکتور اينتيݢر، مڽاتاكن سابوءه توڤل نڠ باءيسي سومبڠن وان ڤربواتن سموا اينتيݢر دالم سابوءه ۏيکتور. سومبڠن باءيق هاروس سام وان ݢونوڠ وان ڤربواتن باءيق هاروس سام وان 1. >>> sum_product(((std::vector<long>())) (std::make_tuple(0, 1)) >>> sum_product(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);\n    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());\n    return std::make_tuple(sum, product);\n}",
        "test": "}\nint main() {\n    auto candidate = sum_product;\n    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));\n    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));\n    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));\n}\n"
    },
    {
        "task_id": "HumanEval/9",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دري سابوتيڠ ۏيكتور انتيڬري، ماولاكن ۏيكتور رولانݢ ايليمن ماكسيما نڠ دتومڤوڠ سمڤأي ڤريستيوا دالم سيكويري. >>> rolling_max(((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 3, (long) 4, (long) 2}))) (std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = LONG_MIN;\n\n    for (long num : numbers) {\n        max_so_far = std::max(max_so_far, num);\n        result.push_back(max_so_far);\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = rolling_max;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));\n}\n"
    },
    {
        "task_id": "HumanEval/10",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ماكن ڤاليندروم ڤاليڠ كورڠ نڠ مولاي دڠن سورت ڤاليندروم. ايديا الورڬيتم ساڠت سيبيل: - ماكن ڤاس ڤوتفيكس ڤاليڠ لاما سورت ڤاليندروم. - ماكن ڤرڤادوان سورت ڤاليندروم ك سورت ڤاليندروم. >>> ماكن_ڤاليندروم (((\"\")) (\"\") >>> ماكن_ڤاليندروم (((\"cat\")) (\"كاتك\") >>> ماكن_ڤاليندروم (((\"cata\")) (\"كاتك\")\nstd::string make_palindrome(std::string string) {\n",
        "canonical_solutions": "std::string make_palindrome(std::string string) {\n    auto is_palindrome = [](const std::string &s) {\n        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());\n    };\n\n    for (size_t i = 0; i < string.size(); ++i) {\n        if (is_palindrome(string.substr(i))) {\n            std::string prefix = string.substr(0, i);\n            std::reverse(prefix.begin(), prefix.end());\n            return string + prefix;\n        }\n    }\n\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"jerry\")) == (\"jerryrrej\"));\n}\n"
    },
    {
        "task_id": "HumanEval/11",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input اداله دوا تار a وان b نڠ تاڽاڽ 1 وان 0۔ ڤروليهان XOR باينري ڤد ڤڠمبيلن ڠيني وان ڤاڤنڽ جوا ساباڬاي تار۔ >>> string_xor((\"010\"), (\"110\")) (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n",
        "canonical_solutions": "std::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
    },
    {
        "task_id": "HumanEval/12",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دري ۏيكتور ستريڠ، ڤرلو مڽاراكن ڤيڠتاما. ڤرلو مڽاراكن ڤيڠتاما ڤرتام دالم كيس باڽق ستريڠ دري ڤيڠتاما سام. ڤرلو مڽاراكن نون دالم كيس ڤيڠتاما ڤرلو كيس ڤيڠتاما. >>> longest(((std::vector<std::string>())) std::nullopt >>> longest(((std::vector<std::string>{((std::string) \"a\", (std::string) \"b\", (std::string) \"c\"}))) \"a\" >>> longest(((std::vector<std::string>(((std::string) \"a\", (std::string) \"bb\", (stdstring) \"cc\"} \"cc\")))::c\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) return std::nullopt;\n\n    return *std::max_element(strings.begin(), strings.end(), \n                             [](const std::string& a, const std::string& b) {\n                                 return a.size() < b.size();\n                             });\n}",
        "test": "}\nint main() {\n    auto candidate = longest;\n    assert(candidate((std::vector<std::string>())) == std::nullopt);\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == \"x\");\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"yyy\", (std::string)\"zzzz\", (std::string)\"www\", (std::string)\"kkkk\", (std::string)\"abc\"}))) == \"zzzz\");\n}\n"
    },
    {
        "task_id": "HumanEval/13",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مروڤاكن سابوءه ڤربينچڠن كومون نڠ ڤاليڠ بسر دري دوا انتيڬره a وان b >>> greatest_common_divisor (((3), (5)) (1) >>> greatest_common_divisor (((25), (15)) (5)\nlong greatest_common_divisor(long a, long b) {\n",
        "canonical_solutions": "long greatest_common_divisor(long a, long b) {\n    return std::gcd(a, b);\n}",
        "test": "}\nint main() {\n    auto candidate = greatest_common_divisor;\n    assert(candidate((3), (7)) == (1));\n    assert(candidate((10), (15)) == (5));\n    assert(candidate((49), (14)) == (7));\n    assert(candidate((144), (60)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/14",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيكتور ڤرجالنن كسموا ڤريفكس دري ڤاليڠ كوتاه سمڤأي ڤاليڠ لاما دري ساءنجور ڤرتاهنن >>> all_prefixes (((\"abc\")) (std::vector<std::string> (({(std::string) \"a\", (std::string) \"ab\", (std::string) \"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n",
        "canonical_solutions": "std::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (size_t i = 1; i <= string.size(); ++i) {\n        prefixes.push_back(string.substr(0, i));\n    }\n    return prefixes;\n}",
        "test": "}\nint main() {\n    auto candidate = all_prefixes;\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"asdfgh\")) == (std::vector<std::string>({(std::string)\"a\", (std::string)\"as\", (std::string)\"asd\", (std::string)\"asdf\", (std::string)\"asdfg\", (std::string)\"asdfgh\"})));\n    assert(candidate((\"WWW\")) == (std::vector<std::string>({(std::string)\"W\", (std::string)\"WW\", (std::string)\"WWW\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/15",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڽاتاكن ساءيرڠ نڠ مان ناڠ باءيسي نومبور نڠ ديبينتيڠ ڤاس ڤاس ڤاس ڤاس ڤاس برمولا دري 0 سمڤأي n. >>> string_sequence((0)) (\"0\") >>> string_sequence((5)) (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n",
        "canonical_solutions": "std::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i > 0) oss << \" \";\n        oss << i;\n    }\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_sequence;\n    assert(candidate((0)) == (\"0\"));\n    assert(candidate((3)) == (\"0 1 2 3\"));\n    assert(candidate((10)) == (\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"
    },
    {
        "task_id": "HumanEval/16",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتاهن سابوءه ساءينتير، مانجولكن ساكيتار-ساكيتار نڠ بابيدا (باڬي مان مان مان كيس) نڠ مان اي مڠمبيل >>> count_distinct_characters (((\"xyzXYZ\")) (3) >>> count_distinct_characters (((\"Jerry\")) (4)\nlong count_distinct_characters(std::string string) {\n",
        "canonical_solutions": "long count_distinct_characters(std::string string) {\n    std::unordered_set<char> distinct_chars;\n    for (char ch : string) {\n        distinct_chars.insert(std::tolower(ch));\n    }\n    return distinct_chars.size();\n}",
        "test": "}\nint main() {\n    auto candidate = count_distinct_characters;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abcde\")) == (5));\n    assert(candidate((\"abcdecadeCADE\")) == (5));\n    assert(candidate((\"aaaaAAAAaaaa\")) == (1));\n    assert(candidate((\"Jerry jERRY JeRRRY\")) == (5));\n}\n"
    },
    {
        "task_id": "HumanEval/17",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤانݢݢݢيران ڤانݢݢݢيران ݢاسان مانݢݢݢالاكان تاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتاتات\nstd::vector<long> parse_music(std::string music_string) {\n",
        "canonical_solutions": "std::vector<long> parse_music(std::string music_string) {\n    std::vector<long> beats;\n    std::istringstream iss(music_string);\n    std::string note;\n    \n    while (iss >> note) {\n        if (note == \"o\") beats.push_back(4);\n        else if (note == \"o|\") beats.push_back(2);\n        else if (note == \".|\") beats.push_back(1);\n    }\n\n    return beats;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_music;\n    assert(candidate((\"\")) == (std::vector<long>()));\n    assert(candidate((\"o o o o\")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\".| .| .| .|\")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));\n    assert(candidate((\"o| o| .| .| o o o o\")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\"o| .| o| .| o o| o o|\")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/18",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ماچم ساج ڤون جادي سوبسترينگ نڠ دبريكن د ساج اوريجنل. مڠحساب كاسوس نڠ مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان\nlong how_many_times(std::string string, std::string substring) {\n",
        "canonical_solutions": "long how_many_times(std::string string, std::string substring) {\n    if (substring.empty()) return 0;\n    \n    long count = 0;\n    size_t pos = 0;\n    \n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++;  // Move one position forward to count overlapping occurrences\n    }\n    \n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = how_many_times;\n    assert(candidate((\"\"), (\"x\")) == (0));\n    assert(candidate((\"xyxyxyx\"), (\"x\")) == (4));\n    assert(candidate((\"cacacacac\"), (\"cac\")) == (4));\n    assert(candidate((\"john doe\"), (\"john\")) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/19",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤاڤرن اداله سڤنجڠ ڤڠاروهن ڤوست دالم ڤرماءينن نومبور دري 'صفر' سمڤأي 'تاهون'. ڤيليهن ڤاليڠ باءيق اداله 'صفر', 'ساتو', 'دوا', 'ثلاث', 'چهار', 'خمس', 'دوا', 'سبوت', 'تمڤت' دان 'تاهون'. مروڤاكن سڤنجڠ دڠن نومبور دڤرتنديڠن دري نڠ ڤاليڠ كايڠ سمڤأي نڠ ڤاليڠ بسر >>> sort_numbers((\"three one five\")) (\"واحد تيڬ ليم\")\nstd::string sort_numbers(std::string numbers) {\n",
        "canonical_solutions": "std::string sort_numbers(std::string numbers) {\n    std::unordered_map<std::string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    std::unordered_map<int, std::string> rev_map = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    std::istringstream iss(numbers);\n    std::vector<int> num_list;\n    std::string word;\n\n    while (iss >> word) {\n        num_list.push_back(num_map[word]);\n    }\n\n    std::sort(num_list.begin(), num_list.end());\n\n    std::ostringstream oss;\n    for (size_t i = 0; i < num_list.size(); ++i) {\n        if (i > 0) oss << \" \";\n        oss << rev_map[num_list[i]];\n    }\n\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = sort_numbers;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"three\")) == (\"three\"));\n    assert(candidate((\"three five nine\")) == (\"three five nine\"));\n    assert(candidate((\"five zero four seven nine eight\")) == (\"zero four five seven eight nine\"));\n    assert(candidate((\"six five four three two one zero\")) == (\"zero one two three four five six\"));\n}\n"
    },
    {
        "task_id": "HumanEval/20",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دري ۏيكتور ارقام (بڠكيتڽ كادا كادوا) ڤيليه وان مروڤاكن دوا ايليمن نڠ ڤاليڠ كاي كڤد سابوءهڽ وان مروڤاكنڽ دالم اورد (ارقام نڠ كاي، ارقام نڠ كاي). >>> find_closest_elements (((std::vector<float>(({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) (std::make_tuple (((2.0f, 2.2f)) >>> find_closest_elements (((std::vector<float>(({(float)1.0f, (float)2.0f, (float)3.0f, (float04.0f, (float5.0f, (float2.0f)) (std::make_tuple: 2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0, num2 = 0;\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = numbers[i] - numbers[i - 1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i - 1];\n            num2 = numbers[i];\n        }\n    }\n\n    return std::make_tuple(num1, num2);\n}",
        "test": "}\nint main() {\n    auto candidate = find_closest_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));\n}\n"
    },
    {
        "task_id": "HumanEval/21",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيكتور ارقام (كاكرڽ دوا ايليمن) دبري، ماڤليكاسيكن ترنسفورما لينيار كڤد ڤيكتور ايت، جادي انم اڠكاو جادي 0 وان انم جادي 1 >>> rescale_to_unit (((std::vector<float>(({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        std::fill(numbers.begin(), numbers.end(), 0.0f);\n        return numbers;\n    }\n\n    for (float &num : numbers) {\n        num = (num - min_val) / (max_val - min_val);\n    }\n\n    return numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n}\n"
    },
    {
        "task_id": "HumanEval/22",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيلتر ڤيكتور ڤرنه دبريكن دري ڤاروليه cppthon سلاكو اونتوق اينتيجر >>> filter_integers((std::vector<std::any>({(std::string) \"a\", (std::string)3.14f, (std::string)5}))) (std::vector<long>({(long)5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::<long,map>), std::vector<long>(()))) (std::vector<long>({(long) 1, (long) 2, (long) 3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n",
        "canonical_solutions": "std::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (const auto& val : values) {\n        if (val.type() == typeid(long)) {\n            result.push_back(std::any_cast<long>(val));\n        } else if (val.type() == typeid(int)) {\n            result.push_back(std::any_cast<int>(val));\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_integers;\n    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));\n    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, \"adasd\"}))) == (std::vector<long>({(long)4, (long)9})));\n    assert(candidate((std::vector<std::any>({3, \"c\", 3, 3, \"a\", \"b\"}))) == (std::vector<long>({(long)3, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/23",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤاڽاراه ڤاڽاراه string >>> string_length((\"\")) (0) >>> string_length((\"abc\")) (3)\nlong string_length(std::string string) {\n",
        "canonical_solutions": "long string_length(std::string string) {\n    return string.length();\n}",
        "test": "}\nint main() {\n    auto candidate = string_length;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"x\")) == (1));\n    assert(candidate((\"asdasnakj\")) == (9));\n}\n"
    },
    {
        "task_id": "HumanEval/24",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// باݢي سابوتيڠ نومبور ن، مانونجوكاكن نومبور نڠ ڤاليڠ بسر نڠ باءيسي ڤربينچڠن ن نڠ باءيسي نڠ كاي >>> largest_divisor ((((15)) (5)\nlong largest_divisor(long n) {\n",
        "canonical_solutions": "long largest_divisor(long n) {\n    for (long i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_divisor;\n    assert(candidate((3)) == (1));\n    assert(candidate((7)) == (1));\n    assert(candidate((10)) == (5));\n    assert(candidate((100)) == (50));\n    assert(candidate((49)) == (7));\n}\n"
    },
    {
        "task_id": "HumanEval/25",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيكتور ڤرجالنن ڤاكتور ڤرم اول ڤد انتيڬر دبريكن دالم اوردين دري ڤاليڠ كيت سهيڠڬ ڤاليڠ بسر. ستياڤ ڤاكتور هاروس دڤاكتوركن باڽق كالي يڠ سام دڠن باڽق كالي ڤون اي برلاكو دالم ڤاكتوريساسي. نومبور ڤرماءينن هاروس سام دڠن ڤربواتن سموا ڤاكتور >>> فكتوريس (((8)) (std::vector<long>({(long) 2, (long) 2, (long) 2})) >>> فكتوريس (((25)) (std::vector<long>({(long) 5, (long) 5})) >>> فكتوريس ((((70)) (std::vector<long>({(long) 2, (long) 5, (long) 7}))\nstd::vector<long> factorize(long n) {\n",
        "canonical_solutions": "std::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    for (long i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}",
        "test": "}\nint main() {\n    auto candidate = factorize;\n    assert(candidate((2)) == (std::vector<long>({(long)2})));\n    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));\n    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));\n    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));\n    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/26",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دري ۏيكتور انتيڬري، مڠحاصيلكن سموا ايليمن يڠ برلاكو لبيه دري ساتو. مڠحاصيلكن اوردين ايليمن تيدق سام سڤرتي دالم ڤڠمبيلن. >>> remove_duplicates((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 4}))) (std::vector<long>({(long) 1, (long) 3, (long) 4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::unordered_map<long, int> freq;\n    for (long num : numbers) {\n        freq[num]++;\n    }\n\n    std::vector<long> result;\n    for (long num : numbers) {\n        if (freq[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_duplicates;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));\n}\n"
    },
    {
        "task_id": "HumanEval/27",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// باݢي ستريڠ دبري، ڤرݢيکن کارکتر کومانݢݢوناءن کڤد کومانݢوناءن بسر دان کومانݢوناءن بسر کڤد کومانݢوناءن کومانݢوناءن. >>> flip_case (((\"Hello\")) (\"HELLO\")\nstd::string flip_case(std::string string) {\n",
        "canonical_solutions": "std::string flip_case(std::string string) {\n    for (char &ch : string) {\n        if (std::islower(ch)) {\n            ch = std::toupper(ch);\n        } else if (std::isupper(ch)) {\n            ch = std::tolower(ch);\n        }\n    }\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = flip_case;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hello!\")) == (\"hELLO!\"));\n    assert(candidate((\"These violent delights have violent ends\")) == (\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"
    },
    {
        "task_id": "HumanEval/28",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// كونكاتينات ڤيكتور ستراينڬ كاو سيكوراڠ ستراينڬ >>> كونكاتينات ((((std::vektor<std::string>())) (\"\") >>> كونكاتينات ((((std::vektor<std::string>({(std::string) \"a\", (std::string) \"b\", (std::string) \"c\"}))) (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = concatenate;\n    assert(candidate((std::vector<std::string>())) == (\"\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == (\"xyz\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\", (std::string)\"w\", (std::string)\"k\"}))) == (\"xyzwk\"));\n}\n"
    },
    {
        "task_id": "HumanEval/29",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيلتر ڤيكتور ڤرماءينن ستريڠ تله باݢي اورڠ-اورڠ يڠ برمولا دڠن ڤريفيکس دڤرتوان اݢوڠ. >>> filter_by_prefix(((std::vector<std::string>()), (\"a\")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bcd\", (std::string) \"cde\", (stdstring) \"array\"})), (\"a\") (std::vector<std::string>(({(std::string) \"abc\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/30",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڽاتاكن ڤون ڤوسيتيف ڤون ڤيكتور. >>> get_positive((std::vector<long>({long) -1, (long) -2, (long) -4, (long) -5, (long) -6}))) (std::vector<long>({long) -2, (long) -5, (long) -6})) >>> get_positive((std::vector<long>({long) -5, (long) -3, (long) -5, (long) -2, (long) -3, (long) -9, (long) -0, (long) -123, (long) -1, (long) -10}))) (std::vector<long>{(long) -5, (long) -3, (long) -2, (long) -3, (long) -9, (long) -123, (long) -1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = get_positive;\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/31",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مروڤاكن كاءيقينن اڤابيلا سابوءه ارق دبريكن اداله ڤرم، وان كادأن لاينڽ. >>> is_prime((6)) (false) >>> is_prime((101)) (true) >>> is_prime((11) (true) >>> is_prime((13441)) (true) >>> is_prime(61)) (true) >>> is_prime(4)) (false) >>> is_prime(1) (false)\nbool is_prime(long n) {\n",
        "canonical_solutions": "bool is_prime(long n) {\n    if (n < 2) return false;\n    if (n < 4) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_prime;\n    assert(candidate((6)) == (false));\n    assert(candidate((101)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((13441)) == (true));\n    assert(candidate((61)) == (true));\n    assert(candidate((4)) == (false));\n    assert(candidate((1)) == (false));\n    assert(candidate((5)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((17)) == (true));\n    assert(candidate((85)) == (false));\n    assert(candidate((77)) == (false));\n    assert(candidate((255379)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/33",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فانكسيا ڠيني مڠاكو ۏيكتور l وان مروڤاكن ۏيكتور l' سهيڠڬ l اداله ايدينتيك لڠه اينديكس نڠ كادا ديۏيدول لڠه ترديري دري تيڬ، سهيڠڬاڤاڽ ۏرلوڽ د اينديكس نڠ ديۏيدول لڠه ترديري سام لاون ۏرلو اينديكس لڠه سڤرتي، تاڤي دسيورت. >>> sort_third((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_third((std::vector<long>{(long>{(long) 5, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 2}))) (std::vector<(long>{(long>2, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> third_indices;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    std::sort(third_indices.begin(), third_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        l[i] = third_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_third;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/34",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڽاراكن ايليمن ݢاريسن ݢاريسن نڠ دڤرتيمبڠكن دالم ۏيكتور >>> unique((std::vector<long>({(long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 0, (long) 2, (long) 3, (long) 5, (long) 9, (long) 123}))\nstd::vector<long> unique(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = unique;\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));\n}\n"
    },
    {
        "task_id": "HumanEval/35",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڽاتاكن ايليمن ماكسيموم دالم ۏيكتور. >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long)-5, (long) 2, (long)-3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (123)\nlong max_element(std::vector<long> l) {\n",
        "canonical_solutions": "long max_element(std::vector<long> l) {\n    return *std::max_element(l.begin(), l.end());\n}",
        "test": "}\nint main() {\n    auto candidate = max_element;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));\n}\n"
    },
    {
        "task_id": "HumanEval/36",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ماولاهاكن جومله ڤندودوق دالم ارقام اينتيڬر نڠ كادا نڠ ديبداكن اوليه 11 اتاو 13. >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)\nlong fizz_buzz(long n) {\n",
        "canonical_solutions": "long fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            long temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++;\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = fizz_buzz;\n    assert(candidate((50)) == (0));\n    assert(candidate((78)) == (2));\n    assert(candidate((79)) == (3));\n    assert(candidate((100)) == (3));\n    assert(candidate((200)) == (6));\n    assert(candidate((4000)) == (192));\n    assert(candidate((10000)) == (639));\n    assert(candidate((100000)) == (8026));\n}\n"
    },
    {
        "task_id": "HumanEval/37",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فانكسيا ڠيني ماڠڬوڤاكن ۏيكتور l وان ماڠرجاكن ۏيكتور l' سهيڠڬ l' اداله ايدينتيك لڠكڤ l دالم اينديكس ڤرڠ، سهيڠڬاڤا ۏيليوڽ دالم اينديكس ڤرڠ سام اداله سام لڠكڤ ڤيليو دري اينديكس ڤرڠ l، تاڤي دسيورت. >>> sort_even{(std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even{(std::vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std::vector<((({(long) 3, (long) 6, (long) 5, (long) 4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_even;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));\n}\n"
    },
    {
        "task_id": "HumanEval/39",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib مڽاتاكن نومبور ن-تڠه يڠ اداله نومبور فيبوناتچي وان جوا نڠ ڤرماءين. >>> prime_fib((1)) (2) >>> prime_fib((2)) (3) >>> prime_fib((3)) (5) >>> prime_fib((4)) (13) >>> prime_fib((5)) (89)\nlong prime_fib(long n) {\n",
        "canonical_solutions": "bool is_prime(long num) {\n    if (num < 2) return false;\n    if (num < 4) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (long i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nlong prime_fib(long n) {\n    std::vector<long> prime_fibs;\n    long a = 1, b = 1;\n    while (prime_fibs.size() < n) {\n        long next = a + b;\n        a = b;\n        b = next;\n        if (is_prime(next)) {\n            prime_fibs.push_back(next);\n        }\n    }\n    return prime_fibs[n - 1];\n}",
        "test": "}\nint main() {\n    auto candidate = prime_fib;\n    assert(candidate((1)) == (2));\n    assert(candidate((2)) == (3));\n    assert(candidate((3)) == (5));\n    assert(candidate((4)) == (13));\n    assert(candidate((5)) == (89));\n    assert(candidate((6)) == (233));\n    assert(candidate((7)) == (1597));\n    assert(candidate((8)) == (28657));\n    assert(candidate((9)) == (514229));\n    assert(candidate((10)) == (433494437));\n}\n"
    },
    {
        "task_id": "HumanEval/40",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// triple_sum_to_zero مڠاخيري ۏيكتور اينتيجر سباڬاي اينترو. اي مروڤاكن سچارا اڤابيلا ترداڤت تيڬ ايليمن بربيذا دالم ۏيكتور يڠ مروڤاكن سومتڽ كاو صفر، وان باڬايماناڽ كالي لاين. >>> triple_sum_to_zero (((std::vector<long>(long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> triple_sum_to_zero (((std::vector<long>(long) 1, (long) 3, (long)-2, (long) 1} >>> (true) triple_sum_to_zero (((std::vector<long>(long) 1, (long) 2, (long) 3, (long) 7}))) (se) >>> triple_sum_to_zero (((std::vector<long>(long)) >>> triple_false (long) >>> triple_sum_to_zero (((long>{(long>{(long)) 2, (long) (long) (4, (long) (long) (5, (long) 3, (long) 9, (long)) (long)) (true)) triple_long)))\nbool triples_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n - 2; i++) {\n        size_t left = i + 1, right = n - 1;\n        while (left < right) {\n            long sum = l[i] + l[left] + l[right];\n            if (sum == 0) return true;\n            else if (sum < 0) left++;\n            else right--;\n        }\n    }\n    \n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = triples_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));\n    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/41",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠهيدوڤكن سبواه جالن نڠ باءيق لڠسوڠ نڠ كادا باءيق. ن باءيق مڠهابيسكن ك ليم ك ك كاو، سابوءه ساتو سيڤت باءيق نڠ باءيق مڠهابيسكن كاو كاو كاو. دوا سيڤت باءيق مولا دالم ڤرڠ باءيق دري سابوءه لاڬي. سموا باءيق مڠهابيسكن كاو دالم ڤرڠ سام. دوا بواه بواه باءيق دكاتاكن مڠهابيسكن كاو اڤابيلا بواه بواه بواه بواه يڠ مڠهابيسكن كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو. نامون، بواه بواه بواه بواه نڠ كاو مڠهابيسكن كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو كاو\nlong car_race_collision(long n) {\n",
        "canonical_solutions": "long car_race_collision(long n) {\n    return n * n;\n}",
        "test": "}\nint main() {\n    auto candidate = car_race_collision;\n    assert(candidate((2)) == (4));\n    assert(candidate((3)) == (9));\n    assert(candidate((4)) == (16));\n    assert(candidate((8)) == (64));\n    assert(candidate((10)) == (100));\n}\n"
    },
    {
        "task_id": "HumanEval/42",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيكتور ڤرجالنن دڠن ايليمن نڠ دڤرتومبوه اوليه 1. >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 2, (long) 3, (long) 4})) >>> incr_list(((std::vector<long>{long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> incr_list(std::vector<long> l) {\n    for (long &num : l) {\n        num++;\n    }\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = incr_list;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));\n    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));\n}\n"
    },
    {
        "task_id": "HumanEval/43",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero مڠاخيري ۏيكتور اينتيجر سباڬاي اينترو. اي مروڤاكن سچارا اڤابيلا ترداڤت دوا ايليمن بربيذا دالم ۏيكتور يڠ مروڤاكن سومتڽ كاو صفر، وان باڬايماناڽ كالي لاين. >>> pairs_sum_to_zero(std::vector<long>(long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> pairs_sum_to_zero(std::vector<long>(long) 1, (long) 3, (long)-2, (long) 1} >>> (false) pairs_sum_to_zero(std::vector<long>(long) 1, (long) 2, (long) 3, (long) 7}))) (se) pairs >>>_sum_to_zero(std::vector<long> (long) 2, (long) 4, (long) (long) 5, (long) 3, (long) 5, (long) 7))) >>> (true_sum_long_se) >>> (long_vector) >>> (long_long_1)))\nbool pairs_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> seen;\n    for (long num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = pairs_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/44",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠاجر اساس نوميريال نومبور ڤرماءينن x كاو اساس. ڤرتمڤورن تار ڤرتوکرن ستله ڤرماءينن. نومبور اساس ادله کتيک 10. >>> change_base((8), (3)) (\"22\") >>> change_base(8), (2)) (\"1000\") >>> change_base((7), (2)) (\"111\")\nstd::string change_base(long x, long base) {\n",
        "canonical_solutions": "std::string change_base(long x, long base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = change_base;\n    assert(candidate((8), (3)) == (\"22\"));\n    assert(candidate((9), (3)) == (\"100\"));\n    assert(candidate((234), (2)) == (\"11101010\"));\n    assert(candidate((16), (2)) == (\"10000\"));\n    assert(candidate((8), (2)) == (\"1000\"));\n    assert(candidate((7), (2)) == (\"111\"));\n    assert(candidate((2), (3)) == (\"2\"));\n    assert(candidate((3), (4)) == (\"3\"));\n    assert(candidate((4), (5)) == (\"4\"));\n    assert(candidate((5), (6)) == (\"5\"));\n    assert(candidate((6), (7)) == (\"6\"));\n    assert(candidate((7), (8)) == (\"7\"));\n}\n"
    },
    {
        "task_id": "HumanEval/45",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديبارياكان لاوانݢ لاوان ڤاساݢيان نانݢ ڤاليڠ باݢيان لاوانݢ تريكؤنت. >>> triangle_area((5), (3)) (7.5f)\nfloat triangle_area(long a, long h) {\n",
        "canonical_solutions": "float triangle_area(long a, long h) {\n    return 0.5f * a * h;\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((5), (3)) == (7.5f));\n    assert(candidate((2), (2)) == (2.0f));\n    assert(candidate((10), (8)) == (40.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/46",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سيكانسي نومبور Fib4 اداله سيكانسي نڠ سام لاون سيكانسي Fibbonacci نڠ ديفينيسي سڤرتي اين: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). كريتاكن منوليس فانسي اونتوق مڠحساب ايليمن ك-ن سيكانسي نومبور fib4. تيدق مڠڬوناكن ريكورسي. >>> fib4((5)) (4) >>> fib4(6)) (8) >>>4((7)) (14)\nlong fib4(long n) {\n",
        "canonical_solutions": "long fib4(long n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 2;\n\n    for (long i = 4; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fib4;\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (28));\n    assert(candidate((10)) == (104));\n    assert(candidate((12)) == (386));\n}\n"
    },
    {
        "task_id": "HumanEval/47",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤولاو ڤينڠ ڤولاو ڤينڠ ڤولاو ڤينڠ ڤولاو ڤينڠ ڤولاو ڤينڠ ڤولاو ڤينڠ ڤولاو ڤينڠ ڤولاو ڤينڠ ڤولاو ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤينڠ ڤين\nfloat median(std::vector<long> l) {\n",
        "canonical_solutions": "float median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    if (n % 2 == 1) {\n        return static_cast<float>(l[n / 2]);\n    } else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = median;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));\n    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));\n    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));\n    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));\n    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));\n}\n"
    },
    {
        "task_id": "HumanEval/48",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤرچاكاكاكن اڤابيلا سورت دبريكن اداله ڤاليندروم >>> is_palindrome (((\"\")) (true) >>> is_palindrome (((\"aba\")) (true) >>> is_palindrome (((\"aaaaa\")) (true) >>> is_palindrome (((\"zbcd\")) (false)\nbool is_palindrome(std::string text) {\n",
        "canonical_solutions": "bool is_palindrome(std::string text) {\n    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());\n}",
        "test": "}\nint main() {\n    auto candidate = is_palindrome;\n    assert(candidate((\"\")) == (true));\n    assert(candidate((\"aba\")) == (true));\n    assert(candidate((\"aaaaa\")) == (true));\n    assert(candidate((\"zbcd\")) == (false));\n    assert(candidate((\"xywyx\")) == (true));\n    assert(candidate((\"xywyz\")) == (false));\n    assert(candidate((\"xywzx\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/49",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مروڤاكن 2^n مودولو p (تاهڤكن نوميريک). >>> modp(((3), (5)) (3) >>> modp((1101), (101)) (2) >>> modp((0), (101)) (1) >>> modp((3), (11)) (8) >>> modp((100), (101) (1)\nlong modp(long n, long p) {\n",
        "canonical_solutions": "long modp(long n, long p) {\n    return std::pow(2, n) % p;\n}",
        "test": "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/51",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels اداله فانسي يڠ مڠمبيل ساءينت وان مڽرتاي ساءينت تنڤا ۏوكل. >>> remove_vowels((\"\")) (\"\") >>> remove_vowels((\"abcdef\")) (\"bcdf\") >>> remove_vowels((\"aaaaa\")) (\"\") >>> remove_vowels(\"aaBAA\")) (\"B\") >>> remove_vowels((\"zbcd\")) (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n",
        "canonical_solutions": "std::string remove_vowels(std::string text) {\n    std::string result;\n    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    for (char ch : text) {\n        if (vowels.find(ch) == vowels.end()) {\n            result += ch;\n        }\n    }\n    \n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_vowels;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"abcdef\\nghijklm\")) == (\"bcdf\\nghjklm\"));\n    assert(candidate((\"fedcba\")) == (\"fdcb\"));\n    assert(candidate((\"eeeee\")) == (\"\"));\n    assert(candidate((\"acBAA\")) == (\"cB\"));\n    assert(candidate((\"EcBOO\")) == (\"cB\"));\n    assert(candidate((\"ybcd\")) == (\"ybcd\"));\n}\n"
    },
    {
        "task_id": "HumanEval/52",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مروڤاكن كاءجيكت سچارا اڤابيلا سموا نومبور د ڤيكتور l اد د لالو ڤڠهادڤن t. >>> below_threshold((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 10})), (100)) (true) >>> below_threshold((std::vector<long>({(long) 1, (long) 20, (long) 4, (long) 10})), (5)) (false)\nbool below_threshold(std::vector<long> l, long t) {\n",
        "canonical_solutions": "bool below_threshold(std::vector<long> l, long t) {\n    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });\n}",
        "test": "}\nint main() {\n    auto candidate = below_threshold;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/53",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڽومبڠ دوا نومبور x وان y >>> مڽومبڠ (((2), (3)) (5) >>> مڽومبڠ (((5), (7)) (12)\nlong add(long x, long y) {\n",
        "canonical_solutions": "long add(long x, long y) {\n    return x + y;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((0), (1)) == (1));\n    assert(candidate((1), (0)) == (1));\n    assert(candidate((2), (3)) == (5));\n    assert(candidate((5), (7)) == (12));\n    assert(candidate((7), (5)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/54",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤرچاي اڤابيلا دوا كات اد حروف يڠ سام. >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) (true) >>> same_chars((\"abcd\"), (\"dddddddabc\")) (true) >>> same_chars(\"dddddddabc\"), (\"abcd\") (true) >>> same_chars((\"eabcd\"), (\"dddddddabc\")) (false) same_chars >>>\"(abcd\"), (\"dddddddddabce\") (false) >>> same_chars((\"eabcd\"), (\"ddddzzzzzdzzdddabc\") (false)\nbool same_chars(std::string s0, std::string s1) {\n",
        "canonical_solutions": "bool same_chars(std::string s0, std::string s1) {\n    std::unordered_set<char> set0(s0.begin(), s0.end());\n    std::unordered_set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}",
        "test": "}\nint main() {\n    auto candidate = same_chars;\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(candidate((\"abcd\"), (\"dddddddabc\")) == (true));\n    assert(candidate((\"dddddddabc\"), (\"abcd\")) == (true));\n    assert(candidate((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(candidate((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(candidate((\"aabb\"), (\"aaccc\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/55",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڽاتاكن نومبور فيبوناچي ن-هين. >>> fib((10)) (55) >>> fib((1)) (1) >>> fib((8)) (21)\nlong fib(long n) {\n",
        "canonical_solutions": "long fib(long n) {\n    if (n <= 1) return n;\n    \n    long a = 0, b = 1, c;\n    for (long i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    \n    return b;\n}",
        "test": "}\nint main() {\n    auto candidate = fib;\n    assert(candidate((10)) == (55));\n    assert(candidate((1)) == (1));\n    assert(candidate((8)) == (21));\n    assert(candidate((11)) == (89));\n    assert(candidate((12)) == (144));\n}\n"
    },
    {
        "task_id": "HumanEval/56",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets اداله ساءينج \"<\" وان \">\". return true اڤابيلا ستياڤ bracket ڤمبوكاين اداله بركاءيتن بركاءيتن ڤمبوكاين. >>> correct_bracketing((\"<\")) (false) >>> correct_bracketing(\"<>\")) (true) >>> correct_bracketing(\"<><>\")) (true) >>> correct_bracketing(\">(<>\") (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') balance++;\n        else if (ch == '>') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"<>\")) == (true));\n    assert(candidate((\"<<><>>\")) == (true));\n    assert(candidate((\"<><><<><>><>\")) == (true));\n    assert(candidate((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(candidate((\"<<<><>>>>\")) == (false));\n    assert(candidate((\"><<>\")) == (false));\n    assert(candidate((\"<\")) == (false));\n    assert(candidate((\"<<<<\")) == (false));\n    assert(candidate((\">\")) == (false));\n    assert(candidate((\"<<>\")) == (false));\n    assert(candidate((\"<><><<><>><>><<>\")) == (false));\n    assert(candidate((\"<><><<><>><>>><>\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/57",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true اداله ايليمن ۏيكتور مونوتونيك ممڤرتاهن اتاو مڠورڠ. >>> monotonic(((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 20}))) (true) >>> monotonic(((std::vector<long>{(long) 1, (long) 20, (long) 4, (long) 10}))) (false) >>> monotonic(((std::vector<long>{(long) 4, (long) 1, (long) 0, (long) -10}))) (true)\nbool monotonic(std::vector<long> l) {\n",
        "canonical_solutions": "bool monotonic(std::vector<long> l) {\n    bool increasing = true, decreasing = true;\n    \n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) decreasing = false;\n        if (l[i] < l[i - 1]) increasing = false;\n    }\n    \n    return increasing || decreasing;\n}",
        "test": "}\nint main() {\n    auto candidate = monotonic;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));\n    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/58",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڽاتاكن ايليمن كومين ڠونيك ترڤرتنديڠن باڬي دوا ۏيكتور. >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5})), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653})) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8})), (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long) 2, (long) 3))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n",
        "canonical_solutions": "std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::unordered_set<long> set1(l1.begin(), l1.end());\n    std::unordered_set<long> result_set;\n    \n    for (long num : l2) {\n        if (set1.count(num)) {\n            result_set.insert(num);\n        }\n    }\n    \n    std::vector<long> result(result_set.begin(), result_set.end());\n    std::sort(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = common;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/59",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڽاتاكن فاكتور ڤرمايسوري ن نڠ ڤاليڠ بسر. مڠهارڤكن ن > 1 وان كادا ڤرمايسوري. >>> largest_prime_factor (((13195)) (29) >>> largest_prime_factor (((2048)) (2)\nlong largest_prime_factor(long n) {\n",
        "canonical_solutions": "long largest_prime_factor(long n) {\n    long largest = -1;\n    \n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n    \n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n    \n    if (n > 1) largest = n;\n    \n    return largest;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n}\n"
    },
    {
        "task_id": "HumanEval/60",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n اداله فانكسسي يڠ مڽومبڠكن نومبور دري ١ سمڤأي n. >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)\nlong sum_to_n(long n) {\n",
        "canonical_solutions": "long sum_to_n(long n) {\n    return n * (n + 1) / 2;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_to_n;\n    assert(candidate((1)) == (1));\n    assert(candidate((6)) == (21));\n    assert(candidate((11)) == (66));\n    assert(candidate((30)) == (465));\n    assert(candidate((100)) == (5050));\n}\n"
    },
    {
        "task_id": "HumanEval/61",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets اداله ساءيرڠ \"(\" وان \")\". مڽاتاكن كاءيقينن اڤابيلا ستياڤ bracket ڤمبوكاان اداله بركاءيقينن ڤمبوكاان ڤمبوكاان. >>> correct_bracketing((\"(\")) (false) >>> correct_bracketing(\"() \")) (true) >>> correct_bracketing(\"(()))))) (true) >>> correct_bracketing((\") (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') balance++;\n        else if (ch == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/62",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// xs ممڤرتيمبڠكن كوافيتس ڤولينوم. xs[0] + xs[1] * x + xs[2] * x^2 + .... مڽاتاكن ديريۏيتات ڤولينوم اين دالم بنتوق سام. >>> ديريۏيتاتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتتت\nstd::vector<long> derivative(std::vector<long> xs) {\n",
        "canonical_solutions": "std::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> result;\n    for (size_t i = 1; i < xs.size(); i++) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = derivative;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));\n    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/63",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سيكانسي نومبور فيبوفيب اداله سيكانسي نڠ سام لاون سيكانسي فيبوبوناكچي نڠ ديفينيسي سڤرتي اين: فيبوفيب ((0) == 0 فيبوفيب ((1) == 0 فيبوفيب ((2) == 1 فيبوفيب ((n) == فيبوفيب ((n-1) + فيبوفيب ((n-2) + فيبوفيب ((n-3). كريتاكن منوليس فانكس اونتوق مڠحساب ايليمن ن-هاي سيكانسي نومبور فيبوفيب. >>> فيبوفيب (((1)) (0) >>> فيبوفيب (((5)) (4) >>> فيبوفيب (((8)) (24)\nlong fibfib(long n) {\n",
        "canonical_solutions": "long fibfib(long n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 1;\n\n    for (long i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fibfib;\n    assert(candidate((2)) == (1));\n    assert(candidate((1)) == (0));\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (24));\n    assert(candidate((10)) == (81));\n    assert(candidate((12)) == (274));\n    assert(candidate((14)) == (927));\n}\n"
    },
    {
        "task_id": "HumanEval/64",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي vowels_count نڠ مڠاكو سورت يڠ مڠاجر سابوءه كاتا نڠ دڤرتاهن سباڬاي اينڤوت وان مڽاتاكن جومله ۏوكل د سورت ايت. ۏوكل دالم حال اين اداله 'a', 'e', 'i', 'o', 'u'. دمان، 'y' جوڬ اداله ۏوكل، تاڤي هاڽ ڤد اخير كات يڠ دبريكن. چونتوه: >>> vowels_count (((\"abcde\")) (2) >>> vowels_count (((\"ACEDY\")) (3)\nlong vowels_count(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong vowels_count(std::string s) {\n  long count = 0;\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  for (char c : s) {\n    if (vowels.count(c)) {\n      count++;\n    }\n  }\n  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n    count++;\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = vowels_count;\n    assert(candidate((\"abcde\")) == (2));\n    assert(candidate((\"Alone\")) == (3));\n    assert(candidate((\"key\")) == (2));\n    assert(candidate((\"bye\")) == (1));\n    assert(candidate((\"keY\")) == (2));\n    assert(candidate((\"bYe\")) == (1));\n    assert(candidate((\"ACEDY\")) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/65",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سيلكولر مڠڬوناكن ديڬيت انتيڬر x، مڠڬوناكن ديڬيت ك كيري اوليه مڠڬوناكن وان مڽرجاكن حاصيل سباڬاي ساءينت. اڤابيلا مڠڬوناكن > جومله ديڬيت، مڽرجاكن ديڬيت ڤد ڤد ڤد. >>> circular_shift((12), (1)) (\"21\") >>> circular_shift((12), (2)) (\"12\")\nstd::string circular_shift(long x, long shift) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string circular_shift(long x, long shift) {\n  std::string s = std::to_string(x);\n  long n = s.length();\n  if (n == 0) {\n    return \"\";\n  }\n  shift %= n;\n  if (shift < 0) {\n    shift += n;\n  }\n  if (shift == 0) {\n    return s;\n  }\n  if (shift > n) {\n    std::reverse(s.begin(), s.end());\n    return s;\n  }\n  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);\n  return shifted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = circular_shift;\n    assert(candidate((100), (2)) == (\"001\"));\n    assert(candidate((12), (2)) == (\"12\"));\n    assert(candidate((97), (8)) == (\"79\"));\n    assert(candidate((12), (1)) == (\"21\"));\n    assert(candidate((11), (101)) == (\"11\"));\n}\n"
    },
    {
        "task_id": "HumanEval/66",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// تاهڤ منوليس فانسي نڠ مڠاخيري سورت جادي اينڤوت وان مروڤاكن سومبر كاراكتر اوتامڽ نڠ كادا دڤرتوان ايسي. چونتوه: >>> digitSum((\"\")) (0) >>> digitSum((\"abAB\")) (131) >>> digitSum((\"abcCd\")) (67) >>> digitSum((\"helloE\")) (69) >>> digitSum((\"woArBld\")) (131) >>> digitSum((\"aAXaaaa\") (153)\nlong digitSum(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += static_cast<long>(c);\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = digitSum;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abAB\")) == (131));\n    assert(candidate((\"abcCd\")) == (67));\n    assert(candidate((\"helloE\")) == (69));\n    assert(candidate((\"woArBld\")) == (131));\n    assert(candidate((\"aAaaaXa\")) == (153));\n    assert(candidate((\" How are yOu?\")) == (151));\n    assert(candidate((\"You arE Very Smart\")) == (327));\n}\n"
    },
    {
        "task_id": "HumanEval/67",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دالم تاسك ڠيني، اندا اكن دبري ساءينر نڠ مروڤاكن باڽق ايڤل وان ڤيڠڬوان نڠ دڤرباتاساكن دالم سابوتيڠ باهن باهن اين مروڤاكن ايڤل، ڤيڠڬوان، وان بواه بواه مانجو. دبري ساءينر نڠ مروڤاكن جومله ايڤل وان ڤيڠڬوان وان اينتڬري نڠ مروڤاكن جومله بواه بواه مانجو دالم باهن مروڤاكن جومله بواه مانجو دالم باهن. باڬي چونتوه: >>> fruit_distribution ((((((\"5 ايڤل وان 6 بواه مانجو\"), (19)) (8) >>> fruit_distribution ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nlong fruit_distribution(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong fruit_distribution(std::string s, long n) {\n  long apples = 0;\n  long oranges = 0;\n  size_t apples_pos = s.find(\"apples\");\n  if (apples_pos != std::string::npos) {\n    size_t start = 0;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    apples = std::stoll(s.substr(start, apples_pos - start));\n  }\n  size_t oranges_pos = s.find(\"oranges\");\n  if (oranges_pos != std::string::npos) {\n    size_t and_pos = s.find(\"and\");\n    size_t start = and_pos + 3;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    oranges = std::stoll(s.substr(start, oranges_pos - start));\n  }\n  return n - apples - oranges;\n}",
        "test": "}\nint main() {\n    auto candidate = fruit_distribution;\n    assert(candidate((\"5 apples and 6 oranges\"), (19)) == (8));\n    assert(candidate((\"5 apples and 6 oranges\"), (21)) == (10));\n    assert(candidate((\"0 apples and 1 oranges\"), (3)) == (2));\n    assert(candidate((\"1 apples and 0 oranges\"), (3)) == (2));\n    assert(candidate((\"2 apples and 3 oranges\"), (100)) == (95));\n    assert(candidate((\"2 apples and 3 oranges\"), (5)) == (0));\n    assert(candidate((\"1 apples and 100 oranges\"), (120)) == (19));\n}\n"
    },
    {
        "task_id": "HumanEval/68",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"ديتاهوي سابوتيڠ ڤيكتور نڠ مروڤاكن سابوتيڠ ڤڠڬيلن دري سابوتيڠ ڤاكر نڠ كادا ناڠڬاتيف نوڬول اينتيڬر كاوجاڠن كامو اداله ڬاڤاكن سابوتيڠ ڤاكر نڠ باءيسي باءيسي نڠ ڤاليڠ كاي. اڤابيلا ببراڤ ڤاكر نڠ باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي نڠ كاي باءيسي نڠ ڤاليڠ كاي باءيسي ڤاليڠ كاي باءيسي ڤاليڠ كاي ڤاليڠ كاي ڤاليڠ كاي ڤاليڠ كاي ڤاليڠ كاي ڤاليڠ كاي ڤاليڠ كاي ڤاليڠ كاي ڤاليڠ كاي ڤاليڠ كاي ڤولا كاليڠ كاي ڤولا كاي ڤولا كاي ڤولا كاي ڤولا كاي ڤولا ك\nstd::vector<long> pluck(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> pluck(std::vector<long> arr) {\n  if (arr.empty()) {\n    return {};\n  }\n  long min_even = -1;\n  long min_index = -1;\n  for (long i = 0; i < arr.size(); ++i) {\n    if (arr[i] % 2 == 0) {\n      if (min_even == -1 || arr[i] < min_even) {\n        min_even = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  if (min_even == -1) {\n    return {};\n  }\n  return {min_even, min_index};\n}",
        "test": "}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/69",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو دبري ۏيكتور ڤون-ڤوسيتيف ڤوسيتيف. ڤوليهكن انجيڬر ڤاليڠ بسر يڠ لبيه بسر دري صفر، وان لڠكهڽ لبيه بسر دري اتاو سام دڠن قدر اينجيڬرڽ. ڤوليهكن انجيڬر اداله ڤوليه-ڤوليه ڤون يڠ برلاكو د ۏيكتور. اڤابيلا تياد ڤوليه-ڤوليه لاڬي، ڤوليهكن -1. چونتوه: >>> search(((std::vector<long>({(long) 4, (long) 1, (long) 2, (long) 3, (long) 1}))) (2) >>> search((std::vector<(long>1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4, (long) 4} (3)))) >>>(std::vector<(long>{(long>5, (long) 5, (long) 4, (long) 4, (long) 1} (long))\nlong search(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong search(std::vector<long> lst) {\n  std::map<long, long> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  long result = -1;\n  for (auto const& [value, count] : counts) {\n    if (value > 0 && count >= value) {\n      result = std::max(result, value);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/70",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيكتور اينتيجر دبري، ڤيكتور ڤرلو دڤرچايا ?? ي دالم اوردين ڤينڠ. ڤرتنديڠن ڤينڠ، اداله اڤابيلا اندا برمولا دڠن قدر مينيموم، لالو ماكسيموم ڤيڠڬيرن اينتيجر، لالو مينيموم دان سباڬايڽ. چونتوه: >>> strange_sort_list{((((std::vector<long>(({(long) 1, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 4, (long) 2, (long) 3})) >>> strange_sort_list<(((std::vector<long>{(long) 5, (long) 5, (long) 5}))) (std::vector<(long>{(long) 5, (long) 5, (long) 5, (long) 5}))) >>> strange_sort_list<(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  if (lst.empty()) {\n    return {};\n  }\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  long left = 0;\n  long right = lst.size() - 1;\n  bool take_min = true;\n  while (left <= right) {\n    if (take_min) {\n      result.push_back(lst[left++]);\n    } else {\n      result.push_back(lst[right--]);\n    }\n    take_min = !take_min;\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = strange_sort_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));\n}\n"
    },
    {
        "task_id": "HumanEval/71",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتاهن لڠسوڠ تيݢ بݢيتو ڤرݢيݢيت. مڽاتاكن ڤلڠسوڠ تيݢ ڤرݢيݢيت دڤڠݢيل کڤد 2 تيتيق ديسمل اڤابيلا تيݢ بݢيتو ممبنتوق تيݢ ڤرݢيݢيت يڠ باءيق. اڤابيلا تيدق مڽاتاكن -1 تيݢ بݢيتو ممبنتوق تيݢ ڤرݢيݢيت يڠ باءيق اڤابيلا سومبڠن تيݢ بݢيتو ڤاليڠ بسر دري تيݢ ڤرݢيݢيت يڠ باءيق. چونتوه: >>> triangle_area((3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())\nfloat triangle_area(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nfloat triangle_area(long a, long b, long c) {\n  if (a + b <= c || a + c <= b || b + c <= a) {\n    return -1.0f;\n  }\n  double s = static_cast<double>(a + b + c) / 2.0;\n  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));\n  std::stringstream ss;\n  ss << std::fixed << std::setprecision(2) << area;\n  return std::stof(ss.str());\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((3), (4), (5)) == (6.0f));\n    assert(candidate((1), (2), (10)) == (float(-1)));\n    assert(candidate((4), (8), (5)) == (8.18f));\n    assert(candidate((2), (2), (2)) == (1.73f));\n    assert(candidate((1), (2), (3)) == (float(-1)));\n    assert(candidate((10), (5), (7)) == (16.25f));\n    assert(candidate((2), (6), (3)) == (float(-1)));\n    assert(candidate((1), (1), (1)) == (0.43f));\n    assert(candidate((2), (2), (10)) == (float(-1)));\n}\n"
    },
    {
        "task_id": "HumanEval/72",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤونچق ڤونچا يڠ مروڤاكن تڤت جك اوبجيكت q اكن مڠلواركن، وان تڤت لاين. اوبجيكت q اكن مڠلواركن جك اي ممڤوڽاءي كاءداءن (اين اداله ۏكتور ڤاليندروميك) وان سومبڠن ايليمنڽ اداله كتيڠڬن اتاو سام دڠن كاءداءن ماكسيما موڠكين. چونتوه: >>> will_it_fly((std::vector<long>({long) 1, (long) 2}), (5)) (false) # 1+2 اداله كتيڠڬن دري كاءداءن ماكسيما موڠكين، تتاڤي اي تيدق ممڤوڽاءي كاءداءن. >>> will_it_fly(((((std::vector<long>{long>(3, (long) 2, (long) 3}, (true) # 3+2 اداله كاءداءن ماكسيما موڠكين، تتاڤي اي ممڤوڽاءي كاءداءن ماكسيما موڠكين، تتاڤي كاءداءن ماكسيما موڠكين. >>> will_it_fly_{long}, (long) 3, (true) (1) (false) # مڠيكت مڠكالي 3+3 اداله كاءن، تتاڤون 3+3 اداله كاءن ماكسيما كاءن دري كاءن ماكسيما موڠكين، تتاڤ، تتاڤ، تيدڠڬام مڠڬام مڠڬون كاءن ماكوت مڠكن. >>> will_long_long_long_long_long_long_long_long_long_long.\nbool will_it_fly(std::vector<long> q, long w) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool will_it_fly(std::vector<long> q, long w) {\n  std::vector<long> reversed_q = q;\n  std::reverse(reversed_q.begin(), reversed_q.end());\n  if (q != reversed_q) {\n    return false;\n  }\n  long sum = 0;\n  for (long val : q) {\n    sum += val;\n  }\n  return sum <= w;\n}",
        "test": "}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/73",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتاهن سابوءه ۏيکتور ار ار، مانداڤتي باهن ايليمن نڠ ڤاليڠ كاي ڤرلو دڤاروبوڠاكن ڬسن منجادي ۏيکتور ڤاليندروميك. ۏيکتور ڤاليندروميك اداله ۏيکتور نڠ دباچ سام ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد\nlong smallest_change(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong smallest_change(std::vector<long> arr) {\n  long n = arr.size();\n  long changes = 0;\n  for (long i = 0; i < n / 2; ++i) {\n    if (arr[i] != arr[n - 1 - i]) {\n      changes++;\n    }\n  }\n  return changes;\n}",
        "test": "}\nint main() {\n    auto candidate = smallest_change;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/74",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچڤونچپونچڤونچپونچپونچ ڤونچ ڤونچڤونچپونچپونچ\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  long count1 = 0;\n  for (const std::string& s : lst1) {\n    count1 += s.length();\n  }\n  long count2 = 0;\n  for (const std::string& s : lst2) {\n    count2 += s.length();\n  }\n  if (count1 <= count2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = total_match;\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"}))) == (std::vector<std::string>({(std::string)\"4\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hii\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)\"this\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\"})), (std::vector<std::string>())) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/75",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ مروڤاكن كاءيقينن اڤابيلا نومبور دبريكن اداله ڤربالهن دري 3 نومبور ڤرمين دان كاءيقينن لاينڽ. مڠاتكن بهاوا (a) اداله كورڠ دري 100. چونتوه: >>> is_multiply_prime((30)) (true) 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_multiply_prime(long a) {\n  if (a <= 0) {\n    return false;\n  }\n  std::vector<int> primes;\n  std::vector<bool> is_prime(100, true);\n  is_prime[0] = is_prime[1] = false;\n  for (int p = 2; p * p < 100; p++) {\n    if (is_prime[p]) {\n      for (int i = p * p; i < 100; i += p)\n        is_prime[i] = false;\n    }\n  }\n  for (int p = 2; p < 100; p++) {\n    if (is_prime[p]) {\n      primes.push_back(p);\n    }\n  }\n  int count = 0;\n  for (int p1 : primes) {\n    if (a % p1 == 0) {\n      count++;\n      int rem = a / p1;\n      for (int p2 : primes) {\n        if (rem % p2 == 0) {\n          count++;\n          int rem2 = rem / p2;\n          for (int p3 : primes) {\n            if (rem2 == p3) {\n              count++;\n              if (count == 3) {\n                return true;\n              }\n              count--;\n            }\n          }\n          count--;\n        }\n      }\n      count--;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = is_multiply_prime;\n    assert(candidate((5)) == (false));\n    assert(candidate((30)) == (true));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (false));\n    assert(candidate((125)) == (true));\n    assert(candidate((105)) == (true));\n    assert(candidate((126)) == (false));\n    assert(candidate((729)) == (false));\n    assert(candidate((891)) == (false));\n    assert(candidate((1001)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/76",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// كاريا كامو اداله منوليس فانكسسي نڠ مروڤاكن كاءيقينن اڤابيلا سابوءه باهن x اداله كاءيقينن ڤندودوق ن وان كاءيقينن ڤندودوق لاين. x اداله كاءيقينن ڤندودوق ن اڤابيلا n**int=x چونتوهڽ: >>> is_simple_power((1), (4)) (true) >>> is_simple_power(2), (2)) (true) >>> is_simple_power(8), (2)) (true) >>> is_simple_power(3), (2)) (false) >>> is_simple_power(3), (1)) (false) >>> is_simple_power(5), (3)) (false)\nbool is_simple_power(long x, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_simple_power(long x, long n) {\n  if (x == n) return true;\n  if (n == 1) return x == 1;\n  if (n == 0) return x == 0;\n  if (x == 0) return false;\n  if (x == 1) return true;\n  long power = n;\n  while (power < x) {\n    if (x % n != 0) return false;\n    if (power > x / n) return false;\n    power *= n;\n  }\n  return power == x;\n}",
        "test": "}\nint main() {\n    auto candidate = is_simple_power;\n    assert(candidate((16), (2)) == (true));\n    assert(candidate((143214), (16)) == (false));\n    assert(candidate((4), (2)) == (true));\n    assert(candidate((9), (3)) == (true));\n    assert(candidate((16), (4)) == (true));\n    assert(candidate((24), (2)) == (false));\n    assert(candidate((128), (4)) == (false));\n    assert(candidate((12), (6)) == (false));\n    assert(candidate((1), (1)) == (true));\n    assert(candidate((1), (12)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/77",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانکشن نڠ مڠاخيري انتيڬر a وان مروڤاكن تڤت جك اين اينڬير اداله كوب دري ببراڤ ارق اينتيڬر. تيتيق: اندا موڠكين مڠڠڬڤ ڤڠاڤرنڽ سداڠ ڤاليڠ باءيق. چونتوه: >>> ايكوب (تول) (تتڤ) >>> ايكوب (تول) (تول) (تول) (تول) >>> ايكوب (تول-1)) (تتڤ) >>> ايكوب (تول-64)) (تتڤ) >>> ايكوب (تول0) (تتڤ) >>> ايكوب (تول-180)) (تول)\nbool iscube(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool iscube(long a) {\n  if (a == 0) return true;\n  long abs_a = std::abs(a);\n  long root = round(std::cbrt(abs_a));\n  return root * root * root == abs_a;\n}",
        "test": "}\nint main() {\n    auto candidate = iscube;\n    assert(candidate((1)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((-1)) == (true));\n    assert(candidate((64)) == (true));\n    assert(candidate((180)) == (false));\n    assert(candidate((1000)) == (true));\n    assert(candidate((0)) == (true));\n    assert(candidate((1729)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/78",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو تله دتاڠني اونتوق منوليس فانسي يڠ منريما ارق هيكساديسمل سباڬاي سورتن دان مڠحسابكن ڤندودوق هيكساديسمل يڠ اداله ڤرميس (ارق ڤرميس اداله ڤرميس نيتورل نڠ لبيه بسر دري 1 نڠ تيدق منجادي ڤرودوک دري دوا ارق نيتورل نڠ لاما). ارق هيكساديسمل اداله 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. ارق ڤرميس اداله 2, 3, 5, 7, 11, 13, 17،...، جادي اكو ڤرلو مميليه ببراڤ ارق ڤد يڠ مان: 2, 3, 5, 7, B (= ديسمل 11), D (= ديسمل 13). تڠكڤ: اكو موڠكين مڠڬڤ ڤرودوقڽ سداڠ باءيق اتاو بياس، دان سيمبول A,B,C,D,E,F سداڠكن اداله كاسر. چونتوهن: >>> hex_((AB\"key\") >>> hex_(AB\") >>> hex_1\nlong hex_key(std::string num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong hex_key(std::string num) {\n  long count = 0;\n  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};\n  for (char c : num) {\n    if (prime_hex.count(c)) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/79",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو اكن دبريكن نومبور دالم بنتوق ديسيمل دان كاوسن اكو اداله اونتوق مڠمبيلڽ كڤد بنتوق باينري. فڠسي اكن مڽاتاكن ستريڠ، دڠن ستياڤ كاراكتر ممڤرتنديڠي ساتو نومبور باينر. ستياڤ كاراكتر دالم ستريڠ اكن منجادي '0' اتاو '1'. اكن اد ساتو جوت كاراكتر 'db' د ڤرتام دان اخير ستريڠ. كاراكتر٢ لاين اداله اونتوق ممبنتو دڠن بنتوق. چونتوه: >>> ديسيمل_تاو_باينر (((15)) (\"db1111db\") >>> ديسيمل_تاو_باينر (((32)) (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string decimal_to_binary(long decimal) {\n  if (decimal == 0) {\n    return \"db0db\";\n  }\n  std::string binaryString = \"\";\n  long temp = std::abs(decimal);\n  while (temp > 0) {\n    binaryString = (temp % 2 == 0 ? \"0\" : \"1\") + binaryString;\n    temp /= 2;\n  }\n  return \"db\" + binaryString + \"db\";\n}",
        "test": "}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
    },
    {
        "task_id": "HumanEval/80",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سوده دبريكن ساءين س. كاوسن كامو اداله اونتوق مڠيكوت اڤابيلا ساءين ايت هاڤڤي اتاو تيدق. ساءين س اداله هاڤي اڤابيلا لڠكهڽ كيرا-كيرا 3 دان ستياڤ 3 حروف ترتنتو بربيذا. چونتوهڽ: >>> is_happy((\"a\")) (false) >>> is_happy(\"aa\")) (false) >>> is_happy(\"abcd\")) (true) >>> is_happy((\"aabb\")) (false) >>> is_happy(\"adb\")) (true) >>> is_happy(\"xyy\") (false)\nbool is_happy(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (size_t i = 0; i <= s.length() - 3; ++i) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_happy;\n    assert(candidate((\"a\")) == (false));\n    assert(candidate((\"aa\")) == (false));\n    assert(candidate((\"abcd\")) == (true));\n    assert(candidate((\"aabb\")) == (false));\n    assert(candidate((\"adb\")) == (true));\n    assert(candidate((\"xyy\")) == (false));\n    assert(candidate((\"iopaxpoi\")) == (true));\n    assert(candidate((\"iopaxioi\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/81",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ݢاريس ڤڠاجرن ڤرلو مڠݢوناکن ڤرکارا-ڤرکارا ترسبوت دالم مڠاجر ڤلاجر. ڤلاجر تله ممبنتو ڤڠاجر اونتوق مڠاجر ڤلاجر. ڤرکارا-ڤرکارا ترسبوت تله دݢوناکن دالم مڠاجر ڤلاجر. ڤلاجر تله ممڤوڽاءي ڤرکارا-ڤرکارا ترسبوت. ڤلاجر تله ممڤوڽاءي ڤرکارا-ڤرکارا ترسبوت دالم مڠاجر ڤلاجر. ڤلاجر تله ممڤوڽاءي ڤرکارا-ڤرکارا ترسبوت دالم مڠاجر ڤلاجر. ڤلاجر تله ممڤوڽاءي ڤرکارا-ڤرکارا ترسبوت دالم مڠاجر ڤلاجر. ڤلاجر تله ممڤوڽاءي ڤرکارا-ڤرکارا ترسبوت دالم مڠاجر ڤلاجر. ڤلاجر تله ممڤوڽاءي ڤرکارا-ڤرکارا ترسبوت دالم مڠاجر ڤلاجر.\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float gpa : grades) {\n    if (gpa == 4.0f) {\n      letter_grades.push_back(\"A+\");\n    } else if (gpa > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (gpa > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (gpa > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (gpa > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (gpa > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (gpa > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (gpa > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (gpa > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (gpa > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (gpa > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (gpa > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "test": "}\nint main() {\n    auto candidate = numerical_letter_grade;\n    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"})));\n    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)\"D+\"})));\n    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)\"D-\"})));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)\"E\"})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)\"D\", (std::string)\"D-\", (std::string)\"C-\", (std::string)\"B\", (std::string)\"B+\"})));\n    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)\"E\", (std::string)\"D-\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/82",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانکشن نڠ مڠمبيل ساءينتير وان مروڤاكن كاءيقينن اڤابيلا لڠسوڠ ساءينتير اداله نومبور ڤرم اتاو كاءيقينن لاينڽ چونتوه >>> prime_length((\"Hello\")) (true) >>> prime_length((\"abcdcba\")) (true) >>> prime_length((\"kittens\")) (true) >>> prime_length((\"orange\")) (false)\nbool prime_length(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(int n) {\n  if (n <= 1) return false;\n  for (int i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nbool prime_length(std::string string) {\n  return is_prime(string.length());\n}",
        "test": "}\nint main() {\n    auto candidate = prime_length;\n    assert(candidate((\"Hello\")) == (true));\n    assert(candidate((\"abcdcba\")) == (true));\n    assert(candidate((\"kittens\")) == (true));\n    assert(candidate((\"orange\")) == (false));\n    assert(candidate((\"wow\")) == (true));\n    assert(candidate((\"world\")) == (true));\n    assert(candidate((\"MadaM\")) == (true));\n    assert(candidate((\"Wow\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"HI\")) == (true));\n    assert(candidate((\"go\")) == (true));\n    assert(candidate((\"gogo\")) == (false));\n    assert(candidate((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(candidate((\"Madam\")) == (true));\n    assert(candidate((\"M\")) == (false));\n    assert(candidate((\"0\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/83",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديبارياكن سابوءه انتيڬره ڤوسيتيف n، ماولاه ڤمباچاءن ارقام انتيڬره ڤوسيتيف ن-دجيت نڠ برمولا اتوا اخير دڠن 1.\nlong starts_one_ends(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong starts_one_ends(long n) {\n  if (n <= 0) {\n    return 0;\n  }\n  if (n == 1) {\n    return 1;\n  }\n  long starts_with_one = std::pow(10, n - 1);\n  long ends_with_one = std::pow(10, n - 1);\n  long starts_and_ends_with_one = std::pow(10, n - 2);\n  return starts_with_one + ends_with_one - starts_and_ends_with_one;\n}",
        "test": "}\nint main() {\n    auto candidate = starts_one_ends;\n    assert(candidate((1)) == (1));\n    assert(candidate((2)) == (18));\n    assert(candidate((3)) == (180));\n    assert(candidate((4)) == (1800));\n    assert(candidate((5)) == (18000));\n}\n"
    },
    {
        "task_id": "HumanEval/84",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديباڠوناكن سابوءه اينتڬير ڤوسيتيف N، ماولاكن سومبڠن سومبڠن ديڬيتڽ دالم بينيار. چونتوه >>> solve((1000)) (\"1\") >>> solve((150)) (\"110\") >>> solve((147)) (\"1100\") ڤارابيل: @N اينتڬير كونستريينتس: 0 ≤ N ≤ 10000. ڤرودوك: سابوءه ساءورڠ ارق باينري\nstd::string solve(long N) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string solve(long N) {\n  if (N < 0 || N > 10000) {\n    return \"\"; // Or handle invalid input as needed\n  }\n  long sum = 0;\n  std::string s = std::to_string(N);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  if (sum == 0) {\n    return \"0\";\n  }\n  std::string binary_sum = \"\";\n  while (sum > 0) {\n    binary_sum = (sum % 2 == 0 ? \"0\" : \"1\") + binary_sum;\n    sum /= 2;\n  }\n  return binary_sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((1000)) == (\"1\"));\n    assert(candidate((150)) == (\"110\"));\n    assert(candidate((147)) == (\"1100\"));\n    assert(candidate((333)) == (\"1001\"));\n    assert(candidate((963)) == (\"10010\"));\n}\n"
    },
    {
        "task_id": "HumanEval/85",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبري ڤيكتور تيدق ڤاكيت انجيڬر lst. ماڽومبڠكن ايليمن ڤرڤادوان يڠ اد د اينديكس ڤرڤادوان.. چونتوه: >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7}))) (2)\nlong add(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));\n    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));\n    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/86",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤرسيون ڤرسيون، اداله ڤرسيون د مان سموا كات (دڤربادڠكن اوليه ڤرڠ) دڤرتوان اڤابيلا سموا كات دتربيتكن اوليه ساتو كات بارو د مان سموا كات دتربيتكن دالم ڤرڠ ڤرتنديڠن يڠ مڠورڠسڠ يڠ دڤرتنديڠكن اوليه ڤرڠ ڤرتنديڠن. كات: اندا بوليه مڠحفظ ڤرڠ ڤرتنديڠن كات دان ڤرڠ ڤرتنديڠن دالم سڤنجڠ. چونتوهڽ: >>> anti_shuffle((\"Hi\")) (\"Hi\") >>> anti_shuffle(((\"hello\")) (\"ehllo\") >>> anti_shuffle\"(Hello World!!!\")) (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string anti_shuffle(std::string s) {\n  std::string result = \"\";\n  std::string current_word = \"\";\n  for (char c : s) {\n    if (c == ' ') {\n      std::sort(current_word.begin(), current_word.end());\n      result += current_word;\n      result += c;\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  std::sort(current_word.begin(), current_word.end());\n  result += current_word;\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = anti_shuffle;\n    assert(candidate((\"Hi\")) == (\"Hi\"));\n    assert(candidate((\"hello\")) == (\"ehllo\"));\n    assert(candidate((\"number\")) == (\"bemnru\"));\n    assert(candidate((\"abcd\")) == (\"abcd\"));\n    assert(candidate((\"Hello World!!!\")) == (\"Hello !!!Wdlor\"));\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hi. My name is Mister Robot. How are you?\")) == (\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"
    },
    {
        "task_id": "HumanEval/87",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> coordinates;\n  for (long i = 0; i < lst.size(); ++i) {\n    std::vector<std::pair<long, long>> row_coords;\n    for (long j = 0; j < lst[i].size(); ++j) {\n      if (lst[i][j] == x) {\n        row_coords.push_back({j, i});\n      }\n    }\n    std::sort(row_coords.rbegin(), row_coords.rend());\n    for (const auto& coord_pair : row_coords) {\n      coordinates.emplace_back(coord_pair.second, coord_pair.first);\n    }\n  }\n  return coordinates;\n}",
        "test": "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));\n    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));\n}\n"
    },
    {
        "task_id": "HumanEval/88",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتنتوكن ۏيكتور ڠيتو نڠ تيدق نڠڬاتيف، مروڤاكن كوكڤ ڤيكتور نڠ ديتنتوكن ستله ڤمبنتو، اندا اكن مڠورڠكن ۏيكتور نڠ ديتنتوكن دالم اوردين ڤرتام نڠ مڠورڠكن اڤابيلا سوم ((اولاڽ ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچاي ڤرچايچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤرچ ڤر\nstd::vector<long> sort_array(std::vector<long> array) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if (sorted_array.empty()) {\n    return sorted_array;\n  }\n  long first = 0;\n  long last = sorted_array.size() - 1;\n  if ((first + last) % 2 != 0) {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  } else {\n    std::sort(sorted_array.rbegin(), sorted_array.rend());\n  }\n  return sorted_array;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));\n    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));\n    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));\n    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));\n}\n"
    },
    {
        "task_id": "HumanEval/89",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فڠسي اينكريڤت يڠ مڠڬوناكن ستريڠ سباڬاي ارڬومنت دان مڠرجاكن ستريڠ اينكريڤت دڠن ابجد دڤرتڠڬوڠ. ابجد هاروس دڤرتڠڬوڠ دالم چارا سڤرتي حروف برڤريڠكت دڠن دوا دڤربواتاكن كدوا جاڠن. چونتوهڽ: >>> اينكريڤت (((\"hi\")) (\"lm\") >>> اينكريڤت (((\"asdfghjkl\")) (\"ewhjklnop\") >>> اينكريڤت (((\"gf\")) (\"kj\") >>> اينكريڤت (((\"et\")) (\"ix\")\nstd::string encrypt(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encrypt(std::string s) {\n  std::string encrypted_s = \"\";\n  int shift = 2 * 2;\n  for (char c : s) {\n    if (isalpha(c)) {\n      char base = islower(c) ? 'a' : 'A';\n      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);\n    } else {\n      encrypted_s += c;\n    }\n  }\n  return encrypted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = encrypt;\n    assert(candidate((\"hi\")) == (\"lm\"));\n    assert(candidate((\"asdfghjkl\")) == (\"ewhjklnop\"));\n    assert(candidate((\"gf\")) == (\"kj\"));\n    assert(candidate((\"et\")) == (\"ix\"));\n    assert(candidate((\"faewfawefaewg\")) == (\"jeiajeaijeiak\"));\n    assert(candidate((\"hellomyfriend\")) == (\"lippsqcjvmirh\"));\n    assert(candidate((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")) == (\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert(candidate((\"a\")) == (\"e\"));\n}\n"
    },
    {
        "task_id": "HumanEval/90",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو دبري ۏيكتور انتيجر. منوليس فڠسي next_smallest() نڠ مروڤاكن ايليمن كدوا ڤاليڠ كودين ۏيكتور. مروڤاكن نون اڤابيلا تيدق اد ايليمن سڤرتي ايت. >>> next_smallest(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) 2 >>> next_smallest((std::vector<long>({long) 5, (long) 1, (long) 4, (long) 3, (long) 2))) >>> 2 next_smallest(std::vector<long>())) std::nullopt >>> next_smallest(std::vector<long>{(long) 1, (long) 1))) std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n  if (lst[0] == lst[1]) {\n    return std::nullopt;\n  }\n  return lst[1];\n}",
        "test": "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);\n}\n"
    },
    {
        "task_id": "HumanEval/91",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو اكن دبريكن سليرا كلمات، دان ڤركارا اكو اداله ممباچ كاءداءن. كاءداءن اداله سسواتو يڠ برمولا دڠن كات \"I\". سسواتو دڤرچايا ?? ي اوليه '.', '?' اتاو '!'. چونتوهڽ: >>> is_bored((\"سلام دنيا\")) (0) >>> is_bored((\"سماءن بليو. هاري مڽمبوت. اكو مڠهيدوڤكن اڤ٢ ڤد ماس اين\")) (1)\nlong is_bored(std::string S) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong is_bored(std::string S) {\n  long boredom_count = 0;\n  std::string current_sentence = \"\";\n  for (char c : S) {\n    current_sentence += c;\n    if (c == '.' || c == '?' || c == '!') {\n      std::stringstream ss(current_sentence);\n      std::string first_word;\n      ss >> first_word;\n      if (first_word == \"I\") {\n        boredom_count++;\n      }\n      current_sentence = \"\";\n    }\n  }\n  return boredom_count;\n}",
        "test": "}\nint main() {\n    auto candidate = is_bored;\n    assert(candidate((\"Hello world\")) == (0));\n    assert(candidate((\"Is the sky blue?\")) == (0));\n    assert(candidate((\"I love It !\")) == (1));\n    assert(candidate((\"bIt\")) == (0));\n    assert(candidate((\"I feel good today. I will be productive. will kill It\")) == (2));\n    assert(candidate((\"You and I are going for a walk\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/92",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڽاتاكن فڠسي يڠ مڠمبيل 3 ڠيتو. مڽاتاكن سچارا تڤت اڤابيلا ساتو دري ڠيتو سام دڠن سومبڠن دوا ڠيتو لاين، وان سموا ڠيتو اداله اينتيڬر. مڽاتاكن تيدق سچارا تڤت دالم حال لاين. چونتوه >>> any_int((float(5)), (float(2)), (float(7))) (true) >>> any_int((float3)), (float(2)), (float(2))) (false) >>> any_int((float(3)), (float(-2)), (float(1))) (true) >>> any_int(((3.6f), (-2.2f), (float(2))) (false)\nbool any_int(float x, float y, float z) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool any_int(float x, float y, float z) {\n  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {\n    return false;\n  }\n  long ix = static_cast<long>(x);\n  long iy = static_cast<long>(y);\n  long iz = static_cast<long>(z);\n  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);\n}",
        "test": "}\nint main() {\n    auto candidate = any_int;\n    assert(candidate((float(2)), (float(3)), (float(1))) == (true));\n    assert(candidate((2.5f), (float(2)), (float(3))) == (false));\n    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));\n    assert(candidate((float(2)), (float(6)), (float(2))) == (false));\n    assert(candidate((float(4)), (float(2)), (float(2))) == (true));\n    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));\n    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));\n    assert(candidate((float(2)), (float(1)), (float(1))) == (true));\n    assert(candidate((float(3)), (float(4)), (float(7))) == (true));\n    assert(candidate((3.0f), (float(4)), (float(7))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/93",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ مڠمبيل بريتا، دان مڠكودكن سچارا يڠ مڠمبيل كيس دري سموا حروف، مڠمبيل سموا ۏوكل دالم بريتا دڠن حروف يڠ بركسن 2 ڤوست سبلوم ۏوكل دالم ابجد بهاس ايڠڬريس. مڠڬڤيكن هاڽ حروف. چونتوه: >>> انكود (((\"test\")) (\"TGST\") >>> انكود (((\"This is a message\")) (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encode(std::string message) {\n  std::string encoded_message = \"\";\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  std::map<char, char> vowel_map = {\n      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};\n  for (char c : message) {\n    if (isalpha(c)) {\n      char swapped_case = islower(c) ? toupper(c) : tolower(c);\n      if (vowels.count(c)) {\n        encoded_message += vowel_map[c];\n      } else {\n        encoded_message += swapped_case;\n      }\n    } else {\n      encoded_message += c;\n    }\n  }\n  return encoded_message;\n}",
        "test": "}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
    },
    {
        "task_id": "HumanEval/94",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠت ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ ڤيڠ\nlong skjkasdkd(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nlong sum_digits(long n) {\n  long sum = 0;\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  return sum;\n}\n\nlong skjkasdkd(std::vector<long> lst) {\n  long largest_prime = -1;\n  for (long num : lst) {\n    if (num > largest_prime && is_prime(num)) {\n      largest_prime = num;\n    }\n  }\n  if (largest_prime == -1) {\n    return 0;\n  }\n  return sum_digits(largest_prime);\n}",
        "test": "}\nint main() {\n    auto candidate = skjkasdkd;\n    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));\n    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));\n    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));\n    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)8191}))) == (19));\n    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));\n    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));\n}\n"
    },
    {
        "task_id": "HumanEval/95",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤىچاهان ڤاهان ڤاهان ڤاهان ڤاهان ڤاهان ڤاهان ڤان ڤان ڤان ڤان ڤان\nbool check_dict_case(std::map<std::string,std::string> dict) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n  bool first_key_lower = false;\n  bool first_key_upper = false;\n  auto it = dict.begin();\n  if (!it->first.empty() && islower(it->first[0])) {\n    first_key_lower = true;\n  } else if (!it->first.empty() && isupper(it->first[0])) {\n    first_key_upper = true;\n  } else {\n    return false;\n  }\n  for (const auto& pair : dict) {\n    if (pair.first.empty()) {\n      return false;\n    }\n    bool current_lower = true;\n    bool current_upper = true;\n    for (char c : pair.first) {\n      if (!islower(c)) {\n        current_lower = false;\n      }\n      if (!isupper(c)) {\n        current_upper = false;\n      }\n    }\n    if (first_key_lower && !current_lower) {\n      return false;\n    }\n    if (first_key_upper && !current_upper) {\n      return false;\n    }\n    if (!first_key_lower && !first_key_upper) {\n        if (current_lower) first_key_lower = true;\n        else if (current_upper) first_key_upper = true;\n        else return false;\n    }\n  }\n  return first_key_lower || first_key_upper;\n}",
        "test": "}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>())) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/96",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي نڠ مڠاخيري انتيڬر نڠ كادا نڬاتيف وان مروڤاكن ۏيكتور نڠ ڤرتام نڠ اداله نومبور ڤرم وان كادا ن. چونتوهڽ: >>> count_up_to((5)) (std::vector<long>{(long) 2, (long) 3})) >>> count_up_to(11)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7}) >>> count_up_to(0)) (std::vector<long>)) >>> count_up_to(20)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7, (long) 11, (long) 1, (long) 3, (long) 17, (long) 19)) >>> count_up_1) (std::vector<long>>>>1 to (long) 8, (std) vector<long>11, (long) 3, (long) 5, (long) 17)) (std (long) 1, (long)\nstd::vector<long> count_up_to(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long num) {\n  if (num <= 1) return false;\n  for (long i = 2; i * i <= num; ++i) {\n    if (num % i == 0) return false;\n  }\n  return true;\n}\n\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n <= 2) {\n    return primes;\n  }\n  for (long i = 2; i < n; ++i) {\n    if (is_prime(i)) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "test": "}\nint main() {\n    auto candidate = count_up_to;\n    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));\n    assert(candidate((0)) == (std::vector<long>()));\n    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));\n    assert(candidate((1)) == (std::vector<long>()));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));\n    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));\n}\n"
    },
    {
        "task_id": "HumanEval/97",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي يڠ مڠاخيري دوا انتيجر وان مروڤاكن ڤربينچڠن داءيت اونيتڽ. مڠاتسي ڤڠاڤرنڽ سداڠ ڤاليڠ باءيق. چونتوه: >>> مڠمبيل (((148), (412)) (16) >>> مڠمبيل (((19), (28)) (72) >>> مڠمبيل (((2020), (1851)) (0) >>> مڠمبيل (((14), (-15)) (20)\nlong multiply(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong multiply(long a, long b) {\n  long unit_a = std::abs(a) % 10;\n  long unit_b = std::abs(b) % 10;\n  return unit_a * unit_b;\n}",
        "test": "}\nint main() {\n    auto candidate = multiply;\n    assert(candidate((148), (412)) == (16));\n    assert(candidate((19), (28)) == (72));\n    assert(candidate((2020), (1851)) == (0));\n    assert(candidate((14), (-15)) == (20));\n    assert(candidate((76), (67)) == (42));\n    assert(candidate((17), (27)) == (49));\n    assert(candidate((0), (1)) == (0));\n    assert(candidate((0), (0)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/98",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتاهن ساءينت s، مڠحسابكن جومله ۏوكل ڤيڠݢير دالم اينديكس جادي. چونتوهڽ: >>> count_upper (((\"aBCdEf\")) (1) >>> count_upper (((\"abcdefg\")) (0) >>> count_upper (((\"dBBE\")) (0)\nlong count_upper(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong count_upper(std::string s) {\n  long count = 0;\n  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};\n  for (long i = 0; i < s.length(); ++i) {\n    if (i % 2 == 0 && upper_vowels.count(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_upper;\n    assert(candidate((\"aBCdEf\")) == (1));\n    assert(candidate((\"abcdefg\")) == (0));\n    assert(candidate((\"dBBE\")) == (0));\n    assert(candidate((\"B\")) == (0));\n    assert(candidate((\"U\")) == (1));\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"EEEE\")) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/99",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي يڠ مڠمبيل ڤرماءينن (ستريڠ) يڠ مروڤاكن ساتو ڠيتو دان مروڤاكن انتيڬر نڠ ڤاليڠ كاي. اڤابيلا ڠيتو اداله ڤارڠ سام دري دوا انتيڬر، ڤرلو مڠورونكنڽ دري صفر. چونتوه >>> ڤارڠ_انتيڬر (((\"10\")) (10) >>> ڤارڠ_انتيڬر (((\"15.3\")) (15): ڤارڠكن دري صفر برمعنى اڤابيلا ڠيتو اداله ڤارڠ سام دري دوا انتيڬر، اڤابيلا ڠيتو ڤرلو مروڤاكن انتيڬر يڠ ڤاليڠ ڤاليڠ كاي دري صفر. چونتوه ڤارڠ_انتيڬر (((\"14.5\") ڤرلو مروڤاكن 15 دان ڤارڠ_انتيڬر ((-14.5\") ڤرلو مروڤاكن -15.\nlong closest_integer(std::string value) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  if (num >= 0) {\n    if (num - std::floor(num) <= 0.5) {\n      return static_cast<long>(std::floor(num));\n    } else {\n      return static_cast<long>(std::ceil(num));\n    }\n  } else {\n    if (std::ceil(num) - num <= 0.5) {\n      return static_cast<long>(std::ceil(num));\n    } else {\n      return static_cast<long>(std::floor(num));\n    }\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/100",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤاتوتي ڤوسيتيف اينتڬري ن، اندا بوليه ممبنتو ڤوليه دري ن ليۏل ڤوتري. ليۏل ڤرتام اد ن ڤوتري. جومله ڤوتري د ليۏل لالو اداله: - ڤوليه جومله ڤوتري جادي ن اد. - ڤوليه جومله ڤوتري جادي ن اد. مروڤاكن جومله ڤوتري د ستياڤ ليۏل دالم ۏيكتور، د مان ايليمن د ايندكس i مروڤاكن جومله ڤوتري د ليۏل (i+1). چونتوه: >>> make_a_pile((3)) (std::vector<long>{long) 3, (long) 5, (long) 7}))\nstd::vector<long> make_a_pile(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long current_stones = n;\n  for (int i = 0; i < n; ++i) {\n    pile.push_back(current_stones);\n    if (current_stones % 2 != 0) {\n      current_stones += 2;\n    } else {\n      current_stones += 2;\n    }\n  }\n  return pile;\n}",
        "test": "}\nint main() {\n    auto candidate = make_a_pile;\n    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));\n    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));\n    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));\n    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));\n    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));\n}\n"
    },
    {
        "task_id": "HumanEval/101",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن ڤن\nstd::vector<std::string> words_string(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ',' || c == ' ') {\n      if (!current_word.empty()) {\n        words.push_back(current_word);\n        current_word = \"\";\n      }\n    } else {\n      current_word += c;\n    }\n  }\n  if (!current_word.empty()) {\n    words.push_back(current_word);\n  }\n  return words;\n}",
        "test": "}\nint main() {\n    auto candidate = words_string;\n    assert(candidate((\"Hi, my name is John\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"})));\n    assert(candidate((\"One, two, three, four, five, six\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"Hi, my name\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\"})));\n    assert(candidate((\"One,, two, three, four, five, six,\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"ahmed     , gamal\")) == (std::vector<std::string>({(std::string)\"ahmed\", (std::string)\"gamal\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/102",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فانسي ڠيني مڠمبيل دوا نومبور ڤوسيتيف x وان y وان مڽاراكن نومبور اينتيڬر ڤاليڠ بسر نڠ اد دالم رنچان [x, y] سماس. اڤابيلا هان اد نومبور نڠ سام، لالو فانسي هاروس مڽاراكن -1. چونتوهڽ: >>> choose_num((12), (15)) (14) >>> choose_num((13), (12)) (-1)\nlong choose_num(long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong choose_num(long x, long y) {\n  if (x > y) {\n    return -1;\n  }\n  long end = y;\n  if (end % 2 != 0) {\n    end--;\n  }\n  if (end < x) {\n    return -1;\n  }\n  return end;\n}",
        "test": "}\nint main() {\n    auto candidate = choose_num;\n    assert(candidate((12), (15)) == (14));\n    assert(candidate((13), (12)) == (-1));\n    assert(candidate((33), (12354)) == (12354));\n    assert(candidate((5234), (5233)) == (-1));\n    assert(candidate((6), (29)) == (28));\n    assert(candidate((27), (10)) == (-1));\n    assert(candidate((7), (7)) == (-1));\n    assert(candidate((546), (546)) == (546));\n}\n"
    },
    {
        "task_id": "HumanEval/103",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// اكو دبري دوا انتيجر ڤوسيتيف n وان m، وان كارياكو اداله اونتوق مڠحساب ڤاراسا انتيجر دري n سمڤاي m (تڠڬارا n وان m). ڤڠوروسن جواڤن كڤد انتيڬر ڤاليڠ كاي وان مڠوروسكنڽ ك باينري. اڤابيلا n لبيه بسر دري m، ڤرلو مڽاتاكن -1. چونتوه: >>> rounded_avg((1), (5)) \"0b11\" >>> rounded_avg(7), (5)) -1 >>> rounded_avg(10), (20)) \"0b1111\" >>> rounded_avg(20), (33) \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;\n    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_string_long rounded_avg(long n, long m) {\n  if (n > m) {\n    return Union_std_string_long(-1);\n  }\n  double sum = 0;\n  for (long i = n; i <= m; ++i) {\n    sum += i;\n  }\n  double avg = sum / (m - n + 1);\n  long rounded_avg_long = std::round(avg);\n  if (rounded_avg_long == 0) {\n    return Union_std_string_long(\"0b0\");\n  }\n  std::string binary_string = \"\";\n  long temp = std::abs(rounded_avg_long);\n  while (temp > 0) {\n    binary_string = (temp % 2 == 0 ? \"0\" : \"1\") + binary_string;\n    temp /= 2;\n  }\n  return Union_std_string_long(\"0b\" + binary_string);\n}",
        "test": "}\nint main() {\n    auto candidate = rounded_avg;\n    assert(candidate((1), (5)) == \"0b11\");\n    assert(candidate((7), (13)) == \"0b1010\");\n    assert(candidate((964), (977)) == \"0b1111001010\");\n    assert(candidate((996), (997)) == \"0b1111100100\");\n    assert(candidate((560), (851)) == \"0b1011000010\");\n    assert(candidate((185), (546)) == \"0b101101110\");\n    assert(candidate((362), (496)) == \"0b110101101\");\n    assert(candidate((350), (902)) == \"0b1001110010\");\n    assert(candidate((197), (233)) == \"0b11010111\");\n    assert(candidate((7), (5)) == -1);\n    assert(candidate((5), (1)) == -1);\n    assert(candidate((5), (5)) == \"0b101\");\n}\n"
    },
    {
        "task_id": "HumanEval/104",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتاهوي سابوءه ۏيكتور ڤوسيتيف اينتيڬر x. مروڤاكن ۏيكتور ڤاريتاسي سموا ايليمن نڠ كادا ناڠ ساكيت ڤرڤادوان. تاتاڤ: ۏيكتور ڤاريتاسي ڤرلو دڤاريتاسي دالم اورد ڤرتومبوهن. چونتوهڽ: >>> unique_digits(std::vector<long>({long) 15, (long) 33, (long) 1422, (long) 1}))) (std::vector<long>{long) 1, (long) 15, (long) 33})) >>> unique_digits(std::vector<long>{long) 152, (long) 323, (long) 1422, (long) 10}))) (std::vector<long>(long))\nstd::vector<long> unique_digits(std::vector<long> x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool has_even_digit(long n) {\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    if ((c - '0') % 2 == 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (long val : x) {\n    if (!has_even_digit(val)) {\n      result.push_back(val);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = unique_digits;\n    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));\n    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));\n    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));\n}\n"
    },
    {
        "task_id": "HumanEval/105",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتنتوكن سابوءه ۏيكتور انتيڬري، ڤوليهكن ۏيكتور انتارا 1 وان 9، ڤوليهكن ۏيكتور ننتي، لالو ڤاتوت مڠاجر ستياڤ ݢيت دڠن نامڽ نڠ بركاءيتن دري \"ساتو\"، \"دوا\"، \"ثلاث\"، \"أربع\"، \"خمس\"، \"ست\"، \"سبوت\"، \"تاهون\"، \"ساو\" . چونتوهڽ: >>> by_length(std::vector<long>{long) 2، (long) 1، (long) 1، (long) 4، (long) 5، (long) 8، (long) 2، (long) 3}))) (std::vector<std::string>{(std::string) 8، (std::string) 5، (std::string) 4، (std::string) 5، (std::string) 3، (std::string) 3، (std::string) 4، (std::string) 5، (std::string) 1، (std::string) 1، (st:string) 1، (st:string) (st:string) (st:string) (st:string) (st:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:string:str:str:str:\nstd::vector<std::string> by_length(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> valid_numbers;\n  std::vector<std::string> result;\n  std::map<long, std::string> number_names = {\n      {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n      {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n  for (long num : arr) {\n    if (num >= 1 && num <= 9) {\n      valid_numbers.push_back(num);\n    }\n  }\n  std::sort(valid_numbers.begin(), valid_numbers.end());\n  std::reverse(valid_numbers.begin(), valid_numbers.end());\n  for (long num : valid_numbers) {\n    result.push_back(number_names[num]);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = by_length;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)\"Three\", (std::string)\"Two\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)\"Nine\", (std::string)\"Eight\", (std::string)\"Four\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/106",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي f نڠ مڠاخيري n سباڬاي ڤاراميتر، وان مروڤاكن ۏيكتور ڤڠوروسن n، جادي بهاڬين ايليمن د ايندكس i اداله فكتوريل i اڤابيلا i اداله ڤرڤادوان اتاو سومبڠن نومبور دري 1 هيڠڬ i اڤابيلا تيدق. i برمولا دري 1. فكتوريل i اداله ڤربالهن نومبور دري 1 هيڠڬ i (1 * 2 * ... * i). چونتوه: >>> f((5)) (std::vector<long>{(long) 1, (long) 2, (long) 6, (long) 24, (long) 15}))\nstd::vector<long> f(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> f(long n) {\n  std::vector<long> result;\n  for (long i = 1; i <= n; ++i) {\n    if (i % 2 == 0) {\n      long factorial = 1;\n      for (long j = 1; j <= i; ++j) {\n        factorial *= j;\n      }\n      result.push_back(factorial);\n    } else {\n      long sum = 0;\n      for (long j = 1; j <= i; ++j) {\n        sum += j;\n      }\n      result.push_back(sum);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = f;\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/107",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديباڠونكن سابوتيڠ انتيڬر ڤوسيتيف n، مروڤاكن سابوتيڠ توڤل نڠ باءيسي باڽق ڤاليندروم انتيڬر ڤرڤادوان وان ڤرڤادوان نڠ دالم ڤريڠكت ((1، n) ، تامسوك. چونتوه 1: >>> even_odd_palindrome ((3)) (std::make_tuple ((1, 2)) ڤرتفسن: ڤاليندروم انتيڬر اداله 1، 2، 3. ساتو دريڽ اداله ڤرڤادوان وان دوا دريڽ اداله ڤرڤادوان. چونتوه 2: >>> even_odd_palindrome ((12)) (std::make_tuple ((4, 6)) ڤرتفسن: ڤاليندروم انتيڬر اداله 1، 2، 3، 4، 5، 6، 7، 8، 9، 11، چوچوڽ اداله ڤرڤادوان وان 6 دريڽ اداله ڤرڤادوان. تاتنتو: 1 <= n= 10^3 < 3 2.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_palindrome(long num) {\n  std::string s = std::to_string(num);\n  std::string reversed_s = s;\n  std::reverse(reversed_s.begin(), reversed_s.end());\n  return s == reversed_s;\n}\n\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0;\n  long odd_count = 0;\n  for (long i = 1; i <= n; ++i) {\n    if (is_palindrome(i)) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n  return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_palindrome;\n    assert(candidate((123)) == (std::make_tuple(8, 13)));\n    assert(candidate((12)) == (std::make_tuple(4, 6)));\n    assert(candidate((3)) == (std::make_tuple(1, 2)));\n    assert(candidate((63)) == (std::make_tuple(6, 8)));\n    assert(candidate((25)) == (std::make_tuple(5, 6)));\n    assert(candidate((19)) == (std::make_tuple(4, 6)));\n    assert(candidate((9)) == (std::make_tuple(4, 5)));\n    assert(candidate((1)) == (std::make_tuple(0, 1)));\n}\n"
    },
    {
        "task_id": "HumanEval/108",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي count_nums نڠ مڠاخيري ۏيكتور انتيڬري وان مروڤاكن كاءداءن ايليمن نڠ ناڽ اد سومبڠن ديڬيت > 0. اڤابيلا سابوءه نومبور نڠ نڠ نڠڬاتيف، لالو ديڬيت ڤرتامڽ نڠ دتوليس اكن نڠڬاتيف: چونتوهڽ -123 ناڠ دتوليس ديڬيت -1، 2، وان 3. >>> count_nums ((((std::vector<long>())) (0) >>> count_nums (((std::vector<long>{(long) - 1، (long) - 11، (long) - 11))))) (1) >>> count_nums (((std::vector<long>{(long) - 1، (long) - 1، (long) - 2} (3))))\nlong count_nums(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_digits_signed(long n) {\n  std::string s = std::to_string(n);\n  long sum = 0;\n  for (long i = 0; i < s.length(); ++i) {\n    if (i == 0 && s[i] == '-') {\n      if (s.length() > 1) {\n        sum -= (s[i + 1] - '0');\n        i++;\n      }\n    } else {\n      sum += (s[i] - '0');\n    }\n  }\n  return sum;\n}\n\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    if (sum_digits_signed(num) > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_nums;\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));\n    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));\n    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/109",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// كيت اد ۏيكتور 'ار' دري N انتيڬر ار[1], ار[2]، ..., ار[N]. نومبور-نمبور د ۏيكتور اكن دأرتسكن سچارا رندوم. كاريا كامو اداله ممنتڤكن اڤابيلا كامو ممڤوڽاءي ۏيكتور دالم اوردين نون-ديسكريسين ملالوءي اوڤراسي يڠ دبريتاهو دڤاكر ۏيكتور: كامو داڤت ممڤوڽاءي اوڤراسي ڤمبلاجرن كڤد ڤاكر سهيڠڬ ساتو ڤوسيت دالم ڤاكر سهيڠڬ ڤوسيت اخير ۏيكتور اكن دڤاڤركن كڤد ڤوسيت ڤرتام د ڤاكر سهيڠڬ 0th اينديكس. اڤابيلا كامو ممڤوڽاءي ۏيكتور يڠ دأرتسكن ملالوءي اوڤراسي ڤمبلاجرن ڤمبلاجرن ڤد ڤاكر سهيڠ اول دڤاكر ڤاكر ڤاكر ڤد ڤاكر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر ڤر\nbool move_one_ball(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool move_one_ball(std::vector<long> arr) {\n  if (arr.empty()) {\n    return true;\n  }\n  int n = arr.size();\n  std::vector<long> sorted_arr = arr;\n  std::sort(sorted_arr.begin(), sorted_arr.end());\n  for (int shift = 0; shift < n; ++shift) {\n    std::vector<long> shifted_arr(n);\n    for (int i = 0; i < n; ++i) {\n      shifted_arr[i] = arr[(i - shift + n) % n];\n    }\n    if (shifted_arr == sorted_arr) {\n      return true;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/110",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دالم مسئله اين، كامو اكن ممڤركنلكن ڤڠڬوناان يڠ ممڤوڽاءي دوا ۏيكتور ڤڠڬوناان، دان ممڤركنلكن اڤابيلا ممڤوڽاءي ڤڠڬوناان انتارا ايليمن انتاراڽ اونتوق منجاديكن lst1 سباڬاي ۏيكتور ڤڠڬوناان جادي تيدق اد ڤڠڬوناان انتارا ايليمن يڠ دڤڠڬوناكن انتارا lst1 دان lst2. اڤابيلا ممڤوڽاءي ڤڠڬوناان انتارا ايليمن انتارا lst1 دان lst2 اونتوق منجاديكن سموا ايليمن lst1 جادي جادي، ڤرلو مڠاتاكن \"YES\". اڤابيلا تيدق، ڤرلو مڠاتاكن \"NO\". چونتوهڽ: >>> exchange((std::vector<>(long) {1, (long) {2, (long) {2, (long) {3, (long) {4}) ، (std::vector<>(long}}، (long) {4, (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long))\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  long odd_count_lst1 = 0;\n  for (long num : lst1) {\n    if (num % 2 != 0) {\n      odd_count_lst1++;\n    }\n  }\n  long even_count_lst2 = 0;\n  for (long num : lst2) {\n    if (num % 2 == 0) {\n      even_count_lst2++;\n    }\n  }\n  if (even_count_lst2 >= odd_count_lst1) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = exchange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (\"YES\"));\n}\n"
    },
    {
        "task_id": "HumanEval/111",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتنتوكن ساءينتر يڠ مروڤاكن حروف مينومن دڠن ڤرڤادوان، مڽاتاكن ڤتا حروف دڠن ڤرڤادوان ڤاليڠ باڽق دان مڠمبيل كاءونتيڠ يڠ سام. ماناكالا: >>> هيستوڬرم (((\"a b c\")) (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}})) >>> هيستوڬرم ((((\"a b a\")) (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})) >>> هيستوڬرم (((\"a b c a b\")) (std::map<std::string,long>{{\"a\", 2}, {\"b\", 2}})) >>> هيستوڬرم (((\"a b b b\") (std::std::string, 4\") >>> ({{\"b\"c\", 1}})) >>> هيستوڬرم (long>) >>> (std) (<std))\nstd::map<std::string,long> histogram(std::string test) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string, long> counts;\n  std::string current_word;\n  std::stringstream ss(test);\n  while (ss >> current_word) {\n    counts[current_word]++;\n  }\n  if (counts.empty()) {\n    return {};\n  }\n  long max_count = 0;\n  for (const auto& pair : counts) {\n    if (pair.second > max_count) {\n      max_count = pair.second;\n    }\n  }\n  std::map<std::string, long> result;\n  for (const auto& pair : counts) {\n    if (pair.second == max_count) {\n      result[pair.first] = pair.second;\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = histogram;\n    assert(candidate((\"a b b a\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c a b\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c d g\")) == (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}, {\"d\", 1}, {\"g\", 1}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"b b b b a\")) == (std::map<std::string,long>({{\"b\", 4}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"\")) == (std::map<std::string,long>()));\n    assert(candidate((\"a\")) == (std::map<std::string,long>({{\"a\", 1}})));\n}\n"
    },
    {
        "task_id": "HumanEval/112",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توكوان كيت دبري دوا تار s وان c، كامو ڤرلو مڠحذير سموا كاراكتر د s يڠ سام دڠن ستياڤ كاراكتر د c لالو مڠيكوت اڤابيلا تار ريسلتاڽ كاله ڤاليندروم. تار دكنلي سباڬاي ڤاليندروم اڤابيلا مڠيكوت ڤوليه ڤوليه كالي سام سڤرتي ڤوليه ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤ\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  std::unordered_set<char> chars_to_delete(c.begin(), c.end());\n  for (char ch : s) {\n    if (chars_to_delete.find(ch) == chars_to_delete.end()) {\n      result += ch;\n    }\n  }\n  std::string reversed_result = result;\n  std::reverse(reversed_result.begin(), reversed_result.end());\n  return std::make_tuple(result, result == reversed_result);\n}",
        "test": "}\nint main() {\n    auto candidate = reverse_delete;\n    assert(candidate((\"abcde\"), (\"ae\")) == (std::make_tuple(\"bcd\", false)));\n    assert(candidate((\"abcdef\"), (\"b\")) == (std::make_tuple(\"acdef\", false)));\n    assert(candidate((\"abcdedcba\"), (\"ab\")) == (std::make_tuple(\"cdedc\", true)));\n    assert(candidate((\"dwik\"), (\"w\")) == (std::make_tuple(\"dik\", false)));\n    assert(candidate((\"a\"), (\"a\")) == (std::make_tuple(\"\", true)));\n    assert(candidate((\"abcdedcba\"), (\"\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"abcdedcba\"), (\"v\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"vabba\"), (\"v\")) == (std::make_tuple(\"abba\", true)));\n    assert(candidate((\"mamma\"), (\"mia\")) == (std::make_tuple(\"\", true)));\n}\n"
    },
    {
        "task_id": "HumanEval/113",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتنتوكن سابوءه ۏيكتور ستراين، نڠ ستياڤ ستراين باءيسي ڬرقن هاڽ، ماولاه سابوءه ۏيكتور. ستياڤ ايليمن i ڤد ڤنوليسن ڤرلو جادي \"كاءداءن ايليمن ڤد ستراين i ڤد ڤنوليسن. \" نڠ سموا i ڤرلو دڤاواڠكن اوليه كاءداءن ايليمن ڤد ستراين ڤد ڤنوليسن. >>> odd_count(std::vector<std::string>((({std::string) \"1234567\"}))) (std::vector<std::string>(({stdstring)::\"كاءداءن ايليمن ڤرلو 4n ستراين 4 ڤد 4n. \")) >>> odd_count((stdvector<stdstring>::{stdstring>(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (const std::string& s : lst) {\n    int count = 0;\n    for (char c : s) {\n      if ((c - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string count_str = std::to_string(count);\n    std::string modified_s = s;\n    for (char& c : modified_s) {\n      if (isdigit(c) && (c - '0') % 2 != 0) {\n        c = count_str[0];\n      }\n    }\n    result.push_back(\"the number of odd elements \" + count_str + \"n the str\" + modified_s + \"ng \" + modified_s + \" of the \" + modified_s + \"nput.\");\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = odd_count;\n    assert(candidate((std::vector<std::string>({(std::string)\"1234567\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"271\", (std::string)\"137\", (std::string)\"314\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\", (std::string)\"the number of odd elements 3n the str3ng 3 of the 3nput.\", (std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/114",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديباڠوناكان سابوتيڠ ۏيكتور انتيݢىر نانݢ نانݢ نانݢ كادا باءيسي, مانداڤاتاكان سومبوهان نانݢ كادا باءيسي نانݢ كادا باءيسي داري سابوتيڠ ۏيكتور نانݢ كادا باءيسي. چونتوه >>> minSubArraySum((((std::vector<long>({long) 2, (long) 3, (long) 4, (long) 1, (long) 2, (long) 4}))) (1) >>> minSubArraySum((std::vector<long>{(long) -1, (long) -2, (long) -3)))) (-6)\nlong minSubArraySum(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong minSubArraySum(std::vector<long> nums) {\n  if (nums.empty()) {\n    throw std::invalid_argument(\"Input vector cannot be empty.\");\n  }\n  long min_so_far = nums[0];\n  long current_min = nums[0];\n  for (size_t i = 1; i < nums.size(); ++i) {\n    current_min = std::min(nums[i], current_min + nums[i]);\n    min_so_far = std::min(min_so_far, current_min);\n  }\n  return min_so_far;\n}",
        "test": "}\nint main() {\n    auto candidate = minSubArraySum;\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));\n    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));\n    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));\n    assert(candidate((std::vector<long>({(long)-10}))) == (-10));\n    assert(candidate((std::vector<long>({(long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/115",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤرلوكن كامي اداله مڠڬوناكن ڤاكر-ڤاكر ڤرلوكن كامي مڠڬوناكن ڤاكر-ڤاكر ڤرلوكن كامي مڠڬوناكن ڤاكر-ڤاكر ڤرلوكن كامي مڠڬوناكن ڤاكر-ڤاكر ڤرلوكن كامي مڠڬوناكن ڤاكر-ڤاكر ڤرلوكن كامي مڠڬوناكن ڤاكر-ڤاكر ڤرلوكن كامي مڠڬوناكن ڤاكر-ڤاكر ڤرلوكن كامي مڠڬوناكن ڤاكر-ڤاكر ڤرلوكن كامي مڠڬوناكن ڤاكر-ڤاكر ڤرلوكن كامي مڠڬوناكن ڤاكر-ڤاكر ڤرلوكن كامي مڠڬوناكن ڤاكر-ڤاكر ڤرلوكن كامي مڠڬوناكن ڤاكر-ڤاكر ڤرلوكن كامي مڠڬوناكن ڤاكر-ڤاكرلوكن كامي مڠڬوناكن ڤاكرلوكن كامي مڠڬوناكن ڤرلوكن كامي مڠڬوناكن ڤرلوكن كامي مڠڬوناكن ڤرلوكن كامي مڠكڠكڤ ڤرلوكن ڤرلوكن كامي مڠ ڤرلوكن ڤرلوكن كامي ڤرلوكن كامي ڤرلوكن كامي ڤرلوكن كامي ڤرلوكن كامي ڤرلوكن كامي ڤرلوكن كامي ڤرلوكن كامي ڤرلومان كامي ڤرلومان ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن ڤرلوڠن\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long bucket_lowering_count = 0;\n  for (const auto& row : grid) {\n    long water_in_well = 0;\n    for (long unit : row) {\n      water_in_well += unit;\n    }\n    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;\n  }\n  return bucket_lowering_count;\n}",
        "test": "}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/116",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دالم كاتا اين، كامو ممباچ ۏيكتور ڤيڠت ڤنوه-ڤنوه نڠ كادا نڠڬاتيف سيوچارا بربنديڠ دالم ڤرڤريسيناسي بينيارڽ دالم اورد ڤنوه. باڬي ڤيڠت ڤنوه نڠ سام، مباچ سچارا باڬي ۏرچاي ديسيمل. ڤرلو دأيمڤليميتيكن سڤرتي اين: >>> sort_array((std::vector<long>{(long>1, (long) 5, (long) 2, (long) 3, (long) 3, (long) 4، (long) 5)) >>> sort_array(std::vector<long>{(long>2, (long) 3, (long) 4, (long) 5, (long) 6)) (std::vector<long>{(long>-6, (long) 5, (long-4, (long) 3, (long-2)) >>>array_std::vector<long>0, (long>1, (long) 3, (long)) (long) 2, (long)) (long) 4، (long)) (long)\nstd::vector<long> sort_array(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nint count_set_bits(long n) {\n  int count = 0;\n  if (n < 0) {\n    n = std::abs(n);\n  }\n  while (n > 0) {\n    n &= (n - 1);\n    count++;\n  }\n  return count;\n}\n\nbool compare(long a, long b) {\n  int bits_a = count_set_bits(a);\n  int bits_b = count_set_bits(b);\n  if (bits_a != bits_b) {\n    return bits_a < bits_b;\n  }\n  return a < b;\n}\n\nstd::vector<long> sort_array(std::vector<long> arr) {\n  std::sort(arr.begin(), arr.end(), compare);\n  return arr;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));\n    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n}\n"
    },
    {
        "task_id": "HumanEval/117",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتوليس ساكيت s وان سابوتيڠ نومبور نيتيرال n، اندا تله دڤرلوكن ممڤركنلكن فانسي يڠ مروڤاكن ۏيكتور دري ستياڤ كات دري ساكيت s يڠ مان ساكيتڽ نڠ باهنر، سهيڠڬ كات-كات اين برتيندق د ساكيت s. اڤابيلا ساكيت s باهنر كالي اندا ڤرلو مروڤاكن ۏيكتور باهنر. تاتنتو: اندا موڠكين مڠيكوت ساكيت ڤرنه ممڤوڽاءي حروف دان ڤاسير. چونتوه: >>>select_words(((\"ماري ممڤوڽاءي كريتا رنده\") ، (4)) (std::vector<std::string>، (4) (std::vector>، (5) (std::vector>، (6) (std::vector>، (7) (std::vector>، (7) (d::vector>، (7) (d:std::vector)) >>> (Hello) (<string>) (<string>) (<string>) (<string>)\nstd::vector<std::string> select_words(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_consonant(char c) {\n  c = tolower(c);\n  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ' ') {\n      long consonant_count = 0;\n      for (char word_char : current_word) {\n        if (is_consonant(word_char)) {\n          consonant_count++;\n        }\n      }\n      if (consonant_count == n) {\n        result.push_back(current_word);\n      }\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  long consonant_count = 0;\n  for (char word_char : current_word) {\n    if (is_consonant(word_char)) {\n      consonant_count++;\n    }\n  }\n  if (consonant_count == n) {\n    result.push_back(current_word);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/118",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو دبري كاتا. كاوسنكو اداله مميليه ۏوكل ڤاليڠ كايڠين يڠ بركنا ?? ن انتارا دوا كونسونن دري سڤنجڠ كاتا (سڤنجڠ كيس). ۏوكل د ڤرمولأن دان اخير تيدق دحسبتكن. مڠرجاكن سليرا تيدق لڠسوڠ اڤابيلا اكو تيدق مميليه ۏوكل ڤد شرط د اتس. اكو موڠكين مڠيكوت بهاوا سليرا ايت ممڤوڽاءي حروف بهاس ايڠڬريس سهاج. چونتوه: >>> get_closest_vowel((\"yogurt\")) (\"u\") >>> get_closest_vowel(\"FULL\")) (\"U\") >>> get_closest_vowel(\"quick\") (\"\") >>> get_closest_vowel((ab\") (\"\")\nstd::string get_closest_vowel(std::string word) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_vowel(char c) {\n  c = tolower(c);\n  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\nbool is_consonant(char c) {\n  return isalpha(c) && !is_vowel(c);\n}\n\nstd::string get_closest_vowel(std::string word) {\n  if (word.length() < 3) {\n    return \"\";\n  }\n  for (int i = word.length() - 2; i >= 1; --i) {\n    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "test": "}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
    },
    {
        "task_id": "HumanEval/119",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠڬرن\nstd::string match_parens(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_good(const std::string& s) {\n  int balance = 0;\n  for (char c : s) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n    }\n    if (balance < 0) {\n      return false;\n    }\n  }\n  return balance == 0;\n}\n\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  if (is_good(s1 + s2) || is_good(s2 + s1)) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
    },
    {
        "task_id": "HumanEval/120",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتاهوءي ۏيکتور ار ار وان ڤوسيتيف اينتڬري k، مڽارڠ ۏيکتور لڠسوڠ k دڠن ماکسيما k نومبور د ار. چونتوه 1: >>> ماکسيما﴿ست﴾: ۏيکتور<لانج>﴿لانج>-٣، (لانج) -٤، (لانج) -٥) ، (3)) (لانج: ۏيکتور<لانج>-٤، (لانج) -٣، (لانج) -٥)) چونتوه 2: >>> ماکسيما﴿ست﴾: ۏيکتور<لانج>-٤، (لانج) -٤) ، (2)) (لانج: ۏيکتور<لانج>-٤، (لانج) -٤)) چونتوه 3: >>> ماکسيما﴿ست﴾: ۏيکتور<لانج>-٣، (لانج) -٢، (لانج) -١، (لانج) -٢، (لانج) -١، (لانج: ۏيکتور<لانج>-٢) 1. ڤيکتور لڠسوڠ اکن دالم ڤريڠݢان ۏيکتور 1000. [نوت: لينج] ۏيکتور لڠسوڠ اکن اداله دالم ڤريڠݢان ۏيکتور لڠسوڠ ۏيکتور لڠ ۏيکتور لڠ ݢن: ٠=١، لڠسوڠ=١، لڠ=٢، لڠ=١، لڠ=١، لڠ=١، لڠ=٣.\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.rbegin(), arr.rend());\n  std::vector<long> result;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    result.push_back(arr[i]);\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));\n    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));\n    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));\n    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/121",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤاتوتي ۏيكتور تيدق ڤاكيت، مروڤاكن سومبر سموا ايليمن ڤرچاي يڠ دالم ڤوسيسي ڤرچاي. چونتوه >>> solution((std::vector<long>({(long) 5, (long) 8, (long) 7, (long) 1}))) (12) >>> solution((((std::vector<long>({(long) 3, (long) 3, (long) 3, (long) 3}))) (9) >>> solution(((std::vector<long>(({(long) 30, (long) 13, (long) 24, (long) 321}))) (0)\nlong solution(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solution;\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));\n    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));\n    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));\n    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/122",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديبارياكن سابوتيڠ ۏيكتور نان-ڤاكيت داري اينتيڬار ارر وان سابوتيڠ اينتيڬار ك، ماولاه سومبڠن ايليمن نڠ كادا باڽق لاين دوا ديڬيت دري ايليمن ك ڤرتام ارر. چونتوه: >>> add_elements((std::vector<long>({long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) كونستراكسي: 1. 1 <= len(arr) <= 100 2. 1 <= k <= lenarr)\nlong add_elements(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add_elements;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));\n    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));\n    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));\n    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));\n    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/123",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيڠڬيرن كولاتز اداله ڤيڠڬيرن دالم ماتماتيكا يڠ برتوجوان دڤرتنديڠن: برمولا دڠن ڤيڠڬيرن ڤوسيتيف ن. ستياڤ ڤريڠكت دڤيليه دري ڤريڠكت سبلومڽ سڤرتي اين: اڤابيلا ڤريڠكت سبلومڽ اداله ڤرڠكت، ڤريڠكت سبلومڽ اداله ڤريڠكت سڤولوهڽ. اڤابيلا ڤريڠكت سبلومڽ اداله ڤرڠكت، ڤريڠكت سبلومڽ اداله 3 كالي ڤريڠكت سبلومڽ ڤلسو 1. ڤيڠڬيرنڽ اداله بهاوا اڤابيلا ڤريڠكت ن اداله ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤستي ڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤيڤ\nstd::vector<long> get_odd_collatz(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> odd_numbers;\n  std::unordered_set<long> seen;\n  long current = n;\n  while (seen.find(current) == seen.end()) {\n    seen.insert(current);\n    if (current % 2 != 0) {\n      odd_numbers.push_back(current);\n    }\n    if (current == 1) {\n      break;\n    }\n    if (current % 2 == 0) {\n      current /= 2;\n    } else {\n      current = 3 * current + 1;\n    }\n  }\n  std::sort(odd_numbers.begin(), odd_numbers.end());\n  return odd_numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = get_odd_collatz;\n    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));\n    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/124",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو ڤرلو منوليس فانسي يڠ مڠمبيل ڤرمايسوري دالم سيسي تاريخ دان مڽاتاكن سچارا اڤابيلا تاريخ اداله ڤرمايسوري اتاو تيدق. تاريخ اداله ڤرمايسوري اڤابيلا سموا قاعده-قاعده يڠ دلاڤوركن اين دڤرلوكن: 1. سيسي تاريخ تيدق چوكوڤ. 2. ڤرمايسوري تيدق كورڠ دري 1 اتاو لبيه دري 31 هاري باڬي بولن 1,3,5,7,8,10,12. دان ڤرمايسوري تيدق كورڠ دري 1 اتاو لبيه دري 30 هاري باڬي بولن 4,6,9,11. دان، ڤرمايسوري تيدق كورڠ دري 1 اتاو لبيه دري 29 هاري باڬي بولن 2. 3. بولن تيدق بوليه كورڠ دري 1 اتاو لبيه دري 12. 4. تاريخ ڤرلو دالم ڤورتم: mm-dd-yyyy >>> valid_(تاريخ 103-11-2000\")) (ڤرمايسوري >>> valid_date_(((15-01-2012\") (ڤرمايسوري تيدق >>> valid_date_((04-2040\") (ڤرمايسوري >>> valid_(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nbool valid_date(std::string date) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool valid_date(std::string date) {\n  if (date.empty()) {\n    return false;\n  }\n  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n    return false;\n  }\n  int month, day, year;\n  try {\n    month = std::stoi(date.substr(0, 2));\n    day = std::stoi(date.substr(3, 2));\n    year = std::stoi(date.substr(6, 4));\n  } catch (const std::invalid_argument& e) {\n    return false;\n  } catch (const std::out_of_range& e) {\n    return false;\n  }\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1) {\n    return false;\n  }\n  if (month == 2) {\n    if (day > 29) {\n      return false;\n    }\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30) {\n      return false;\n    }\n  } else {\n    if (day > 31) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = valid_date;\n    assert(candidate((\"03-11-2000\")) == (true));\n    assert(candidate((\"15-01-2012\")) == (false));\n    assert(candidate((\"04-0-2040\")) == (false));\n    assert(candidate((\"06-04-2020\")) == (true));\n    assert(candidate((\"01-01-2007\")) == (true));\n    assert(candidate((\"03-32-2011\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"04-31-3000\")) == (false));\n    assert(candidate((\"06-06-2005\")) == (true));\n    assert(candidate((\"21-31-2000\")) == (false));\n    assert(candidate((\"04-12-2003\")) == (true));\n    assert(candidate((\"04122003\")) == (false));\n    assert(candidate((\"20030412\")) == (false));\n    assert(candidate((\"2003-04\")) == (false));\n    assert(candidate((\"2003-04-12\")) == (false));\n    assert(candidate((\"04-2003\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/125",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// ديتنتوكن سابوءه سورت، مروڤاكن ساتو ۏيكتور سوكو كات ڤرباڬاي ڤد ڤرڠ، اڤابيلا تياد ڤرڠ دالم تيكس اكو ڤرلو مروڤاكن ڤرڠ د دالم كوم '، اڤابيلا تياد كوم اكو ڤرلو مروڤاكن جوتاءن حروف مينيس دڠن اوروسن بيجق دالم ابجد، ord (a) = 0، ord (b) = 1، ... ord (z) = 25 چونتوه >>> split_words (de) >>> split_words (de) >>> split_words (de) 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;\n    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  if (txt.find(' ') != std::string::npos) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n    std::string word;\n    while (ss >> word) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if (txt.find(',') != std::string::npos) {\n    std::vector<std::string> words;\n    std::string current_word;\n    for (char c : txt) {\n      if (c == ',') {\n        words.push_back(current_word);\n        current_word = \"\";\n      } else {\n        current_word += c;\n      }\n    }\n    words.push_back(current_word);\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long odd_order_count = 0;\n    for (char c : txt) {\n      if (islower(c)) {\n        if ((c - 'a') % 2 != 0) {\n          odd_order_count++;\n        }\n      }\n    }\n    return Union_std_vector_std_string__long(odd_order_count);\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/126",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيكتور ڤيڠڬيرن، ڤرلو مڠرجاكن اڤابيلاڽ دڤرتيمبڠكن سچارا مڠورڠ. اڤابيلا ڤيڠڬيرن اد لبيه دري 1 دوڤليک ڤيڠڬيرن سام، ڤرلو مڠرجاكن false. مڠاداكن تيدق اد ڤيڠڬيرن نڠڬاتيف دان هاڽ اينتيڬر. چونتوه >>> is_sorted (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)\nbool is_sorted(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_sorted(std::vector<long> lst) {\n  if (lst.size() <= 1) {\n    return true;\n  }\n  std::map<long, int> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  for (auto const& [key, val] : counts) {\n    if (val > 2) {\n      return false;\n    }\n  }\n  for (size_t i = 0; i < lst.size() - 1; ++i) {\n    if (lst[i] > lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_sorted;\n    assert(candidate((std::vector<long>({(long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/127",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاونن ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاون ڤرلاڤ\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get(interval1);\n  long end1 = std::get(interval1);\n  long start2 = std::get(interval2);\n  long end2 = std::get(interval2);\n  long intersection_start = std::max(start1, start2);\n  long intersection_end = std::min(end1, end2);\n  long intersection_length = intersection_end - intersection_start + 1;\n  if (intersection_length <= 0) {\n    return \"NO\";\n  }\n  if (is_prime(intersection_length)) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
    },
    {
        "task_id": "HumanEval/128",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو دبري ۏيكتور ار ار وانكو ڤرلو مروڤاكن سومبڠن ڬانل ار دالم ڤرودوك سموا تينجوق ستياڤ ار د ڤيكتور، دڤرتيمبڠكن اوليه ١،-١ اتاو ٠. تيتيقن: مروڤاكن نيه باڬي ار بياسا. چونتوه: >>> prod_signs((std::vector<long>{(long) ١، (long) ٢، (long) ٢، (long) -٤}))) 9 >>> prod_signs(std::vector<long>({(long) ٠، (long) ١}))) 0 >>> prod_signs(std::vector<long>((std::nopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  long sum_magnitudes = 0;\n  long product_of_signs = 1;\n  for (long num : arr) {\n    sum_magnitudes += std::abs(num);\n    if (num > 0) {\n      product_of_signs *= 1;\n    } else if (num < 0) {\n      product_of_signs *= -1;\n    } else {\n      product_of_signs *= 0;\n    }\n  }\n  return sum_magnitudes * product_of_signs;\n}",
        "test": "}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/129",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// د مان جريد دڠن N رنچان وان N ستور (N >= 2) وان ساتو اينتيڬر ڤوسيتيف k، ستياڤ سيل جريد ممڤوڽاءي ۏاليو. ستياڤ اينتيڬر دالم رنچان [1, N * N] ڤون برلاكو ساكيت سام ساتو ڤد سيل جريد. اندا ڤرلو مميليه ڤاسر مينيموم ڤاسر ڤولاو k د جريد. اندا بوليه مولا دري سيل مان، دان د ستياڤ ڤاسر اندا بوليه مڠمبيل ڤاسر كڤد سيل ڤاسر ڤاسر ڤاسر يڠ برسام اندا. اندا بوليه تيدق برلاكو دري جريد. ڤاسر A (ڤاسر ڤولاو k) بوليه دأڠڬڤ سباڬاي ڤاسر ڤولاو B (ڤاسر ڤولاو k) اڤابيلا ستله ممبنتو ۏيکتور ڤرتوتراوان ڤاسر ڤولاو A وان B (كيتله كيتله كيتله جادي l_stA وان l_st_ l_st_ l_ l_ l_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  int n = grid.size();\n  std::vector<long> min_path;\n\n  std::function<void(int, int, std::vector<long>)> dfs = \n    [&](int row, int col, std::vector<long> current_path) {\n    if (current_path.size() == k) {\n      if (min_path.empty() || current_path < min_path) {\n        min_path = current_path;\n      }\n      return;\n    }\n\n    current_path.push_back(grid[row][col]);\n\n    int dr= {-1, 1, 0, 0};\n    int dc= {0, 0, -1, 1};\n\n    for (int i = 0; i < 4; ++i) {\n      int next_row = row + dr[i];\n      int next_col = col + dc[i];\n      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {\n        dfs(next_row, next_col, current_path);\n      }\n    }\n  };\n\n  for (int start_row = 0; start_row < n; ++start_row) {\n    for (int start_col = 0; start_col < n; ++start_col) {\n      dfs(start_row, start_col, {});\n    }\n  }\n\n  return min_path;\n}",
        "test": "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/130",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سياڤاڽ تاهو سلسله فيبوناتچي،ڽو دڤرچايا ?? ي سچارا لڠسوڠ اوليه ڤارا ماتماتيك دالم دوا ابد اخير.تتاڤي،اڤ يڠ اورڠ تيدق تاهو اياله سلسله تريبوناتچي.سلسلة تريبوناتچي دتوليس اوليه ڤنوليسن: tri(1) = 3 tri(n) = 1 + n / 2، اڤابيلا n اداله جوت. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، اڤابيلا n اداله بياد. چونتوهڽ: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 اڤابيلا اكو دبريكن نومبور اينتڬاتيف ن،كو ڤرلو مڠيروڤاكن ۏكتور ڤرتام n + 1 دري سلسله تريبوناتچي. چونتوهڽ: >>> tri(3) (dst long vector><<<({long} (long 1,3, (long 2, long 8))\nstd::vector<long> tri(long n) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> tri(long n) {\n  std::vector<long> result;\n  if (n >= 0) {\n    result.push_back(1);\n  }\n  if (n >= 1) {\n    result.push_back(3);\n  }\n  for (long i = 2; i <= n; ++i) {\n    if (i % 2 == 0) {\n      result.push_back(1 + i / 2);\n    } else {\n      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)\n      {\n          result.push_back(result[i-1] + result[i-2] + result[i]);\n      }\n      else if (i - 1 >= 0 && i - 2 >= 0)\n      {\n          result.push_back(result[i-1] + result[i-2]);\n      }\n      else if (i - 1 >= 0)\n      {\n          result.push_back(result[i-1]);\n      }\n      else\n      {\n          result.push_back(0);\n      }\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = tri;\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));\n    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));\n    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));\n    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));\n    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));\n    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));\n    assert(candidate((0)) == (std::vector<long>({(long)1})));\n    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/131",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديباڠونكن سابوتيڠ انتيڬر ڤوسيتيف ن، ماولاه ڤرباتاس دالم ديڬيت ڤرڠ. ماولاه 0 اڤابيلا سموا ديڬيت اداله ڤرڠ. چونتوهڽ: >>> ديڬيت (((1)) (1) >>> ديڬيت (((4)) (0) >>> ديڬيت (((235)) (15)\nlong digits(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digits(long n) {\n  long product = 1;\n  std::string s = std::to_string(n);\n  bool has_odd = false;\n  for (char c : s) {\n    long digit = c - '0';\n    if (digit % 2 != 0) {\n      product *= digit;\n      has_odd = true;\n    }\n  }\n  if (!has_odd) {\n    return 0;\n  }\n  return product;\n}",
        "test": "}\nint main() {\n    auto candidate = digits;\n    assert(candidate((5)) == (5));\n    assert(candidate((54)) == (5));\n    assert(candidate((120)) == (1));\n    assert(candidate((5014)) == (5));\n    assert(candidate((98765)) == (315));\n    assert(candidate((5576543)) == (2625));\n    assert(candidate((2468)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/132",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي يڠ مڠاخيري سورت كيت سڤرتي ڤڠمبيلن ڤركتيك. فانسي هاروس مڠرجاكن سچارا تيدق سڤرتي ڤركتيك يڠ اد دالم ساتو سورت ڤركتيك دڠن ڤون ساتو ڤركتيك دالمڽ. >>> is_nested((\"[[]]\")) (true) >>> is_nested((\"[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]\nbool is_nested(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_nested(std::string string) {\n  int balance = 0;\n  bool nested = false;\n  for (char c : string) {\n    if (c == '[') {\n      balance++;\n    } else if (c == ']') {\n      if (balance > 1) {\n        nested = true;\n      }\n      balance--;\n      if (balance < 0) {\n        return false;\n      }\n    }\n  }\n  return balance == 0 && nested;\n}",
        "test": "}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/133",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠڬيرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڬرن ڤيڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠ\nlong sum_squares(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    long rounded_up = std::ceil(num);\n    sum += rounded_up * rounded_up;\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));\n    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));\n    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));\n    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/134",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فڠسي يڠ مروڤاكن كاءداءن سچارا سچارا اڤابيلا كاراكتر اخير ستراين دبريكن اداله كاراكتر ابجد دان تيدق باڬين دري ساتو كات، وان كاءداءن لاين. تاتاڤ: \"كات\" اداله ڬروڤ كاراكتر يڠ ديباڠكيت اوليه ڤڠاروه. چونتوه: >>> check_if_last_char_is_a_letter (((\"apple pie\")) (false) >>> check_if_last_char_is_a_letter (((\"apple pi e\")) (true) >>> check_if_last_char_is_a_letter ((((\"apple pi e \")) (false) >>> check_if_last_char_is_a_letter (((\"\")) (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) {\n    return false;\n  }\n  if (!isalpha(txt.back())) {\n    return false;\n  }\n  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {\n    return false;\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = check_if_last_char_is_a_letter;\n    assert(candidate((\"apple\")) == (false));\n    assert(candidate((\"apple pi e\")) == (true));\n    assert(candidate((\"eeeee\")) == (false));\n    assert(candidate((\"A\")) == (true));\n    assert(candidate((\"Pumpkin pie \")) == (false));\n    assert(candidate((\"Pumpkin pie 1\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"eeeee e \")) == (false));\n    assert(candidate((\"apple pie\")) == (false));\n    assert(candidate((\"apple pi e \")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/135",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي يڠ مروڤاكن ايندكس ڤاليڠ بسر دري ايليمن يڠ تيدق لبيه بسر اتاو سام دڠن ايليمن يڠ سديا سبلومڽ. اڤابيلا ايليمن نڠ كادا اد كالي اين مروڤاكن -1. ۏيكتور يڠ دبري اندا اكن ممڤوڽاءي ۏيليو دوڤليک. چونتوه: >>> can_arrange(((std::vector<long>({long) 1, (long) 2, (long) 4, (long) 3, (long) 5}))) (3) >>> can_arrange((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (-1)\nlong can_arrange(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong can_arrange(std::vector<long> arr) {\n  for (long i = 1; i < arr.size(); ++i) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "test": "}\nint main() {\n    auto candidate = can_arrange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));\n    assert(candidate((std::vector<long>())) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/136",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي يڠ مروڤاكن توڤل (a، b) ، د مان 'a' اداله ڤونچا نڠ ڤاليڠ بسر دري اينتيڬر نڠڬاتيف، وان 'b' اداله ڤونچا نڠ ڤاليڠ كلوار دري اينتيڬر ڤوسيتيف دالم ساتو ۏيكتور. اڤابيلا تياد اينتيڬر نڠڬاتيف اتاو ڤوسيتيف، مروڤاكنڽ سباڬاي None. چونتوه: >>> largest_smallest_integers(((std::vector<long>{long>(long) 2, (long) 4, (long) 1, (long) 3, (long) 5, (long) 7)) std::make_tuplest_d::optional<long>(dull::nopt), std::optional<long>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<tuple>\n#include<vector>\n\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative.has_value() || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive.has_value() || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative, smallest_positive);\n}",
        "test": "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));\n    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));\n}\n"
    },
    {
        "task_id": "HumanEval/137",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// مڠمبيل فانسي يڠ مڠاخيري انتيجر، فلوات، اتاو سورت يڠ مروڤاكن ارق ريال، وان مروڤاكن ۏاريابيل نڠ لابه بسر دالم جنيس ڤاريابيل نڠ دبريڽ. مروڤاكن نڠه اڤابيلا ۏاريابيل نڠ سام. تاتنتو: اڤابيلا ارق ريال دڤرتنديڠ سباڬاي سورت، تيتيق ڤلڠڬن موڠكين . اتاو، >>> مقاساس_ساتوءن ((1، 2.5f) 2.5f >>> مقاس_ساتوءن ((1، \"2,3\") \"2,3\" >>> مقاس_ساتوءن ((\"5,1\"، \"6\") \"6\" >>> مقاس_ساتوءن ((\"1\"، 1) std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<string>\n\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;\n    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;\n    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n\ndouble parse_real(const std::string& s) {\n    std::string temp = s;\n    std::replace(temp.begin(), temp.end(), ',', '.');\n    try {\n        return std::stod(temp);\n    } catch (const std::invalid_argument& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    } catch (const std::out_of_range& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    }\n}\n\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a.f2.empty() && b.f2.empty()) {\n        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {\n            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {\n            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {\n            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {\n            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);\n        }\n    } else {\n        double val_a, val_b;\n        if (!a.f2.empty()) val_a = parse_real(a.f2);\n        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);\n        else val_a = static_cast<double>(a.f1);\n\n        if (!b.f2.empty()) val_b = parse_real(b.f2);\n        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);\n        else val_b = static_cast<double>(b.f1);\n\n        if (!std::isnan(val_a) && !std::isnan(val_b)) {\n            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);\n            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);\n        }\n    }\n    return Union_long_float_std_string_std_nullopt(std::nullopt{});\n}",
        "test": "}\nint main() {\n    auto candidate = compare_one;\n    assert(candidate(1, 2) == 2);\n    assert(candidate(1, 2.5f) == 2.5f);\n    assert(candidate(2, 3) == 3);\n    assert(candidate(5, 6) == 6);\n    assert(candidate(1, \"2,3\") == \"2,3\");\n    assert(candidate(\"5,1\", \"6\") == \"6\");\n    assert(candidate(\"1\", \"2\") == \"2\");\n    assert(candidate(\"1\", 1) == std::nullopt);\n}\n"
    },
    {
        "task_id": "HumanEval/138",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠاڤلواڠكن بهاوا نومبور ن نڠ دبريكن بوليه دتوليس سباڬاي سوم 4 نومبور ڤوسيتيف تتاڤي ڤوسيتيف ڤون چونتوه >>> is_equal_to_sum_even ((4)) (false) >>> is_equal_to_sum_even ((6)) (false) >>> is_equal_to_sum_even ((8)) (true)\nbool is_equal_to_sum_even(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_equal_to_sum_even(long n) {\n    if (n <= 6 || n % 2 != 0) {\n        return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_equal_to_sum_even;\n    assert(candidate((4)) == (false));\n    assert(candidate((6)) == (false));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (true));\n    assert(candidate((11)) == (false));\n    assert(candidate((12)) == (true));\n    assert(candidate((13)) == (false));\n    assert(candidate((16)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/139",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فكتوريل برازيليا دتودوه ساباڬاي: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! دمان n > 0 چونتوهڽ: >>> special_factorial((4)) (288) فكتوريل اكن منداڤت سابوءه انتيڬر سباڬاي اينتريم وان هاروس مڽارولاكن فكتوريل خاص انتيڬر ڠيني.\nlong special_factorial(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong factorial(long k) {\n    long res = 1;\n    for (long i = 2; i <= k; ++i) {\n        res *= i;\n    }\n    return res;\n}\n\nlong special_factorial(long n) {\n    if (n <= 0) {\n        return 1;\n    }\n    long result = 1;\n    for (long i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = special_factorial;\n    assert(candidate((4)) == (288));\n    assert(candidate((5)) == (34560));\n    assert(candidate((7)) == (125411328000));\n    assert(candidate((1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/140",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتنتوكن سابوتيڠ تيكس سورت، ماڠاجوكن سموا ڤاسير دالمڽ دڠن كاكيتاڠن، وان جادي سابوتيڠ سورت اد باڽق دري 2 ڤاسير سورت، لالو ماڠاجوكن سموا ڤاسير سورت دڠن - >>> fix_spaces((\" چونتوه \")) (\" چونتوه \") >>> fix_spaces((\" چونتوه 1 \")) (\" چونتوه_1 \") >>> fix_spaces((\" چونتوه 2 \")) (\"_ چونتوه_2 \") >>> fix_spaces((\" چونتوه 3 \")) (\"_ چونتوه-3\")\nstd::string fix_spaces(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string fix_spaces(std::string text) {\n    std::string result = \"\";\n    int space_count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 1) {\n                result += '-';\n            }\n            result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1 && !result.empty() && result.back() != '_') {\n        result += '_';\n    } else if (space_count > 1 && !result.empty() && result.back() != '-') {\n        result += '-';\n    } else if (space_count > 0 && result.empty()) {\n        if (space_count > 2) result += '-';\n        else if (space_count == 1) result += '_';\n    } else if (space_count == 1 && result.empty()) {\n        result += '_';\n    }\n\n    std::string trimmed_result = \"\";\n    bool non_space_found = false;\n    for (char c : result) {\n        if (c != ' ') {\n            non_space_found = true;\n            trimmed_result += c;\n        } else if (non_space_found) {\n            trimmed_result += c;\n        }\n    }\n\n    while (!trimmed_result.empty() && trimmed_result.front() == '_') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '_') {\n        trimmed_result.pop_back();\n    }\n     while (!trimmed_result.empty() && trimmed_result.front() == '-') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '-') {\n        trimmed_result.pop_back();\n    }\n\n    std::string final_result = \"\";\n    space_count = 0;\n    for (char c : trimmed_result) {\n        if (c == '_') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                final_result += '_';\n            } else if (space_count > 1) {\n                final_result += '-';\n            }\n            final_result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1) {\n        final_result += '_';\n    } else if (space_count > 1) {\n        final_result += '-';\n    }\n\n    return final_result;\n}",
        "test": "}\nint main() {\n    auto candidate = fix_spaces;\n    assert(candidate((\"Example\")) == (\"Example\"));\n    assert(candidate((\"Mudasir Hanif \")) == (\"Mudasir_Hanif_\"));\n    assert(candidate((\"Yellow Yellow  Dirty  Fellow\")) == (\"Yellow_Yellow__Dirty__Fellow\"));\n    assert(candidate((\"Exa   mple\")) == (\"Exa-mple\"));\n    assert(candidate((\"   Exa 1 2 2 mple\")) == (\"-Exa_1_2_2_mple\"));\n}\n"
    },
    {
        "task_id": "HumanEval/141",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فڠسي يڠ مڠمبيل سورت يڠ مروڤاكن نام فايل، دان مڽاتاكن 'Yes' اڤابيلا نام فايل ايت باءيق، دان مڽاتاكن 'No' اڤابيلا تيدق. نام فايل ايت دأڠݢڤ باءيق اڤابيلا ساريڠ شرط-شرط يڠ دتتڤكن: - تيدق بوليه اد لبيه دري تيݢ ديڬيت ('0'-'9') دالم نام فايل. - نام فايل ايت ممڤوڽاءي سڤرتي ساتو تندا '.' - سورت سبلوم تندا تيدق بوليه برڤاكاين، دان مولا دڠن حروف دري حروف لاتين ('a'-'z' دان 'A'Z'). - سورت سبلوم تندا ڤرلو جادي ساتو دري حروف-حروف اين: ['txt', 'exe', 'lld'] چونتوه: >>> file_name_check\"{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::string file_name_check(std::string file_name) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    size_t dot_pos = std::string::npos;\n\n    for (size_t i = 0; i < file_name.length(); ++i) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        } else if (file_name[i] == '.') {\n            dot_count++;\n            dot_pos = i;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {\n        return \"No\";\n    }\n\n    std::string name_part = file_name.substr(0, dot_pos);\n    std::string ext_part = file_name.substr(dot_pos + 1);\n\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    if (ext_part == \"txt\" || ext_part == \"exe\" || ext_part == \"dll\") {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) == (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n    assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"_f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
    },
    {
        "task_id": "HumanEval/142",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \" فانكس ڠيني مڠاخيري ۏيكتور انتيڬري. ڬسن سموا اينتر د ڤيكتور، فانكس هاروس مڠكوادري اينتر انتيڬري اڤابيلا ايندكسڽ اداله ڤرباتسن دري 3 وان هاروس مڠكوايس اينتر انتيڬري اڤابيلا ايندكسڽ اداله ڤرباتسن دري 4 وان كادا ڤرباتسن دري 3. فانكس هان مڠاجر اينتر د ڤيكتور يڠ ايندكسڽ اداله ڤرباتسن دري 3 اتاو 4. فانكس هاروس مڠرجوكن سومتوم سموا اينتر. چونتوه: >>> lst (long({(long) 1, (long) 2, (long) 3})) >>> lst ((long)) >>> lst ({(long) -1, (long) -5, (long) 2, (long) -1, (long) -5}))\nlong sum_squares(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));\n    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));\n    assert(candidate((std::vector<long>({(long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));\n    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));\n    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));\n}\n"
    },
    {
        "task_id": "HumanEval/143",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو دبري ساءيرڠ يڠ مروڤاكن سابوءه ساءيرڠ، ساءيرڠ ايت مڠاندوڠي ببراڤ كات دڤرباتڠكن دڠن سبواه ڤرتاڽان، وان اكو ڤرلو مڠرجاكن ساءيرڠ يڠ مڠاندوڠي كات-كات دري ساءيرڠ اول، نڠ لنجوتڽ اداله ڤرميت، اورد كات-كات د ساءيرڠ بارو ڤرلو سام لاڬي ساءيرڠ اول. چونتوه 1: >>> words_in_sentence (((\"This is a test\")) (\"is\") چونتوه 2: >>> words_in_sentence (((\"let's go for swimming\")) (\"go for\") كونترينت: * 1 <= len ((sentence) <= 100 * ساءيرڠ ايت مڠاندوڠي ڤرتولوڠن حروف\nstd::string words_in_sentence(std::string sentence) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
    },
    {
        "task_id": "HumanEval/144",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// كاريكاتورن كامي اداله اونتوق ممڤركنلكن ڤركارا x * n. ڤركارا اين ممبري ڤرچاي درڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد جاوي ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤ\nbool simplify(std::string x, std::string n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong gcd(long a, long b) {\n    while (b) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\nbool simplify(std::string x, std::string n) {\n    long x_num, x_den, n_num, n_den;\n    size_t slash_pos = x.find('/');\n    x_num = std::stol(x.substr(0, slash_pos));\n    x_den = std::stol(x.substr(slash_pos + 1));\n\n    slash_pos = n.find('/');\n    n_num = std::stol(n.substr(0, slash_pos));\n    n_den = std::stol(n.substr(slash_pos + 1));\n\n    long num = x_num * n_num;\n    long den = x_den * n_den;\n\n    long common_divisor = gcd(num, den);\n    den /= common_divisor;\n\n    return den == 1;\n}",
        "test": "}\nint main() {\n    auto candidate = simplify;\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/6\"), (\"2/1\")) == (false));\n    assert(candidate((\"5/1\"), (\"3/1\")) == (true));\n    assert(candidate((\"7/10\"), (\"10/2\")) == (false));\n    assert(candidate((\"2/10\"), (\"50/10\")) == (true));\n    assert(candidate((\"7/2\"), (\"4/2\")) == (true));\n    assert(candidate((\"11/6\"), (\"6/1\")) == (true));\n    assert(candidate((\"2/3\"), (\"5/2\")) == (false));\n    assert(candidate((\"5/2\"), (\"3/5\")) == (false));\n    assert(candidate((\"2/4\"), (\"8/4\")) == (true));\n    assert(candidate((\"2/4\"), (\"4/2\")) == (true));\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/5\"), (\"1/5\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/145",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ مڠورڠكن ۏيكتور اينتيجر دالم اوردين مڠورڠكن سڤرتي سومبڠن ديڬيتڽ. تاهو: اڤابيلا اد ببراڤ ايتيمن دڠن سومبڠن ديڬيتڽ نڠ سام، مڠورڠكنڽ بربنديڠ اينديكسڽ د دالم ۏيكتور اصل. چونتوهڽ: >>> order_by_points((std::vector<long>({long) 1, (long) 11, (long)-1, (long) - 11, (long) - 12}))) (std::vector<long>({long) - 1, (long) - 11, (long) - 1, (long) - 12, (long) - 11)) >>> order_by_points((std::vector<long>())) (std::vector<long>(long))\nstd::vector<long> order_by_points(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_digits(long n) {\n    long sum = 0;\n    std::string s = std::to_string(std::abs(n));\n    for (char c : s) {\n        sum += c - '0';\n    }\n    return sum;\n}\n\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, size_t>> indexed_nums;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {\n        long sum_a = sum_digits(a.first);\n        long sum_b = sum_digits(b.first);\n        if (sum_a != sum_b) {\n            return sum_a < sum_b;\n        }\n        return a.second < b.second;\n    });\n\n    std::vector<long> result;\n    for (const auto& pair : indexed_nums) {\n        result.push_back(pair.first);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = order_by_points;\n    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));\n    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/146",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانکشن نڠ مڠاخيري ۏيكتور نومبور سباڬاي اينڤوت وان مروڤاكن كاءداءن ايليمن د ۏيكتور نڠ لبيه بسر دري 10 وان دوا-دوا ديڬيت ڤرتام وان اخير نومبور اداله ڤارڠ (1, 3, 5, 7, 9). چونتوهڽ: >>> specialFilter((std::vector<long>({long) 15, (long) -73, (long) 14، (long) -15}))) (1) >>> specialFilter((std::vector<long>({long) 33, (long) -2, (long) -3, (long) -4, (long) 21, (long) 109} (2))))\nlong specialFilter(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_odd_digit(char c) {\n    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');\n}\n\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (std::abs(num) > 10) {\n            std::string s = std::to_string(std::abs(num));\n            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = specialFilter;\n    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));\n    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));\n    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));\n    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));\n    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>())) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/147",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو دبريكن ساتو اينتڬر ڤوسيتيف ن. اكو ڤرلو مڠمبيل ۏيكتور اينتڬر a دري لڠكه n. باڬي ستياڤ i (1 ≤ i ≤ n) ، ۏاليو a[i] = i * i - i + 1. مروڤاكن كاءداءن تريبل (a[i], a[j], a[k]) دري a د مان i < j < k، وان a[i] + a[j] + a[k] اداله ڤربلنجأن دري 3. چونتوه: >>> get_max_triples((5)) (1) ڤرتفسن: a = [1, 3, 7, 13, 21] تريبل ڤاليڠ باءيق اداله (1, 7, 13).\nlong get_max_triples(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong get_max_triples(long n) {\n    if (n < 3) {\n        return 0;\n    }\n    std::vector<long> a(n);\n    for (long i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            for (long k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = get_max_triples;\n    assert(candidate((5)) == (1));\n    assert(candidate((6)) == (4));\n    assert(candidate((10)) == (36));\n    assert(candidate((100)) == (53361));\n}\n"
    },
    {
        "task_id": "HumanEval/148",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اد تاهون لالو دالم سيستم سولر كيت: نڠ ڤاليڠ كايڠين كيت كڤد هاري اداله ميريچي، نڠ ڤاليڠ كايڠين اداله ۏينوس، لالو بومي، مريس، جوڤيتر، ساترن، اورانوس، نڤتون. منوليس فڠسي يڠ مڠڬوناكن دوا نام ڤلانيت سباڬاي سورت ڤلانيت1 وان ڤلانيت2. فڠسي هاروس ممباوا سابوءه توڤل يڠ ممباوا سلوروه ڤلانيت يڠ اوربيتڽ دتوكر انتارا اوربيت ڤلانيت1 وان اوربيت ڤلانيت2، دتربيتكن اوليه كايڠكأن كڤد هاري. فڠسي هاروس ممباوا سابوءه توڤل ڤاليڠ باءيك اڤابيلا ڤلانيت1 اتاو ڤلانيت2 تيدق نام ڤلانيت. چونتوهن >>> bf((\"جوبيتر\") (نيڤتون) (std) (st) (d) (d) (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d) (d) (d (d) (d) (d (d) (d) (d) (d) (d (d) (d) (d) (d) (d (d) (d) (d) (d (d) (d) (d) (d) (d (d) (d) (d) (d) (d (d) (d) (d) (d) (d) (d (d) (d) (d (d) (d) (d) (d) (d (d) (d) (d\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};\n    }\n\n    int index1 = std::distance(planets.begin(), it1);\n    int index2 = std::distance(planets.begin(), it2);\n\n    if (index1 == index2) {\n        return {};\n    }\n\n    int start = std::min(index1, index2) + 1;\n    int end = std::max(index1, index2);\n\n    std::vector<std::string> result;\n    for (int i = start; i < end; ++i) {\n        result.push_back(planets[i]);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/149",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤيڠين ڤي\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> even_length_strings;\n    for (const std::string& s : lst) {\n        if (s.length() % 2 == 0) {\n            even_length_strings.push_back(s);\n        }\n    }\n\n    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n\n    return even_length_strings;\n}",
        "test": "}\nint main() {\n    auto candidate = sorted_list_sum;\n    assert(candidate((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"}))) == (std::vector<std::string>({(std::string)\"aa\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"school\", (std::string)\"AI\", (std::string)\"asdf\", (std::string)\"b\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"asdf\", (std::string)\"school\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"b\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"dcba\", (std::string)\"abcd\", (std::string)\"a\"}))) == (std::vector<std::string>({(std::string)\"abcd\", (std::string)\"dcba\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"b\", (std::string)\"c\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaa\", (std::string)\"bbbb\", (std::string)\"dd\", (std::string)\"cc\"}))) == (std::vector<std::string>({(std::string)\"cc\", (std::string)\"dd\", (std::string)\"aaaa\", (std::string)\"bbbb\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/150",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سابوتيڠ ڤروڬرم سيباڬايڽ نڠ ڤرلو مڽاراكن ڤاريت x اڤابيلا n اداله سابوتيڠ نومبور ڤرم وان ڤرلو مڽاراكن ڤاريت y. چونتوه: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)\nlong x_or_y(long n, long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(long n) {\n    if (n <= 1) return false;\n    for (long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nlong x_or_y(long n, long x, long y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = x_or_y;\n    assert(candidate((7), (34), (12)) == (34));\n    assert(candidate((15), (8), (5)) == (5));\n    assert(candidate((3), (33), (5212)) == (33));\n    assert(candidate((1259), (3), (52)) == (3));\n    assert(candidate((7919), (-1), (12)) == (-1));\n    assert(candidate((3609), (1245), (583)) == (583));\n    assert(candidate((91), (56), (129)) == (129));\n    assert(candidate((6), (34), (1234)) == (1234));\n    assert(candidate((1), (2), (0)) == (0));\n    assert(candidate((2), (2), (0)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/151",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتاهن سابوءه ۏيكتور ڤارا نومبور، ماولاه سومبر تربيت ڤارا نومبور د ۏيكتور نڠ كادڠ. ماولاهكن نومبور نڠ نڠ نݢاتيف اتاو كادا اينتيڬر. >>> double_the_difference(((std::vector<float>({(long) 1, (long) 3, (long) 2, (long) 0}))) (10) >>> double_the_difference(((std::vector<float>{(long)-1, (long)-2, (long) 0}))) (0) >>> double_the_difference(((std::vector<float>{(long) 9, (long)-2}))) (81) >>> double_the_difference(((std::vector<float>{(long) 0))) (0) اڤون ۏيكتور ڤرلو، ماولاه 0.\nlong double_the_difference(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong double_the_difference(std::vector<float> lst) {\n    long sum_of_squares = 0;\n    for (float num : lst) {\n        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {\n            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);\n        }\n    }\n    return sum_of_squares;\n}",
        "test": "}\nint main() {\n    auto candidate = double_the_difference;\n    assert(candidate((std::vector<float>())) == (0));\n    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));\n    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));\n    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));\n}\n"
    },
    {
        "task_id": "HumanEval/152",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤندودوق ڤرلو مڠاتسي ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبهن ڤرسمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرمبن ڤرم\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    std::vector<long> diff;\n    for (size_t i = 0; i < game.size(); ++i) {\n        diff.push_back(std::abs(game[i] - guess[i]));\n    }\n    return diff;\n}",
        "test": "}\nint main() {\n    auto candidate = compare;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));\n    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/153",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو اكن دبري نام كلاس (سوكو) وان ۏيكتور ايكستينسي. ايكستينسي ها اكن دڤاكاي ڬاسن مڠلواركن كلاس-كلاس لاين ك كلاس. كقواتن ايكستينسي ها اداله سڤرتي اين: كاي CAP اداله كادأن حروف-حروف ماڤيركيس دالم نام ايكستينسي، وان كاي SM اداله كادأن حروف-حروف مينيس دالم نام ايكستينسي، كقواتن دبري اوليه كروسي CAP - SM. اكو ڤرلو مميليه ايكستينسي نڠ كوات وان مروڤاكن سوكو دالم ڤورتميت اين: ClassName.StrongestExtensionName. اڤابيلا اد دوا اتاو لبيه ايكستينسي نڠ كقواتن سام، اكو ڤرلو مميليه ايكستينسي نڠ ڤرتام د ڤيڠكتن. چونتوهڽ، اڤابيلا اكو دبري \"سوكس\" سباڬاي كلاس وان ۏيكتور ايكستينسي: ['S'S'viS'liNGCes'Ces'Ces'Ces'Ces'Ces'Ces'C'es'C'es'], 'Cheese', 'Stufed'StuF'F'F'StuF' فاكرلو اكو ڤرلو مروت اكو ڤرلوار 'سيسيس'كوسن ايكس'كايڽ: 'S'S'viS'viSviSviSviSviSviviviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSviSvi\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint calculate_strength(const std::string& extension) {\n    int cap_count = 0;\n    int sm_count = 0;\n    for (char c : extension) {\n        if (isupper(c)) {\n            cap_count++;\n        } else if (islower(c)) {\n            sm_count++;\n        }\n    }\n    return cap_count - sm_count;\n}\n\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    if (extensions.empty()) {\n        return class_name;\n    }\n\n    std::string strongest_extension = extensions[0];\n    int max_strength = calculate_strength(extensions[0]);\n\n    for (size_t i = 1; i < extensions.size(); ++i) {\n        int current_strength = calculate_strength(extensions[i]);\n        if (current_strength > max_strength) {\n            max_strength = current_strength;\n            strongest_extension = extensions[i];\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}",
        "test": "}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"}))) == (\"Sp.671235\"));\n}\n"
    },
    {
        "task_id": "HumanEval/154",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// كامو دبري ٢ كات. كامو ڤرلو مڽاتاكن سيكڤ اڤابيلا كات كدوا اتاو سابوءه ڤرتمڤورنڽ اداله سوبسترينگ د كات ڤرتام >>> سيكڤتيرن_چيك (((\"ابكد\"), (\"ابكد\")) (فالس) >>> سيكڤتيرن_چيك (((\"سلو\"), (\"ال\")) (ترا) >>> سيكڤتيرن_چيك (((\"واسوپ\"), (\"ڤس\")) (فالس) >>> سيكڤتيرن_چيك (((\"اباب\"), (\"با\")) (ترا) >>> سيكڤتيرن_ (((چيك\"ايف\"), (\"ايفف\") (فالس) >>> سيكڤتيرن_چيك (((\"سيمنس\"), (\"سيمن\") (ترا)\nbool cycpattern_check(std::string a, std::string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool cycpattern_check(std::string a, std::string b) {\n    if (b.empty()) {\n        return true;\n    }\n    if (a.length() < b.length()) {\n        return false;\n    }\n    for (int i = 0; i < b.length(); ++i) {\n        std::rotate(b.begin(), b.begin() + 1, b.end());\n        if (a.find(b) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = cycpattern_check;\n    assert(candidate((\"xyzw\"), (\"xyw\")) == (false));\n    assert(candidate((\"yello\"), (\"ell\")) == (true));\n    assert(candidate((\"whattup\"), (\"ptut\")) == (false));\n    assert(candidate((\"efef\"), (\"fee\")) == (true));\n    assert(candidate((\"abab\"), (\"aabb\")) == (false));\n    assert(candidate((\"winemtt\"), (\"tinem\")) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/155",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديباڠونكن سابوءه انتيڬر. ماولاه سابوءه توڤل نڠ بايسي باڽق ديڬيت ڤرتاڽا وان ڤرتاڽا. چونتوه: >>> even_odd_count((-12)) (std::make_tuple(1, 1)) >>> even_odd_count((123)) (std::make_tuple(1, 2)\nstd::tuple<long, long> even_odd_count(long num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<tuple>\n\nstd::tuple<long, long> even_odd_count(long num) {\n    long even_count = 0;\n    long odd_count = 0;\n    std::string s = std::to_string(std::abs(num));\n    for (char c : s) {\n        int digit = c - '0';\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_count;\n    assert(candidate((7)) == (std::make_tuple(0, 1)));\n    assert(candidate((-78)) == (std::make_tuple(1, 1)));\n    assert(candidate((3452)) == (std::make_tuple(2, 2)));\n    assert(candidate((346211)) == (std::make_tuple(3, 3)));\n    assert(candidate((-345821)) == (std::make_tuple(3, 3)));\n    assert(candidate((-2)) == (std::make_tuple(1, 0)));\n    assert(candidate((-45347)) == (std::make_tuple(2, 3)));\n    assert(candidate((0)) == (std::make_tuple(1, 0)));\n}\n"
    },
    {
        "task_id": "HumanEval/156",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتنتوكن سابوءه انتيڬر ڤوسيتيف، ماوليهاكن ايكسڤيرد نومبر رومنڽ سابوءه ستريڠ، وان مروڤاكنڽ دالم كاسر مينيس. رينستريكتس: 1 <= num <= 1000 چونتوه: >>> int_to_mini_roman((19)) (\"xix\") >>> int_to_mini_roman((152)) (\"clii\") >>> int_to_mini_roman(426) (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            roman += pair.second;\n            number -= pair.first;\n        }\n    }\n    return roman;\n}",
        "test": "}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
    },
    {
        "task_id": "HumanEval/157",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتاهن لڠكه دري تيݢ بنتوق تيݢݢݢان. مڽاتاكن كاءيقينن اڤابيلا تيݢ بنتوق ممبنتوق تيݢݢان ڤرچاي، كادا. تيݢݢان ڤرچاي اداله تيݢݢان د مان ساتو ڤڠاروهڽ اداله ڤڠاروه ڤرچاي اتاو 90 دراج. چونتوه: >>> right_angle_triangle (((3), (4), (5)) (true) >>> right_angle_triangle (((1), (2), (3)) (false)\nbool right_angle_triangle(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool right_angle_triangle(long a, long b, long c) {\n    std::vector<long> sides = {a, b, c};\n    std::sort(sides.begin(), sides.end());\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);\n}",
        "test": "}\nint main() {\n    auto candidate = right_angle_triangle;\n    assert(candidate((3), (4), (5)) == (true));\n    assert(candidate((1), (2), (3)) == (false));\n    assert(candidate((10), (6), (8)) == (true));\n    assert(candidate((2), (2), (2)) == (false));\n    assert(candidate((7), (24), (25)) == (true));\n    assert(candidate((10), (5), (7)) == (false));\n    assert(candidate((5), (12), (13)) == (true));\n    assert(candidate((15), (8), (17)) == (true));\n    assert(candidate((48), (55), (73)) == (true));\n    assert(candidate((1), (1), (1)) == (false));\n    assert(candidate((2), (2), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/158",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤينتادين ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچق ڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤونچڤون\nstd::string find_max(std::vector<std::string> words) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint count_unique_chars(const std::string& s) {\n    std::set<char> unique_chars;\n    for (char c : s) {\n        unique_chars.insert(c);\n    }\n    return unique_chars.size();\n}\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) {\n        return \"\";\n    }\n\n    std::string max_unique_word = words[0];\n    int max_unique_count = count_unique_chars(words[0]);\n\n    for (size_t i = 1; i < words.size(); ++i) {\n        int current_unique_count = count_unique_chars(words[i]);\n        if (current_unique_count > max_unique_count) {\n            max_unique_count = current_unique_count;\n            max_unique_word = words[i];\n        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {\n            max_unique_word = words[i];\n        }\n    }\n    return max_unique_word;\n}",
        "test": "}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"}))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
    },
    {
        "task_id": "HumanEval/159",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو اداله سابوتيڠ بڠكيت يڠ سوده ماكن باڽق كروت، تاڤي كامي ڤرلو ماكن لبيه باڽق كروت اونتوق مڠمبيل ماس ڤد هاري اين. اكو ڤرلو مڠرجاكن ۏيكتور [كورڠن كروت يڠ دميليكي ستله ماكنن، كيرا-كيرا كروت يڠ تله دميليكي ستله ماكنن] اڤابيلا تيدق اد باڽق كروت يڠ سوده سوده، اكو اكن ممبلي سموا كروت يڠ سوده سوده، تاڤي اكو ماسيه ماسيه برڤاكاين. چونتوه: >>> مڠومڤول ((((5), (6), (10)) (std::vector<long>{(()11, (long)4}) >>> مڠومڤول (((4), (8), (9) (std::vector<long>{((12, ( (1})) >>> مڠومڤول (((1), (10), (10) (std::vector<long>{(11, ()) مڠومڤول (((0)))))) مڠومڤول (((2), (11)) (5) (std::vector<d::vector<d::vector<d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d\nstd::vector<long> eat(long number, long need, long remaining) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = 0;\n    long left = remaining;\n    long to_eat = need;\n\n    if (left >= to_eat) {\n        eaten = to_eat;\n        left -= to_eat;\n    } else {\n        eaten = left;\n        left = 0;\n    }\n\n    return {(long)number + eaten, left};\n}",
        "test": "}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
    },
    {
        "task_id": "HumanEval/160",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠݢيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤيڠڬيرن ڤڠڬيرن ڤڠڬيرن ڤڠڬيرن ڤڠڬيرن ڤڠڬيرن ڤڠڬيرن ڤڠڬيرن ڤڠڬيرن ڤڠڬيرن ڤڠڠڠڬيرن ڤڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠڠ\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    std::vector<long> current_operand = operand;\n    std::vector<std::string> current_operator = op;\n\n    auto apply_op = [&](long a, long b, const std::string& o) {\n        if (o == \"+\") return a + b;\n        if (o == \"-\") return a - b;\n        if (o == \"*\") return a * b;\n        if (o == \"//\") return a / b;\n        if (o == \"**\") return static_cast<long>(pow(a, b));\n        return 0L; // Should not happen\n    };\n\n    std::vector<std::string> precedence1 = {\"**\"};\n    std::vector<std::string> precedence2 = {\"*\", \"//\"};\n    std::vector<std::string> precedence3 = {\"+\", \"-\"};\n\n    auto evaluate = [&](const std::vector<std::string>& prec) {\n        size_t i = 0;\n        while (i < current_operator.size()) {\n            bool found = false;\n            for (const auto& o : prec) {\n                if (current_operator[i] == o) {\n                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);\n                    current_operand.erase(current_operand.begin() + i + 1);\n                    current_operator.erase(current_operator.begin() + i);\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                i++;\n            }\n        }\n    };\n\n    evaluate(precedence1);\n    evaluate(precedence2);\n    evaluate(precedence3);\n\n    return current_operand[0];\n}",
        "test": "}\nint main() {\n    auto candidate = do_algebra;\n    assert(candidate((std::vector<std::string>({(std::string)\"**\", (std::string)\"*\", (std::string)\"+\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));\n    assert(candidate((std::vector<std::string>({(std::string)\"+\", (std::string)\"*\", (std::string)\"-\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));\n    assert(candidate((std::vector<std::string>({(std::string)\"//\", (std::string)\"*\"})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));\n}\n"
    },
    {
        "task_id": "HumanEval/161",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اڤابيلا س[i] اداله حروف، ڤرلوكن كيسڽ دري تڠه كاو تڠه اتاو ڤد ڤد ڤد ڤد ڤد، جادي تيدق. اڤابيلا س[i] تيدق اد حروف، ڤرلوكن س[i] تڠه. فڠسي بوليه مڽاتاكن س[i]تڠه يڠ دأصلكن. چونتوه >>> solve((\"1234\")) (\"4321\") >>> solve(\"ab\")) (\"AB\") >>> solve(\"#a@C\") (\"#A@c\")\nstd::string solve(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (has_letter) {\n        for (char& c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    } else {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((\"AsDf\")) == (\"aSdF\"));\n    assert(candidate((\"1234\")) == (\"4321\"));\n    assert(candidate((\"ab\")) == (\"AB\"));\n    assert(candidate((\"#a@C\")) == (\"#A@c\"));\n    assert(candidate((\"#AsdfW^45\")) == (\"#aSDFw^45\"));\n    assert(candidate((\"#6@2\")) == (\"2@6#\"));\n    assert(candidate((\"#$a^D\")) == (\"#$A^d\"));\n    assert(candidate((\"#ccc\")) == (\"#CCC\"));\n}\n"
    },
    {
        "task_id": "HumanEval/162",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتاهن ساءينت 'تيكس'، مروڤاكن ساءينت هاش ايمد-٥ ايۏيۏيلنتڽ. اڤابيلا 'تيكس' اداله ساءينت باءيق، مروڤاكن نون. >>> string_to_md5((\"Hello world\")) \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include <optional>\n\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\n\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    std::stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n    return ss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_to_md5;\n    assert(candidate((\"Hello world\")) == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert(candidate((\"\")) == std::nullopt);\n    assert(candidate((\"A B C\")) == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert(candidate((\"password\")) == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n"
    },
    {
        "task_id": "HumanEval/163",
        "nl": "bjn_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ديتاهوي دوا انتيڬر ڤوسيتيف a وان b، مروڤاكن ديڬيت ڤرڤادوان انتارا a وان b، دالم اورد ڤنوه. چونتوهڽ: >>> generate_integers((2), (8)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((8), (2)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((10), (14) (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long start = std::min(a, b);\n    long end = std::max(a, b);\n    for (long i = start; i <= end; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = generate_integers;\n    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((17), (89)) == (std::vector<long>()));\n}\n"
    }
]