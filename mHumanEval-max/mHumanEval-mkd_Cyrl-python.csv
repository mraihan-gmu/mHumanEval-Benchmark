task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,mkd_Cyrl,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Проверете дали во дадена листа на броеви, се некои два броеви поблиску еден до друг од дадениот праг. Пример: >>> има_блиски_елементи (([1.0, 2.0, 3.0], 0.5) Лажна >>> има_блиски_елементи (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) Вистина """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,mkd_Cyrl,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Внесување на оваа функција е низа која содржи повеќе групи на вградени скоби. Вашата цел е да ги одделите тие групи во посебни низи и да ја вратите листата на тие. Одделни групи се балансирани (секое отворено скоби е правилно затворено) и не се вградени еден во друг. Игнорирајте ги сите простори во внесувањето на низата. Пример: >>> separate_paren_groups'(( ) (() (( ) ) ) ) ) ) ['() ', '(()) ', '((()) ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,mkd_Cyrl,python,"

def truncate_number(number: float) -> float:
    """"""Даден позитивен број со плавачка точка, може да се разложи во цело број (најголемиот цело број помал од дадениот број) и децимал (останатиот дел секогаш помал од 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,mkd_Cyrl,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Ви се дава листа на операции за депозити и повлекување на банкарска сметка која започнува со нула баланс. Вашата задача е да откриете дали во било кој момент балансот на сметката паѓа под нула, и во тој момент функцијата треба да врати Вистина. Во спротивно, таа треба да врати Лажна. Пример: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) Вистина """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,mkd_Cyrl,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""За дадена листа на входно бројки, пресметајте Средна апсолутна девијација околу просекот на овој збир на податоци. Средна апсолутна девијација е просечна апсолутна разлика помеѓу секој елемент и централна точка (средна во овој случај): MAD = просечна. x - x_мена. Пример: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,mkd_Cyrl,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Вметнете број ""делиметар"" помеѓу секој два последователни елементи на входното списокот `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,mkd_Cyrl,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Внесување на оваа функција е низа претставува повеќе групи за вградени скоби одделени со простори. За секоја од групата, излез најдлабокиот ниво на вградување на скоби. На пример (() (()) има максимум два нивоа на вградување додека ((())) има три. >>> parse_nested_parens('((()) ((())) () (((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,mkd_Cyrl,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Филтрирајте входна листа на низи само за оние кои содржат даден поднизго >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,mkd_Cyrl,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""За дадена листа на цели броеви, вратете тупел кој се состои од сума и производ на сите цели броеви во листата. Празната сума треба да биде еднаква на 0 и празната производ треба да биде еднаква на 1. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,mkd_Cyrl,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Од дадена листа на цели броеви, генерирајте листа на највисоки елементи кои се наоѓаат до даден момент во низата. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,mkd_Cyrl,python,"

def is_palindrome(string: str) -> bool:
    """"""Најкраткиот палиндром кој започнува со дадена низа. Идејата на алгоритмот е едноставна: - Најдовте најдолгиот постфикс на дадена низа кој е палиндром. - Додадете на крајот на низата обратна страна на префикс на низа кој доаѓа пред палиндромот. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('catac') ' >>> make_palindrome ((('catac') ' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Тестирајте дали дадениот низа е палиндром.""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,mkd_Cyrl,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Внесувањето се два низа а и б кои се состојат само од 1 и 0. Извршете бинарна XOR на овие влезни и враќајте го резултатот исто така како низа. >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,mkd_Cyrl,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Од листата на низи, вратете ја најдолгата. Вратете ја првата во случај на повеќе низи со иста должина. Вратете Ништо во случај на влезната листа да е празна. >>> најдолгиот (([]) >>> најдолгиот ((['a', 'b', 'c']) 'а' >>> најдолгиот ((['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,mkd_Cyrl,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Враќа најголемиот заеднички делувач на два цели броеви a и b >>> најголемиот_ заеднички_ делувач ((3, 5) 1 >>> најголемиот_ заеднички_ делувач ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,mkd_Cyrl,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Враќа листа на сите префикси од најкраток до најдолг од входното низо >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,mkd_Cyrl,python,"

def string_sequence(n: int) -> str:
    """"""Враќа низа која содржи просторно-ограничени броеви почнувајќи од 0 до n вклучително. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,mkd_Cyrl,python,"

def count_distinct_characters(string: str) -> int:
    """"""Дадена низа, дознајте колку различни карактери (без оглед на случајот) се состојат од >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,mkd_Cyrl,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Внесување на оваа функција е низа претставување на музички ноти во посебен ASCII формат. Вашата задача е да се анализира низа листа на цели кои одговараат на многу удари не е. Еве легенда: 'o' нота, последниот победи 'o' ќе ' - половина нота, последниот два победи '- quater нота, последниот еден удар >>> parse_music. 'o' o ' .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,mkd_Cyrl,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Најдете колку пати даден под-нив може да се најде во оригиналниот нив. Бројте ги совпаѓачките случаи. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,mkd_Cyrl,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Внесување е низа од бројки од 'нула' до 'девет'. Валидни избори се 'нула', 'еден', 'два', 'три', 'четири', 'пет', 'шест', 'седум', 'осум' и 'девет'. Враќа низа со броеви сортирани од најмалиот до најголемиот >>> sort_numbers (('три еден пет') 'еден три пет' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,mkd_Cyrl,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Од понудената листа на броеви (од должина најмалку два) изберете и вратете два кои се најблиски еден до друг и вратете ги по ред (помалку број, поголем број). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,mkd_Cyrl,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Дадена листа на броеви (од најмалку два елемента), примени линеарна трансформација на таа листа, така што најмалиот број ќе стане 0 и најголемиот ќе стане 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,mkd_Cyrl,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Филтер даде листа на било кои питонски вредности само за цели броеви >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,mkd_Cyrl,python,"

def strlen(string: str) -> int:
    """"""Враќа должина на даден низа >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,mkd_Cyrl,python,"

def largest_divisor(n: int) -> int:
    """"""За даден број n, најдете го најголемиот број кој го дели n подеднакво, помали од n >>> најголемиот_делител ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,mkd_Cyrl,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Враќа листа на простите фактори на даденото цело число во редослед од најмалиот до најголемиот. Секој од факторите треба да биде наведен број пати кои одговараат на тоа колку пати се појавува во факторизација. Враќање на бројот треба да биде еднаков на производот на сите фактори >>> факторизирај(8) [2, 2, 2] >>> факторизирај(25) [5, 5] >>> факторизирај(70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,mkd_Cyrl,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Од листата со цели броеви, отстранете ги сите елементи кои се појавуваат повеќе од еднаш. Држете го редоследот на елементите оставен ист како во влезот. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,mkd_Cyrl,python,"

def flip_case(string: str) -> str:
    """"""За дадена низа, префрлете мали карактери во големи и големи во мали. >>> flip_case (('Hello') 'HELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,mkd_Cyrl,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Конкатенација на листа на низи во една низа >>> конкатенација (([]) '' >>> конкатенација ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,mkd_Cyrl,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Филтрирајте входна листа на низи само за оние кои почнуваат со даден префикс. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,mkd_Cyrl,python,"

def get_positive(l: list):
    """"""Враќа само позитивни броеви во листата. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,mkd_Cyrl,python,"

def is_prime(n):
    """"""Враќа вистина ако даден број е премиум, и лажна во спротивно. >>> е_прим ((6) Лажна >>> е_прим ((101) Вистина >>> е_прим ((11) Вистина >>> е_прим ((13441) Вистина >>> е_прим ((61) Вистина >>> е_прим ((4) Лажна >>> е_прим ((1) Лажна """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,mkd_Cyrl,python,"import math


def poly(xs: list, x: float):
    """"""find_zero враќа само нула точка, дури и ако има многу. Покрај тоа, find_zero зема само листа xs кои имаат парен број на коефициенти и најголем нула коефициент бидејќи гарантира решение. >>> круг (((find_zero[1, 2]), 2) # f (((x) = 1 + 2x -0.5 >>> круг (((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Оценето на полиномот со коефициенти xs во точка x. враќа xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,mkd_Cyrl,python,"

def sort_third(l: list):
    """"""Оваа функција зема листа l и враќа листа l' така што l' е идентичен со l во индексите кои не се деливи на три, додека нејзините вредности на индексите кои се деливи на три се еднакви на вредностите на соодветните индекси на l, но сортирани. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,mkd_Cyrl,python,"

def unique(l: list):
    """"""Враќа сортирани уникатни елементи во листа >>> уникатен (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,mkd_Cyrl,python,"

def max_element(l: list):
    """"""Враќа максимален елемент во листата. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,mkd_Cyrl,python,"

def fizz_buzz(n: int):
    """"""Враќа бројот на пати кога цифрата 7 се појавува во цели броеви помали од n кои се делнички со 11 или 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,mkd_Cyrl,python,"

def sort_even(l: list):
    """"""Оваа функција зема листа l и враќа листа l' така што l' е идентичен со l во непарните индекси, додека нејзините вредности на паротните индекси се еднакви на вредностите на паротните индекси на l, но сортирани. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,mkd_Cyrl,python,"

def encode_cyclic(s: str):
    """"""го зема како влезен низа кодирана со encode_cyclic функцијата. Враќа декодирана низа. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""враќа кодирана низа по циклусни групи од три знаци. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,mkd_Cyrl,python,"

def prime_fib(n: int):
    """"""prime_fib враќа n-ти број кој е Фибоначи број и исто така е премиер. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,mkd_Cyrl,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero зема листа на цели броеви како влез. Враќа True ако има три различни елементи во листата кои се вкупно нула, и False во спротивно. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,mkd_Cyrl,python,"

def car_race_collision(n: int):
    """"""Замислете си пат кој е совршено права бесконечно долга линија. n автомобили се возат лево кон десно; истовремено, различен сет од n автомобили се возат десно кон лево. Двата сета автомобили започнуваат оддалечени еден од друг. Сите автомобили се движат со иста брзина. За два возила се вели дека се судираат кога автомобил кој се движи лево кон десно се судира со автомобил кој се движи десно кон лево. Сепак, автомобилите се бесконечно цврсти и силни; како резултат, тие продолжуваат да се движат во својата траекторија како да не се судираа. Оваа функција го дава бројот на такви судири.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,mkd_Cyrl,python,"

def incr_list(l: list):
    """"""Враќа листа со елементи зголемени со 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,mkd_Cyrl,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero зема листа на цели броеви како влез. Враќа True ако има два различни елементи во листата кои се вкупно нула, и False во спротивно. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,mkd_Cyrl,python,"

def change_base(x: int, base: int):
    """"""Промени ја нумеричката основа на входниот број x во основа. Враќаат реплика репрезентација по конверзијата. Броевите на базите се помали од 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,mkd_Cyrl,python,"

def triangle_area(a, h):
    """"""Дадена должина на страна и висока повратна површина за триаголник. >>> триаголник_ареа""""""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,mkd_Cyrl,python,"

def fib4(n: int):
    """"""Фиб4 бројната низа е низа слична на низата на Фибоначи која е дефинирана како што следува: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Ве молиме напишете функција за ефикасно пресметување на n-ти елемент од низата на бројните низи на фиб4. Не користете рекурзија. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,mkd_Cyrl,python,"

def median(l: list):
    """"""Враќање на медиана на елементи во листата l. >>> медиана (([3, 1, 2, 4, 5]) 3 >>> медиана (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,mkd_Cyrl,python,"

def is_palindrome(text: str):
    """"""Проверува дали дадениот низа е палиндром >>> е_палиндром (('') Вистина >>> е_палиндром (('aba') Вистина >>> е_палиндром (('aaaaa') Вистина >>> е_палиндром (('zbcd') Лажна """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,mkd_Cyrl,python,"

def modp(n: int, p: int):
    """"""Враќа 2^n модул p (бидете свесни за нумериката). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,mkd_Cyrl,python,"

def encode_shift(s: str):
    """"""го зема како влезен низа кодиран со функцијата encode_shift. Враќа декодиран низа. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""враќа кодирана низа со поместување на секој симбол за 5 во азбуката.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,mkd_Cyrl,python,"

def remove_vowels(text):
    """"""remove_vowels е функција која зема низа и враќа низа без самогласни. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,mkd_Cyrl,python,"

def below_threshold(l: list, t: int):
    """"""Враќа вистина ако сите броеви во листата l се под прагот t. >>> below_threshold (([1, 2, 4, 10], 100) Вистина >>> below_threshold (([1, 20, 4, 10], 5) Лажна """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,mkd_Cyrl,python,"

def add(x: int, y: int):
    """"""Додадете два броја x и y >>> додадете ((2, 3) 5 >>> додадете ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,mkd_Cyrl,python,"

def same_chars(s0: str, s1: str):
    """"""Проверете дали два збора имаат исти карактери. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') Вистина >>> same_chars (('abcd', 'dddddddddabc') Вистина >>> same_chars (('dddddddabc', 'abcd') Вистина >>> same_chars (('eabcd', 'dddddddddabc') Невистина >>> same_chars ((('abcd', 'dddddddabddce') Невистина >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') Невистина """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,mkd_Cyrl,python,"

def fib(n: int):
    """"""Враќа n-ти број на Фибоначи. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,mkd_Cyrl,python,"

def correct_bracketing(brackets: str):
    """"""brackets е низа од ""<"" и "">"". return Верно ако секоја отворачка скоба има соодветна затварачка скоба. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") Вистина >>> correct_bracketing(""<><>>"") Вистина >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,mkd_Cyrl,python,"

def monotonic(l: list):
    """"""Враќа вистина е листички елементи се монотонски зголемува или намалува. >>> монотонски (([1, 2, 4, 20]) Вистина >>> монотонски (([1, 20, 4, 10]) Лажна >>> монотонски (([4, 1, 0, -10]) Вистина """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,mkd_Cyrl,python,"

def common(l1: list, l2: list):
    """"""Враќа сортирани уникатни заеднички елементи за две листи. >>> заеднички (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> заеднички (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,mkd_Cyrl,python,"

def largest_prime_factor(n: int):
    """"""Враќа најголемиот прост фактор на n. Претпоставуваме дека n > 1 и не е прост. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,mkd_Cyrl,python,"

def sum_to_n(n: int):
    """"""sum_to_n е функција која ги збирува броевите од 1 до n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,mkd_Cyrl,python,"

def correct_bracketing(brackets: str):
    """"""brackets е низа од ""("" и "")"". return Верно ако секоја отворачка скоба има соодветна затварачка скоба. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() True >>> correct_bracketing(""""""""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,mkd_Cyrl,python,"

def derivative(xs: list):
    """"""xs претставува коефициенти на полином. xs[0] + xs[1] * x + xs[2] * x^2 + .... Враќа дериват на овој полином во иста форма. >>> дериват (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> дериват[(1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,mkd_Cyrl,python,"

def fibfib(n: int):
    """"""ФИБФИБ бројната низа е низа слична на низата на Фибоначи која е дефинирана како што следува: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).""""""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,mkd_Cyrl,python,"
FIX = """"""Напишете функција vowels_count која зема низа која претставува збор како влез и го враќа бројот на самогласни во низата. Самогласни во овој случај се 'a', 'e', 'i', 'o', 'u'. Овде, 'y' е исто така самогласница, но само кога е на крајот на дадениот збор. Пример: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Додадете повеќе тестови.""""""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,mkd_Cyrl,python,"
def circular_shift(x, shift):
    """"""Кружно поместувајте ги цифрите на целобројниот x, поместувајте ги цифрите десно по поместување и вратете го резултатот како низа. Ако сместување > број на цифри, вратете цифри обратно. >>> кружно_сместување ((12, 1) ""21"" >>> кружно_сместување ((12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,mkd_Cyrl,python,"
def digitSum(s):
    """"""Задача Напишете функција која зема низа како влез и ја враќа сумата на горните карактери само' ASCII кодови. Примери: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,mkd_Cyrl,python,"
def fruit_distribution(s,n):
    """"""Во оваа задача, ќе ви биде дадена низа која претставува број на јаболка и портокали кои се дистрибуирани во кошница со овошје оваа кошница содржи јаболка, портокали и манго плодови. Даден низа која го претставува вкупниот број на портокали и јаболка и целосна бројка која го претставува вкупниот број на плодови во кошница врати бројот на манго плодови во кошница. за пример: fruit_distribution""5(јаболка и 6 портокали"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 јаболка и 1 портокал"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 јаболка и 3 портокали"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 јаболка и 120) "",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,mkd_Cyrl,python,"
def pluck(arr):
    """"""Ако има масив кој претставува гранка на дрво која има не-негативни цели јазли вашата задача е да одземете еден од јазлите и да го вратите. Одземенот јазол треба да биде јазол со најмала парална вредност. Ако се најдат повеќе јазли со иста најмала парална вредност, вратете ја јазол со најмала индекс. Одземенот јазол треба да се врати во листа, [smallest_value, неговиот индекс]. Ако нема парална вредност или даденото низо е празно, вратете []. Пример 1: Внесување: [4,2,3] Изнесување: [2, 1] Објаснување: 2 има најмала парална вредност, а 2 има најмала индекс. Пример 2: Внесување: [1,2,3] Изнесување: [2, 1] Објаснување: 2 има најмала парална вредност, а 2 има најмала парална индекс. Пример 3: Внесување: [] Изнесување: [] Пример 4: [5, 3, 4] Изнесување: [0, 0] Изнесување: 1 јазол со најмала парална вредност, но има две нули.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,mkd_Cyrl,python,"
def search(lst):
    '''Ви е дадена непразна листа на позитивни цели броеви. Враќа најголемиот цело број кој е поголем од нула, и има фреквенција поголема од или еднаква на вредноста на самиот цело број. Фреквенцијата на цело број е бројот на пати кога се појавува во листата. Ако таква вредност не постои, враќа -1.'''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,mkd_Cyrl,python,"
def strange_sort_list(lst):
    '''Дадена листа на цели броеви, враќа листа во чуден редослед. Чудно сортирање, е кога започнувате со минималната вредност, потоа максимум од преостанатите цели броеви, потоа минимум и така натаму. Примери: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,mkd_Cyrl,python,"
def triangle_area(a, b, c):
    '''Дадена е должината на трите страни на триаголник. Враќа површината на триаголник заоблена на 2 децимални точки ако трите страни формираат валиден триаголник. Во спротивно враќа -1 Три страни прават валиден триаголник кога сумата на било кои две страни е поголема од третата страна. Пример: триаголник_ареа (д, д, д) == 6.00 триаголник_ареа (д, д, д) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,mkd_Cyrl,python,"
def will_it_fly(q,w):
    '''Напишете функција која враќа True ако објектот q ќе лета, и False во спротивно. Обект q ќе лета ако е балансиран (ова е палиндромична листа) и сумата на неговите елементи е помала или еднаква на максималната можна тежина w. Пример: will_it_fly (([1, 2], 5) â -> False # 1+2 е помала од максималната можна тежина, но е неравномерна. will_it_fly (([3, 2, 3], 1) â -> False # е балансирана, но 3+2+3 е поголема од максималната можна тежина. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 е помала од максималната можна тежина, и е балансирана. will_it_fly ((([3], â 5) -> True # 3 е помала од максималната можна тежина, и е балансирана. '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,mkd_Cyrl,python,"
def smallest_change(arr):
    """"""Даден низа на цели броеви, најдете минимален број на елементи кои треба да се променат за да се направи низата палиндромична. Палиндромична низа е низа која се чита исто назад и напред. Во една промена, можете да промените еден елемент во било кој друг елемент. На пример: најмала_промена (([1,2,3,5,4,7,9,6]) == 4 најмала_промена (([1, 2, 3, 4, 3, 2, 2]) == 1 најмала_промена (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,mkd_Cyrl,python,"
def total_match(lst1, lst2):
    '''Напишете функција која прифаќа две листи на низи и ја враќа листата која има вкупниот број на знаци во сите низи на листата помалку од другата листа. ако двете листи имаат ист број на знаци, вратете ја првата листа. Примери total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi]) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,mkd_Cyrl,python,"
def is_multiply_prime(a):
    """"""Напишете функција која враќа вистина ако дадениот број е множење на 3 прости броеви и лажни во спротивно.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,mkd_Cyrl,python,"
def is_simple_power(x, n):
    """"""Вашата задача е да напишете функција која враќа вистина ако бројот x е едноставен степен на n и лажна во другите случаи. x е едноставен степен на n ако n**int=x На пример: е_једноставен_силен(1, 4) => вистина е_једноставен_силен(2, 2) => вистина е_једноставен_силен(8, 2) => вистина е_једноставен_силен(3, 2) => лажна е_једноставен_силен(3, 1) лажна => е_једноставен_силен(5, 3) => лажна """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,mkd_Cyrl,python,"
def iscube(a):
    '''Напишете функција која зема цело број a и враќа ВАЖНО ако овој ingeger е куб на некој цело број. Забелешка: можете да претпоставите дека влезот е секогаш валиден. Примери: iscube ((1) ==> Вистински iscube ((2) ==> Лажни iscube ((-1) ==> Вистински iscube ((64) ==> Вистински iscube ((0) ==> Вистински iscube ((180) ==> Лажни '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,mkd_Cyrl,python,"
def hex_key(num):
    """"""Вашата задача е да напишете функција која прима хексадецималниот број како низа и ги брои хексадецималните цифри кои се прости броеви (првичен број, или прост број, е природен број поголем од 1 кој не е производ на два помали природни броеви). Хексадецималните цифри се 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Првите броеви се 2, 3, 5, 7, 11, 13, 17,... Па, треба да се одреди број од следните цифри: 2, 3, 5, 7, B (=децимал 11), D (=децимал 13). Забелешка: можете да претпоставите дека влезот е секогаш исправен или празен низа, а симболите A,B,C,D,E,F се секогаш големи букви. Примери: За num = AB издот треба да биде num = 1. За num = 1077E издот треба да биде 2. За num = ""AB33"" издот треба да биде num = 4.331АББДИ = 4.123АБДИ = 6.06745ЕФИ за издот треба да биде num = 2.2020""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,mkd_Cyrl,python,"
def decimal_to_binary(decimal):
    """"""Ќе ви биде даден број во децимална форма и вашата задача е да го конвертирате во бинарен формат. Функцијата треба да врати низа, со секој симбол кој претставува бинарен број. Секој симбол во низата ќе биде '0' или '1'. Ќе има дополнителен пар на симболи 'db' на почетокот и на крајот на низата.""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,mkd_Cyrl,python,"
def is_happy(s):
    """"""Ви е дадена низа s. Вашата задача е да проверите дали низата е среќна или не. Низа е среќна ако нејзината должина е најмалку 3 и секоја од 3 последователни букви се различни На пример: е_среќна (a) => Лажна е_среќна (a) => Лажна е_среќна (a) => Лажна е_среќна (bcd) => Вистина е_среќна (aabb) => Лажна е_среќна (adb) => Вистина е_среќна (xyy) => Лажна """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,mkd_Cyrl,python,"
def numerical_letter_grade(grades):
    """"""Тоа е последната недела од семестарот и учителот мора да им ги даде оценките на учениците. Учителот го направи својот алгоритам за оценување. Единствениот проблем е што ја изгубил кодот што го користела за оценување. Таа ви даде листа на средни оценки за некои ученици и треба да напишете функција која може да изведе листа на буквени оценки користејќи ја следната табела: GPA.""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,mkd_Cyrl,python,"
def prime_length(string):
    """"""Напишете функција која зема низа и враќа Вистина ако должината на низата е премиум или Лажна во спротивно Примери prime_length (('Hello') == Вистинска премиум_должина (('abcdcba') == Вистинска премиум_должина (('kittens') == Вистинска премиум_должина (('orange') == Лажна """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,mkd_Cyrl,python,"
def starts_one_ends(n):
    """"""Даден позитивен целосен број n, врати го бројот на n-цифрите позитивни целосни броеви кои почнуваат или завршуваат со 1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,mkd_Cyrl,python,"
def solve(N):
    """"""Даден позитивен целосен број N, вратете ја вкупната сума на неговите цифри во бинарна форма. Пример За N = 1000, сумата на цифри ќе биде 1 излезот треба да биде ""1"". За N = 150, сумата на цифри ќе биде 6 излезот треба да биде ""110"". За N = 147, сумата на цифри ќе биде 12 излезот треба да биде ""1100"".""""""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,mkd_Cyrl,python,"
def add(lst):
    """"""Дадена непразна листа на цели броеви, прво додадете ги парните елементи кои се на непарни индекси.""""""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,mkd_Cyrl,python,"
def anti_shuffle(s):
    """"""Напишете функција која зема низа и враќа уредена верзија од неа. Редена верзија на низа, е низа каде сите зборови (одделени со простор) се заменети со нов збор каде сите карактери се распоредени во нарастот на редоследот врз основа на ASCII вредност. Забелешка: Треба да го задржите редоследот на зборовите и празниот простор во реченицата. На пример: anti_shuffle ((('Hi') враќа 'Hi' anti_shuffle ((('hello') враќа 'ehllo' anti_shuffle (('Hello World!!!') враќа 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,mkd_Cyrl,python,"
def get_row(lst, x):
    """"""Дадени се 2 димензионални податоци, како вградени списоци, кои се слични на матрицата, сепак, за разлика од матриците, секој ред може да содржи различен број на колони. Дадени lst и целоброј x, најдете цели броеви x во листата, и вратете листа на tuples, [(x1, y1), (x2, y2) ...] така што секој тупл е координати - (ряд, колони), почнувајќи со 0.""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,mkd_Cyrl,python,"
def sort_array(array):
    """"""Дадена низа од не-негативни цели броеви, вратете копија од даденото низа по сортирање, ќе го сортирате дадениот низа во нарастот ако сумата ((прва индексна вредност, последна индексна вредност) е непарна, или ќе го сортирате во опаѓачки редослед ако сумата ((прва индексна вредност, последна индексна вредност) е парна.""""""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,mkd_Cyrl,python,"
def encrypt(s):
    """"""Создавање на функција encrypt која зема низа како аргумент и враќа низа шифрирана со ротирањето на алфавитот. Алфавитот треба да се ротира на таков начин што буквите се поместуваат надолу помножени за две места. На пример: encrypt('hi') враќа 'lm' encrypt('asdfghjkl') враќа 'ewhjklnop' encrypt('gf') враќа 'kj' encrypt('et') враќа 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,mkd_Cyrl,python,"
def next_smallest(lst):
    """"""Ви е дадена листа со цели броеви. Напишете функција next_smallest (() која го враќа вториот најмали елемент од листата. Враќа Ништо ако нема таков елемент. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == Ништо next_smallest (([1, 1]) == Ништо """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,mkd_Cyrl,python,"
def is_bored(S):
    """"""Ќе ви биде дадена низа зборови, а вашата задача е да го изброите бројот на досадни зборови. Досада е реченица која почнува со зборот ""Ј"". Речениците се дели со '.', '?' или '!'. На пример: >>> е_досадно (а) ""Здраво светот"") 0 >>> е_досадно (а) ""Небото е сино. Сонцето сјае.""""""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,mkd_Cyrl,python,"
def any_int(x, y, z):
    '''Создавање на функција која зема 3 броеви. Враќа вистина ако еден од броевите е еднаков на збирот на другите два, а сите броеви се цели броеви. Враќа лага во сите други случаи. Примери any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,mkd_Cyrl,python,"
def encode(message):
    """"""Напишете функција која зема порака и ја кодира на таков начин што ги менува буквите, ги заменува сите самогласни во пораката со буквата која се појавува 2 места пред таа самогласница во англискиот алфавит.""""""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,mkd_Cyrl,python,"

def skjkasdkd(lst):
    """"""Ви е дадена листа со цели броеви. Треба да ја најдете најголемата простена вредност и да ја вратите сумата од нејзините цифри. Примери: За lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] излазот треба да биде 10 За lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] излазот треба да биде 25 За lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] излазот треба да биде 13 За lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] излазот треба да биде 11 За lst = [0,81,12,31,21] излазот треба да биде 3 За lst = [0,1,8,1,2,1,7] излазот треба да биде """"""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,mkd_Cyrl,python,"
def check_dict_case(dict):
    """"""Ако е даден речник, враќа True ако сите клучеви се низи со мали букви или сите клучеви се низи со големи букви, инаку враќа False. Функцијата треба да врати False ако дадениот речник е празен. Примери: check_dict_case{""a"":""апло"", ""b"":""банана""}) треба да врати True. check_dict_case{""a"":""апло"", ""A"":""банана"", ""B"":""банана""}) треба да врати False. check_dict_case{""a"":""апло"", 8:""банана"", ""a"":""апло""}) треба да врати False. check_dict_case{""име"":""Џон"", ""возраст"":""36"", ""Град"":""Хјустон""}) треба да врати False. check_dict_case{""NC"":""STATE"", ""ZIP"":""45"" }) треба да врати True.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,mkd_Cyrl,python,"
def count_up_to(n):
    """"""Имплементирајте функција која зема не-негативен целокупен број и враќа низа од првите n цели броеви кои се прости броеви и помали од n. На пример: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,mkd_Cyrl,python,"
def multiply(a, b):
    """"""Завршете ја функцијата која зема два цели броеви и го враќа производот на нивните единици. Претпоставуваме дека влезот е секогаш валиден. Примери: множење ((148, 412) треба да врати 16. множење ((19, 28) треба да врати 72. множење ((2020, 1851) треба да врати 0. множење ((14,-15) треба да врати 20. """"""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,mkd_Cyrl,python,"
def count_upper(s):
    """"""Дадена низа s, избројувајте го бројот на големи гласници во парни индекси. На пример: count_upper (('aBCdEf') враќа 1 count_upper (('abcdefg') враќа 0 count_upper (('dBBE') враќа 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,mkd_Cyrl,python,"
def closest_integer(value):
    '''Создавање на функција која зема вредност (нишка) која претставува број и ја враќа најблиската целосна бројка. Ако бројот е еднакво далеку од два цели броеви, закргли го од нула. Примери >>> најблиска_целна бројка ((""10"") 10 >>> најблиска_целна бројка ((""15.3"") 15 Забелешка: Закрглување далеку од нула значи дека ако дадениот број е еднакво далеку од два цели броеви, оној што треба да го вратите е оној што е најдалеку од нула. За пример, најблиската_целна бројка ((""14.5"") треба да врати 15 и најблиската_целна бројка ((-14.5"") треба да врати -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,mkd_Cyrl,python,"
def make_a_pile(n):
    """"""Дадено позитивно цело число n, треба да направите куп од n нивоа на камења. Првото ниво има n камења. Бројот на камења во следното ниво е: - следниот непарен број ако n е непарен. - следниот парен број ако n е парен. Враќате го бројот на камења во секое ниво во листа, каде што елементот на индексот i го претставува бројот на камења во нивото (i+1). Примери: >>> make_a_pile(3) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,mkd_Cyrl,python,"
def words_string(s):
    """"""Ќе ви биде дадена низа од зборови одделени со кома или простори. Вашата задача е да ја поделите низата на зборови и да вратите низа од зборови. На пример: words_string ((""Здраво, моето име е Џон"") == [""Здраво"", ""мојот"", ""име"", ""е"", ""Џон""] words_string ((""Едно, две, три, четири, пет, шест"") == [""Едно"", ""два"", ""три"", ""четири"", ""пет"", ""шест""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,mkd_Cyrl,python,"
def choose_num(x, y):
    """"""Оваа функција зема два позитивни броеви x и y и го враќа најголемиот парен број кој е во опсегот [x, y] вклучително. Ако нема таков број, тогаш функцијата треба да врати -1. На пример: choose_num(12, 15) = 14 choose_num(13, 12) = -1 """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,mkd_Cyrl,python,"
def rounded_avg(n, m):
    """"""Ако n е поголем од m, вратете -1. Пример: округли_авг (авг) 1, 5) => ""0b11"" округли_авг (авг), 7, 5) => -1 округли_авг (авг), 10, 20) => ""0b1111"" округли_авг (авг), 20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,mkd_Cyrl,python,"
def unique_digits(x):
    """"""Дадена листа на позитивни цели броеви x. Враќа сортирана листа на сите елементи кои немаат парата цифра. Забелешка: Вратена листа треба да се сортира во нарастот на редоследот. На пример: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,mkd_Cyrl,python,"
def by_length(arr):
    """"""Даден низа цели броеви, сортирајте ги цели броеви кои се помеѓу 1 и 9 вклучително, превртете го добиениот низа, а потоа замените ја секоја цифра со соодветниот број од ""Еден"", ""Два"", ""Три"", ""Четири"", ""Пет"", ""Шест"", ""Седум"", ""Осум"", ""Девет"". На пример: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> сортирајте arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> обратен arr -> [8, 5, 4, 3, 2, 2, 1, 1] враќање [""Осум"", ""Четири"", ""Три"", ""Два"", ""Два"", ""Еден"", ""Еден""] Ако низата е празна, враќајте низа: arr = [] враќање [] Ако низата има некој странен број, игнорирајте го: arr = [1, 1 , 55] -> сортирајте -> arr - 1 , 55 -> arr - 1 , 55 -> реверс -> arr = [55,1] враќање - 1 ' ' """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,mkd_Cyrl,python,"
def f(n):
    """"""Имплементирајте ја функцијата f која го зема n како параметар и враќа листа со големина n, така што вредноста на елементот на индексот i е факториел на i ако i е парен или сумата на броевите од 1 до i во спротивно. i започнува од 1. факториел на i е множењето на броевите од 1 до i (1 * 2 * ... * i).""""""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,mkd_Cyrl,python,"
def even_odd_palindrome(n):
    """"""Даден позитивен цело број n, врати тупл кој има број на парови и непарни целобројни палиндроми кои се наоѓаат во опсегот ((1, n), вклучително. Пример1: Внесување: 3 Изводот: (1, 2) Објаснување: Цели палиндроми се 1, 2, 3. еден од нив е паров, а двајца од нив се непарни. Пример2: Внесување: 12 Изводот: (4, 6) Објаснување: Цели палиндроми се 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. четири од нив се парови, а 6 од нив се непарни. Забелешка: 1. 1 <= n <= 10^3 2. тупл го врати бројот на парови и непарни целобројни палиндроми соодветно. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,mkd_Cyrl,python,"
def count_nums(arr):
    """"""Напишете функција count_nums која зема низа цели броеви и враќа број на елементи кои имаат сума на цифри > 0. Ако бројот е негативен, тогаш неговата прва потпишана цифра ќе биде негативна: на пример, -123 има потпишани цифри -1, 2 и 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,mkd_Cyrl,python,"
def move_one_ball(arr):
    """"""Имаме масив 'arr' од N цели броеви arr[1], arr[2], ..., arr[N].Броевите во масивот ќе бидат случајно подредени. Вашата задача е да утврдите дали е можно да добиете масив сореден во не-намалување со извршување на следната операција на даден масив: Ви е дозволено да извршите десно поместување операција било кој број на пати. Една десно поместување операција значи поместување на сите елементи на масивот од една позиција во вистинската насока. Последниот елемент на масивот ќе биде преместен во почетната позиција во масивот т.е. 0-ти индекс. Ако е можно да се добие сортиран масив со извршување на горенаведените операции тогаш враќаат Вистина, инаку враќаат Лаж. Ако дадениот масив е празен тогаш враќаат Вистина. Забелешка: Дадената листа е загарантирана да има уникатни елементи. На пример: move_one_(ball[3, 4, 5, 2]===Вистина објаснување: Со перфорација на десно 2 операции, не-намалување може да се постигне за масивот со извршување на било кој број на операции.""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,mkd_Cyrl,python,"
def exchange(lst1, lst2):
    """"""Во овој проблем, ќе имплементирате функција која зема две листи со броеви, и утврдува дали е можно да се изврши размена на елементи меѓу нив за да се направи lst1 листа само со парови броеви. Нема ограничување на бројот на разменети елементи помеѓу lst1 и lst2. Ако е можно да се разменуваат елементи помеѓу lst1 и lst2 за да се направат сите елементи на lst1 парови, врати ""ДА"". Во спротивно, врати ""НЕ"". На пример: размена [1, 2, 3, 4], [1, 2, 3, 4]) => ""ДА"" размена [1, 2, 3, 4], [1, 5, 3, 4]) => ""НЕ"" Се претпоставува дека входните листи ќе бидат непразни. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,mkd_Cyrl,python,"
def histogram(test):
    """"""Ако е дадена низа која претставува мали букви одделени со простор, вратете речник на буквата со најмногу повторувања и со соодветниот број. Ако неколку букви имаат иста појава, вратете ги сите. Пример: хистограма ((('а b c') == {'а': 1, 'b': 1, 'c': 1} хистограма ((('а b b a') == {'а': 2, 'b': 2} хистограма ((('а b c a b') == {'а': 2, 'b': 2} хистограма ((('b b a') == {'b 4}: хистограма (((')) == {} """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,mkd_Cyrl,python,"
def reverse_delete(s,c):
    """"""Задача Имаме два низа s и c, мора да ги избришете сите карактери во s кои се еднакви на било кој симбол во c, а потоа проверете дали резултата е палиндром. Низа се нарекува палиндром ако се чита исто назад како и напред. Треба да вратите тупела која содржи резултата на низата и Вистина/Невистина за проверка. На пример за s = ""abcde"", c = ""ae"", резултатот треба да биде ('bcd',Невистина) За s = ""abcdef"", c = ""b"" резултатот треба да биде ('acdef',Невистина) За s = ""abcdedcba"", c = ""ab"", резултатот треба да биде ('cdedc',Вистина)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,mkd_Cyrl,python,"
def odd_count(lst):
    """"""Дадена листа на низи, каде што секоја низа се состои само од бројки, врати листа. Секој елемент i на излезот треба да биде ""бројот на непарни елементи во низата i на влезот"". каде сите i треба да бидат заменети со бројот на непарни бројки во i'т низа на влезот. >>> odd_count['1234567']) [""бројот на непарни елементи 4n на str4ng 4 на 4nput.""] >>> odd_count['3',""111111""]) [""бројот на непарни елементи 1n на str1ng 1 на 1nput."", ""бројот на непарни елементи 8n на str8ng 8 на 8nput.""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,mkd_Cyrl,python,"
def minSubArraySum(nums):
    """"""Дадена низа од цели броеви n, најдете минимална сума на било кој непразен под-низа од броеви.""""""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,mkd_Cyrl,python,"
def max_fill(grid, capacity):
    import math
    """"""Секоја редица претставува една единица вода. Секој бунар има соодветна кофа која може да се користи за извлекување вода од него, а сите кофа имаат ист капацитет. Вашата задача е да ги користите кофата за да ги испразните бунарите. Извадете го бројот на пати кога треба да ги спуштите кофата. Пример 1: Внесување: редица: [[0,0,1,0], [0,1,0,0], [1,1,1]] bucket_capacity: 1 Изводот: 6 Пример 2: Внесување: редица: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 Изводот: 5 Пример 3: Внесување: [[:0,0,0], [0,0,0]] bucket_capacity: 5 Изводот: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,mkd_Cyrl,python,"
def sort_array(arr):
    """"""Во овој ката, треба да сортирате низа од не-негативни цели броеви според бројот на еднолични во нивната бинарна репрезентација во асенден ред. За сличен број на еднолични, сортирајте врз основа на децималната вредност.""""""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,mkd_Cyrl,python,"
def select_words(s, n):
    """"""Ако сте добиле низа s и природен број n, ви е дадена задача да имплементирате функција која враќа листа на сите зборови од низата s кои содржат точно n согласници, со цел овие зборови да се појават во низата s. Ако низата s е празна, тогаш функцијата треба да врати празна листа. Забелешка: може да претпоставите дека входното низо содржи само букви и простори. Примери: select_words (""Марија имаше мало јагне"", 4) ==> [""малено""] select_words (""Марија имаше мало јагне"", 3) ==> [""Марија"", ""јагне""] select_words ""просто бело простор"", 2) ==> [] select_words (""Здраво свет"", 4) ==> [""свет""] select_words (""Дјадо Сам"", 3) ==> [""Дјадо""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,mkd_Cyrl,python,"
def get_closest_vowel(word):
    """"""Ви е даден збор. Вашата задача е да го најдете најблискиот гласник кој стои помеѓу две согласници од десната страна на зборот (чувствителна за големи и мали букви). Гласниците на почетокот и крајот не се сметаат. Вратете празен синџир ако не сте нашле ниту еден гласник кој ја исполнувал погоре наведената состојба. Може да претпоставите дека дадениот синџир содржи само англиски букви.""""""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,mkd_Cyrl,python,"
def match_parens(lst):
    '''Ви се дадени листа од два низа, и двата низа се состојат од отворени скоби '(' или затворени скоби ') '. Вашата работа е да проверите дали е можно да се поврзат двата низа во некој ред, што резултира со добар низа. Низа S се смета за добра ако и само ако сите скоби во S се балансирани. На пример: низата '((()) ' е добра, додека низата '()) ' не е. Враќате 'Да' ако постои начин да се направи добра низа, и враќате 'Не' во спротивно. Примери: match_parens[('() ', ') ']) == 'Да' match_parens[(') ', ') ']) == 'Не' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,mkd_Cyrl,python,"
def maximum(arr, k):
    """"""Даден низа arr од цели броеви и позитивен цело број k, врати сортирана листа од должина k со максимални k броеви во arr. Пример1: Внесување: arr = [-3, -4, 5], k = 3 Изнесување: [-4, -3, 5] Пример2: Внесување: arr = [4, -4, 4], k = 2 Изнесување: [4, 4] Пример3: Внесување: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Изнесување: [2] Забелешка: 1.""""""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,mkd_Cyrl,python,"
def solution(lst):
    """"""Дадена непразна листа на цели броеви, врати го збирот на сите непарни елементи кои се во парови позиции.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,mkd_Cyrl,python,"
def add_elements(arr, k):
    """"""Даден непразен низа од цели броеви arr и целоброј k, врати го сумата на елементите со најмногу две цифри од првите k елементи на arr. Пример: Внесување: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Изнесување: 24 # сумата од 21 + 3 Ограничувања: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr) """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,mkd_Cyrl,python,"
def get_odd_collatz(n):
    """"""За дадена позитивна цел број n, врати сортирана листа која ги има непарните броеви во колоц секвенца. Колац претпоставка е претпоставка во математиката која се однесува на низа дефинирана како што следува: започнете со било кој позитивен цело број n. Потоа секој термин се добива од претходниот термин како што следува: ако претходниот термин е парен, следниот термин е половина од претходниот термин. Ако претходниот термин е непарен, следниот термин е 3 пати претходниот термин плус 1.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,mkd_Cyrl,python,"
def valid_date(date):
    """"""Треба да напишете функција која ќе го потврди даден низа датум и ќе врати Вистина ако датумот е валиден, во спротивно Лаж. Датата е валидна ако се исполнуваат сите следни правила: 1. низа датум не е празна. 2. бројот на денови не е помалку од 1 или поголем од 31 ден за месеците 1,3,5,7,8,10,12. и бројот на денови не е помалку од 1 или поголем од 30 дена за месеците 4,6,9,11. и бројот на денови не е помалку од 1 или поголем од 29 за месеците 2. 3. месеците не треба да бидат помалку од 1 или поголем од 12. 4. датумот треба да биде во формат: mm-dd-yyyy, на пример: valid_date (('03-11-2000') => True_valid_date (('15-01-2012') => False valid_date (('04-02040') => False_valid_date (('06-04-2020') => True_valid (('06/04/2020') => False""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,mkd_Cyrl,python,"
def split_words(txt):
    '''Ако не постојат запетки, треба да го вратите бројот на букви со мали букви со непарен редослед во алфавитот, ord ((a)) = 0, ord ((b)) = 1, ... ord ((z)) = 25 Примери за поделување на зборовите (((""Здраво светот!"") â -> [""Здраво"", ""светот!""] split_words (((""Здраво, светот!"") â -> [""Здраво"", ""светот!""] split_words (((""Здраво, светот!"") â -> [""Здраво"", ""светот!""] split_words (((""abcdef"") == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,mkd_Cyrl,python,"
def is_sorted(lst):
    '''Ако е дадена листа на броеви, врати дали се сортирани во нарастот на редоследот. Ако листата има повеќе од 1 дупликат на истиот број, врати False. Претпоставувај дека нема негативни броеви и само цели броеви. Примери е_сортиран ((([5]) â -> Вистински е_сортиран (([1, 2, 3, 4, 5]) â -> Вистински е_сортиран (([1, 2, 3, 4, 5, 6]) â -> Лажни е_сортиран (([1, 2, 3, 4, 5, 6, 7]) â -> Вистински е_сортиран (([1, 3, 2, 4, 5, 6, 7]) â -> Лажни е_сортиран (([1, 3, 2, 4, 5, 6, 7]) â -> Лажни е_сортиран (([1, 2, 2, 3, 3, 4]) â -> Вистински е_сортиран (([1, 2, 2, 3, 4 -> Лажни ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,mkd_Cyrl,python,"
def intersection(interval1, interval2):
    """"""На пример, интервалот на интервалите (1, 3), (2, 4) е (2, 3) чија должина е 1, која не е прост број. Ако должината на пресекот е прост број, вратете ""ДА"", во спротивно вратете ""НЕ"". Ако двата интервала не се пресекуваат, вратете ""НЕ"". [input/output] примероци: пресечок (((1, 2), (2, 3) ==> ""пресек ((-1, 1), 4) ==> ""пресек ((0, 4) "" ==> ""НЕ"", 5 ((1), ==> ""Е"", 5 ((5, 3 ((1) ))""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,mkd_Cyrl,python,"
def prod_signs(arr):
    """"""Ви е дадена низа на цели броеви и треба да ја вратите сумата од големините на цели броеви помножени со производот на сите знаци на секој број во низата, претставени со 1, -1 или 0.""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,mkd_Cyrl,python,"
def minPath(grid, k):
    """"""Ако имате решетка со N редови и N колони (N >= 2) и позитивна целосна бројка k, секоја ќелија од решетката содржи вредност. Секој целосен број во опсегот [1, N * N] вклучително се појавува точно еднаш на ќелиите од решетката. Мора да ја најдете минималната патека од должина k во решетката. Можете да започнете од која било ќелија, и во секој чекор можете да се движите кон било која од соседните ќелии, со други зборови, можете да одите до ќелии кои делат работна страна со вашата моментална ќелија. Имајте предвид дека патека од должина k значи посета на точно k ќелии (не мора да бидат различни). НЕ МОЖЕ да одите од решетката. Патот A (од должина k) се смета за помала од пат B (од должина k) ако по правењето на подредени списоци на вредности на ќелиите што поминуваат низ A и B (да ги наречеме l_stA и l_stB), лексикално е помала од l_stA, во други зборови, во решетката можете да ја најдете минималната патека од должина k. Можете да започнете од која било ќелија, и во секој чекор можете да одите до било која од соседните ќелии, со други зборови, со други зборови, можете да одите до ќелии кои делите кои делатна граница ја делатна со вашата се со вашата сегашна клетка.""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,mkd_Cyrl,python,"
def tri(n):
    """"""Сите го знаат Фибоначиевиот редослед, тој е длабоко проучен од страна на математичарите во последните неколку векови. Сепак, она што луѓето не го знаат е Трибоначиевиот редослед. Трибоначиевиот редослед е дефиниран со повторувањето: tri(1) = 3 tri(n) = 1 + n / 2, ако n е парен. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ако n е непарен. На пример: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,mkd_Cyrl,python,"
def digits(n):
    """"""Дадено е позитивен целосен број n, врати го производот на непарните бројки. Врати 0 ако сите бројки се парни. На пример: бројки ((1) == 1 бројки ((4) == 0 бројки ((235) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,mkd_Cyrl,python,"
def is_nested(string):
    '''Функцијата треба да врати ВАЖНО ако и само ако постои валидна поделба на скоби каде најмалку еден скоп во поделбата е вграден. е_вграден '[[]]') â -> Врачен е_вграден '[[]]]]]]]]]]]]]] [[[[[[[]') â -> Лажен е_вграден '[][]') â -> Лажен е_вграден '[]') â -> Лажен е_вграден '[[]') â -> Лажен е_вграден '[[]]') â -> Врачен е_вграден '[[]]]]]]'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,mkd_Cyrl,python,"

def sum_squares(lst):
    """"""Ви е дадена листа на броеви. Треба да ја вратите сумата на квадратните броеви во дадената листа, прво да го округлите секој елемент од листата на горниот int ((Ceiling) Примери: За lst = [1,2,3] излазот треба да биде 14 За lst = [1,4,9] излазот треба да биде 98 За lst = [1,3,5,7] излазот треба да биде 84 За lst = [1.4,4.2,0] излазот треба да биде 29 За lst = [-2.4,1,1] излазот треба да биде 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,mkd_Cyrl,python,"
def check_if_last_char_is_a_letter(txt):
    '''Создавање на функција која враќа ВАЖНО ако последниот карактер на даден низа е алфабетски карактер и не е дел од збор, и ВАЖНО во спротивно. Забелешка: ""реч"" е група на карактери одделени со простор. Примери: check_if_last_char_is_a_letter ((""јаблочна питка"") â -> False check_if_last_char_is_a_letter (((""јаблочна пие"") â -> ВАЖНО check_if_last_char_is_a_letter (((""јаблочна пие"") â -> ВАЖНО check_if_last_char_is_a_letter "" ((("") â -> ВАЖНО '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,mkd_Cyrl,python,"
def can_arrange(arr):
    """"""Создавање на функција која ќе го врати најголемиот индекс на елемент кој не е поголем од или еднаков на елементот веднаш пред него. Ако не постои таков елемент тогаш враќа -1.""""""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,mkd_Cyrl,python,"
def largest_smallest_integers(lst):
    '''Создадете функција која враќа тупл (а, б), каде што 'а' е најголемиот од негативните цели броеви, а 'б' е најмалиот од позитивните цели броеви во листата. Ако нема негативни или позитивни цели броеви, вратете ги како Ништо. Примери: најголеми_најмалите_цели броеви[2, 4, 1, 3, 5, 7]) == (Ништо, 1) најголеми_најмалите_цели броеви([]) == (Ништо, Ништо) најголеми_најмалите_цели броеви[0]) == (Ништо, Ништо) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,mkd_Cyrl,python,"
def compare_one(a, b):
    """"""Создавање на функција која зема цели броеви, плови или низи кои претставуваат реални броеви, и ја враќа поголемата променлива во нејзиниот даден тип на променлива. Враќа Ништо ако вредностите се еднакви. Забелешка: Ако реално число е претставено како низа, плавачката точка може да биде . или , compare_one{1, 2.5) â -> 2.5 compare_one{1, ""2,3"") â -> ""2,3"" compare_one{5,1"", ""6"") â -> ""6"" compare_one{1"", 1) â -> Ништо """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,mkd_Cyrl,python,"
def is_equal_to_sum_even(n):
    """"""Оценете дали дадениот број n може да се напише како збир на точно 4 позитивни парови броеви Пример е_еднаков_на_сумата_парата ((4) == Лажен е_еднаков_на_сумата_парата ((6) == Лажен е_еднаков_на_сумата_парата ((8) == Вистински """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,mkd_Cyrl,python,"
def special_factorial(n):
    """"""Бразилскиот факториел е дефиниран како: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! каде n > 0 На пример: >>> special_factorial ((4) 288 Функцијата ќе добие цело број како влез и треба да го врати специјалниот факториел на овој цело број. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,mkd_Cyrl,python,"
def fix_spaces(text):
    """"""_Пример-3из, заменете ги сите простори со потценки, а ако низата има повеќе од 2 последователни простори, тогаш заменете ги сите последователни простори со - fix_spaces ((""Пример"") == ""Пример"" fix_spaces ((""Пример1"") == ""Пример_1"" fix_spaces (((""Пример2"") == ""_Пример_2"" fix_spaces ((""Пример 3"") == ""_Пример-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,mkd_Cyrl,python,"
def file_name_check(file_name):
    """"""Создавање на функција која зема низа која претставува име на датотека, и враќа ""Да"" ако името на датотеката е валидно, и враќа ""Не"" во спротивно. Името на датотека се смета за валидно ако и само ако се исполнат сите следни услови: - Не треба да има повеќе од три цифри ('0'-'9') во името на датотеката. - Името на датотеката содржи точно една точка '.' - Поднизата пред точка не треба да биде празна, и започнува со буква од латинската алфа ('a'-'z' и 'A'Z'). - Поднизата по точка треба да биде една од овие: ['txt', 'exe', 'll'd'] Примери: file_name_check""(example.txt"") # => 'Да' file_name_check""(example.dll1"") => 'Не' (името треба да започне со латинска алфа) # => 'Не' (името треба да започне со латинска алфа)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,mkd_Cyrl,python,"


def sum_squares(lst):
    """""""" Оваа функција ќе земе листа на цели броеви. За сите записи во листата, функцијата ќе го квадрира внесувањето на целобројниот број ако неговиот индекс е множествен од 3 и ќе го кубикува внесувањето на целобројниот број ако неговиот индекс е множествен од 4 и не множествен од 3. Функцијата нема да ги менува внесувањата во листата чии индекси не се множествен од 3 или 4. Функцијата потоа ќе ја врати сумата на сите внесувања. Примери: За lst = [1,2,3] излезот треба да биде 6 За lst = [] излезот треба да биде 0 За lst = [-1,-5,2,-1,-5] излезот треба да биде -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,mkd_Cyrl,python,"
def words_in_sentence(sentence):
    """"""Ви е дадена низа која претставува реченица, реченицата содржи некои зборови одделени со простор, и треба да вратите низа која ги содржи зборовите од оригиналната реченица, чија должина се прости броеви, редоследот на зборовите во новата низа треба да биде ист како оригиналната. Пример1: Внесување: реченица = ""Ова е тест"" Изнесување: ""е"" Пример2: Внесување: реченица = ""да одиме за пливање"" Изнесување: ""да одиме за"" Ограничувања: * 1 <= len(реченица) <= 100 * реченицата содржи само букви """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,mkd_Cyrl,python,"
def simplify(x, n):
    """"""Вашата задача е да имплементирате функција која ќе го поедностави изразот x * n. Функцијата враќа ВАЖНО ако x * n се оценува на цело број и Фалшиво во спротивно. И x и n се реплицирана репрезентација на фракција и имаат следниот формат, < броец>/< именувач> каде и броецот и именувачот се позитивни цели броеви. Можете да претпоставите дека x и n се валидни фракции и немаат нула како именувач.""""""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,mkd_Cyrl,python,"
def order_by_points(nums):
    """"""Напишете функција која ја сортира дадената листа на цели броеви во возрасен редослед според збирот на нивните цифри.""""""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,mkd_Cyrl,python,"
def specialFilter(nums):
    """"""Напишете функција која зема низа на броеви како влез и го враќа бројот на елементи во низата кои се поголеми од 10 и двете први и последни цифри на еден број се непарни (1, 3, 5, 7, 9). На пример: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,mkd_Cyrl,python,"
def get_max_triples(n):
    """"""Ви е даден позитивен цело број n. Треба да создадете целоброен низа a со должина n. За секоја i (1 ‰¤ i ‰¤ n), вредноста на a[i] = i * i - i + 1. Враќате го бројот на тројки (a[i], a[j], a[k]) од a каде i < j < k, а a[i] + a[j] + a[k] е кратен број на 3. Пример: Внесување: n = 5 Изнесување: 1 Објаснување: a = [1, 3, 7, 13, 21] Единствениот валиден тројка е (1, 7, 13). """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,mkd_Cyrl,python,"
def bf(planet1, planet2):
    '''Во нашиот Сончев систем има осум планети: најблиската до Сонцето е Меркури, следната е Венера, потоа Земјата, Марс, Јупитер, Сатурн, Уран, Нептун. Напишете функција која зема два имиња на планетите како низи планета1 и планета2. Функцијата треба да врати тупела која ги содржи сите планети чии орбити се наоѓаат помеѓу орбитата на планета1 и орбитата на планета2, сортирани според близината до Сонцето. Функцијата треба да врати празна тупела ако планета1 или планета2 не се точни имиња на планетите. Примери bf ""(Јупитер"", ""Нептун"") ==> (""Сатурн"", ""Уран"") bf (((""Земја"", ""Меркури"") ==> (""Венера"") bf (""Меркури"", ""Уран"") ==> (""Венера"", ""Земја"", ""Марс"", ""Јупитер"", ""Сн"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,mkd_Cyrl,python,"
def sorted_list_sum(lst):
    """"""Напишете функција која прифаќа листа на низи како параметар, ги брише низите кои имаат непарни должини од неа, и ја враќа резултираната листа со сортиран редослед. Листата е секогаш листа на низи и никогаш низа на броеви, и може да содржи дупликати. Редовноста на листата треба да биде асензивна по должина на секој збор, и треба да ја вратите листата сортирана според тоа правило. Ако два збора имаат иста должина, сортирајте ја листата по алфавит. Функцијата треба да врати листа на низи во сортиран редослед. Може да претпоставите дека сите зборови ќе имаат иста должина. На пример: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => ""cd ""]""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,mkd_Cyrl,python,"
def x_or_y(n, x, y):
    """"""Едноставна програма која треба да ја врати вредноста на x ако n е премиум број и треба да ја врати вредноста на y во спротивно.""""""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,mkd_Cyrl,python,"
def double_the_difference(lst):
    '''Дадена листа на броеви, вратете ја сумата на квадратите на броевите во листата кои се непарни. Игнорирајте ги броевите кои се негативни или не се цели. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Ако входното е празно, вратете 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,mkd_Cyrl,python,"
def compare(game,guess):
    """"""Мислам дека сите го памтиме тоа чувство кога конечно ќе се знае резултатот од некој долго очекуван настан. Чувствата и мислите што ги имате во тој момент дефинитивно вредат да се забележат и споредат. Вашата задача е да се утврди дали една личност правилно ги погодила резултатите од голем број натпревари. Ви се дадени две масиви со резултати и претпоставки од еднаква должина, каде секој индекс покажува натпревар. Вратете масива од иста должина која означува колку далеку е секој претпоставка. Ако тие го погодиле правилно, вредноста е 0, а ако не, вредноста е апсолутната разлика помеѓу претпоставката и резултатот.""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,mkd_Cyrl,python,"
def Strongest_Extension(class_name, extensions):
    """"""Ќе ви биде дадено име на класа (нишка) и листа на екстензии. Екстензиите треба да се користат за да се внесуваат дополнителни класи во класата. Силата на екстензијата е следнава: Нека CAP биде бројот на големите букви во името на екстензијата, и нека SM биде бројот на малите букви во името на екстензијата, силата е дадена со фракцијата CAP - SM. Треба да го најдете најсилниот екстензион и да вратите нишка во овој формат: ClassName.StrongestExtensionName. Ако има два или повеќе екстензии со иста сила, треба да го изберете оној кој е прв на листата. На пример, ако ви е дадена ""Slices"" како класа и листа на екстензии: ['SEviRNGSliCes', 'Cheese', 'StuFfed'], тогаш треба да вратите 'Slices.SEviRNGSliCes' бидејќи 'SviRNGSliCes' е најсилниот екстензион (на пример: 'AA_Beats' е најсилниот', 'AA_class' е најсилниот екстензист).""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,mkd_Cyrl,python,"
def cycpattern_check(a , b):
    """"""Ви се дадени 2 зборови. Треба да вратите Вистина ако вториот збор или било која од неговите ротации е поднишка во првиот збор cycpattern_check (((""abcd"",""abd"") => Лажна cycpattern_check (((""здраво"",""ell"") => Вистина cycpattern_check (((""whassup"",""psus"") => Лажна cycpattern_check (((""abab"",""baa"") => Вистина cycpattern_check (((""efef"",""eeff"") => Лажна cycpattern_check (((hims"",""simen"") => Вистина """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,mkd_Cyrl,python,"
def even_odd_count(num):
    """"""Дадено цело число. Враќа тупела која има број на парови и непарни цифри соодветно. Пример: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,mkd_Cyrl,python,"
def int_to_mini_roman(number):
    """"""Даден позитивен целосен број, добијте го неговиот римски бројски еквивалент како низа и вратете го во мали букви.""""""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,mkd_Cyrl,python,"
def right_angle_triangle(a, b, c):
    '''Дадена должината на трите страни на триаголник. Враќа ВАЖНО ако трите страни формираат правоаголен триаголник, ВАЖНО во спротивно. Правоаголен триаголник е триаголник во кој еден агол е правоаголник или 90 степени. Пример: right_angle_triangle ((3, 4, 5) == Вистински правоаголник_триаголник ((1, 2, 3) == ВАЖНО '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,mkd_Cyrl,python,"
def find_max(words):
    """"""Напишете функција која прифаќа листа на низи. Листата содржи различни зборови. Враќа збор со максимален број на уникатни карактери. Ако повеќе низи имаат максимален број на уникатни карактери, вратете го оној кој доаѓа прв во лексикографски редослед.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,mkd_Cyrl,python,"
def eat(number, need, remaining):
    """"""Вие сте гладен зајак, и веќе сте јаделе одреден број моркови, но сега треба да јадете повеќе моркови за да ги завршите дневните оброци. треба да вратите низа од [ вкупниот број на јаделе моркови по оброците, бројот на моркови останаа по оброците ] ако нема доволно преостанати моркови, ќе ги изедат сите преостанати моркови, но сепак ќе биде гладен. Пример: * јаде ((5, 6, 10) -> [11, 4] * јаде ((4, 8, 9) -> [12, 1] * јаде ((1, 10, 10) -> [11, 0] * јаде ((2, 11, 5) -> [7, 0] променливи: @ број: целосен број на моркови кои сте ги јаделе. @ потреба: целосен број на моркови кои треба да се јаде. @ остатокот: целосен број на преостанати моркови во залихите: * ограничување: * број = 0 <= 0 * број = 1000 <= 0 * остатокот = 1000 <= 1000""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,mkd_Cyrl,python,"
def do_algebra(operator, operand):
    """"""Дадени две списоци оператор, и операнда. Првата листа има основни алгебарски операции, а втората листа е листа на цели броеви. Користете ги двете дадени листи за да го изградите алгебарскиот израз и да ја вратите оценката на овој израз. Основните алгебарски операции: Додавање ( +) Одземање ( -) Мултипликација ( *) Поделување ( //) Поделување ( ** Пример) Оператор['+', '*', '-'] масив = [2, 3, 4, 5] резултат = 2 + 3 * 4 - 5 => резултат = 9 Забелешка: Должината на листата на оператори е еднаква на должината на операнда листа минус еден. Операнда е листа на не-негативни цели броеви. Оператор има најмалку една листа на оператори, а операнда листа има најмалку два операнда. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,mkd_Cyrl,python,"
def solve(s):
    """"""Ако s[i] е буквата, превратајте ја неговата големина од долна кон горна или обратно, во спротивно оставете ја како што е. Ако низата не содржи букви, превратајте ја низата. Функцијата треба да го врати резултираниот низа. Примери solve(""1234"") = ""4321"" solve(""ab"") = ""AB"" solve(""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,mkd_Cyrl,python,"
def string_to_md5(text):
    """"""Ако е дадена низа 'текст', врати ја неговата md5 хеш еквивалентна низа. Ако 'текст' е празна низа, врати Ништо. >>> string_to_md5('Здраво светот') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,mkd_Cyrl,python,"
def generate_integers(a, b):
    """"""Дадени два позитивни цели броеви а и б, вратете ги паратните цифри помеѓу а и б, во порастот. На пример: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
