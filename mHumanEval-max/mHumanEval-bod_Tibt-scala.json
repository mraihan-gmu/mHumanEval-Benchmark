[{"task_id":"HumanEval_0","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཚད་གཞི་གཏན་འབེབས་བྱས་ཡོད།    \/\/ཤོག་གྲངས་གྲངས་གྲངས་སུ་ ཇི་འདྲ་གཉིས་རེ་ ཇི་འདྲ་གཉིས་ལས་ཉེ་བར་ཡོད་མེད་བརྟག་དཔྱད་བྱེད་རོགས།    \/\/ >>> hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)), (0.5f))\n    \/\/ (false)\n    \/\/ >>> hasCloseElements((List[Float](1.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))\n    \/\/ (true)\n    def hasCloseElements(numbers : List[Float], threshold : Float) : Boolean = {\n","canonical_solution":"def hasCloseElements(numbers: List[Float], threshold: Float): Boolean = {\n      val sortedNumbers = numbers.sorted\n      for (i <- 1 until sortedNumbers.length) {\n        if (abs(sortedNumbers(i) - sortedNumbers(i - 1)) < threshold) {\n          return true\n        }\n      }\n      false\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.3f)) == (true));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.05f)) == (false));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.95f)) == (true));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.8f)) == (false));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.1f)) == (true));\n    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (1.0f)) == (true));\n    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (0.5f)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_1","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ནང་འཇུག་ཐིག་ནང་ཡོད་པའི་བར་སྟོང་ལ་དོ་སྣང་མ་བྱེད།    \/\/སྡེ་ཚན་སོ་སོར་ཆ་སྙོམ་ (སྒོ་ཕྱེས་པའི་རྒྱབ་ལག་རེ་རེ་བཞིན་ལེགས་པར་རྒྱབ་) བྱས་ཡོད་པ་དང་ཕན་ཚུན་དབར་སྦྲེལ་མེད་པ།    \/\/ཚོ་ཚོ་ཁག་སོ་སོར་དབྱེ་ནས་ ཚོ་ཁག་གི་ཐོ་ཡིག་ཕྱིར་ལོག་བྱེད་པ།    \/\/ལས་འགན་འདི་ནང་ནང་འཇུག་བྱེད་དེ་ སྦྲེལ་ཡོད་པའི་སྒམ་ཚིགས་ཀྱི་སྡེ་ཚན་མང་པོ་བསྡུས་པའི་ཐིག་ཡིག་ཡིན། ཁྱོད་ཀྱི་དམིགས་ཡུལ་ནི་     \/\/ >>> separateParenGroups((\"( ) (( )) (( )( ))\"))\n    \/\/ (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string : String) : List[String] = {\n","canonical_solution":"def separateParenGroups(paren_string: String): List[String] = {\n    val result = ListBuffer[String]()\n    val sanitizedInput = paren_string.replaceAll(\"\\\\s\", \"\")\n    var balance = 0\n    var currentGroup = new StringBuilder()\n\n    for (char <- sanitizedInput) {\n        currentGroup.append(char)\n        if (char == '(') balance += 1\n        else if (char == ')') balance -= 1\n\n        if (balance == 0 && currentGroup.nonEmpty) {\n            result += currentGroup.toString()\n            currentGroup = new StringBuilder()\n        }\n    }\n\n    result.toList\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_2","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/གྲངས་ཀའི་བཅུ་ཆ་ཕྱིར་ལོག་བྱེད།    \/\/(ལྷག་ལུས་ཆ་ཤས་ནི་ 1 ལས་ཆུང་བ་རེད།)    \/\/གྲངས་ཆ་ཧྲིལ་པོ་ (གྲངས་ཆ་ཆེ་ཤོས་ནི་གྲངས་ཆ་ཉུང་བ་ལས་ཆུང་བ་) བཅུ་ཚིགས་ཀྱི་གྲངས་ཆ་     \/\/ཤོག་གྲངས་ལྡོག་པའི་ཐིག་ཁྲམ་ནང་ ཤོག་གྲངས་ལྡོག་པའི་ཐིག་ཁྲམ་ནང་     \/\/ >>> truncateNumber((3.5f))\n    \/\/ (0.5f)\n    def truncateNumber(number : Float) : Float = {\n","canonical_solution":"val integerPart = number.floor\n        val decimalPart = number - integerPart\n        decimalPart.toFloat\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"},{"task_id":"HumanEval_3","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཚད་འདི་ནས་ function དེ་ true སླར་ལོག་བྱེད་དགོས། དེ་མིན་ false སླར་ལོག་བྱེད་དགོས།    \/\/ཤོག་ངོས་འདི་ཡི་བཟོ་བཅོས་མཐའ་མ་༢༩ ལ་མཐའ་འབྲས་ཀྱི་འགྲེལ་བརྗོད་བྱས་འདུག    \/\/ཤོག་ངོས་འདི་ནང་ \"གླ་དངུལ་དང་དངུལ་ཁུག་གི་ལས་འགུལ་གྱི་ཐོ་ཡིག་\" ཟེར་བའི་ཡི་གེ་ཡོད་པ་རེད།    \/\/ >>> belowZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (false)\n    \/\/ >>> belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong)))\n    \/\/ (true)\n    def belowZero(operations : List[Long]) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def belowZero(operations: List[Long]): Boolean = {\n    var balance: Long = 0\n    for (operation <- operations) {\n      balance += operation\n      if (balance < 0) {\n        return true\n      }\n    }\n    false\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(belowZero(List(1L, 2L, 3L)))         \/\/ false\n    println(belowZero(List(1L, 2L, -4L, 5L)))    \/\/ true\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(belowZero((List[Long]())) == (false));\n    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -3l.toLong, 1l.toLong, 2l.toLong, -3l.toLong))) == (false));\n    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong))) == (true));\n    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (false));\n    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -5l.toLong))) == (true));\n    assert(belowZero((List[Long](1l.toLong, -2l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_4","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/MAD = average ཟེར་བ་ཡིན། x - x_mean ཟེར་བ་ཡིན།    \/\/ཚད་གཞི་དང་བར་གྱི་ཆ་ཤས་ (གནས་འདི་ནང་གི་བར་གྱི་ཆ་ཤས་) དང་།    \/\/ཚད་ལྡན་བར་ཁྱད་པར་གྱི་བར་ཁྱད་པར་གྱི་ཚད་ནི་ ཚད་ལྡན་བར་ཁྱད་པར་གྱི་ཚད་ཡིན།    \/\/ཚད་གཞི་འདི་ནང་གི་བར་མའི་གྲངས་ ཀྱི་ཉེ་འཁོར་དུ་ཡོད།    \/\/ནང་འཇུག་གྲངས་ཀྱི་ཐོ་ཡིག་ཤིག་ཡོད་ན། ཚད་གཏན་ནས་མི་འདྲ་བའི་ཚད་གཞི་རྩིས་དགོས།    \/\/ >>> meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat)))\n    \/\/ (1.0f)\n    def meanAbsoluteDeviation(numbers : List[Float]) : Float = {\n","canonical_solution":"val mean = numbers.sum \/ numbers.size\n    val deviations = numbers.map(num => math.abs(num - mean))\n    val mad = deviations.sum \/ deviations.size\n    mad\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat))) == (0.5f));\n    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))) == (1.0f));\n    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))) == (1.2f));\n    }\n\n}\n"},{"task_id":"HumanEval_5","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ནང་འཇུག་གི་ཐོ་ཡིག་ནང་ཐིག་གཉིས་རེ་རེའི་བར་ལ་ \"delimeter\" ཀྱི་གྲངས་ཀ་ཞིག་བཅུག་དགོས།    \/\/ >>> intersperse((List[Long]()), (4l))\n    \/\/ (List[Long]())\n    \/\/ >>> intersperse((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (4l))\n    \/\/ (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))\n    def intersperse(numbers : List[Long], delimeter : Long) : List[Long] = {\n","canonical_solution":"if (numbers.isEmpty) {\n        List()\n      } else {\n        numbers.init.flatMap(n => List(n, delimeter)) :+ numbers.last\n      }\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_6","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན། (() (()) ནི་ཚང་གི་ཚད་གཉིས་ལས་མང་བ་མེད་ལ། ((())) ནི་ཚང་གི་ཚད་གསུམ་ལས་མང་བ་མེད་ལ།    \/\/སྡེ་ཚན་རེ་རེའི་ཆེད་དུ་ཚིགས་སུ་བསྡུར་བའི་ཚད་མཐོའི་ཚད་གཞི་ཕྱིར་འདོན་བྱ་དགོས།    \/\/ལས་འགན་འདི་ནང་ནང་འཇུག་བྱེད་པ་དེ་ནི་ སྦྲེལ་ཡོད་པའི་སྒམ་ཚིགས་ཀྱི་ཆེད་དུ་སྡེ་ཚན་མང་པོ་བཞིན་པའི་ string ཞིག་ཡིན།    \/\/ >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    \/\/ (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def parseNestedParens(paren_string: String): List[Long] = {\n    paren_string.split(\" \").toList.map { group =>\n      var maxDepth = 0\n      var currentDepth = 0\n      group.foreach {\n        case '(' => \n          currentDepth += 1\n          maxDepth = max(maxDepth, currentDepth)\n        case ')' => \n          currentDepth -= 1\n      }\n      maxDepth.toLong\n    }\n  }\n\n  \/\/ Example usage\n  def main(args: Array[String]): Unit = {\n    val result = parseNestedParens(\"(()()) ((())) () ((())()())\")\n    println(s\"Result: ${result.mkString(\", \")}\")\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_7","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ནང་འཇུག་གི་ཡིག་འབྲུ་ཐོ་ཡིག་ནང་ཡིག་འབྲུ་ཆུང་བ་ཡོད་ན་རྐྱང་པ་ར་སེལ་འཐུ་འབད།    \/\/ >>> filterBySubstring((List[String]()), (\"a\"))\n    \/\/ (List[String]())\n    \/\/ >>> filterBySubstring((List[String](\"abc\", \"bacd\", \"cde\", \"array\")), (\"a\"))\n    \/\/ (List[String](\"abc\", \"bacd\", \"array\"))\n    def filterBySubstring(strings : List[String], substring : String) : List[String] = {\n","canonical_solution":"strings.filter(_.contains(substring))\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(filterBySubstring((List[String]()), (\"john\")).equals((List[String]())));\n    assert(filterBySubstring((List[String](\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xxx\")).equals((List[String](\"xxx\", \"xxxAAA\", \"xxx\"))));\n    assert(filterBySubstring((List[String](\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xx\")).equals((List[String](\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"))));\n    assert(filterBySubstring((List[String](\"grunt\", \"trumpet\", \"prune\", \"gruesome\")), (\"run\")).equals((List[String](\"grunt\", \"prune\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_8","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/སྟོང་པའི་བསྡོམས་ནི་ 0 དང་སྟོང་པའི་ཐོན་རིམ་ནི་ 1 འདྲ་མཉམ་དགོས་པ་ཡིན།    \/\/གྲངས་ཀྱི་ཐོ་ཡིག་གང་ཞིག་ལ་གྲངས་ཚང་གི་གྲངས་ཚུའི་བསྡོམས་དང་འབྲས་བུ་ལས་གྲུབ་པའི་གྲངས་ཚུའི་ཐིག་ཁྲམ་ཞིག་ཕྱིར་ལོག་བྱེད་པ།    \/\/ >>> sumProduct((List[Long]()))\n    \/\/ ((0l, 1l))\n    \/\/ >>> sumProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ ((10l, 24l))\n    def sumProduct(numbers : List[Long]) : Tuple2[Long, Long] = {\n","canonical_solution":"def sumProduct(numbers: List[Long]): (Long, Long) = {\n        val sum = numbers.sum\n        val product = numbers.foldLeft(1L)(_ * _)\n        (sum, product)\n    }\n\n    def main(args: Array[String]): Unit = {\n        \/\/ Test examples\n        println(sumProduct(List[Long]())) \/\/ (0L, 1L)\n        println(sumProduct(List[Long](1L, 2L, 3L, 4L))) \/\/ (10L, 24L)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sumProduct((List[Long]())).equals(((0l, 1l))));\n    assert(sumProduct((List[Long](1l.toLong, 1l.toLong, 1l.toLong))).equals(((3l, 1l))));\n    assert(sumProduct((List[Long](100l.toLong, 0l.toLong))).equals(((100l, 0l))));\n    assert(sumProduct((List[Long](3l.toLong, 5l.toLong, 7l.toLong))).equals(((15l, 105l))));\n    assert(sumProduct((List[Long](10l.toLong))).equals(((10l, 10l))));\n    }\n\n}\n"},{"task_id":"HumanEval_9","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/རིམ་བཞིན་    \/\/གྲངས་ཚང་གི་ཐོ་ཡིག་ནས་ ཇི་ཡོད་དུས་ཡུན་བར་ཐོབ་པའི་ ཚད་མཐོའི་ཆ་ཤས་ཀྱི་ཐོ་ཡིག་ཞིག་བསྐྲུན་དགོས།    \/\/ >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def rollingMax(numbers: List[Long]): List[Long] = {\n        var maxSoFar = Long.MinValue\n        numbers.map { num =>\n            maxSoFar = max(maxSoFar, num)\n            maxSoFar\n        }\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_10","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/- string reverse གི་མཇུག་ཏུ་ palindromic suffix གི་སྔོན་དུ་ string prefix ཞིག་སྣོན་དགོས།    \/\/- ཇི་འདྲ་ཡིན་ན་ palindrome ཡོད་པའི་ string གི་ postfix ཡི་རིང་ཤོས་འཚོལ་དགོས།    \/\/ཚད་འཛིན་གྱི་བསམ་ཚུལ་ནི་དྭངས་མ་ཡིན།    \/\/ཚད་ལྡན་ཡིག་འབྲུ་ནང་འཇུག་པའི་སྔོན་རྟགས་ཆུང་ཤོས་འཚོལ་དགོས།    \/\/ >>> makePalindrome((\"\"))\n    \/\/ (\"\")\n    \/\/ >>> makePalindrome((\"cat\"))\n    \/\/ (\"catac\")\n    \/\/ >>> makePalindrome((\"cata\"))\n    \/\/ (\"catac\")\n    def makePalindrome(string : String) : String = {\n","canonical_solution":"def makePalindrome(string: String): String = {\n    \/\/ Helper function to check if a string is a palindrome\n    def isPalindrome(s: String): Boolean = s == s.reverse\n\n    \/\/ Find the longest palindromic suffix\n    var endIndex = string.length\n    while (endIndex > 0 && !isPalindrome(string.substring(endIndex - 1))) {\n      endIndex -= 1\n    }\n\n    \/\/ Extract the non-palindromic prefix\n    val prefix = string.substring(0, endIndex - 1)\n\n    \/\/ Append the reverse of the prefix to form the shortest palindrome\n    string + prefix.reverse\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"},{"task_id":"HumanEval_11","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཌའི་ལོག་ནང་ binary XOR བྱེད་ནས་འབྲས་བུ་ཡང་ string གྱི་ཚུལ་དུ་ཕྱིར་ལོག་བྱེད་པ།    \/\/ནང་འཇུག་ནི་ a དང་ b གཉིས་ནི་ 1 དང་ 0 ཙམ་ལས་གྲུབ་པའི་ཡིག་འབྲུ་གཉིས་ཡིན།    \/\/ >>> stringXor((\"010\"), (\"110\"))\n    \/\/ (\"100\")\n    def stringXor(a : String, b : String) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def stringXor(a: String, b: String): String = {\n    (a zip b).map { case (charA, charB) => \n      if (charA == charB) '0' else '1'\n    }.mkString\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"},{"task_id":"HumanEval_12","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ནང་འཇུག་ཐོ་ཡིག་སྟོང་པ་ཡོད་ན་ None སླར་ལོག་བྱེད།    \/\/string གྱི་ཐོ་ཡིག་ལས་ string གྱི་རིང་ཤོས་ཕྱིར་ལོག་བྱེད། ཇི་ཡོད་ཆ་ནས་སྔོན་ལ་ཕྱིར་ལོག་བྱེད།    \/\/ >>> longest((List[String]()))\n    \/\/ None\n    \/\/ >>> longest((List[String](\"a\", \"b\", \"c\")))\n    \/\/ Some(\"a\")\n    \/\/ >>> longest((List[String](\"a\", \"bb\", \"ccc\")))\n    \/\/ Some(\"ccc\")\n    def longest(strings : List[String]) : Option[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ Out of list of strings, return the longest one. Return the first one in case of multiple\n    \/\/ strings of the same length. Return None in case the input list is empty.\n    def longest(strings: List[String]): Option[String] = {\n        if (strings.isEmpty) None\n        else Some(strings.maxBy(_.length))\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(longest((List[String]())).equals(None));\n    assert(longest((List[String](\"x\", \"y\", \"z\"))).equals(Some(\"x\")));\n    assert(longest((List[String](\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"))).equals(Some(\"zzzz\")));\n    }\n\n}\n"},{"task_id":"HumanEval_13","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/གྲངས་ཆ་ a དང་ b གཉིས་ཀྱི་ཆེ་མཐོའི་སྤྱིར་བཏང་ཆ་བགོས་ཕྱིར་ལོག་བྱེད་པ།    \/\/ >>> greatestCommonDivisor((3l), (5l))\n    \/\/ (1l)\n    \/\/ >>> greatestCommonDivisor((25l), (15l))\n    \/\/ (5l)\n    def greatestCommonDivisor(a : Long, b : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ Return a greatest common divisor of two integers a and b\n    \/\/ >>> greatestCommonDivisor((3l), (5l))\n    \/\/ (1l)\n    \/\/ >>> greatestCommonDivisor((25l), (15l))\n    \/\/ (5l)\n    def greatestCommonDivisor(a: Long, b: Long): Long = {\n        if (b == 0) a else greatestCommonDivisor(b, a % b)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(greatestCommonDivisor((3l), (7l)) == (1l));\n    assert(greatestCommonDivisor((10l), (15l)) == (5l));\n    assert(greatestCommonDivisor((49l), (14l)) == (7l));\n    assert(greatestCommonDivisor((144l), (60l)) == (12l));\n    }\n\n}\n"},{"task_id":"HumanEval_14","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ནང་འཇུག་ཐིག་གི་སྔོན་འཇུག་ཚུའི་ཐོ་ཡིག་ ཆུང་ཤོས་ནས་རིང་ཤོས་བར་སླར་ལོག་བྱེད།    \/\/ >>> allPrefixes((\"abc\"))\n    \/\/ (List[String](\"a\", \"ab\", \"abc\"))\n    def allPrefixes(string : String) : List[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Return list of all prefixes from shortest to longest of the input string\n  \/\/ >>> allPrefixes((\"abc\"))\n  \/\/ (List[String](\"a\", \"ab\", \"abc\"))\n  def allPrefixes(string: String): List[String] = {\n    (1 to string.length).map(i => string.substring(0, i)).toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(allPrefixes((\"\")).equals((List[String]())));\n    assert(allPrefixes((\"asdfgh\")).equals((List[String](\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"))));\n    assert(allPrefixes((\"WWW\")).equals((List[String](\"W\", \"WW\", \"WWW\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_15","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/0 ནས་ n བར་གྱི་བར་གྱི་གོ་རིམ་བར་མཚམས་གྲངས་ཡོད་པའི་ string སླར་ལོག་བྱེད།    \/\/ >>> stringSequence((0l))\n    \/\/ (\"0\")\n    \/\/ >>> stringSequence((5l))\n    \/\/ (\"0 1 2 3 4 5\")\n    def stringSequence(n : Long) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def stringSequence(n: Long): String = {\n    (0L to n).mkString(\" \")\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(stringSequence((0l)).equals((\"0\")));\n    assert(stringSequence((3l)).equals((\"0 1 2 3\")));\n    assert(stringSequence((10l)).equals((\"0 1 2 3 4 5 6 7 8 9 10\")));\n    }\n\n}\n"},{"task_id":"HumanEval_16","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/string ཞིག་ཡོད་ན། དེའི་ནང་ཡིག་འབྲུ་ཁྱད་པར་ཅན་ཇི་ཙམ་ཡོད་མེད་འཚོལ་དགོས།    \/\/ >>> countDistinctCharacters((\"xyzXYZ\"))\n    \/\/ (3l)\n    \/\/ >>> countDistinctCharacters((\"Jerry\"))\n    \/\/ (4l)\n    def countDistinctCharacters(string : String) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Given a string, find out how many distinct characters (regardless of case) does it consist of\n  \/\/ >>> countDistinctCharacters((\"xyzXYZ\"))\n  \/\/ (3l)\n  \/\/ >>> countDistinctCharacters((\"Jerry\"))\n  \/\/ (4l)\n  def countDistinctCharacters(string: String): Long = {\n    string.toLowerCase.toSet.size.toLong\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(countDistinctCharacters((\"\")) == (0l));\n    assert(countDistinctCharacters((\"abcde\")) == (5l));\n    assert(countDistinctCharacters((\"abcdecadeCADE\")) == (5l));\n    assert(countDistinctCharacters((\"aaaaAAAAaaaa\")) == (1l));\n    assert(countDistinctCharacters((\"Jerry jERRY JeRRRY\")) == (5l));\n    }\n\n}\n"},{"task_id":"HumanEval_17","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/' ' ' ' ' ' ' ' ' ' ' ཟེར་བའི་སྒྲ་བཞི་ཅན་གྱི་སྒྲ་ཞིག་ལ།    \/\/'o Sa Ra' - ཟློག་ཕྱེད་པ། ཐུབ་ཐེངས་གཉིས་པ།    \/\/'o' - སྒྲ་ཆ་ཚང་ཞིག་ལ། སྒྲ་ཐེངས་བཞི་རིང་དུ་གནས་པ།    \/\/འདི་ལྟ་སྟེ།    \/\/མཐའ་མའི་དུས་མིན་རེད།    \/\/ཁྱོད་ཀྱི་ལས་འགན་ནི་ string འདི་ལ་དཔྱད་ཞིབ་བྱས་རྗེས་ ཇི་ཙམ་རེ་བརྡུང་བའི་གྲངས་གྲངས་ཀྱི་ཐོ་དེ་ཕྱིར་སློག་བྱ་རྒྱུ་ཡིན།    \/\/ལས་འགན་འདི་ལ་ཨེན་ཊི་ཨེས་སི་ཨི་ཨི་ (ASCII) གྱི་རྣམ་པ་སོ་སོར་སྒྲ་དབྱངས་ཀྱི་སྒྲ་དབྱངས་ཀྱི་སྒྲ་དབྱངས་ཀྱི་སྒྲ་དབྱངས་ཀྱི་སྒྲ་དབྱངས་ཤིག་རྩིས་སྤྲོད་བྱེད།    \/\/ >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    \/\/ (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def parseMusic(music_string: String): List[Long] = {\n    val noteMap = Map(\"o\" -> 4L, \"o|\" -> 2L, \".|\" -> 1L)\n    val notes = music_string.split(\" \")\n    notes.toList.map(note => noteMap(note))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_18","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཚད་གཞི་ཐོག་མའི་ནང་ནང་གཞི་གྲངས་ཇི་ཙམ་ཡོད་མེད་འཚོལ་བ། ཚད་གཞི་གཉིས་སུ་ཐབ་པའི་གྲངས་རྩིས་རྒྱག་པ།    \/\/ >>> howManyTimes((\"\"), (\"a\"))\n    \/\/ (0l)\n    \/\/ >>> howManyTimes((\"aaa\"), (\"a\"))\n    \/\/ (3l)\n    \/\/ >>> howManyTimes((\"aaaa\"), (\"aa\"))\n    \/\/ (3l)\n    def howManyTimes(string : String, substring : String) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def howManyTimes(string: String, substring: String): Long = {\n        if (substring.isEmpty || string.isEmpty) return 0L\n        var count: Long = 0L\n        for (i <- 0 to (string.length - substring.length)) {\n            if (string.substring(i, i + substring.length) == substring) {\n                count += 1\n            }\n        }\n        count\n    }\n\n    \/\/ Test cases\n    def main(args: Array[String]): Unit = {\n        println(howManyTimes(\"\", \"a\"))    \/\/ Output: 0\n        println(howManyTimes(\"aaa\", \"a\")) \/\/ Output: 3\n        println(howManyTimes(\"aaaa\", \"aa\")) \/\/ Output: 3\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(howManyTimes((\"\"), (\"x\")) == (0l));\n    assert(howManyTimes((\"xyxyxyx\"), (\"x\")) == (4l));\n    assert(howManyTimes((\"cacacacac\"), (\"cac\")) == (4l));\n    assert(howManyTimes((\"john doe\"), (\"john\")) == (1l));\n    }\n\n}\n"},{"task_id":"HumanEval_19","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཆུང་ཤོས་ནས་ཆེ་བར་རིམ་སྒྲིག་བྱས་པའི་གྲངས་ཀྱི་ཐིག་ཡིག་སླར་ལོག་བྱེད།    \/\/འདྲ་མིན་གྱི་གདམ་ཁ་ནི། ༠། ༡། ༢། ༣། ༤། ༥། ༦། ༧། ༨། ༩ བཅས་ཡིན།    \/\/ནང་འཇུག་ནི་ས་སྟོང་གི་ཚད་མཚམས་ཡོད་པའི་གྲངས་ཀྱི་ཐིག་ལེ་ཞིག་ཡིན་ཏེ། \"ཟི་ལོ\"ནས་ \"དགུ་\"བར་ཡིན།    \/\/ >>> sortNumbers((\"three one five\"))\n    \/\/ (\"one three five\")\n    def sortNumbers(numbers : String) : String = {\n","canonical_solution":"def sortNumbers(numbers: String): String = {\n    val numberWords = Map(\n      \"zero\" -> 0,\n      \"one\" -> 1,\n      \"two\" -> 2,\n      \"three\" -> 3,\n      \"four\" -> 4,\n      \"five\" -> 5,\n      \"six\" -> 6,\n      \"seven\" -> 7,\n      \"eight\" -> 8,\n      \"nine\" -> 9\n    )\n    \n    numbers.split(\" \")\n      .sortBy(word => numberWords(word))\n      .mkString(\" \")\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sortNumbers((\"\")).equals((\"\")));\n    assert(sortNumbers((\"three\")).equals((\"three\")));\n    assert(sortNumbers((\"three five nine\")).equals((\"three five nine\")));\n    assert(sortNumbers((\"five zero four seven nine eight\")).equals((\"zero four five seven eight nine\")));\n    assert(sortNumbers((\"six five four three two one zero\")).equals((\"zero one two three four five six\")));\n    }\n\n}\n"},{"task_id":"HumanEval_20","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/གཞན་དང་རིམ་བཞིན་ལོག་འཇུག་ (གྲངས་ཉུང་། གྲངས་མང་།)    \/\/ཤོག་གྲངས་ཀྱི་ཐོ་ཡིག་ལས་ (ཉུང་མཐར་གཉིས་དགོས་) ཤོག་གྲངས་གཉིས་འདེམས་ནས་སོ་སོར་ཉེ་བར་ཡོད་ཚད་ཕྱིར་ལོག་བྱེད་ཅིག    \/\/ >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))\n    \/\/ ((2.0f, 2.2f))\n    \/\/ >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))\n    \/\/ ((2.0f, 2.0f))\n    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def findClosestElements(numbers: List[Float]): (Float, Float) = {\n    require(numbers.length >= 2, \"List must contain at least two elements\")\n    val sortedNumbers = numbers.sorted\n\n    var minDiff = Float.MaxValue\n    var closestPair = (0.0f, 0.0f)\n\n    for(i <- 0 until sortedNumbers.length - 1) {\n      val currentDiff = abs(sortedNumbers(i) - sortedNumbers(i + 1))\n      if(currentDiff < minDiff) {\n        minDiff = currentDiff\n        closestPair = (sortedNumbers(i), sortedNumbers(i + 1))\n      }\n    }\n    \n    closestPair\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f, 4.0f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f, 2.2f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));\n    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));\n    }\n\n}\n"},{"task_id":"HumanEval_21","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/གྲངས་ཆུང་ཤོས་ནི་ 0 དང་གྲངས་ཆེ་བ་ནི་ 1 ཡིན་པའི་ངེས་པ་ཡོད།    \/\/གྲངས་ཐོ་ (ཉུང་མཐར་ཆ་ཤས་གཉིས་ལས་) ཞིག་ཡོད་ན། གྲངས་ཐོ་དེའི་ནང་ཐིག་ལེ་སྒྱུར་བཅོས་བྱེད་པ།    \/\/ >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    \/\/ (List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers : List[Float]) : List[Float] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Given list of numbers (of at least two elements), apply a linear transform to that list,\n  \/\/ such that the smallest number will become 0 and the largest will become 1\n  def rescaleToUnit(numbers: List[Float]): List[Float] = {\n    val minVal = numbers.min\n    val maxVal = numbers.max\n    numbers.map(num => (num - minVal) \/ (maxVal - minVal))\n  }\n}\n\n\/\/ Usage example\nobject Main extends App {\n  val numbers = List[Float](1.0f, 2.0f, 3.0f, 4.0f, 5.0f)\n  val rescaledNumbers = Problem.rescaleToUnit(numbers)\n  println(rescaledNumbers) \/\/ Output: List(0.0, 0.25, 0.5, 0.75, 1.0)\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat, 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"},{"task_id":"HumanEval_22","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཚད་ལྡན་གནས་ཚད་ཀྱི་གྲངས་ཐོ་དེ་ཨང་གྲངས་ཧྲིལ་པོ་ལ་བརྟག་དཔྱད་བྱ་དགོས།    \/\/ >>> filterIntegers((List[Any](\"a\", 3.14f, 5l)))\n    \/\/ (List[Long](5l.toLong))\n    \/\/ >>> filterIntegers((List[Any](1l, 2l, 3l, \"abc\", Map[Long,Long](), List[Long]())))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 3l.toLong))\n    def filterIntegers(values : List[Any]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def filterIntegers(values: List[Any]): List[Long] = {\n    values.collect {\n      case l: Long => l\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(filterIntegers(List[Any](\"a\", 3.14f, 5l))) \/\/ List(5)\n    println(filterIntegers(List[Any](1l, 2l, 3l, \"abc\", Map[Long, Long](), List[Long]()))) \/\/ List(1, 2, 3)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(filterIntegers((List[Any]())).equals((List[Long]())));\n    assert(filterIntegers((List[Any](4l, Map[Long,Long](), List[Long](), 23.2f, 9l, \"adasd\"))).equals((List[Long](4l.toLong, 9l.toLong))));\n    assert(filterIntegers((List[Any](3l, \"c\", 3l, 3l, \"a\", \"b\"))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_23","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/string གྱི་ཚད་གཞི་སླར་ལོག་བྱེད།    \/\/ >>> stringLength((\"\"))\n    \/\/ (0l)\n    \/\/ >>> stringLength((\"abc\"))\n    \/\/ (3l)\n    def strlen(string : String) : Long = {\n","canonical_solution":"def strlen(string: String): Long = {\n        string.length.toLong\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(strlen((\"\")) == (0l));\n    assert(strlen((\"x\")) == (1l));\n    assert(strlen((\"asdasnakj\")) == (9l));\n    }\n\n}\n"},{"task_id":"HumanEval_24","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/གྲངས་ n ཤིག་ཡོད་ན། n ལས་ཆུང་བའི་གྲངས་ཆེན་ཤོས་ n ཀྱིས་ཆ་བགོས་བྱེད་དེ་འཚོལ་དགོས།    \/\/ >>> largestDivisor((15l))\n    \/\/ (5l)\n    def largestDivisor(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ For a given number n, find the largest number that divides n evenly, smaller than n\n    \/\/ >>> largestDivisor(15l)\n    \/\/ (5l)\n    def largestDivisor(n: Long): Long = {\n        for (i <- (n \/ 2) to 1 by -1) {\n            if (n % i == 0) return i\n        }\n        1L  \/\/ if no divisor found, return 1 (since 1 divides any number)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(largestDivisor((3l)) == (1l));\n    assert(largestDivisor((7l)) == (1l));\n    assert(largestDivisor((10l)) == (5l));\n    assert(largestDivisor((100l)) == (50l));\n    assert(largestDivisor((49l)) == (7l));\n    }\n\n}\n"},{"task_id":"HumanEval_25","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ནང་འཇུག་གྲངས་ནི་གཞི་གྲངས་ཚང་མའི་འབྲས་བུ་དང་མཚུངས་པར་ངེས་པ་དགོས།    \/\/ཚད་གཞི་རེ་རེ་ནི་གཞི་གྲངས་རྩིས་པའི་སྐབས་ ཇི་ཙམ་མང་བ་མངོན་པར་བྱེད་པ་དེ་དང་མཚུངས་པའི་གྲངས་སུ་བཀོད་དགོས།    \/\/ཆེ་ཆུང་ནས་ཆེ་ཆུང་བར་རིམ་བཞིན་གྲངས་ཀྱི་གྲངས་གཞི་སྔོན་གྲངས་ཀྱི་ཐོ་ཡིག་སླར་ལོག་བྱེད།    \/\/ >>> factorize((8l))\n    \/\/ (List[Long](2l.toLong, 2l.toLong, 2l.toLong))\n    \/\/ >>> factorize((25l))\n    \/\/ (List[Long](5l.toLong, 5l.toLong))\n    \/\/ >>> factorize((70l))\n    \/\/ (List[Long](2l.toLong, 5l.toLong, 7l.toLong))\n    def factorize(n : Long) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def factorize(n: Long): List[Long] = {\n    var num = n\n    val factors = ListBuffer[Long]()\n    \n    var i = 2L\n    while (i <= sqrt(num).toLong) {\n      while (num % i == 0) {\n        factors += i\n        num \/= i\n      }\n      i += 1\n    }\n    \n    if (num > 1) {\n      factors += num\n    }\n    \n    factors.toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(factorize((2l)).equals((List[Long](2l.toLong))));\n    assert(factorize((4l)).equals((List[Long](2l.toLong, 2l.toLong))));\n    assert(factorize((8l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong))));\n    assert(factorize((57l)).equals((List[Long](3l.toLong, 19l.toLong))));\n    assert(factorize((3249l)).equals((List[Long](3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((185193l)).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((20577l)).equals((List[Long](3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((18l)).equals((List[Long](2l.toLong, 3l.toLong, 3l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_26","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ནང་འཇུག་བྱ་ཡུལ་ནང་ཡོད་པའི་རིམ་པ་འདྲ་མཚུངས་རང་འཇོག་དགོས།    \/\/ཆ་ཚང་གྲངས་ཐོ་ལས་ཐེངས་གཅིག་ལས་མང་བ་བྱུང་བའི་ཆ་ཤས་ཚང་མ་ཕྱིར་འདོན་བྱ་དགོས།    \/\/ >>> removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))\n    \/\/ (List[Long](1l.toLong, 3l.toLong, 4l.toLong))\n    def removeDuplicates(numbers : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def removeDuplicates(numbers: List[Long]): List[Long] = {\n    val elementCount = numbers.groupBy(identity).mapValues(_.size)\n    numbers.filter(num => elementCount(num) == 1)\n  }\n\n  def main(args: Array[String]): Unit = {\n    val numbers = List[Long](1L, 2L, 3L, 2L, 4L)\n    println(removeDuplicates(numbers)) \/\/ Output: List(1, 3, 4)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(removeDuplicates((List[Long]())).equals((List[Long]())));\n    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 5l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_27","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཚད་ལྡན་ཡིག་འབྲུ་ཚུའི་ནང་ཡིག་ཆུང་ཡིག་ཆུང་དང་ཡིག་ཆུང་ཡིག་ཆུང་ལ་བསྒྱུར་དགོས།    \/\/ >>> flipCase((\"Hello\"))\n    \/\/ (\"hELLO\")\n    def flipCase(string : String) : String = {\n","canonical_solution":"def flipCase(string: String): String = {\n    string.map {\n      case c if c.isLower => c.toUpper\n      case c if c.isUpper => c.toLower\n      case c => c\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(flipCase((\"\")).equals((\"\")));\n    assert(flipCase((\"Hello!\")).equals((\"hELLO!\")));\n    assert(flipCase((\"These violent delights have violent ends\")).equals((\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")));\n    }\n\n}\n"},{"task_id":"HumanEval_28","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/string ཀྱི་ཐོ་ཡིག་གཅིག་ཏུ་བསྡུས།    \/\/ >>> concatenate((List[String]()))\n    \/\/ (\"\")\n    \/\/ >>> concatenate((List[String](\"a\", \"b\", \"c\")))\n    \/\/ (\"abc\")\n    def concatenate(strings : List[String]) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ Concatenate list of strings into a single string\n    \/\/ >>> concatenate((List[String]()))\n    \/\/ (\"\")\n    \/\/ >>> concatenate((List[String](\"a\", \"b\", \"c\")))\n    \/\/ (\"abc\")\n    def concatenate(strings: List[String]): String = {\n        strings.mkString(\"\")\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(concatenate((List[String]())).equals((\"\")));\n    assert(concatenate((List[String](\"x\", \"y\", \"z\"))).equals((\"xyz\")));\n    assert(concatenate((List[String](\"x\", \"y\", \"z\", \"w\", \"k\"))).equals((\"xyzwk\")));\n    }\n\n}\n"},{"task_id":"HumanEval_29","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ནང་འཇུག་གི་ཡིག་འབྲུ་ཐོ་ཡིག་ནང་ prefix དང་འགོ་འཛུགས་པའི་ཡིག་འབྲུ་གཅིག་པུ་འདེམས་དགོས།    \/\/ >>> filterByPrefix((List[String]()), (\"a\"))\n    \/\/ (List[String]())\n    \/\/ >>> filterByPrefix((List[String](\"abc\", \"bcd\", \"cde\", \"array\")), (\"a\"))\n    \/\/ (List[String](\"abc\", \"array\"))\n    def filterByPrefix(strings : List[String], prefix : String) : List[String] = {\n","canonical_solution":"strings.filter(_.startsWith(prefix))\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(filterByPrefix((List[String]()), (\"john\")).equals((List[String]())));\n    assert(filterByPrefix((List[String](\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xxx\")).equals((List[String](\"xxx\", \"xxxAAA\", \"xxx\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_30","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཤོག་གྲངས་ནང་ཡོད་པའི་གྲངས་ཆ་རྐྱང་པ་ལོག་འཇུག་དགོས།    \/\/ >>> getPositive((List[Long](-1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong)))\n    \/\/ (List[Long](2l.toLong, 5l.toLong, 6l.toLong))\n    \/\/ >>> getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))\n    \/\/ (List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))\n    def getPositive(l : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def getPositive(l: List[Long]): List[Long] = {\n        l.filter(_ > 0)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(getPositive((List[Long](-1l.toLong, -2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](4l.toLong, 5l.toLong, 6l.toLong))));\n    assert(getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))));\n    assert(getPositive((List[Long](-1l.toLong, -2l.toLong))).equals((List[Long]())));\n    assert(getPositive((List[Long]())).equals((List[Long]())));\n    }\n\n}\n"},{"task_id":"HumanEval_31","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/གྲངས་ཤིག་སྔོན་གྲངས་ཡིན་ན་ true སླར་ལོག་བྱེད། དེ་མིན་ན་ false སླར་ལོག་བྱེད།    \/\/ >>> isPrime((6l))\n    \/\/ (false)\n    \/\/ >>> isPrime((101l))\n    \/\/ (true)\n    \/\/ >>> isPrime((11l))\n    \/\/ (true)\n    \/\/ >>> isPrime((13441l))\n    \/\/ (true)\n    \/\/ >>> isPrime((61l))\n    \/\/ (true)\n    \/\/ >>> isPrime((4l))\n    \/\/ (false)\n    \/\/ >>> isPrime((1l))\n    \/\/ (false)\n    def isPrime(n : Long) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Return true if a given number is prime, and false otherwise.\n  def isPrime(n: Long): Boolean = {\n    if (n <= 1) return false\n    if (n <= 3) return true\n    if (n % 2 == 0 || n % 3 == 0) return false\n    var i = 5\n    while (i * i <= n) {\n      if (n % i == 0 || n % (i + 2) == 0) return false\n      i += 6\n    }\n    true\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isPrime((6l)) == (false));\n    assert(isPrime((101l)) == (true));\n    assert(isPrime((11l)) == (true));\n    assert(isPrime((13441l)) == (true));\n    assert(isPrime((61l)) == (true));\n    assert(isPrime((4l)) == (false));\n    assert(isPrime((1l)) == (false));\n    assert(isPrime((5l)) == (true));\n    assert(isPrime((11l)) == (true));\n    assert(isPrime((17l)) == (true));\n    assert(isPrime((85l)) == (false));\n    assert(isPrime((77l)) == (false));\n    assert(isPrime((255379l)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_33","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པ་རེད་ཀྱང་། ཚད་གཞི་སོ་སོར་དབྱེ་བ་བྱས་ཡོད།    \/\/l' ནི་ 3 ལ་བགོས་མི་ཐུབ་པའི་རྟགས་གྲངས་ནང་ l དང་མཚུངས་པ་དང་། དེའི་ཐང་ནི་ 3 ལ་བགོས་ཐུབ་པའི་རྟགས་གྲངས་ནང་འདྲ་མཉམ་ཡིན།    \/\/ལས་འགན་འདི་གིས་ཡིག་སྣོད་ l དང་ཡིག་སྣོད་ l' དེ་ཕྱིར་སློག་བྱེད་དེ།    \/\/ >>> sortThird((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 3l.toLong))\n    \/\/ >>> sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))\n    \/\/ (List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))\n    def sortThird(l : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \n  def sortThird(l: List[Long]): List[Long] = {\n    \/\/ Get the elements at indices divisible by 3\n    val elementsAtThirdIndices = l.zipWithIndex.collect {\n      case (value, index) if index % 3 == 0 => value\n    }\n    \n    \/\/ Sort the collected elements\n    val sortedElements = elementsAtThirdIndices.sorted\n    \n    \/\/ Replace elements at indices divisible by 3 with the sorted ones\n    l.zipWithIndex.map {\n      case (_, index) if index % 3 == 0 => sortedElements(index \/ 3)\n      case (value, _) => value\n    }\n  }\n\n  \/\/ Example usage:\n  def main(args: Array[String]): Unit = {\n    println(sortThird(List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    println(sortThird(List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))));\n    assert(sortThird((List[Long](5l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 5l.toLong))));\n    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong, 1l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_34","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཚད་ལྡན་གྱི་ཐོ་ཡིག་ནང་དབྱེ་བ་ཕྱེ་ཟིན་པའི་ཆ་ཤས་ཕྱིར་ལོག་བྱེད།    \/\/ >>> unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    \/\/ (List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))\n    def unique(l : List[Long]) : List[Long] = {\n","canonical_solution":"def unique(l: List[Long]): List[Long] = {\n    l.toSet.toList.sorted\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_35","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཚད་ལྡན་ཡིག་གཟུགས་ནང་ཡིག་གཟུགས་མང་ཤོས་ཕྱིར་ལོག་བྱེད།    \/\/ >>> maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (3l)\n    \/\/ >>> maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))\n    \/\/ (123l)\n    def maxElement(l : List[Long]) : Long = {\n","canonical_solution":"def maxElement(l: List[Long]): Long = {\n    l.max\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (3l));\n    assert(maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 124l.toLong, 1l.toLong, -10l.toLong))) == (124l));\n    }\n\n}\n"},{"task_id":"HumanEval_36","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/གྲངས་ 7 ནི་ 11 དང་ 13 ཀྱིས་ཆ་བགོས་ཐུབ་པའི་ n ལས་ཆུང་བའི་ཧྲིལ་གྲངས་ནང་ཐེངས་གྲངས་ཕྱིར་ལོག་བྱེད་པ།    \/\/ >>> fizzBuzz((50l))\n    \/\/ (0l)\n    \/\/ >>> fizzBuzz((78l))\n    \/\/ (2l)\n    \/\/ >>> fizzBuzz((79l))\n    \/\/ (3l)\n    def fizzBuzz(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def fizzBuzz(n: Long): Long = {\n    var count = 0L\n    for (i <- 1L until n) {\n      if (i % 11 == 0 || i % 13 == 0) {\n        count += i.toString.count(_ == '7')\n      }\n    }\n    count\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fizzBuzz((50l)) == (0l));\n    assert(fizzBuzz((78l)) == (2l));\n    assert(fizzBuzz((79l)) == (3l));\n    assert(fizzBuzz((100l)) == (3l));\n    assert(fizzBuzz((200l)) == (6l));\n    assert(fizzBuzz((4000l)) == (192l));\n    assert(fizzBuzz((10000l)) == (639l));\n    assert(fizzBuzz((100000l)) == (8026l));\n    }\n\n}\n"},{"task_id":"HumanEval_37","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཚད་གཞི་དང་མཚུངས་པའི་གྲངས་ཀ་ཡིན་ཀྱང་། ཚད་གཞི་དང་མཚུངས་པའི་གྲངས་ཀ་ཡིན་ཀྱང་།    \/\/l' འདི་ l དང་མཚུངས་པ་ཉེར་མཁོ་ཅན་གྱི་གནས་ཚད་ནང་ཡིན་པའི་སྐབས་དང་ དེའི་གནས་ཚད་དེ་ཉེར་མཁོ་ཅན་གྱི་གནས་ཚད་ནང་འདྲ་མཉམ་ཡིན།    \/\/ལས་འགན་འདི་གིས་ཡིག་སྣོད་ l དང་ཡིག་སྣོད་ l' དེ་ཕྱིར་སློག་བྱེད་དེ།    \/\/ >>> sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 3l.toLong))\n    \/\/ >>> sortEven((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (List[Long](3l.toLong, 6l.toLong, 5l.toLong, 4l.toLong))\n    def sortEven(l : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ This function takes a list l and returns a list l' such that\n  \/\/ l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  \/\/ to the values of the even indicies of l, but sorted.\n  def sortEven(l: List[Long]): List[Long] = {\n    val evenIndices = l.indices.filter(_ % 2 == 0)\n    val sortedEvens = evenIndices.map(l(_)).sorted\n\n    l.indices.map { index =>\n      if (index % 2 == 0) sortedEvens(evenIndices.indexOf(index))\n      else l(index)\n    }.toList\n  }\n\n  \/\/ Examples\n  def main(args: Array[String]): Unit = {\n    println(sortEven(List[Long](1L, 2L, 3L)))\n    println(sortEven(List[Long](5L, 6L, 3L, 4L)))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong))));\n    assert(sortEven((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](-10l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 5l.toLong, 0l.toLong, 9l.toLong, 1l.toLong, 123l.toLong))));\n    assert(sortEven((List[Long](5l.toLong, 8l.toLong, -12l.toLong, 4l.toLong, 23l.toLong, 2l.toLong, 3l.toLong, 11l.toLong, 12l.toLong, -10l.toLong))).equals((List[Long](-12l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 2l.toLong, 12l.toLong, 11l.toLong, 23l.toLong, -10l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_39","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/prime_fib དེ་ནི་ཨང་གྲངས་ n-th དེ་ནི་ཕི་བྷོ་ན་ཅིའི་གྲངས་ཀ་ཞིག་ཡིན་པ་དང་དེ་ཡང་ཨང་གྲངས་ prime ཡིན་པ་ཕྱིར་སློག་བྱེད་པ་ཡིན།    \/\/ >>> primeFib((1l))\n    \/\/ (2l)\n    \/\/ >>> primeFib((2l))\n    \/\/ (3l)\n    \/\/ >>> primeFib((3l))\n    \/\/ (5l)\n    \/\/ >>> primeFib((4l))\n    \/\/ (13l)\n    \/\/ >>> primeFib((5l))\n    \/\/ (89l)\n    def primeFib(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def primeFib(n: Long): Long = {\n    \/\/ Function to check if a number is prime\n    def isPrime(num: Long): Boolean = {\n      if (num <= 1) return false\n      if (num == 2) return true\n      if (num % 2 == 0) return false\n      for (i <- Range(3, math.sqrt(num).toInt + 1, 2)) {\n        if (num % i == 0) return false\n      }\n      true\n    }\n\n    \/\/ Function to generate Fibonacci numbers\n    def fibonacciStream(): Stream[Long] = {\n      def fibs(a: Long, b: Long): Stream[Long] = a #:: fibs(b, a + b)\n      fibs(0, 1)\n    }\n\n    \/\/ Find the n-th Fibonacci number that is also prime\n    val primeFibs = fibonacciStream().filter(isPrime)\n    primeFibs.take(n.toInt).last\n  }\n\n  \/\/ Test the function\n  def main(args: Array[String]): Unit = {\n    println(primeFib(1L)) \/\/ 2\n    println(primeFib(2L)) \/\/ 3\n    println(primeFib(3L)) \/\/ 5\n    println(primeFib(4L)) \/\/ 13\n    println(primeFib(5L)) \/\/ 89\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(primeFib((1l)) == (2l));\n    assert(primeFib((2l)) == (3l));\n    assert(primeFib((3l)) == (5l));\n    assert(primeFib((4l)) == (13l));\n    assert(primeFib((5l)) == (89l));\n    assert(primeFib((6l)) == (233l));\n    assert(primeFib((7l)) == (1597l));\n    assert(primeFib((8l)) == (28657l));\n    assert(primeFib((9l)) == (514229l));\n    assert(primeFib((10l)) == (433494437l));\n    }\n\n}\n"},{"task_id":"HumanEval_40","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/སྟོང་པ་ཉིད་དུ་བསྡོམས་ནས་གཞན་དུ་རྫུས་མ་ཡིན།    \/\/གལ་ཏེ་ཡིག་སྣོད་ནང་ཁྱད་པར་ཅན་གྱི་ཆ་ཤས་གསུམ་ཡོད་ན་ true སླར་ལོག་བྱེད།    \/\/triple_sum_to_zero ནང་འཇུག་ལྟར་གྲངས་ཚང་གི་ཐོ་ཡིག་ཞིག་ལེན་ཡོད།    \/\/ >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))\n    \/\/ (false)\n    \/\/ >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))\n    \/\/ (true)\n    \/\/ >>> triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))\n    \/\/ (false)\n    \/\/ >>> triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong)))\n    \/\/ (true)\n    \/\/ >>> triplesSumToZero((List[Long](1l.toLong)))\n    \/\/ (false)\n    def triplesSumToZero(l : List[Long]) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ triples_sum_to_zero takes a list of integers as an input.\n    \/\/ it returns true if there are three distinct elements in the list that\n    \/\/ sum to zero, and false otherwise.\n    def triplesSumToZero(l: List[Long]): Boolean = {\n        val n = l.length\n        if (n < 3) return false\n\n        \/\/ Sort the list to use the two-pointer technique\n        val sortedList = l.sorted\n\n        \/\/ Iterate over the list\n        for (i <- 0 until n - 2) {\n            var left = i + 1\n            var right = n - 1\n\n            \/\/ Use two pointers to find the remaining two numbers\n            while (left < right) {\n                val currentSum = sortedList(i) + sortedList(left) + sortedList(right)\n                if (currentSum == 0) {\n                    return true\n                } else if (currentSum < 0) {\n                    left += 1\n                } else {\n                    right -= 1\n                }\n            }\n        }\n\n        false\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -1l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (true));\n    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 5l.toLong, 7l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))) == (true));\n    assert(triplesSumToZero((List[Long](1l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](100l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_41","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ལས་འགན་འདི་ནས་གློག་རྡུལ་འདི་འདྲ་མང་པོ་བྱུང་བའི་གྲངས་ཐོར་ཐིག་བཏོན་ཡོད།    \/\/འདྲ་བ་དེ་དག་གིས་མ་བརྡུང་བར་རང་རང་གི་ལམ་དུ་འགྲོ་བ་རེད།    \/\/ཡིན་ན་ཡང་ཤིང་རྟ་ཚོ་ཧ་ཅང་བརྟན་པོ་དང་ཤུགས་ཆེན་པོ་ཡོད་སྟབས་དུས་རྒྱུན་དུ་འགྲོ་གི་འདུག    \/\/ཕྱོགས་གང་ནས་འགྲོ་བའི་ཤིང་རྟ་ཞིག་གཡས་གཡོན་ནས་འགྲོ་བའི་ཤིང་རྟ་ཞིག་དང་ཐུག་སྐབས།    \/\/སྣུམ་འཁོར་ཚང་མ་མྱུར་ཚད་གཅིག་མཚུངས་ལ་འགྲོ་གི་ཡོད། སྣུམ་འཁོར་གཉིས་བརྡབ་སྐྱོན་བྱུང་ཞེས་བརྗོད་ཀྱི་ཡོད།    \/\/ཕྱོགས་གཡས་གཡོན་ལ་འགྲོ་གི་འདུག སྣུམ་འཁོར་གཉིས་ཀ་འདི་ནས་ཧ་ཅང་ཐག་རིང་ནས་འགྲོ་གི་འདུག    \/\/ཕྱོགས་གཅིག་ཏུ་ n པོ་འཁོར་ལམ་གྱི་ཁ་ཕྱོགས་ནས་གཡོན་ཕྱོགས་སུ་འགྲོ་གི་ཡོད་པ་དང་། ཕྱོགས་གཅིག་ཏུ་ n པོ་འཁོར་ལམ་གྱི་ཁ་ཕྱོགས་ནས་ཁ་ཕྱོགས་ལ་འགྲོ་གི་ཡོད།    \/\/ཚད་མེད་རིང་བའི་ཕྲེང་བ་དྲང་པོ་ཞིག་ཡིན་པ་བསམ་བློ་བཏང་ཞིག    def carRaceCollision(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Imagine a road that's a perfectly straight infinitely long line.\n  \/\/ n cars are driving left to right; simultaneously, a different set of n cars\n  \/\/ are driving right to left. The two sets of cars start out being very far from\n  \/\/ each other. All cars move at the same speed. Two cars are said to collide\n  \/\/ when a car that's moving left to right hits a car that's moving right to left.\n  \/\/ However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  \/\/ in their trajectory as if they did not collide.\n  \/\/ This function outputs the number of such collisions.\n  def carRaceCollision(n: Long): Long = {\n    n\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"},{"task_id":"HumanEval_42","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཕྱིར་ལོག་གི་ཐོ་ཡིག་ནང་ཆ་ཤས་ ༡ ཙམ་ཡར་སེང་ཡོད།    \/\/ >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    \/\/ >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    \/\/ (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ Return list with elements incremented by 1.\n    def incrList(l: List[Long]): List[Long] = {\n        l.map(_ + 1)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_43","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/སྟོང་པ་ཉིད་དུ་བསྡོམས་ནས་གཞན་དུ་རྫུས་མ་ཡིན།    \/\/འདྲ་མཚུངས་ཅན་གྱི་ཆ་ཤས་གཉིས་ཡོད་ན་ true སླར་ལོག་བྱེད།    \/\/pairs_sum_to_zero ནང་འཇུག་ལྟར་གྲངས་ཚང་གི་ཐོ་ཡིག་ཞིག་ལེན་པ།    \/\/ >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))\n    \/\/ (false)\n    \/\/ >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))\n    \/\/ (false)\n    \/\/ >>> pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))\n    \/\/ (false)\n    \/\/ >>> pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    \/\/ (true)\n    \/\/ >>> pairsSumToZero((List[Long](1l.toLong)))\n    \/\/ (false)\n    def pairsSumToZero(l : List[Long]) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def pairsSumToZero(l: List[Long]): Boolean = {\n        val seen = HashSet[Long]()\n        for (num <- l) {\n            if (seen.contains(-num)) {\n                return true\n            }\n            seen.add(num)\n        }\n        false\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](1l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 30l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 31l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 30l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 31l.toLong))) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_44","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/གཞི་གྲངས་ནི་ ༡༠ ལས་ཉུང་བ་རེད།    \/\/ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་ ཚད་གཞི་འདི་ནི་    \/\/ནང་འཇུག་གྲངས་ x གི་གྲངས་གཞི་གཞི་བསྒྱུར་བ།    \/\/ >>> changeBase((8l), (3l))\n    \/\/ (\"22\")\n    \/\/ >>> changeBase((8l), (2l))\n    \/\/ (\"1000\")\n    \/\/ >>> changeBase((7l), (2l))\n    \/\/ (\"111\")\n    def changeBase(x : Long, base : Long) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def changeBase(x: Long, base: Long): String = {\n        require(base > 1 && base < 10, \"Base must be between 2 and 9\")\n        \n        if (x == 0) return \"0\"\n\n        val result = new StringBuilder()\n        var number = x\n\n        while (number > 0) {\n            val remainder = number % base\n            result.append(remainder.toString)\n            number \/= base\n        }\n\n        result.reverse.toString()\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(changeBase((8l), (3l)).equals((\"22\")));\n    assert(changeBase((9l), (3l)).equals((\"100\")));\n    assert(changeBase((234l), (2l)).equals((\"11101010\")));\n    assert(changeBase((16l), (2l)).equals((\"10000\")));\n    assert(changeBase((8l), (2l)).equals((\"1000\")));\n    assert(changeBase((7l), (2l)).equals((\"111\")));\n    assert(changeBase((2l), (3l)).equals((\"2\")));\n    assert(changeBase((3l), (4l)).equals((\"3\")));\n    assert(changeBase((4l), (5l)).equals((\"4\")));\n    assert(changeBase((5l), (6l)).equals((\"5\")));\n    assert(changeBase((6l), (7l)).equals((\"6\")));\n    assert(changeBase((7l), (8l)).equals((\"7\")));\n    }\n\n}\n"},{"task_id":"HumanEval_45","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཟུར་གསུམ་གྱི་རིང་ཚད་དང་མཐོ་ཚད་ཀྱི་ལོག་ཕྱོགས་ཀྱི་ས་ཆ་    \/\/ >>> triangleArea((5l), (3l))\n    \/\/ (7.5f)\n    def triangleArea(a : Long, h : Long) : Float = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ Given length of a side and height, return area for a triangle.\n    \/\/ >>> triangleArea(5l, 3l)\n    \/\/ (7.5f)\n    def triangleArea(a: Long, h: Long): Float = {\n        (a * h \/ 2.0).toFloat\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(triangleArea((5l), (3l)) == (7.5f));\n    assert(triangleArea((2l), (2l)) == (2.0f));\n    assert(triangleArea((10l), (8l)) == (40.0f));\n    }\n\n}\n"},{"task_id":"HumanEval_46","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/fib4གྲངས་རིམ་གྱི་ n-th ཆ་ཤས་ངེས་གཏན་ཆེད་ལས་འགན་ཞིག་བྲིས་རོགས་གནང་། སླར་ལོག་མི་འཇུག་རོགས་གནང་།    \/\/མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད། མཆིན་པ་ནད།    \/\/fib4(3) -> 0     \/\/fib4 (((2) -> 2     \/\/fib4(1) -> 0     \/\/fib4 ((0)) -> 0     \/\/Fib4 ནི་ Fibbonacci གི་རིམ་པ་དང་འདྲ་བའི་རིམ་པ་ཞིག་ཡིན་ཏེ། དེའི་འགྲེལ་བཤད་ནི་གཤམ་གསལ་ལྟར་ཡིན།    \/\/ >>> fib4((5l))\n    \/\/ (4l)\n    \/\/ >>> fib4((6l))\n    \/\/ (8l)\n    \/\/ >>> fib4((7l))\n    \/\/ (14l)\n    def fib4(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def fib4(n: Long): Long = {\n    if (n == 0 || n == 1) return 0\n    if (n == 2) return 2\n    if (n == 3) return 0\n\n    var a: Long = 0\n    var b: Long = 0\n    var c: Long = 2\n    var d: Long = 0\n    \n    var result: Long = 0\n    \n    for (i <- 4L to n) {\n      result = a + b + c + d\n      a = b\n      b = c\n      c = d\n      d = result\n    }\n    \n    result\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fib4((5l)) == (4l));\n    assert(fib4((8l)) == (28l));\n    assert(fib4((10l)) == (104l));\n    assert(fib4((12l)) == (386l));\n    }\n\n}\n"},{"task_id":"HumanEval_47","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཤོག་གྲངས་ཀྱི་བར་མཚམས་ཀྱི་གྲངས་ཐང་ལོག་འཇུག་བྱེད་པ། l    \/\/ >>> median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))\n    \/\/ 3l\n    \/\/ >>> median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong)))\n    \/\/ (15.0f)\n    def median(l : List[Long]) : Float = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Return median of elements in the list l.\n  def median(l: List[Long]): Float = {\n    val sortedList = l.sorted\n    val n = sortedList.length\n    if (n % 2 == 1) {\n      sortedList(n \/ 2).toFloat\n    } else {\n      (sortedList(n \/ 2 - 1) + sortedList(n \/ 2)).toFloat \/ 2\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(median(List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) \/\/ 3.0\n    println(median(List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) \/\/ 15.0\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == 3l);\n    assert(median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) == (8.0f));\n    assert(median((List[Long](5l.toLong))) == 5l);\n    assert(median((List[Long](6l.toLong, 5l.toLong))) == (5.5f));\n    assert(median((List[Long](8l.toLong, 1l.toLong, 3l.toLong, 9l.toLong, 9l.toLong, 2l.toLong, 7l.toLong))) == 7l);\n    }\n\n}\n"},{"task_id":"HumanEval_48","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/string དེ་ palindrome ཡིན་མིན་ལ་བརྟག་དཔྱད་བྱེད།    \/\/ >>> isPalindrome((\"\"))\n    \/\/ (true)\n    \/\/ >>> isPalindrome((\"aba\"))\n    \/\/ (true)\n    \/\/ >>> isPalindrome((\"aaaaa\"))\n    \/\/ (true)\n    \/\/ >>> isPalindrome((\"zbcd\"))\n    \/\/ (false)\n    def isPalindrome(text : String) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Checks if given string is a palindrome\n  def isPalindrome(text: String): Boolean = {\n    val length = text.length\n    for (i <- 0 until length \/ 2) {\n      if (text(i) != text(length - i - 1)) return false\n    }\n    true\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isPalindrome((\"\")) == (true));\n    assert(isPalindrome((\"aba\")) == (true));\n    assert(isPalindrome((\"aaaaa\")) == (true));\n    assert(isPalindrome((\"zbcd\")) == (false));\n    assert(isPalindrome((\"xywyx\")) == (true));\n    assert(isPalindrome((\"xywyz\")) == (false));\n    assert(isPalindrome((\"xywzx\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_49","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཕྱིར་ལོག་ 2^n modulo p (གྲངས་ཀ་ལ་དོ་སྣང་བྱ་དགོས།)    \/\/ >>> modp((3l), (5l))\n    \/\/ (3l)\n    \/\/ >>> modp((1101l), (101l))\n    \/\/ (2l)\n    \/\/ >>> modp((0l), (101l))\n    \/\/ (1l)\n    \/\/ >>> modp((3l), (11l))\n    \/\/ (8l)\n    \/\/ >>> modp((100l), (101l))\n    \/\/ (1l)\n    def modp(n : Long, p : Long) : Long = {\n","canonical_solution":"def modp(n: Long, p: Long): Long = {\n    \/\/ Calculate 2^n modulo p using iterative exponentiation by squaring.\n    def powMod(base: Long, exp: Long, mod: Long): Long = {\n      var result = 1L\n      var b = base % mod\n      var e = exp\n      \n      while (e > 0) {\n        if ((e & 1) == 1) { \/\/ Check if e is odd\n          result = (result * b) % mod\n        }\n        e >>= 1\n        b = (b * b) % mod\n      }\n\n      result\n    }\n\n    powMod(2, n, p)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"},{"task_id":"HumanEval_51","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/remove_vowels ནི་ལས་འགན་ཞིག་ཡིན་པས་ string དང་ vowels མེད་པའི་ string སླར་ལོག་བྱེད།    \/\/ >>> removeVowels((\"\"))\n    \/\/ (\"\")\n    \/\/ >>> removeVowels((\"abcdef\"))\n    \/\/ (\"bcdf\")\n    \/\/ >>> removeVowels((\"aaaaa\"))\n    \/\/ (\"\")\n    \/\/ >>> removeVowels((\"aaBAA\"))\n    \/\/ (\"B\")\n    \/\/ >>> removeVowels((\"zbcd\"))\n    \/\/ (\"zbcd\")\n    def removeVowels(text : String) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def removeVowels(text: String): String = {\n        val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n        text.filterNot(vowels.contains)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(removeVowels((\"\")).equals((\"\")));\n    assert(removeVowels((\"abcdef\\nghijklm\")).equals((\"bcdf\\nghjklm\")));\n    assert(removeVowels((\"fedcba\")).equals((\"fdcb\")));\n    assert(removeVowels((\"eeeee\")).equals((\"\")));\n    assert(removeVowels((\"acBAA\")).equals((\"cB\")));\n    assert(removeVowels((\"EcBOO\")).equals((\"cB\")));\n    assert(removeVowels((\"ybcd\")).equals((\"ybcd\")));\n    }\n\n}\n"},{"task_id":"HumanEval_52","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/གྲངས་ཐོ་ l ནང་གི་གྲངས་ཆ་ཚང་མ་ཚད་མཐའི་ཚད་ t ལས་དམའ་བ་ཡིན་ན་ true སླར་ལོག་བྱེད།    \/\/ >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))\n    \/\/ (true)\n    \/\/ >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))\n    \/\/ (false)\n    def belowThreshold(l : List[Long], t : Long) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Return true if all numbers in the list l are below threshold t.\n  \/\/ >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))\n  \/\/ (true)\n  \/\/ >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))\n  \/\/ (false)\n  def belowThreshold(l: List[Long], t: Long): Boolean = {\n    l.forall(_ < t)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l)) == (false));\n    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (21l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (22l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (11l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (10l)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_53","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/གྲངས་གཉིས་ x དང་ y བསྡུས་པ།    \/\/ >>> add((2l), (3l))\n    \/\/ (5l)\n    \/\/ >>> add((5l), (7l))\n    \/\/ (12l)\n    def add(x : Long, y : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    \/\/ Add two numbers x and y\n    \/\/ >>> add((2l), (3l))\n    \/\/ (5l)\n    \/\/ >>> add((5l), (7l))\n    \/\/ (12l)\n    def add(x: Long, y: Long): Long = {\n        x + y\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(add((0l), (1l)) == (1l));\n    assert(add((1l), (0l)) == (1l));\n    assert(add((2l), (3l)) == (5l));\n    assert(add((5l), (7l)) == (12l));\n    assert(add((7l), (5l)) == (12l));\n    }\n\n}\n"},{"task_id":"HumanEval_54","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཚིག་གཉིས་ནང་ཡིག་འབྲུ་འདྲ་མཚུངས་ཡོད་མེད་བརྟག་དཔྱད་བྱེད་དགོས།    \/\/ >>> sameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n    \/\/ (true)\n    \/\/ >>> sameChars((\"abcd\"), (\"dddddddabc\"))\n    \/\/ (true)\n    \/\/ >>> sameChars((\"dddddddabc\"), (\"abcd\"))\n    \/\/ (true)\n    \/\/ >>> sameChars((\"eabcd\"), (\"dddddddabc\"))\n    \/\/ (false)\n    \/\/ >>> sameChars((\"abcd\"), (\"dddddddabce\"))\n    \/\/ (false)\n    \/\/ >>> sameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n    \/\/ (false)\n    def sameChars(s0 : String, s1 : String) : Boolean = {\n","canonical_solution":"import scala.collection.mutable._\n\nobject Problem {\n  def sameChars(s0: String, s1: String): Boolean = {\n    def charSet(s: String): Set[Char] = s.toSet\n    charSet(s0) == charSet(s1) && charSet(s0).forall(c => s0.count(_ == c) <= s1.count(_ == c) && s1.count(_ == c) <= s0.count(_ == c))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(sameChars((\"abcd\"), (\"dddddddabc\")) == (true));\n    assert(sameChars((\"dddddddabc\"), (\"abcd\")) == (true));\n    assert(sameChars((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(sameChars((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(sameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(sameChars((\"aabb\"), (\"aaccc\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_55","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཕི་བོ་ན་ཅིའི་གྲངས་ n སླར་ལོག་བྱ་དགོས།    \/\/ >>> fib((10l))\n    \/\/ (55l)\n    \/\/ >>> fib((1l))\n    \/\/ (1l)\n    \/\/ >>> fib((8l))\n    \/\/ (21l)\n    def fib(n : Long) : Long = {\n","canonical_solution":"def fib(n: Long): Long = {\n        if (n <= 1) n\n        else {\n            var a: Long = 0\n            var b: Long = 1\n            for (_ <- 2L to n) {\n                val temp = a + b\n                a = b\n                b = temp\n            }\n            b\n        }\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fib((10l)) == (55l));\n    assert(fib((1l)) == (1l));\n    assert(fib((8l)) == (21l));\n    assert(fib((11l)) == (89l));\n    assert(fib((12l)) == (144l));\n    }\n\n}\n"},{"task_id":"HumanEval_56","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/return true གལ་ཏེ་ཁ་ཕྱེས་པའི་ bracket ནང་འཇུག་པའི་ bracket ཞིག་ཡོད་ན་ true སླར་ལོག་བྱེད།    \/\/brackets ནི་ \"<\" དང་ \">\" ཀྱི་ཡིག་འབྲུ་ཡིན།    \/\/ >>> correctBracketing((\"<\"))\n    \/\/ (false)\n    \/\/ >>> correctBracketing((\"<>\"))\n    \/\/ (true)\n    \/\/ >>> correctBracketing((\"<<><>>\"))\n    \/\/ (true)\n    \/\/ >>> correctBracketing((\"><<>\"))\n    \/\/ (false)\n    def correctBracketing(brackets : String) : Boolean = {\n","canonical_solution":"import scala.collection.mutable.Stack\n\nobject Problem {\n  def correctBracketing(brackets: String): Boolean = {\n    val stack = new Stack[Char]()\n    for (char <- brackets) {\n      if (char == '<') {\n        stack.push(char)\n      } else if (char == '>') {\n        if (stack.isEmpty || stack.pop() != '<') {\n          return false\n        }\n      }\n    }\n    stack.isEmpty\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(correctBracketing((\"<>\")) == (true));\n    assert(correctBracketing((\"<<><>>\")) == (true));\n    assert(correctBracketing((\"<><><<><>><>\")) == (true));\n    assert(correctBracketing((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(correctBracketing((\"<<<><>>>>\")) == (false));\n    assert(correctBracketing((\"><<>\")) == (false));\n    assert(correctBracketing((\"<\")) == (false));\n    assert(correctBracketing((\"<<<<\")) == (false));\n    assert(correctBracketing((\">\")) == (false));\n    assert(correctBracketing((\"<<>\")) == (false));\n    assert(correctBracketing((\"<><><<><>><>><<>\")) == (false));\n    assert(correctBracketing((\"<><><<><>><>>><>\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_57","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/Return true is list elements are monotonically increasing or decreasing. ཤོག་གྲངས་གྲངས་གྲངས་སུ་ཡོད་མེད་སླར་ལོག་བྱེད།    \/\/ >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))\n    \/\/ (true)\n    \/\/ >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))\n    \/\/ (false)\n    \/\/ >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))\n    \/\/ (true)\n    def monotonic(l : List[Long]) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Return true if list elements are monotonically increasing or decreasing.\n  \/\/ >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))\n  \/\/ (true)\n  \/\/ >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))\n  \/\/ (false)\n  \/\/ >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))\n  \/\/ (true)\n  def monotonic(l: List[Long]): Boolean = {\n    if (l.isEmpty || l.length == 1) return true\n\n    val increasing = l.sliding(2).forall { case List(a, b) => a <= b }\n    val decreasing = l.sliding(2).forall { case List(a, b) => a >= b }\n\n    increasing || decreasing\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong))) == (false));\n    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong))) == (true));\n    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 5l.toLong, 60l.toLong))) == (false));\n    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 60l.toLong))) == (true));\n    assert(monotonic((List[Long](9l.toLong, 9l.toLong, 9l.toLong, 9l.toLong))) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_58","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/འདྲ་མིན་གྱི་གོ་རིམ་སྒྲིག་པའི་ཆ་ཤས་གཉིས་སུ་ལོག་འཇུག་བྱེད།    \/\/ >>> common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))\n    \/\/ (List[Long](1l.toLong, 5l.toLong, 653l.toLong))\n    \/\/ >>> common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))\n    \/\/ (List[Long](2l.toLong, 3l.toLong))\n    def common(l1 : List[Long], l2 : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Return sorted unique common elements for two lists.\n  def common(l1: List[Long], l2: List[Long]): List[Long] = {\n    (l1.toSet intersect l2.toSet).toList.sorted\n  }\n\n  \/\/ Example usage\n  def main(args: Array[String]): Unit = {\n    println(common(List[Long](1L, 4L, 3L, 34L, 653L, 2L, 5L), List[Long](5L, 7L, 1L, 5L, 9L, 653L, 121L)))\n    println(common(List[Long](5L, 3L, 2L, 8L), List[Long](3L, 2L)))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 653l.toLong))));\n    assert(common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));\n    }\n\n}\n"},{"task_id":"HumanEval_59","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/n གི་གྲངས་ཐང་ཆེ་ཤོས་ཕྱིར་ལོག་བྱེད་པ། n > 1 དང་གྲངས་ཐང་ཆེ་མིན་པའི་ངེས་ཚིག་ཡིན།    \/\/ >>> largestPrimeFactor((13195l))\n    \/\/ (29l)\n    \/\/ >>> largestPrimeFactor((2048l))\n    \/\/ (2l)\n    def largestPrimeFactor(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def largestPrimeFactor(n: Long): Long = {\n        var number = n\n        var largestFactor = 1L\n\n        \/\/ Check for number of 2s that divide n\n        while (number % 2 == 0) {\n            largestFactor = 2L\n            number \/= 2\n        }\n\n        \/\/ n must be odd at this point, so a skip of 2 (i = i + 2) can be used\n        var i = 3\n        while (i <= sqrt(number)) {\n            while (number % i == 0) {\n                largestFactor = i\n                number \/= i\n            }\n            i += 2\n        }\n\n        \/\/ This condition is to check if number is a prime number greater than 2\n        if (number > 2) {\n            largestFactor = number\n        }\n\n        largestFactor\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(largestPrimeFactor((15l)) == (5l));\n    assert(largestPrimeFactor((27l)) == (3l));\n    assert(largestPrimeFactor((63l)) == (7l));\n    assert(largestPrimeFactor((330l)) == (11l));\n    assert(largestPrimeFactor((13195l)) == (29l));\n    }\n\n}\n"},{"task_id":"HumanEval_60","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/sum_to_n ནི་ 1 ནས་ n བར་གྱི་གྲངས་གྲངས་བསྡོམས་པའི་ལས་འགན་ཡིན།    \/\/ >>> sumToN((30l))\n    \/\/ (465l)\n    \/\/ >>> sumToN((100l))\n    \/\/ (5050l)\n    \/\/ >>> sumToN((5l))\n    \/\/ (15l)\n    \/\/ >>> sumToN((10l))\n    \/\/ (55l)\n    \/\/ >>> sumToN((1l))\n    \/\/ (1l)\n    def sumToN(n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sumToN(n: Long): Long = {\n        (1L to n).sum\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sumToN((1l)) == (1l));\n    assert(sumToN((6l)) == (21l));\n    assert(sumToN((11l)) == (66l));\n    assert(sumToN((30l)) == (465l));\n    assert(sumToN((100l)) == (5050l));\n    }\n\n}\n"},{"task_id":"HumanEval_61","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/return true གལ་ཏེ་ཁ་ཕྱེས་པའི་ bracket ནང་འཇུག་པའི་ bracket ཞིག་ཡོད་ན་ true སླར་ལོག་བྱེད།    \/\/brackets ནི་ \"(\" དང་ \"\") ཀྱི་ཡིག་འབྲུ་ཡིན།    \/\/ >>> correctBracketing((\"(\"))\n    \/\/ (false)\n    \/\/ >>> correctBracketing((\"()\"))\n    \/\/ (true)\n    \/\/ >>> correctBracketing((\"(()())\"))\n    \/\/ (true)\n    \/\/ >>> correctBracketing((\")(()\"))\n    \/\/ (false)\n    def correctBracketing(brackets : String) : Boolean = {\n","canonical_solution":"var balance = 0\n        for (ch <- brackets) {\n            if (ch == '(') balance += 1\n            else if (ch == ')') balance -= 1\n            \n            if (balance < 0) return false\n        }\n        balance == 0\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(correctBracketing((\"()\")) == (true));\n    assert(correctBracketing((\"(()())\")) == (true));\n    assert(correctBracketing((\"()()(()())()\")) == (true));\n    assert(correctBracketing((\"()()((()()())())(()()(()))\")) == (true));\n    assert(correctBracketing((\"((()())))\")) == (false));\n    assert(correctBracketing((\")(()\")) == (false));\n    assert(correctBracketing((\"(\")) == (false));\n    assert(correctBracketing((\"((((\")) == (false));\n    assert(correctBracketing((\")\")) == (false));\n    assert(correctBracketing((\"(()\")) == (false));\n    assert(correctBracketing((\"()()(()())())(()\")) == (false));\n    assert(correctBracketing((\"()()(()())()))()\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_62","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/འདྲ་བའི་རྣམ་གྲངས་ཀྱི་ཟུར་གྲངས་ཕྱིར་ལོག་བྱེད་པ།    \/\/xs[0] + xs[1] * x + xs[2] * x^2 + ....     \/\/xs ནི་མང་ཚུའི་མཚོན་རྟགས་ཡིན་ཏེ།    \/\/ >>> derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))\n    \/\/ (List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))\n    \/\/ >>> derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[Long](2l.toLong, 6l.toLong))\n    def derivative(xs : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.collection.mutable._\n\nobject Problem {\n  def derivative(xs: List[Long]): List[Long] = {\n    xs.zipWithIndex.tail.map { case (coeff, index) => coeff * index }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))));\n    assert(derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 6l.toLong))));\n    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 2l.toLong))));\n    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 0l.toLong, 16l.toLong))));\n    assert(derivative((List[Long](1l.toLong))).equals((List[Long]())));\n    }\n\n}\n"},{"task_id":"HumanEval_63","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཤོག་གྲངས་རིམ་པའི་ n-th ནང་གི་ཆ་ཤས་ལེགས་པར་རྩིས་ཐུབ་པའི་ལས་འགན་ཞིག་བྲིས་རོགས།    \/\/fib fib (n) == fib (n-1) + fib (n-2) + fib (n-3)    \/\/མཆིན་པ་གཉིས།    \/\/སྦྲེལ་རྟགས་:    \/\/fib fib        \/\/FibFib ཨང་རིམ་ནི་ Fibbonacci sequence དང་འདྲ་བའི་རིམ་པ་ཞིག་ཡིན་ཏེ། དེའི་འགྲེལ་བཤད་ནི་གཤམ་གསལ་ལྟར་ཡིན།    \/\/ >>> fibfib((1l))\n    \/\/ (0l)\n    \/\/ >>> fibfib((5l))\n    \/\/ (4l)\n    \/\/ >>> fibfib((8l))\n    \/\/ (24l)\n    def fibfib(n : Long) : Long = {\n","canonical_solution":"def fibfib(n: Long): Long = {\n    if (n == 0) return 0\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a: Long = 0\n    var b: Long = 0\n    var c: Long = 1\n    var d: Long = 0\n\n    for (_ <- 3L to n) {\n      d = a + b + c\n      a = b\n      b = c\n      c = d\n    }\n    d\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fibfib((2l)) == (1l));\n    assert(fibfib((1l)) == (0l));\n    assert(fibfib((5l)) == (4l));\n    assert(fibfib((8l)) == (24l));\n    assert(fibfib((10l)) == (81l));\n    assert(fibfib((12l)) == (274l));\n    assert(fibfib((14l)) == (927l));\n    }\n\n}\n"},{"task_id":"HumanEval_64","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/vowel ཟེར་བ་འདི། འོན་ཀྱང་ཚིག་གི་མཐའ་མ་ལ་ཡོད་ན་ཁོ་ན་ཡིན།    \/\/འདིར་སྒྲ་དབྱངས་ཀྱི་རྣམ་པ་ནི་ \"a\", \"e\", \"i\", \"o\", \"u\" རྣམས་ཡིན། འདིར་ \"y\" ཀྱང་ a ཡིན་    \/\/ཚིག་ཡིག་འདི་ནི་ནང་འཇུག་བྱེད་སྟངས་དང་ string ནང་གི་སྒྲ་སྒྲ་གྲངས་ཕྱིར་ལོག་བྱེད་སྟངས་ཡིན།    \/\/ཤོག་གྲངས་ཀྱི་རྣམ་གྲངས་ལ་མཚོན་པའི་ཡིག་འབྲུ་ཞིག་བྲིས་ན།    \/\/ >>> vowelsCount((\"abcde\"))\n    \/\/ (2l)\n    \/\/ >>> vowelsCount((\"ACEDY\"))\n    \/\/ (3l)\n    def vowelsCount(s : String) : Long = {\n","canonical_solution":"def vowelsCount(s: String): Long = {\n    val vowels = Set('a', 'e', 'i', 'o', 'u')\n    val lowerCaseWord = s.toLowerCase\n    var count = 0L\n\n    for (i <- lowerCaseWord.indices) {\n      if (vowels.contains(lowerCaseWord(i)) || (lowerCaseWord(i) == 'y' && i == lowerCaseWord.length - 1)) {\n        count += 1\n      }\n    }\n\n    count\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(vowelsCount((\"abcde\")) == (2l));\n    assert(vowelsCount((\"Alone\")) == (3l));\n    assert(vowelsCount((\"key\")) == (2l));\n    assert(vowelsCount((\"bye\")) == (1l));\n    assert(vowelsCount((\"keY\")) == (2l));\n    assert(vowelsCount((\"bYe\")) == (1l));\n    assert(vowelsCount((\"ACEDY\")) == (3l));\n    }\n\n}\n"},{"task_id":"HumanEval_65","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/shift > digits ཟེར་བ་ཡོད་ན་ return digits བསྒྱུར་ནས་ཨང་གྲངས་འདེམས་དགོས།    \/\/འབྲས་བུ་ནི་ string སྦེ་སླར་ལོག་འབདཝ་ཨིན།    \/\/འབོར་གྲངས་ x གི་ཨང་གྲངས་རྣམས་འཁོར་ལམ་དུ་སྤོ་བཤུད་བྱེད་པ། ཨང་གྲངས་རྣམས་གཡས་སུ་སྤོ་བཤུད་བྱེད་པ།    \/\/ >>> circularShift((12l), (1l))\n    \/\/ (\"21\")\n    \/\/ >>> circularShift((12l), (2l))\n    \/\/ (\"12\")\n    def circularShift(x : Long, shift : Long) : String = {\n","canonical_solution":"def circularShift(x: Long, shift: Long): String = {\n  val digits = x.toString\n  val length = digits.length\n  \n  if (shift >= length) {\n    digits.reverse\n  } else {\n    val effectiveShift = (length - shift % length).toInt\n    (digits.drop(effectiveShift) + digits.take(effectiveShift))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(circularShift((100l), (2l)).equals((\"001\")));\n    assert(circularShift((12l), (2l)).equals((\"12\")));\n    assert(circularShift((97l), (8l)).equals((\"79\")));\n    assert(circularShift((12l), (1l)).equals((\"21\")));\n    assert(circularShift((11l), (101l)).equals((\"11\")));\n    }\n\n}\n"},{"task_id":"HumanEval_66","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ཨཱ་སི་ཀི་ཨི་ཨང་ཀོཌ།    \/\/ནང་འཇུག་ལྟར་ string དང་སྟེང་གི་ཡིག་རྟགས་ཀྱི་བསྡོམས་གྲངས་ཕྱིར་ལོག་བྱེད་ function ཞིག་འབྲི་དགོས།    \/\/ལས་འགན་     \/\/ >>> digitSum((\"\"))\n    \/\/ (0l)\n    \/\/ >>> digitSum((\"abAB\"))\n    \/\/ (131l)\n    \/\/ >>> digitSum((\"abcCd\"))\n    \/\/ (67l)\n    \/\/ >>> digitSum((\"helloE\"))\n    \/\/ (69l)\n    \/\/ >>> digitSum((\"woArBld\"))\n    \/\/ (131l)\n    \/\/ >>> digitSum((\"aAaaaXa\"))\n    \/\/ (153l)\n    def digitSum(s : String) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def digitSum(s: String): Long = {\n    s.filter(_.isUpper).map(_.toLong).sum\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(digitSum((\"\")) == (0l));\n    assert(digitSum((\"abAB\")) == (131l));\n    assert(digitSum((\"abcCd\")) == (67l));\n    assert(digitSum((\"helloE\")) == (69l));\n    assert(digitSum((\"woArBld\")) == (131l));\n    assert(digitSum((\"aAaaaXa\")) == (153l));\n    assert(digitSum((\" How are yOu?\")) == (151l));\n    assert(digitSum((\"You arE Very Smart\")) == (327l));\n    }\n\n}\n"},{"task_id":"HumanEval_67","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཆེད་སྒྲིག    \/\/ཙེལ་པོ་ནང་ཡོད་པའི་མན་གྷོའི་འབྲས་བུ་གྲངས་ཕྱིར་ལོག་བྱེད་པ།    \/\/འབྲས་བུའི་གྲངས་ཐང་མཚོན་པའི་ཨང་གྲངས་ཧྲིལ་པོ་དང་ཁམ་བུ་དང་ཁམ་བུ་བཅས་ཡིན།    \/\/འབྲས་བུའི་གྲངས་རྩིས་ཀྱི་ཐིག་ཁྲམ་འདི་ལ།    \/\/འབྲས་བུ་ཡོད་པའི་ཙེལ་པོ་ཞིག་ལ་བགོས་པའི་ཤིང་འབྲས་ཡིན།    \/\/ལས་འགན་འདིའི་ནང་ཁྱོད་ཚོར་ apple དང་ orange གྱི་གྲངས་ཐང་མཚོན་པའི་ string ཞིག་ཐོབ་ངེས་ཡིན།    \/\/ >>> fruitDistribution((\"5 apples and 6 oranges\"), (19l))\n    \/\/ (8l)\n    \/\/ >>> fruitDistribution((\"0 apples and 1 oranges\"), (3l))\n    \/\/ (2l)\n    \/\/ >>> fruitDistribution((\"2 apples and 3 oranges\"), (100l))\n    \/\/ (95l)\n    \/\/ >>> fruitDistribution((\"100 apples and 1 oranges\"), (120l))\n    \/\/ (19l)\n    def fruitDistribution(s : String, n : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def fruitDistribution(s: String, n: Long): Long = {\n    val fruits = s.split(\" and \").map(_.split(\" \")(0).toLong)\n    val totalApplesAndOranges = fruits.sum\n    n - totalApplesAndOranges\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fruitDistribution((\"5 apples and 6 oranges\"), (19l)) == (8l));\n    assert(fruitDistribution((\"5 apples and 6 oranges\"), (21l)) == (10l));\n    assert(fruitDistribution((\"0 apples and 1 oranges\"), (3l)) == (2l));\n    assert(fruitDistribution((\"1 apples and 0 oranges\"), (3l)) == (2l));\n    assert(fruitDistribution((\"2 apples and 3 oranges\"), (100l)) == (95l));\n    assert(fruitDistribution((\"2 apples and 3 oranges\"), (5l)) == (0l));\n    assert(fruitDistribution((\"1 apples and 100 oranges\"), (120l)) == (19l));\n    }\n\n}\n"},{"task_id":"HumanEval_68","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཞི་དང་པོ།    \/\/གལ་ཏེ་གྲངས་ཆ་མཚུངས་མེད་པའམ་གྲངས་ཐོ་སྟོང་པ་ཡོད་ན་ return [] བྱེད་དགོས།    \/\/ཕྱིར་བཏོན་པའི་ཨང་གྲངས་དེ་ཐོ་ཡིག་ནང་ཕྱིར་ལོག་བྱེད་པ། [smallest_value, its index]     \/\/གལ་ཏེ་ཕྲ་གྲངས་ཆུང་ཤོས་དང་ཕྲ་གྲངས་ཉུང་ཤོས་འདྲ་མཉམ་ཡོད་པའི་ཕྲ་གྲངས་མང་པོ་བསྡུས་ན་ཕྲ་གྲངས་ཆུང་ཤོས་ཡོད་པའི་ཕྲ་གྲངས་ཕྱིར་ལོག་བྱེད།    \/\/ཕྱིར་འཐེན་བྱས་པའི་ཨང་རྟགས་ནི་ཨང་རྟགས་ཆུང་ཤོས་དང་མཚུངས་པའི་ཨང་རྟགས་ཡིན་དགོས།    \/\/ཁྱོད་ཀྱི་ལས་འགན་ནི་ཨང་རྟགས་གཅིག་བཏོན་ནས་ཕྱིར་ལོག་བྱེད་རྒྱུ་དེ་ཡིན།    \/\/\"ཨང་གྲངས་ཆ་མེད་མེད་པའི་ཨང་གྲངས་ཀྱི་སྒོ་ཡོད་ཀྱི་ཤིང་སྡོང་གི་ཡལ་ག་མཚོན་པའི་ཐོ་ཡིག་ཤིག་གནང་ན།    \/\/ >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[Long](2l.toLong, 1l.toLong))\n    \/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    \/\/ Example 2:\n    \/\/ >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[Long](2l.toLong, 1l.toLong))\n    \/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    \/\/ Example 3:\n    \/\/ >>> pluck((List[Long]()))\n    \/\/ (List[Long]())\n    \/\/ Example 4:\n    \/\/ >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    \/\/ (List[Long](0l.toLong, 1l.toLong))\n    \/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n    \/\/ so we will choose the first zero, which has the smallest index.\n    \/\/ Constraints:\n    \/\/ * 1 <= nodes.length <= 10000\n    \/\/ * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def pluck(arr: List[Long]): List[Long] = {\n    val evenNodes = arr.zipWithIndex.filter { case (value, _) => value % 2 == 0 }\n    if (evenNodes.isEmpty) {\n      List.empty[Long]\n    } else {\n      val (smallestValue, index) = evenNodes.minBy { case (value, index) => (value, index) }\n      List(smallestValue, index.toLong)\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n"},{"task_id":"HumanEval_69","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/གལ་ཏེ་གོང་ཚད་དེ་མེད་ན་ -1 སླར་ལོག་བྱེད།    \/\/ཨང་གྲངས་ཧྲིལ་པོ་ཞིག་གི་འཕྲལ་ཆའི་གྲངས་ནི་གྲངས་ཐོ་ནང་དུ་ཐེངས་ཇི་ཙམ་མངོན་པ་ཡིན།    \/\/ནུས་པ་ 0 དང་འཕྲལ་དུ་མང་བ་ཡང་ན་ འདྲ་མཉམ་གྲངས་ཆ་རང་གི་རིན་ཐང་དང་མཚུངས་པ་ཡོད།    \/\/ཁྱོད་ཀྱིས་ཁ་གྲངས་ཆ་མཉམ་ཁ་སྐོང་གྱི་གྲངས་ཐོ་སྟོང་པ་མིན་པ་ཞིག་ཐོབ་ཡོད། ལས་མང་བ་ཡོད་ཚད་ཀྱི་གྲངས་ཐང་ཆེན་ཤོས་ཕྱིར་ལོག་བྱོས།    \/\/ >>> search((List[Long](4l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\n    \/\/ (2l)\n    \/\/ >>> search((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))\n    \/\/ (3l)\n    \/\/ >>> search((List[Long](5l.toLong, 5l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))\n    \/\/ (-1l)\n    def search(lst : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def search(lst: List[Long]): Long = {\n    val frequencyMap = lst.groupBy(identity).mapValues(_.size)\n    lst.filter(num => frequencyMap(num) >= num).sorted(Ordering[Long].reverse) match {\n      case x :: _ => x\n      case Nil => -1L\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(search((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](4l.toLong, 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](3l.toLong, 3l.toLong))) == (-1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));\n    assert(search((List[Long](2l.toLong, 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](2l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong, 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong, 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));\n    assert(search((List[Long](6l.toLong, 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 7l.toLong, 9l.toLong))) == (1l));\n    assert(search((List[Long](1l.toLong, 9l.toLong, 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](6l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong, 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (5l));\n    assert(search((List[Long](1l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong, 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 5l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong, 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong))) == (2l));\n    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong, 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong, 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong))) == (4l));\n    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong, 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong, 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong, 10l.toLong, 8l.toLong))) == (-1l));\n    assert(search((List[Long](10l.toLong))) == (-1l));\n    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong, 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 7l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 4l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 1l.toLong, 8l.toLong))) == (1l));\n    assert(search((List[Long](7l.toLong, 9l.toLong, 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong, 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));\n    }\n\n}\n"},{"task_id":"HumanEval_70","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/དེའི་རྗེས་ལ་ལྷག་ལུས་ཧྲིལ་གྲངས་ཀྱི་ཆེ་མཐར། དེའི་རྗེས་ལ་ཉུང་མཐར། ཟེར་བ་ལྟ་བུ།    \/\/ཇི་ཙམ་གལ་ཆེ་བས་གལ་ཆེ་བ་ཡིན་པའི་ཚད་གཞི་ནས་འགོ་འཛུགས་པ།    \/\/གྲངས་ཀྱི་ཐོ་ཚོམ་ཡོད་ན། རྒྱུན་མི་འདྲ་བའི་རིམ་པ་བཞིན་ལོག་འཇུག་དགོས།    \/\/ >>> strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))\n    \/\/ >>> strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong)))\n    \/\/ (List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))\n    \/\/ >>> strangeSortList((List[Long]()))\n    \/\/ (List[Long]())\n    def strangeSortList(lst : List[Long]) : List[Long] = {\n","canonical_solution":"def strangeSortList(lst: List[Long]): List[Long] = {\n    val buffer = lst.sorted.toBuffer\n    val result = ArrayBuffer[Long]()\n    var takeMin = true\n\n    while (buffer.nonEmpty) {\n      if (takeMin) {\n        result += buffer.remove(0) \/\/ take the minimum\n      } else {\n        result += buffer.remove(buffer.length - 1) \/\/ take the maximum of the remaining\n      }\n      takeMin = !takeMin\n    }\n\n    result.toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong, 7l.toLong))));\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong, 8l.toLong, 6l.toLong, 7l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))));\n    assert(strangeSortList((List[Long]())).equals((List[Long]())));\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong, 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));\n    assert(strangeSortList((List[Long](0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong, 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));\n    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_71","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/ཤོག་ངོས་གསུམ་པ་ལས་ལྷག་པ་མེད།    \/\/གཡོན་པ་གསུམ་གྱིས་རྣམ་གསུམ་གྲུབ་པའི་སྐབས་ཀྱི་གྲངས་ཐང་ནི་གཞན་གྱི་ཟུར་པ་གཉིས་ལས་མང་བ་ཡིན་ཏེ།    \/\/དེ་མིན་ལོག་ -1     \/\/ཕྱོགས་གསུམ་གྱི་རྣམ་པ་གསུམ་ལྡན་པ་ཞིག་ཡིན་ན། ཟུར་གསུམ་གྱི་མཐའ་འཁོར་གྱི་ཟུར་གྲངས་ནི་བཅུ་ཆ་གཉིས་སུ་བསྡུ་དགོས།    \/\/ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་རིང་ཚད་ལ་གཞི་བྱས་ན། གྱི་ཁྱབ་ཚད་ཕྱིར་ལོག་བྱེད་པ།    \/\/ >>> triangleArea((3l), (4l), (5l))\n    \/\/ (6.0f)\n    \/\/ >>> triangleArea((1l), (2l), (10l))\n    \/\/ -1l\n    def triangleArea(a : Long, b : Long, c : Long) : Float = {\n","canonical_solution":"import scala.math._\n\nobject Problem {\n  def triangleArea(a: Long, b: Long, c: Long): Float = {\n    if (a + b > c && a + c > b && b + c > a) {\n      val s = (a + b + c) \/ 2.0\n      val area = sqrt(s * (s - a) * (s - b) * (s - c))\n      BigDecimal(area).setScale(2, BigDecimal.RoundingMode.HALF_UP).toFloat\n    } else {\n      -1f\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(triangleArea((3l), (4l), (5l)) == (6.0f));\n    assert(triangleArea((1l), (2l), (10l)) == -1l);\n    assert(triangleArea((4l), (8l), (5l)) == (8.18f));\n    assert(triangleArea((2l), (2l), (2l)) == (1.73f));\n    assert(triangleArea((1l), (2l), (3l)) == -1l);\n    assert(triangleArea((10l), (5l), (7l)) == (16.25f));\n    assert(triangleArea((2l), (6l), (3l)) == -1l);\n    assert(triangleArea((1l), (1l), (1l)) == (0.43f));\n    assert(triangleArea((2l), (2l), (10l)) == -1l);\n    }\n\n}\n"},{"task_id":"HumanEval_72","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/དངོས་པོ་ q དེ་ཚད་ལྡན་ཡིན་ན་འཕུར་ཐུབ། (དེ་ནི་ཁ་དོག་གི་ཐོ་ཞིག་ཡིན།) སྐར་ཆ་ q ཡི་ཆ་ཤས་ཀྱི་གྲངས་ཐང་ནི་ w ཡི་ཚད་མཐོའི་ཚད་དང་མཚུངས་པའམ་དེ་ལས་ཆུང་བ་ཡིན་ན།    \/\/དངོས་པོ་ q འཕུར་ནས་འགྲོ་ཐུབ་ན་ true སླར་ལོག་བྱེད་པ་དང་གཞན་ན་ false སླར་ལོག་བྱེད་པའི་ལས་འགན་ཞིག་བྲིས་ཤིག    \/\/ >>> willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\n    \/\/ (false)\n    \/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n    \/\/ >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l))\n    \/\/ (false)\n    \/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n    \/\/ >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\n    \/\/ (true)\n    \/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n    \/\/ >>> willItFly((List[Long](3l.toLong)), (5l))\n    \/\/ (true)\n    \/\/ # 3 is less than the maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def willItFly(q: List[Long], w: Long): Boolean = {\n    val isPalindromic = q == q.reverse\n    val sumOfElements = q.sum\n    isPalindromic && sumOfElements <= w\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(willItFly(List[Long](1L, 2L), 5L)) \/\/ false\n    println(willItFly(List[Long](3L, 2L, 3L), 1L)) \/\/ false\n    println(willItFly(List[Long](3L, 2L, 3L), 9L)) \/\/ true\n    println(willItFly(List[Long](3L), 5L)) \/\/ true\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_73","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/ཕྱོགས་གཉིས་སུ་འདྲ་མཚུངས་ཀློག་ཐུབ། འགྱུར་བ་གཅིག་གི་ནང་ཁྱེད་རང་ཚོས་ཆ་ཤས་གཅིག་ལ་ཆ་ཤས་གཞན་ཞིག་ཏུ་བསྒྱུར་ཐུབ།    \/\/ཤོག་གྲངས་འདི་ལ་བསྒྱུར་བ་དགོས་ན་སྒྲོམ་དེ་ཁ་ཕྱོགས་ཀྱི་སྒྲོམ་ (palindromic) ཞིག་ཏུ་འགྱུར་ཐུབ།    \/\/སྐར་གྲངས་མཐའ་དག་གི་ཐོ་ཡིག་ arr ཞིག་ཡོད་ན། ཇི་འདྲ་ཡིན་པའི་ཉུང་མཐའི་གྲངས་ཀ་འཚོལ་དགོས།    \/\/ >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    \/\/ (4l)\n    \/\/ >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    \/\/ (1l)\n    \/\/ >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong)))\n    \/\/ (0l)\n    def smallestChange(arr : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Given a list arr of integers, find the minimum number of elements that\n  \/\/ need to be changed to make the list palindromic.\n\n  def smallestChange(arr: List[Long]): Long = {\n    var changes: Long = 0\n\n    for (i <- 0 until arr.length \/ 2) {\n      if (arr(i) != arr(arr.length - 1 - i)) {\n        changes += 1\n      }\n    }\n\n    changes\n  }\n\n  \/\/ Example usage\n  def main(args: Array[String]): Unit = {\n    println(smallestChange(List(1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L)))  \/\/ Output: 4\n    println(smallestChange(List(1L, 2L, 3L, 4L, 3L, 2L, 2L)))  \/\/ Output: 1\n    println(smallestChange(List(1L, 2L, 3L, 2L, 1L)))  \/\/ Output: 0\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong, 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    }\n\n}\n"},{"task_id":"HumanEval_74","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/གལ་ཏེ་ཡིག་འབྲུ་གྲངས་ཆ་འདྲ་ཡོད་ན་ཡིག་འབྲུ་དང་པོ་ཕྱིར་ལོག་བྱེད་དགོས།    \/\/ཤོག་གྲངས་ཀྱི་ཐོ་ཡིག་ནང་ཡོད་པའི་ཡིག་འབྲུ་ཚང་མའི་གྲངས་ནི་གཞན་གྱི་ཐོ་ཡིག་ལས་ཉུང་བ་རེད།    \/\/ཡིག་འབྲུ་གཉིས་དང་ཡིག་འབྲུ་ཡོད་ཚད་ཀྱི་ཐོ་ཡིག་ལེན་ནས་ ཡོད་པའི་ཐོ་ཡིག་ཕྱིར་ལོག་བྱེད་ function ཡིག་སྒྱུར་བྱོས།    \/\/ >>> totalMatch((List[String]()), (List[String]()))\n    \/\/ (List[String]())\n    \/\/ >>> totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"Hi\")))\n    \/\/ (List[String](\"hI\", \"Hi\"))\n    \/\/ >>> totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hi\", \"hi\", \"admin\", \"project\")))\n    \/\/ (List[String](\"hi\", \"admin\"))\n    \/\/ >>> totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"hi\", \"hi\")))\n    \/\/ (List[String](\"hI\", \"hi\", \"hi\"))\n    \/\/ >>> totalMatch((List[String](\"4\")), (List[String](\"1\", \"2\", \"3\", \"4\", \"5\")))\n    \/\/ (List[String](\"4\"))\n    def totalMatch(lst1 : List[String], lst2 : List[String]) : List[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def totalMatch(lst1: List[String], lst2: List[String]): List[String] = {\n    val sum1 = lst1.map(_.length).sum\n    val sum2 = lst2.map(_.length).sum\n    if (sum1 <= sum2) lst1 else lst2\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(totalMatch((List[String]()), (List[String]())).equals((List[String]())));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hi\", \"hi\"))).equals((List[String](\"hi\", \"hi\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hi\", \"hi\", \"admin\", \"project\"))).equals((List[String](\"hi\", \"admin\"))));\n    assert(totalMatch((List[String](\"4\")), (List[String](\"1\", \"2\", \"3\", \"4\", \"5\"))).equals((List[String](\"4\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"Hi\"))).equals((List[String](\"hI\", \"Hi\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"hi\", \"hi\"))).equals((List[String](\"hI\", \"hi\", \"hi\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"hi\", \"hii\"))).equals((List[String](\"hi\", \"admin\"))));\n    assert(totalMatch((List[String]()), (List[String](\"this\"))).equals((List[String]())));\n    assert(totalMatch((List[String](\"this\")), (List[String]())).equals((List[String]())));\n    }\n\n}\n"},{"task_id":"HumanEval_75","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/(a) ནི་ 100 ལས་ཆུང་བ་ཡིན་པར་ཤེས་པ་དགོས།    \/\/འདྲ་མིན་ལ་རྫུན་བཤད་ཀྱི་ཡོད།    \/\/གྲངས་གཞི་གྲངས་ནི་ 3 ཀྱི་གྲངས་གཞི་གྲངས་དང་མཚུངས་པ་ཡིན་ན་ true སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་བྲིས་ཤིག    \/\/ >>> isMultiplyPrime((30l))\n    \/\/ (true)\n    \/\/ 30 = 2 * 3 * 5\n    def isMultiplyPrime(a : Long) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def isMultiplyPrime(a: Long): Boolean = {\n    def isPrime(num: Long): Boolean = {\n      if (num <= 1) return false\n      if (num <= 3) return true\n      if (num % 2 == 0 || num % 3 == 0) return false\n      var i = 5\n      while (i * i <= num) {\n        if (num % i == 0 || num % (i + 2) == 0) return false\n        i += 6\n      }\n      true\n    }\n\n    val primes = (2L to 100L).filter(isPrime)\n    val primeList = primes.toList\n\n    for {\n      i <- primeList.indices\n      j <- i until primeList.size\n      k <- j until primeList.size\n      if primeList(i) * primeList(j) * primeList(k) == a\n    } return true\n\n    false\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isMultiplyPrime((5l)) == (false));\n    assert(isMultiplyPrime((30l)) == (true));\n    assert(isMultiplyPrime((8l)) == (true));\n    assert(isMultiplyPrime((10l)) == (false));\n    assert(isMultiplyPrime((125l)) == (true));\n    assert(isMultiplyPrime((105l)) == (true));\n    assert(isMultiplyPrime((126l)) == (false));\n    assert(isMultiplyPrime((729l)) == (false));\n    assert(isMultiplyPrime((891l)) == (false));\n    assert(isMultiplyPrime((1001l)) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_76","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/x ནི་ n གི་རྣམ་གྲངས་གཅིག་པུ་ཡིན་ན། n**int=x     \/\/ཤུགས་ n དང་ false གཞན་གྱི་གནས་སྟངས་ནང་    \/\/ཁྱོད་ཀྱི་ལས་འགན་ནི་གྲངས་ x ནི་གྲངས་རྐྱང་པ་ཡིན་ན་ true སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་འབྲི་དགོས་པ་ཡིན།    \/\/ >>> isSimplePower((1l), (4l))\n    \/\/ (true)\n    \/\/ >>> isSimplePower((2l), (2l))\n    \/\/ (true)\n    \/\/ >>> isSimplePower((8l), (2l))\n    \/\/ (true)\n    \/\/ >>> isSimplePower((3l), (2l))\n    \/\/ (false)\n    \/\/ >>> isSimplePower((3l), (1l))\n    \/\/ (false)\n    \/\/ >>> isSimplePower((5l), (3l))\n    \/\/ (false)\n    def isSimplePower(x : Long, n : Long) : Boolean = {\n","canonical_solution":"def isSimplePower(x: Long, n: Long): Boolean = {\n        if (n == 1) {\n            return x == 1\n        }\n        \n        var value: Long = n\n        while (value <= x) {\n            if (value == x) {\n                return true\n            }\n            \n            if (value > Long.MaxValue \/ n) {\n                return false\n            }\n            value *= n\n        }\n        \n        false\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l), (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l), (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n    assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l), (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_77","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/Note: ཁྱོད་ཀྱིས་གཏན་ནས་གཏན་ལ་ཕབ་པའི་ངེས་དོན་གཏན་ལ་ཕབ་ཐུབ།    \/\/གལ་ཏེ་འདི་ནི་ཨེན་ཇི་ཇར་ནི་ཨང་གྲངས་ཧྲིལ་པོ་ཅིག་གི་གྲུ་བཞི་ཡིན་ན།    \/\/གྲངས་ཧྲིལ་ a དང་ true སླར་ལོག་བྱེད་པའི་ལས་འགན་ཞིག་བྲིས་ཤིག    \/\/ >>> iscube((1l))\n    \/\/ (true)\n    \/\/ >>> iscube((2l))\n    \/\/ (false)\n    \/\/ >>> iscube((-1l))\n    \/\/ (true)\n    \/\/ >>> iscube((64l))\n    \/\/ (true)\n    \/\/ >>> iscube((0l))\n    \/\/ (true)\n    \/\/ >>> iscube((180l))\n    \/\/ (false)\n    def iscube(a : Long) : Boolean = {\n","canonical_solution":"def iscube(a: Long): Boolean = {\n  val cubeRoot = math.cbrt(a.toDouble).round\n  cubeRoot * cubeRoot * cubeRoot == a\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(iscube((1l)) == (true));\n    assert(iscube((2l)) == (false));\n    assert(iscube((-1l)) == (true));\n    assert(iscube((64l)) == (true));\n    assert(iscube((180l)) == (false));\n    assert(iscube((1000l)) == (true));\n    assert(iscube((0l)) == (true));\n    assert(iscube((1729l)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_78","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ཚོས་གཞི་ A,B,C,D,E,F འདི་ཚོ་རྒྱུན་དུ་ཡིག་ཆུང་ཡིན།    \/\/དྲན་གསོ། ཁྱོད་ཀྱིས་གཏན་ནས་ནང་འཇུག་དེ་བདེན་པའམ་སྟོང་པ་རེད་བསམ་ཐུབ།    \/\/B (= བཅུ་ཚིགས་ཀྱི་གྲངས་ཀ་ ༡༡) D (= བཅུ་ཚིགས་ཀྱི་གྲངས་ཀ་ ༡༣) ཡིན།    \/\/ཁྱོད་ཀྱིས་གཤམ་གསལ་ཨང་གྲངས་ཀྱི་གྲངས་ཀ་འདེམས་དགོས། ༢། ༣། ༥། ༧།     \/\/ཕྲ་གྲངས་ནི་ ༢། ༣། ༥། ༧། ༡༡། ༡༣། ༡༧། ...    \/\/༦གོང་མའི་ཨང་གྲངས་ནི་ ༠། ༡། ༢། ༣། ༤། ༥། ༦། ༧། ༨། ༩། A། B། C། D། E། F།    \/\/1ལས་མང་བ་འདི་ནི་གྲངས་ཆུང་བ་གཉིས་ལས་མང་བ་མ་ཡིན་)    \/\/གྲངས་ཆེན་ནི་རང་བྱུང་གྲངས་ཡིན།    \/\/༦ ཕྲེང་གྲངས་ནི་ string དང་གྲངས་རྩིས་ཀྱི་གྲངས་ཀ་ཡིན།    \/\/ཁྱོད་ཚོར་ཐོབ་པའི་ལས་འགན་ཞིག་འབྲི་དགོས་པའི་འགན་ཁུར་སྤྲད་ཡོད།    \/\/ >>> hexKey((\"AB\"))\n    \/\/ (1l)\n    \/\/ >>> hexKey((\"1077E\"))\n    \/\/ (2l)\n    \/\/ >>> hexKey((\"ABED1A33\"))\n    \/\/ (4l)\n    \/\/ >>> hexKey((\"123456789ABCDEF0\"))\n    \/\/ (6l)\n    \/\/ >>> hexKey((\"2020\"))\n    \/\/ (2l)\n    def hexKey(num : String) : Long = {\n","canonical_solution":"def hexKey(num: String): Long = {\n  val primeHexDigits = Set('2', '3', '5', '7', 'B', 'D')\n  num.count(ch => primeHexDigits.contains(ch)).toLong\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"},{"task_id":"HumanEval_79","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ཤོག་གྲངས་ཁ་སྐོང་ནི་ཡིག་གཟུགས་སྒྲིག་སྟངས་ལ་ཕན་ཐོགས་ཀྱི་ཆེད་དུ་ཡིན།    \/\/string གི་ཐོག་དང་མཇུག་ཏུ་ 'db' ཡིག་རྟགས་གཉིས་རེ་ལྷག་ཡོད།    \/\/string ནང་གི་ཡིག་འབྲུ་རེ་རེར་ '0' ཡང་ན་ '1' ཟེར་བ་ཡོད།    \/\/binary format. function གྱིས་ string སླར་ལོག་བྱེད་དགོས། ཕྲེང་བ་རེ་རེས་ binary  ཟེར་བ་མཚོན་དགོས།    \/\/ཁྱོད་ཚོར་བཅུ་གྲངས་ཀྱི་རྣམ་པ་ནས་གྲངས་ཤིག་ཐོབ་རྒྱུ་དང་ཁྱོད་ཀྱི་ལས་འགན་ནི་དེ་ ལ་བསྒྱུར་རྒྱུ་དེ་ཡིན།    \/\/ >>> decimalToBinary((15l))\n    \/\/ (\"db1111db\")\n    \/\/ >>> decimalToBinary((32l))\n    \/\/ (\"db100000db\")\n    def decimalToBinary(decimal : Long) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def decimalToBinary(decimal: Long): String = {\n    \"db\" + decimal.toBinaryString + \"db\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"},{"task_id":"HumanEval_80","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/string ནི་ hapscala ཡིན་ན། དེའི་རིང་ཚད་ནི་ཉུང་མཐར་ 3 ཡིན། ཡང་ 3 ཡི་གེ་རེ་རེ་ནི་སོ་སོར་ཁྱད་པར་ཡོད།    \/\/ཁྱོད་ཀྱི་ལས་འགན་ནི་ string འདི་ hapscala ཡིན་མིན་ལ་བརྟག་དཔྱད་བྱ་རྒྱུ་རེད།    \/\/ཚད་གཞི་དེ་ཁྱོད་ལ་ཐོབ་ཡོད།    \/\/ >>> isHappy((\"a\"))\n    \/\/ (false)\n    \/\/ >>> isHappy((\"aa\"))\n    \/\/ (false)\n    \/\/ >>> isHappy((\"abcd\"))\n    \/\/ (true)\n    \/\/ >>> isHappy((\"aabb\"))\n    \/\/ (false)\n    \/\/ >>> isHappy((\"adb\"))\n    \/\/ (true)\n    \/\/ >>> isHappy((\"xyy\"))\n    \/\/ (false)\n    def isHappy(s : String) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def isHappy(s: String): Boolean = {\n    if (s.length < 3) return false \n\n    for (i <- 0 until s.length - 2) {\n      if (s(i) == s(i + 1) || s(i) == s(i + 2) || s(i + 1) == s(i + 2)) {\n        return false\n      }\n    }\n    true\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isHappy((\"a\")) == (false));\n    assert(isHappy((\"aa\")) == (false));\n    assert(isHappy((\"abcd\")) == (true));\n    assert(isHappy((\"aabb\")) == (false));\n    assert(isHappy((\"adb\")) == (true));\n    assert(isHappy((\"xyy\")) == (false));\n    assert(isHappy((\"iopaxpoi\")) == (true));\n    assert(isHappy((\"iopaxioi\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_81","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/0.0 E     \/\/> 0.0 D-     \/\/> 0.7 D     \/\/> ༡.༠ D+     \/\/> 1.3 C-     \/\/> 1.7 C     \/\/> 2.0 C+     \/\/> 2.3 B-     \/\/> 2.7 B     \/\/> 3.0 B+     \/\/> 3.3 A-     \/\/> 3.7 A     \/\/4.0 A+     \/\/GPA སྐུགས་ཚད་ཨང་གྲངས་    \/\/ལས་འགན་འདི་ནས་ཡིག་རྟགས་ཀྱི་ཚད་གཞི་ཐོ་ཡིག་ཞིག་བཏོན་ཐུབ། དེའི་ནང་གཤམ་གསལ་ཐིག་ཁྲམ་འདི་ལག་ལེན་བྱ་ཐུབ།    \/\/ཕྲུག་གི་སློབ་ཕྲུག་འགའ་ཤས་ཀྱི་ GPA གྱི་ཐོ་ཡིག་ཁྱོད་ལ་སྤྲད་ཡོད། ཁྱོད་ཀྱིས་དེ་བྲིས་དགོས།    \/\/སྐྱོན་ནི་མོ་ལ་རྟགས་རྒྱག་སྐབས་བེད་སྤྱོད་བྱེད་པའི་ཡིག་རྟགས་དེ་ཤོར་སོང་བ་རེད།    \/\/སློབ་དཔོན་གྱིས་རང་རང་གི་ཚད་གཞི་བཟོ་བཞིན་ཡོད།    \/\/སློབ་དུས་ཀྱི་བདུན་ཕྲག་མཇུག་གི་ཉིན་མོ་ཡིན་པས་སློབ་དཔོན་གྱིས་སློབ་ཚན་གྱི་རྟགས་མ་སྤྲོད་དགོས་ཀྱི་འདུག    \/\/ >>> gradeEquation((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat)))\n    \/\/ (List[String](\"A+\", \"B\", \"C-\", \"C\", \"A-\"))\n    def numericalLetterGrade(grades : List[Float]) : List[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def numericalLetterGrade(grades: List[Float]): List[String] = {\n    grades.map { gpa =>\n      gpa match {\n        case g if g == 4.0 => \"A+\"\n        case g if g > 3.7 => \"A\"\n        case g if g > 3.3 => \"A-\"\n        case g if g > 3.0 => \"B+\"\n        case g if g > 2.7 => \"B\"\n        case g if g > 2.3 => \"B-\"\n        case g if g > 2.0 => \"C+\"\n        case g if g > 1.7 => \"C\"\n        case g if g > 1.3 => \"C-\"\n        case g if g > 1.0 => \"D+\"\n        case g if g > 0.7 => \"D\"\n        case g if g > 0.0 => \"D-\"\n        case _ => \"E\"\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val grades = List[Float](4.0f, 3.0f, 1.7f, 2.0f, 3.5f)\n    println(numericalLetterGrade(grades)) \/\/ Output: List(A+, B, C-, C, A-)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(numericalLetterGrade((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat))).equals((List[String](\"A+\", \"B\", \"C-\", \"C\", \"A-\"))));\n    assert(numericalLetterGrade((List[Float](1.2f.toFloat))).equals((List[String](\"D+\"))));\n    assert(numericalLetterGrade((List[Float](0.5f.toFloat))).equals((List[String](\"D-\"))));\n    assert(numericalLetterGrade((List[Float](0.0f.toFloat))).equals((List[String](\"E\"))));\n    assert(numericalLetterGrade((List[Float](1.0f.toFloat, 0.3f.toFloat, 1.5f.toFloat, 2.8f.toFloat, 3.3f.toFloat))).equals((List[String](\"D\", \"D-\", \"C-\", \"B\", \"B+\"))));\n    assert(numericalLetterGrade((List[Float](0.0f.toFloat, 0.7f.toFloat))).equals((List[String](\"E\", \"D-\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_82","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/length ནི་གྲངས་དང་པོ་ཡིན་པའམ་གཞན་ན་ false ཡིན་པ་ངེས་པ་མེད།    \/\/string ཞིག་ལེན་ནས་ true སླར་ལོག་བྱེད་རྒྱུའི་ལས་འགན་ཞིག་བྲིས་ན།    \/\/ >>> primeLength((\"Hello\"))\n    \/\/ (true)\n    \/\/ >>> primeLength((\"abcdcba\"))\n    \/\/ (true)\n    \/\/ >>> primeLength((\"kittens\"))\n    \/\/ (true)\n    \/\/ >>> primeLength((\"orange\"))\n    \/\/ (false)\n    def primeLength(string : String) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def primeLength(string: String): Boolean = {\n    val length = string.length\n\n    if (length <= 1) return false\n    \n    for (i <- 2 to sqrt(length).toInt) {\n      if (length % i == 0) return false\n    }\n    true\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(primeLength((\"Hello\")) == (true));\n    assert(primeLength((\"abcdcba\")) == (true));\n    assert(primeLength((\"kittens\")) == (true));\n    assert(primeLength((\"orange\")) == (false));\n    assert(primeLength((\"wow\")) == (true));\n    assert(primeLength((\"world\")) == (true));\n    assert(primeLength((\"MadaM\")) == (true));\n    assert(primeLength((\"Wow\")) == (true));\n    assert(primeLength((\"\")) == (false));\n    assert(primeLength((\"HI\")) == (true));\n    assert(primeLength((\"go\")) == (true));\n    assert(primeLength((\"gogo\")) == (false));\n    assert(primeLength((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(primeLength((\"Madam\")) == (true));\n    assert(primeLength((\"M\")) == (false));\n    assert(primeLength((\"0\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_83","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/འབྲས་བུ་ནི་ 1 དང་འགོ་བཟུང་བའམ་མཇུག་བསྡོམས་པའི་ཧྲིལ་གྲངས་ཡིན།    \/\/འབྲས་བུ་ལྡན་གྲངས་ n ཞིག་ཡོད་ན། ཨང་གྲངས་ n-digit གྱི་གྲངས་རྩིས་ཕྱིར་ལོག་བྱོས།    def startsOneEnds(n : Long) : Long = {\n","canonical_solution":"def startsOneEnds(n: Long): Long = {\n        if (n <= 0) return 0\n        \n        \/\/ Calculate numbers starting with 1: 1XX...X (n-1) digits after 1\n        val startWithOne: Long = math.pow(10, n - 1).toLong\n        \n        \/\/ Calculate numbers ending with 1: XX...X1 (n-1) digits before 1\n        \/\/ but without leading zeroes allowed, i.e., the first digit can't be zero\n        val endWithOne: Long = math.pow(10, n - 1).toLong\n        \n        \/\/ Reverse counting: numbers starting and ending with 1 (11XX...X)\n        val bothStartAndEndWithOne: Long = if (n > 1) math.pow(10, n - 2).toLong else 0\n        \n        \/\/ The total numbers starting or ending, or both, with 1\n        startWithOne + endWithOne - bothStartAndEndWithOne\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(startsOneEnds((1l)) == (1l));\n    assert(startsOneEnds((2l)) == (18l));\n    assert(startsOneEnds((3l)) == (180l));\n    assert(startsOneEnds((4l)) == (1800l));\n    assert(startsOneEnds((5l)) == (18000l));\n    }\n\n}\n"},{"task_id":"HumanEval_84","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/འབྲས་བུ་ཆ་མཉམ་ N བྱིན་ནས་དེའི་ཨང་གྲངས་ཀྱི་བསྡོམས་གྲངས་ཉིས་ལྡན་དུ་ཕྱིར་ལོག་འབད།    \/\/ >>> solve((1000l))\n    \/\/ (\"1\")\n    \/\/ >>> solve((150l))\n    \/\/ (\"110\")\n    \/\/ >>> solve((147l))\n    \/\/ (\"1100\")\n    \/\/ Variables:\n    \/\/ @N integer\n    \/\/ Constraints: 0 ≤ N ≤ 10000.\n    \/\/ Output:\n    \/\/ a string of binary number\n    def solve(N : Long) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ Given a positive integer N, return the total sum of its digits in binary.\n    def solve(N: Long): String = {\n        val sumOfDigits = N.toString.map(_.asDigit).sum\n        sumOfDigits.toBinaryString\n    }\n\n    def main(args: Array[String]): Unit = {\n        println(solve(1000L))  \/\/ should print \"1\"\n        println(solve(150L))   \/\/ should print \"110\"\n        println(solve(147L))   \/\/ should print \"1100\"\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"},{"task_id":"HumanEval_85","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/སྟོང་པ་མིན་པའི་གྲངས་ཆ་གྲངས་ཐོ་ཞིག་ཡོད་ན། ཐོག་མར་གྲངས་ཆ་ཆ་སྙོམས་དང་གྲངས་ཆ་ཆ་མི་འདྲ་བ་རྣམས་བསྡོམས་དགོས།    \/\/ >>> add((List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)))\n    \/\/ (2l)\n    def add(lst : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Given a non-empty list of integers lst. add the even elements that are at odd indices.\n  def add(lst: List[Long]): Long = {\n    lst.zipWithIndex.collect {\n      case (value, index) if index % 2 == 1 && value % 2 == 0 => value\n    }.sum\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(add((List[Long](4l.toLong, 88l.toLong))) == (88l));\n    assert(add((List[Long](4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 2l.toLong, 122l.toLong))) == (122l));\n    assert(add((List[Long](4l.toLong, 0l.toLong, 6l.toLong, 7l.toLong))) == (0l));\n    assert(add((List[Long](4l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))) == (12l));\n    }\n\n}\n"},{"task_id":"HumanEval_86","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/དྲན་གསོ། ཁྱོད་ཀྱིས་ཚིག་དང་སྟོང་པ་རིམ་བཞིན་བཞག་དགོས་པ་ཡིན།    \/\/ཚད་གཞི་གཞི་ཐོག་ཡར་འགྲོ་གི་རིམ་པ་    \/\/ཀྱི་ནང་ཡོད་པའི་ཡིག་འབྲུ་ཚང་མ་འདེམས་པའི་ཚིག་གསར་པ་ཞིག་གིས་ཚབ་ཏུ་འཇུག་དགོས།    \/\/ordered version of string འདི་ནང་ཚིག་ཆ་ཚང་མ་ (བར་སྟོང་གིས་སོ་སོར་དབྱེ་) ཡོད་པའི་ string ཞིག་ཡིན།    \/\/ཚད་གཞི་ཅིག་ལེན་ཏེ་ དེའི་རིམ་པ་སྒྲིག་པའི་རྣམ་པ་ཅིག་སླར་ལོག་འབད་ནིའི་ལས་འགན་ཅིག་འབྲི་དགོས།    \/\/ >>> antiShuffle((\"Hi\"))\n    \/\/ (\"Hi\")\n    \/\/ >>> antiShuffle((\"hello\"))\n    \/\/ (\"ehllo\")\n    \/\/ >>> antiShuffle((\"Hello World!!!\"))\n    \/\/ (\"Hello !!!Wdlor\")\n    def antiShuffle(s : String) : String = {\n","canonical_solution":"import scala.collection.mutable.ArrayBuffer\n\nobject Problem {\n  def antiShuffle(s: String): String = {\n    val words = s.split(\"(?<=\\\\s)\")\n    val sortedWords = words.map(word => {\n      val trimmedWord = word.trim\n      val sortedChars = trimmedWord.sorted\n      word.replace(trimmedWord, sortedChars)\n    })\n    sortedWords.mkString(\"\")\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(antiShuffle(\"Hi\"))\n    println(antiShuffle(\"hello\"))\n    println(antiShuffle(\"Hello World!!!\"))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(antiShuffle((\"Hi\")).equals((\"Hi\")));\n    assert(antiShuffle((\"hello\")).equals((\"ehllo\")));\n    assert(antiShuffle((\"number\")).equals((\"bemnru\")));\n    assert(antiShuffle((\"abcd\")).equals((\"abcd\")));\n    assert(antiShuffle((\"Hello World!!!\")).equals((\"Hello !!!Wdlor\")));\n    assert(antiShuffle((\"\")).equals((\"\")));\n    assert(antiShuffle((\"Hi. My name is Mister Robot. How are you?\")).equals((\".Hi My aemn is Meirst .Rboot How aer ?ouy\")));\n    }\n\n}\n"},{"task_id":"HumanEval_87","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/དེ་མིན་གྲལ་རིམ་གྱི་གོ་རིམ་རིམ་རིམ་བཞིན་གྲལ་རིམ་གྱི་གོ་རིམ་རིམ་སྒྲིག་དགོས།    \/\/ཐོག་མར་གོ་རིམ་ཡར་རྒྱས་ཀྱི་རིམ་པ་བཞིན་གོ་རིམ་སྒྲིག་དགོས།    \/\/ཐིག་ཁྲམ་རེ་རེའི་ནང་ 0 ལས་འགོ་ཚུགས་པའི་ ཚད་གཞིའི་ (row, columns) ཞིག་ཡོད།    \/\/འདྲེས་པའི་ཐིག་ཁྲམ་སླར་ལོག་བྱེད། [(x1, y1), (x2, y2) ...] འདི་ལྟར་ཡིན་ན།     \/\/lst དང་ཧྲིལ་གྲངས་ x ཟེར་བ་ཡོད་ན། ཤོག་གྲངས་ཀྱི་ནང་ཧྲིལ་གྲངས་ x འཚོལ་དགོས།    \/\/གྲལ་ཐིག་རེ་རེར་ཀ་བའི་གྲངས་མི་འདྲ་བ་ཡོད་སྲིད་དོ།    \/\/ཇི་ནི་མ་ཊི་རེས་དང་འདྲ་བ་ཞིག་ཡིན། མ་ཊི་རེས་དང་མི་འདྲ་བ་ཞིག་ཡིན།    \/\/ཁྱོད་ཚོར་ཚད་གཉིས་ཀྱི་ཡིག་ཆ་ཞིག་སྤྲོད་ཀྱི་ཡོད། ཚད་གཉིས་ཀྱི་ཡིག་ཆ་དེ་སྦྲེལ་ཡོད་པའི་ཐོ་ཡིག་ལྟ་བུ་ཡིན།    \/\/ >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    \/\/ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    \/\/ >>> getRow((List[List[Long]]()), (1l))\n    \/\/ (List[Tuple2[Long, Long]]())\n    \/\/ >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n    \/\/ (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]], x : Long) : List[Tuple2[Long, Long]] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def getRow(lst: List[List[Long]], x: Long): List[(Long, Long)] = {\n    val coordinates = for {\n      (row, rowIndex) <- lst.zipWithIndex\n      (value, colIndex) <- row.zipWithIndex\n      if value == x\n    } yield (rowIndex.toLong, colIndex.toLong)\n\n    coordinates\n      .groupBy(_._1)\n      .toList\n      .sortBy(_._1)\n      .flatMap { case (rowIndex, coords) =>\n        coords.sortBy(-_._2)\n      }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()), (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long, Long]]((2l, 2l)))));\n    }\n\n}\n"},{"task_id":"HumanEval_88","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/* ཤོག་ངོས་འདི་ལ་བསྒྱུར་བཅོས་མ་བྱེད།    \/\/དྲན་གསོ།    \/\/ཡང་ན་བསྡོམས་ ((སྔོན་མའི་ཚད་གཞི་གནས་གོང་དང་རྗེས་མའི་ཚད་གཞི་གནས་གོང་) རྣམས་ཆ་སྙོམས་ཡིན་ན་རིམ་པ་མར་བབས་ནས་དབྱེ་བ་བྱེད་དགོས།    \/\/ཁྱོད་ཀྱིས་གོ་རིམ་ཡར་རྒྱས་ཀྱི་རིམ་པ་བཞིན་ཐོ་ཡིག་དེ་དབྱེ་ན། བསྡོམས་ (ཐོག་མའི་ཚད་གཞི་རིན་གོང་དང་མཐའ་མའི་ཚད་གཞི་རིན་གོང་) ཇི་འདྲ་ཡིན་ན།    \/\/ཤོག་གྲངས་ཆ་མེད་མིན་པའི་གྲངས་ཆ་མཉམ་གྱི་ཐོ་ཡིག་ཤིག་ཡོད་ན། ཚད་གཞི་དེ་རིམ་སྒྲིག་བྱས་རྗེས་ཡིག་ཆ་དེ་ཕྱིར་ལོག་བྱེད་པ།    \/\/ >>> sortArray((List[Long]()))\n    \/\/ (List[Long]())\n    \/\/ >>> sortArray((List[Long](5l.toLong)))\n    \/\/ (List[Long](5l.toLong))\n    \/\/ >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    \/\/ (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    \/\/ >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    \/\/ (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def sortArray(array: List[Long]): List[Long] = {\n    if (array.isEmpty) {\n      array\n    } else {\n      val first = array.head\n      val last = array.last\n      val sum = first + last\n      if (sum % 2 == 0) {\n        array.sorted(Ordering[Long].reverse)\n      } else {\n        array.sorted\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(sortArray(List[Long]())) \/\/ (List[Long]())\n    println(sortArray(List[Long](5L))) \/\/ (List[Long](5L))\n    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L))) \/\/ (List[Long](0L, 1L, 2L, 3L, 4L, 5L))\n    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L, 6L))) \/\/ (List[Long](6L, 5L, 4L, 3L, 2L, 1L, 0L))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_89","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/ཕྱོགས་གཉིས་སུ་སྤོ་དགོས།    \/\/ཤོག་ངོས་འདི་ཡི་བཟོ་བཅོས་མཐའ་མ་༢༩༩༩ལ་འགྲུབ།    \/\/ཕྱིར་ལོག་བྱེད་དེ་ཨང་ཡིག་བསྒྱུར་བའི་ནང་ཨང་ཡིག་སྦྲེལ་བ་ཞིག་ཡིན།    \/\/ལས་འགན་ཞིག་བཟོ་ནས་རྟགས་མཚན་ལྟར་ཐིག་ཡིག་ཅིག་ལེན་ནས་     \/\/ >>> encrypt((\"hi\"))\n    \/\/ (\"lm\")\n    \/\/ >>> encrypt((\"asdfghjkl\"))\n    \/\/ (\"ewhjklnop\")\n    \/\/ >>> encrypt((\"gf\"))\n    \/\/ (\"kj\")\n    \/\/ >>> encrypt((\"et\"))\n    \/\/ (\"ix\")\n    def encrypt(s : String) : String = {\n","canonical_solution":"def encrypt(s: String): String = {\n  s.map(c => {\n    val rotatedChar = (c - 'a' + 4) % 26 + 'a'\n    rotatedChar.toChar\n  })\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\")).equals((\"e\")));\n    }\n\n}\n"},{"task_id":"HumanEval_90","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/འདྲ་མཉམ་མེད་ན་ None སླར་ལོག་བྱེད།    \/\/ཤོག་གྲངས་གཉིས་པ་ཆུང་ཤོས་ཀྱི་གྲངས་ཀ་ལོག་འཇུག་པའི་ function next_smallest () ཡིག་སྒྱུར་བྱོས།    \/\/ཁྱོད་ཚོར་གྲངས་ཆ་ཆ་ཚང་གི་ཐོ་ཡིག་ཐོབ་ཡོད།    \/\/ >>> nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\n    \/\/ Some(2l)\n    \/\/ >>> nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong)))\n    \/\/ Some(2l)\n    \/\/ >>> nextSmallest((List[Long]()))\n    \/\/ None\n    \/\/ >>> nextSmallest((List[Long](1l.toLong, 1l.toLong)))\n    \/\/ None\n    def nextSmallest(lst : List[Long]) : Option[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def nextSmallest(lst: List[Long]): Option[Long] = {\n    if (lst.size < 2) return None\n\n    val distinctSorted = lst.distinct.sorted\n    if (distinctSorted.size < 2) None\n    else Some(distinctSorted(1))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals(Some(2l)));\n    assert(nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong))).equals(Some(2l)));\n    assert(nextSmallest((List[Long]())).equals(None));\n    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));\n    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(1l)));\n    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));\n    assert(nextSmallest((List[Long](-35l.toLong, 34l.toLong, 12l.toLong, -45l.toLong))).equals(Some(-35l)));\n    }\n\n}\n"},{"task_id":"HumanEval_91","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/ཚིག་ཡིག་ལ་མཐའ་མཚམས་སུ་ \"\", \"?\" ཡང་ན་ \"!\" ཟེར་བ་ཡོད།    \/\/རྒྱུད་ཀྱི་འདུ་ཤེས་ནི་ \"ང་\" ཟེར་ནས་འགོ་འཛུགས་པའི་ཚིག་ཡིན།    \/\/ཁྱོད་ཚོར་ཚིག་གྲངས་ཤིག་སྤྲད་ནས་ཁྱོད་རྣམས་ཀྱི་ལས་འགན་ནི་གྲངས་རྩིས་རྒྱག་རྒྱུ་རེད།    \/\/ >>> isBored((\"Hello world\"))\n    \/\/ (0l)\n    \/\/ >>> isBored((\"The sky is blue. The sun is shining. I love this weather\"))\n    \/\/ (1l)\n    def isBored(S : String) : Long = {\n","canonical_solution":"def isBored(S: String): Long = {\n    \/\/ Split the input string into sentences using '.', '?' or '!' as delimiters\n    val sentences = S.split(\"[.!?]\").map(_.trim)\n\n    \/\/ Filter sentences that start with 'I' and count them\n    sentences.count(sentence => sentence.startsWith(\"I\"))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isBored((\"Hello world\")) == (0l));\n    assert(isBored((\"Is the sky blue?\")) == (0l));\n    assert(isBored((\"I love It !\")) == (1l));\n    assert(isBored((\"bIt\")) == (0l));\n    assert(isBored((\"I feel good today. I will be productive. will kill It\")) == (2l));\n    assert(isBored((\"You and I are going for a walk\")) == (0l));\n    }\n\n}\n"},{"task_id":"HumanEval_92","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/གཞན་གནས་སྟངས་གང་རུང་དུ་ false སླར་ལོག་བྱེད།    \/\/གྲངས་ཆ་གཅིག་ནི་གཞན་གཉིས་གྱི་བསྡོམས་དང་མཚུངས་པ་ཡིན་ན་ true སླར་ལོག་བྱེད། གྲངས་ཆ་ཚང་མ་ནི་ཧྲིལ་པོ་ཡིན།    \/\/གྲངས་ 3 ཅན་གྱི་ལས་འགན་ཞིག་བཟོས་པ།    \/\/ >>> anyInt(5l, 2l, 7l)\n    \/\/ (true)\n    \/\/ >>> anyInt(3l, 2l, 2l)\n    \/\/ (false)\n    \/\/ >>> anyInt(3l, -2l, 1l)\n    \/\/ (true)\n    \/\/ >>> anyInt((3.6f), (-2.2f), 2l)\n    \/\/ (false)\n    def anyInt(x : Float, y : Float, z : Float) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \/\/ Create a function that takes 3 numbers.\n  \/\/ Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  \/\/ Returns false in any other cases.\n  def anyInt(x: Float, y: Float, z: Float): Boolean = {\n    val xLong = x.toLong\n    val yLong = y.toLong\n    val zLong = z.toLong\n\n    \/\/ Check if all inputs are actually integers\n    if (xLong == x && yLong == y && zLong == z) {\n      return xLong + yLong == zLong || xLong + zLong == yLong || yLong + zLong == xLong\n    }\n    false\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(anyInt(2l, 3l, 1l) == (true));\n    assert(anyInt((2.5f), 2l, 3l) == (false));\n    assert(anyInt((1.5f), 5l, (3.5f)) == (false));\n    assert(anyInt(2l, 6l, 2l) == (false));\n    assert(anyInt(4l, 2l, 2l) == (true));\n    assert(anyInt((2.2f), (2.2f), (2.2f)) == (false));\n    assert(anyInt(-4l, 6l, 2l) == (true));\n    assert(anyInt(2l, 1l, 1l) == (true));\n    assert(anyInt(3l, 4l, 7l) == (true));\n    assert(anyInt((3.0f), 4l, 7l) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_93","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ཡིག་འབྲུ་ཙམ་གྱིས་འཛིན་དགོས།    \/\/ཨིང་ལིཤ་ཡི་གེ་ནང་གི་སྒྲ་སྒྲ་ཡིན།    \/\/ཤོག་ངོས་འདི་ཡི་བཟོ་བཅོས་མཐའ་མ་༢ ནང་ལ་སྔར་གྱི་ནང་དོན་གསལ།    \/\/ཀྱི་ནང་གི་སྒྲ་དབྱངས་ཚང་མ་བརྗེ་སྒྱུར་བྱེད་པ།    \/\/འདྲ་བའི་འཕྲིན་ཡིག་ཞིག་ལེན་ནས་དེའི་ནང་ཡིག་རྟགས་བཀོད་པའི་ function ཞིག་འབྲི་དགོས།    \/\/ >>> encode((\"test\"))\n    \/\/ (\"TGST\")\n    \/\/ >>> encode((\"This is a message\"))\n    \/\/ (\"tHKS KS C MGSSCGG\")\n    def encode(message : String) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def encode(message: String): String = {\n    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n    val vowelMap = Map(\n      'a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w',\n      'A' -> 'C', 'E' -> 'G', 'I' -> 'K', 'O' -> 'Q', 'U' -> 'W'\n    )\n    \n    message.map { char =>\n      if (vowels.contains(char)) {\n        vowelMap(char)\n      } else if (char.isLetter) {\n        if (char.isLower) char.toUpper else char.toLower\n      } else {\n        char\n      }\n    }.mkString\n  }\n\n  \/\/ Test cases\n  def main(args: Array[String]): Unit = {\n    println(encode(\"test\"))            \/\/ should print \"TGST\"\n    println(encode(\"This is a message\")) \/\/ should print \"tHKS KS C MGSSCGG\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"},{"task_id":"HumanEval_94","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ཁྱོད་ཀྱིས་ཆེ་མཐའི་སྔོན་གྲངས་འཚོལ་དགོས་པ་དང་དེའི་ཨང་གྲངས་ཀྱི་བསྡོམས་ཕྱིར་ལོག་དགོས།    \/\/ཁྱོད་ཚོར་གྲངས་ཆ་ཆ་ཚང་གི་ཐོ་ཡིག་ཐོབ་ཡོད།    \/\/ >>> skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))\n    \/\/ (10l)\n    \/\/ >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))\n    \/\/ (25l)\n    \/\/ >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong)))\n    \/\/ (13l)\n    \/\/ >>> skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))\n    \/\/ (11l)\n    \/\/ >>> skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong)))\n    \/\/ (3l)\n    \/\/ >>> skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong)))\n    \/\/ (7l)\n    def skjkasdkd(lst : List[Long]) : Long = {\n","canonical_solution":"def skjkasdkd(lst: List[Long]): Long = {\n  def isPrime(n: Long): Boolean = {\n    if (n <= 1) false\n    else if (n == 2) true\n    else if (n % 2 == 0) false\n    else !(3L to math.sqrt(n).toLong by 2).exists(n % _ == 0)\n  }\n\n  def sumOfDigits(n: Long): Long = n.toString.map(_.asDigit).sum\n\n  val largestPrime = lst.filter(isPrime).sorted.lastOption.getOrElse(0L)\n  sumOfDigits(largestPrime)\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong))) == (10l));\n    assert(skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong))) == (25l));\n    assert(skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong))) == (13l));\n    assert(skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong))) == (11l));\n    assert(skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong))) == (3l));\n    assert(skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong))) == (7l));\n    assert(skjkasdkd((List[Long](8191l.toLong))) == (19l));\n    assert(skjkasdkd((List[Long](8191l.toLong, 123456l.toLong, 127l.toLong, 7l.toLong))) == (19l));\n    assert(skjkasdkd((List[Long](127l.toLong, 97l.toLong, 8192l.toLong))) == (10l));\n    }\n\n}\n"},{"task_id":"HumanEval_95","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ལས་འགན་འདི་ false སླར་ལོག་བྱེད་དགོས། གལ་ཏེ་གཞི་ཁྲམ་འདི་སྟོང་པ་ཡོད་ན་    \/\/ཚད་ལྡན་ཡིག་རྟགས་གང་རུང་ནི་ string ཡིན། གལ་ཏེ་ཚད་ལྡན་ཡིག་རྟགས་གང་རུང་ནི་ string ཡིན། ཚད་ལྡན་ཡིག་རྟགས་གང་རུང་ནི་ string ཡིན། གལ་ཏེ་ཚད་ལྡན་ཡིག་རྟགས་གང་རུང་ནི་ string ཡིན། ཚད་ལྡན་ཡིག་རྟགས་གང་རུང་ནི་ string ཡིན།    \/\/ཚད་གཞི་འདི་ནི་གཞི་ཁྲམ་ཞིག་ཡིན་ན། ཚད་གཞི་ཚང་མ་ནི་ lower  ནང་གི་ཡིག་འབྲུ་ཡིན་ན་ true སླར་ལོག་བྱེད།    \/\/ >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    \/\/ (true)\n    \/\/ >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    \/\/ (false)\n    \/\/ >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    \/\/ (false)\n    \/\/ >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    \/\/ (false)\n    \/\/ >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    \/\/ (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def checkDictCase(dict: Map[String, String]): Boolean = {\n    if (dict.isEmpty) return false\n\n    val keys = dict.keys.toList\n    val allLowerCase = keys.forall(key => key == key.toLowerCase)\n    val allUpperCase = keys.forall(key => key == key.toUpperCase)\n\n    allLowerCase || allUpperCase\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_96","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/གྲངས་ཚོམ་དང་ n ལས་ཆུང་བ་དག་གི་གྲངས་ཚོམ་ཡིན།    \/\/འབྲས་བུ་མེད་པའི་གྲངས་ཀ་ཆ་ཚང་ཞིག་ལེན་ནས་ཐོག་མའི་གྲངས་ཀ་ n   ཀྱི་ཐོ་ཡིག་ཕྱིར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་ལག་བསྟར་བྱ་དགོས།    \/\/ >>> countUpTo((5l))\n    \/\/ (List[Long](2l.toLong, 3l.toLong))\n    \/\/ >>> countUpTo((11l))\n    \/\/ (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    \/\/ >>> countUpTo((0l))\n    \/\/ (List[Long]())\n    \/\/ >>> countUpTo((20l))\n    \/\/ (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    \/\/ >>> countUpTo((1l))\n    \/\/ (List[Long]())\n    \/\/ >>> countUpTo((18l))\n    \/\/ (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n","canonical_solution":"def countUpTo(n: Long): List[Long] = {\n    def isPrime(num: Long): Boolean = {\n      if (num < 2) return false\n      for (i <- 2L to math.sqrt(num).toLong) {\n        if (num % i == 0) return false\n      }\n      true\n    }\n\n    (2L until n).filter(isPrime).map(_.toLong).toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_97","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ནང་འཇུག་གཏན་ལ་ཕབ་ནས་གཏན་ལ་ཕབ་དགོས།    \/\/ཚད་ལྡན་ཨང་གྲངས་ཀྱི་འབྲས་བུ་ཡིན།    \/\/འབྲས་བུ་གྲངས་ཆ་གཉིས་ལེན་པའི་ function ཆ་ཚང་སྒྲིལ་ནས་ཕྱིར་ལོག་བྱེད་པ།    \/\/ >>> multiply((148l), (412l))\n    \/\/ (16l)\n    \/\/ >>> multiply((19l), (28l))\n    \/\/ (72l)\n    \/\/ >>> multiply((2020l), (1851l))\n    \/\/ (0l)\n    \/\/ >>> multiply((14l), (-15l))\n    \/\/ (20l)\n    def multiply(a : Long, b : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def multiply(a: Long, b: Long): Long = {\n        val unitDigitA = abs(a % 10)\n        val unitDigitB = abs(b % 10)\n        unitDigitA * unitDigitB\n    }\n\n    def main(args: Array[String]): Unit = {\n        println(multiply(148l, 412l))  \/\/ 16l\n        println(multiply(19l, 28l))    \/\/ 72l\n        println(multiply(2020l, 1851l)) \/\/ 0l\n        println(multiply(14l, -15l))   \/\/ 20l\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n"},{"task_id":"HumanEval_98","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/string s ཤིག་ཡོད་ན། ཆེ་ཆུང་གི་སྒྲ་སྒྲ་གྲངས་རྩིས་ཤིག    \/\/ >>> countUpper((\"aBCdEf\"))\n    \/\/ (1l)\n    \/\/ >>> countUpper((\"abcdefg\"))\n    \/\/ (0l)\n    \/\/ >>> countUpper((\"dBBE\"))\n    \/\/ (0l)\n    def countUpper(s : String) : Long = {\n","canonical_solution":"def countUpper(s: String): Long = {\n  val uppercaseVowels = Set('A', 'E', 'I', 'O', 'U')\n  s.zipWithIndex.collect {\n    case (ch, index) if index % 2 == 0 && uppercaseVowels.contains(ch) => ch\n  }.size.toLong\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(countUpper((\"aBCdEf\")) == (1l));\n    assert(countUpper((\"abcdefg\")) == (0l));\n    assert(countUpper((\"dBBE\")) == (0l));\n    assert(countUpper((\"B\")) == (0l));\n    assert(countUpper((\"U\")) == (1l));\n    assert(countUpper((\"\")) == (0l));\n    assert(countUpper((\"EEEE\")) == (2l));\n    }\n\n}\n"},{"task_id":"HumanEval_99","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/འབྲས་བུ་འདི་ནི་གྲངས་ཆ་གཉིས་ལས་ 0 ཀྱི་མཐའ་འཁོར་དུ་འཁོར་བ་ཡིན།    \/\/གྲངས་ཀ་ཉེར་མཁོ་ཡོད་ན་ ཚད་ལྡན་གྲངས་ཀ་ཉེར་མཁོ་ཡོད་ན་ ཚད་ལྡན་གྲངས་ཀ་ཉེར་མཁོ་ཡོད་ན་ ཚད་ལྡན་གྲངས་ཀ་ཉེར་མཁོ་ཡོད་ན་    \/\/གྲངས་ཐང་ (string) ཞིག་ངོས་འཛིན་བྱ་བའི་ལས་འགན་ཞིག་བཟོ།    \/\/ >>> closestInteger((\"10\"))\n    \/\/ (10l)\n    \/\/ >>> closestInteger((\"15.3\"))\n    \/\/ (15l)\n    \/\/ Note:\n    \/\/ Rounding away from zero means that if the given number is equidistant\n    \/\/ from two integers, the one you should return is the one that is the\n    \/\/ farthest from zero. For example closest_integer(\"14.5\") should\n    \/\/ return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def closestInteger(value: String): Long = {\n    val num = value.toDouble\n    val lower = floor(num).toLong\n    val upper = ceil(num).toLong\n    \n    if (abs(num - lower) == abs(num - upper)) {\n      if (num > 0) upper else lower\n    } else {\n      round(num)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(closestInteger(\"10\"))  \/\/ 10\n    println(closestInteger(\"15.3\")) \/\/ 15\n    println(closestInteger(\"14.5\")) \/\/ 15\n    println(closestInteger(\"-14.5\")) \/\/ -15\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"},{"task_id":"HumanEval_100","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/i ནི་ཚད་ (i+1) ནང་གི་རྡོ་གྲངས་མཚོན་པ་ཡིན།    \/\/ཚད་གཞི་ནང་ཡོད་པའི་རྡོའི་གྲངས་ཁ་སླར་ལོག་འབདཝ་ཨིན།    \/\/- རྗེས་སུ་ཡོད་པའི་གྲངས་ཆ་ཆ་ཡིན་ན། n ནི་ཆ་ཆ་ཡིན་ན།    \/\/- རྗེས་སུ་ཡོད་པའི་གྲངས་ཆ་རྐྱང་པ་ n ནི་གྲངས་ཆ་རྐྱང་པ་ཡིན་ན་    \/\/ཤུལ་མའི་གནས་ཚད་ནང་རྡོ་གྲངས་ནི་:    \/\/ཐོག་མར་རྡོ་ n ཡིན།    \/\/གྲངས་ཧྲིལ་པོ་ n ཞིག་ཡོད་ན། རྡོ་རིང་གི་ཚད་ n ཡི་རྡོ་བྲིས་དགོས།    \/\/ >>> makeAPile((3l))\n    \/\/ (List[Long](3l.toLong, 5l.toLong, 7l.toLong))\n    def makeAPile(n : Long) : List[Long] = {\n","canonical_solution":"import scala.collection.mutable.ListBuffer\n\nobject Problem {\n    def makeAPile(n: Long): List[Long] = {\n        val pile = ListBuffer[Long]()\n        var currentStones = n\n        for (_ <- 0 until n.toInt) {\n            pile += currentStones\n            currentStones += (if (currentStones % 2 == 0) 2 else 2)\n        }\n        pile.toList\n    }\n\n    def main(args: Array[String]): Unit = {\n        val result = makeAPile(3L)\n        println(result)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(makeAPile((3l)).equals((List[Long](3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(makeAPile((4l)).equals((List[Long](4l.toLong, 6l.toLong, 8l.toLong, 10l.toLong))));\n    assert(makeAPile((5l)).equals((List[Long](5l.toLong, 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));\n    assert(makeAPile((6l)).equals((List[Long](6l.toLong, 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));\n    assert(makeAPile((8l)).equals((List[Long](8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_101","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/string འདི་ཚིག་གི་ཆ་ཤས་སུ་བགོས་ནས་ཚིག་གི་ཐོ་ཡིག་ཕྱིར་ལོག་བྱེད་པ།    \/\/ཁྱོད་ཚོར་ཚིག་ཡིག་གི་རིམ་པ་སྤྲོད་རྒྱུ་རེད། རྒྱུན་དང་བར་སྟོང་གིས་སོ་སོར་དབྱེ་དགོས། ཁྱོད་ཀྱི་ལས་འགན་ནི་    \/\/ >>> wordsString((\"Hi, my name is John\"))\n    \/\/ (List[String](\"Hi\", \"my\", \"name\", \"is\", \"John\"))\n    \/\/ >>> wordsString((\"One, two, three, four, five, six\"))\n    \/\/ (List[String](\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))\n    def wordsString(s : String) : List[String] = {\n","canonical_solution":"def wordsString(s: String): List[String] = {\n    s.split(\"[, ]+\").toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(wordsString((\"Hi, my name is John\")).equals((List[String](\"Hi\", \"my\", \"name\", \"is\", \"John\"))));\n    assert(wordsString((\"One, two, three, four, five, six\")).equals((List[String](\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))));\n    assert(wordsString((\"Hi, my name\")).equals((List[String](\"Hi\", \"my\", \"name\"))));\n    assert(wordsString((\"One,, two, three, four, five, six,\")).equals((List[String](\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))));\n    assert(wordsString((\"\")).equals((List[String]())));\n    assert(wordsString((\"ahmed     , gamal\")).equals((List[String](\"ahmed\", \"gamal\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_102","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/གྲངས་ཀ་དེ་མེད་ན་ function དེ་ -1 སླར་ལོག་བྱེད་དགོས།    \/\/ཚད་ [x, y] ནང་གི་གྲངས་ཆ་ཚག་གྲངས་ཆེ་ཤོས་ཡིན་ན།    \/\/ལས་འགན་འདི་ནི་གྲངས་ཆ་ལྡོག་པ་གཉིས་ x དང་ y དང་ཕྱིར་ལོག་བྱེད་གྲངས་ཐང་ཡིན།    \/\/ >>> chooseNum((12l), (15l))\n    \/\/ (14l)\n    \/\/ >>> chooseNum((13l), (12l))\n    \/\/ (-1l)\n    def chooseNum(x : Long, y : Long) : Long = {\n","canonical_solution":"def chooseNum(x: Long, y: Long): Long = {\n    \/\/ Ensure x is the lesser value and y is the greater value\n    val (start, end) = if (x > y) (y, x) else (x, y)\n    \n    \/\/ Start from the end of the range and search backwards for an even number\n    for (i <- end to start by -1 if i % 2 == 0) {\n      return i\n    }\n    \n    \/\/ If no even number is found, return -1\n    -1\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(chooseNum((12l), (15l)) == (14l));\n    assert(chooseNum((13l), (12l)) == (-1l));\n    assert(chooseNum((33l), (12354l)) == (12354l));\n    assert(chooseNum((5234l), (5233l)) == (-1l));\n    assert(chooseNum((6l), (29l)) == (28l));\n    assert(chooseNum((27l), (10l)) == (-1l));\n    assert(chooseNum((7l), (7l)) == (-1l));\n    assert(chooseNum((546l), (546l)) == (546l));\n    }\n\n}\n"},{"task_id":"HumanEval_103","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/གལ་ཏེ་ n ནི་ m ལས་ཆེ་བ་ཡིན་ན་ -1 སླར་ལོག་བྱེད་དགོས།    \/\/དེའི་ལན་དེ་ཉེར་མཁོ་པའི་གྲངས་ཆ་ཆ་ཚང་དང་ཉེར་མཁོ་གྲངས་ཆ་གཉིས་སུ་བསྒྱུར་དགོས།    \/\/n ནས་ m བར་གྱི་གྲངས་ཐང་གི་བར་ནའི་བར་ནའི་གྲངས་ཐང་ (n དང་ m བཅས་ཀྱང་མཉམ་ཡོད།)    \/\/ཁྱོད་ཚོར་ n དང་ m ཟེར་བའི་གྲངས་ཆ་ཧྲིལ་པོ་གཉིས་ཐོབ་ཡོད། ཁྱོད་ཀྱི་ལས་འགན་ནི་     \/\/ >>> roundedAvg((1l), (5l))\n    \/\/ \"0b11\"\n    \/\/ >>> roundedAvg((7l), (5l))\n    \/\/ -1l\n    \/\/ >>> roundedAvg((10l), (20l))\n    \/\/ \"0b1111\"\n    \/\/ >>> roundedAvg((20l), (33l))\n    \/\/ \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n  \/\/ Function to compute the average of the integers from n through m\n  def roundedAvg(n: Long, m: Long): Either[String, Long] = {\n    if (n > m) {\n      Right(-1L)\n    } else {\n      val count = m - n + 1\n      val sum = (n + m) * count \/ 2\n      val average = round(sum.toDouble \/ count)\n      Left(\"0b\" + average.toLong.toBinaryString)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(roundedAvg(1L, 5L))    \/\/ Left(\"0b11\")\n    println(roundedAvg(7L, 5L))    \/\/ Right(-1L)\n    println(roundedAvg(10L, 20L))  \/\/ Left(\"0b1111\")\n    println(roundedAvg(20L, 33L))  \/\/ Left(\"0b11010\")\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n"},{"task_id":"HumanEval_104","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/དྲན་གསོ། ཕྱིར་ལོག་པའི་ཐོ་ཡིག་དེ་ཡར་རྒྱས་ཀྱི་རིམ་པ་བཞིན་དབྱེ་དགོས།    \/\/ཇི་ཡོད་ཆ་ཤས་ལ་ཆ་སྙོམ་གྲངས་མེད་པ།    \/\/འབྲས་བུ་གྲངས་ཚང་གི་ཐོ་ཡིག་ x ཡོད་པ་ལས་ ཆ་ཚང་གི་ཐོ་ཡིག་རིམ་སྒྲིག་བྱས་པ་ཞིག་ཕྱིར་ལོག་བྱེད་པ།    \/\/ >>> uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong)))\n    \/\/ (List[Long](1l.toLong, 15l.toLong, 33l.toLong))\n    \/\/ >>> uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong)))\n    \/\/ (List[Long]())\n    def uniqueDigits(x : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def uniqueDigits(x: List[Long]): List[Long] = {\n    def hasEvenDigit(n: Long): Boolean = {\n      n.toString.exists(c => (c - '0') % 2 == 0)\n    }\n\n    x.filterNot(hasEvenDigit).sorted\n  }\n\n  \/\/ Example usage\n  def main(args: Array[String]): Unit = {\n    println(uniqueDigits(List[Long](15L, 33L, 1422L, 1L)))\n    println(uniqueDigits(List[Long](152L, 323L, 1422L, 10L)))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 15l.toLong, 33l.toLong))));\n    assert(uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong))).equals((List[Long]())));\n    assert(uniqueDigits((List[Long](12345l.toLong, 2033l.toLong, 111l.toLong, 151l.toLong))).equals((List[Long](111l.toLong, 151l.toLong))));\n    assert(uniqueDigits((List[Long](135l.toLong, 103l.toLong, 31l.toLong))).equals((List[Long](31l.toLong, 135l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_105","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/༡། ༢། ༣། ༤། ༥། ༦། ༧། ༨། ༩།    \/\/བྱུང་བའི་ཐོ་ཡིག་དེ་ཕྱིར་ལོག་བྱེད་ནས་ཨང་ཀེར་རེ་རེ་དེའི་མིང་དང་མཚུངས་པའི་གྲངས་ཀ་                                 \/\/གྲངས་ཚང་གི་ཐོ་ཡིག་ཤིག་ཡོད་ན། ༡ དང་ ༩ བར་གྱི་གྲངས་ཚང་ལ་དབྱེ་དགོས།    \/\/ >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))\n    \/\/ If the list is empty, return an empty list:\n    \/\/ >>> byLength((List[Long]()))\n    \/\/ (List[String]())\n    \/\/ If the list has any strange number ignore it:\n    \/\/ >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))\n    \/\/ (List[String](\"One\"))\n    def byLength(arr : List[Long]) : List[String] = {\n","canonical_solution":"import scala.collection.mutable._\n\nobject Problem {\n  def byLength(arr: List[Long]): List[String] = {\n    \/\/ Map of digit to its corresponding name\n    val numToName = Map(\n      1L -> \"One\",\n      2L -> \"Two\",\n      3L -> \"Three\",\n      4L -> \"Four\",\n      5L -> \"Five\",\n      6L -> \"Six\",\n      7L -> \"Seven\",\n      8L -> \"Eight\",\n      9L -> \"Nine\"\n    )\n\n    \/\/ Filter numbers between 1 and 9\n    val filteredAndSorted = arr.filter(num => num >= 1 && num <= 9).sorted(Ordering[Long].reverse)\n    \/\/ Map filtered and sorted numbers to their corresponding names\n    filteredAndSorted.map(numToName)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"))));\n    assert(byLength((List[Long]())).equals((List[String]())));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](\"One\"))));\n    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](\"Three\", \"Two\", \"One\"))));\n    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](\"Nine\", \"Eight\", \"Four\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_106","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/i གི་ཕྲེང་བ་ནི་ 1 ནས་ i བར་གྱི་གྲངས་ཀྱི་ལྡབ་གྲངས་ཡིན། (1 * 2 * ... * i)    \/\/i 1 ནས་འགོ་ཚུགས།    \/\/ཡང་ན་ 1 ནས་ i བར་གྱི་གྲངས་ཐང་གི་བསྡོམས་ཡིན་ན།    \/\/ཚད་ n ཡི་ཐོ་ཡིག་ཕྱིར་ལོག་བྱེད་ཅིང་། དེ་ལྟ་སྟེ། ཚད་གཞི་ i ཡི་ནང་ཡོད་པའི་ཆ་ཤས་ཀྱི་ཐང་ནི་ i ཡི་གྲངས་ཆ་ཡིན་ན།    \/\/ཚད་གཞི་ n སྦེ་ལེན་པའི་ function f འདི་ལག་ལེན་བསྟར་དགོས།    \/\/ >>> f((5l))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))\n    def f(n : Long) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def f(n: Long): List[Long] = {\n        def factorial(x: Long): Long = if (x == 0) 1 else x * factorial(x - 1)\n        \n        (1L to n).map { i =>\n            if (i % 2 == 0) factorial(i) else (1L to i).sum\n        }.toList\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(f((5l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))));\n    assert(f((7l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong, 720l.toLong, 28l.toLong))));\n    assert(f((1l)).equals((List[Long](1l.toLong))));\n    assert(f((3l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_107","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཞི་དང་པོ།    \/\/སྐར་གྲངས་ཀྱི་ནང་པའི་ཧྲིལ་གྲངས་ཀྱི་ཚད་གཞི་ (n) དང་།    \/\/འབྲས་བུ་ནི་ n ཡིན་པའི་ཆ་ཤས་ཚག་དང་ཚག་གཉིས་ཡོད་པ།    \/\/ >>> evenOddPalindrome((3l))\n    \/\/ ((1l, 2l))\n    \/\/ Explanation:\n    \/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n    \/\/ Example 2:\n    \/\/ >>> evenOddPalindrome((12l))\n    \/\/ ((4l, 6l))\n    \/\/ Explanation:\n    \/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n    \/\/ Note:\n    \/\/ 1. 1 <= n <= 10^3\n    \/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\n    def evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {\n","canonical_solution":"def evenOddPalindrome(n: Long): (Long, Long) = {\n  def isPalindrome(x: Long): Boolean = {\n    val str = x.toString\n    str == str.reverse\n  }\n\n  var evenCount: Long = 0\n  var oddCount: Long = 0\n\n  for (i <- 1L to n) {\n    if (isPalindrome(i)) {\n      if (i % 2 == 0) evenCount += 1\n      else oddCount += 1\n    }\n  }\n\n  (evenCount, oddCount)\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(evenOddPalindrome((123l)).equals(((8l, 13l))));\n    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((3l)).equals(((1l, 2l))));\n    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));\n    assert(evenOddPalindrome((25l)).equals(((5l, 6l))));\n    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((9l)).equals(((4l, 5l))));\n    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));\n    }\n\n}\n"},{"task_id":"HumanEval_108","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན། -123 ནང་གི་ཨང་རྟགས་ནི་ -1, 2, 3 ཡིན།    \/\/གྲངས་ཆ་འདི་ཆ་མེད་ཡིན་ན། དེའི་སྔོན་གྱི་ཨང་རྟགས་ནི་ཆ་མེད་ཡིན་:     \/\/ཤོག་གྲངས་ཀྱི་གྲངས་ཐང་ནི་ 0 སྟེང་གི་ཨང་གྲངས་ཀྱི་བསྡོམས་གྲངས་ཡིན།    \/\/གྲངས་ཆ་ཚང་མའི་ཐོ་ཡིག་ལེན་ནས་སླར་ལོག་བྱ་བའི་ལས་འགན་ count_nums ཡིག་སྒྱུར་བྱོས།    \/\/ >>> countNums((List[Long]()))\n    \/\/ (0l)\n    \/\/ >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    \/\/ (1l)\n    \/\/ >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n    \/\/ (3l)\n    def countNums(arr : List[Long]) : Long = {\n","canonical_solution":"def countNums(arr: List[Long]): Long = {\n  arr.count(num => {\n    val sumOfDigits = num.toString.foldLeft(0) { (acc, char) =>\n      if (char == '-') acc else acc + (char - '0')\n    }\n    sumOfDigits > 0\n  }).toLong\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n"},{"task_id":"HumanEval_109","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་མཚོན།:     \/\/ཟུར་ཐོ་ནང་ངོས་ཀྱིས་ཆ་རྐྱེན་གཅིག་པུ་ཡོད་ངེས་གཏན་འདུག    \/\/གལ་ཏེ་ཡིག་སྣོད་འདི་སྟོང་པ་ཡོད་ན་ true སླར་ལོག་བྱེད།    \/\/དེ་ནས་ true སླར་ལོག་བྱེད། ཡང་ན་ false སླར་ལོག་བྱེད།    \/\/གོང་གི་བྱ་རིམ་ལྟར་རིམ་སྒྲིག་ཅན་གྱི་ཐོ་ཡིག་ཐོབ་ཐུབ་ན།    \/\/ཤོག་གྲངས་ 0 པའི་ནང་ཡོད་པའི་ཐོ་ཡིག་གི་འགོ་ཐོག་གི་གནས་བབ།    \/\/ཤོག་ངོས་མཐའ་མའི་ནང་ཡོད་པའི་ཡིག་ཆ་དེ་ ཕྱོགས་གང་སར་སྤོ་བཤུད་བྱེད།    \/\/གཡས་ཕྱོགས་བསྐྱོད་བྱ་རིམ་གཅིག་གིས་ཐོ་ཡིག་ནང་གི་ཆ་ཤས་ཚང་མ་ 1 ཀྱིས་སྤོ་བཤུད་བྱ་རྒྱུ་རེད།    \/\/ཁྱོད་ཀྱིས་གཡས་གཡོན་དུ་འགྲོ་བར་ཐེངས་ཇི་ཙམ་འགོར་རུང་།    \/\/ཤོག་གྲངས་ནང་བཀོད་པའི་ལས་རིམ་འདི་ལ།    \/\/བྱེད་ནུས་ཡོད་ན་ཡིག་སྣོད་དེ་རིམ་པ་མི་ཆག་པའི་རིམ་པ་བཞིན་རིམ་པ་སྒྲིག་ཐུབ།    \/\/ཤོག་གྲངས་ནང་ཡོད་པའི་གྲངས་ཀ་རྣམས་གོ་རིམ་བཞིན་དུ་གོ་སྒྲིག་བྱེད་ཡོད། ཁྱོད་ཀྱི་ལས་འགན་ནི་ ཇི་འདྲ་ཡིན་མིན་གཏན་འཁེལ་བྱེད་རྒྱུ་དེ་ཡིན།    \/\/འདིར་ 'arr' ཡི་ཐོ་ཡིག་ཞིག་ཡོད། འདིར་ N ཡི་གྲངས་ཐང་ arr[1], arr[2], ..., arr[N] ཡོད།    \/\/ >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    \/\/ (true)\n    \/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n    \/\/ be achieved for the given list.\n    \/\/ >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong)))\n    \/\/ (false)\n    \/\/ Explanation:It is not possible to get non-decreasing order for the given\n    \/\/ list by performing any number of right shift operations.\n    def moveOneBall(arr : List[Long]) : Boolean = {\n","canonical_solution":"def moveOneBall(arr: List[Long]): Boolean = {\n  if (arr.isEmpty) return true\n\n  \/\/ Find how many times the array needs to be shifted to become sorted\n  val n = arr.length\n  var shiftIndex = -1\n\n  for (i <- 0 until n) {\n    if (arr(i) > arr((i + 1) % n)) {\n      \/\/ More than one place where the order breaks means it can't be sorted with a shift\n      if (shiftIndex != -1) return false\n      shiftIndex = i + 1\n    }\n  }\n\n  \/\/ If no break in order was found, the array is already sorted\n  if (shiftIndex == -1) return true\n\n  \/\/ Check if shifting by the found index sorts the array\n  for (i <- 1 until n) {\n    if (arr((shiftIndex + i) % n) < arr((shiftIndex + i - 1) % n)) return false\n  }\n  \n  true\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong, 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]())) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_110","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/དེ་མིན་ \"NO\" ཕྱིར་སློག་བྱོས།    \/\/lst1 ནང་གི་ཆ་ཤས་ཚང་མ་ཆ་སྙོམས་ཡིན་ན། \"YES\" སླར་ལོག་བྱེད་དགོས།    \/\/ཕྱོགས་མཚུངས་ཀྱི་ཆ་རྐྱེན་ཞིག་ཡིན་ན།    \/\/lst1 དང་ lst2 བར་བརྗེ་ལེན་བྱེད་རྒྱུའི་ཆ་ཤས་གྲངས་ཚད་མེད་ཡིན།    \/\/ཤོག་གྲངས་ཉེར་གཅིག་ལས་ལྷག་པའི་གྲངས་ཐོ་ཞིག་བཟོས་ནས་    \/\/འདྲ་པར་བརྗེ་ལེན་བྱེད་ཆོག་མིན་ལ་དཔྱད་པ།    \/\/འདིར་ཁྱེད་ཚོས་གྲངས་ཐོ་གཉིས་ལེན་པའི་ལས་འགན་ཞིག་ལག་ལེན་བྱེད་རྒྱུ་ཡིན།    \/\/ >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (\"YES\")\n    \/\/ >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (\"NO\")\n    \/\/ It is assumed that the input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def exchange(lst1: List[Long], lst2: List[Long]): String = {\n    \/\/ Check if all elements in lst1 are already even\n    if (lst1.forall(_ % 2 == 0)) return \"YES\"\n\n    \/\/ Find if there's any even number in lst2 to exchange with lst1\n    val lst2EvensExist = lst2.exists(_ % 2 == 0)\n\n    \/\/ Check if there's also at least one odd in lst1 to swap it out\n    val lst1OddsExist = lst1.exists(_ % 2 != 0)\n\n    \/\/ Only possible if both an even element in lst2 and an odd element in lst1 exist\n    if (lst2EvensExist && lst1OddsExist) \"YES\" else \"NO\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"},{"task_id":"HumanEval_111","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/གལ་ཏེ་ཡིག་རྟགས་མང་པོ་ཞིག་འདྲ་མཚུངས་བྱུང་ན་ཡིག་རྟགས་ཚང་མ་ཕྱིར་སློག་བྱེད་དགོས།    \/\/ཤོག་གྲངས་གང་ཞིག་ལ་ཨང་གྲངས་མང་ཤོས་དང་དེའི་ནང་གྲངས་རྩིས་ཡོད་ན་དེའི་ནང་ཡིག་འབྲུ་གང་ཞིག་ཡོད་ན་དེའི་ནང་འཇུག་དགོས།    \/\/སྐར་ཁུང་གི་ཡིག་འབྲུ་ཆུང་ཆུང་གཉིས་སུ་དབྱེ་བའི་ཡིག་འབྲུ་ ཞིག་ཡོད་ན། སྐར་ཁུང་གི་ས་ཁྲ་སླར་ལོག་བྱེད།    \/\/ >>> histogram((\"a b c\"))\n    \/\/ (Map[String,Long](\"a\" -> 1l, \"b\" -> 1l, \"c\" -> 1l))\n    \/\/ >>> histogram((\"a b b a\"))\n    \/\/ (Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))\n    \/\/ >>> histogram((\"a b c a b\"))\n    \/\/ (Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))\n    \/\/ >>> histogram((\"b b b b a\"))\n    \/\/ (Map[String,Long](\"b\" -> 4l))\n    \/\/ >>> histogram((\"\"))\n    \/\/ (Map[String,Long]())\n    def histogram(test : String) : Map[String,Long] = {\n","canonical_solution":"def histogram(test: String): Map[String, Long] = {\n        val words = test.split(\" \")\n        val frequencyMap = words.groupBy(identity).mapValues(_.length.toLong)\n\n        if (frequencyMap.isEmpty) return Map.empty[String, Long]\n\n        val maxCount = frequencyMap.values.max\n        frequencyMap.filter { case (_, count) => count == maxCount }\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(histogram((\"a b b a\")).equals((Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))));\n    assert(histogram((\"a b c a b\")).equals((Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))));\n    assert(histogram((\"a b c d g\")).equals((Map[String,Long](\"a\" -> 1l, \"b\" -> 1l, \"c\" -> 1l, \"d\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"r t g\")).equals((Map[String,Long](\"r\" -> 1l, \"t\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"b b b b a\")).equals((Map[String,Long](\"b\" -> 4l))));\n    assert(histogram((\"r t g\")).equals((Map[String,Long](\"r\" -> 1l, \"t\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"\")).equals((Map[String,Long]())));\n    assert(histogram((\"a\")).equals((Map[String,Long](\"a\" -> 1l))));\n    }\n\n}\n"},{"task_id":"HumanEval_112","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ཚོད་ལྟ་བྱེད་སྐབས་འབྲས་བུ་ string དང་ true\/false ཡོད་པའི་ tuple སླར་ལོག་བྱེད་དགོས།    \/\/string འདི་ལ་ palindrome ཞེས་ཟེར་བ་ནི། ཕྱིར་དང་མདུན་གྱི་གོ་དོན་འདྲ་མཚུངས་ཡིན་ན།    \/\/འབྲས་བུ་ནི་ palindrome ཡིན་མིན་ལ་བརྟག་དཔྱད་བྱེད་དགོས།    \/\/འདིར་ s དང་ c གཉིས་ཀྱི་ཡིག་འབྲུ་གཉིས་ཡོད། ཁྱོད་ཀྱིས་ s ནང་གི་ཡིག་འབྲུ་གང་འདྲ་ཞིག་ c ནང་གི་ཡིག་འབྲུ་གང་འདྲ་ཞིག་དང་མཚུངས་པ་ཚང་མ་སེལ་དགོས།    \/\/ལས་འགན་     \/\/ >>> reverseDelete((\"abcde\"), (\"ae\"))\n    \/\/ ((\"bcd\", false))\n    \/\/ >>> reverseDelete((\"abcdef\"), (\"b\"))\n    \/\/ ((\"acdef\", false))\n    \/\/ >>> reverseDelete((\"abcdedcba\"), (\"ab\"))\n    \/\/ ((\"cdedc\", true))\n    def reverseDelete(s : String, c : String) : Tuple2[String, Boolean] = {\n","canonical_solution":"def reverseDelete(s: String, c: String): Tuple2[String, Boolean] = {\n    \/\/ Convert the characters to be deleted into a set for quick lookup\n    val deleteSet = c.toSet\n    \n    \/\/ Filter out characters from s that are present in deleteSet\n    val filteredString = s.filterNot(deleteSet.contains)\n    \n    \/\/ Check if the filtered string is a palindrome\n    val isPalindrome = filteredString == filteredString.reverse\n    \n    \/\/ Return the tuple with the filtered string and the palindrome check result\n    (filteredString, isPalindrome)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(reverseDelete((\"abcde\"), (\"ae\")).equals(((\"bcd\", false))));\n    assert(reverseDelete((\"abcdef\"), (\"b\")).equals(((\"acdef\", false))));\n    assert(reverseDelete((\"abcdedcba\"), (\"ab\")).equals(((\"cdedc\", true))));\n    assert(reverseDelete((\"dwik\"), (\"w\")).equals(((\"dik\", false))));\n    assert(reverseDelete((\"a\"), (\"a\")).equals(((\"\", true))));\n    assert(reverseDelete((\"abcdedcba\"), (\"\")).equals(((\"abcdedcba\", true))));\n    assert(reverseDelete((\"abcdedcba\"), (\"v\")).equals(((\"abcdedcba\", true))));\n    assert(reverseDelete((\"vabba\"), (\"v\")).equals(((\"abba\", true))));\n    assert(reverseDelete((\"mamma\"), (\"mia\")).equals(((\"\", true))));\n    }\n\n}\n"},{"task_id":"HumanEval_113","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཇི་ཇི་ཨང་གྲངས་ནང་ཐིག་གྲངས་གྲངས་ཀྱི་གྲངས་ཆ་མི་འདྲ་བ་ཡོད་ན།    \/\/ནང་འཇུག་གི་ string i ཟེར་བའི་ནང་ i ཚང་མ་གྲངས་ཀ་ ཀྱིས་ཚབ་ཏུ་འཇུག་དགོས།    \/\/ཕྱིར་ཐོན་གྱི་ཆ་ཤས་ i ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་    \/\/string འདི་ནང་ཡིག་འབྲུ་རེ་རེ་བཞིན་ནི་ཨང་གྲངས་ཀྱི་གྲངས་ཀ་ལས་གྲུབ་པ་ཞིག་ཡིན་ན། list དེ་ཕྱིར་སློག་བྱེད་དགོས།    \/\/ >>> oddCount((List[String](\"1234567\")))\n    \/\/ (List[String](\"the number of odd elements 4n the str4ng 4 of the 4nput.\"))\n    \/\/ >>> oddCount((List[String](\"3\", \"11111111\")))\n    \/\/ (List[String](\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"))\n    def oddCount(lst : List[String]) : List[String] = {\n","canonical_solution":"def oddCount(lst: List[String]): List[String] = {\n    lst.map { str =>\n      val oddCount = str.count(c => c.asDigit % 2 != 0)\n      val replacedString = s\"the number of odd elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${oddCount}nput.\"\n      replacedString\n    }\n  }\n\n  \/\/ Example usage\n  def main(args: Array[String]): Unit = {\n    println(oddCount(List(\"1234567\")))  \/\/ List(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")\n    println(oddCount(List(\"3\", \"11111111\")))  \/\/ List(\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\")\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(oddCount((List[String](\"1234567\"))).equals((List[String](\"the number of odd elements 4n the str4ng 4 of the 4nput.\"))));\n    assert(oddCount((List[String](\"3\", \"11111111\"))).equals((List[String](\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"))));\n    assert(oddCount((List[String](\"271\", \"137\", \"314\"))).equals((List[String](\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_114","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ཀྱི་གྲངས་ཀ་ཡིན།    \/\/གྲངས་ཚང་གི་ཐོ་ཡིག་ཅིག་ཡོད་ན། སྟོང་པ་མིན་པའི་ཐོ་ཡིག་འོག་མའི་ཉུང་མཐའི་བསྡོམས་གྲངས་འཚོལ་དགོས།    \/\/ >>> minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)))\n    \/\/ (1l)\n    \/\/ >>> minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)))\n    \/\/ (-6l)\n    def minSubArraySum(nums : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def minSubArraySum(nums: List[Long]): Long = {\n    var minEndingHere = nums.head\n    var minSoFar = nums.head\n    \n    for (i <- 1 until nums.length) {\n      minEndingHere = min(nums(i), minEndingHere + nums(i))\n      minSoFar = min(minSoFar, minEndingHere)\n    }\n    \n    minSoFar\n  }\n\n  \/\/ Test Cases\n  def main(args: Array[String]): Unit = {\n    println(minSubArraySum(List(2l, 3l, 4l, 1l, 2l, 4l))) \/\/ Output: 1\n    println(minSubArraySum(List(-1l, -2l, -3l))) \/\/ Output: -6\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));\n    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));\n    assert(minSubArraySum((List[Long](-9999999999999999l.toLong))) == (-9999999999999999l));\n    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong, 20l.toLong, 1000000l.toLong))) == (0l));\n    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](100l.toLong, -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong, 3l.toLong, 4l.toLong))) == (3l));\n    assert(minSubArraySum((List[Long](100l.toLong, -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));\n    assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));\n    assert(minSubArraySum((List[Long](7l.toLong))) == (7l));\n    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));\n    }\n\n}\n"},{"task_id":"HumanEval_115","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཞི་དང་པོ།    \/\/སྦ་སྒོར་ཕབ་དགོས་པའི་དུས་གྲངས་འདེམས་དགོས།    \/\/ཁྱོད་ཚོར་ལས་འགན་ནི་ཆུ་མཛོད་རྣམས་ཆུ་ཟམ་ནས་ཆུ་བསྐོལ་བའི་ཆེད་དུ་སླ་པོ་རྣམས་བེད་སྤྱོད་བྱེད་རྒྱུ་དེ་ཡིན།    \/\/ཚང་མ་ཁོར་ཡུག་འདྲ་མཉམ་ཡོད།    \/\/ཆུ་དོང་རེ་རེར་ཆུ་རྫིང་རེ་ཡོད་དེ། ཆུ་དེ་ནས་ཆུ་བཏོན་པའི་ཆེད་དུ་བེད་སྤྱོད་བྱེད་ཆོག    \/\/ཤོག་ངོས་རེ་རེའི་ནང་ 1 ཟེར་བ་ནི་ཆུ་གི་ཆ་ཤས་གཅིག་ཡིན་པ་མཚོན་པ་ཡིན།    \/\/ཁྱོད་ཚོར་ཆུ་རྐ་གྲུ་བཞི་ཅན་གྱི་དྲ་རྒྱ་ཞིག་སྤྲོད་ཡོད། རེའུ་མིག་རེ་རེར་ཆུ་རྐ་གཅིག་རང་ཡོད།    \/\/ >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n    \/\/ (6l)\n    \/\/ Example 2:\n    \/\/ >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    \/\/ (5l)\n    \/\/ Example 3:\n    \/\/ >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    \/\/ (0l)\n    \/\/ Constraints:\n    \/\/ * all wells have the same length\n    \/\/ * 1 <= grid.length <= 10^2\n    \/\/ * 1 <= grid[:,1].length <= 10^2\n    \/\/ * grid[i][j] -> 0 | 1\n    \/\/ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long) : Long = {\n","canonical_solution":"def maxFill(grid: List[List[Long]], capacity: Long): Long = {\n  var totalWaterUnits = 0L\n\n  for (row <- grid) {\n    totalWaterUnits += row.sum\n  }\n\n  \/\/ Calculate the number of times you need to lower the buckets\n  val bucketOperations = totalWaterUnits \/ capacity + (if (totalWaterUnits % capacity != 0) 1 else 0)\n\n  bucketOperations\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"},{"task_id":"HumanEval_116","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/འདྲ་བཤུས་འདི་བཞིན་ལག་ལེན་བྱ་དགོས།    \/\/འདྲ་མཉམ་གྲངས་སུ་གཅིག་ཡོད་ན། བཅུ་ཚིགས་ཀྱི་རིན་ཐང་ཐོག་ནས་དབྱེ་བ་དགོས།    \/\/ཤོག་གྲངས་གཉིས་པའི་ནང་གྲངས་གྲངས་ཡར་སེང་གི་རིམ་པ་བཞིན་ཡོད།    \/\/འདིར་ཁྱོད་ཀྱིས་ ཤོག་གྲངས་ སྐྱོན་མེད་ཀྱི་གྲངས་ཚང་གི་ཐོ་ཡིག་ལ་ ཇི་འདྲ་ཡིན་པར་རིམ་སྒྲིག་བྱེད་དགོས་པ་ཡིན།    \/\/ >>> sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    \/\/ >>> sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    \/\/ (List[Long](-6l.toLong, -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    \/\/ >>> sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long]) : List[Long] = {\n","canonical_solution":"def sortArray(arr: List[Long]): List[Long] = {\n        arr.sortBy(n => (n.toBinaryString.count(_ == '1'), n))\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong, 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong, 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong, 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_117","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/Note: ཁྱོད་ཀྱིས་ནང་འཇུག་ string ནང་ཡིག་རྟགས་དང་བར་སྟོང་མ་གཏོགས་གཞན་མེད་ཟེར་ངེས་ཐུབ།    \/\/གལ་ཏེ་ string s ནི་སྟོང་པ་ཡིན་ན་ function ཀྱིས་སྟོང་པའི་ཐོ་ཡིག་ཕྱིར་ལོག་བྱེད་དགོས།    \/\/n ཟུར་སྒྲ་རྣམས་རིམ་བཞིན་སོར་ལྡོག་བྱེད་ནས་ ཚིག་རྣམས་རིམ་བཞིན་སོར་ལྡོག་བྱེད་ནས་སོར་ལྡོག་བྱེད་ཡོད།    \/\/ཚད་ལྡན་ཚིག་ཡིག་ s ནང་གི་ཚིག་ཡིག་ཚང་མ་སླར་ལོག་བྱ་བའི་ལས་འགན་ཡིན།    \/\/string s དང་ natural number n ཞིག་ཡོད་ན། ཁྱོད་ཚོར་ལག་ལེན་བྱེད་རྒྱུའི་འགན་ཁུར་ཡོད།    \/\/ >>> selectWords((\"Mary had a little lamb\"), (4l))\n    \/\/ (List[String](\"little\"))\n    \/\/ >>> selectWords((\"Mary had a little lamb\"), (3l))\n    \/\/ (List[String](\"Mary\", \"lamb\"))\n    \/\/ >>> selectWords((\"simple white space\"), (2l))\n    \/\/ (List[String]())\n    \/\/ >>> selectWords((\"Hello world\"), (4l))\n    \/\/ (List[String](\"world\"))\n    \/\/ >>> selectWords((\"Uncle sam\"), (3l))\n    \/\/ (List[String](\"Uncle\"))\n    def selectWords(s : String, n : Long) : List[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def selectWords(s: String, n: Long): List[String] = {\n    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n    \n    def consonantCount(word: String): Int = {\n      word.count(c => c.isLetter && !vowels.contains(c))\n    }\n\n    if (s.isEmpty) {\n      List()\n    } else {\n      s.split(\"\\\\s+\").filter(word => consonantCount(word) == n).toList\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(selectWords((\"Mary had a little lamb\"), (4l)).equals((List[String](\"little\"))));\n    assert(selectWords((\"Mary had a little lamb\"), (3l)).equals((List[String](\"Mary\", \"lamb\"))));\n    assert(selectWords((\"simple white space\"), (2l)).equals((List[String]())));\n    assert(selectWords((\"Hello world\"), (4l)).equals((List[String](\"world\"))));\n    assert(selectWords((\"Uncle sam\"), (3l)).equals((List[String](\"Uncle\"))));\n    assert(selectWords((\"\"), (4l)).equals((List[String]())));\n    assert(selectWords((\"a b c d e f\"), (1l)).equals((List[String](\"b\", \"c\", \"d\", \"f\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_118","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/ཁྱོད་ཀྱིས་བྱིན་ཡིག་ string ནང་དཔར་ཡིག་དབྱིན་ཡིག་ཁོ་ན་ཡོད་པར་ངེས་གཏན་བྱེད་དགོས།    \/\/སྟེང་གི་གནས་སྟངས་ལ་བསྟུན་པའི་སྒྲ་སྒྲ་གང་ཞིག་འཚོལ་དགོས།    \/\/ཐོག་དང་མཇུག་གི་སྒྲ་དབྱངས་ལ་རྩིས་མི་བྱེད། གལ་ཏེ་མེད་ན་སྟོང་པ་ཕྱིར་ལོག་བྱོས།    \/\/ཚིག་གི་གཡས་ཕྱོགས་ནས་སྒྲ་གཉིས་བཏགས་པ། (case sensitive)    \/\/ཁྱོད་ཚོར་ཚིག་ཅིག་སྤྲོད་ཡོད། ཁྱོད་ཀྱི་ལས་འགན་ནི་ ཇི་ཙམ་ཉེ་བར་ཡོད་པ་དང་དེའི་བར་གྱི་སྒྲ་དབྱངས་འཚོལ་རྒྱུ་དེ་ཡིན།    \/\/ >>> getClosestVowel((\"yogurt\"))\n    \/\/ (\"u\")\n    \/\/ >>> getClosestVowel((\"FULL\"))\n    \/\/ (\"U\")\n    \/\/ >>> getClosestVowel((\"quick\"))\n    \/\/ (\"\")\n    \/\/ >>> getClosestVowel((\"ab\"))\n    \/\/ (\"\")\n    def getClosestVowel(word : String) : String = {\n","canonical_solution":"def getClosestVowel(word: String): String = {\n    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n    \n    for (i <- word.length - 2 until 0 by -1) {\n      if (!vowels.contains(word(i)) && vowels.contains(word(i + 1)) && !vowels.contains(word(i + 2))) {\n        return word(i + 1).toString\n      }\n    }\n    \n    \"\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"},{"task_id":"HumanEval_119","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/གལ་ཏེ་ string བཟོ་ཐབས་ཡོད་ན་ 'Yes' སླར་ལོག་བྱེད་དང་གཞན་ན་ 'No' སླར་ལོག་བྱེད་    \/\/\" ((()) \"མི་འདུག    \/\/ཚད་ལྡན་ཡིན་པའི་དཔེར་ན། string '(((() 'ནི་ལེགས་པོ་ཡིན་པ་དང་། string     \/\/string S འདི་ལེགས་པར་བརྩི་བའི་དོན་ནི་ S ནང་གི་ parentheses ཚང་མ་ལེགས་པ་ཡིན་ན་དེ་འདྲ་ཡིན་ན་མ་གཏོགས་གཞན་གང་ཡང་མེད།    \/\/ཚད་གཞི་འདི་ནི་རིམ་པ་གང་རུང་ཞིག་ཡིན་ན། འབྲས་བུ་ནི་ string ཡི་ལེགས་པ་ངེས་ཅན་ཞིག་ཡིན།    \/\/ཁྱོད་ཀྱི་ལས་འགན་ནི་ string གཉིས་ནང་འབྲེལ་མཐུད་བྱེད་ནུས་ཡོད་མེད་བརྟག་དཔྱད་བྱེད་རྒྱུ་རེད།    \/\/ནང་འཇུག་བྱེད་ཚིག་ཡིག་ནང་ \" ((\") \" ཡང་ན་ \") \" ཟེར་བའི་ནང་འཇུག་བྱེད་ཚིག་ཡིག་དེ་མ་གཏོགས་གཞན་མེད།    \/\/ཁྱོད་ཚོར་ string གཉིས་ཡོད་པའི་ཐོ་ཡིག་ཞིག་ཐོབ་ཡོད། string གཉིས་ཀ་ open ཟེར་བ་ལས་གྲུབ་པ་ཡིན།    \/\/ >>> matchParens((List[String](\"()(\", \")\")))\n    \/\/ (\"Yes\")\n    \/\/ >>> matchParens((List[String](\")\", \")\")))\n    \/\/ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n","canonical_solution":"def matchParens(lst: List[String]): String = {\n    def isBalanced(s: String): Boolean = {\n      var balance = 0\n      for (char <- s) {\n        if (char == '(') balance += 1\n        else if (char == ')') balance -= 1\n        if (balance < 0) return false\n      }\n      balance == 0\n    }\n    \n    val combinations = List(\n      lst(0) + lst(1),\n      lst(1) + lst(0)\n    )\n    \n    if (combinations.exists(isBalanced)) \"Yes\" else \"No\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n"},{"task_id":"HumanEval_120","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཞི་དང་པོ།    \/\/ཚད་ k དང་གྲངས་ k ཡི་རིང་ཚད་ arr ནང་ཡོད།    \/\/མཆོང་བའི་གྲངས་ཐོ་ arr དང་མཆོང་བའི་གྲངས་ཐོ་ k ཟེར་བ་ཡོད་ན། མཆོང་བའི་གྲངས་ཐོ་ཞིག་ཕྱིར་སློག་བྱ་དགོས།    \/\/ >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    \/\/ (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    \/\/ Example 2:\n    \/\/ >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    \/\/ (List[Long](4l.toLong, 4l.toLong))\n    \/\/ Example 3:\n    \/\/ >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    \/\/ (List[Long](2l.toLong))\n    \/\/ Note:\n    \/\/ 1. The length of the list will be in the range of [1, 1000].\n    \/\/ 2. The elements in the list will be in the range of [-1000, 1000].\n    \/\/ 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n","canonical_solution":"def maximum(arr: List[Long], k: Long): List[Long] = {\n    arr.sorted(Ordering[Long].reverse).take(k.toInt).sorted\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n"},{"task_id":"HumanEval_121","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/སྟོང་པ་མིན་པའི་གྲངས་ཆ་ཆ་ཚང་གི་ཐོ་ཡིག་ཤིག་ཡོད་ན། གྱངས་ཁ་ཆ་སྙོམ་ཡོད་པའི་ཆ་ཤས་ཆ་སྙོམ་ཐམས་ཅད་ཀྱི་བསྡོམས་གྲངས་ཕྱིར་ལོག་བྱེད་པ།    \/\/ >>> solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong)))\n    \/\/ (12l)\n    \/\/ >>> solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong)))\n    \/\/ (9l)\n    \/\/ >>> solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong)))\n    \/\/ (0l)\n    def solution(lst : List[Long]) : Long = {\n","canonical_solution":"def solution(lst: List[Long]): Long = {\n  lst.zipWithIndex.collect {\n    case (num, idx) if idx % 2 == 0 && num % 2 != 0 => num\n  }.sum\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong))) == (12l));\n    assert(solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong))) == (9l));\n    assert(solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong))) == (0l));\n    assert(solution((List[Long](5l.toLong, 9l.toLong))) == (5l));\n    assert(solution((List[Long](2l.toLong, 4l.toLong, 8l.toLong))) == (0l));\n    assert(solution((List[Long](30l.toLong, 13l.toLong, 23l.toLong, 32l.toLong))) == (23l));\n    assert(solution((List[Long](3l.toLong, 13l.toLong, 2l.toLong, 9l.toLong))) == (3l));\n    }\n\n}\n"},{"task_id":"HumanEval_122","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/arr ནང་གི་ཆ་ཤས་ k ཐོག་མའི་ཆ་ཤས་ནས་ཨང་གྲངས་གཉིས་ལས་མང་བ་མེད་པའི་ཆ་ཤས་ཀྱི་བསྡོམས་ཡིན།    \/\/ཨང་གྲངས་ཧྲིལ་པོ་ arr དང་ཨང་གྲངས་ཧྲིལ་པོ་ k གི་ཐོ་ཡིག་སྟོང་པ་མིན་པ་ཡོད་ན། return     \/\/ >>> addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l))\n    \/\/ (24l)\n    \/\/ Constraints:\n    \/\/ 1. 1 <= len(arr) <= 100\n    \/\/ 2. 1 <= k <= len(arr)\n    def addElements(arr : List[Long], k : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def addElements(arr: List[Long], k: Long): Long = {\n    arr.take(k.toInt).filter(x => x >= -99 && x <= 99).sum\n  }\n\n  def main(args: Array[String]): Unit = {\n    val result = addElements(List[Long](111L, 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L), 4L)\n    println(result) \/\/ Output will be 24L\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(addElements((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 41l.toLong, 57l.toLong, 76l.toLong, 87l.toLong, 88l.toLong, 99l.toLong)), (3l)) == (-4l));\n    assert(addElements((List[Long](111l.toLong, 121l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong)), (2l)) == (0l));\n    assert(addElements((List[Long](11l.toLong, 21l.toLong, 3l.toLong, 90l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (125l));\n    assert(addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (24l));\n    assert(addElements((List[Long](1l.toLong)), (1l)) == (1l));\n    }\n\n}\n"},{"task_id":"HumanEval_123","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/get_odd_collatz(5) སླར་ལོག་བྱས་ [1, 5] # 5 གི་ collatz ཐིག་ཁྲམ་ནི་ [5, 16, 8, 4, 2, 1] ཡིན་པས་གྲངས་ཆ་རྐྱང་ནི་ 1 དང་ 5 ཙམ་ཡིན།    \/\/དཔེར་ན་:     \/\/2.ལོག་བཏང་བའི་ཐོ་ཡིག་རིམ་བཞིན་ཡར་འགྲོ་བ།    \/\/Collatz ((1) ནི་ [1]ཡིན།    \/\/དྲན་གསོ།    \/\/ཚིག་གྲངས་དང་ལྡན། 1 ཟེར་བ་དེའི་ནང་ n ཇི་འདྲ་ཡིན་རུང་རིམ་པ་ 1 ཏུ་ངེས་པ་རེད་འདུག    \/\/གལ་ཏེ་སྔོན་གྱི་གྲངས་ནི་རྣམ་རྟོག་ཡིན་ན། རྗེས་མའི་གྲངས་ནི་སྔོན་གྱི་གྲངས་ལས་ 3 ཙམ་ཡིན།    \/\/སྔོན་མའི་གྲངས་ནི་ཆ་སྙོམས་ཡིན་ན། རྗེས་མའི་གྲངས་ནི་ གྱི་ཕྱེད་ཀ་ཡིན།    \/\/ཇི་འདྲ་ཡིན་རུང་ཨང་གྲངས་ཧྲིལ་པོ་ n ལས་འགོ་འཛུགས་དགོས། དེ་ནས་རིམ་པ་རེ་རེར་ ལས་ཐོབ་ཡོད།    \/\/ཀོ་ལ་ཊི་ (Collaz) གི་རྣམ་གཞག་ནི་རྩིས་རིག་གི་རྣམ་གཞག་ཞིག་ཡིན་ཏེ། དེའི་ནང་གསལ་གྱི་རིམ་པ་ཞིག་ཡིན་ཏེ།    \/\/འབྲས་བུ་གྲངས་ཆ་མཉམ་ n ཞིག་ཡོད་ན། ཚད་ལྡན་གྲངས་ཐོ་ཞིག་ཕྱིར་སློག་བྱ་དགོས། དེའི་ནང་གྲངས་ཆ་རྐྱང་རྣམས་ collatz རིམ་དུ་ཡོད།    \/\/ >>> getOddCollatz((5l))\n    \/\/ (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) : List[Long] = {\n","canonical_solution":"import scala.collection.mutable.ListBuffer\n\nobject Problem {\n  def getOddCollatz(n: Long): List[Long] = {\n    val oddNumbers = ListBuffer[Long]()\n    var number = n\n    while (number != 1) {\n      if (number % 2 == 1) {\n        oddNumbers += number\n      }\n      number = if (number % 2 == 0) number \/ 2 else 3 * number + 1\n    }\n    oddNumbers += 1\n    oddNumbers.sorted.toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong, 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong, 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_124","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/4. ཚེས་གྲངས་ནི་ཨང་རིམ་:ཨེམ་ཨེམ་-དི་-ཡཡཡ། ནང་དུ་བཀོད་དགོས།    \/\/ཟླ་བ་ ༡ ལས་ཉུང་བ་མིན་པར་ ༡༢ ལས་མང་བ་མིན་པར་དགོས།    \/\/ཟླ་བ་ ༡། ༣། ༥། ༧། ༨། ༡༠། ༡༢ ཀྱི་ཉིན་གྲངས་ནི་ ༡ ལས་ཉུང་བ་མིན་པ་དང་ ༣༡ ལས་མང་བ་མིན་པ་དང་། ཟླ་བ་ ༤། ༦། ༩། ༡༡ གྱི་ཉིན་གྲངས་ནི་ ༡ ལས་ཉུང་བ་མིན་པ་དང་ ༣༠ ལས་མང་བ་མིན་པ་དང་། ཟླ་བ་ ༢ གྱི་ཉིན་གྲངས་ནི་ ༡ ལས་ཉུང་བ་མིན་པ་དང་ ༢༩ ལས་མང་བ་མིན་པ་བཅས་ཡིན།    \/\/1. ཚེས་གྲངས་ཀྱི་ཐིག་ཡིག་ནི་སྟོང་པ་མིན་ནོ།།    \/\/ཚེས་གྲངས་དེ་གནས་ངེས་ཡིན་ན། འོག་གི་ཁྲིམས་ལུགས་ཚང་མ་སྲུང་དགོས།    \/\/གལ་ཏེ་ཚེས་གྲངས་དེ་བདེན་པ་ཡིན་ན་ true སླར་ལོག་བྱེད། གལ་ཏེ་དེ་བདེན་མེད་ན་ false སླར་ལོག་བྱེད།    \/\/ཁྱོད་ཀྱིས་དུས་གྲངས་ཀྱི་ཐིག་ཡིག་ལ་རྟགས་རྒྱག་པའི་ function ཞིག་འབྲི་དགོས།    \/\/ >>> validDate((\"03-11-2000\"))\n    \/\/ (true)\n    \/\/ >>> validDate((\"15-01-2012\"))\n    \/\/ (false)\n    \/\/ >>> validDate((\"04-0-2040\"))\n    \/\/ (false)\n    \/\/ >>> validDate((\"06-04-2020\"))\n    \/\/ (true)\n    \/\/ >>> validDate((\"06\/04\/2020\"))\n    \/\/ (false)\n    def validDate(date : String) : Boolean = {\n","canonical_solution":"import scala.util.Try\n\nobject Problem {\n  def validDate(date: String): Boolean = {\n    if (date.isEmpty) return false\n    \n    val datePattern = \"\"\"^(\\d{2})-(\\d{2})-(\\d{4})$\"\"\".r\n\n    date match {\n      case datePattern(monthStr, dayStr, yearStr) => \n        (Try(monthStr.toInt).toOption, Try(dayStr.toInt).toOption) match {\n          case (Some(month), Some(day)) if month >= 1 && month <= 12 =>\n            month match {\n              case 1 | 3 | 5 | 7 | 8 | 10 | 12 => day >= 1 && day <= 31\n              case 4 | 6 | 9 | 11 => day >= 1 && day <= 30\n              case 2 => day >= 1 && day <= 29\n              case _ => false\n            }\n          case _ => false\n        }\n      case _ => false\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(validDate((\"03-11-2000\")) == (true));\n    assert(validDate((\"15-01-2012\")) == (false));\n    assert(validDate((\"04-0-2040\")) == (false));\n    assert(validDate((\"06-04-2020\")) == (true));\n    assert(validDate((\"01-01-2007\")) == (true));\n    assert(validDate((\"03-32-2011\")) == (false));\n    assert(validDate((\"\")) == (false));\n    assert(validDate((\"04-31-3000\")) == (false));\n    assert(validDate((\"06-06-2005\")) == (true));\n    assert(validDate((\"21-31-2000\")) == (false));\n    assert(validDate((\"04-12-2003\")) == (true));\n    assert(validDate((\"04122003\")) == (false));\n    assert(validDate((\"20030412\")) == (false));\n    assert(validDate((\"2003-04\")) == (false));\n    assert(validDate((\"2003-04-12\")) == (false));\n    assert(validDate((\"04-2003\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_125","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/དབྱེ་ཡིག་ ord (a) = 0 ord (b) = 1 ord (z) = 25    \/\/ཚད་མ་ནང་ཡིག་ཆུང་ཆུང་གི་གྲངས་དང་གོ་རིམ་རྣམ་རྟོག་མེད་པ།    \/\/ཚིག་ཡིག་གི་ཐིག་ཡིག་ཐོབ་ཡོད་ན། སྟོང་པ་ཁ་ཕྱེ་ནས་ཚིག་ཡིག་གི་ཐོ་ཡིག་ཕྱིར་ལོག་བྱེད་པ། གལ་ཏེ་ཡིག་ཆ་ནང་སྟོང་པ་མེད་ན་     \/\/ >>> splitWords((\"Hello world!\"))\n    \/\/ List[String](\"Hello\", \"world!\")\n    \/\/ >>> splitWords((\"Hello,world!\"))\n    \/\/ List[String](\"Hello\", \"world!\")\n    \/\/ >>> splitWords((\"abcdef\"))\n    \/\/ 3l\n    def splitWords(txt : String) : Either[List[String], Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def splitWords(txt: String): Either[List[String], Long] = {\n    if (txt.contains(\" \")) {\n      Left(txt.split(\"\\\\s+\").toList)\n    } else if (txt.contains(\",\")) {\n      Left(txt.split(\",\").toList)\n    } else {\n      val oddOrderCount = txt.toCharArray\n        .count(c => ('a' to 'z').contains(c) && (c - 'a') % 2 == 0)\n      Right(oddOrderCount.toLong)\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(splitWords((\"Hello world!\")).equals(List[String](\"Hello\", \"world!\")));\n    assert(splitWords((\"Hello,world!\")).equals(List[String](\"Hello\", \"world!\")));\n    assert(splitWords((\"Hello world,!\")).equals(List[String](\"Hello\", \"world,!\")));\n    assert(splitWords((\"Hello,Hello,world !\")).equals(List[String](\"Hello,Hello,world\", \"!\")));\n    assert(splitWords((\"abcdef\")).equals(3l));\n    assert(splitWords((\"aaabb\")).equals(2l));\n    assert(splitWords((\"aaaBb\")).equals(1l));\n    assert(splitWords((\"\")).equals(0l));\n    }\n\n}\n"},{"task_id":"HumanEval_126","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/གྲངས་ཆ་མེད་པ། ནུས་མེད་པ། འབྲས་བུ་ནི་ཆ་མཉམ་ཡིན་པ་ངེས་པ།    \/\/ཤོག་གྲངས་འདྲ་མིན་གཅིག་ལས་མང་བ་ཡོད་ན། ཤོག་གྲངས་འདྲ་མིན་གཉིས་ལས་མང་བ་ཡོད་ན། ཤོག་གྲངས་འདྲ་མིན་གཉིས་ལས་མང་བ་ཡོད་ན། ཤོག་གྲངས་འདྲ་མིན་གཉིས་ལས་མང་བ་ཡོད་ན། ཤོག་གྲངས་འདྲ་མིན་གཉིས་ལས་མང་བ་ཡོད་ན།    \/\/གྲངས་ཐོ་ཞིག་ཡོད་ན་དེ་རིམ་སྒྲིག་བྱས་ཡོད་མེད་ཕྱིར་ལོག་འཇུག་དགོས།    \/\/ >>> isSorted((List[Long](5l.toLong)))\n    \/\/ (true)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\n    \/\/ (true)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))\n    \/\/ (false)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)))\n    \/\/ (true)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))\n    \/\/ (true)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))\n    \/\/ (false)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (true)\n    \/\/ >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    \/\/ (false)\n    def isSorted(lst : List[Long]) : Boolean = {\n","canonical_solution":"def isSorted(lst: List[Long]): Boolean = {\n    if (lst.isEmpty || lst.length == 1) return true\n\n    var hasDuplicate = false\n\n    for (i <- 1 until lst.length) {\n        if (lst(i) < lst(i - 1)) {\n            return false\n        }\n        if (lst(i) == lst(i - 1)) {\n            if (hasDuplicate) return false\n            hasDuplicate = true\n        } else {\n            hasDuplicate = false\n        }\n    }\n\n    true\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isSorted((List[Long](5l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (false));\n    assert(isSorted((List[Long]())) == (true));\n    assert(isSorted((List[Long](1l.toLong))) == (true));\n    assert(isSorted((List[Long](3l.toLong, 2l.toLong, 1l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_127","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/[input\/output] དཔེ་གཟུགས།    \/\/གལ་ཏེ་བར་མཚམས་གཉིས་དེ་དང་མི་འདྲ་ན། \"NO\" སླར་ལོག་བྱེད།    \/\/དེ་མིན་ \"NO\" ཟེར་བ་ཕྱིར་ལོག་བྱོས།    \/\/གལ་ཏེ་ཕྲེང་བའི་རིང་ཚད་ནི་སྔོན་གྲངས་ཡིན་ན། \"YES\" ཕྱིར་སློག་བྱོས།    \/\/དེའི་རིང་ཚད་ནི་ 1 ཡིན་ལ། དེ་ནི་སྔོན་གྲངས་མིན་པ་ཡིན།    \/\/དཔེ་གཞི་འདི་ནི་བར་མཚམས་ (1, 3), (2, 4) གྱི་ཕྲ་རིང་ནི་ (2, 3) ཡིན།    \/\/བར་མཚམས་ནི་གྲངས་དང་པོ་ཡིན།    \/\/ཁྱོད་ཀྱི་ལས་འགན་ནི་འདི་གཉིས་ཀྱི་ཕྲད་ཚད་ ཇི་ཡིན་གཏན་འབེབས་བྱ་རྒྱུ་དེ་ཡིན།    \/\/ཚད་གཞི་སོ་སོར་ཆ་བཞག་ན་དུས་ཡུན་གྱི་འགོ་ནི་མཐའ་མ་ལས་ཆུང་བའམ་མཚུངས་པ་རེད་ཟེར།    \/\/ཀྱི་འགོ་དང་མཐའ་གཉིས་ཀ་ཚུད་ཡོད།    \/\/ཇི་ཡོད་བར་མཚམས་ནི་བསྡམས་པ་རེད་ཟེར། དེའི་དོན་ནི་བར་མཚམས་ (འགོ་འཛུགས་དང་མཇུག་བསྡུ་) ཟེར་བ་རེད།    \/\/ཚོད་མཚམས་རེ་རེ་ནི་གྲངས་ཆ་ཆ་ཚང་གཉིས་ཡིན། དཔེར་ན། ཚོད་མཚམས་ = (འགོ་འཛིན། མཇུག་) = (1, 2)    \/\/ཁྱོད་ཚོར་དུས་ཡུན་གཉིས་ཐོབ་ཡོད།    \/\/ >>> intersection(((1l, 2l)), ((2l, 3l)))\n    \/\/ (\"NO\")\n    \/\/ >>> intersection(((-1l, 1l)), ((0l, 4l)))\n    \/\/ (\"NO\")\n    \/\/ >>> intersection(((-3l, -1l)), ((-5l, 5l)))\n    \/\/ (\"YES\")\n    def intersection(interval1 : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : String = {\n","canonical_solution":"import scala.math._\n\nobject Problem {\n  def isPrime(n: Long): Boolean = {\n    if (n <= 1) return false\n    if (n <= 3) return true\n    if (n % 2 == 0 || n % 3 == 0) return false\n    var i = 5\n    while (i * i <= n) {\n      if (n % i == 0 || n % (i + 2) == 0) return false\n      i += 6\n    }\n    true\n  }\n\n  def intersection(interval1: (Long, Long), interval2: (Long, Long)): String = {\n    val start = max(interval1._1, interval2._1)\n    val end = min(interval1._2, interval2._2)\n    if (start > end) return \"NO\"\n\n    val length = end - start\n    if (isPrime(length)) \"YES\" else \"NO\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"},{"task_id":"HumanEval_128","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/Note: return None for empty arr. སྟོང་པ་ཉིད་ཕྱིར་ལོག་བྱེད།    \/\/ཤོག་གྲངས་རེ་རེའི་ནང་ 1 དང་ 0 ཡང་ན་ 1 ཟེར་བ་ཡོད།    \/\/འབྲས་བུ་ནི་ཨང་གྲངས་ཧྲིལ་པོ་གི་ཆེ་ཆུང་དང་རྟགས་ཐམས་ཅད་ཀྱི་འབྲས་བུ་ལ་སོགས་པའི་གྲངས་ཀ་ཡིན།    \/\/ཁྱོད་ཀྱིས་གྲངས་ཧྲིལ་གྲངས་ཀྱི་ཐོ་ཡིག་ arr ཞིག་ཐོབ་ནས་ཕྱིར་ལོག་བྱེད་དགོས་པ་ཡིན།    \/\/ >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong)))\n    \/\/ Some(9l)\n    \/\/ >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))\n    \/\/ Some(0l)\n    \/\/ >>> prodSigns((List[Long]()))\n    \/\/ None\n    def prodSigns(arr : List[Long]) : Option[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def prodSigns(arr: List[Long]): Option[Long] = {\n    if (arr.isEmpty) return None\n\n    val productOfSigns = arr.foldLeft(1l)((acc, num) => acc * sign(num))\n    val sumOfMagnitudes = arr.map(_.abs).sum\n\n    Some(sumOfMagnitudes * productOfSigns)\n  }\n\n  private def sign(num: Long): Long = {\n    if (num > 0) 1\n    else if (num < 0) -1\n    else 0\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(Some(-9l)));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(Some(0l)));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(Some(-10l)));\n    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(Some(20l)));\n    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(Some(4l)));\n    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(Some(-4l)));\n    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(0l)));\n    }\n\n}\n"},{"task_id":"HumanEval_129","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ཆུང་ཤོས་ཀྱི་ལམ་བརྒྱུད་པའི་ཐིག་ཁྲམ་ནང་གི་རིན་ཐང་གི་རིམ་སྒྲིག་ཅན་གྱི་ཐོ་ཡིག་ཕྱིར་ལོག་བྱེད།    \/\/ཇི་འདྲ་ཡིན་ན་ལན་གཅིག་ཡོད་ངེས་རེད།    \/\/lst_A[j] = lst_B[j] ཟེར་བ་ལྟ་བུ།    \/\/འདྲ་བའི་ lst_A[i] < lst_B[i] དང་ j (1 <= j < i) ཇི་ཡོད་ཀྱི་ཆེད་དུ་    \/\/འདྲ་མིན་གྱི་ཚིག་གཞན་ལ་ lst_B དང་བསྡུར་ན་གྲངས་ཚང་གི་གྲངས་ཐང་ i (1 <= i <= k) ཡོད་པ་རེད།    \/\/རྒྱུད་ནས་ (ང་ཚོས་དེ་དག་ལ་ lst_A དང་ lst_B ཞེས་འབོད།) lst_A ནི་ཚིག་མཛོད་རིག་པའི་ཐོག་ནས་ཉུང་བ་རེད།    \/\/ནང་ཐིག་ A དང་ B ནང་གི་རིན་ཐང་གི་རིམ་སྒྲིག་ཅན་གྱི་ཐོ་འགོད་བྱས་རྗེས་འགྲོ་བཞིན་ཡོད།    \/\/ཕྲང་ལམ་ A (རིང་ཚད་ k) ནི་ཕྲང་ལམ་ B (རིང་ཚད་ k) ལས་ཆུང་བ་ཡིན་པར་རྩིས་ན།    \/\/ཁྱོད་ནི་གློག་ཀླད་ཀྱི་ལམ་ནས་འགྲོ་མི་ཐུབ།    \/\/འདྲ་མིན་གྱི་ཆ་རྐྱེན་ལ་བརྟེན་པ་མིན་ནམ།    \/\/ཚད་ k ཡོད་པའི་ལམ་གྱི་དོན་ནི་ k ཁང་མིག་ལ་ཐད་ཀར་འགྲོ་དགོས་ (མི་     \/\/ cell  cell  cell  cell    \/\/གཞན་སྐད་དུ་བཤད་ན། ཁྱོད་མིག་མིག་ལ་འགྲོ་ཐུབ། ཇི་ཞིག་ལ་ཁྱོད་དང་འདེམས་པའི་མཚམས་ཡོད་པ།    \/\/ཇི་འདྲ་ཞིག་ནས་ཀྱང་ cell ཇི་འདྲ་ཞིག་ནས་ཀྱང་ step ཇི་འདྲ་ཞིག་ནས་ཀྱང་ neighbour cell ཇི་འདྲ་ཞིག་ནས་ཀྱང་ step ཇི་འདྲ་ཞིག་ནས་ཀྱང་ neighbour cell ཇི་འདྲ་ཞིག་ནས་ཀྱང་ step ཇི་འདྲ་ཞིག་ནས་ཀྱང་ neighbour cell ཇི་འདྲ་ཞིག་ནས་ཀྱང་ step ཇི་འདྲ་ཞིག་ནས་ཀྱང་ neighbour cell    \/\/ཁྱོད་ཀྱིས་དྲ་ལམ་ནང་གི་ཚད་ k ཡི་ཆུང་ཤོས་ཀྱི་ལམ་འཚོལ་དགོས། ཁྱོད་ཀྱིས་འགོ་ཚུགས་ཐུབ།    \/\/ཕྱོགས་མཚུངས་ནི་ཐིག་ཁྲམ་ནང་གི་ཚགས་པར་ནང་ཐེངས་གཅིག་རང་མངོན་པར་བྱེད།    \/\/ཕྲེང་བའི་སྒོ་མིག་རེ་རེར་ཐང་ཞིག་ཡོད། [1, N * N] ནང་གི་གྲངས་ཧྲིལ་པོ་རེ་རེ    \/\/གྲལ་ཐིག་དང་ཀ་བ་ N ཡོད་པའི་དྲ་རྒྱ་ཞིག་དང་ (N >= 2) དང་གྲངས་ཆ་ k ཅན་ཞིག་ཡོད་ན།    \/\/ >>> minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l))\n    \/\/ (List[Long](1l.toLong, 2l.toLong, 1l.toLong))\n    \/\/ >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l))\n    \/\/ (List[Long](1l.toLong))\n    def minPath(grid : List[List[Long]], k : Long) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def minPath(grid: List[List[Long]], k: Long): List[Long] = {\n    val n = grid.length\n    val directions = List((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def isValid(x: Int, y: Int): Boolean = x >= 0 && y >= 0 && x < n && y < n\n\n    def dfs(x: Int, y: Int, path: List[Long]): List[Long] = {\n      if (path.length == k) return path\n      var minPath: List[Long] = List.fill(k)(Long.MaxValue)\n      for ((dx, dy) <- directions) {\n        val nx = x + dx\n        val ny = y + dy\n        if (isValid(nx, ny)) {\n          val newPath = dfs(nx, ny, path :+ grid(nx)(ny))\n          if (lexCompare(newPath, minPath)) {\n            minPath = newPath\n          }\n        }\n      }\n      minPath\n    }\n\n    def lexCompare(a: List[Long], b: List[Long]): Boolean = {\n      a.zip(b).find { case (x, y) => x != y } match {\n        case Some((x, y)) => x < y\n        case None => false\n      }\n    }\n\n    var minPathOverall = List.fill(k)(Long.MaxValue)\n    for {\n      i <- 0 until n\n      j <- 0 until n\n    } {\n      val startingPath = List(grid(i)(j))\n      val currentPath = dfs(i, j, startingPath)\n      if (lexCompare(currentPath, minPathOverall)) {\n        minPathOverall = currentPath\n      }\n    }\n    minPathOverall\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong, 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong, 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong, 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong, 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong, 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong), List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong, 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong, 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong, 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong), List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_130","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ཐོག་མའི་ n+1 ནི་ Tribonacci sequence གྱི་གྲངས་ཀ་ཡིན།    \/\/ཁྱོད་ཀྱིས་གྲངས་ཆ་མེད་མེད་གྲངས་ཆ་ n ཞིག་ཐོབ་ཡོད་ན། ཁྱོད་ཀྱིས་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་གྲངས་ཆ་མེད་    \/\/= 2 + 3 + 3 = 8    \/\/tri(3) = tri(2) + tri(1) + tri(4)     \/\/tri ((4) = 3     \/\/tri ((2) = 1 + (2 \/ 2) = 2    \/\/དཔེར་ན་:     \/\/tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1) ཡིན་ན། n ནི་གྲངས་ཆ་མ་ཡིན།    \/\/tri (n) = 1 + n \/ 2 ཡིན་ན། n ནི་ཆ་སྙོམས་ཡིན་ན།    \/\/tri ((1) = 3     \/\/Tribonacci sequence འདི་ཡང་བསྐྱར་དུ་བྱུང་བའི་སྒོ་ནས་གསལ་བཤད་བྱེད་པ།    \/\/ཡིན་ན་ཡང་མི་ཚོས་མི་ཤེས་པ་ནི་ཏྲི་བོན་ཅེ་ (Tribonacci) གི་རིམ་པ་ཡིན།    \/\/མི་ཚང་མས་ཕི་བོ་ན་ཅིའི་རིམ་པ་ཤེས་ཀྱི་ཡོད། ཕི་བོ་ན་ཅིའི་རིམ་པ་ནི་ ༡༩༥༠ ལོར་རིག་རྩལ་མཁས་པ་རྣམས་ཀྱིས་ཞིབ་ཏུ་ཞིབ་འཇུག་བྱས་པ་ཡིན།    \/\/ >>> tri((3l))\n    \/\/ (List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n","canonical_solution":"import scala.collection.mutable.ListBuffer\n\nobject Problem {\n  def tri(n: Long): List[Long] = {\n    \/\/ Initialize list with the first element of the Tribonacci sequence\n    val tribonacciSeq = ListBuffer[Long](3)\n\n    \/\/ Generate remaining elements up to the nth element\n    for (i <- 1L to n) {\n      if (i % 2 == 0) {\n        \/\/ If even, the formula is 1 + n \/ 2\n        tribonacciSeq.append(1 + i \/ 2)\n      } else {\n        \/\/ If odd, the formula is tri(n - 1) + tri(n - 2) + tri(n + 1)\n        \/\/ tri(n + 1) is handled as we iterate further\n        val tri_i_minus_1 = if (i - 1 >= 0) tribonacciSeq((i - 1).toInt) else 0\n        val tri_i_minus_2 = if (i - 2 >= 0) tribonacciSeq((i - 2).toInt) else 0\n        val tri_i_plus_1 = if (i + 1 <= n) 1 + (i + 1) \/ 2 else 0 \/\/ calculated as if the next is even\n        tribonacciSeq.append(tri_i_minus_1 + tri_i_minus_2 + tri_i_plus_1)\n      }\n    }\n\n    \/\/ Return as a list\n    tribonacciSeq.toList\n  }\n\n  \/\/ Test examples\n  def main(args: Array[String]): Unit = {\n    println(tri(3)) \/\/ List(3, 2, 8)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n    assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong, 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_131","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/གྲངས་ཀ་ཆ་མཉམ་ཉ་ན་ 0 སླར་ལོག་བྱེད།    \/\/འབྲས་བུ་འདི་ནི་ཨང་གྲངས་ཧྲིལ་པོ་ n ཞིག་ཡོད་ན། ཨང་གྲངས་ཉེར་མཁོ་ཅན་གྱི་འབྲས་བུ་ཕྱིར་སློག་བྱ་དགོས།    \/\/ >>> digits((1l))\n    \/\/ (1l)\n    \/\/ >>> digits((4l))\n    \/\/ (0l)\n    \/\/ >>> digits((235l))\n    \/\/ (15l)\n    def digits(n : Long) : Long = {\n","canonical_solution":"def digits(n: Long): Long = {\n    val product = n.toString.map(_.asDigit).filter(_ % 2 != 0).product\n    if (product == 1 && n.toString.forall(_.asDigit % 2 == 0)) 0L else product\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(digits((5l)) == (5l));\n    assert(digits((54l)) == (5l));\n    assert(digits((120l)) == (1l));\n    assert(digits((5014l)) == (5l));\n    assert(digits((98765l)) == (315l));\n    assert(digits((5576543l)) == (2625l));\n    assert(digits((2468l)) == (0l));\n    }\n\n}\n"},{"task_id":"HumanEval_132","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཤུལ་རིམ་གྱི་ནང་ལ་ཉུང་ཤོས་དྲ་མིག་གཅིག་རང་སྦྲེལ་ཡོད།    \/\/ལས་འགན་འདི་ true སླར་ལོག་བྱ་དགོས་ན། གལ་ཏེ་ brackets ཀྱི་རིམ་པ་ངེས་ཅན་ཞིག་ཡོད་ན་མ་གཏོགས་གཞན་མེད།    \/\/ཤོག་གྲངས་ནང་ཡོད་པའི་ཟུར་ཟུར་གྱི་སྒམ་པང་གཅིག་པུ་ཡོད་པའི་ནང་འཇུག་གི་རིམ་པ་ལེན་པའི་ལས་འགན་ཞིག་བཟོ།    \/\/ >>> isNested((\"[[]]\"))\n    \/\/ (true)\n    \/\/ >>> isNested((\"[]]]]]]][[[[[]\"))\n    \/\/ (false)\n    \/\/ >>> isNested((\"[][]\"))\n    \/\/ (false)\n    \/\/ >>> isNested((\"[]\"))\n    \/\/ (false)\n    \/\/ >>> isNested((\"[[][]]\"))\n    \/\/ (true)\n    \/\/ >>> isNested((\"[[]][[\"))\n    \/\/ (true)\n    def isNested(string : String) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def isNested(string: String): Boolean = {\n    var stack = new Stack[Char]()\n    var nested = false\n\n    for (char <- string) {\n      char match {\n        case '[' => stack.push(char)\n        case ']' =>\n          if (stack.nonEmpty) {\n            stack.pop()\n            if (stack.nonEmpty) {\n              nested = true\n            }\n          }\n      }\n      if (nested) return true\n    }\n\n    false\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isNested((\"[[]]\")) == (true));\n    assert(isNested((\"[]]]]]]][[[[[]\")) == (false));\n    assert(isNested((\"[][]\")) == (false));\n    assert(isNested((\"[]\")) == (false));\n    assert(isNested((\"[[[[]]]]\")) == (true));\n    assert(isNested((\"[]]]]]]]]]]\")) == (false));\n    assert(isNested((\"[][][[]]\")) == (true));\n    assert(isNested((\"[[]\")) == (false));\n    assert(isNested((\"[]]\")) == (false));\n    assert(isNested((\"[[]][[\")) == (true));\n    assert(isNested((\"[[][]]\")) == (true));\n    assert(isNested((\"\")) == (false));\n    assert(isNested((\"[[[[[[[[\")) == (false));\n    assert(isNested((\"]]]]]]]]\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_133","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ཐིག་ཁྲམ་ནང་གི་ཆ་ཤས་རེ་རེར་ཐོག་མར་སྟེང་མཐོར་ int ((Ceiling) ཟེར་བ་ལྟར་འཁོར་དགོས།    \/\/ཁྱོད་ཀྱིས་གྲངས་ཐོ་ནང་གྲངས་ཀྱི་གྲུ་བཞི་བསྡོམས་པའི་གྲངས་ཐང་ཕྱིར་ལོག་བྱེད་དགོས།    \/\/ཁྱོད་ཚོར་ཨང་གྲངས་ཀྱི་ཐོ་ཞིག་སྤྲད་ཡོད།    \/\/ >>> lst((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)))\n    \/\/ (14l)\n    \/\/ >>> lst((List[Float](1.0f.toFloat, 4.0f.toFloat, 9.0f.toFloat)))\n    \/\/ (98l)\n    \/\/ >>> lst((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat)))\n    \/\/ (84l)\n    \/\/ >>> lst((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat)))\n    \/\/ (29l)\n    \/\/ >>> lst((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat)))\n    \/\/ (6l)\n    def sumSquares(lst : List[Float]) : Long = {\n","canonical_solution":"import scala.math._\n\nobject Problem {\n  def sumSquares(lst: List[Float]): Long = {\n    lst.map(x => ceil(x.toDouble).toLong)\n      .map(x => x * x)\n      .sum\n  }\n\n  \/\/ Example usage, you can test the function with the given examples:\n  def main(args: Array[String]): Unit = {\n    println(sumSquares(List(1.0f, 2.0f, 3.0f))) \/\/ Output: 14\n    println(sumSquares(List(1.0f, 4.0f, 9.0f))) \/\/ Output: 98\n    println(sumSquares(List(1.0f, 3.0f, 5.0f, 7.0f))) \/\/ Output: 84\n    println(sumSquares(List(1.4f, 4.2f, 0.0f))) \/\/ Output: 29\n    println(sumSquares(List(-2.4f, 1.0f, 1.0f))) \/\/ Output: 6\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));\n    assert(sumSquares((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat))) == (29l));\n    assert(sumSquares((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat))) == (6l));\n    assert(sumSquares((List[Float](100.0f.toFloat, 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));\n    assert(sumSquares((List[Float](10000.0f.toFloat, 10000.0f.toFloat))) == (200000000l));\n    assert(sumSquares((List[Float](-1.4f.toFloat, 4.6f.toFloat, 6.3f.toFloat))) == (75l));\n    assert(sumSquares((List[Float](-1.4f.toFloat, 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));\n    assert(sumSquares((List[Float](0.0f.toFloat))) == (0l));\n    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));\n    assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) == (2l));\n    }\n\n}\n"},{"task_id":"HumanEval_134","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/Note: \"word\" ནི་ཡིག་འབྲུ་ཁག་གི་སྡེ་ཚན་ཞིག་ཡིན་ཏེ། དེའི་བར་ལ་སྟོང་པ་གཉིས་ཡོད།    \/\/ཕྱོགས་གཞན་ནས་རྫུན་བཤད་ཀྱི་ཡོད།    \/\/string གྱི་ཡིག་འབྲུ་འདི་ alphabetical character ཡིན་པ་ལས་ མིན་པ་མཚོན་ཐུབ།    \/\/གལ་ཏེ་མཐའ་མའི་ཡིག་འབྲུ་འདི་ trueཡིན་ན་ function དེ་སླར་ལོག་བྱ་དགོས།    \/\/ >>> checkIfLastCharIsALetter((\"apple pie\"))\n    \/\/ (false)\n    \/\/ >>> checkIfLastCharIsALetter((\"apple pi e\"))\n    \/\/ (true)\n    \/\/ >>> checkIfLastCharIsALetter((\"apple pi e \"))\n    \/\/ (false)\n    \/\/ >>> checkIfLastCharIsALetter((\"\"))\n    \/\/ (false)\n    def checkIfLastCharIsALetter(txt : String) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def checkIfLastCharIsALetter(txt: String): Boolean = {\n        if (txt.isEmpty) return false\n        val trimmed = txt.trim\n        if (trimmed.isEmpty) return false\n        val parts = trimmed.split(\" \")\n        val lastChars = parts.map(_.last)\n        if (lastChars.isEmpty) return false\n        val lastChar = trimmed.last\n        lastChars.contains(lastChar) && lastChar.isLetter\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(checkIfLastCharIsALetter((\"apple\")) == (false));\n    assert(checkIfLastCharIsALetter((\"apple pi e\")) == (true));\n    assert(checkIfLastCharIsALetter((\"eeeee\")) == (false));\n    assert(checkIfLastCharIsALetter((\"A\")) == (true));\n    assert(checkIfLastCharIsALetter((\"Pumpkin pie \")) == (false));\n    assert(checkIfLastCharIsALetter((\"Pumpkin pie 1\")) == (false));\n    assert(checkIfLastCharIsALetter((\"\")) == (false));\n    assert(checkIfLastCharIsALetter((\"eeeee e \")) == (false));\n    assert(checkIfLastCharIsALetter((\"apple pie\")) == (false));\n    assert(checkIfLastCharIsALetter((\"apple pi e \")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_135","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/འདྲ་མཚུངས་ཀྱི་ཚད་གཞི་    \/\/དེ་འདྲ་བའི་ཆ་ཤས་མེད་ན་ return - 1 སླར་ལོག་བྱེད། འདིར་བཀོད་པའི་ཐོ་ཡིག་ནང་ ཟེར་བ་མི་འདུག    \/\/ཇི་འདྲ་ཞིག་ཡིན་རུང་དེ་སྔོན་གྱི་ཆ་ཤས་དང་འདྲན་པ་ཡང་ན་དེ་ལས་ཆེ་བ་མིན། གལ་ཏེ་    \/\/ཚད་གཞི་ ཆེ་ཆུང་གི་ཚད་གཞི་སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་བཟོ་དགོས།    \/\/ >>> canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    \/\/ (3l)\n    \/\/ >>> canArrange((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    \/\/ (-1l)\n    def canArrange(arr : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n  def canArrange(arr: List[Long]): Long = {\n    for (i <- arr.indices.drop(1)) {\n      if (arr(i) < arr(i - 1)) return i.toLong\n    }\n    -1L\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]())) == (-1l));\n    }\n\n}\n"},{"task_id":"HumanEval_136","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/གལ་ཏེ་ཁ་བ་ ཡང་ན་ཁ་བ་ཅན་གྱི་ཧྲིལ་གྲངས་མེད་ན་ None སྦེ་ཕྱིར་ལོག་བྱེད།    \/\/ཤོག་གྲངས་ཀྱི་ནང་པའི་ཨང་གྲངས་ཀྱི་གྲངས་ཐིག་ནང་ཡོད་ན།    \/\/ཆུང་ཤོས་ནི་ b ཡིན་    \/\/ལས་འགན་ཞིག་བཟོ། དེ་ནང་ 'a' ནི་ ཡིན་པའི་ནང་།    \/\/ >>> largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    \/\/ (Some(None), Some(1l))\n    \/\/ >>> largestSmallestIntegers((List[Long]()))\n    \/\/ (Some(None), Some(None))\n    \/\/ >>> largestSmallestIntegers((List[Long](0l.toLong)))\n    \/\/ (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long], Option[Long]] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def largestSmallestIntegers(lst: List[Long]): Tuple2[Option[Long], Option[Long]] = {\n    val negativeIntegers = lst.filter(_ < 0)\n    val positiveIntegers = lst.filter(_ > 0)\n\n    val largestNegative = if (negativeIntegers.nonEmpty) Some(negativeIntegers.max) else None\n    val smallestPositive = if (positiveIntegers.nonEmpty) Some(positiveIntegers.min) else None\n\n    (largestNegative, smallestPositive)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    }\n\n}\n"},{"task_id":"HumanEval_138","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/གྲངས་ n འདི་གྲངས་ཆ་རྐྱང་ 4 གི་རྩིས་གཞི་ལྟར་བྲིས་ཐུབ་མིན་ལ་དཔྱད་པ།    \/\/ >>> isEqualToSumEven((4l))\n    \/\/ (false)\n    \/\/ >>> isEqualToSumEven((6l))\n    \/\/ (false)\n    \/\/ >>> isEqualToSumEven((8l))\n    \/\/ (true)\n    def isEqualToSumEven(n : Long) : Boolean = {\n","canonical_solution":"def isEqualToSumEven(n: Long): Boolean = {\n    \/\/ Explanation: A number is the sum of 4 positive even numbers if it is at least 8 and even.\n    n >= 8 && n % 2 == 0\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(isEqualToSumEven((4l)) == (false));\n    assert(isEqualToSumEven((6l)) == (false));\n    assert(isEqualToSumEven((8l)) == (true));\n    assert(isEqualToSumEven((10l)) == (true));\n    assert(isEqualToSumEven((11l)) == (false));\n    assert(isEqualToSumEven((12l)) == (true));\n    assert(isEqualToSumEven((13l)) == (false));\n    assert(isEqualToSumEven((16l)) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_139","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/དེར་ n > 0     \/\/brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1!     \/\/བརཱ་ཛིལ་གྱི་གནས་ལུགས་ནི་གཤམ་གསལ་ལྟར་ངེས་གཏན་བྱས་ཡོད།    \/\/ >>> specialFactorial((4l))\n    \/\/ (288l)\n    \/\/ The function will receive an integer as input and should return the special\n    \/\/ factorial of this integer.\n    def specialFactorial(n : Long) : Long = {\n","canonical_solution":"def specialFactorial(n: Long): Long = {\n        def factorial(x: Long): Long = {\n            if (x == 0 || x == 1) 1L\n            else x * factorial(x - 1)\n        }\n\n        (1L to n).map(factorial).product\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(specialFactorial((4l)) == (288l));\n    assert(specialFactorial((5l)) == (34560l));\n    assert(specialFactorial((7l)) == (125411328000l));\n    assert(specialFactorial((1l)) == (1l));\n    }\n\n}\n"},{"task_id":"HumanEval_140","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དེ་ནས་རིམ་བཞིན་གྱི་བར་སྟོང་རྣམས་ -   ཀྱིས་བརྗེ་བ།    \/\/གལ་ཏེ་ string ནང་ space གཉིས་ལས་མང་བ་ཡོད་ན།    \/\/ཚིག་ཡིག་ཡིག་སྣོད་ཅིག་ཡོད་ན་ ནང་གི་བར་སྟོང་ཆ་ཚང་མ་འོག་ཡིག་དང་ཚབ་བཙུགས་དགོས།    \/\/ >>> fixSpaces((\" Example\"))\n    \/\/ (\"Example\")\n    \/\/ >>> fixSpaces((\" Example 1\"))\n    \/\/ (\"Example_1\")\n    \/\/ >>> fixSpaces((\" Example 2\"))\n    \/\/ (\"_Example_2\")\n    \/\/ >>> fixSpaces((\" Example 3\"))\n    \/\/ (\"_Example-3\")\n    def fixSpaces(text : String) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def fixSpaces(text: String): String = {\n    val result = new StringBuilder()\n    var spaceCount = 0\n    var leadingSpace = true\n    \n    for (ch <- text) {\n      if (ch == ' ') {\n        spaceCount += 1\n      } else {\n        if (spaceCount > 0) {\n          if (leadingSpace && result.isEmpty) {\n            result.append('_')\n          } else if (spaceCount == 1) {\n            result.append('_')\n          } else if (spaceCount > 1) {\n            result.append('-')\n          }\n          spaceCount = 0\n        }\n        result.append(ch)\n        leadingSpace = false\n      }\n    }\n    \n    if (spaceCount == 1) {\n      result.append('_')\n    } else if (spaceCount > 1) {\n      result.append('-')\n    }\n    \n    result.toString()\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fixSpaces((\"Example\")).equals((\"Example\")));\n    assert(fixSpaces((\"Mudasir Hanif \")).equals((\"Mudasir_Hanif_\")));\n    assert(fixSpaces((\"Yellow Yellow  Dirty  Fellow\")).equals((\"Yellow_Yellow__Dirty__Fellow\")));\n    assert(fixSpaces((\"Exa   mple\")).equals((\"Exa-mple\")));\n    assert(fixSpaces((\"   Exa 1 2 2 mple\")).equals((\"-Exa_1_2_2_mple\")));\n    }\n\n}\n"},{"task_id":"HumanEval_141","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ཕྲེང་བ་རྗེས་ཀྱི་ཡིག་འབྲུ་ནི་གཤམ་གསལ་གྱི་གཅིག་རེད། ['txt', 'exe', 'dll']    \/\/ཤོག་གྲངས་ལ་དབྱིན་ཡིག་གི་ཡི་གེ་ (a-z, A-z) ཟེར་བ་ཡོད།    \/\/- ཕྲེང་བ་སྔོན་གྱི་ནང་དོན་ནི་སྟོང་པ་མི་དགོས། ཕྲེང་བ་དེའི་ནང་ཡི་གེ་    ནས་འགོ་འཛུགས་དགོས།    \/\/- ཡིག་སྣོད་མིང་གི་ནང་དོན་གཅིག་རང་ཡོད།    \/\/- ཡིག་སྣོད་མིང་དུ་ཨང་གྲངས་ ༣ ལས་ལྷག་མི་ཆོག (༠-༩)    \/\/ཚང་ཡོད་ན།    \/\/གལ་ཏེ་གཤམ་གསལ་གནས་སྟངས་ཚང་མ་ཡོད་ན་ཡིག་སྣོད་མིང་དེ་བདེན་པ་ཡིན་པར་བརྩི་དགོས།    \/\/གལ་ཏེ་ཡིག་སྣོད་མིང་གི་མིང་དེ་བདེན་པ་ཡིན་ན་ \"Yes\" དེ་ཡིན་ན་ \"No\" དེ་ཡིན་ན་ \"No\" ཟེར་བ་ཕྱིར་ལོག་བྱེད།    \/\/ཡིག་སྣོད་མིང་རྟགས་ཀྱི་ཐིག་ཡིག་ལེན་ནས་སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་བཟོ།    \/\/ >>> fileNameCheck((\"example.txt\"))\n    \/\/ (\"Yes\")\n    \/\/ >>> fileNameCheck((\"1example.dll\"))\n    \/\/ (\"No\")\n    def fileNameCheck(file_name : String) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def fileNameCheck(file_name: String): String = {\n    val validExtensions = Set(\"txt\", \"exe\", \"dll\")\n    val dotIndex = file_name.lastIndexOf('.')\n\n    if (dotIndex == -1) return \"No\"\n\n    val beforeDot = file_name.substring(0, dotIndex)\n    val afterDot = file_name.substring(dotIndex + 1)\n\n    if (beforeDot.isEmpty || !beforeDot.head.isLetter) return \"No\"\n\n    val digitCount = beforeDot.count(_.isDigit)\n    if (digitCount > 3) return \"No\"\n\n    if (!validExtensions.contains(afterDot)) return \"No\"\n\n    \"Yes\"\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(fileNameCheck(\"example.txt\")) \/\/ \"Yes\"\n    println(fileNameCheck(\"1example.dll\")) \/\/ \"No\"\n    println(fileNameCheck(\"test123.exe\")) \/\/ \"Yes\"\n    println(fileNameCheck(\".hidden.txt\")) \/\/ \"No\"\n    println(fileNameCheck(\"file..txt\")) \/\/ \"No\"\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(fileNameCheck((\"example.txt\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"1example.dll\")).equals((\"No\")));\n    assert(fileNameCheck((\"s1sdf3.asd\")).equals((\"No\")));\n    assert(fileNameCheck((\"K.dll\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"MY16FILE3.exe\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"His12FILE94.exe\")).equals((\"No\")));\n    assert(fileNameCheck((\"_Y.txt\")).equals((\"No\")));\n    assert(fileNameCheck((\"?aREYA.exe\")).equals((\"No\")));\n    assert(fileNameCheck((\"\/this_is_valid.dll\")).equals((\"No\")));\n    assert(fileNameCheck((\"this_is_valid.wow\")).equals((\"No\")));\n    assert(fileNameCheck((\"this_is_valid.txt\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"this_is_valid.txtexe\")).equals((\"No\")));\n    assert(fileNameCheck((\"#this2_i4s_5valid.ten\")).equals((\"No\")));\n    assert(fileNameCheck((\"@this1_is6_valid.exe\")).equals((\"No\")));\n    assert(fileNameCheck((\"this_is_12valid.6exe4.txt\")).equals((\"No\")));\n    assert(fileNameCheck((\"all.exe.txt\")).equals((\"No\")));\n    assert(fileNameCheck((\"I563_No.exe\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"Is3youfault.txt\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"no_one#knows.dll\")).equals((\"Yes\")));\n    assert(fileNameCheck((\"1I563_Yes3.exe\")).equals((\"No\")));\n    assert(fileNameCheck((\"I563_Yes3.txtt\")).equals((\"No\")));\n    assert(fileNameCheck((\"final..txt\")).equals((\"No\")));\n    assert(fileNameCheck((\"final132\")).equals((\"No\")));\n    assert(fileNameCheck((\"_f4indsartal132.\")).equals((\"No\")));\n    assert(fileNameCheck((\".txt\")).equals((\"No\")));\n    assert(fileNameCheck((\"s.\")).equals((\"No\")));\n    }\n\n}\n"},{"task_id":"HumanEval_142","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ལས་འགན་འདི་ནས་ཡིག་སྣོད་གྲངས་སུ་ 3 དང་ 4 ཀྱི་གྱངས་ཁ་མི་འདྲ་བའི་ཡིག་སྣོད་རྣམས་བརྗེ་སྒྱུར་བྱེད་ན། ལས་འགན་འདི་ནས་ཡིག་སྣོད་ཡོངས་ཀྱི་བསྡོམས་གྲངས་ཕྱིར་ལོག་བྱེད་རྒྱུ་ཡིན།    \/\/གྲངས་འབོར་ནི་ 3 ཀྱི་ལྡབ་གྲངས་ཡིན་པ་དང་དེའི་གཞི་གྲངས་ནི་ 4 ཀྱི་ལྡབ་གྲངས་ཡིན་ན་ ཧྲིལ་གྲངས་ཀྱི་གྲངས་འབོར་ནི་ 3 གྱི་ལྡབ་གྲངས་ཡིན་ན་ ཇི་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་ཡིན་    \/\/ལས་འགན་འདི་ནི་གྲངས་ཚང་གི་ཐོ་ཡིག་ཞིག་ལེན་ངེས་ཡིན། གྲངས་ཚང་གི་ཐོ་ཡིག་ནང་གི་ནང་འཇུག་ཆ་མཉམ་གྱི་ཆེད་དུ་ ལས་འགན་འདི་ནི་གྲངས་ཚང་གི་ནང་འཇུག་ཆ་གཉིས་སུ་རྩིས་དགོས་ན་དེའི་ནང་འཇུག་རྟགས་ནི་ a ཡིན།    \/\/\"     \/\/ >>> lst\n    \/\/ List[Long](1l.toLong, 2l.toLong, 3l.toLong)\n    \/\/ >>> lst\n    \/\/ List[Long]()\n    \/\/ >>> lst\n    \/\/ List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong)\n    def sumSquares(lst : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def sumSquares(lst: List[Long]): Long = {\n        lst.zipWithIndex.map { case (value, index) =>\n            if (index % 3 == 0) {\n                value * value\n            } else if (index % 4 == 0) {\n                value * value * value\n            } else {\n                value\n            }\n        }.sum\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sumSquares((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (6l));\n    assert(sumSquares((List[Long](1l.toLong, 4l.toLong, 9l.toLong))) == (14l));\n    assert(sumSquares((List[Long]())) == (0l));\n    assert(sumSquares((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))) == (9l));\n    assert(sumSquares((List[Long](-1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong))) == (-3l));\n    assert(sumSquares((List[Long](0l.toLong))) == (0l));\n    assert(sumSquares((List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong))) == (-126l));\n    assert(sumSquares((List[Long](-56l.toLong, -99l.toLong, 1l.toLong, 0l.toLong, -2l.toLong))) == (3030l));\n    assert(sumSquares((List[Long](-1l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, -1l.toLong))) == (0l));\n    assert(sumSquares((List[Long](-16l.toLong, -9l.toLong, -2l.toLong, 36l.toLong, 36l.toLong, 26l.toLong, -20l.toLong, 25l.toLong, -40l.toLong, 20l.toLong, -4l.toLong, 12l.toLong, -26l.toLong, 35l.toLong, 37l.toLong))) == (-14196l));\n    assert(sumSquares((List[Long](-1l.toLong, -3l.toLong, 17l.toLong, -1l.toLong, -15l.toLong, 13l.toLong, -1l.toLong, 14l.toLong, -14l.toLong, -12l.toLong, -5l.toLong, 14l.toLong, -14l.toLong, 6l.toLong, 13l.toLong, 11l.toLong, 16l.toLong, 16l.toLong, 4l.toLong, 10l.toLong))) == (-1448l));\n    }\n\n}\n"},{"task_id":"HumanEval_143","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཞི་དང་པོ།    \/\/ཚིག་རིམ་གསར་པའི་ནང་ ཚིག་རིམ་སྔོན་མའི་ནང་ཡོད་པ་ལྟར་བྱ་དགོས།    \/\/དེའི་རིང་ཚད་ནི་སྔོན་གྲངས་ཡིན།    \/\/ཟེར་བའི་ཚིག་ཡིག་ཐོག་མ་དེ་ཡོད་པའི་ string སླར་ལོག་བྱ་དགོས།    \/\/ཚིག་ཡིག་དེའི་ནང་ཡིག་འབྲུ་འགའ་ཤས་ཡོད་པའི་ནང་བར་སྟོང་བཞག་ཡོད་ན།    \/\/ཇི་འདྲ་ཞིག་ཡིན་རུང་།    \/\/ >>> wordsInSentence((\"This is a test\"))\n    \/\/ (\"is\")\n    \/\/ Example 2:\n    \/\/ >>> wordsInSentence((\"lets go for swimming\"))\n    \/\/ (\"go for\")\n    \/\/ Constraints:\n    \/\/ * 1 <= len(sentence) <= 100\n    \/\/ * sentence contains only letters\n    def wordsInSentence(sentence : String) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def isPrime(n: Int): Boolean = {\n    if (n < 2) false\n    else if (n == 2) true\n    else !(2 to sqrt(n).toInt).exists(n % _ == 0)\n  }\n\n  def wordsInSentence(sentence: String): String = {\n    val words = sentence.split(\" \")\n    val primeLengthWords = words.filter(word => isPrime(word.length))\n    primeLengthWords.mkString(\" \")\n  }\n  \n  \/\/ Example usage:\n  \/\/ println(wordsInSentence(\"This is a test\"))\n  \/\/ println(wordsInSentence(\"lets go for swimming\"))\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(wordsInSentence((\"This is a test\")).equals((\"is\")));\n    assert(wordsInSentence((\"lets go for swimming\")).equals((\"go for\")));\n    assert(wordsInSentence((\"there is no place available here\")).equals((\"there is no place\")));\n    assert(wordsInSentence((\"Hi I am Hussein\")).equals((\"Hi am Hussein\")));\n    assert(wordsInSentence((\"go for it\")).equals((\"go for it\")));\n    assert(wordsInSentence((\"here\")).equals((\"\")));\n    assert(wordsInSentence((\"here is\")).equals((\"is\")));\n    }\n\n}\n"},{"task_id":"HumanEval_144","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཁྱོད་ཀྱིས་ x དང་ n ནི་ཆ་ཤས་ངེས་ཅན་ཡིན་པར་ངེས་ཤིང་། གྲངས་སུ་ 0 མེད་པར་ངེས་པ་ཡོད།    \/\/གྲངས་དང་གྲངས་འཛིན་གཉིས་ཆ་རང་ནི་ཧྲིལ་པོ་རྩིས་ལྡན་ཡིན།    \/\/x དང་ n གཉིས་ནི་ཕྲེང་བའི་རྩིས་རྟགས་ཡིན་ཏེ། འདྲ་བཤུས་འདི་འདྲ་ཡིན་ཏེ།    \/\/x * n གྲངས་ཀ་ཧྲིལ་པོ་ཡིན་པ་དང་ false ཡིན་ན་ལས་འགན་ true སླར་ལོག་བྱེད།    \/\/ཁྱོད་ཀྱི་ལས་འགན་ནི་ function ཞིག་ལག་ལེན་དུ་འཇུག་ནས་ཚིག་བརྗོད་པ་དལ་བུར་བཟོ་བ།    \/\/ >>> simplify((\"1\/5\"), (\"5\/1\"))\n    \/\/ (true)\n    \/\/ >>> simplify((\"1\/6\"), (\"2\/1\"))\n    \/\/ (false)\n    \/\/ >>> simplify((\"7\/10\"), (\"10\/2\"))\n    \/\/ (false)\n    def simplify(x : String, n : String) : Boolean = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def simplify(x: String, n: String): Boolean = {\n    def parseFraction(fraction: String): (Int, Int) = {\n      val parts = fraction.split(\"\/\")\n      (parts(0).toInt, parts(1).toInt)\n    }\n\n    val (numX, denX) = parseFraction(x)\n    val (numN, denN) = parseFraction(n)\n\n    val multipliedNumerator = numX * numN\n    val multipliedDenominator = denX * denN\n\n    multipliedNumerator % multipliedDenominator == 0\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(simplify((\"1\/5\"), (\"5\/1\")) == (true));\n    assert(simplify((\"1\/6\"), (\"2\/1\")) == (false));\n    assert(simplify((\"5\/1\"), (\"3\/1\")) == (true));\n    assert(simplify((\"7\/10\"), (\"10\/2\")) == (false));\n    assert(simplify((\"2\/10\"), (\"50\/10\")) == (true));\n    assert(simplify((\"7\/2\"), (\"4\/2\")) == (true));\n    assert(simplify((\"11\/6\"), (\"6\/1\")) == (true));\n    assert(simplify((\"2\/3\"), (\"5\/2\")) == (false));\n    assert(simplify((\"5\/2\"), (\"3\/5\")) == (false));\n    assert(simplify((\"2\/4\"), (\"8\/4\")) == (true));\n    assert(simplify((\"2\/4\"), (\"4\/2\")) == (true));\n    assert(simplify((\"1\/5\"), (\"5\/1\")) == (true));\n    assert(simplify((\"1\/5\"), (\"1\/5\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_145","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/ཤོག་གྲངས་ཐོག་མའི་ནང་ཡོད་པའི་ index གྱི་གཞི་རྟེན་ཐོག་ནས་རིམ་སྒྲིག་བྱེད་པ།    \/\/དྲན་གསོ། གལ་ཏེ་ནང་དོན་ཁ་ཤས་ཀྱི་ཨང་གྲངས་བསྡོམས་འདྲ་མཚུངས་ཡོད་ན།    \/\/ཤོག་གྲངས་ཀྱི་གོ་རིམ་ལྟར་ཡར་འཕར་གྱི་གོ་རིམ་ལྟར་ཡིན།    \/\/འདིར་གྲངས་ཚང་གི་ཐོ་ཡིག་ལ་རིམ་སྒྲིག་བྱེད་པའི་ལས་འགན་ཞིག་བྲིས་དགོས།    \/\/ >>> orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong)))\n    \/\/ (List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))\n    \/\/ >>> orderByPoints((List[Long]()))\n    \/\/ (List[Long]())\n    def orderByPoints(nums : List[Long]) : List[Long] = {\n","canonical_solution":"def orderByPoints(nums: List[Long]): List[Long] = {\n    def digitSum(n: Long): Int = n.abs.toString.map(_.asDigit).sum\n    \n    nums.zipWithIndex\n      .sortBy { case (num, index) => (digitSum(num), index) }\n      .map(_._1)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));\n    assert(orderByPoints((List[Long](1234l.toLong, 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong, 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong, 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));\n    assert(orderByPoints((List[Long]())).equals((List[Long]())));\n    assert(orderByPoints((List[Long](1l.toLong, -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong, -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));\n    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong, 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))));\n    assert(orderByPoints((List[Long](0l.toLong, 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong, -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_146","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/གྲངས་ཀྱི་ཨང་གྲངས་དང་པོ་དང་མཐའ་མ་ནི་རྣམ་གྲངས་ཡིན། (1, 3, 5, 7, 9)    \/\/ཤོག་གྲངས་ 10 ལས་མང་བའི་གྲངས་ཀ་དང་གཉིས་ཀ་ཡིན།    \/\/གྲངས་ཐོ་ཞིག་ནང་འཇུག་དང་ཕྱིར་ལོག་བྱེད་པའི་ལས་འགན་ཞིག་བྲིས་ཤིག    \/\/ >>> specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong)))\n    \/\/ (1l)\n    \/\/ >>> specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong)))\n    \/\/ (2l)\n    def specialFilter(nums : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def specialFilter(nums: List[Long]): Long = {\n    def isOddDigit(c: Char): Boolean = c == '1' || c == '3' || c == '5' || c == '7' || c == '9'\n    \n    nums.count { num =>\n      val absNumStr = num.abs.toString\n      val firstDigit = absNumStr.head\n      val lastDigit = absNumStr.last\n      \n      num > 10 && isOddDigit(firstDigit) && isOddDigit(lastDigit)\n    }.toLong\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(specialFilter(List(15L, -73L, 14L, -15L))) \/\/ Output: 1\n    println(specialFilter(List(33L, -2L, -3L, 45L, 21L, 109L))) \/\/ Output: 2\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(specialFilter((List[Long](5l.toLong, -2l.toLong, 1l.toLong, -5l.toLong))) == (0l));\n    assert(specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong))) == (1l));\n    assert(specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong))) == (2l));\n    assert(specialFilter((List[Long](43l.toLong, -12l.toLong, 93l.toLong, 125l.toLong, 121l.toLong, 109l.toLong))) == (4l));\n    assert(specialFilter((List[Long](71l.toLong, -2l.toLong, -33l.toLong, 75l.toLong, 21l.toLong, 19l.toLong))) == (3l));\n    assert(specialFilter((List[Long](1l.toLong))) == (0l));\n    assert(specialFilter((List[Long]())) == (0l));\n    }\n\n}\n"},{"task_id":"HumanEval_147","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་མཚོན།:    \/\/a[i] + a[j] + a[k] ནི་ 3 ཀྱི་ལྡབ་བའང་ཡིན།    \/\/ཕྱིར་ལོག་བྱེད་གྲངས་ནི་ a གི་ triples (a[i], a[j], a[k]) གྱི་གྲངས་ཡིན། དེར་ i < j < k,     \/\/i (1 ≤ i ≤ n) རེ་རེ་ལ་ a[i] = i * i - i + 1 གྱི་ཐང་ཡིན།    \/\/ཁྱོད་ཀྱིས་གྲངས་ཆ་ཚིམས་ n ཞིག་ཐོབ་ཡོད། ཁྱོད་ཀྱིས་གྲངས་ཆ་ཚིམས་ a ཡི་ཐོ་ཚད་ n བཟོ་དགོས།    \/\/ >>> getMaxTriples((5l))\n    \/\/ (1l)\n    \/\/ Explanation: \n    \/\/ a = [1, 3, 7, 13, 21]\n    \/\/ The only valid triple is (1, 7, 13).\n    def getMaxTriples(n : Long) : Long = {\n","canonical_solution":"def getMaxTriples(n: Long): Long = {\n    val a = (1L to n).map(i => i * i - i + 1).toList\n    var count = 0L\n\n    for {\n      i <- 0L until n\n      j <- i + 1 until n\n      k <- j + 1 until n\n    } {\n      if ((a(i.toInt) + a(j.toInt) + a(k.toInt)) % 3 == 0) {\n        count += 1\n      }\n    }\n\n    count\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(getMaxTriples((5l)) == (1l));\n    assert(getMaxTriples((6l)) == (4l));\n    assert(getMaxTriples((10l)) == (36l));\n    assert(getMaxTriples((100l)) == (53361l));\n    }\n\n}\n"},{"task_id":"HumanEval_148","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/སྐར་མ་མིང་ནི་དྲང་པོ་མིན་འདུག    \/\/ལས་འགན་འདི་ plan1 ཡང་ན་ plan2 ཡིན་ན་སྟོང་པའི་ཐུལ་པི་ཕྱིར་ལོག་བྱེད་དགོས།    \/\/ཉི་མའི་ཉེ་འགྲམ་ལ།    \/\/སྐར་ཆེན་1དང་སྐར་ཆེན་2ཀྱི་འཁོར་ལམ་བར་གྱི་ས་ཁུལ།    \/\/ལས་འགན་འདི་གིས་ སྐར་མ་ཚང་མའི་འཁོར་ལམ་ ཡོད་པའི་འཁོར་ལམ་ལོག་འཇུག་དགོས།    \/\/སྐར་མ་གཉིས་ཀྱི་མིང་ planet1 དང་ planet2 ཟེར་བའི་ཐིག་ཡིག་ནང་བཀོད་དགོས།    \/\/ཨུ་རུ་ནུ། ནེ་པྲུན་བཅས་ཡིན།    \/\/མུ་རུའི་སྟེང་གི་ས་བོན་ནི་ཝེ་ནེར་ཡིན། དེའི་རྗེས་ལ་འཛམ་གླིང་དང་། མཱར་སི་དང་། མུ་པི་ཊར་དང་། སཱ་ཏུར་ནེ།    \/\/ཉི་མའི་ལམ་ལུགས་ནང་སྐར་ཆེན་བརྒྱད་ཡོད་ཅིང་། ཉི་མའི་ཉེ་འགྲམ་ཆགས་པའི་སྐར་ཆེན་ཡིན།    \/\/ >>> bf((\"Jupiter\"), (\"Neptune\"))\n    \/\/ (List[String](\"Saturn\", \"Uranus\"))\n    \/\/ >>> bf((\"Earth\"), (\"Mercury\"))\n    \/\/ (List[String](\"Venus\"))\n    \/\/ >>> bf((\"Mercury\"), (\"Uranus\"))\n    \/\/ (List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) : List[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def bf(planet1: String, planet2: String): List[String] = {\n    val planets = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    \n    \/\/ Find the indices of the given planets\n    val index1Opt = planets.indexOf(planet1)\n    val index2Opt = planets.indexOf(planet2)\n    \n    \/\/ If either planet is not found, return an empty list\n    if (index1Opt == -1 || index2Opt == -1) {\n      return List.empty\n    }\n    \n    \/\/ Sort indices to ensure proper traversal direction\n    val (startIndex, endIndex) = if (index1Opt < index2Opt) (index1Opt, index2Opt) else (index2Opt, index1Opt)\n    \n    \/\/ Get the planets between the indices\n    planets.slice(startIndex + 1, endIndex)\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"},{"task_id":"HumanEval_149","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/ཁྱོད་ཀྱིས་ཚིག་ཐམས་ཅད་རིང་ཚད་གཅིག་མཚུངས་ཡིན་པར་བསམ་ཐུབ།    \/\/ལས་འགན་འདི་ནི་ string ཀྱི་ཐོ་ཡིག་རིམ་བཞིན་ཕྱིར་ལོག་བྱེད་དགོས།    \/\/ཚིག་གཉིས་རིང་ཚད་གཅིག་མཚུངས་ཡོད་ན་ཡིག་ཐོ་ལ་ཨེབ་གྲངས་རིམ་བཞིན་དབྱེ་དགོས།    \/\/ཚད་གཞི་དེ་དང་བསྟུན་ཏེ་ཐོ་ཡིག་དེ་ལོག་འཇུག་དགོས།    \/\/ཚིག་རེ་རེ་བཞིན་རིམ་བཞིན་ཡར་འཕོ་དགོས་པ་དང་། ཁྱོད་ཀྱིས་    \/\/འདྲ་པར་གཉིས་པ་ཡང་ཡོད་སྲིད་ཀྱི་རེད།    \/\/ཤོག་གྲངས་ནི་གཏན་ནས་ཡིག་འབྲུ་གི་ཐོ་ཡིག་ཞིག་ཡིན་པས་གྲངས་ཀྱི་ཐོ་ཡིག་ནམ་ཡང་མི་འདུག    \/\/ཕྱིར་ལོག་བྱས་ན་ཐོ་ཡིག་དེ་རིམ་སྒྲིག་བྱས་ཡོད།    \/\/ཚད་མ་རྣམ་གྲངས་ཡོད་པའི་ string རྣམས་འདེམས་ནས་སེལ་བ།    \/\/ཚད་གཞི་ལྟར་ཐིག་ཡིག་གི་ཐོ་ཡིག་ལེན་པའི་ལས་འགན་ཞིག་བྲིས་པ།    \/\/ >>> listSort((List[String](\"aa\", \"a\", \"aaa\")))\n    \/\/ (List[String](\"aa\"))\n    \/\/ >>> listSort((List[String](\"ab\", \"a\", \"aaa\", \"cd\")))\n    \/\/ (List[String](\"ab\", \"cd\"))\n    def sortedListSum(lst : List[String]) : List[String] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n    def listSort(lst: List[String]): List[String] = {\n        lst.filter(_.length % 2 == 0)\n           .sorted\n           .sortBy(_.length)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(sortedListSum((List[String](\"aa\", \"a\", \"aaa\"))).equals((List[String](\"aa\"))));\n    assert(sortedListSum((List[String](\"school\", \"AI\", \"asdf\", \"b\"))).equals((List[String](\"AI\", \"asdf\", \"school\"))));\n    assert(sortedListSum((List[String](\"d\", \"b\", \"c\", \"a\"))).equals((List[String]())));\n    assert(sortedListSum((List[String](\"d\", \"dcba\", \"abcd\", \"a\"))).equals((List[String](\"abcd\", \"dcba\"))));\n    assert(sortedListSum((List[String](\"AI\", \"ai\", \"au\"))).equals((List[String](\"AI\", \"ai\", \"au\"))));\n    assert(sortedListSum((List[String](\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"))).equals((List[String]())));\n    assert(sortedListSum((List[String](\"aaaa\", \"bbbb\", \"dd\", \"cc\"))).equals((List[String](\"cc\", \"dd\", \"aaaa\", \"bbbb\"))));\n    }\n\n}\n"},{"task_id":"HumanEval_150","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/གྲངས་ཚིག དང་ y གི་ཐང་ལོག་འཇུག་དགོས།    \/\/གལ་ཏེ་ n ནི་ ཡིན་ན་ x གི་ཐང་ཕྱིར་ལོག་བྱ་རྒྱུའི་ལས་རིམ་དྭངས་མ་ཞིག་ཡིན།    \/\/ >>> xOrY((7l), (34l), (12l))\n    \/\/ (34l)\n    \/\/ >>> xOrY((15l), (8l), (5l))\n    \/\/ (5l)\n    def xOrY(n : Long, x : Long, y : Long) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  \n  def isPrime(num: Long): Boolean = {\n    if (num <= 1) return false\n    if (num <= 3) return true\n    if (num % 2 == 0 || num % 3 == 0) return false\n    var i = 5\n    while (i * i <= num) {\n      if (num % i == 0 || num % (i + 2) == 0) return false\n      i += 6\n    }\n    true\n  }\n\n  def xOrY(n: Long, x: Long, y: Long): Long = {\n    if (isPrime(n)) x else y\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(xOrY((7l), (34l), (12l)) == (34l));\n    assert(xOrY((15l), (8l), (5l)) == (5l));\n    assert(xOrY((3l), (33l), (5212l)) == (33l));\n    assert(xOrY((1259l), (3l), (52l)) == (3l));\n    assert(xOrY((7919l), (-1l), (12l)) == (-1l));\n    assert(xOrY((3609l), (1245l), (583l)) == (583l));\n    assert(xOrY((91l), (56l), (129l)) == (129l));\n    assert(xOrY((6l), (34l), (1234l)) == (1234l));\n    assert(xOrY((1l), (2l), (0l)) == (0l));\n    assert(xOrY((2l), (2l), (0l)) == (2l));\n    }\n\n}\n"},{"task_id":"HumanEval_151","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/གྲངས་ཆ་མེད་དང་མི་ལྡན་པའི་གྲངས་ཆ་ལ་སྣང་མེད་དུ་འཇོག་དགོས།    \/\/གྲངས་ཐོ་ཞིག་ཡོད་ན། གྲངས་ཀའི་གྲུ་བཞི་གི་བསྡོམས་གྲངས་ཕྱིར་ལོག་བྱེད་ཅིག    \/\/ >>> doubleTheDifference((List[Float](1l.toLong, 3l.toLong, 2l.toLong, 0l.toLong)))\n    \/\/ (10l)\n    \/\/ >>> doubleTheDifference((List[Float](-1l.toLong, -2l.toLong, 0l.toLong)))\n    \/\/ (0l)\n    \/\/ >>> doubleTheDifference((List[Float](9l.toLong, -2l.toLong)))\n    \/\/ (81l)\n    \/\/ >>> doubleTheDifference((List[Float](0l.toLong)))\n    \/\/ (0l)\n    \/\/ If the input list is empty, return 0.\n    def doubleTheDifference(lst : List[Float]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def doubleTheDifference(lst: List[Float]): Long = {\n    lst.filter(x => x > 0 && x.isValidLong && x.toLong % 2 != 0)\n      .map(x => x.toLong * x.toLong)\n      .sum\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(doubleTheDifference((List[Float]())) == (0l));\n    assert(doubleTheDifference((List[Float](5.0f.toFloat, 4.0f.toFloat))) == (25l));\n    assert(doubleTheDifference((List[Float](0.1f.toFloat, 0.2f.toFloat, 0.3f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](-10.0f.toFloat, -20.0f.toFloat, -30.0f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](-1.0f.toFloat, -2.0f.toFloat, 8.0f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](0.2f.toFloat, 3.0f.toFloat, 5.0f.toFloat))) == (34l));\n    assert(doubleTheDifference((List[Float](-9.0f.toFloat, -7.0f.toFloat, -5.0f.toFloat, -3.0f.toFloat, -1.0f.toFloat, 1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat, 9.0f.toFloat))) == (165l));\n    }\n\n}\n"},{"task_id":"HumanEval_152","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/ཚད་ནི་ 0 ཡིན་པ་དང་། གལ་ཏེ་དེ་ 0 ཡིན་ན་ཚད་ནི་དཔེར་བརྗོད་དང་ཐིག་ཁྲམ་གཉིས་ཀྱི་བར་གྱི་ཁྱད་པར་གཏན་ནས་ཡིན།    \/\/ཚད་གཅིག་མཚུངས་ཀྱི་ཐོ་ཡིག་ཕྱིར་ལོག་བྱེད་དེ། ཚོད་དཔག་གང་ཙམ་ཐག་རིང་ཡོད་པར་མཚོན་པ་ཡིན། གལ་ཏེ་ཚོད་དཔག་དེ་བདེན་པ་ཡིན་ན་     \/\/ཁྱོད་ཚོར་ཚད་གཞི་དང་ཚོད་དཔག་ཚད་འདྲ་མཉམ་གྱི་ཐོ་གཉིས་ཐོབ་ཡོད། ཚད་གཞི་རེ་རེར་གཅིག་མཚུངས་ཡོད་པར་སྟོན་ཡོད།    \/\/ཁྱོད་ཀྱི་ལས་འགན་ནི་མི་ཞིག་གིས་འགྲན་བསྡུར་གྱི་གྲུབ་འབྲས་དེ་བདེན་པར་ཚོད་ལྟ་བྱས་ཡོད་མེད་ལ་བརྟག་དཔྱད་བྱེད་རྒྱུ་དེ་ཡིན།    \/\/འདྲ་བཤུས་དང་བསྡུར་བྱེད་འོས་པ་ཞིག་རེད།    \/\/བྱུང་རིམ་དེ་མཇུག་ཏུ་ཤེས་རྟོགས་བྱུང་ཡོད། དེ་དུས་ཁྱེད་རང་ཚོར་བའི་ཚོར་སྣང་དང་བསམ་བློ་རྣམས་    \/\/ཚང་མས་དུས་ཡུན་རིང་པོར་སྒུག་པའི་རྐྱེན་གྱི་ཚོར་བ་དེ་དྲན་གྱི་རེད།    \/\/ >>> compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong)))\n    \/\/ (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))\n    \/\/ >>> compare((List[Long](0l.toLong, 5l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 4l.toLong)), (List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, -2l.toLong)))\n    \/\/ (List[Long](4l.toLong, 4l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, 6l.toLong))\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def compare(game: List[Long], guess: List[Long]): List[Long] = {\n    game.zip(guess).map { case (g, gs) => abs(g - gs) }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_153","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/(དེའི་ཤུགས་ནི་ -༡) ཡིན།    \/\/return \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension ཟེར་བ་འདི་ནི་ཁ་སྐོང་ཤུགས་ཆེ་ཤོས་ཡིན་པས་ཕྱིར་ལོག་བྱེད།    \/\/རྒྱས་འགྲེལ། ['SERVINGSliCes', 'Cheese', 'StuFfed'] བྱས་ན་ཁྱེད་ཀྱིས་     \/\/དཔེར་ན་ \"Slices\" ཟེར་བའི་སློབ་ཚན་དང་ ཤོག་གྲངས་ཀྱི་ཐོ་ཡིག་ཐོབ་ཡོད་ན།    \/\/ཤོག་ངོས་དང་པོ་ལ་གང་ཞིག་ཡོད་ན་འདེམས་དགོས།    \/\/གལ་ཏེ་ནུས་པ་གཅིག་མཚུངས་ཡོད་པའི་ extension གཉིས་སམ་དེ་ལས་མང་བ་ཡོད་ན།    \/\/format: ClassName.StrongestExtensionName.   ཚད་འཛིན་མིང་། ཚད་འཛིན་མིང་། ཚད་འཛིན་མིང་། ཚད་འཛིན་མིང་། ཚད་འཛིན་མིང་། ཚད་འཛིན་མིང་།    \/\/ཁྱོད་ཀྱིས་ཤུགས་ཆེ་ཤོས་ཀྱི་ extension འཚོལ་ནས་དེའི་ནང་ string སླར་ལོག་བྱེད་དགོས།    \/\/ཤུགས་ཚད་ནི་ CAP-SM ཀྱི་ཆ་ཤས་ཀྱིས་སྟོན་ཡོད།    \/\/ཡིག་འབྲུ་ཆུང་ཆུང་གི་མིང་དུ་ SM ཟེར་དགོས།    \/\/ཚད་འཛིན་གྱི་ནུས་པ་འདི་འདྲ་ཡིན། CAP ནི་ཡིག་འབྲུ་ཆེན་པོའི་གྲངས་ཀ་ཡིན་པར་བྱའོ།    \/\/རྒྱས་འགྲེལ། ཚད་མ་དེ་སློབ་ཚན་གྱི་ནང་འཇུག་བྱེད་ཆེད་བེད་སྤྱོད་བྱ་དགོས།    \/\/ཁྱོད་ཚོར་ class གི་མིང་ (string) དང་ extension གྱི་ཐོ་ཡིག་ཐོབ་པར་འགྱུར།    \/\/ >>> StrongestExtension((\"my_class\"), (List[String](\"AA\", \"Be\", \"CC\")))\n    \/\/ (\"my_class.AA\")\n    def StrongestExtension(class_name : String, extensions : List[String]) : String = {\n","canonical_solution":"def StrongestExtension(class_name: String, extensions: List[String]): String = {\n        extensions.map { extension =>\n            val capCount = extension.count(_.isUpper)\n            val lowerCount = extension.count(_.isLower)\n            val strength = capCount - lowerCount\n            (extension, strength)\n        }.maxBy(_._2)._1\n    } match {\n        case strongest => s\"$class_name.$strongest\"\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"},{"task_id":"HumanEval_154","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཁྱོད་ཀྱིས་ཚིག་གཉིས་ཐོབ་ཡོད། གལ་ཏེ་ཚིག་གཉིས་པ་ཡང་ན་དེའི་འཁོར་བ་གང་ཞིག་ནི་ཚིག་དང་པོའི་ནང་གི་འོག་རིམ་ཡིན་ན་ true སླར་ལོག་བྱེད་དགོས་པ་ཡིན།    \/\/ >>> cycpatternCheck((\"abcd\"), (\"abd\"))\n    \/\/ (false)\n    \/\/ >>> cycpatternCheck((\"hello\"), (\"ell\"))\n    \/\/ (true)\n    \/\/ >>> cycpatternCheck((\"whassup\"), (\"psus\"))\n    \/\/ (false)\n    \/\/ >>> cycpatternCheck((\"abab\"), (\"baa\"))\n    \/\/ (true)\n    \/\/ >>> cycpatternCheck((\"efef\"), (\"eeff\"))\n    \/\/ (false)\n    \/\/ >>> cycpatternCheck((\"himenss\"), (\"simen\"))\n    \/\/ (true)\n    def cycpatternCheck(a : String, b : String) : Boolean = {\n","canonical_solution":"def cycpatternCheck(a: String, b: String): Boolean = {\n  val bLength = b.length\n  val bDouble = b + b \/\/ Create a string with b concatenated with itself to represent all rotations\n  for (i <- 0 until bLength) {\n    val rotation = bDouble.substring(i, i + bLength) \/\/ Get the current rotation\n    if (a.contains(rotation)) return true\n  }\n  false\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(cycpatternCheck((\"xyzw\"), (\"xyw\")) == (false));\n    assert(cycpatternCheck((\"yello\"), (\"ell\")) == (true));\n    assert(cycpatternCheck((\"whattup\"), (\"ptut\")) == (false));\n    assert(cycpatternCheck((\"efef\"), (\"fee\")) == (true));\n    assert(cycpatternCheck((\"abab\"), (\"aabb\")) == (false));\n    assert(cycpatternCheck((\"winemtt\"), (\"tinem\")) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_155","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/གྲངས་ཆ་ཚག་དང་གྲངས་ཆ་ཆ་མི་ཚག་གཉིས་ཡོད་པ།     \/\/ >>> evenOddCount((-12l))\n    \/\/ ((1l, 1l))\n    \/\/ >>> evenOddCount((123l))\n    \/\/ ((1l, 2l))\n    def evenOddCount(num : Long) : Tuple2[Long, Long] = {\n","canonical_solution":"def evenOddCount(num: Long): Tuple2[Long, Long] = {\n  val digits = num.abs.toString.map(_.asDigit)\n  val evenCount = digits.count(_ % 2 == 0).toLong\n  val oddCount = digits.count(_ % 2 != 0).toLong\n  (evenCount, oddCount)\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(evenOddCount((7l)).equals(((0l, 1l))));\n    assert(evenOddCount((-78l)).equals(((1l, 1l))));\n    assert(evenOddCount((3452l)).equals(((2l, 2l))));\n    assert(evenOddCount((346211l)).equals(((3l, 3l))));\n    assert(evenOddCount((-345821l)).equals(((3l, 3l))));\n    assert(evenOddCount((-2l)).equals(((1l, 0l))));\n    assert(evenOddCount((-45347l)).equals(((2l, 3l))));\n    assert(evenOddCount((0l)).equals(((1l, 0l))));\n    }\n\n}\n"},{"task_id":"HumanEval_156","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ཚད་འཛིན་: 1 <= num <= 1000    \/\/ཆེ་ཆུང་ཡིག་གཟུགས་ནང་ཕྱིར་ལོག་བྱེད་ཅིག    \/\/འབྲས་བུ་ལྡན་གྲངས་ཤིག་ཡོད་ན། རོམ་གྲངས་ཀྱི་འདྲ་མཚུངས་དེ་ཐིག་ཡིག་ལྟར་ལེན་དགོས།    \/\/ >>> intToMiniRoman((19l))\n    \/\/ (\"xix\")\n    \/\/ >>> intToMiniRoman((152l))\n    \/\/ (\"clii\")\n    \/\/ >>> intToMiniRoman((426l))\n    \/\/ (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n","canonical_solution":"import scala.collection.mutable._\n\nobject Problem {\n  def intToMiniRoman(number: Long): String = {\n    val romanMap: List[(Int, String)] = List(\n      (1000, \"m\"),\n      (900, \"cm\"),\n      (500, \"d\"),\n      (400, \"cd\"),\n      (100, \"c\"),\n      (90, \"xc\"),\n      (50, \"l\"),\n      (40, \"xl\"),\n      (10, \"x\"),\n      (9, \"ix\"),\n      (5, \"v\"),\n      (4, \"iv\"),\n      (1, \"i\")\n    )\n\n    var num = number.toInt\n    val stringBuilder = new StringBuilder\n\n    for ((value, roman) <- romanMap) {\n      while (num >= value) {\n        stringBuilder.append(roman)\n        num -= value\n      }\n    }\n\n    stringBuilder.toString()\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n}\n"},{"task_id":"HumanEval_157","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/ཚད་མ་ ༩༠ ཡོད་པ་རེད།    \/\/ཟུར་གསུམ་ཟུར་དྲང་པོ་ནི་ཟུར་གསུམ་གྱི་ཟུར་གཅིག་ཟུར་དྲང་པོ་ཡིན་པའམ། ཡང་ན་    \/\/ཕྱོགས་གཉིས་ནི་ཟུར་དྲང་གསུམ་གྱི་དབྱིབས་ཡིན་ན། འདྲ་མིན་ན་རྫུན་རེད།    \/\/ཚད་གསུམ་གྱི་ཟུར་གསུམ་གྱི་རིང་ཚད་ཡོད་ན། true སླར་ལོག་བྱེད།    \/\/ >>> rightAngleTriangle((3l), (4l), (5l))\n    \/\/ (true)\n    \/\/ >>> rightAngleTriangle((1l), (2l), (3l))\n    \/\/ (false)\n    def rightAngleTriangle(a : Long, b : Long, c : Long) : Boolean = {\n","canonical_solution":"def rightAngleTriangle(a: Long, b: Long, c: Long): Boolean = {\n        val sides = List(a, b, c).sorted\n        pow(sides(0), 2) + pow(sides(1), 2) == pow(sides(2), 2)\n    }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(rightAngleTriangle((3l), (4l), (5l)) == (true));\n    assert(rightAngleTriangle((1l), (2l), (3l)) == (false));\n    assert(rightAngleTriangle((10l), (6l), (8l)) == (true));\n    assert(rightAngleTriangle((2l), (2l), (2l)) == (false));\n    assert(rightAngleTriangle((7l), (24l), (25l)) == (true));\n    assert(rightAngleTriangle((10l), (5l), (7l)) == (false));\n    assert(rightAngleTriangle((5l), (12l), (13l)) == (true));\n    assert(rightAngleTriangle((15l), (8l), (17l)) == (true));\n    assert(rightAngleTriangle((48l), (55l), (73l)) == (true));\n    assert(rightAngleTriangle((1l), (1l), (1l)) == (false));\n    assert(rightAngleTriangle((2l), (2l), (10l)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_158","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ཡིག་འབྲུ་ནང་ཚིག་མཛོད་ཀྱི་རིམ་པ་ཐོག་མར་ཐོན་པ་ཕྱིར་ལོག་བྱེད་པ།    \/\/གལ་ཏེ་ string མང་པོ་ཡོད་ན་ unique  གྱི་གྲངས་མང་ཤོས་ཡོད་ན་    \/\/ཚིག་གྲངས་ཀྱི་གྲངས་ཚད་མཐོ་ཤོས་ཡོད་པའི། ཚིག་གྲངས་ཁ་སྐོང་སླར་ལོག་འབད།    \/\/string གི་ཐོ་ཡིག་ངོས་ལེན་བྱེད་པའི་ function ཞིག་འབྲི་དགོས།    \/\/ >>> findMax((List[String](\"name\", \"of\", \"string\")))\n    \/\/ (\"string\")\n    \/\/ >>> findMax((List[String](\"name\", \"enam\", \"game\")))\n    \/\/ (\"enam\")\n    \/\/ >>> findMax((List[String](\"aaaaaaa\", \"bb\", \"cc\")))\n    \/\/ (\"aaaaaaa\")\n    def findMax(words : List[String]) : String = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def findMax(words: List[String]): String = {\n    words.maxBy(word => (word.toSet.size, -word.toLowerCase))\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(findMax((List[String](\"name\", \"of\", \"string\"))).equals((\"string\")));\n    assert(findMax((List[String](\"name\", \"enam\", \"game\"))).equals((\"enam\")));\n    assert(findMax((List[String](\"aaaaaaa\", \"bb\", \"cc\"))).equals((\"aaaaaaa\")));\n    assert(findMax((List[String](\"abc\", \"cba\"))).equals((\"abc\")));\n    assert(findMax((List[String](\"play\", \"this\", \"game\", \"of\", \"footbott\"))).equals((\"footbott\")));\n    assert(findMax((List[String](\"we\", \"are\", \"gonna\", \"rock\"))).equals((\"gonna\")));\n    assert(findMax((List[String](\"we\", \"are\", \"a\", \"mad\", \"nation\"))).equals((\"nation\")));\n    assert(findMax((List[String](\"this\", \"is\", \"a\", \"prrk\"))).equals((\"this\")));\n    assert(findMax((List[String](\"b\"))).equals((\"b\")));\n    assert(findMax((List[String](\"play\", \"play\", \"play\"))).equals((\"play\")));\n    }\n\n}\n"},{"task_id":"HumanEval_159","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་ཆ།     \/\/གལ་ཏེ་མར་ཀེ་རོ་ཊི་ལྷག་མ་གངམ་མེད་ན། ཁྱོད་ཀྱིས་མར་ཀེ་རོ་ཊི་ལྷག་མ་ཚང་མ་ཟ་ནའང་མུ་གེས་ལུས་པར་འགྱུར།    \/\/ཟ་ཚར་རྗེས་ལྷག་པའི་ཀེ་རོ་ཊི་གྲངས་ ]     \/\/ཟ་ཚར་བའི་རྗེས་ལ་ཟ་བའི་ཀེ་རོ་ཊའི་གྲངས་ཚད།    \/\/ད་ལྟའི་ཟས་རེའི་ནང་ག་ག་མང་ཟ་དགོས་པ་རེད།    \/\/ཁྱོད་ནི་ལྟོ་བ་ཚ་བའི་བེའུ་ཞིག་རེད། ཁྱོད་ཀྱིས་ག་རེར་ག་རེར་ག་རེར་ཟ་ཚར་ཡོད།    \/\/ >>> eat((5l), (6l), (10l))\n    \/\/ (List[Long](11l.toLong, 4l.toLong))\n    \/\/ >>> eat((4l), (8l), (9l))\n    \/\/ (List[Long](12l.toLong, 1l.toLong))\n    \/\/ >>> eat((1l), (10l), (10l))\n    \/\/ (List[Long](11l.toLong, 0l.toLong))\n    \/\/ >>> eat((2l), (11l), (5l))\n    \/\/ (List[Long](7l.toLong, 0l.toLong))\n    \/\/ Variables:\n    \/\/ @number : integer\n    \/\/ the number of carrots that you have eaten.\n    \/\/ @need : integer\n    \/\/ the number of carrots that you need to eat.\n    \/\/ @remaining : integer\n    \/\/ the number of remaining carrots thet exist in stock\n    \/\/ Constrain:\n    \/\/ * 0 <= number <= 1000\n    \/\/ * 0 <= need <= 1000\n    \/\/ * 0 <= remaining <= 1000\n    \/\/ Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def eat(number: Long, need: Long, remaining: Long): List[Long] = {\n    val totalNeeded = number + need\n    if (remaining >= need) {\n      List(totalNeeded, remaining - need)\n    } else {\n      List(number + remaining, 0)\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"},{"task_id":"HumanEval_160","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/ལས་བྱེད་ཐོ་ཡིག་ནང་ ལས་བྱེད་གཅིག་ལས་ཉུང་བ་མེད་པ་དང་། ལས་བྱེད་ཐོ་ཡིག་ནང་ ལས་བྱེད་གཉིས་ལས་ཉུང་བ་མེད་པ།    \/\/ཨོ་པེ་རན་ཌི་ནི་ ནེ་གེ་རེ་ཊི་མེད་པའི་ཧྲིལ་གྲངས་ཀྱི་ཐོ་ཡིག་ཡིན།    \/\/འབྲེལ་བའི་ཡིག་ཆའི་རིང་ཚད་ནི་ འབྲེལ་བའི་ཡིག་ཆའི་རིང་ཚད་དང་ཉུང་བ་ ༡ འདྲ།    \/\/དྲན་གསོ།    \/\/= = གྲུབ་འབྲས་ = 9     \/\/འབྲས་བུ་ནི་ 2 + 3 * 4 - 5 ཡིན།    \/\/list = [2, 3, 4, 5] ཟེར་བ་ལྟ་བུ།    \/\/ལས་འཛིན་པ་['+', '*', '-']     \/\/དཔེ་ཆ།     \/\/ཚད་འཛིན་གྱི་རིམ་པ། (**)     \/\/གྱེན་གྱི་ཆ་ཤས་ (_ _)     \/\/བསྐྱར་ལྡན། (*)     \/\/ཕྱིར་བཏོན་ (--) བྱེད་པ།    \/\/བསྡུར་ཐེངས། (+)     \/\/ཚད་ལྡན་ཨང་རྩིས་ཀྱི་ལག་ལེན་ཚུ།    \/\/expression དང་ expression གི་མཐའ་འབྲས་སླར་ལོག་བྱེད།    \/\/ཐིག་ཁྲམ་གཉིས་པ་ནི་ཨང་གྲངས་ཧྲིལ་པོ་དག་གི་ཐོ་ཡིག་ཡིན། ཚད་ལྡན་ཨང་གྲངས་ཀྱི་ཐོ་ཡིག་གཉིས་པ་བེད་སྤྱོད་བྱེད་ནས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་    \/\/སྟབས་གཉིས་སུ་ཨོ་པེ་ཊར་དང་ཨོ་པེ་རན་ཌི་གཉིས་ཡོད། ཨོ་པེ་ཊར་དང་པོ་ལ་ཨལ་ཇི་བིར་གྱི་གཞི་རྟེན་གྱི་ལས་བྱའི་རིགས་ཡོད་ཅིང་།    def doAlgebra(op : List[String], operand : List[Long]) : Long = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def doAlgebra(op: List[String], operand: List[Long]): Long = {\n    var result = operand.head\n    for (i <- 0 until op.length) {\n      op(i) match {\n        case \"+\" => result += operand(i + 1)\n        case \"-\" => result -= operand(i + 1)\n        case \"*\" => result *= operand(i + 1)\n        case \"\/\/\" => result \/= operand(i + 1)\n        case \"**\" => result = pow(result.toDouble, operand(i + 1).toDouble).toLong\n      }\n    }\n    result\n  }\n\n  def main(args: Array[String]): Unit = {\n    val operators = List(\"+\", \"*\", \"-\")\n    val operands = List(2L, 3L, 4L, 5L)\n    println(doAlgebra(operators, operands)) \/\/ Output: 9\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\/\/\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"},{"task_id":"HumanEval_161","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེ་གཟིགས།    \/\/ལས་འགན་འདི་ནས་ཐིག་ལེ་ཐོན་པའི་འབྲས་བུ་ཕྱིར་ལོག་བྱ་དགོས།    \/\/string ནང་ཡི་གེ་མེད་ན་ string ཕྱིར་ལྡོག་དགོས།    \/\/དེ་མིན་དེ་འདྲ་བཞག་ན་ཡག་པོ་རེད།    \/\/གལ་ཏེ་ s[i]ནི་ཡི་གེ་ཡིན་ན། དེའི་ཡིག་གཟུགས་འོག་ནས་གོང་དུ་སྒྱུར་བའམ་རྒྱབ་ཕྱོགས་ལ་བསྒྱུར་བ།    \/\/ཚད་གཞི་དེ་ཁྱོད་ལ་ཐིག་ལེ་ s ཞིག་སྤྲད་ཡོད།    \/\/ >>> solve((\"1234\"))\n    \/\/ (\"4321\")\n    \/\/ >>> solve((\"ab\"))\n    \/\/ (\"AB\")\n    \/\/ >>> solve((\"#a@C\"))\n    \/\/ (\"#A@c\")\n    def solve(s : String) : String = {\n","canonical_solution":"def solve(s: String): String = {\n    if (s.exists(_.isLetter)) {\n      s.map {\n        case c if c.isLetter && c.isLower => c.toUpper\n        case c if c.isLetter && c.isUpper => c.toLower\n        case c => c\n      }.mkString\n    } else {\n      s.reverse\n    }\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(solve((\"AsDf\")).equals((\"aSdF\")));\n    assert(solve((\"1234\")).equals((\"4321\")));\n    assert(solve((\"ab\")).equals((\"AB\")));\n    assert(solve((\"#a@C\")).equals((\"#A@c\")));\n    assert(solve((\"#AsdfW^45\")).equals((\"#aSDFw^45\")));\n    assert(solve((\"#6@2\")).equals((\"2@6#\")));\n    assert(solve((\"#$a^D\")).equals((\"#$A^d\")));\n    assert(solve((\"#ccc\")).equals((\"#CCC\")));\n    }\n\n}\n"},{"task_id":"HumanEval_162","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/གལ་ཏེ་ 'text' ནི་སྟོང་པའི་ཐིག་ཡིག་ཡིན་ན་ None སླར་ལོག་བྱེད།    \/\/string 'text' ཤིག་ཡོད་ན། md5 ཧེཤི་འདྲ་མཉམ་གྱི་ string དེ་ཕྱིར་སློག་དགོས།    \/\/ >>> stringToMd5((\"Hello world\"))\n    \/\/ Some(\"3e25960a79dbc69b674cd4ec67a72c62\")\n    def stringToMd5(text : String) : Option[String] = {\n","canonical_solution":"import java.security.MessageDigest\n\nobject Problem {\n  def stringToMd5(text: String): Option[String] = {\n    if (text.isEmpty) None\n    else {\n      val md = MessageDigest.getInstance(\"MD5\")\n      val digest = md.digest(text.getBytes)\n      Some(digest.map(\"%02x\".format(_)).mkString)\n    }\n  }\n}\n\n\/\/ Example usage:\n\/\/ println(Problem.stringToMd5(\"Hello world\"))  \/\/ Output: Some(\"3e25960a79dbc69b674cd4ec67a72c62\")","tests":"    }\n    def main(args: Array[String]) = {\n    assert(stringToMd5((\"Hello world\")).equals(Some(\"3e25960a79dbc69b674cd4ec67a72c62\")));\n    assert(stringToMd5((\"\")).equals(None));\n    assert(stringToMd5((\"A B C\")).equals(Some(\"0ef78513b0cb8cef12743f5aeb35f888\")));\n    assert(stringToMd5((\"password\")).equals(Some(\"5f4dcc3b5aa765d61d8327deb882cf99\")));\n    }\n\n}\n"},{"task_id":"HumanEval_163","nl":"bod_Tibt","pl":"scala","prompt":"import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    \/\/དཔེར་ན་:     \/\/b ཡར་རྒྱས་ཀྱི་རིམ་པ་བཞིན་    \/\/འབྲས་བུ་ཆ་མཉམ་ a དང་ b གཉིས་ཡོད་ན། a དང་ b  གི་བར་གྱི་གྲངས་ཆ་ཆ་ཉེར་ལྡོག་ཕྱིར་ལོག་བྱོས།    \/\/ >>> generateIntegers((2l), (8l))\n    \/\/ (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))\n    \/\/ >>> generateIntegers((8l), (2l))\n    \/\/ (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))\n    \/\/ >>> generateIntegers((10l), (14l))\n    \/\/ (List[Long]())\n    def generateIntegers(a : Long, b : Long) : List[Long] = {\n","canonical_solution":"import scala.math._\nimport scala.collection.mutable._\n\nobject Problem {\n  def generateIntegers(a: Long, b: Long): List[Long] = {\n    val start = min(a, b)\n    val end = max(a, b)\n    val evenNumbers = for (i <- start to end if i % 2 == 0) yield i\n    evenNumbers.map(_.toLong).toList\n  }\n}","tests":"    }\n    def main(args: Array[String]) = {\n    assert(generateIntegers((2l), (10l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));\n    assert(generateIntegers((10l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));\n    assert(generateIntegers((132l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));\n    assert(generateIntegers((17l), (89l)).equals((List[Long]())));\n    }\n\n}\n"}]