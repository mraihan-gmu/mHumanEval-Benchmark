task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,mlt_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Iċċekkja jekk f'lista mogħtija ta' numri, hemmx xi żewġ numri eqreb minn xulxin milli d-dritti mogħtija. Eżempju: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) False >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,mlt_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Il-funzjoni hija stringa li fiha gruppi multipli ta' parentesi mdawla. L-għan tiegħek huwa li tissepara dawk il-gruppi f'stringi separati u tirritorna l-lista ta' dawk. Il-gruppi separati huma bilanċjati (kull brace miftuħa hija magħluqa sewwa) u mhux mdawla fi ħdan xulxin.""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,mlt_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Meta jingħata numru b'punt li jvarja pożittiv, jista' jiġi dekomposut f'parti ta' numru sħiħ (l-akbar numru sħiħ iżgħar minn numru mogħti) u f'parti deċimali (il-parti li tibqa' dejjem iżgħar minn 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,mlt_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Jekk il-funzjoni ta ' l-awditjar hija waħda mill-funzjonijiet li l-awditur għandu jidentifika, il-funzjoni għandha tirritorna True.""""""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,mlt_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Għal lista partikolari ta' numri ta' input, ikkalkula l-Mean Absolute Deviation madwar il-medja ta' dan is-sett ta' data. Il-Mean Absolute Deviation hija d-differenza medja assoluta bejn kull element u punt ċentrali (medja f'dan il-każ): MAD = medja. x - x_mean. Eżempju: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,mlt_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Daħħal numru 'delimiter' bejn kull żewġ elementi konsekuttivi tal-lista ta' input `numbers' >>> intersperse (([], 4) [] >>> intersperse (([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,mlt_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Il-valur ta' dan il-funzjoni huwa stringa li tirrappreżenta gruppi multipli għal parentesi mdawla separati minn spazji. Għal kull wieħed mill-grupp, ħareġ l-aktar livell profond ta' mdawla ta' parentesi. E.g. (() (()) għandu massimu ta' żewġ livelli ta' mdawla filwaqt li ((())) għandu tlieta. >>> parse_nested_parens (('((()) ((())) () ((()) (((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,mlt_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Filtra lista ta' input ta' strings biss għal dawk li fihom substring partikolari >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,mlt_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Għal lista mogħtija ta' integers, jirritorna tuple li jikkonsisti f'somma u prodott tal-integers kollha f'lista. Is-somma vojta għandha tkun ugwali għal 0 u l-prodott vojt għandu jkun ugwali għal 1. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,mlt_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Minn lista mogħtija ta' numri sħaħ, iġġenera lista ta' elementi massimi li jinsabu sa mument partikolari fis-sekwenza. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,mlt_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Sib l-iqsar palindrome li jibda b'string provdut. L-idea tal-algoritmu hija sempliċi: - Sib l-itwal postfix ta 'string provdut li huwa palindrome. - Żid fit-tmiem tal-string ir-rivers ta' prefix ta 'string li jiġi qabel is-suffix palindromiku. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Test jekk stringa mogħtija hix palindromu """"""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,mlt_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""L-input huma żewġ strings a u b li jikkonsistu biss minn 1s u 0s. Wettaq XOR binarju fuq dawn l-inputs u jirritorna r-riżultat ukoll bħala stringa. >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,mlt_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Minn lista ta' strings, erġa' lura l-itwal wieħed. Erġa' lura l-ewwel wieħed fil-każ ta' strings multipli ta' l-istess tul. Erġa' lura Null fil-każ li l-lista ta' input tkun vojta. >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,mlt_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Irtira l-akbar diviżur komuni ta ' żewġ numri sħaħ a u b >>> l-akbar_diviżur komuni ((3, 5) 1 >>> l-akbar_diviżur komuni ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,mlt_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Irritorna lista tal-prefissuri kollha mill-iqsar sal-itwal tal-string tal-input >>> all_prefissuri (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,mlt_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Irtira string li jkun fih numri delimitati bl-ispazju li jibdew minn 0 sa n inkluż. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,mlt_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Meta tingħata string, issib kemm karattri distinti (irrispettivament mill-każ) jikkonsistu minn >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,mlt_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Input għal din il-funzjoni hija stringa li jirrappreżenta n-noti mużikali f'format speċjali ASCII. Ħidma tiegħek hija li parse lista stringa ta 'integers li jikkorrispondu għal ħafna beats ma. Hawnhekk huwa legenda: 'o' nota, lasts beats 'o, dak li huwa' - nota nofs. lasts żewġ beats 'o, dak li huwa' - nota quater, lasts wieħed beats >>> parse_music. 'o o. .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,mlt_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Sib kemm-il darba s-substring partikolari jista' jinstab fis-serje oriġinali. Għodd il-każijiet li jkopru. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,mlt_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""L-input huwa stringa ta' numri delimitata bl-ispazju minn 'żero' sa 'disa'. L-għażliet validi huma 'żero', 'wieħed', 'żewġ', 'tliet', 'erba', 'ħames', 'sitt', 'seba', 'tmien' u 'disa'. Irritorna l-stringa b'numri magħżula mill-iżgħar għall-akbar >>> sort_numbers (('tliet wieħed ħamsa') 'wieħed tliet ħamsa' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,mlt_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Minn lista provduta ta' numri (ta' tul ta' mill-inqas tnejn) agħżel u erġa' lura tnejn li huma l-eqreb lejn xulxin u erġa' lurahom f'ordni (numru iżgħar, numru akbar). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,mlt_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Meta tingħata lista ta' numri (ta' mill-inqas żewġ elementi), applika trasformazzjoni lineari għal dik il-lista, b'tali mod li l-iżgħar numru isir 0 u l-akbar isir 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,mlt_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filtru lista mogħtija ta 'kwalunkwe valur tal-python għal integers biss >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,mlt_Latn,python,"

def strlen(string: str) -> int:
    """"""It-tul ta' ritorn ta' stringa mogħtija >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,mlt_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Għal numru n, agħti n-numru l-akbar li jaqsam n b'mod ugwali, iżgħar minn n >>> l-akbar_diviżur ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,mlt_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Irritorna lista ta' fatturi primi ta' numru sħiħ mogħti fl-ordni mill-iżgħar għall-akbar. Kull wieħed mill-fatturi għandu jkun elenkat numru ta' drabi li jikkorrispondu għal kemm-il darba jidher fil-fattorizzazzjoni. Input number għandu jkun ugwali għall-prodott tal-fatturi kollha >>> fattorizza ((8) [2, 2, 2] >>> fattorizza ((25) [5, 5] >>> fattorizza ((70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,mlt_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Minn lista ta' numri sħaħ, neħħi l-elementi kollha li jseħħu aktar minn darba. Żomm l-ordni ta' elementi li tħallew l-istess bħal fl-input. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,mlt_Latn,python,"

def flip_case(string: str) -> str:
    """"""Għal stringa partikolari, imdawwar karattri minuri għal minuri kbar u minuri kbar għal minuri żgħar. >>> flip_case ((('Hello') 'HELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,mlt_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Konkatenata lista ta ' strings f'stringa waħda >>> konkatenata (([]) ' ' >>> konkatenata ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,mlt_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Filtra lista ta' input ta' strings biss għal dawk li jibdew b'prefiss mogħti. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,mlt_Latn,python,"

def get_positive(l: list):
    """"""Irritorna biss numri pożittivi fil-lista. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,mlt_Latn,python,"

def is_prime(n):
    """"""Irritorna true jekk numru partikolari huwa prim, u false inkella. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,mlt_Latn,python,"import math


def poly(xs: list, x: float):
    """"""xs huma koeffiċjenti ta' polinomi. find_zero find x tali li poly ((x) = 0. find_zero jirritorna biss biss punt żero, anke jekk hemm ħafna. Barra minn hekk, find_zero jieħu biss lista xs li għandhom numru pari ta 'koeffiċjenti u l-akbar koeffiċjent mhux żero peress li jiggarantixxi soluzzjoni. >>> round (((find_zero[1, 2]), 2) # f ((x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Jevalwa polinomu b'koeffiċjenti xs fil-punt x. jirritorna xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,mlt_Latn,python,"

def sort_third(l: list):
    """"""Din il-funzjoni tieħu lista l u tirritorna lista l' b'tali mod li l' hija identika għal l fl-indiċijiet li mhumiex diviżibbli bi tlieta, filwaqt li l-valuri tagħha fl-indiċijiet li huma diviżibbli bi tlieta huma ugwali għall-valuri tal-indiċijiet korrispondenti ta' l, iżda magħżula. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,mlt_Latn,python,"

def unique(l: list):
    """"""Irritorna elementi uniċi magħżula f'lista >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,mlt_Latn,python,"

def max_element(l: list):
    """"""Irritorna l-element massimu fil-lista. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,mlt_Latn,python,"

def fizz_buzz(n: int):
    """"""Irritorna n-numru ta' drabi li d-diġit 7 jidher f'inteġers inqas minn n li huma diviżibbli b'11 jew 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,mlt_Latn,python,"

def sort_even(l: list):
    """"""Din il-funzjoni tieħu lista l u tirritorna lista l' b'tali mod li l' hija identika għal l fl-indiċijiet mhux pari, filwaqt li l-valuri tagħha fl-indiċijiet pari huma ugwali għall-valuri tal-indiċijiet pari ta' l, iżda ssortjati. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,mlt_Latn,python,"

def encode_cyclic(s: str):
    """"""tieħu bħala input string kodifikata bil-funzjoni encode_cyclic. Irritorna string dekodifikata. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""jirritorna stringa kkodifikata minn gruppi ċikliċi ta' tliet karattri. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,mlt_Latn,python,"

def prime_fib(n: int):
    """"""prime_fib jirritorna n-numru li huwa numru ta 'Fibonacci u huwa wkoll prim. >>> prime_fib ((1) 2 >>> prime_fib ((2) 3 >>> prime_fib ((3) 5 >>> prime_fib ((4) 13 >>> prime_fib ((5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,mlt_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero tieħu lista ta' integers bħala input. jirritorna True jekk hemm tliet elementi distinti fil-lista li jimla għal żero, u False inkella. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,mlt_Latn,python,"

def car_race_collision(n: int):
    """"""Immaġina triq li hija linja infinitament twila perfettament dritta. n karozzi qed isuqu min-naħa tax-xellug għal-lemin; simultanjament, sett differenti ta ' n karozzi qed isuqu min-naħa tal-lemin għal-lemin. Iż-żewġ settijiet ta ' karozzi jibdew ikunu ' l bogħod ħafna minn xulxin. Il-karozzi kollha jimxu bl-istess veloċità. Żewġ karozzi jingħad li jgħaqqdu meta karozza li qed tiċċaqlaq min-naħa tax-xellug għal-lemin tiltaqa ' ma ' karozza li qed tiċċaqlaq min-naħa tal-lemin għal-lemin. Madankollu, il-karozzi huma infinitament sodi u b'saħħithom; bħala riżultat, jibqgħu jiċċaqilqu fit-trajettorja tagħhom bħallikieku ma kkollidjawx. Din il-funzjoni toħroġ in-numru ta ' tali kolliżjonijiet. """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,mlt_Latn,python,"

def incr_list(l: list):
    """"""L-isem tal-lista li tirritorna b'elementi miżjuda b'1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,mlt_Latn,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero tieħu lista ta' enteri bħala input. jirritorna True jekk hemm żewġ elementi distinti fil-lista li jammontaw għal żero, u False inkella. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,mlt_Latn,python,"

def change_base(x: int, base: int):
    """"""Bidla bażi numerika ta ' l-input numru x għall-bażi. jirritornaw rappreżentazzjoni tal-ktajjen wara l-konverżjoni. numri bażi huma inqas minn 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,mlt_Latn,python,"

def triangle_area(a, h):
    """"""Meta jingħata t-tul ta' naħa u l-erja għolja ta' ritorn għal triangolu. >>> triangle_area ((5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,mlt_Latn,python,"

def fib4(n: int):
    """"""Is-sekwenza tan-numri Fib4 hija sekwenza simili għas-sekwenza ta' Fibbonacci li hija definita kif ġej: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Jekk jogħġbok ikteb funzjoni biex tikkalkula b'mod effiċjenti l-n-th element tas-sekwenza tan-numri fib4. Tużax rikorsjoni. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,mlt_Latn,python,"

def median(l: list):
    """"""L-element li jġib lura l-medjan tal-lista l. >>> medjan (([3, 1, 2, 4, 5]) 3 >>> medjan (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,mlt_Latn,python,"

def is_palindrome(text: str):
    """"""Iċċekkja jekk stringa mogħtija hijiex palindromu >>> is_palindrome (('') True >>> is_palindrome (('aba') True >>> is_palindrome (('aaaaa') True >>> is_palindrome (('zbcd') False """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,mlt_Latn,python,"

def modp(n: int, p: int):
    """"""Irritorna 2^n modulo p (kun konxju tan-numeriċi). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,mlt_Latn,python,"

def encode_shift(s: str):
    """"""tieħu bħala input string kodifikata bil-funzjoni encode_shift. Irritorna string dekodifikata. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""jirritorna stringa kkodifikata billi jbiddel kull karattru b'5 fl-alfabett. """"""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,mlt_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels hija funzjoni li tieħu stringa u tirritorna stringa mingħajr vokali. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,mlt_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Irritorna True jekk in-numri kollha fil-lista l huma taħt il-limitu t. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,mlt_Latn,python,"

def add(x: int, y: int):
    """"""Żid żewġ numri x u y >>> żid ((2, 3) 5 >>> żid ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,mlt_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Iċċekkja jekk żewġ kelmiet għandhomx l-istess karattri. >>> same_chars (('eabcdzzzz', 'dddzzzzzzzddeddabc') True >>> same_chars (('abcd', 'dddddddddabc') True >>> same_chars (('dddddddabc', 'abcd') True >>> same_chars (('eabcd', 'dddddddddabc') False >>> same_chars ((('abcd', 'dddddddabddce') False >>> same_chars (((abcdzzzz', 'dddzzzzzzzddabc') False """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,mlt_Latn,python,"

def fib(n: int):
    """"""Irritorna n-th numru ta' Fibonacci. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,mlt_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets hija stringa ta ""<"" u "">"". return True jekk kull bracket tal-ftuħ għandu bracket tal-għeluq korrispondenti. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,mlt_Latn,python,"

def monotonic(l: list):
    """"""Return True is list elements are monotonically increasing or decreasing. >>> monotonic (([1, 2, 4, 20]) True >>> monotonic (([1, 20, 4, 10]) False >>> monotonic (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,mlt_Latn,python,"

def common(l1: list, l2: list):
    """"""Irritorna elementi komuni uniċi magħżula għal żewġ listi. >>> komuni (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> komuni (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,mlt_Latn,python,"

def largest_prime_factor(n: int):
    """"""Irritorna l-akbar fattur prim ta' n. Assumi n > 1 u mhux prim. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,mlt_Latn,python,"

def sum_to_n(n: int):
    """"""sum_to_n hija funzjoni li ssemmi numri minn 1 sa n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,mlt_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets hija stringa ta '""("" u "")"". return True jekk kull bracket tal-ftuħ għandu bracket tal-għeluq korrispondenti. >>> correct_bracketing ""(("") False >>> correct_bracketing ""("")) True >>> correct_bracketing ""(() "") True >>> correct_bracketing ""(() "" False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,mlt_Latn,python,"

def derivative(xs: list):
    """"""xs jirrappreżenta koeffiċjenti ta 'polinom. xs[0] + xs[1] * x + xs[2] * x^2 + .... Irritorna d-derivattiva ta' dan il-polinom fl-istess forma. >>> derivattiva (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivattiva (([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,mlt_Latn,python,"

def fibfib(n: int):
    """"""Is-sekwenza tan-numri FibFib hija sekwenza simili għas-sekwenza ta 'Fibbonacci li hija definita kif ġej: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Jekk jogħġbok ikteb funzjoni biex tikkalkula b'mod effiċjenti l-n-th element tas-sekwenza tan-numri fibfib. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,mlt_Latn,python,"
FIX = """"""Ikteb funzjoni vowels_count li tieħu stringa li tirrappreżenta kelma bħala input u tirritorna n-numru ta' vokali fil-stringa. Vokali f'dan il-każ huma 'a', 'e', 'i', 'o', 'u'. Hawnhekk, 'y' hija wkoll vokali, iżda biss meta tkun fit-tmiem tal-kelma mogħtija. Eżempju: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Żid aktar każijiet ta' ttestjar. """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,mlt_Latn,python,"
def circular_shift(x, shift):
    """"""Iċ-ċirkuli jbiddel iċ-ċifri tal-integer x, iċ-ċifri lejn il-lemin b'xi ċifri u jirritorna r-riżultat bħala stringa. Jekk iċ-ċifri > numru ta 'ċifri, jirritorna ċifri inversi. >>> circular_shift ((12, 1) ""21"" >>> circular_shift ((12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,mlt_Latn,python,"
def digitSum(s):
    """"""Xogħol Ikteb funzjoni li tieħu stringa bħala input u tirritorna s-somma tal-karattri ta' fuq biss' kodiċijiet ASCII. Eżempji: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,mlt_Latn,python,"
def fruit_distribution(s,n):
    """"""F'din il-kompitu, inti se tingħata string li tirrappreżenta numru ta 'tuffieħ u l-larinġ li huma mqassma fil-basket ta' frott dan il-basket fih tuffieħ, naranġ, u frott tal-manga. Given il-string li tirrappreżenta l-għadd totali tal-oranġini u l-tuffieħ u numru sħiħ li jirrappreżenta l-għadd totali tal-frott fil-basket jirritorna l-għadd tal-frott tal-manga fil-basket. għall-eżempji: fruit_distribution""5(tuffieħ u 6 naranġ"", 19) ->19 - 5 - 6 = 8 fruit_distribution""0tuffieħ u 1 naranġ"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2tuffieħ u 3 naranġ"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 tuffieħ u 1 naranġ"",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,mlt_Latn,python,"
def pluck(arr):
    """"""""Meta jkollok matrix li jirrappreżenta fergħa ta 'siġra li għandha nodi ta' numru sħiħ mhux negattiv, il-kompitu tiegħek huwa li tiġbed wieħed mill-nodes u terġa' lura. In-nodu miġbud għandu jkun in-nodu bl-iżgħar valur pari. Jekk jinstabu nodi multipli bl-istess valur pari l-iżgħar, terġa' lura n-nodu li għandu l-iżgħar indiċi. In-nodu miġbud għandu jiġi lura f'lista, [small_value, l-indiċi tiegħu ], Jekk m'hemmx valuri pari jew l-array mogħti huwa vojt, terġa' lura []. Eżempju 1: Input: [4,2,3] Output: [2, 1] Spjegazzjoni: 2 għandu l-iżgħar valur pari, u 2 għandu l-iżgħar indiċi. Eżempju 2: Input: [1,2,3] Output: [2, 1] Spjegazzjoni: 2 għandu l-iżgħar valur pari, u 2 għandu l-iżgħar indiċi. Eżempju 3: Input: [] Output: [4:] Input: [5, 3, 4, 2] Output: [0, 1 Output: 0] L-iżgħar nod għandu l-iżgħar valur pari, iżda l-iżgħar valur huwa żero, allura aħna nagħżlu l-ewwel nod li għandu żeroli. * = żeroli, iżda l-iżgħar valur huwa żeroli.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,mlt_Latn,python,"
def search(lst):
    '''Jekk int int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, jekk int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int'''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,mlt_Latn,python,"
def strange_sort_list(lst):
    '''Jekk tingħata lista ta' numri sħaħ, tirritorna lista f'ordni stramba. Sortjar stramba, huwa meta tibda bil-valur minimu, imbagħad il-massimu tal-inteġers li jifdal, imbagħad minimu u hekk 'il quddiem. Eżempji: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,mlt_Latn,python,"
def triangle_area(a, b, c):
    '''Meta wieħed jagħti t-tul tat-tliet naħat ta' trianglu. Irritorna l-erja tat-trianglu mqarrba għal 2 punti deċimali jekk it-tliet naħat jiffurmaw trianglu validu. Inkella jirritorna -1 It-tliet naħat jagħmlu trianglu validu meta s-somma ta' kwalunkwe żewġ naħat tkun akbar mit-tielet naħa. Eżempju: triangle_area ({3, 4, 5) == 6.00 triangle_area ({1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,mlt_Latn,python,"
def will_it_fly(q,w):
    '''Ikteb funzjoni li tirritorna True jekk l-oġġett q se jtir, u False inkella. L-oġġett q se jtir jekk ikun ibbilanċjat (hija lista palindroma) u s-somma tal-elementi tiegħu tkun inqas minn jew ugwali għall-piż massimu possibbli w. Eżempju: will_it_fly (([1, 2], 5) â -> False # 1+2 huwa inqas mill-piż massimu possibbli, iżda huwa mhux ibbilanċjat. will_it_fly (([3, 2, 3], 1) â -> False # huwa bbilanċjat, iżda 3+2+3 huwa aktar mill-piż massimu possibbli. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 huwa inqas mill-piż massimu possibbli, u huwa bbilanċjat. will_it_fly ((([3], â 5) -> True # 3 huwa inqas mill-piż massimu possibbli, u huwa ibbilanċjat. '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,mlt_Latn,python,"
def smallest_change(arr):
    """"""Jekk int int ta 'arr ta' numri enteri, agħżel in-numru minimu ta 'elementi li għandhom jinbidlu biex jagħmlu l-array palindromiku. Array palindromiku huwa array li jinqara l-istess lura u 'l quddiem. F'bidla waħda, tista' tibdel element wieħed għal kwalunkwe element ieħor. Per eżempju: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,mlt_Latn,python,"
def total_match(lst1, lst2):
    '''Ikteb funzjoni li taċċetta żewġ listi ta' strings u tirritorna l-lista li għandha l-għadd totali ta' karri fil-strings kollha tal-lista inqas mill-lista l-oħra. jekk iż-żewġ listi għandhom l-istess numru ta' karri, jirritornaw l-ewwel lista. Eżempji total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['4', ['1', '2', '3', '4', '5', '4]) -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,mlt_Latn,python,"
def is_multiply_prime(a):
    """"""Ikteb funzjoni li tirritorna vera jekk in-numru mogħti huwa l-multiplikazzjoni ta' 3 numri primi u false inkella.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,mlt_Latn,python,"
def is_simple_power(x, n):
    """"""Il-kompitu tiegħek huwa li tikteb funzjoni li tirritorna true jekk numru x huwa qawwa sempliċi ta ' n u false f'każijiet oħra. x huwa qawwa sempliċi ta ' n jekk n**int=x Per eżempju: is_simple_power ((1, 4) => true is_simple_power ((2, 2) => true is_simple_power ((8, 2) => true is_simple_power ((3, 2) => false is_simple_power ((3, 1) false => is_simple_power ((5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,mlt_Latn,python,"
def iscube(a):
    '''Ikteb funzjoni li tieħu numru sħiħ a u tirritorna True jekk dan ingeger huwa kubju ta ' xi numru sħiħ. Nota: tista ' tassumi li l-input huwa dejjem validu. Eżempji: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,mlt_Latn,python,"
def hex_key(num):
    """"""Int intqallek biex tikteb funzjoni li tirċievi numru eżadeċimali bħala stringa u tgħodd in-numru ta' ċifri eżadeċimali li huma primes (numru prim, jew prim, huwa numru naturali akbar minn 1 li mhuwiex prodott ta' żewġ numri naturali iżgħar). Ċifri eżadeċimali huma 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Numri primji huma 2, 3, 5, 7, 11, 13, 17,... Allura għandek tiddetermina numru ta' ċifri li ġejjin: 2, 3, 5, 7, B (= deċimali 11), D (= deċimali 13). Nota: tista' tassumi li l-input huwa dejjem korrett jew vojt, u s-simboli A,B,C,D,E,F huma dejjem bil-kaxxa. Eżempji: Għan-num = AB, l-output għandu jkun 1. Għan-num = 1077E, l-output għandu jkun 2. Għan-num = ""AB33"" l-output għandu jkun 4.33ABC, l-output għandu jkun 6.0123ABC, 6.045DEF, għall-output għandu jkun 2.02020 """"""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,mlt_Latn,python,"
def decimal_to_binary(decimal):
    """"""Jekk inti ma tkunx taf kif tagħmel dan, inti tista 'tagħmel dan billi tuża l-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal-kodiċi tal""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,mlt_Latn,python,"
def is_happy(s):
    """"""Int tingħata string s. Il-kompitu tiegħek huwa li tivverifika jekk il-string hux kuntent jew le. String huwa kuntent jekk it-tul tiegħu huwa mill-inqas 3 u kull 3 ittri konsekuttivi huma distinti Per eżempju: is_happy ((a) => False is_happy ((aa) => False is_happy ((abcd) => True is_happy ((aabb) => False is_happy ((adb) => True is_happy ((xyy) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,mlt_Latn,python,"
def numerical_letter_grade(grades):
    """"""Il-klassifikazzjonijiet tal-GPAs huma l-klassifikazzjonijiet tal-GPAs tal-istudenti. Il-klassifikazzjonijiet tal-GPAs huma l-klassifikazzjonijiet tal-istudenti. Il-klassifikazzjonijiet tal-GPAs huma l-klassifikazzjonijiet tal-istudenti.""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,mlt_Latn,python,"
def prime_length(string):
    """"""Ikteb funzjoni li tieħu stringa u tirritorna True jekk it-tul tal-istringa huwa numru primju jew False inkella Eżempji prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,mlt_Latn,python,"
def starts_one_ends(n):
    """"""Meta jingħata numru sħiħ pożittiv n, irritorna l-għadd ta' numri ta' numri kollha pożittivi b'n-digit li jibdew jew jispiċċaw b'1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,mlt_Latn,python,"
def solve(N):
    """"""Jekk N huwa numru sħiħ pożittiv, irritorna s-somma totali tad-diġiti tiegħu fil-binarju. Eżempju Għal N = 1000, is-somma tad-diġiti tkun 1 l-output għandu jkun ""1"". Għal N = 150, is-somma tad-diġiti tkun 6 l-output għandu jkun ""110"". Għal N = 147, is-somma tad-diġiti tkun 12 l-output għandu jkun ""1100"". Varjabbli: @N restrizzjonijiet ta' numru sħiħ: 0 â‰¤ N â‰¤ 10000. Output: stringa ta' numru binarju """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,mlt_Latn,python,"
def add(lst):
    """"""Meta tingħata lista mhux vojta ta' numri sħaħ lst, żid l-elementi pari li huma f'indiċijiet mhux tas-soltu. Eżempji: żid (([4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,mlt_Latn,python,"
def anti_shuffle(s):
    """"""Ikteb funzjoni li tieħu stringa u tirritorna verżjoni ordnata tagħha. Verżjoni ordnata ta 'stringa, hija stringa fejn il-kliem kollha (separati minn spazju) huma sostitwiti b'kelma ġdida fejn il-karattri kollha rranġati f'ordni li jiżdied ibbażati fuq il-valur ascii. Nota: Għandek iżżomm l-ordni tal-kliem u l-ispazji vojta fis-sentenza. Per eżempju: anti_shuffle ((('Hi') jirritorna 'Hi' anti_shuffle (('hello') jirritorna 'ehllo' anti_shuffle (('Hello World!!!') jirritorna 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,mlt_Latn,python,"
def get_row(lst, x):
    """"""Jekk ikollok data bidimensjonali, bħal lista mdawla, li hija simili għal matrix, madankollu, b'differenza mill-matriċi, kull riġla tista' jkollha numru differenti ta' kolonni. Meta tingħata lst, u l-intjer x, issib l-intjeri x fil-lista, u terġa' lura lista ta' tuples, [(x1, y1), (x2, y2) ...] b'tali mod li kull tuple tkun koordinata - (ringiela, kolonni), li tibda b'0.""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,mlt_Latn,python,"
def sort_array(array):
    """"""Meta tingħata materja prima ta' numri enteri mhux negattivi, erġa' lura kopja tal-materja prima mogħtija wara li tiġi ssortjata, inti ser issorda l-materja prima mogħtija f'ordni li jiżdied jekk is-somma ((l-ewwel valur tal-indiċi, l-aħħar valur tal-indiċi) tkun mhux ugwali, jew issordaha f'ordni li jonqos jekk is-somma ((l-ewwel valur tal-indiċi, l-aħħar valur tal-indiċi) tkun ugwali. Nota: * ma tibdelx l-materja prima mogħtija. Eżempji: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,mlt_Latn,python,"
def encrypt(s):
    """"""Il-funzjoni encrypt tieħu stringa bħala argument u tirritorna stringa encrypted bl-alfabett li qed jiġi rrotat. L-alfabett għandu jiġi rrotat b'tali mod li l-ittri jinbidlu 'l isfel b'żewġt immultiplikati għal żewġ postijiet. Per eżempju: encrypt (('hi') jirritorna 'lm' encrypt (('asdfghjkl') jirritorna 'ewhjklnop' encrypt (('gf') jirritorna 'kj' encrypt (('et') jirritorna 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,mlt_Latn,python,"
def next_smallest(lst):
    """"""Ikteb funzjoni next_smallest (() li tirritorna t-tieni element l-iżgħar tal-lista. Irritorna None jekk m'hemmx tali element. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,mlt_Latn,python,"
def is_bored(S):
    """"""Jekk inti tkun qed tagħmel xi ħaġa li ma tkunx trid tagħmel, inti tista 'tkun qed tagħmel xi ħaġa li ma tkunx trid tagħmel.""""""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,mlt_Latn,python,"
def any_int(x, y, z):
    '''Ħolqien ta' funzjoni li tieħu 3 numri. Jirritorna true jekk wieħed min-numri jkun ugwali għas-somma tat-tnejn l-oħra, u n-numri kollha jkunu integers. Jirritorna false f'kull każ ieħor. Eżempji any_int{5, 2, 7) â -> True any_int{3, 2, 2) â -> False any_int{3, -2, 1) â -> True any_int{3.6, -2.2, 2) â -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,mlt_Latn,python,"
def encode(message):
    """"""Ikteb funzjoni li tieħu messaġġ, u tikkodja b'tali mod li tibdel il-każ ta' l-ittri kollha, tissostitwixxi l-vokali kollha fil-messaġġ bl-ittra li tidher 2 postijiet qabel dik il-vokali fl-alfabett Ingliż. Assumi biss ittri. Eżempji: >>> encode('test') 'TGST' >>> encode('Dan huwa messaġġ') 'tHKS KS C MGSSCGG' """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,mlt_Latn,python,"

def skjkasdkd(lst):
    """"""Jekk l-ewwel numru huwa l-valur primarju l-akbar u tirritorna s-somma tad-diġiti tiegħu. Eżempji: Għal lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] l-output għandu jkun 10 Għal lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] l-output għandu jkun 25 Għal lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] l-output għandu jkun 13 Għal lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] l-output għandu jkun 11 Għal lst = [0,81,12,31,21] l-output għandu jkun 3 Għal lst = [0,1,8,1,2,7] l-output għandu jkun 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,mlt_Latn,python,"
def check_dict_case(dict):
    """"""Jekk dan ikun dizzjunarju, jirritorna True jekk il-key kollha jkunu strings f'ittri żgħar jew il-key kollha jkunu strings f'ittri kbar, inkella jirritorna False. Il-funzjoni għandha tirritorna False jekk id-dizzjunarju mogħti jkun vojt. Eżempji: check_dict_case{""a"":""apple"", ""b"":""banana""}) għandu jirritorna True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) għandu jirritorna False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) għandu jirritorna False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) False għandu jirritorna check.dict_case{""NC"":""STATE"", ""Z"":""IP""}) għandu jirritorna True.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,mlt_Latn,python,"
def count_up_to(n):
    """"""Implimenta funzjoni li tieħu numru sħiħ mhux negattiv u tirritorna materja tal-ewwel n numri sħaħ li huma numri primi u inqas minn n. per eżempju: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,mlt_Latn,python,"
def multiply(a, b):
    """"""Ikkompletat il-funzjoni li tieħu żewġ integers u jirritorna l-prodott tad-diġiti tal-unità tagħhom. Assumi li l-input huwa dejjem validu. Eżempji: multiplikazzjoni ((148, 412) għandu jirritorna 16. multiplikazzjoni ((19, 28) għandu jirritorna 72. multiplikazzjoni ((2020, 1851) għandu jirritorna 0. multiplikazzjoni ((14,-15) għandu jirritorna 20. """"""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,mlt_Latn,python,"
def count_upper(s):
    """"""Jekk tingħata stringa s, għodd in-numru ta' vokali kbar f'indiċijiet pari. Pereżempju: count_upper (('aBCdEf') jirritorna 1 count_upper (('abcdefg') jirritorna 0 count_upper (('dBBE') jirritorna 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,mlt_Latn,python,"
def closest_integer(value):
    '''Jekk in-numru huwa eqwidistanti minn żewġ numri sħaħ, dawwarh 'il bogħod minn żero. Eżempji >>> eqwidistanti minn żewġ numri sħaħ, dawwarh 'il bogħod minn żero. Nota: It-twaqqigħ 'il bogħod minn żero jfisser li jekk in-numru mogħti huwa eqwidistanti minn żewġ numri sħaħ, dak li għandek tirritorna huwa dak li huwa l-iktar 'il bogħod minn żero. Għall-eżempju eqwidistanti minn żewġ numri sħaħ, dawwarh 'il bogħod minn żero.'''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,mlt_Latn,python,"
def make_a_pile(n):
    """"""Meta tingħata numru sħiħ pożittiv n, trid tagħmel munzell ta' livelli n ta' ġebel. L-ewwel livell għandu n ġebel. In-numru ta' ġebel fil-livell li jmiss huwa: - in-numru li jmiss mhux par jekk n huwa mhux par. - in-numru li jmiss pari jekk n huwa pari. Irritorna n-numru ta' ġebel f'kull livell f'lista, fejn l-element fl-indiċi i jirrappreżenta n-numru ta' ġebel fil-livell (i+1). Eżempji: >>> make_a_pile (i+1) """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,mlt_Latn,python,"
def words_string(s):
    """"""Meta tkun qed tikteb il-kliem, inti ser tingħata stringa ta 'kliem separati minn kommi jew spazji. Il-kompitu tiegħek huwa li taqsam il-linja fil-kliem u jirritornaw materja tal-kliem. Per eżempju: words_string ((""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""] words_string ((""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,mlt_Latn,python,"
def choose_num(x, y):
    """"""Din il-funzjoni tieħu żewġ numri pożittivi x u y u tirritorna l-akbar numru sħiħ pari li jinsab fil-medda [x, y] inkluż. Jekk m'hemmx numru bħal dan, allura l-funzjoni għandha tirritorna -1. Per eżempju: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1 """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,mlt_Latn,python,"
def rounded_avg(n, m):
    """"""Jekk n huwa akbar minn m, irkupra -1. Eżempju: rounded_avg ((1, 5) => ""0b11"" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => ""0b11"" rounded_avg ((20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,mlt_Latn,python,"
def unique_digits(x):
    """"""Meta tingħata lista ta' numri enteri pożittivi x, tirritorna lista ordinata ta' l-elementi kollha li m'għandhiex xi ċifra pari. Nota: Il-lista li tirritorna għandha tiġi ordinata b'ordni dejjem jikber. Pereżempju: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,mlt_Latn,python,"
def by_length(arr):
    """"""Meta tingħata materja prima ta' numri sħaħ, issortja l-għadd ta' numri sħaħ li huma bejn 1 u 9 inklużi, irriversja l-materja prima li tirriżulta, u mbagħad ibdel kull ċifra bl-isem korrispondenti tagħha minn ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"". Pereżempju: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> issortja arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> arr lura -> [8, 5, 4, 3, 2, 2, 1, 1] return [""Eight"", ""Five"", ""Three"", ""Two"", ""Two"", ""One"", ""One""] Jekk l-materja hija vojta, return an array: arr = [] return [] Jekk l-materja prima għandha xi numru stramb injorah: arr = [1, -1 , 55] -> arr -> [1, 55] -> arr lura [55, 1] return - ['One'] """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,mlt_Latn,python,"
def f(n):
    """"""Implimenta l-funzjoni f li tieħu n bħala parametru, u tirritorna lista ta 'daqs n, b'tali mod li l-valur tal-element fl-indiċi i huwa l-fatturjali ta' i jekk i huwa pari jew is-somma ta' numri minn 1 sa i inkella. i jibda minn 1. il-fatturjali ta 'i huwa l-multiplikazzjoni tan-numri minn 1 sa i (1 * 2 * ... * i). Eżempju: f(5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,mlt_Latn,python,"
def even_odd_palindrome(n):
    """"""Meta jingħata numru sħiħ pożittiv n, jirritorna tuple li għandu n-numru ta' palindromi ta' numri sħaħ u mhux sħaħ li jaqgħu fil-medda ((1, n), inklużi. Eżempju1: Daħla: 3 Ħruġ: (1, 2) Spjegazzjoni: Palindromi ta' numri sħaħ huma 1, 2, 3. wieħed minnhom huwa pari, u tnejn minnhom huma mhux sħaħ. Eżempju2: Daħla: 12 Ħruġ: (4, 6) Spjegazzjoni: Palindromi ta' numri sħaħ huma 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. erba' minnhom huma pari, u 6 minnhom huma mhux sħaħ. Nota: 1. 1 <= n <= 10^3 2. tuple li jirritorna n-numru ta' palindromi ta' numri sħaħ pari u mhux sħaħ rispettivament. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,mlt_Latn,python,"
def count_nums(arr):
    """"""Ikteb funzjoni count_nums li tieħu materja prima ta' numri intjeri u tirritorna n-numru ta' elementi li għandhom somma ta' ċifri > 0. Jekk numru huwa negattiv, allura l-ewwel ċifra ffirmata tiegħu tkun negattiva: eż. -123 għandha ċifri ffirmati -1, 2, u 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,mlt_Latn,python,"
def move_one_ball(arr):
    """"""Għandna array 'arr' ta' N integers arr[1], arr[2], ..., arr[N].In-numri fl-array se jkunu ordnati b'mod każwali. Il-kompitu tiegħek huwa li tiddetermina jekk huwiex possibbli li jkollok array issortjat f'ordni mhux li jonqos billi twettaq l-operazzjoni li ġejja fuq l-array mogħti: Inti permess li twettaq operazzjoni ta 'swiċċjar lejn il-lemin kwalunkwe numru ta' drabi. Operazzjoni ta 'swiċċjar lejn il-lemin tfisser li tbiddel l-elementi kollha tal-array b'pożizzjoni waħda fid-direzzjoni t-tajba. L-aħħar element tal-array se jiġi mċaqlaq lejn il-pożizzjoni tal-bidu fl-array jiġifieri 0th indiċi. Jekk huwa possibbli li jinkiseb l-array issortjat billi twettaq l-operazzjoni ta 'hawn fuq allura jirritorna True jew jirritorna False. Jekk l-array mogħti huwa vojt allura jirritorna True. Nota: Il-lista mogħtija hija garantita li jkollha elementi uniċi. Pereżempju: move_one_(ball[3, 4, 5, 1, 2]==>True Spjega: Permezz ta 'perforzazzjoni ta' operazzjonijiet 2 min-lemin, l-ordni mhux li jonqos jista 'jiskont għall-array.""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,mlt_Latn,python,"
def exchange(lst1, lst2):
    """"""F'din il-problema, int ser timplimenta funzjoni li tieħu żewġ listi ta' numri, u tiddetermina jekk huwiex possibbli li jsir skambju ta' elementi bejniethom biex lst1 issir lista ta' numri pari biss. M'hemm l-ebda limitu fuq in-numru ta' elementi skambjati bejn lst1 u lst2. Jekk huwa possibbli li jiġu skambjati elementi bejn lst1 u lst2 biex l-elementi kollha ta' lst1 ikunu pari, erġa' ""Iva"". Inkella, erġa' ""Le"". Pereżempju: skambju [(1, 2, 3, 4], [1, 2, 3, 4]) => ""Iva"" skambju [(1, 2, 3, 4], [1, 5, 3, 4]) => ""Le"" Huwa preżunt li l-listi ta' input mhux se jkunu vojta. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,mlt_Latn,python,"
def histogram(test):
    """"""Jekk tingħata stringa li tirrappreżenta ittri żgħar separati minn spazju, erġa' lura d-dizzjunarju tal-ittra bl-aktar ripetizzjoni u li jkun fih il-għadd korrispondenti. Jekk diversi ittri jkollhom l-istess okkorrenza, erġa' lura kollha. Eżempju: istogramma ((('a b c') == {'a': 1, 'b': 1, 'c': 1} istogramma ((('a b b a') == {'a': 2, 'b': 2} istogramma ((('a b c a b') == {'a': 2, 'b': 2} istogramma ((('b b a') == {'b 4}: istogramma (((')) == {} """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,mlt_Latn,python,"
def reverse_delete(s,c):
    """"""Il-kompitu Aħna ngħataw żewġ strings s u c, għandek tħassar il-karattri kollha f's li huma ugwali għal kwalunkwe karattru f'c imbagħad iċċekkja jekk il-string riżultat huwa palindrome. String huwa msejjaħ palindrome jekk jaqra l-istess lura kif 'il quddiem. Għandek tirritorna tuple li jkun fih il-string riżultat u True / False għall-kontroll. Eżempju Għal s = ""abcde"", c = ""ae"", ir-riżultat għandu jkun ('bcd', False) Għal s = ""abcdef"", c = ""b"" ir-riżultat għandu jkun ('acdef', False) Għal s = ""abcdedcba"", c = ""ab"", ir-riżultat għandu jkun ('cdedc', True) """"""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,mlt_Latn,python,"
def odd_count(lst):
    """"""Meta tingħata lista ta' strings, fejn kull stringa tikkonsisti biss f'diġiti, tirritorna lista. Kull element i tal-output għandu jkun ""in-numru ta' elementi mhux tas-soltu fil-stringa i tal-input"". fejn l-i kollha għandhom jiġu sostitwiti bin-numru ta' ċifri mhux tas-soltu fl-i'th string tal-input. >>> odd_count['1234567']) [""in-numru ta' elementi mhux tas-soltu 4n l-str4ng 4 tal- 4nput.""] >>> odd_count['3',""111111""]) [""in-numru ta' elementi mhux tas-soltu 1n l-str1ng 1 tal- 1nput."", ""in-numru ta' elementi mhux tas-soltu 8n l-str8ng 8 tal- 8nput.""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,mlt_Latn,python,"
def minSubArraySum(nums):
    """"""Meta tingħata materjalità ta' intjeri n, issib is-somma minima ta' kull sub-materjalità ta' n li mhix vojta. Eżempju minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,mlt_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Il-ġbir tal-ilma huwa l-ġbir tal-ilma li jista' jiġi estratt mill-ilma. Il-ġbir tal-ilma huwa l-ġbir tal-ilma li jista' jiġi estratt mill-ilma. Il-ġbir tal-ilma huwa l-ġbir tal-ilma li jista' jiġi estratt mill-ilma.""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,mlt_Latn,python,"
def sort_array(arr):
    """"""F'dan il-Kata, għandek issorda materjalità ta' numri interi mhux negattivi skond in-numru ta' dawk fir-rappreżentazzjoni binarja tagħhom f'ordni li jikber. Għal numru simili ta' dawk, issorda abbażi tal-valur deċimali. Dan għandu jiġi implimentat kif ġej: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,mlt_Latn,python,"
def select_words(s, n):
    """"""Jekk int taw string s u numru naturali n, int intqallek biex timplimenta funzjoni li tirritorna lista tal-kliem kollha minn string s li fihom eżattament n konsonanti, sabiex dawn il-kliem jidhru fil-string s. Jekk il-string s huwa vojt allura l-funzjoni għandha tirritorna lista vojta. Nota: tista 'taċċetta li l-string ta' input fih biss ittri u spazji. Eżempji: select_words (((""Mary had a little lamb"", 4) ==> [""little""] select_words (((""Mary had a little lamb"", 3) ==> [""Mary"", ""lamb""] select_words"" (((simple white space"", 2) ==> [] select_words (((""Hello world"", 4) ==> [""world""] select_words (((""Uncle sam"", 3) ==> [""Uncle""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,mlt_Latn,python,"
def get_closest_vowel(word):
    """"""Jekk ma ssibx xi vokali li jissodisfaw il-kundizzjoni ta' hawn fuq, erġa' lura stringa vojta. Tista' tassumi li l-istringa mogħtija fiha l-ittra Ingliża biss. Eżempju: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" (((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,mlt_Latn,python,"
def match_parens(lst):
    '''Jekk int qed tikteb il-lista ta' żewġ strings, iż-żewġ strings jikkonsistu biss minn parentesi miftuħa '(' jew parentesi magħluqa ') '. Ix-xogħol tiegħek huwa li tivverifika jekk huwiex possibbli li tgħaqqad iż-żewġ strings f'xi ordni, li l-istringa li tirriżulta tkun tajba. String S huwa meqjus bħala tajjeb jekk u biss jekk il-parentesi kollha f'S ikunu bilanċjati. Per eżempju: il-string '((()) ' huwa tajjeb, filwaqt li l-istringa '()) ' mhuwiex. Irritorna 'Iva' jekk hemm mod kif tagħmel stringa tajba, u tirritorna 'Le' inkella. Eżempji: match_parens[('() ', ') ']) == 'Iva' match_parens[(') ', ') ']) == 'Le' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,mlt_Latn,python,"
def maximum(arr, k):
    """"""Meta tingħata materja arr ta 'inteġers u numru sħiħ pożittiv k, jirritorna lista magħżula ta' tul k bl-ogħla numru k f'arr. Eżempju1: Daħla: arr = [-3, -4, 5], k = 3 Ħruġ: [-4, -3, 5] Eżempju2: Daħla: arr = [4, -4, 4], k = 2 Ħruġ: [4, 4] Eżempju3: Daħla: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Ħruġ: [2] Nota: 1. It-tul tal-materja se jkun fil-medda ta ' [1, 1000]. 2. L-elementi fl-materja se jkunu fil-medda ta ' [-1000, 1000]. 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,mlt_Latn,python,"
def solution(lst):
    """"""Ikkonferma li l-valur tal-element mhux miżjud huwa l-valur tal-element mhux miżjud li huwa f'pożizzjoni pari.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,mlt_Latn,python,"
def add_elements(arr, k):
    """"""Meta tingħata matrix mhux vojt ta 'integers arr u integer k, irritorna s-somma tal-elementi b'mhux aktar minn żewġ ċifri mill-ewwel k elementi ta' arr. Eżempju: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # somma ta '21 + 3 Restrizzjonijiet: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)""""""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,mlt_Latn,python,"
def get_odd_collatz(n):
    """"""Jekk wieħed jagħti numru sħiħ pożittiv n, irritorna lista ordnata li għandha n-numri mhux tas-soltu fis-sekwenza ta' Collatz. Il-kunjetura ta' Collatz hija kunjetura fil-matematika li tikkonċerna sekwenza definita kif ġej: ibda b'kull numru sħiħ pożittiv n. Imbagħad kull terminu jinkiseb mit-terminu preċedenti kif ġej: jekk it-terminu preċedenti huwa pari, it-terminu li jmiss huwa nofs it-terminu preċedenti. Jekk it-terminu preċedenti huwa mhux tas-soltu, it-terminu li jmiss huwa 3 darbiet it-terminu preċedenti flimkien ma '1. Il-kunjetura hija li tkun xi tkun il-valur ta' n, is-sekwenza dejjem tilħaq 1. Nota: 1. Collatz (((1) huwa [1]. 2. Lista ritornata ordnata b'ordni dejjem jiżdied. Pereżempju: get_odd_collatz ((5) jirritorna [1, 5] # Is-sekwenza ta' Collatz għal 5 hija [5, 8, 16, 4, 2, 1], għalhekk in-numri mhux tas-soltu huma biss 1, u 5. """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,mlt_Latn,python,"
def valid_date(date):
    """"""Għandek tikteb funzjoni li tivvalida ċirkolazzjoni ta' data u tirritorna True jekk id-data tkun valida inkella False. Id-data tkun valida jekk ir-regoli kollha li ġejjin ikunu sodisfatti: 1. Il-ċirkolazzjoni tad-data ma tkunx vojta. 2. In-numru ta' jiem ma jkunx inqas minn 1 jew ogħla minn 31 jum għal xhur 1,3,5,7,8,10,12. U n-numru ta' jiem ma jkunx inqas minn 1 jew ogħla minn 30 jum għal xhur 4,6,9,11. U, in-numru ta' jiem ma jkunx inqas minn 1 jew ogħla minn 29 jum għal xahar 2. 3. Il- xhur ma għandhomx ikunu inqas minn 1 jew ogħla minn 12. 4. Id-data għandha tkun fil-format: mm-dd-yyyy-eż.: valid_date (('03-11-2000') => True_valid_date (('15-01-2012') => False valid_date (('04-040-20') => False_valid_date (('06-04-2020') => True_valid_date (('06/04/2020') => False""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,mlt_Latn,python,"
def split_words(txt):
    '''Meta tingħata sensiela ta' kliem, tirritorna lista ta' kliem maqsuma fuq spazju abjad, jekk ma jeżisti l-ebda spazju abjad fit-test għandek taqsam fuq kommi ',' jekk ma jeżisti l-ebda komma għandek tirritorna n-numru ta' ittri żgħar b'ordni mhux normali fl-alfabett, ord ((('a') = 0, ord ((('b') = 1, ... ord ((('z') = 25 Eżempji split_words ((""Hello world!"") â -> [""Hello"", ""world!""] split_words ((""Hello,world!"") â -> [""Hello"", ""world!"" split_words ((""abcdef"") == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,mlt_Latn,python,"
def is_sorted(lst):
    '''Jekk tingħata lista ta' numri, irritorna jekk humiex issortjati jew le f'ordni li jikber. Jekk il-lista jkollha aktar minn 1 duplikat tal-istess numru, irritorna False. Assumi li m'hemm l-ebda numru negattiv u biss in-numru sħiħ. Eżempji is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5, 5]) â -> True is_sorted (([1, 2, 3, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,mlt_Latn,python,"
def intersection(interval1, interval2):
    """"""Jekk inti għandek żewġ intervalli, fejn kull intervall huwa par ta 'inteġers. Per eżempju, intervall = (bidu, tmiem) = (1, 2). L-intervalli mogħtija huma magħluqa li jfisser li l-intervall (bidu, tmiem) jinkludi kemm bidu u tmiem. Għal kull intervall mogħti, huwa preżunt li l-bidu tiegħu huwa inqas jew ugwali għall-aħħar tiegħu. Ħidmet tiegħek hija li tiddetermina jekk it-tul ta 'intersezzjoni ta' dawn iż-żewġ intervalli huwa numru prim. Eżempju, l-intersezzjoni ta 'l-intervalli (1, 3), (2, 4) huwa (2, 3) li t-tul tiegħu huwa 1, li mhux numru prim. Jekk it-tul tal-intersezzjoni huwa numru prim, jirritorna ""Iva"", inkella, jirritorna ""le"". Jekk iż-żewġ intervalli ma jintersegawx, jirritorna ""le"". [input/output] kampjuni: intersezzjoni (((1, 2), (2, 3) ==> ""intersezzjoni"", ""NO"", intersezzjoni ((-1, 1), 4) ==> ""intersezzjoni"", ""NO"", ==> 5 - (((1, 5), ""YES"" - "" ((5,))""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,mlt_Latn,python,"
def prod_signs(arr):
    """"""Int tingħata arr ta 'inteġers u għandek bżonn li jirritornaw somma ta' magnitudini ta 'inteġers multiplikat bil-prodott ta 'l-ismijiet ta' kull numru fl-array, rappreżentati minn 1, -1 jew 0. Nota: return None għal arr vojta. Eżempju: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == None """"""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,mlt_Latn,python,"
def minPath(grid, k):
    """"""Jekk ikollok grid b'N-ringieli u N-kolonni (N >= 2) u b'għadd sħiħ k pożittiv, kull ċellula tal-grid fiha valur. Kull numru sħiħ fil-medda [1, N * N] inkluż jidher eżatt darba fuq iċ-ċelloli tal-grid. Għandek issib il-passaġġ minimu ta' tul k fil-grid. Tista 'tibda minn kwalunkwe ċellula, u f'kull pass tista' timxi lejn kwalunkwe ċellula ġirien, fi kliem ieħor, tista 'tmur lejn ċelloli li jaqsmu tarf miegħek ċellula kurrenti. Jekk jogħġbok innota li passaġġ ta' tul k ifisser li żżur eżattament k ċelloli (mhux neċessarjament distinti). Inti MA TISIEQX tmur barra mill-grid. A (tul k) huwa meqjus inqas minn passaġġ B (tul k) jekk wara li tagħmel il-listi ordnati tal-valuri fuq iċ-ċelloli li jgħaddu minn A u B (aħna nsejħulhom l_l_l_l_l_l_l_l_l_l_l_l), l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,mlt_Latn,python,"
def tri(n):
    """"""Il-Fibonacci sequence hija definita mill-rikorrenza: tri(1) = 3 tri(n) = 1 + n / 2, jekk n huwa pari. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), jekk n huwa odd. Per eżempju: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Inti tingħata numru sħiħ mhux negattiv n, għandek tirritorna lista tal-ewwel numri n + 1 tas-sekwenza ta 'Tribonacci. Eżempji: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,mlt_Latn,python,"
def digits(n):
    """"""Jekk hemm numru sħiħ pożittiv n, irritorna l-prodott tad-diġiti mhux par. Irritorna 0 jekk id-diġiti kollha huma pari. Per eżempju: digits(1) == 1 digits(4) == 0 digits(235) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,mlt_Latn,python,"
def is_nested(string):
    '''Ħolqien ta' funzjoni li tieħu stringa bħala input li fiha biss parassiti kwadri. Il-funzjoni għandha tirritorna True jekk u biss jekk hemm sottosekwenza valida ta' parassiti fejn mill-inqas wieħed mill-parassiti fis-sottosekwenza huwa mdawwar. is_nested '[[]]') â -> True is_nested '[[]]]]]]]]]]]]]][[[[[[[]') â -> False is_nested '[][]') â -> False is_nested '[]') â -> False is_nested '[[]]]]') â -> True is_nested '[[]]]]]]]]]]'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,mlt_Latn,python,"

def sum_squares(lst):
    """"""Jekk inti tagħti lista ta ' numri. Inti għandek bżonn li jirritornaw is-somma ta ' numri kwadrati fil-lista mogħtija, tordna kull element fil-lista għall-int ta ' fuq ((Il-limitu massimu) l-ewwel. Eżempji: Għal lst = [1,2,3] l-output għandu jkun 14 Għal lst = [1,4,9] l-output għandu jkun 98 Għal lst = [1,3,5,7] l-output għandu jkun 84 Għal lst = [1.4,4.2,0] l-output għandu jkun 29 Għal lst = [-2.4,1,1] l-output għandu jkun 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,mlt_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Ħolqien ta' funzjoni li tirritorna True jekk l-aħħar karattru ta' stringa partikolari huwa karattru alfabetiku u mhux parti minn kelma, u False inkella. Nota: ""kelma"" hija grupp ta' karattri separati minn spazju. Eżempji: check_if_last_char_is_a_letter ((""apple pie"") â -> False check_if_last_char_is_a_letter ((""apple pi e"") â -> True check_if_last_char_is_a_letter ((""apple pi e"") â -> False check_if_last_char_is_a_letter"" (("") â -> False '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,mlt_Latn,python,"
def can_arrange(arr):
    """"""Ifisser li l-element li jkun hemm qabel ma jkunx l-akbar jew l-istess daqs l-element li jkun hemm wara. Jekk l-element ma jkunx hemm, irritorna -1.""""""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,mlt_Latn,python,"
def largest_smallest_integers(lst):
    '''Iftaħ funzjoni li tirritorna tupla (a, b), fejn 'a' huwa l-ikbar numru sħiħ negattiv, u 'b' huwa l-iżgħar numru sħiħ pożittiv f'lista. Jekk m'hemmx numru sħiħ negattiv jew pożittiv, erġa' lura bħala Ħadd. Eżempji: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (Ħadd, 1) largest_smallest_integers([]) == (Ħadd, Ħadd) largest_smallest_integers[0]) == (Ħadd, Ħadd)'''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,mlt_Latn,python,"
def compare_one(a, b):
    """"""Ħolqien ta' funzjoni li tieħu l-inteġers, floats, jew strings li jirrappreżentaw in-numri reali, u jirritorna l-varjabbli akbar fit-tip ta' varjabbli mogħti. Irritorna None jekk il-valuri huma ugwali. Nota: Jekk numru reali huwa rrappreżentat bħala stringa, il-punt li jvarja jista' jkun . jew , compare_one{1, 2.5) â -> 2.5 compare_one{1, ""2,3"") â -> ""2,3"" compare_one{"",5,1"", ""6"") â -> ""6"" compare_one{"",1"", 1) â -> None """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,mlt_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Evaluta jekk in-numru n mogħti jistax jinkiteb bħala s-somma ta' eżattament 4 numri pari pożittivi Eżempju is_equal_to_sum_even ((4) == False is_equal_to_sum_even ((6) == False is_equal_to_sum_even ((8) == True """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,mlt_Latn,python,"
def special_factorial(n):
    """"""Il-fatturjali Brażiljan huwa definit bħala: brazil_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! fejn n > 0 Pereżempju: >>> special_factorial ((4) 288 Il-funzjoni tirċievi numru sħiħ bħala input u għandha tirritorna l-fatturjali speċjali ta 'dan in-numru sħiħ. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,mlt_Latn,python,"
def fix_spaces(text):
    """"""_Eżempju-3ringa ta' test, ibdel l-ispazji kollha fiha b'sottolinja, u jekk stringa jkollha aktar minn 2 spazji konsekuttivi, ibdel l-ispazji konsekuttivi kollha b' - fix_spaces ((""Eżempju"") == ""Eżempju"" fix_spaces (((""Eżempju1"") == ""Eżempju_1"" fix_spaces (((""Eżempju2"") == ""_Eżempju_2"" fix_spaces (((""Eżempju 3"") == ""_Eżempju-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,mlt_Latn,python,"
def file_name_check(file_name):
    """"""- L-isem tal-fajl għandu jkun fih eżattament punt wieħed. - Is-substring qabel il-punt m'għandux ikun vojt, u għandu jibda b'ittra mill-alfabetta Latina ('a'-'z' u 'A'-Z'). - Is-substring wara l-punt għandu jkun wieħed minn dawn: ['txt', 'exe', 'lld'] Eżempji: file_name_check""{eżempju.txt"") # => 'Yes' file_name_check""{eżempju.ll1"") => 'No' (l-isem għandu jibda b'ittra mill-alfabetta Latina)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,mlt_Latn,python,"


def sum_squares(lst):
    """""""" Din il-funzjoni se tieħu lista ta ' entrati. Għall-entrati kollha fil-lista, il-funzjoni għandha kwadrat l-entrata enterja jekk l-indiċi tagħha huwa multiplu ta ' 3 u se kubju l-entrata enterja jekk l-indiċi tagħha huwa multiplu ta ' 4 u mhux multiplu ta ' 3. Il-funzjoni mhux se tbiddel l-entrati fil-lista li l-indiċi tagħhom mhumiex multiplu ta ' 3 jew 4. Il-funzjoni mbagħad għandha tirritorna s-somma ta ' l-entrati kollha. Eżempji: Għal lst = [1,2,3] l-output għandu jkun 6 Għal lst = [] l-output għandu jkun 0 Għal lst = [-1,-5,2,-1,-5] l-output għandu jkun -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,mlt_Latn,python,"
def words_in_sentence(sentence):
    """"""Int tingħata string li tirrappreżenta sentenza, is-sentenza fiha xi kliem separati minn spazju, u trid tirritorna string li fiha l-kliem mis-sentenza oriġinali, li t-tul tagħhom huwa numru primarju, l-ordni tal-kliem fis-serje l-ġdida għandu jkun l-istess bħal dak oriġinali. Eżempju1: Input: sentenza = ""Dan huwa test"" Output: ""huwa"" Eżempju2: Input: sentenza = ""jħallu jmorru għall-għawm"" Output: ""morru għal"" Restrizzjonijiet: * 1 <= len(sentenza) <= 100 * is-sentenza fiha biss ittri """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,mlt_Latn,python,"
def simplify(x, n):
    """"""Il-funzjoni tirritorna True jekk x * n jiġi evalwat bħala numru sħiħ u False jekk le. Kemm x u n huma rappreżentazzjoni ta' stringa ta' frazzjoni, u għandhom il-format li ġej, <numeratur>/<denominatur> fejn kemm in-numeratur kif ukoll id-denominatur huma numri sħaħ pożittivi. Tista' tassumi li x, u n huma frazzjonijiet validi, u m'għandhomx żero bħala denominatur. simplify ""1/5"", ""5/1"") = True simplify ""1/6"", ""2/1"") = False simplify ""7/10"", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,mlt_Latn,python,"
def order_by_points(nums):
    """"""Ikteb funzjoni li ssordixxi l-lista mogħtija ta' numri sħaħ f'ordni li jikber skond is-somma tad-diġiti tagħhom. Nota: jekk hemm diversi elementi b'somma simili tad-diġiti tagħhom, ordnalhom abbażi tal-indiċi tagħhom fil-lista oriġinali. Per eżempju: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,mlt_Latn,python,"
def specialFilter(nums):
    """"""Ikteb funzjoni li tieħu materja prima ta' numri bħala input u tirritorna n-numru ta' elementi fl-materja prima li huma akbar minn 10 u kemm l-ewwel kif ukoll l-aħħar ċifri ta' numru huma mhux pari (1, 3, 5, 7, 9). Pereżempju: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,mlt_Latn,python,"
def get_max_triples(n):
    """"""Int tingħata numru sħiħ pożittiv n. Għandek toħloq materjalità ta 'għadd sħiħ a ta' tul n. Għal kull i (1 ‰¤ i ‰¤ n), il-valur ta 'a[i] = i * i - i + 1. Irritorna n-numru ta 'tripli (a[i], a[j], a[k]) ta 'a fejn i < j < k, u a[i] + a[j] + a[k] huwa multiplu ta' 3. Eżempju: Input: n = 5 Output: 1 Spjegazzjoni: a = [1, 3, 7, 13, 21] L-uniku triplu validu huwa (1, 7, 13). """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,mlt_Latn,python,"
def bf(planet1, planet2):
    '''Hemm tmien planeti fis-sistema solari tagħna: l-eqreb lejn ix-xemx huwa Merkurju, il-ieħor huwa Venu, imbagħad l-Art, Mars, Ġove, Saturnu, Uranu, Neptunu. Ikteb funzjoni li tieħu żewġ ismijiet ta 'pjaneta bħala strings planet1 u planet2. Il-funzjoni għandha tirritorna tuple li jkun fih il-pjaneti kollha li l-orbit tagħhom jinsabu bejn l-orbita ta' planet1 u l-orbita ta 'planeta2, magħżula mill-prossimità lejn ix-xemx. Il-funzjoni għandha tirritorna tuple vojta jekk planet1 jew planet2 mhumiex ismijiet ta 'pjaneti korretti. Eżempji bf ""(Ġove"", ""Ġove"") ==> (""Saturnu"", ""Uran"") bf (((""Terra"", ""Merkurju"") ==> (""Venu"") bf (((""Merkurju"", ""Uran"") ==> (""Venu"", ""Terra"", ""Mars"", ""Ġove"", ""Sn"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,mlt_Latn,python,"
def sorted_list_sum(lst):
    """"""Ikteb funzjoni li taċċetta lista ta' strings bħala parametru, tħassar il-strings li għandhom tul mhux ugwali minnha, u tirritorna l-lista li tirriżulta b'ordni ordnat, Il-lista hija dejjem lista ta' strings u qatt ma hija materja ta' numri, u tista' tinkludi duplikati. L-ordni tal-lista għandu jkun li jitla' bil-tul ta' kull kelma, u għandek tirritorna l-lista ordnata b'dik ir-regola. Jekk żewġ kelmiet għandhom l-istess tul, issortja l-lista alfabetikament. Il-funzjoni għandha tirritorna lista ta' strings f'ordni ordnat. Tista' tassumi li l-kliem kollha se jkollhom l-istess tul. Per eżempju: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => ""ab"", ""cd ])""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,mlt_Latn,python,"
def x_or_y(n, x, y):
    """"""Programm sempliċi li għandu jirritorna l-valur ta' x jekk n huwa numru prim u għandu jirritorna l-valur ta' y inkella. Eżempji: għal x_or_y(7, 34, 12) == 34 għal x_or_y(15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,mlt_Latn,python,"
def double_the_difference(lst):
    '''Meta tingħata lista ta' numri, irritorna s-somma tal-kwartieri tan-numri fil-lista li huma mhux par. Injora n-numri li huma negattivi jew mhux integers. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Jekk il-lista ta' input hija vojta, irritorna 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,mlt_Latn,python,"
def compare(game,guess):
    """"""Il-logħba hija waħda li tista 'tiġi interpretata b'mod ċar u b'mod ċar. Il-logħba hija waħda li tista' tiġi interpretata b'mod ċar u b'mod ċar. Il-logħba hija waħda li tista 'tiġi interpretata b'mod ċar u b'mod ċar.""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,mlt_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Jekk ikun hemm żewġ estensjonijiet bl-istess qawwa, għandek tagħżel dik li tidher l-ewwel fil-lista. Pereżempju, jekk tingħata ""Slices"" bħala l-klassi u lista ta' estensjonijiet: ['SEviviSliCes', 'Cheese', 'StuFfed'] allura għandek tirritorna 'Slices.SEviSliCes' peress li 'SviviSliCes' hija l-aktar qawwa estensjoni (eż.: 'AA_Beats'), pereżempju 'Class_Strongest' = 'AA_Beats', 'Class_Strongest' = 'AA_Beats'), għal 'Class_Strongest' = 'Class_Strongest' => 'Class_Beats' => 'Class_Strongest' => 'Class_AA_Beats' => 'Class_Strongest' => 'Class_Beats' => 'Class_Beats' => 'Class_Beats' => 'Class_AA_Beats' => 'Class_Beats'""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,mlt_Latn,python,"
def cycpattern_check(a , b):
    """"""Inti tingħata 2 kelmiet. Għandek bżonn li jirritornaw True jekk it-tieni kelma jew xi wieħed mill-rotazzjoni tagħha hija sottostring fl-ewwel kelma cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,mlt_Latn,python,"
def even_odd_count(num):
    """"""Jekk jingħata numru sħiħ, jirritorna tuple li għandu n-numru ta' ċifri pari u mhux pari rispettivament. Eżempju: even_odd_count ((-12) ==> (1, 1) even_odd_count ((123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,mlt_Latn,python,"
def int_to_mini_roman(number):
    """"""Meta tingħata numru sħiħ pożittiv, tikseb l-ekwivalenti tiegħu fin-numri Rumani bħala stringa, u terġa' lura f'ittri żgħar. Restrizzjonijiet: 1 <= num <= 1000 Eżempji: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,mlt_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Ikteb it-tul tat-tliet naħat ta' triangolu. Irritorna True jekk it-tliet naħat jiffurmaw triangolu rettangolu, False inkella. Triangolu rettangolu huwa triangolu li fih angolu wieħed huwa angolu rett jew 90 grad. Eżempju: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,mlt_Latn,python,"
def find_max(words):
    """"""Ikteb funzjoni li taċċetta lista ta' strings. Il-lista fiha kliem differenti. Irritorna l-kelma b'numru massimu ta' karattri uniċi. Jekk strings multipli għandhom numru massimu ta' karattri uniċi, irritorna dak li jiġi l-ewwel f'ordni leksikografika.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,mlt_Latn,python,"
def eat(number, need, remaining):
    """"""Inti ġawnun bil-ġuħ, u inti diġà kielu ċertu numru ta 'karawett, iżda issa għandek bżonn li jieklu aktar karawett biex tikkompleta ikliet tal-ġurnata. għandek jirritornaw array ta' [numru totali ta 'karawett mietu wara l-ikliet tiegħek, l-għadd ta 'karawett li fadal wara l-ikliet tiegħek ] jekk ma jkunx hemm biżżejjed karawett li jifdal, inti ser jieklu l-karawett li jifdal, iżda xorta se jkun bil-ġuħ. Eżempju: * jieklu ((5, 6, 10) -> [11, 4] * jieklu ((4, 8, 9) -> [12, 1] * jieklu ((1, 10, 10) -> [11, 0] * jieklu ((2, 11, 5) -> [7, 0] Varjabbli: @number: in-numru sħiħ tan-numru ta 'karawett li inti tkun kielu. @need: in-numru sħiħ tal-karawett li għandek bżonn li jieklu. @remaining: in-numru sħiħ tan-numru ta 'karawett li jifdal fil-istokk: * Constrain = 0 <= 0 * <= 1000 <= 0 * in-numru sħiħ tal-karwett li jifdal <= 1000 <= 1000 <= 1000""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,mlt_Latn,python,"
def do_algebra(operator, operand):
    """"""Meta wieħed jagħti żewġ listi ta' operatur, u operand. L-ewwel lista għandha operazzjonijiet bażiċi tal-alġebra, u t-tieni lista hija lista ta' integers. Uża ż-żewġ listi mogħtija biex tibni l-espressjoni alġebrika u terġa' lura l-evalwazzjoni ta' din l-espressjoni. L-operazzjonijiet bażiċi tal-alġebra: Żid (+) Tnaqqis (- -) Tkissir (*) Taqsima ta' art (//) Esponenzja (** Eżempju): operatur['+', '*', '-'] matrix = [2, 3, 4, 5] riżultat = 2 + 3 * 4 - 5 => riżultat = 9 Nota: It-tul tal-lista ta' operatur huwa ugwali għat-tul tal-lista ta' operand minus wieħed. L-operand hija lista ta' integers mhux negattivi. Operatur għandha mill-inqas operatur wieħed, u lista ta' operand għandha mill-inqas żewġ operandi. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,mlt_Latn,python,"
def solve(s):
    """"""Jekk s[i] hija ittra, irriversja l-kaxxa tagħha minn isfel għal fuq jew vice versa, inkella żommha kif inhi. Jekk il-linja ma fiha l-ebda ittra, irriversja l-linja. Il-funzjoni għandha tirritorna l-linja li tirriżulta. Eżempji solve{""1234"") = ""4321"" solve{""ab"") = ""AB"" solve{""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,mlt_Latn,python,"
def string_to_md5(text):
    """"""Jekk tingħata stringa 'text', erġa' lura l-stringa ekwivalenti ta' md5 hash tagħha. Jekk 'text' hija stringa vojta, erġa' lura None. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,mlt_Latn,python,"
def generate_integers(a, b):
    """"""Meta jingħataw żewġ numri sħaħ pożittivi a u b, irritorna d-diġiti pari bejn a u b, f'ordni li jikber. Pereżempju: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
