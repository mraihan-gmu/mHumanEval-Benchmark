[
    {
        "task_id": "HumanEval/0",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"ตรวจสอบว่าในรายการจํานวนที่ให้ไว้ มีจํานวนใด ๆ ที่ใกล้เคียงกันมากกว่าขอบที่ให้ไว้ ตัวอย่าง: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) False >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"การเข้าของฟังก์ชันนี้คือ สตริงที่มีกลุ่มหลายกลุ่มของลูกกรงกิ่งที่อยู่ในรัง คุณตั้งเป้าที่จะแยกกลุ่มเหล่านั้นออกเป็นสตริงที่แยกกันและคืนรายการของกลุ่มเหล่านั้น กลุ่มที่แยกกันมีสมดุล (แต่ละลูกกรงกิ่งที่เปิดถูกปิดอย่างถูกต้อง) และไม่อยู่ในรังในตัวอื่นๆ ละเลยช่องว่างใด ๆ ในสตริงการเข้า ตัวอย่าง: >>> separate_paren_groups' ((( ) (() (( ) ) ) ) ) ' ' ' ' (') ', ' (') ', ' (') '\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"ให้จํานวนจุดลอยบวก, มันสามารถแยกออกเป็น ส่วนทั้งตัว (จํานวนทั้งตัวที่ใหญ่ที่สุดน้อยกว่าจํานวนที่ให้) และส่วนทศนิยม (ส่วนที่เหลือเสมอน้อยกว่า 1) ยกคืนส่วนทศนิยมของจํานวน ตัวอย่าง: >>> truncate_number ((3.5) 0.5 \"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"คุณได้รับรายการการฝากและถอนเงินในบัญชีธนาคารที่เริ่มต้นด้วยสมดุลศูนย์. งานของคุณคือการตรวจจับว่าในจุดใดที่สมดุลบัญชีลดลงต่ํากว่าศูนย์ และในจุดนั้นฟังก์ชันควรคืน True. ถ้าไม่ควรคืน False. ตัวอย่าง: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"สําหรับรายการข้อมูลข้อมูลที่ได้รับมา, คํานวณ Mean Absolute Deviation ราวๆค่าเฉลี่ยของชุดข้อมูลนี้ Mean Absolute Deviation คือค่าเฉลี่ยของความแตกต่างเฉลี่ยระหว่างแต่ละองค์ประกอบกับจุดศูนย์กลาง (ค่าเฉลี่ยในกรณีนี้): MAD = average. x - x_mean. ตัวอย่าง: >>> mean_absolute_deviation (([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"เพิ่มเลข \"ขอบเขต\" ระหว่างแต่ละ 2 ตัวประกอบติดต่อกันของรายการข้อมูลเข้า `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"การเข้าของฟังก์ชันนี้คือ สตริงที่แสดงเป็นกลุ่มหลายกลุ่มสําหรับลูกเกสรที่วางกองกัน โดยแยกด้วยช่องว่าง สําหรับกลุ่มแต่ละกลุ่ม ออกระดับที่ลึกที่สุดของลูกเกสร เช่น (() (()) มีระดับการวางกองสูงสุด 2 ระดับ ในขณะที่ ((())) มี 3 ระดับ >>> parse_nested_parens('((()) ((())) () (((()) (((()) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"การกรองรายการการเข้าของสายพันธุ์สําหรับที่บรรจุสายพันธุ์รองที่ได้รับการให้ >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"สําหรับรายการจํานวนเต็มที่ให้มา ให้ค่า tuple ประกอบด้วยผลบวกและผลคูณของจํานวนเต็มทั้งหมดในรายการ ผลบวกว่างควรเท่ากับ 0 และผลคูณว่างควรเท่ากับ 1. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"จากรายการจํานวนเต็มที่ให้ไว้, สร้างรายการขององค์ประกอบสูงสุดที่พบจนถึงช่วงเวลาที่ให้มาในลําดับ. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"ค้นหา palindrome ที่สั้นที่สุดที่เริ่มด้วย string ที่ได้รับการจัดหา แนวคิดของอัลกอริทึมง่าย: - ค้นหา postfix ที่ยาวที่สุดของ string ที่ได้รับการจัดหาที่เป็น palindrome. - เพิ่มที่ปลายของ string reverse ของ string prefix ที่มาก่อนที่สับปะ palindromic. >>> make_palindrome('') '' >>> make_palindrome('cat') 'catac' >>> make_palindrome('catac') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"ทดสอบว่า string เป็นพาลินโดรมหรือไม่\"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"การเข้าคือสองสาย a และ b ซึ่งประกอบด้วย 1 และ 0 เท่านั้น ทําการ XOR ไบนารีกับสายเหล่านี้ และคืนผลเป็นสายด้วย. >>> string_xor (('010', '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"จากรายการของสายการเขียน ให้คืนสายที่ยาวที่สุด กลับสายแรกในกรณีที่มีสายการเขียนหลายสายความยาวเดียวกัน กลับไม่มีในกรณีที่รายการข้อมูลเข้าว่าง >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"คืนค่าส่วนร่วมที่ใหญ่ที่สุดของจํานวนเต็ม a และ b >>> greatest_common_divisor ((3, 5) 1 >>> greatest_common_divisor ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"รายการคืนของตัวอักษรทั้งหมดจากตัวอักษรที่สั้นที่สุดไปยังตัวอักษรที่ยาวที่สุดของสายข้อมูล >>> all_prefixes (('abc') ['a', 'ab', 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"คืนสายที่มีตัวเลขที่จํากัดด้วยพื้นที่ เริ่มจาก 0 ถึง n รวมกัน. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"ให้ string, หาว่ามีตัวอักษรแตกต่างกันกี่ตัว (ไม่ว่าจะเป็นตัวเอก) ที่ประกอบด้วย >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"การเข้าสู่ฟังก์ชันนี้คือสายที่แสดงตัวอักษรดนตรีในรูปแบบ ASCII ที่พิเศษ การทํางานของคุณคือการวิเคราะห์รายการสายของจํานวนเต็มที่ตรงกับหลายจังหวะ ทําที่นี่เป็นตํานาน: 'o' โน้ต, ล่าสุดตีสี่ 'o' จอ' - ครึ่งโน้ต, ล่าสุดสองตี' จอ' - quater โน้ต, ล่าสุดตีหนึ่ง >>> parse_music. 'o' จอ' . o' จอ' o' จอ' .\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"หาว่าจํานวนครั้งที่ซับสตริงใด ๆ สามารถพบได้ในสตริงเดิม นับกรณีซ้อนกัน >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"การเข้าคือ สตริงที่มีการจํากัดพื้นที่ของตัวเลขจาก 'ศูนย์' ถึง 'เก้า' ตัวเลือกที่ใช้ได้คือ 'ศูนย์', 'หนึ่ง', 'สอง', 'สาม', 'สี่', 'ห้า', 'หก', 'เจ็ด', 'แปด' และ 'เก้า' ส่งคืน สตริงที่มีตัวเลขเรียงจากตัวเล็กที่สุดไปยังตัวใหญ่ที่สุด >>> sort_numbers (('สาม หนึ่ง ห้า') 'หนึ่ง สาม ห้า' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"จากรายการจํานวนที่ได้รับ (ความยาวอย่างน้อย 2 ตัว) เลือกและคืน 2 ตัวที่ใกล้กันที่สุด และคืนตามลําดับ (ตัวเลขเล็กกว่าตัวเลขใหญ่) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"ให้รายการของตัวเลข (ของอย่างน้อย 2 องค์ประกอบ) ใช้การแปลงเชิงเส้นกับรายการนั้น เช่น ตัวเลขที่เล็กที่สุดจะกลายเป็น 0 และตัวเลขที่ใหญ่ที่สุดจะกลายเป็น 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"การกรองรายการของค่าพีธอนใด ๆ สําหรับจํานวนเต็มเท่านั้น >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"ความยาวของการคืนของ string >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"สําหรับจํานวน n ให้แล้วหาจํานวนที่ใหญ่ที่สุดที่หาร n ได้เท่ากัน, เล็กกว่า n >>> ใหญ่ที่สุด_ผู้หาร ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"คืนรายการของตัวประกอบหลักของจํานวนเต็มที่ให้มาตามลําดับจากตัวเล็กที่สุดไปยังตัวใหญ่ที่สุด. ตัวประกอบแต่ละตัวควรถูกรายชื่อจํานวนครั้งที่ตรงกับจํานวนครั้งที่มันปรากฏในการแยกตัวประกอบ. ตัวเลขทางเข้าควรเท่ากับผลคูณของตัวประกอบทั้งหมด >>> factorise(8) [2, 2, 2] >>> factorise(25) [5, 5] >>> factorise(70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"จากรายการของจํานวนเต็ม ลบองค์ประกอบทั้งหมดที่เกิดขึ้นมากกว่าครั้งหนึ่ง ใส่ลําดับขององค์ประกอบที่เหลือเหมือนในข้อมูลเข้า >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"สําหรับสตริงที่ให้การ, เปลี่ยนตัวอักษรตัวเล็กเป็นตัวใหญ่ และตัวใหญ่เป็นตัวเล็ก. >>> flip_case ((('Hello') 'HELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"การต่อสายเป็นสายเดียว >>> การต่อสาย (([]) '' >>> การต่อสาย ((['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"การกรองรายการการเข้าของสายเสียงสําหรับที่เริ่มต้นด้วยตัวอักษรที่กําหนดไว้เท่านั้น. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"คืนจํานวนบวกในรายการเท่านั้น. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"คืน true หากจํานวนที่ให้ไว้เป็นจํานวนหลัก และ false หากไม่ >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs คือสัมประสิทธิ์ของพหุนาม find_zero find x เช่น poly(x) = 0. find_zero คืนเพียงแค่จุดศูนย์เท่านั้น แม้จะมีหลายจุด นอกจากนี้ find_zero ยังใช้รายการ xs ที่มีสัมประสิทธิ์จํานวนเท่าและสัมประสิทธิ์ที่ไม่เท่ากับศูนย์ที่ใหญ่ที่สุดเท่านั้น เพราะมันรับประกันคําตอบ >>> round ((find_zero[(1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 1.0 \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"ประเมินพหุนามที่มีสัมประสิทธิ์ xs ที่จุด x. คืน xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"ฟังก์ชันนี้ใช้รายการ l และคืนรายการ l' แบบที่ l' เป็นตัวเดียวกันกับ l ในอัณฑ์ที่ไม่หารด้วยสาม ขณะที่ค่าของมันที่อัณฑ์ที่หารด้วยสาม เท่ากับค่าของอัณฑ์ที่ตรงกันของ l แต่จัดเรียง. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"คืนรายการที่จัดเรียงมาเป็นเอกลักษณ์ในรายการ >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"คืนค่าธาตุสูงสุดในรายการ. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"คืนจํานวนครั้งที่หลัก 7 ปรากฏในจํานวนเต็มน้อยกว่า n ที่หารด้วย 11 หรือ 13 >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"ฟังก์ชันนี้ใช้รายการ l และคืนรายการ l' แบบที่ l' เป็นเหมือนกันกับ l ในอัตราตัวเลขคราด ขณะที่ค่าของมันที่อัตราตัวเลขคู่ เท่ากับค่าของอัตราตัวเลขคู่ของ l แต่จัดเรียง. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"รับเป็น string ที่เข้าเข้าแบบโค้ดด้วยฟังก์ชัน encode_cyclic คืน string ที่ถอดรหัส\"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"คืน string ที่เข้ารหัสโดยกลุ่มรอบของสามตัวอักษร\"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib คืนเลขที่ n ที่เป็นเลขฟิโบนาคซี่ และยังเป็นจํานวนหลัก. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero ใช้รายการของจํานวนเต็มเป็นอินพุต มันคืน True ถ้ามีองค์ประกอบที่แตกต่างกันสามอย่างในรายการที่รวมเป็นศูนย์ และ False ถ้าไม่เช่นนั้น >>> triples_sum_to_zero (([1, 3, 5, 0]) False >>> triples_sum_to_zero (([1, 3, -2, 1]) True >>> triples_sum_to_zero (([1, 2, 3, 7]) False >>> triples_sum_to_zero (([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero (([1]) False \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"ลองจินตนาการถนนที่ตรงตรงอย่างสมบูรณ์แบบเป็นเส้นยาวไม่สิ้นสุด. n รถกําลังขับรถไปทางซ้ายไปทางขวา; ในขณะเดียวกัน, รถที่แตกต่างกัน n รถกําลังขับรถไปทางขวาไปทางซ้าย. รถสองชุดเริ่มต้นที่ห่างไกลจากกันและกัน. รถทั้งหมดเคลื่อนที่ด้วยความเร็วเท่ากัน. สองรถบอกว่าจะชนกันเมื่อรถที่เคลื่อนไปทางซ้ายไปทางขวาชนรถที่เคลื่อนไปทางขวาไปทางซ้าย. อย่างไรก็ตาม, รถมีความแข็งแรงและแข็งแรงอย่างไม่สิ้นสุด; ผลลัพธ์คือ, พวกเขากําลังดําเนินการในเส้นทางของพวกเขาเหมือนว่าพวกเขาไม่ได้ชนกัน. ฟังก์ชันนี้ออกจํานวนของชนกันดังกล่าว.\"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"รายการคืนที่มีองค์ประกอบเพิ่มขึ้นด้วย 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] \"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero ใช้รายการของจํานวนเต็มเป็นข้อมูลเข้า มันคืน True ถ้ามีองค์ประกอบที่แตกต่างกันในรายการที่รวมเป็น 0 และ False ถ้าไม่. >>> pairs_sum_to_zero (([1, 3, 5, 0]) False >>> pairs_sum_to_zero (([1, 3, -2, 1]) False >>> pairs_sum_to_zero (([1, 2, 3, 7]) False >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero (([1]) False \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"เปลี่ยนฐานเลขของตัวเลข x เป็นฐาน. คืนตัวแทนสายหลังจากการแปลง. ตัวเลขฐานน้อยกว่า 10 >>> เปลี่ยน_ฐาน(8, 3) '22' >>> เปลี่ยน_ฐาน(8, 2) '1000' >>> เปลี่ยน_ฐาน(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"ความยาวด้านและพื้นที่กลับสูงสําหรับสามเหลี่ยม >>> triangle_area ((5, 3) 7.5 \"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"การเรียงลําดับเลข Fib4 เป็นการเรียงลําดับที่คล้ายกับการเรียงลําดับ Fibbonacci ที่ถูกกําหนดดังนี้: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). กรุณาเขียนฟังก์ชันเพื่อคํานวณองค์ประกอบที่ n ของการเรียงลําดับเลข fib4 อย่างมีประสิทธิภาพ. อย่าใช้การเรียงลําดับ. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"คืนค่าเฉลี่ยของธาตุในรายการ l. >>> median (([3, 1, 2, 4, 5]) 3 >>> median (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"ตรวจสอบว่าสตริงที่ให้มาเป็นพาลินดรอม >>> is_palindrome (('') จริง >>> is_palindrome (('aba') จริง >>> is_palindrome (('aaaaa') จริง >>> is_palindrome (('zbcd') ผิด\"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"คืน 2^n modulo p (ต้องรู้ตัวเลข) >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"รับเป็น string ที่เข้าเข้าโดยใช้ฟังก์ชัน encode_shift คืน string ที่ถอดรหัส\"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"คืน string ที่เข้ารหัส โดยการเลื่อนตัวอักษรทุกตัวด้วย 5 ในอักษร\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels เป็นฟังก์ชันที่ใช้ string และคืน string ที่ไม่มีตัวเสียง. >>> remove_vowels('') '' >>> remove_vowels(\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"คืน True หากเลขทั้งหมดในรายการ l อยู่ใต้ขอบ t. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"บวกเลข x และ y >>> บวก ((2, 3) 5 >>> บวก ((5, 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"ตรวจสอบว่าคําสองคํามีตัวอักษรเหมือนกันหรือไม่ >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') จริง >>> same_chars (('abcd', 'dddddddabc') จริง >>> same_chars (('dddddddabc', 'abcd') จริง >>> same_chars (('eabcd', 'dddddddabc') ผิด >>> same_chars ((('abcd', 'dddddddabddce') ผิด >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') ผิด \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"คืนเลขฟิโบนาคซีที่ n. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets เป็นสายของ \"<\" และ \">\". return True ถ้าทุก bracket ที่เปิดมี bracket ที่ปิดที่ตรงกัน. >>> correct_bracketing(\"<\") False >>> correct_bracketing(\"<>\") True >>> correct_bracketing(\"<><>\") True >>> correct_bracketing(\"><<>\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"Return True คือรายการมีองค์ประกอบที่เพิ่มขึ้นหรือลดลงอย่างเป็นประจํา >>> monotonic (([1, 2, 4, 20]) True >>> monotonic (([1, 20, 4, 10]) False >>> monotonic (([4, 1, 0, -10]) True \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"คืนประเภทประเภทร่วมที่จัดเรียงมาเป็นเอกลักษณ์สําหรับสองรายการ. >>> common (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> common (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"คืนตัวประกอบหลักที่ใหญ่ที่สุดของ n สมมุติว่า n > 1 และไม่ใช่ตัวประกอบหลัก >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n เป็นฟังก์ชันที่รวมตัวเลขจาก 1 ถึง n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets เป็นสายของ \"(\" และ \")\". return True ถ้าทุก bracket ที่เปิดมี bracket ที่ปิดที่ตรงกัน. >>> correct_bracketing(\"(\") False >>> correct_bracketing(\"() True >>> correct_bracketing(\"() True >>> correct_bracketing(\") True >>> correct_bracketing(\")\"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs เป็นตัวประกอบของพหุนาม xs[0] + xs[1] * x + xs[2] * x^2 + .... คืนอนุพันธ์ของพหุนามนี้ในรูปเดียวกัน. >>> derivative (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivative[(1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"การเรียงลําดับเลข FibFib เป็นการเรียงลําดับที่คล้ายกับการเรียงลําดับ Fibbonacci ที่ถูกกําหนดดังนี้: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3 กรุณาเขียนฟังก์ชันเพื่อคํานวณองค์ประกอบที่ n ของการเรียงลําดับเลข fibfib. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"เขียนฟังก์ชัน vowels_count ที่ใช้สายเสียงแทนคําเป็นอินพุต และคืนจํานวนเสียงในสายเสียง. ตัวเสียงในกรณีนี้คือ 'a', 'e', 'i', 'o', 'u'. ในที่นี้ 'y' ก็เป็นเสียง แต่เป็นเสียงในตอนท้ายของคําที่ให้ตัวอย่าง: >>> vowels_count ((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"เพิ่มกรณีทดลองเพิ่มเติม\"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"การเคลื่อนย้ายหลักของจํานวนเต็ม x เป็นวงกลม, การเคลื่อนย้ายหลักไปทางขวาโดยการเคลื่อนย้าย และคืนผลเป็นสตริง หาก shift > จํานวนหลัก, ให้เลขกลับ. >>> circular_shift(12, 1) \"21\" >>> circular_shift(12, 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"การเขียนฟังก์ชันที่ใช้สายคอมเป็นข้อมูลเข้า และคืนผลรวมของตัวอักษรบนเท่านั้น' รหัส ASCII ตัวอย่าง: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"ในงานนี้ คุณจะได้รับสตริงที่แสดงจํานวนแอปเปิ้ลและส้มที่กระจายอยู่ในถังผลไม้ถังนี้มีแอปเปิ้ล, ส้ม, และผลไม้มังโกะ. ให้สตริงที่แสดงจํานวนทั้งหมดของส้มและแอปเปิ้ลและจํานวนเต็มที่แสดงจํานวนทั้งหมดของผลไม้ในถังคืนจํานวนผลไม้มังโกะในถัง. สําหรับตัวอย่าง: fruit_distribution\"5(แอปเปิ้ลและ 6 ส้ม\", 19) -> 19 - 5 - 6 = 8 ผล_การกระจาย\"0แอปเปิ้ลและ 1 ส้ม\",3) -> 3 - 0 - 1 = 2 ผล_การกระจาย\"2แอปเปิ้ลและ 3 ส้ม\", 100) -> 100 - 2 - 3 = 95 ผล_การกระจาย\"100แอปเปิ้ลและ 1 ส้ม\",1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"ให้เรียงตัวแทนสาขาของต้นไม้ที่มีมุมจํานวนเต็มที่ไม่ลบ หน้าที่ของคุณคือการหยิบมุมหนึ่งและคืนมัน ถ้ามุมที่หยิบมาควรจะเป็นมุมที่มีค่าคู่ที่เล็กที่สุด ถ้าพบมุมหลายอันที่มีค่าคู่ที่เล็กที่สุดก็คืนมุมที่มีดัชนีที่เล็กที่สุด มุมที่หยิบมาควรถูกคืนในรายการ, [smallest_value, its index] ถ้าไม่มีค่าคู่หรือเรียงที่ให้มาว่างเปล่า, return []. ตัวอย่าง1: อินพุต: [4,2,3] ผลิต: [2, 1] คําอธิบาย: 2 มีค่าคู่ที่เล็กที่สุด, และ 2 มีดัชนีที่เล็กที่สุด ตัวอย่าง2: อินพุต: [1,2,3] ผลิต: [2, 1] คําอธิบาย: 2 มีค่าคู่ที่เล็กที่สุด, และ 2 มีดัชนีที่เล็กที่สุด ตัวอย่าง3: อินพุต: [] ผลิต: [] อินพุต: [4,5, 3, 4, 2] ผลิต: 1 [0, 0] ผลิต: 1 มีค่าคู่ที่เล็กที่สุด แต่มีค่าตัวเลขที่เล็กที่สุด ตัวอย่างที่สองคือศูนย์เล็กที่สุด ตัวอย่าง: * * เราเลือกมุมแรกที่มีค่าค่าเท่ากับ 0 แต่มีค่าศูนย์เล็กที่สุด ตัวอย่าง: 1 มีค่าศูนย์เล็กที่สุด\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''คุณได้รับรายการจํานวนเต็มบวกที่ไม่ว่าง ให้จํานวนเต็มที่ใหญ่ที่สุดที่มากกว่า 0 และมีความถี่มากกว่าหรือเท่ากับค่าของจํานวนเต็มตัวนั้นเอง ความถี่ของจํานวนเต็มคือจํานวนครั้งที่มันปรากฏในรายการ ถ้าไม่มีค่าดังกล่าวอยู่, ให้คืน -1. ตัวอย่าง: ค้นหา (([4, 1, 2, 2, 3, 1]) == 2 ค้นหา ([1, 2, 2, 3, 3, 3, 4, 4]) == 3 ค้นหา ([5, 5, 4, 4, 4]) == -1 '''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''การจัดเรียงแบบแปลก คือการเริ่มต้นด้วยค่าต่ําสุด จากนั้นก็เลือกค่าสูงสุดของจํานวนเต็มที่เหลือ จากนั้นก็เลือกค่าต่ําสุด เป็นต้น ตัวอย่าง: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''ให้ความยาวของสามด้านของสามเหลี่ยม. คืนพื้นที่ของสามเหลี่ยมโดยประมวลผลเป็น 2 ตัวกลางนิศนาม หากสามด้านเป็นสามเหลี่ยมที่ใช้ได้. ถ้าไม่คืน -1 สามด้านสร้างสามเหลี่ยมที่ใช้ได้เมื่อผลรวมของสองด้านใด ๆ มากกว่าด้านที่สาม. ตัวอย่าง: triangle_area ((3, 4, 5) == 6.00 triangle_area ((1, 2, 10) == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''เขียนฟังก์ชันที่คืน True หากวัตถุ q จะบิน และ False ถ้าไม่วัตถุ q จะบิน หากมันสมดุล (มันเป็นรายการ palindromic) และผลรวมขององค์ประกอบของมันน้อยกว่าหรือเท่ากับน้ําหนักสูงสุดที่อาจเป็นได้ w ตัวอย่าง: will_it_fly (([1, 2], 5) â -> False # 1+2 น้อยกว่าน้ําหนักสูงสุดที่อาจเป็นได้ แต่มันไม่สมดุล will_it_fly (([3, 2, 3], 1) â -> False # มันสมดุล แต่ 3+2+3 มากกว่าน้ําหนักสูงสุดที่อาจเป็นได้ will_it_fly (([3, 2, 3], 9) â -> True # 3+23 น้อยกว่าน้ําหนักสูงสุดที่อาจเป็นได้ และมันสมดุล will_it_fly ((([3], 5) â -> True # 3 น้อยกว่าน้ําหนักสูงสุดที่อาจเป็นได้ และมันสมดุล '''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"การให้จํานวนจํานวนเต็มที่ในเรียงตัวเรียงหาจํานวนลดน้อยที่สุดขององค์ประกอบที่ต้องเปลี่ยนเพื่อให้เรียงตัวเรียงเป็นพาลินดรอม เรียงพาลินดรอมคือเรียงที่อ่านไปข้างหลังและข้างหน้าเหมือนกัน ในการเปลี่ยนแปลงครั้งเดียวคุณสามารถเปลี่ยนองค์ประกอบหนึ่งไปยังองค์ประกอบอื่น ๆ เช่น: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 \"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''เขียนฟังก์ชันที่รับสองรายการของสายและคืนรายการที่มีจํานวนทั้งหมดของตัวอักษรในทุกสายของรายการน้อยกว่ารายการอื่น ๆ หากสองรายการมีจํานวนตัวอักษรเท่ากัน ให้รายการแรกกลับ ตัวอย่าง total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['i', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['hi', 'admin'], ['i', 'hi', 'hi']) â -> ['i', 'hi', 'hi'] total_match ((['4', [''1', '2', '3', '4', '5', ['4]) -> '4' ]]'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"เขียนฟังก์ชันที่คืนค่า true หากจํานวนที่ให้คือการคูณของ 3 หลักและ false ถ้าไม่เช่นนั้น. รู้ว่า (a) น้อยกว่า 100 ตัวอย่าง: is_multiply_prime(30) == True 30 = 2 * 3 * 5 \"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"งานของคุณคือเขียนฟังก์ชันที่คืนค่า true หากจํานวน x เป็นกําลังง่ายของ n และ false ในกรณีอื่นๆ. x เป็นกําลังง่ายของ n หาก n**int=x ตัวอย่าง: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''เขียนฟังก์ชันที่ใช้จํานวนเต็ม a และคืนค่า True หากตัวเลขนี้เป็นลูกบาศก์ของจํานวนเต็มใด ๆ. หมายเหตุ: คุณอาจสมมุติว่าข้อมูลเข้าเป็นจริงเสมอ. ตัวอย่าง: iscube ((1) ==> true iscube ((2) ==> false iscube ((-1) ==> true iscube ((64) ==> true iscube ((0) ==> true iscube ((180) ==> false '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"คุณได้รับภาระการเขียนฟังก์ชันที่รับจํานวน hexadecimal เป็น string และนับจํานวนของหลัก hexadecimal ที่เป็นตัวเลขอนุพันธ์ (ตัวเลขอนุพันธ์, หรือ prime, เป็นจํานวนธรรมชาติที่ใหญ่กว่า 1 ซึ่งไม่ใช่ผลผลผลิตของสองตัวเลขธรรมชาติที่เล็กกว่า) ตัวเลข hexadecimal คือ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. ตัวเลขอนุพันธ์คือ 2, 3, 5, 7, 11, 13, 17,... ดังนั้นคุณต้องกําหนดจํานวนของหลักต่อไปนี้: 2, 3, 5, 7, B (= decimal 11), D (= decimal 13) หมายเหตุ: คุณอาจคิดว่าการเข้าจะถูกต้องเสมอหรือว่างและ string, และสัญลักษณ์ A,B,C,D,E,F, เป็นเสมอตัวเลขใหญ่. ตัวอย่าง: สําหรับ num \"AB\" ผลิตผลิตผลิตผลิตควรจะเป็น num = 1. สําหรับ num = 1077E ผลิตผลิตผลควรจะเป็น 2. สําหรับ num \"AB\" = 331EDA ผลิตผลิตผลผลควรจะเป็น 4. \"BC\" = 6.067123DEF \"สําหรับผลิตผลิตผลควรจะเป็น 2. \"2020\"\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"คุณจะได้รับตัวเลขในรูปแบบทศนิยม และงานของคุณคือการแปลงมันเป็นรูปแบบไบนารี ฟังก์ชันควรคืนสาย, โดยแต่ละตัวอักษรแสดงตัวเลขไบนารี แต่ละตัวอักษรในสายจะเป็น '0' หรือ '1' จะมีตัวอักษรเพิ่มเติม 'db' ในตอนต้นและตอนท้ายของสาย ตัวอักษรเพิ่มเติมจะช่วยในการจัดรูปแบบ ตัวอย่าง: decimal_to_binary ((15) #คืน \"db1111db\" decimal_to_binary32) #คืน \"db100000db\"\"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"คุณได้รับ string s. งานของคุณคือตรวจสอบว่า string เป็น happy หรือไม่. string เป็น happy ถ้าความยาวของ string เป็นอย่างน้อย 3 ตัว และทุก 3 ตัวอักษรติดต่อกันจะแตกต่างกัน ตัวอย่าง: is_happy ((a) => False is_happy ((aa) => False is_happy ((abcd) => True is_happy ((aabb) => False is_happy ((adb) => True is_happy ((xyy) => False \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"เป็นสัปดาห์สุดท้ายของภาคเรียน และครูต้องให้คะแนนกับนักเรียน ครูได้ทําอัลกอริทึมของตัวเองสําหรับการให้คะแนน ปัญหาเดียวคือ เธอได้สูญเสียรหัสที่เธอใช้ในการให้คะแนน เธอได้ให้รายการ GPA สําหรับนักเรียนบางราย และคุณต้องเขียนฟังก์ชันที่สามารถออกรายการของคะแนนอักษรโดยใช้ตารางต่อไปนี้: GPA หมายเลขอักษร 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"เขียนฟังก์ชันที่ใช้สายและคืน True หากความยาวสายเป็นจํานวนหลักหรือ False หากไม่เช่นนั้น ตัวอย่าง prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"ให้จํานวนเต็มบวก n, คืนจํานวนจํานวนของจํานวนเต็มบวก n-หลักที่เริ่มต้นหรือจบด้วย 1. \"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"ให้จํานวนเต็มบวก N, คืนผลรวมของหลักในตัวเลขไบนารี ตัวอย่าง สําหรับ N = 1000, ผลรวมของหลักจะเป็น 1 ผลิตผลควรจะเป็น \"1\". สําหรับ N = 150, ผลรวมของหลักจะเป็น 6 ผลิตผลควรจะเป็น \"110\". สําหรับ N = 147, ผลรวมของหลักจะเป็น 12 ผลิตผลควรจะเป็น \"1100\". ตัวแปร: @N จํากัดจํานวนเต็ม: 0 â‰¤ N â‰¤ 10000. ผลิตผล: สตริงของเลขไบนารี \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"ให้รายการจํานวนเต็มที่ไม่ว่าง lst. บวกจํานวนจํานวนคู่ที่อยู่ในอัณฑ์คราด ตัวอย่าง: บวก (([4, 2, 6, 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"เขียนฟังก์ชันที่ใช้สายและคืนการสั่งการของมัน สายที่สั่งการของสาย, เป็นสายที่คําทั้งหมด (แยกด้วยช่องว่าง) ถูกแทนด้วยคําใหม่ที่ตัวอักษรทั้งหมดจัดเรียงลําดับขึ้นไปตามค่า ascii. หมายเหตุ: คุณควรรักษาลําดับของคําและช่องว่างในประโยค. ตัวอย่าง: anti_shuffle ((('Hi') คืน 'Hi' anti_shuffle ((('hello') คืน 'ehllo' anti_shuffle (('Hello World!!!') คืน 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"คุณได้รับข้อมูล 2 มิติ, เป็นรายการที่รัง, ซึ่งคล้ายกับเมทริกซ์, อย่างไรก็ตาม, ไม่เหมือนกับเมทริกซ์, แต่ละแถวอาจมีจํานวนคอลัมน์ที่แตกต่างกัน. ให้ lst, และ integer x, หาจํานวนทั้ง x ในรายการ, และคืนรายการของ tuples, [(x1, y1), (x2, y2) ...] เช่นว่าแต่ละ tuple เป็นพิกัด - (แถว, คอลัมน์), เริ่มต้นด้วย 0. เรียงพิกัดในตอนแรกโดยแถวในลําดับขึ้นไป. นอกจากนี้, เรียงพิกัดของแถวโดยคอลัมน์ในลําดับลงมา. ตัวอย่าง: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4], 0 (1, 4), (2, 5), (2, 0) get_((1), [] == [[แถวัด]], [1, 2, 3, 2]] [2, 3]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"ให้เรียงของจํานวนเต็มที่ไม่ลบ, ย้อนสําเนาของเรียงที่ได้รับการจัดเรียงหลังจากการจัดเรียง, คุณจะจัดเรียงเรียงที่ได้รับการจัดเรียงในลําดับขึ้นหากผลรวม ((ค่าดัชนีแรก, ราคาดัชนีสุดท้าย) เป็นคราด, หรือจัดเรียงมันในลําดับลดลงหากผลรวม ((ค่าดัชนีแรก, ราคาดัชนีสุดท้าย) เป็นคู่. หมายเหตุ: * ไม่เปลี่ยนเรียงที่ได้รับการจัดเรียง ตัวอย่าง: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"สร้างฟังก์ชัน encrypt ที่ใช้ string เป็นอาร์กูเมนต์ และคืน string ที่ถูกเข้ารหัส โดยการหมุนตัวอักษรตัวอักษรควรถูกหมุนในลักษณะที่ตัวอักษรจะลดลงสองคูณกับสองที่ เช่น: encrypt (('hi') คืน 'lm' encrypt (('asdfghjkl') คืน 'ewhjklnop' encrypt (('gf') คืน 'kj' encrypt (('et') คืน 'ix'\"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"คุณได้รับรายการของจํานวนเต็ม เขียนฟังก์ชัน next_smallest (() ที่คืนองค์ประกอบที่เล็กที่สุดที่ 2 ของรายการ กลับค่า None หากไม่มีองค์ประกอบดังกล่าว next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == ไม่มี next_smallest (([1, 1]) == ไม่มี \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"คุณจะได้รับการให้คําจํานวนหนึ่งและงานของคุณคือการนับจํานวนความเบื่อหน่าย ความเบื่อหน่ายเป็นประโยคที่เริ่มด้วยคําว่า \"I\" ประโยคถูกจํากัดด้วย '.', '?' หรือ '!'. ตัวอย่าง: >>> is_bored ((\"Hello world\") 0 >>> is_bored ((\"ฟ้าสีฟ้า ดวงอาทิตย์กําลังส่องแสง ฉันรักสภาพอากาศนี้\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''สร้างฟังก์ชันที่ใช้ 3 ตัวเลข คืน true ถ้าตัวเลขหนึ่งเท่ากับผลบวกของตัวเลขอีกสองตัว และตัวเลขทั้งหมดเป็นจํานวนเต็ม คืน false ในกรณีอื่น ๆ ตัวอย่าง any_int ((5, 2, 7) â -> True any_int ((3, 2, 2) â -> False any_int ((3, -2, 1) â -> True any_int ((3.6, -2.2, 2) â -> False '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"เขียนฟังก์ชันที่รับข้อความ และโค้ดในแบบที่มันเปลี่ยนตัวอักษรทั้งหมด แทนตัวเสียงทั้งหมดในข้อความด้วยตัวอักษรที่ปรากฏ 2 อันดับก่อนตัวเสียงในอักษรอังกฤษ สมมุติว่ามีเพียงตัวอักษร ตัวอย่าง: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"คุณได้รับรายการของจํานวนเต็ม คุณจําเป็นต้องหาค่าเฉพาะที่ใหญ่ที่สุด และคืนผลรวมของหลักของมัน ตัวอย่าง: สําหรับ lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] ผลิตภัณฑ์ควรเป็น 10 สําหรับ lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] ผลิตภัณฑ์ควรเป็น 25 สําหรับ lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] ผลิตภัณฑ์ควรเป็น 13 สําหรับ lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] ผลิตภัณฑ์ควรเป็น 11 สําหรับ lst = [0,81,12,31,21] ผลิตภัณฑ์ควรเป็น 3 สําหรับ lst = [1,0,8,1,2,1,7] ผลิตภัณฑ์ควรเป็น 7\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"การให้คําศัพท์, return True ถ้าคีย์ทั้งหมดเป็นสายในตัวเล็กหรือคีย์ทั้งหมดเป็นสายในตัวใหญ่, return False. ฟังก์ชันควรคืน False หากคําศัพท์ที่ให้ไว้ว่างเปล่า. ตัวอย่าง: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) ควรคืน True. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) ควรคืน False. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) ควรคืน False. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) False ควรคืน check.dict_case{\"NC\":\"STATE\", \"Z\":\"IP\"45\") }\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"ปฏิบัติฟังก์ชันที่ใช้จํานวนเต็มที่ไม่ลบ และคืนเรียงของจํานวนเต็ม n ตัวแรกที่เป็นจํานวนหลักและน้อยกว่า n ตัวอย่าง: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"กรอกฟังก์ชันที่ใช้จํานวนเต็มสองตัว และคืนผลคูณของหลักหน่วยของมัน สมมุติว่าข้อมูลเข้าใช้ได้เสมอ ตัวอย่าง: คูณ ((148, 412) ควรคืน 16. คูณ ((19, 28) ควรคืน 72. คูณ ((2020, 1851) ควรคืน 0. คูณ ((14,-15) ควรคืน 20. \"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"ให้ string s นับจํานวนตัวเสียงตัวใหญ่ในอัคคีพาร์ ตัวอย่าง: count_upper (('aBCdEf') คืน 1 count_upper (('abcdefg') คืน 0 count_upper (('dBBE') คืน 0 \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''สร้างฟังก์ชันที่ใช้ค่า (สตริง) ที่แสดงตัวเลข และคืนเลขเต็มที่ใกล้ที่สุด ถ้าเลขมีระยะห่างเท่ากันจากจํานวนเต็มสองตัว เลยกลมมันออกไปจากศูนย์ ตัวอย่าง >>> closest_integer ((\"10\") 10 >>> closest_integer ((\"15.3\") 15 หมายเหตุ: การกลมออกไปจากศูนย์ หมายถึงถ้าเลขที่ให้มามีระยะห่างเท่ากันจากจํานวนเต็มสองตัว ตัวอย่างที่คุณควรคืนคือตัวเลขที่ห่างจากศูนย์ที่สุด สําหรับตัวอย่าง closest_integer \" ((14.5\") ควรคืน 15 และ closest_integer \" ((-14.5\") ควรคืน -15. '''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"ให้จํานวนเต็มบวก n, คุณจะต้องสร้างกองหิน n ระดับ. ระดับแรกมี n หิน. จํานวนหินในระดับต่อไปคือ: - เลขไม่เท่าตัวต่อไปถ้า n เป็นเลขไม่เท่าตัว - เลขคู่ต่อไปถ้า n เป็นเลขคู่. คืนจํานวนหินในแต่ละระดับในรายการ, โดยมีธาตุที่อินเด็กซ์ i เป็นตัวแทนจํานวนหินในระดับ (i+1). ตัวอย่าง: >>> make_a_pile(3) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"คุณจะได้รับสายคําที่แยกด้วยคอมมาหรือช่องว่าง หน้าที่ของคุณคือการแยกสายคําเป็นคําและคืนเรียงของคํา ตัวอย่าง: words_string ((\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"] words_string ((\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"ฟังก์ชันนี้ใช้จํานวนบวก x และ y และคืนจํานวนเต็มคู่ที่ใหญ่ที่สุดในช่วง [x, y] รวมกัน ถ้าไม่มีจํานวนดังกล่าวแล้วฟังก์ชันควรคืน -1. ตัวอย่าง: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"คุณได้รับจํานวนเต็มบวก n และ m และงานของคุณคือคํานวณค่าเฉลี่ยของจํานวนเต็มจาก n ถึง m (รวม n และ m) รอบคําตอบเป็นจํานวนเต็มที่ใกล้ที่สุดและแปลงมันเป็นไบนารี หาก n มากกว่า m, ให้ค่า -1. ตัวอย่าง: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b1111\" rounded_avg ((20, 33) => \"0b11010\" \"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"ให้รายการของจํานวนเต็มบวก x. คืนรายการที่เรียงลําดับของทุกองค์ประกอบที่ไม่มีหลักคู่ใด ๆ. หมายเหตุ: รายการที่คืนมาควรถูกเรียงลําดับโดยเพิ่มขึ้น. ตัวอย่าง: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"ให้เรียงตัวเลขเต็ม, เรียงตัวเลขเต็มที่อยู่ระหว่าง 1 และ 9 รวมกัน, ย้อนเรียงผลลัพธ์, และต่อมาแทนแต่ละหลักด้วยชื่อที่สอดคล้องจาก \"หนึ่ง\", \"สอง\", \"สาม\", \"สี่\", \"ห้า\", \"หก\", \"เจ็ด\", \"แปด\", \"เก้า\". ตัวอย่าง: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> เรียง arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> เรียงกลับ arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"แปด\", \"สี่\", \"สาม\", \"สอง\", \"สอง\", \"หนึ่ง\", \"หนึ่ง\"] ถ้าเรียงว่าง, การคืนเรียง: arr = [] return [] ถ้าเรียงมีเลขแปลกใด ๆ ละเลย: arr = [1, 1 , 55 -> arr -> [1, 1 , 55 -> arr -> [55, 1] - return ['One'] กลับ\"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"ปฏิบัติฟังก์ชัน f ที่ใช้ n เป็นพาราเมตร และคืนรายการขนาด n โดยให้ค่าขององค์ประกอบที่อินเด็กซ์ i เป็นตัวประกอบของ i หาก i เป็นคู่ หรือผลรวมของจํานวนจาก 1 ถึง i หากไม่. i เริ่มจาก 1. ตัวประกอบของ i คือการคูณจํานวนจาก 1 ถึง i (1 * 2 * ... * i) ตัวอย่าง: f (((5) == [1, 2, 6, 24, 15] \"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"ให้จํานวนเต็มบวก n, ให้ทับพลที่มีจํานวนของพาลินดรอมจํานวนเต็มคู่และพากย์ ที่อยู่ในช่วง ((1, n) รวมตัวอย่าง1: อินปุต: 3 ผลิตผล: (1, 2) คําอธิบาย: พาลินดรอมจํานวนเต็มมี 1, 2, 3 หนึ่งในนั้นเป็นพาร์ และสองในนั้นเป็นพาร์ ตัวอย่าง2: อินปุต: 12 ผลิตผล: (4, 6) คําอธิบาย: พาลินดรอมจํานวนเต็มมี 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. สี่ในนั้นเป็นพาร์ และ 6 ในนั้นเป็นพาร์ หมายเหตุ: 1. 1 <= n <= 10^3 2. ทับพลให้จํานวนของพาลินดรอมจํานวนคู่และพากย์ ตามลําดับ\"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"เขียนฟังก์ชัน count_nums ที่ใช้เรียงของจํานวนเต็ม และคืนจํานวนขององค์ประกอบที่มีผลรวมของหลัก > 0. ถ้าจํานวนเป็นลบ, แล้วหลักแรกที่ลงนามของมันจะเป็นลบ: เช่น -123 มีหลักลงนาม -1, 2, และ 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"เรามีเรียง 'arr' ของจํานวนเต็ม N arr[1], arr[2], ..., arr[N] ตัวเลขในเรียงจะถูกเรียงตามสุ่ม หน้าที่ของคุณคือการกําหนดว่าเป็นไปได้หรือไม่ที่จะจัดเรียงเรียงในลําดับที่ไม่ลดลงโดยการดําเนินการปฏิบัติการต่อไปนี้บนเรียงที่ได้รับ: คุณได้รับอนุญาตให้ดําเนินการขวาขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางข้ อมูล 0th ถ้าเป็นไปได้ที่จะได้รับเรียงเรียงโดยการดําเนินการด้านบนแล้วกลับ True หรือกลับ False ถ้าเรียงที่ได้รับจะว่างแล้วกลับ True หมายเหตุ: รายการที่ได้รับการรับประกันว่ามีองค์ประกอบที่ไม่เหมือนกัน เช่น: move_one_(ball_[3, 4, 5, 2]================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"ในปัญหานี้คุณจะใช้ฟังก์ชันที่ใช้ 2 รายการของเลข และกําหนดว่าสามารถแลกเปลี่ยนตัวประกอบระหว่างมันได้หรือไม่ เพื่อให้ lst1 เป็นรายการของตัวเลขคู่เท่านั้น ไม่มีขั้นต่ําในการแลกเปลี่ยนตัวประกอบระหว่าง lst1 และ lst2 หากสามารถแลกเปลี่ยนตัวประกอบระหว่าง lst1 และ lst2 เพื่อให้ตัวประกอบทั้งหมดของ lst1 เป็นคู่ ให้คืน \"YES\" ไม่งั้นให้คืน \"NO\" ตัวอย่าง: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\" สมมุติว่ารายการข้อมูลเข้าจะไม่ว่าง\"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"กําหนดการคัดสรรตัวอักษรเล็กแยกด้วยช่องว่าง ให้คําศัพท์ของตัวอักษรที่มีการซ้ํามากที่สุดและมีจํานวนที่ตรงกัน หากมีตัวอักษรหลายตัวมีการปรากฏเหมือนกัน ให้คําศัพท์คืนทั้งหมด ตัวอย่าง: ฮิสโตแกรม ((('a b c') == {'a': 1, 'b': 1, 'c': 1} ฮิสโตแกรม ((('a b b a') == {'a': 2, 'b': 2} ฮิสโตแกรม ((('a b c a b') == {'a': 2, 'b': 2} ฮิสโตแกรม ((('b b a') == {'b 4}': ฮิสโตแกรม (((')) == {} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"การทํางาน เราได้รับสองสาย s และ c, คุณจะต้องลบตัวอักษรทั้งหมดใน s ที่เท่ากับตัวอักษรใด ๆ ใน c แล้วตรวจสอบว่าผลลัพธ์สายเป็น palindrome. สตริงเรียกว่า palindrome ถ้ามันอ่านเหมือนไปข้างหน้าและกลับข้างหลัง. คุณควรคืน tuple ที่มีผลลัพธ์สายและ True/False สําหรับการตรวจสอบ. ตัวอย่างสําหรับ s = \"abcde\", c = \"ae\", ผลลัพธ์ควรจะเป็น ('bcd', False) สําหรับ s = \"abcdef\", c = \"b\" ผลลัพธ์ควรจะเป็น ('acdef', False) สําหรับ s = \"abcdedcba\", c = \"ab\", ผลลัพธ์ควรจะเป็น ('cdedc', True)\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"ให้รายการของสตริง, ที่สตริงแต่ละตัวประกอบด้วยหลักเพียงตัวเลข, ให้รายการ. แต่ละองค์ประกอบ i ของผลผลิตควรจะเป็น \"จํานวนขององค์ประกอบครางในสตริง i ของการเข้า. \" ที่ i ทั้งหมดควรถูกแทนด้วยจํานวนของหลักครางในสตริง i ของการเข้า. >>> odd_count['1234567']) [\"จํานวนขององค์ประกอบคราง 4n สตริง 4 ของ 4nput.\"] >>> odd_count['3',\"111111\"]) [\"จํานวนขององค์ประกอบคราง 1n สตริง 1 ของ 1nput. \", \"จํานวนองค์ประกอบคราง 8n สตริง 8 ของ 8nput. \"]\"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"ให้เรียงของจํานวนเต็ม n, หาผลรวมขั้นต่ําของทุกการไม่ว่างของ n. ตัวอย่าง minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"คุณได้รับกรีดสี่เหลี่ยมของบ่อน้ํา. แต่ละแถวแสดงให้เห็นถึงบ่อน้ําเดียว, และแต่ละ 1 ในแถวแสดงให้เห็นถึงหน่วยเดียวของน้ํา. แต่ละบ่อน้ํามีถังที่ตรงกันที่สามารถใช้ในการสกัดน้ําจากมัน, และถังทั้งหมดมีจุลภาพเดียวกัน. งานของคุณคือการใช้ถังที่จะว่างบ่อน้ํา. ผลิตจํานวนครั้งที่คุณต้องการที่จะลดถัง. ตัวอย่าง1: อุปกรณ์: กริด: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 ผลิต: 6 ตัวอย่าง2: อุปกรณ์: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1,1]] bucket_capacity: 2 ผลิต: 5 ตัวอย่าง3: [[:0,0,0], [0,0,0]] bucket_capacity: 5 ผลิต: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"ในคัตานี้, คุณจะต้องเรียงเรียงเรียงของจํานวนเต็มที่ไม่ลบตามจํานวนหนึ่งในตัวแทนไบนารีของพวกเขาในลําดับเพิ่มขึ้น สําหรับจํานวนหนึ่งที่เหมือนกัน, เรียงตามค่าทศนิยม. มันต้องถูกนําไปใช้เช่นนี้: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"ถ้า string s และ natural number n ให้คุณได้รับภาระการดําเนินการฟังก์ชันที่คืนรายการของคําทั้งหมดจาก string s ที่มีเสียงสะกดตรง n เพื่อให้คําเหล่านี้ปรากฏใน string s หาก string s ไม่มีเสียงแล้วฟังก์ชันควรคืนรายการที่ว่างไว้ ข้อสังเกต: คุณอาจสมมุติว่า string ที่ใส่มีแต่ตัวอักษรและช่องว่าง ตัวอย่าง: select_words (((\"Mary had a little lamb\", 4) ==> [\"little\"] select_words (((\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"] select_words\" (((simple white space\", 2) ==> [] select_words (((\"Hello world\", 4) ==> [\"world\"] select_words (((\"Uncle sam\", 3) ==> [\"Uncle\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"คุณได้รับคําหนึ่ง. งานของคุณคือหาเสียงสัญชาติที่ใกล้ที่สุดที่อยู่ระหว่างเสียงสัญชาติสองจากด้านขวาของคํา ( case sensitive). เสียงสัญชาติในตอนต้นและตอนจบไม่ได้นับ. คืนสายว่างถ้าคุณไม่พบเสียงสัญชาติใด ๆ ที่ตรงกับเงื่อนไขข้างต้น. คุณอาจคิดว่าสายที่ให้มีเพียงตัวอักษรภาษาอังกฤษเท่านั้น. ตัวอย่าง: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''คุณได้รับรายการของสองสาย, ทั้งสองสายประกอบด้วยลูกกรงเปิด '(' หรือลูกกรงปิด ') 'เท่านั้น. งานของคุณคือการตรวจสอบว่าเป็นไปได้ที่จะผูกสายทั้งสองในลําดับใด ๆ, ที่ผลลัพธ์ของสายจะดี. สาย S ถือว่าดีถ้าและเพียงแต่ถ้าลูกกรงทั้งหมดใน S มีความสมดุล. ตัวอย่าง: สาย '((()) 'ดี, ในขณะที่สาย '()) 'ไม่. กลับ 'ใช่' ถ้ามีวิธีที่จะทําให้สายที่ดี, และกลับ 'ไม่' อย่างอื่น. ตัวอย่าง: match_parens[('() ', ') ']) == 'Yes' match_parens[(') ', ') ']) == 'No' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"ให้เรียงเรียงของจํานวนเต็ม arr และจํานวนเต็มบวก k, ให้รายการที่เรียงลําดับความยาว k กับจํานวน k สูงสุดใน arr. ตัวอย่าง1: อินพุต: arr = [-3, -4, 5], k = 3 ผลิต: [-4, -3, 5] ตัวอย่าง2: อินพุต: arr = [4, -4, 4], k = 2 ผลิต: [4, 4] ตัวอย่าง3: อินพุต: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 ผลิต: [2] หมายเหตุ: 1.ความยาวของเรียงจะอยู่ในช่วง [1, 1000]. 2.องค์ประกอบในเรียงจะอยู่ในช่วง [-1000, 1000]. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"ให้รายการจํานวนเต็มที่ไม่ว่าง, คืนผลรวมขององค์ประกอบประเภทประเภทที่อยู่ในตําแหน่งคู่ ตัวอย่างคําตอบ (([5, 8, 7, 1]) ==> 12 คําตอบ (([3, 3, 3, 3, 3]) ==> 9 คําตอบ (([30, 13, 24, 321]) ==> 0 \"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"ให้เรียงจํานวนเต็ม arr และจํานวนเต็ม k ที่ไม่ใช่ว่าง ให้ผลรวมขององค์ประกอบที่มีเลขสองหลักจากองค์ประกอบ k ตัวแรกของ arr ตัวอย่าง: อินพุต: arr = [111,21,3,4000,5,6,7,8,9], k = 4 ผลิต: 24 # ผลรวมของ 21 + 3 ข้อจํากัด: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"การคาดเดาของคอลลาตซ์ (Collatz conjecture) เป็นการคาดเดาในคณิตศาสตร์ที่เกี่ยวกับลําดับที่กําหนดไว้ดังนี้: เริ่มต้นด้วยจํานวนเต็มบวก n ใด ๆ แล้วแต่ละเทอมจะถูกหาจากเทอมก่อนหน้านี้ดังนี้: หากเทอมก่อนหน้าเป็นคู่, เทอมต่อไปจะเป็นครึ่งหนึ่งของเทอมก่อนหน้า หากเทอมก่อนหน้าเป็นคราวก็เป็น 3 เท่าเทอมก่อนหน้าบวก 1.\"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"คุณต้องเขียนฟังก์ชันที่ตรวจสอบความถูกต้องของเส้นประจําวันที่กําหนด และคืน True หากวันที่ถูกต้อง ไม่ถูกต้อง. วันที่ถูกต้องถ้ามีกฎทั้งหมดต่อไปนี้: 1. สายวันที่ไม่ได้ว่าง. 2. จํานวนวันไม่น้อยกว่า 1 หรือมากกว่า 31 วันสําหรับเดือน 1,3,5,7,8,10,12. และจํานวนวันไม่น้อยกว่า 1 หรือมากกว่า 30 วันสําหรับเดือน 4,6,9,11. และจํานวนวันไม่น้อยกว่า 1 หรือมากกว่า 29 สําหรับเดือน 2. 3. เดือนไม่ควรน้อยกว่า 1 หรือมากกว่า 12. 4. วันที่ควรอยู่ในรูปแบบ: mm-dd-yyyy เช่น: valid_date (('03-11-2000') => true_date (('15-01-2012') => false_date (('04-01-2040') => false_date (('06-04-2020') => true_date (('06/04/2020') => false\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''ให้คําจํานวนหนึ่ง, คืนรายการคําที่แยกด้วยช่องว่าง, ถ้าไม่มีช่องว่างในข้อความ คุณควรแยกด้วยคอมมา ',' ถ้าไม่มีคอมมา คุณควรคืนจํานวนตัวอักษรเล็กๆ ด้วยลําดับไม่เหมือนกันในอัลฟาเบท, ord('a') = 0, ord'(b') = 1, ... ord('z') = 25 ตัวอย่าง split_words ((\"Hello world!\") â -> [\"Hello\", \"world!\"] split_words ((\"Hello,world!\") â -> [\"Hello\", \"world!\" split_words\")'''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''ให้รายการของตัวเลข, คืนไม่ว่าพวกเขาจะเรียงลําดับขึ้นไป. ถ้ารายการมีมากกว่า 1 ฉบับของจํานวนเดียวกัน, คืน False. สมมุติว่าไม่มีจํานวนลบและเพียงจํานวนเต็ม. ตัวอย่าง is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 2, 3, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) -> False is_sorted (([1, 2, 2, 3, 3, 3, 4]) -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"คุณได้รับช่วงสองช่วง, โดยช่วงแต่ละช่วงเป็นจํานวนทั้งคู่. ตัวอย่างเช่น, ช่วง = (เริ่มต้น, จบ) = (1, 2). ช่วงที่ได้รับการปิดซึ่งหมายถึงว่าช่วง (เริ่มต้น, จบ) รวมทั้งเริ่มต้นและสิ้นสุด. สําหรับช่วงที่ได้รับการให้, มันสมมุติว่าเริ่มต้นของมันน้อยกว่าหรือเท่ากับปลายของมัน. งานของคุณคือการกําหนดว่าความยาวของตัดของสองช่วงนี้เป็นจํานวนหลัก. ตัวอย่างเช่น, การตัดของช่วง (1, 3), (2, 4) คือ (2, 3) ซึ่งความยาวของมันคือ 1, ซึ่งไม่ใช่จํานวนหลัก. ถ้าความยาวของตัดเป็นจํานวนหลัก, กลับ \"ใช่\", หรือไม่, กลับ \"ไม่\". ถ้าสองช่วงไม่ตัดกัน, กลับ \"ไม่\". [input/output] ตัวอย่าง: ช่วง(((1, 2), (2, 3) ==> \"ตัด-1,((1), 4) ==> \"ตัด\", (0, \"NO\", 5-1,((5) ==> \"ES\", (-))\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"คุณได้รับเรียงของจํานวนเต็มและคุณต้องคืนผลรวมของขนาดของจํานวนเต็มคูณกับผลผลคูณของทุกตัวอย่างของแต่ละตัวเลขในเรียง ซึ่งแสดงด้วย 1, -1 หรือ 0 หมายเหตุ: return ไม่มีสําหรับเรียงว่าง ตัวอย่าง: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == ไม่มี\"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"ให้กรีดที่มี N แถวและ N คอลัมน์ (N >= 2) และจํานวนเต็มบวก k, แต่ละเซลล์ของกรีดมีค่า. ทุกจํานวนเต็มในช่วง [1, N * N] รวมไปถึงปรากฏอยู่อย่างถูกต้องครั้งเดียวในเซลล์ของกรีด. คุณจะต้องหาเส้นทางขั้นต่ําความยาว k ในกรีด. คุณสามารถเริ่มจากเซลล์ใด ๆ, และในแต่ละขั้นตอนคุณสามารถย้ายไปยังเซลล์เพื่อนบ้านใด ๆ, ในคําอื่น ๆ, คุณสามารถไปยังเซลล์ที่แบ่งขอบกับเซลล์ปัจจุบันของคุณ. กรุณาสังเกตว่าเส้นทางความยาว k หมายถึงการเยี่ยมชมเซลล์อย่างถูกต้อง k (ไม่จําเป็นต้องแตกต่างกัน). คุณไม่สามารถออกจากกรีด. เส้นทาง A (ความยาว k) ถือว่าน้อยกว่าเส้นทาง B (ความยาว k) หากหลังจากทํารายการที่กําหนดของค่าบนเซลล์ที่ผ่าน A และ B (ขอเรียกมันว่า l_st และ l_Ast), l_stB กลับ, l_stA ภาษาภาษาลักษณะน้อยกว่า l_stB, ในคําอื่น ๆ, คุณสามารถเริ่มจากเซลล์ใด ๆ และในแต่ละขั้นตอนคุณสามารถย้ายไปที่เซลล์เพื่อนบ้าน, โดยวิธีอื่น ๆ คุณสามารถย้ายไปที่เซลล์ใด ๆ ที่มีขอบริ่งขอบที่เหมือนกันกับขอบด้วยขอบด้วยขอบขอบขอบ (ไม่จําเป็นต้องใช้ขอบขอบขอบขอบขอบขอบขอบขอบขอบ) กรุ้อกว่าเส้นทางความยาว k (ไม่เกิน k) คุณไม่สามารถไปนอกกรีด่านที่ตรงกับกรีด A (ไม่เกิน 1 กร่องขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบข\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"ทุกคนรู้จักลําดับฟิโบนาคซี่ มันถูกศึกษาอย่างลึกซึ้งโดยนักคณิตศาสตร์ในสองสามศตวรรษที่ผ่านมา อย่างไรก็ตามสิ่งที่คนไม่ทราบคือลําดับทริโบนาคซี่ ลําดับทริโบนาคซี่ถูกกําหนดโดยการซ้ําซ้ํา: tri(1) = 3 tri(n) = 1 + n / 2 ถ้า n เป็นคู่. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ถ้า n เป็นคณิต. ตัวอย่าง: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 คุณได้รับจํานวนเต็มที่ไม่ลบ n, คุณจะต้องคืนรายการของจํานวนแรก n + 1 ของลําดับทริโบนาคซี่ ตัวอย่าง: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"ให้จํานวนเต็มบวก n, คืนผลคูณของหลักไม่เท่าตัว. คืน 0 หากหลักทั้งหมดเป็นคู่. ตัวอย่าง:หลัก(1) == 1หลัก(4) == 0หลัก(235) == 15 \"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''สร้างฟังก์ชันที่ใช้สายคูณเป็นอินพุต ซึ่งมีแค่กรอบสี่เหลี่ยม. ฟังก์ชันควรคืนค่า True ถ้าและเพียงแต่มีรุ่นย่อยของกรอบสี่เหลี่ยมที่ใช้ได้ โดยมีกรอบสี่เหลี่ยมอย่างน้อยหนึ่งในรุ่นย่อยที่ซ้อนกัน. is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[]]') â -> True is_nested'[[]]]]]]]]]]'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"คุณได้รับรายการของตัวเลข คุณจําเป็นต้องคืนผลรวมของจํานวนที่กําลังสองในรายการที่ได้รับ การรอบแต่ละองค์ประกอบในรายการไปยัง int บน ((เพดาน) ก่อน ตัวอย่าง: สําหรับ lst = [1,2,3] ผลผลิตควรจะเป็น 14 สําหรับ lst = [1,4,9] ผลผลิตควรจะเป็น 98 สําหรับ lst = [1,3,5,7] ผลผลิตควรจะเป็น 84 สําหรับ lst = [1.4,4.2,0] ผลผลิตควรจะเป็น 29 สําหรับ lst = [-2.4,1,1] ผลผลิตควรจะเป็น 6 \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''สร้างฟังก์ชันที่คืน True หากตัวอักษรสุดท้ายของสตริงที่ให้การเป็นตัวอักษรอักษรและไม่ใช่ส่วนหนึ่งของคํา และ False ถ้าไม่เช่นนั้น. หมายเหตุ: \"คํา\" เป็นกลุ่มตัวอักษรที่แยกด้วยช่องว่าง ตัวอย่าง: check_if_last_char_is_a_letter ((\"apple pie\") â -> False check_if_last_char_is_a_letter ((\"apple pi e\") â -> True check_if_last_char_is_a_letter ((\"apple pi e\") â -> False check_if_last_char_is_a_letter\" ((\") â -> False '''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"สร้างฟังก์ชันที่คืนดัชนีที่ใหญ่ที่สุดขององค์ประกอบที่ไม่ใหญ่หรือเท่ากับองค์ประกอบที่อยู่เบื้องหน้ามันโดยตรง หากไม่มีองค์ประกอบดังกล่าวแล้วคืน -1. แอรเรย์ที่ได้รับจะไม่มีค่าซ้ําตัวอย่าง: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''สร้างฟังก์ชันที่คืนทับเปิ้ล (a, b), โดยที่ 'a' เป็นจํานวนเต็มลบที่ใหญ่ที่สุด, และ 'b' เป็นจํานวนเต็มบวกที่เล็กที่สุดในรายการ. หากไม่มีจํานวนเต็มบวกหรือลบ, ให้คืนเป็น None. ตัวอย่าง: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"สร้างฟังก์ชันที่ใช้จํานวนเต็ม, floats, หรือ string ที่แสดงตัวเลขจริง และคืนตัวแปรที่ใหญ่กว่าในตัวแปรประเภทที่กําหนดไว้ หากค่าเท่ากัน ก็คืนค่า None หมายเหตุ: หากตัวเลขจริงถูกแสดงเป็น string จุดเคลื่อนไหวอาจเป็น . หรือ , compare_one(1, 2.5) â -> 2.5 compare_one(1, \"2,3\") â -> \"2,3\" compare_one(\"5,1\", \"6\") â -> \"6\" compare_one(\"1\", 1) â -> None \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"ประเมินว่าจํานวน n สามารถเขียนได้เป็นผลรวมของจํานวนคู่บวก 4 ตัวอย่าง is_equal_to_sum_even ((4) == ผิด = is_equal_to_sum_even ((6) == ผิด = is_equal_to_sum_even ((8) == จริง \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"การนิยามตัวประกอบบราซิลคือ: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! โดย n > 0 ตัวอย่าง: >>> special_factorial ((4) 288 ฟังก์ชันนี้จะรับจํานวนเต็มเป็นอินพุต และควรคืนตัวประกอบพิเศษของจํานวนเต็มนี้\"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_ ตัวอย่างที่ 3องสายการเขียนแทนที่ช่องว่างทั้งหมดด้วยเครื่องย่อ และถ้าสายการเขียนมีช่องว่างติดต่อกันมากกว่า 2 ตัว, แทนที่ว่างติดต่อกันทั้งหมดด้วย - fix_spaces (((\"ตัวอย่าง\") == \"ตัวอย่าง\" fix_spaces (((\"ตัวอย่าง1\") == \"ตัวอย่าง_1\" fix_spaces (((\"ตัวอย่าง2\") == \"_ตัวอย่าง_2\" fix_spaces (((\"ตัวอย่าง 3\") == \"_ตัวอย่าง-3\" \"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"สร้างฟังก์ชันที่ใช้สตริงแทนชื่อไฟล์ และคืน 'Yes' หากชื่อไฟล์เป็นจริง และคืน 'No' หากไม่เป็นจริง ชื่อไฟล์จะถือว่าเป็นจริง หากและเพียงแต่ถ้าเงื่อนไขทั้งหมดต่อไปนี้ถูกต้อง - ไม่ควรมีมากกว่าสามหลัก ('0'-'9') ในชื่อไฟล์ - ชื่อไฟล์มีจุด '.' - สตริงรองก่อนจุดไม่ควรว่าง และเริ่มด้วยตัวอักษรจากอัลฟาเปตลาติน ('a'-'z' และ 'A'Z'). - สตริงรองหลังจากจุดควรเป็นหนึ่งในตัวอักษรเหล่านี้: ['txt', 'exe', 'lld'] ตัวอย่าง: file_name_check\"(example.txt\") # => 'Yes' file_name_check\"(example.dll1\") => 'No' # (ชื่อควรเริ่มด้วยตัวอัลฟาเปตลาติน)\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\"ฟังก์ชันนี้จะใช้รายการของจํานวนเต็ม สําหรับทุกรายการในรายการนี้ฟังก์ชันจะยกกําลังสองรายการจํานวนเต็ม หากดัชนีของมันเป็นคูณของ 3 และจะยกกําลังลูกสามรายการจํานวนเต็ม หากดัชนีของมันเป็นคูณของ 4 และไม่ใช่คูณของ 3 ฟังก์ชันนี้จะไม่เปลี่ยนแปลงรายการในรายการที่มีดัชนีไม่เป็นคูณของ 3 หรือ 4 ฟังก์ชันนี้จะคืนผลรวมของรายการทั้งหมด ตัวอย่าง: สําหรับ lst = [1,2,3] ผลผลผลิตควรเป็น 6 สําหรับ lst = [] ผลผลผลิตควรเป็น 0 สําหรับ lst = [-1,-5,2,-1,-5] ผลผลิตควรเป็น -126 \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"คุณได้รับสายที่เป็นตัวแทนของประโยค ประโยคนั้นมีคําบางคําแยกด้วยช่องว่าง และคุณต้องคืนสายที่มีคําจากประโยคเดิม ซึ่งความยาวของมันเป็นจํานวนหลัก ลําดับคําในสายใหม่ควรเป็นเหมือนกันกับตัวเดิม ตัวอย่าง1: อินพุต: ประโยค = \"นี่คือการทดสอบ\" ผลิต: \"คือ\" ตัวอย่าง2: อินพุต: ประโยค = \"ขอไปว่ายน้ํา\" ผลิต: \"ไปสําหรับ\" ข้อจํากัด: * 1 <= len(ประโยค) <= 100 * ประโยคมีตัวอักษรเท่านั้น \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"การทํางานของคุณคือการนําฟังก์ชันที่จะทําให้คําว่า x * n ง่ายขึ้นฟังก์ชันจะคืน True ถ้า x * n เป็นจํานวนทั้งตัว และ False ถ้าไม่อย่างนั้น ทั้ง x และ n เป็นตัวแทนของสัดส่วนและมีรูปแบบต่อไปนี้, <numerator>/<denominator> ซึ่งทั้งตัวเศษและตัวส่วนเป็นจํานวนทั้งตัวบวก คุณสามารถสมมุติว่า x, และ n เป็นเศษส่วนที่ใช้ได้ และไม่มีศูนย์เป็นตัวส่วน. simplify \" 1/5\", \"5/1\") = True simplify \" 1/6\", \"2/1\") = False simplify \" 7/10\", \"10/2\") = False \"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"เขียนฟังก์ชันที่จัดลําดับรายการจํานวนเต็มตามลําดับขึ้นไปตามผลรวมของหลักของตัวเลขที่ให้ไว้. หมายเหตุ: หากมีรายการหลายรายการที่มีผลรวมของหลักที่เหมือนกัน, ให้เรียงตามดัชนีในรายการเดิม. ตัวอย่าง: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"เขียนฟังก์ชันที่ใช้เรียงตัวเลขเป็นอินพุต และคืนจํานวนองค์ประกอบในเรียงที่ใหญ่กว่า 10 และทั้งหลักแรกและหลักสุดท้ายของเลขเป็นเลขคี่ (1, 3, 5, 7, 9) ตัวอย่าง: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"คุณได้รับจํานวนเต็มบวก n. คุณต้องสร้างเรียงจํานวนเต็ม a ความยาว n. สําหรับแต่ละ i (1 ‰¤ i ‰¤ n), ค่าของ a[i] = i * i - i + 1. คืนจํานวนของ triples (a[i], a[j], a[k]) ของ a ที่ i < j < k, และ a[i] + a[j] + a[k] เป็นคูณของ 3. ตัวอย่าง: อินพุต: n = 5 ผลิต: 1 คําอธิบาย: a = [1, 3, 7, 13, 21] ค่า triples เท่านั้นคือ (1, 7, 13).\"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''มีดาวเคราะห์ 8 ดวงในระบบสุริยจักรของเรา ดาวเคราะห์ที่ใกล้ดวงอาทิตย์ที่สุดคือพฤกษ์ ดาวเวนัสที่ใกล้ดวงอาทิตย์ที่สุดแล้วเป็นโลก ดาวอังคาร ดาวพฤกษ์ ดาวเสาร์ ดาวอูเรนัส ดาวนพฤกษ์ เขียนฟังก์ชันที่ใช้ชื่อดาวเคราะห์ 2 ดวงเป็นสายดาวเคราะห์ 1 และดาวเคราะห์ 2 ฟังก์ชันนี้ควรคืนทับพลที่มีดาวเคราะห์ทั้งหมดที่มีวงโคจรอยู่ระหว่างวงโคจรดาวเคราะห์ 1 และวงโคจรดาวเคราะห์ 2 โดยเรียงตามความใกล้เคียงกับดวงอาทิตย์ ฟังก์ชันนี้ควรคืนทับพลที่ว่างเปล่าถ้าดาวเคราะห์ 1 หรือดาวเคราะห์ 2 ไม่ถูกต้องเป็นชื่อดาวเคราะห์ ตัวอย่าง bf\"(ดาวเคราะห์\", \"ดาวเคราะห์\") ==> (\"ดาวเคราะห์\") bf\"(ดาวเคราะห์\", \"ดาวเคราะห์\") ==> (\"ดาวเคราะห์\", \"ดาวเคราะห์\", \"ดาวเคราะห์\", \"ดาวเคราะห์\", \"ดาวเคราะห์\")'''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"เขียนฟังก์ชันที่รับรายการของสายเป็นพาราเมทร์ ลบสายที่มีความยาวไม่เท่ากันจากมัน และคืนรายการที่ได้รับผลด้วยลําดับที่เรียงลําดับ รายการนี้เป็นรายการของสายเสมอและไม่เคยเป็นเรียงของตัวเลข และมันอาจมีซ้ํากัน การเรียงลําดับของรายการควรจะขึ้นตามความยาวของแต่ละคํา และคุณควรคืนรายการที่เรียงตามกฎนั้น ถ้าสองคํามีความยาวเท่ากัน ให้เรียงรายการเป็นลําดับอักษร ฟังก์ชันควรคืนรายการของสายในลําดับที่เรียงลําดับ คุณอาจสมมุติว่าคําทั้งหมดจะมีความยาวเท่ากัน ตัวอย่าง: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"a\", \"aaa\", \"cd\" => \"ab\", \"cd ])\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"โปรแกรมง่ายๆที่ควรคืนค่าของ x หาก n เป็นจํานวนหลัก และควรคืนค่าของ y หากไม่เช่นนั้น ตัวอย่าง: สําหรับ x_or_y ((7, 34, 12) == 34 สําหรับ x_or_y ((15, 8, 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''ให้รายการจํานวน, คืนผลรวมกําลังสองของจํานวนในรายการที่คด. ละเลยจํานวนที่ลบหรือไม่ใช่จํานวนเต็ม. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 หากรายการข้อมูลว่าง, คืนค่า 0 '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"ผมว่าทุกคนจําได้ถึงความรู้สึกนั้น เมื่อได้ทราบผลของเหตุการณ์ที่รอคอยมานานแล้ว ความรู้สึกและความคิดที่คุณมีในขณะนั้นแน่นอนว่าคุ้มที่จะบันทึกและเปรียบเทียบ คุณมีหน้าที่คือการกําหนดว่าผู้คนได้เดาผลของจํานวนการแข่งขันถูกต้องหรือไม่ คุณได้รับการจัดเรียงคะแนนและการเดาความยาวเท่ากันสองอันดับ โดยที่แต่ละดัชนีแสดงการแข่งขัน ให้คืนการจัดเรียงความยาวเท่ากันแสดงว่าการเดาแต่ละอันดับมีความห่างไกลแค่ไหน หากพวกเขาได้เดาถูกต้อง ค่าค่าคือ 0 และถ้าไม่ ค่าค่าคือความแตกต่างที่แน่นอนระหว่างการเดาและคะแนน ตัวอย่าง: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare ((([0,5,0,4,0,1,0,4]) -> [4,0,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"คุณจะได้รับชื่อของคลาส (สาย) และรายการของขยาย. ขยายจะใช้ในการโหลดคลาสเพิ่มเติมในคลาส ความแข็งแรงของขยายเป็นดังนี้: ให้ CAP เป็นจํานวนตัวอักษรใหญ่ในชื่อขยาย, และให้ SM เป็นจํานวนตัวอักษรเล็กในชื่อขยาย, ความแข็งแรงถูกให้โดยเศษส่วน CAP - SM. คุณควรหาขยายที่แข็งแรงที่สุดและคืนสายในรูปแบบนี้: ClassName.StrongestExtensionName. ถ้ามีขยายสองหรือมากกว่าที่มีความแข็งแรงเดียวกัน, คุณควรเลือกอันที่มาแรกในรายการ. ตัวอย่างเช่น, ถ้าคุณได้รับ \"Slices\" เป็นคลาสและรายการของขยาย: ['SEviviSliNGCes', 'Cheese', 'Stufed'] แล้วคุณควรคืน 'Slices.SEviSliNGCes' เนื่องจาก 'SviSliNGCes' 'mySviSliNGCes']) เป็นการขยายที่แข็งแรงที่สุด (ตัวอย่าง: 'AA_Beats' = 'StrongestExtensionName', 'AA_Class' = 'Strongest_Extension'), สําหรับ 'AA_Class' = 'Strongest_Class'\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"คุณได้รับ 2 คํา. คุณต้องคืน True หากคําที่สองหรือการหมุนของมันเป็นซับสตริงในคําแรก cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => True cycpattern_check (((\"whassup\",\"psus\") => False cycpattern_check (((\"abab\",\"baa\") => True cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => True \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"ให้จํานวนเต็ม. คืนทับเปิ้ลที่มีจํานวนหลักเป็นคู่และเป็นคด ตามลําดับ ตัวอย่าง: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"ให้จํานวนเต็มบวก, หาตัวเลขโรมันที่เทียบเท่าในรูปของสตริง, และคืนมันในตัวเล็ก: 1 <= num <= 1000 ตัวอย่าง: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''ให้ความยาวของสามด้านของสามเหลี่ยม. คืน True ถ้าสามด้านเป็นสามเหลี่ยมมุมฉาก, False ถ้าไม่เป็นเช่นนั้น. สามเหลี่ยมมุมฉากคือสามเหลี่ยมที่มีมุมหนึ่งเป็นมุมฉากหรือ 90 องศา. ตัวอย่าง: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"เขียนฟังก์ชันที่รับรายการของสายเสียง รายการมีคําต่างกัน กลับคําที่มีจํานวนมากที่สุดของตัวอักษรที่ไม่เหมือนกัน ถ้าสายเสียงหลายตัวมีจํานวนมากที่สุดของตัวอักษรที่ไม่เหมือนกัน กลับคําที่มาแรกตามลําดับคําศัพท์ find_max ((([\"name\", \"of\", \"string\"]) == \"string\" find_max (([\"name\", \"enam\", \"game\"]) == \"enam\" find_max (([\"aaaaaaa\", \"bb\" , \"cc\"]) == \"\"aaaaaaa\" \"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"คุณเป็นกระต่ายหิว และคุณได้กินมะเขือเทศจํานวนหนึ่งแล้ว แต่ตอนนี้คุณต้องกินมะเขือเทศเพิ่มขึ้นเพื่อให้ครบอาหารในวันนี้ คุณควรคืนเรียงของ [ จํานวนมะเขือเทศทั้งหมดที่กินหลังจากอาหาร, จํานวนมะเขือเทศที่เหลือหลังจากอาหาร ] ถ้าไม่มีมะเขือเทศที่เหลือพอ คุณก็จะกินมะเขือเทศที่เหลือทั้งหมด แต่ยังคงหิว ตัวอย่าง: * กิน(5, 6, 10) -> [11, 4] * กิน(4, 8, 9) -> [12, 1] * กิน(1, 10, 10) -> [11, 0] * กิน(2, 11, 5) -> [7, 0] ตัวแปร: @number: จํานวนมะเขือเทศที่คุณได้กิน. @need: จํานวนมะเขือเทศที่คุณต้องการกิน. @remaining: จํานวนมะเขือเทศที่เหลือในสต๊อก: * Constrain: 0= <= 0 * 1000 <= 0 * จํานวนมะเขือเทศที่เหลือในสต๊อก: 0 = <= 1000 <= 0\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"การปฏิบัติงานพีชคณิตฐาน: การบวก (+) การลบ (-)) การคูณ (*) การแบ่งชั้น (-)) การยกกําลัง (**) ตัวอย่าง: operator['+', '*', '-'] array = [2, 3, 4, 5] result = 2 + 3 * 4 - 5 => result = 9 หมายเหตุ: ความยาวของรายการผู้ปฏิบัติงานเท่ากับความยาวของรายการผู้ปฏิบัติงาน ลบหนึ่ง ตัวประกอบคือรายการของจํานวนเต็มที่ไม่ลบ ตัวประกอบมีผู้ปฏิบัติงานอย่างน้อย 1 ตัวประกอบและรายการผู้ปฏิบัติงานมีผู้ปฏิบัติงานอย่างน้อย 2 ตัวประกอบ\"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"คุณได้รับ string s. ถ้า s[i] เป็นตัวอักษร, เปลี่ยนตัวเลขจากล่างไปบน หรือตรงข้าม, ไม่งั้นก็เก็บมันไว้. ถ้า string ไม่มีตัวอักษร, เปลี่ยน string. ฟังก์ชันควรคืน string ผลลัพธ์. ตัวอย่าง solve ((\"1234\") = \"4321\" solve ((\"ab\") = \"AB\" solve ((\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"ถ้า string 'text' มีให้แล้ว ให้ string คู่เทียบ md5 ของมัน ถ้า 'text' เป็น string ไม่มีอะไร ให้ None >>> string_to_md5 (('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "tha_Thai",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"ให้เลขเต็มบวก a และ b สองตัว, คืนเลขคู่ระหว่าง a และ b, ตามลําดับเพิ่มขึ้น. ตัวอย่าง: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]