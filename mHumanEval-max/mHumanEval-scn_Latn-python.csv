task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,scn_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Verificate se in data lista di numeri, ci sò dui numeri più vicini l'unu à l'altru chè u limitu datu. Esempiu: >>> hà_elementi_vicinati (([1.0, 2.0, 3.0], 0.5) Falsu >>> hà_elementi_vicinati (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) Veru """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,scn_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""La funzioni è na stringa chi cunteni gruppi multipli di parentesi annidati. Lu tò scopu è di separari sti gruppi nta stringi siparati e di riturnari la lista di chiddi. Li gruppi siparati sunnu bilanciati (ogni parentesi aperta è chiusa) e nun annidati l'unu dintra l'autru Ignorari ogni spazziu ntâ stringa di input. Esempiu: >>> separate_paren_groups' ((( ) (() ((( ) ) ) ' [' (()) ', '(()) ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,scn_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Datu nu nùmmaru a virtù fluttuanti pusitivu, pò èssiri scumpostu 'n parti nteri (u nùmmaru cchiù granni è cchiù nicu di lu nùmmaru datu) e decimali (la parti ristanti è sempri cchiù nica di 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,scn_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Vi veni datu na lista di operazioni di depòsitu e ritiru nta nu cuntu bancariu ca accuminza cu nu saldu. Lu vostru compitu è di scupirari si a n'eventu lu saldu di nu cuntu cala sutta a nu, e a ddu puntu la funzioni avissi a riturnari True. Altrimenti avissi a riturnari False. Esempiu: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,scn_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Pi na data lista di numari d'intrata, calculi la deviatazzioni assoluta media ntô centru di stu gruppu di dati. La deviatazzioni assoluta media è la diffirenza assoluta media tra ogni elementu e nu puntu cintrali (media nta stu casu): MAD = media. x - x_mean. Esempiu: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,scn_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Inserisci un numeru ""delimitatore"" trà ogni dui elementi consecutivi di a lista di input `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,scn_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""A funzioni è na stringa rapprisintata di gruppi multipli di parentici annidati siparati di spazzi. pi ogni gruppu, si usci lu livellu cchiù funnu di annidamentu di parentici. Esempiu (() (()) havi almenu dui livelli di annidamentu mentri ((())) havi tri.""""""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,scn_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Filtrà na lista di input di stringhi sulu pi chiddi ca cuntèninu na data suttistringa >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,scn_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Pi na data lista di nùmmari interi, riturnari na tupla chi cunsisti di na summa e di nu pruduttu di tutti li nùmmari interi di na lista. La summa vacanti avissi a èssiri uguali a 0 e lu pruduttu vacanti avissi a èssiri uguali a 1. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,scn_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Da na data lista di nùmmari interi, si genera na lista di l'elementi màsimi di rotazzioni truvati nzinu a nu datu mumentu ntâ sequenza. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,scn_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Trova lu palindromu cchiù curtu ca accumincia cu na stringa furnuta. L'algoritmu è semplici: - Trova lu postfix cchiù longu di na stringa furnata ca è nu palindromu. - Aggiungi a la fini di la stringa lu riversu di nu prefissu stringa ca accumincia prima di lu suffissu palindromu. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('catac') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Pruvate se data stringa hè un palindromu""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,scn_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""L'input sunnu dui stringhi a e b ca custituiscinu sulu di 1 e 0. Fate XOR binariu supra sti input e riturnate puru lu risultatu comu na stringha.""""""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,scn_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Da lista di stringhe, ritorna la cchiù longa. Torna la prima se ci sunnu multiple stringhe di la stissa lunghizza. Torna Nulla se la lista di input è vacanti. >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,scn_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Ritorna nu maggiuri cumuni divisori di dui numari interi a e b >>> maggiuri_cumuni_divisori ((3, 5) 1 >>> maggiuri_cumuni_divisori ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,scn_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Restituisci l'elencu di tutti i prefissi da u più cortu à u più longu di a stringa d'ingressu >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,scn_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Ritorna na stringa chi cunteni nummari dilimitati di spazziu chi cumincianu da 0 nzinu a n nclusivi. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,scn_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Datu na stringa, scuprì quantu caratteri distinti (indipendentemente da casu) è custituitu di >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,scn_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Input to this function is a string representing musical notes in a special ASCII format. Your is to parse string list of integers corresponding to many beats does. Here is a legend: 'o' note, lasts four beats 'o 112' - half note, lasts two beats 'o 112' - quater note, lasts one beat >>> parse_music. 'o . o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,scn_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Trova quantu voti na data sutta-stringa pò èssiri attruvata ntâ stringa urigginaria. Cuntari li casi suprapposti. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,scn_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""La stringa di nummari è na stringa di nummari dilimitati di spazziu da 'zero' a 'nòvu'. Li scelte validi sunnu 'zero', 'unu', 'dui', 'tre', 'quattru', 'cinque', 'sei', 'sette', 'ottu' e 'nòvu'. Ritorna la stringa cu nummari ordinati da lu cchiù nicu a lu cchiù granni >>> sort_numbers (('tre unu cincu') 'un tri cincu' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,scn_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Da na lista di numari (di lunghizza armenu dui) si selezziunanu e si riturnanu dui ca sunnu li cchiù vicini l'unu a l'àutru e li riturnanu in ordine (numaru cchiù nicu, numaru cchiù granni). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,scn_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Data na lista di numari (di armenu dui elementi), appricà na trasfurmazzioni liniari a chista lista, accussì ca lu nùmmaru cchiù nicu addiventa 0 e lu cchiù granni addiventa 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,scn_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filtru data lista di ogni valuri di Python sulu pi nùmmura interi >>> filter_integers(['a', 3.14, 5]) [5] >>> filter_integers([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,scn_Latn,python,"

def strlen(string: str) -> int:
    """"""A lunghezza di ritornu di a stringa data >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,scn_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Pi nu datu nùmmuru n, truvamu lu nùmmuru cchiù granni ca si dividi n pari, cchiù picca di n >>> largest_divisor ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,scn_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Arritorna la lista dî fattura primi di nu nùmmaru nternu datu, urdinati da lu cchiù nicu a lu cchiù granni. Ogni fatturi avissi a èssiri nummiru di voti currispunnenti a quantu voti appari nta la fatturazzioni. Lu nùmmuru di input avissi a èssiri uguali ô pruduttu di tutti li fattura >>> fatturazzioni(8) [2, 2, 2] >>> fatturazzioni(25) [5, 5] >>> fatturazzioni(70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,scn_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Da na lista di nùmmari nteri, scinni tutti l'elementi ca si trovanu cchiù di na vota. Manteniri l'òrdini di l'elementi ca sunnu stati lassati uguali a chiddu di l'input. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,scn_Latn,python,"

def flip_case(string: str) -> str:
    """"""Pi na data stringa, trasforma li caratteri minusculi a maiusculi e maiusculi a minusculi. >>> flip_case ((('Hello') 'HELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,scn_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Lista di stringhi cuncatenati nta na sula stringha >>> cuncatenati (([]) '' >>> cuncatenati ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,scn_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Filtrari na lista di strings ca accumincia cu nu prefissu. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,scn_Latn,python,"

def get_positive(l: list):
    """"""Rinniri sulu li nummari pusitivi dâ lista. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,scn_Latn,python,"

def is_prime(n):
    """"""Ritorna veru si nu nùmmaru datu è primu, e falsu altrimenti. >>> è_primu (a) Falsu >>> è_primu (a) 101) Veru >>> è_primu (a) 11 Veru >>> è_primu (a) 13441) Veru >>> è_primu (a) 61) Veru >>> è_primu (a) 4) Falsu >>> è_primu (a) Falsu """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,scn_Latn,python,"import math


def poly(xs: list, x: float):
    """"""xs sunnu cuefficienti di nu pulinomiu. find_zero trova x tali ca poly(x) = 0. find_zero torna sulu sulu puntu zeru, puru siddu ci sunnu tanti. Inoltre, find_zero pigghia sulu l'elencu xs avennu nummuru pari di cuefficienti e lu cchiù granni cuefficienti non zeru comu si garantisci na suluzzioni. >>> round(find_zero[(1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 1.0 """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Valuta nu pulinomiu cu cuefficienti xs ô puntu x. ritorna xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,scn_Latn,python,"

def sort_third(l: list):
    """"""Sta funzioni pigghia na lista l e torna na lista l' accussì ca l' è idinticu a l ntê indici ca nun sunnu divisibili pi tri, mentri li valuri di l'indici ca sunnu divisibili pi tri sunnu uguali a li valuri di l'indici currispunnenti, ma ordinati. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,scn_Latn,python,"

def unique(l: list):
    """"""Ritorna elementi urdinati unichi in una lista >>> unichi (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,scn_Latn,python,"

def max_element(l: list):
    """"""Ritorna l'elimentu màssimu ntâ lista. >>> max_element([1, 2, 3]) 3 >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,scn_Latn,python,"

def fizz_buzz(n: int):
    """"""Ritorna lu nùmmuru di voti ca la cifra 7 appari nta n'entieri cchiù picca di n chi sunnu divisibili pi 11 o 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,scn_Latn,python,"

def sort_even(l: list):
    """"""Sta funzioni pigghia na lista l e torna na lista l' accussì ca l' è idinticu a l nta l'indici pari, mentri li valuri a l'indici pari sunnu uguali a li valuri di l'indici pari, ma ordinati. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,scn_Latn,python,"

def encode_cyclic(s: str):
    """"""pigghia comu stringa di input codificatu cu funzioni encode_cyclic. Ritorna stringa decodificata. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""ritorna stringa codificata da gruppi ciclici di trè caratteri. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,scn_Latn,python,"

def prime_fib(n: int):
    """"""prime_fib torna nu nùmmuru n-esimu ca è nu nùmmuru di Fibonacci e è puru primu. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,scn_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero pigghia na lista di nùmmari ntieri comu n'input. Veni True si ci sunnu tri elementi distinti ntâ lista ca sumanu a zeru, e False altrimenti. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,scn_Latn,python,"

def car_race_collision(n: int):
    """"""Immagina na strata ca è na linia longa e perfetta. n'autura vannu da sinistra a destra; simuluntamenti, nu gruppu di n'autura vannu da dritta a sinistra. Li dui gruppi di autura vannu assai luntani l'unu di l'àutru. Tutti l'autura si muovinu a la stissa velocità. Du' autura si dicinu ca si scontranu quannu na màchina ca si muovi da sinistra a dritta s'attrova na màchina ca si muovi da dritta a sinistra. Ma, li màchini sunnu infinitamente robusti e forti; comu risurtatu, cuntinuanu a muvirisi nta la so traggitoria comu si nun si scontrassiru. Sta funzioni fornisci lu nùmmiru di tali collisioni.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,scn_Latn,python,"

def incr_list(l: list):
    """"""Arritorna lista cu elementi incrementali di 1. >>> incr_list([1, 2, 3]) [2, 3, 4] >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,scn_Latn,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero pigghia na lista di nùmmari ntieri comu n'input. Veni True si ci sunnu dui elementi distinti ntâ lista ca sumanu a zeru, e False altrimenti. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,scn_Latn,python,"

def change_base(x: int, base: int):
    """"""Cambia la basi numerica di lu nùmmuru d'intrata x a basi. ritorna la rapprisintazzioni di stringa doppu la cunvirsioni. li numari di basi sunnu menu di 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,scn_Latn,python,"

def triangle_area(a, h):
    """"""Data la lunghizza di nu latu e l'area di ritornu cchiù granni pi nu triàngulu. >>> triàngulu_area(5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,scn_Latn,python,"

def fib4(n: int):
    """"""La siquenza numerica Fib4 è na siquenza simili a la siquenza di Fibbonacci ca è difinuta comu siguenti: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Scriviti na funzioni pi calculiari n-esimu elementu dâ siquenza numerica fib4. Nun usari la ricursioni. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,scn_Latn,python,"

def median(l: list):
    """"""Ritornu mediana di l'elementi in a lista l. >>> mediana (([3, 1, 2, 4, 5]) 3 >>> mediana (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,scn_Latn,python,"

def is_palindrome(text: str):
    """"""Verifica se data stringa è palindromu >>> is_palindromu (('') True >>> is_palindromu (('aba') True >>> is_palindromu (('aaaaa') True >>> is_palindromu (('zbcd') False """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,scn_Latn,python,"

def modp(n: int, p: int):
    """"""Ritorna 2^n modulo p (siani cuscenti di i numeri). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,scn_Latn,python,"

def encode_shift(s: str):
    """"""pigghia comu stringa di input codificatu cu la funzioni encode_shift. Ritorna stringa decodificata. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""ritorna na stringa codificata spustannu ogni caràttiri di 5 ntô alfabetu.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,scn_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels è na funzioni ca pigghia na stringa e torna na stringa senza vucali. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') ' ' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,scn_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Ritorna True si tutti li numari ntâ lista l sunnu sutta lu limiu t. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,scn_Latn,python,"

def add(x: int, y: int):
    """"""Aggiungi dui numari x e y >>> agghiungi ((2, 3) 5 >>> agghiungi ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,scn_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Verificate se due parole hanno gli stessi caratteri. >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc') Vero >>> same_chars('abcd', 'dddddddabc') Vero >>> same_chars('dddddddabc', 'abcd') Vero >>> same_chars('eabcd', 'dddddddddabc') Falso >>> same_chars('abcd', 'dddddddabddce') Falso >>> same_chars'(abcdzzzz', 'dddzzzzzzzddabc') Falso """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,scn_Latn,python,"

def fib(n: int):
    """"""Ritorna lu n-esimu nùmmuru di Fibonacci. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,scn_Latn,python,"

def correct_bracketing(brackets: str):
    """"""bracket è na stringa di ""<"" e "">"". return True si ogni bracket chi si apri havi un corrispunnenti bracket chi si chiudi. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,scn_Latn,python,"

def monotonic(l: list):
    """"""Return True is list elements are monotonically increasing or decreasing. >>> monotonic (([1, 2, 4, 20]) True >>> monotonic (([1, 20, 4, 10]) False >>> monotonic (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,scn_Latn,python,"

def common(l1: list, l2: list):
    """"""Ritorna elementi cumuni unici ordinati pi dui elenchi. >>> cumuni (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> cumuni (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,scn_Latn,python,"

def largest_prime_factor(n: int):
    """"""Ritorna lu cchiù granni fatturi primu di n. Assumi ca n > 1 e nun è un fatturi primu. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,scn_Latn,python,"

def sum_to_n(n: int):
    """"""sum_to_n è na funzioni ca addica nummari da 1 a n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,scn_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets è na stringa di ""("" e "")"". return True si ogni bracket chi si apri havi un bracket chi si chiudi. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() "") True >>> correct_bracketing("")""""""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,scn_Latn,python,"

def derivative(xs: list):
    """"""xs rapprisenta li cuefficienti di nu pulinomiu. xs[0] + xs[1] * x + xs[2] * x^2 + .... Ritorna la dirivata di stu pulinomiu nta la stissa forma. >>> derivata (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivata (([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,scn_Latn,python,"

def fibfib(n: int):
    """"""La siquenza numerica di FibFib è na siquenza simili a la siquenza di Fibbonacci ca è difinuta comu siguenti: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Scriviti na funzioni pi calcari n-esimu elementu dâ siquenza numerica di fibfib. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,scn_Latn,python,"
FIX = """"""Scrivite na funzioni vowels_count ca pigghia na stringa ca rapprisenta na parola comu input e riturna lu nùmmiru di vucali ntâ stringa. Li vucali ntô casu 'sta sò 'a', 'e', 'i', 'o', 'u'. Quì, 'y' è macari na vucali, ma sulu quannu è a la fini di na parola data. Esempiu: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Aggiungi cchiù casi di prova.""""""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,scn_Latn,python,"
def circular_shift(x, shift):
    """"""Circular move the digits of the integer x, move the digits right by shift and return the result as a string. Si shift > nummiru di digiti, riturnari i digiti inversi. >>> circular_shift(12, 1) ""21"" >>> circular_shift(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,scn_Latn,python,"
def digitSum(s):
    """"""Task Scrivi na funzioni ca pigghia na stringa comu input e torna la summa sulu dî caràttiri cchiù granni. Esempi: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,scn_Latn,python,"
def fruit_distribution(s,n):
    """"""In stu compitu, vi sarà datu una stringa chì rapprisenta un numaru di mele è aranci chì sò distribuitu in un cesti di frutta stu cesti cuntene mele, aranci, e frutti manghjo. datu la stringa chì rapprisenta u numaru tutali di l 'aranci e mele è un nùmmiru tutali chì rapprisentanu u numaru tutali di i frutti in u cesti ritornu u numaru di i frutti manghjo in u cesti. per examble: fruit_distribution""5( mele è 6 aranci"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 mele è 1 aranci"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 mele è 3 aranci"", 100) -> 100 - 2 - 3 = 95 fruit_distribution"" 100 mele è 1 aranci"",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,scn_Latn,python,"
def pluck(arr):
    """"""""Datu na matrice ca rapprisenta na ramu di n'arburu ca havi nodi nenti non-negativi lu tò compitu è di pigghiari unu di li nodi e riturnàlu. Lu nodi pigghiatu avissi a èssiri lu nodi cu lu valuri pari cchiù nicu. Si si trovanu diversi nodi cu lu stissu valuri pari cchiù nicu riturnà lu nodi ca havi l'indici cchiù nicu. Lu nodi pigghiatu avissi a èssiri riturnatu nta na lista, [smallest_value, its index] Se nun ci sunnu valuri pari o la matrice data è vacanti, riturnà []. Esempiu 1: Input: [4,2,3] Output: [2, 1] Spiegazioni: 2 havi lu valuri pari cchiù nicu, e 2 havi l'indici cchiù nicu. Esempiu 2: Input: [1,2,3] Output: [2, 1] Spiegazioni: 2 havi lu valuri pari cchiù nicu, e 2 havi l'indici pari cchiù nicu. Esempiu 3: Input: [] Output: [4:] Input: [5, 3, 4, 2] Output: 1 [0, 0] Spiegazioni: 1 havi lu nodi cchiù nicu, ma lu valuri nnicu è zero. * Esempiu 1: lu primu nodi havi li zeri, ma li valuri sunnu <= 0; * = zero.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,scn_Latn,python,"
def search(lst):
    '''Si ti duna na lista nun vacanti di nùmmura ntiguri pusitivi. Ritorna lu nùmmuru ntiguru cchiù granni ca è cchiù granni di zeru, e havi na friquenza cchiù granni o uguali ô valuri dû nùmmuru ntiguru stissu. La friquenza di nu nùmmuru ntiguru è lu nùmmuru di voti ca appari nta la lista. Si nun esisti nu valuri tali, ritorna -1. Esempi: search (([4, 1, 2, 2, 3, 1]) == 2 search (([1, 2, 2, 3, 3, 3, 4, 4]) == 3 search (([5, 5, 4, 4, 4]) == -1 '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,scn_Latn,python,"
def strange_sort_list(lst):
    '''Datu na lista di nterni, torna na lista n urdinamentu straniu. L'urdinamentu straniu, è quannu si cumincia cu lu valuri minimu, poi lu massimu dî nterni ristanti, poi lu minimu e accussì via. Esempi: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,scn_Latn,python,"
def triangle_area(a, b, c):
    '''Datu li lunghi di li tri lati di nu triàngulu. Ritorna l'aria di lu triàngulu arrotondata a 2 punti decimali si li tri lati formanu nu triàngulu validu. Altrimenti ritorna -1 Tri lati fannu nu triàngulu validu quannu la summa di qualunqui dui lati è cchiù granni di lu terzu latu. Esempiu: triàngulu_aria (a) {3, 4, 5) == 6.00 triàngulu_aria (a) {1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,scn_Latn,python,"
def will_it_fly(q,w):
    '''Scrivite una funzione chì rende True se l'ughjettu q voli, è False altrimenti. L'ughjettu q voli se hè equilibratu (hè una lista palindromica) è a somma di i so elementi hè menu o uguale à u pesu massimu pussibule w. Esempiu: will_it_fly (([1, 2], 5) â -> False # 1+2 hè menu di u pesu massimu pussibule, ma hè sbilanciatu. will_it_fly (([3, 2, 3], 1) â -> False # hè equilibratu, ma 3+2+3 hè più di u pesu massimu pussibule. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 hè menu di u pesu massimu pussibule, è hè equilibratu. will_it_fly ((([3], â 5) -> True # 3 hè menu di u pesu massimu pussibule, è hè equilibratu '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,scn_Latn,python,"
def smallest_change(arr):
    """"""Datu nu matricu arr di nùmmura interi, truvamu lu nùmmuru minimu di elementi ca hannu a èssiri canciati pi fari lu matricu palindromu. Un matricu palindromu è un matricu ca si leggi lu stissu avanti e arreri. 'N na canciamentu, si pò canciari un elementu a n'àutru elementu. Esempiu: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,scn_Latn,python,"
def total_match(lst1, lst2):
    '''Scrivi na funzioni ca accetta dui elenchi di strings e torna la lista ca havi lu nùmmiru tutali di caratteri nta tutti li strings dâ lista cchiù picca di l'àutra lista. si li dui elenchi hannu lu stissu nùmmiru di caratteri, torna la prima lista. Esempii total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4'], ['5']) -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,scn_Latn,python,"
def is_multiply_prime(a):
    """"""Scrivite na funzioni ca torna veru si lu nùmmuru datu è la multiplicazzioni di 3 nùmmura primi e falsu altrimenti. sapennu ca (a) è menu di 100. esempiu: is_multiply_prime(30) == Veru 30 = 2 * 3 * 5 """"""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,scn_Latn,python,"
def is_simple_power(x, n):
    """"""Lu tò compitu è scriviri na funzioni ca torna veru si nu nùmmaru x è na putenza semplici di n e falsu nta l'àutri casi. x è na putenza semplici di n si n**int=x P'asempiu: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,scn_Latn,python,"
def iscube(a):
    '''Scrivi na funzioni ca pigghia nu nùmmuru interi a e torna True si stu ingeger è nu cubu di nu nùmmuru interi. Nota: si pò supponiri ca l'input è sempri validu. Esempi: iscube(1) ==> True iscube(2) ==> False iscube(-1) ==> True iscube(64) ==> True iscube(0) ==> True iscube(180) ==> False '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,scn_Latn,python,"
def hex_key(num):
    """"""Avete avutu u compitu di scrive una funzione chì riceve un numeru esadecimale cum'è una stringa è conta u numeru di cifre esadecimale chì sò primi (un numeru primu, o un primu, hè un numeru naturale più grande di 1 chì ùn hè micca un pruduttu di dui numeri naturali più chjuchi). I cifre esadecimale sò 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. I numeri primi sò 2, 3, 5, 7, 11, 13, 17,... Dunque avete da determinà un numeru di e seguenti cifre: 2, 3, 5, 7, B (= decimale 11), D (= decimale 13). Nota: pudete suppone chì l'ingressu sia sempre currettu o vacante stringa, è i simboli A, B, C, D, E, F sò sempre maiusculi. Esempi: Per num = ""AB"" l'uscita duverebbe esse num = 1. Per ""1077E"" l'uscita duverebbe esse 2. Per num = ""AB33"" u num = 1. ""AB"" u num = 4. ""ABC"" duverebbe esse 6.0896745 A ""A"" duverebbe esse 6.0202020 """"""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,scn_Latn,python,"
def decimal_to_binary(decimal):
    """"""Vi sarà datu un nùmmaru in forma dicimali e u vostru compitu è di cunvertìlu in furmatu binariu. A funzioni deve restituisce una stringa, cù ogni carattere chì rapprisenta un numeru binariu. Ogni carattere in a stringa serà '0' o '1'. Ci sarà un coppiu di caratteri extra 'db' à l'iniziu è à a fine di a stringa. I caratteri extra sò quì per aiutà cù u furmatu. Esempi: decimal_to_binary(15) # restituisce ""db1111db"" decimal_to_binary32) # restituisce ""db100000db"" """"""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,scn_Latn,python,"
def is_happy(s):
    """"""Vi veni data na stringa s. Lu vostru compitu è di cuntrollari si la stringa è felici o no. Na stringa è felici si la sò lunghizza è armenu 3 e ogni 3 littri cunsicutivi sunnu distinti Esempiu: is_happy(a) => False is_happy(aa) => False is_happy(abcd) => True is_happy(aabb) => False is_happy(adb) => True is_happy(xyy) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,scn_Latn,python,"
def numerical_letter_grade(grades):
    """"""È l'ultima simana di semestru e l'insegnante deve dà i voti à i studienti. L'insegnante hà fattu u so propiu algoritmu per a valutazione. L'unicu prublema hè chì hà persu u codice chì hà adupratu per a valutazione. Vi hà datu una lista di GPA per alcuni studienti è avete da scrive una funzione chì pò publicà una lista di voti di lettere aduprendu a tabella seguente: GPA. Gradu di lettera 4.0 A + > 3.7 A > 3.3 A- > 3.0 B + > 2.7 B- > 2.3 B- > 2.0 C + > 1.7 C > 1.3 C- > 1.0 D + > 0.7 D > 0.0 D- 0.0 E: esempiu grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,scn_Latn,python,"
def prime_length(string):
    """"""Scrivi na funzioni ca pigghia na stringa e torna True si la lunghizza di la stringa è nu nùmmuru primu o False altrimenti Esempi prime_length{'Hello') == True prime_length{'abcdcba') == True prime_length{'kittens') == True prime_length{'orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,scn_Latn,python,"
def starts_one_ends(n):
    """"""Datu nu nùmmaru n pusitivu, riturna lu nùmmaru di n-cifri pusitivi ca accumincianu o finiscinu cu 1.""""""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,scn_Latn,python,"
def solve(N):
    """"""Data na n'entieri pusitivu N, riturnari la summa tutali dî sò cifri n'archiu binariu. Esempiu Pi N = 1000, la summa dî cifri sarà 1 la uscita avissi a èssiri ""1"". Pi N = 150, la summa dî cifri sarà 6 la uscita avissi a èssiri ""110"". Pi N = 147, la summa dî cifri sarà 12 la uscita avissi a èssiri ""1100"". Variabili: @N cuntinzioni nteri: 0 â‰¤ N â‰¤ 10000. Uscita: na stringa di nùmmura binaria """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,scn_Latn,python,"
def add(lst):
    """"""Datu na lista nun vacanti di nùmmura ntieri lst. agghiùnciri l'elementi pari ca sunnu a indici dispari.. Esempi: agghiùnciri (([4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,scn_Latn,python,"
def anti_shuffle(s):
    """"""Scrivi na funzioni ca pigghia na stringa e la torna n'urdinata. La virsioni urdinata di stringa è na stringa unni tutti li palori (spartidi di spazzi) sunnu sustituiti di na nova parola unni tutti li caràttiri sunnu urdinati n'urdinamentu crescenti basatu supra lu valuri ascii. Nota: Tu avissi a mantèniri l'urdinamentu di li palori e li spazzi vacanti nta la frasi. P'asempiu: anti_shuffle ((('Hi') torna 'Hi' anti_shuffle ((('hello') torna 'ehllo' anti_shuffle (('Hello World!!!') torna 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,scn_Latn,python,"
def get_row(lst, x):
    """"""Si dà un datu bidimensionale, comu na lista annidata, chi è simili a na matriz, però, a diffirenza di na matriz, ogni rigghia pò cuntèniri nu nùmmiru diffirenti di culonni. Datu lst, e nternu x, truvari nterni x ntâ lista, e riturnari lista di tupuli, [(x1, y1), (x2, y2) ...] tali ca ogni tupla è na cuurdinata - (rigghia, culonni), accuminciannu cu 0. Ordina li cuurdinati inizialmente pi rigghi n urdinamentu crescenti. Ancu, ordinati li cuurdinati dâ rigghia pi culonni n urdinamentu discinnenti. Esempi: get_row[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4], 0 (1, 4), 0 (2, 5), (2, 0) get_((1), 1) [] == [[rigghia]], [1, 2, 3]], [2, 2]] ]]""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,scn_Latn,python,"
def sort_array(array):
    """"""Datu na matrizzioni di nterni nun nigativi, turnari na copia dâ matrizzioni data doppu l'ordinamentu, si sarra la matrizzioni data 'n ordini crescenti si la summa (primu valuri di indici, urtimi valuri di indici) è paru, o si sarra 'n ordini discinnenti si la summa (primu valuri di indici, urtimi valuri di indici) è pari. Nota: * nun canciari la matrizzioni data. Esempi: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,scn_Latn,python,"
def encrypt(s):
    """"""Crea na funzioni encrypt ca pigghia na stringa comu argumentu e torna na stringa criptata cu l'alfabetu ca veni giratu. L'alfabetu avissi a èssiri giratu di na manera ca li littri si spustanu ncapu dui multiplicati pi dui posti. P'asempiu: encrypt ((hi) torna 'lm' encrypt ((asdfghjkl) torna 'ewhjklnop' encrypt ((gf)) torna 'kj' encrypt ((et)) torna 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,scn_Latn,python,"
def next_smallest(lst):
    """"""Vi è datu na lista di nùmmura interi. Scrivite na funzioni next_smallest() ca riturna lu secunnu cchiù nicu elementu dâ lista. Riturna None si nun c'è nuddu tali elementu. next_smallest([1, 2, 3, 4, 5]) == 2 next_smallest([5, 1, 4, 3, 2]) == 2 next_smallest([]) == None next_smallest([1, 1]) == None """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,scn_Latn,python,"
def is_bored(S):
    """"""Vi sarà data una stringa di parolle, è u vostru compitu hè di cuntà u numeru di noie. Una noie hè una frase chì principia cù a parolla ""I"". E frasi sò delimitate da '.', '?' o '!'. Per esempiu: >>> is_bored(""Ciao mondu"") 0 >>> is_bored(""U celu hè blu. U sole brilla. Mi piace stu tempu"") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,scn_Latn,python,"
def any_int(x, y, z):
    '''Crea na funzioni ca pigghia 3 numari. Ritorna veru si unu di li numari è uguali a la summa di l'àutri dui, e tutti li numari sunnu interi. Ritorna falsu nta tutti l'àutri casi. Esempiu any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,scn_Latn,python,"
def encode(message):
    """"""Scrivi na funzioni ca pigghia nu missaggiu, e lu codifica accussì ca cancia li casi di tutti li littri, e sustituisci tutti li vucali dû missaggiu cu la littra ca appari 2 posti avanti di la vucali nta l'alfabetu ngrisi.""""""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,scn_Latn,python,"

def skjkasdkd(lst):
    """"""Vi veni datu na lista di nùmmura interi. Vossia havi a truvari lu cchiù granni valuri primu e riturnari la summa dî sò cifri. Esempi: Pi lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] lu risultatu avissi a èssiri 10 Pi lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] lu risultatu avissi a èssiri 25 Pi lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] lu risultatu avissi a èssiri 13 Pi lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] lu risultatu avissi a èssiri 11 Pi lst = [0,81,12,31,21] lu risultatu avissi a èssiri 3 Pi lst = [0,1,8,2,1,7] lu risultatu avissi a èssiri 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,scn_Latn,python,"
def check_dict_case(dict):
    """"""Datu nu dizziunariu, torna True si tutti li tasteri sunnu strings in minusculi o tutti li tasteri sunnu strings in maiusculi, altrimenti torna False. La funzioni avissi a riturnari False si lu dizziunariu datu è vacanti. Esempi: check_dict_case{""a"":""apple"", ""b"":""banana""}) avissi a riturnari True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) avissi a riturnari False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) avissi a riturnari False. check_dict_case{""Nome"":""John"", ""Age"":""36"", ""City"":""Houston""}) avissi a riturnari False. check_dict_case{""NC"":""STATE"", ""ZIP"":""12345""}) avissi a riturnari True.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,scn_Latn,python,"
def count_up_to(n):
    """"""Implementà una funzione chì piglia un nùmeru interu non negativu è torna una matrice di i primi n numeri interi chì sò numeri primi è menu di n. per esempiu: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,scn_Latn,python,"
def multiply(a, b):
    """"""Completate a funzione chì piglia dui numeri interi è torna u pruduttu di i so cifre unità. Assumemu chì l'ingressu hè sempre validu. Esempi: multiplicà 148, 412 deve restituisce 16. multiplicà 19 28 deve restituisce 72. multiplicà 2020 1851 deve restituisce 0 multiplicà 14-15 deve restituisce 20 """"""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,scn_Latn,python,"
def count_upper(s):
    """"""Datu na stringa s, cuntari lu nùmmiru di vucali maiusculi ntê indici pari. Esempiu: count_upper (('aBCdEf') torna 1 count_upper (('abcdefg') torna 0 count_upper (('dBBE') torna 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,scn_Latn,python,"
def closest_integer(value):
    '''Crea na funzioni ca pigghia nu valuri (string) ca rapprisenta nu nùmmuru e torna lu nùmmuru nternu cchiù vicinu. Se lu nùmmuru è equidistanti di dui nùmmura nterni, arrotondalu luntanu di zeru. Esempi >>> closest_integer (((""10"") 10 >>> closest_integer (((""15.3"") 15 Nota: arrotondari luntanu di zeru significa ca si lu nùmmuru datu è equidistanti di dui nùmmura nterni, chiddu ca si avissi a riturnari è chiddu ca è cchiù luntanu di zeru. P'asempiu closest_integer "" (((14.5"") avissi a riturnari 15 e closest_integer "" ((-14.5"") avissi a riturnari -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,scn_Latn,python,"
def make_a_pile(n):
    """"""Datu un nùmmuru interu pusitivu n, si havi a fari na pila di n livelli di petri. Lu primu liveddu havi n petri. Lu nùmmuru di petri ntô prossimu liveddu è: - lu prossimu nùmmuru paru si n è paru. - lu prossimu nùmmuru paru si n è paru. Ritorna lu nùmmuru di petri nta ogni liveddu nta na lista, unni l'elimentu a indici i rapprisenta lu nùmmuru di petri ntô liveddu (i+1). Esempi: >>> make_a_pile(3) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,scn_Latn,python,"
def words_string(s):
    """"""Vi sarà data na stringa di palori siparati da virgule o spazzi. Lu vostru compitu è di spartiri la stringa 'n palori e riturnari na matria di palori. Esempiu: words_string ((""Ciao, mi chiamu John"") == [""Ciao"", ""meu"", ""nome"", ""è"", ""John""] words_string ((""Unu, dui, tri, quattru, cincu, sei"") == [""Unu"", ""dui"", ""tri"", ""quattru"", ""cinqui"", ""sei""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,scn_Latn,python,"
def choose_num(x, y):
    """"""Sta funzioni pigghia dui numari pusitivi x e y e torna lu nùmmaru pari cchiù granni ca è ntô raggu [x, y] inclusu.""""""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,scn_Latn,python,"
def rounded_avg(n, m):
    """"""Si vi danu dui nterni pusitivi n e m, e lu vostru compitu è di calculi la media dî nterni da n a m (compresi n e m). Arrunciati la risposta ô nternu cchiù vicinu e cunvertitila a binariu. Se n è cchiù granni di m, riturnati -1. Esempiu: rounded_avg ((1, 5) => ""0b11"" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => ""0b11"" rounded_avg ((20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,scn_Latn,python,"
def unique_digits(x):
    """"""Data na lista di nterni pusitivi x. riturna na lista ordinata di tutti l'elementi ca nun hannu nuddu nùmmaru pari. Nota: La lista riturnata avissi a èssiri ordinata pi l'urdinamentu crescenti. Esempiu: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,scn_Latn,python,"
def by_length(arr):
    """"""Datu un array di numari interi, ordinati li numari interi ca sunnu tra 1 e 9 cumprisu, inverti l'array risultanti, e poi sustituisci ogni cifra cu lu nomu currispunnenti di ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"". P'asempiu: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> ordinari arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> arr inversu -> [8, 5, 4, 3, 2, 2, 1, 1] ritornu [""Eight"", ""Five"", ""Three"", ""Two"", ""Two"", ""One"", ""One""] Si l'array è vacanti, ritorna un array: arr = [] ritorna [] Si l'array havi nu nùmmaru stranu ignura lu: arr = [1, -1 , 55] -> arr -> [1, 55] -> arr -> [55, - arr = 1] ritorna ['One'] """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,scn_Latn,python,"
def f(n):
    """"""Implementamu la funzioni f ca pigghia n comu paramaturu, e torna na lista di grannizza n, tali ca lu valuri di l'elimentu a l'indici i è lu fatturialu di i si i è pari o la summa di li nùmmari da 1 a i altrimenti. i accumincia da 1. lu fatturialu di i è la multiplicazzioni dî nùmmari da 1 a i (1 * 2 * ... * i). Esempiu: f (((5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,scn_Latn,python,"
def even_odd_palindrome(n):
    """"""Datu un nùmmaru interu pusitivu n, riturnamu na tupla ca havi lu nùmmaru di palindromi interi pari e dispari ca cadinu ntô raggu ((1, n), inclusi. Esempiu1: Input: 3 Output: (1, 2) Splicazzioni: Palindromi interi sunnu 1, 2, 3. unu di chisti è pari, e dui di chisti sunnu dispari. Esempiu2: Input: 12 Output: (4, 6) Splicazzioni: Palindromi interi sunnu 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. quattru di chisti sunnu pari, e 6 di chisti sunnu dispari. Nota: 1. 1 <= n <= 10^3 2. tupla riturnatu havi lu nùmmaru di palindromi interi pari e dispari rispettivamenti. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,scn_Latn,python,"
def count_nums(arr):
    """"""Scrivite na funzioni count_nums ca pigghia na matrice di nterni e torna lu nùmmiru di elementi ca havi na summa di cifri > 0. Si nu nùmmiru è nigativu, allura la sò prima cifri firmata sarà nigativa: p'asempiu -123 havi li cifri firmati -1, 2, e 3. >>> count_nums[]) == 0 >>> count_nums[-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,scn_Latn,python,"
def move_one_ball(arr):
    """"""Avemu na matrizzioni 'arr' di N nùmmari interi arr[1], arr[2], ..., arr[N].I nùmmari ntâ matrizzioni vennu urdinati a casu. Lu tò compitu è di determinari si è pussìbbili aviri na matrizzioni urdinata a ordini nun diminuenti facennu l'upirazzioni siguenti: Si pò fari l'upirazzioni di spustamentu a destra na quantità di voti. Na upirazzioni di spustamentu a destra significa spustari tutti l'elimenti dâ matrizzioni di na pusizzioni ntâ direzzioni giusta. L'ùrtimu elementu dâ matrizzioni vennu spustati â pusizzioni di partenza ntâ matrizzioni, ossia 0° indici. Si è pussìbbili aviri l'array urdinata facennu l'upirazzioni supra, allura torna True altrimenti torna False. Se la matrizzioni data è vacanti allura torna True. Nota: La lista data è garantita di aviri elementi ùnici. Esempiu: move_one_{(ball_[3, 4, 5, 1, 2>True Explanation: By performin 2 right operations, non-decreasing order can be achieved for the array. Get the following number of times. Right shift operation. One right shift operation means shifting all elements of the array by one position in the right direction. L'ùrtimu elementu dâ matrizzioni dâ matrizzioni vennu vennu vennu vennu l'indici vennu l'indici, ntâ l'indici 0° indici, allura torna True altrimenti torna False.""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,scn_Latn,python,"
def exchange(lst1, lst2):
    """"""In stu prubblema, tu implementarrai na funzioni ca pigghia dui listi di numari, e determina si è pussìbbili fari nu scambio di elementi tra iddi pi fari lst1 na lista di numari pari. Nun c'è limiti a lu nùmmiru di elementi scambiati tra lst1 e lst2. Si è pussìbbili scambiari elementi tra lst1 e lst2 pi fari tutti l'elementi di lst1 essiri pari, torna ""SI"". Altrimenti, torna ""NO"". Esempiu: scambio[(1, 2, 3, 4], [1, 2, 3, 4]) => ""Sì"" scambio[(1, 2, 3, 4], [1, 5, 3, 4]) => ""NO"" Si supponi ca li listi di input nun sunnu vacanti. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,scn_Latn,python,"
def histogram(test):
    """"""Datu na stringa ca rapprisenta na littra minuri separata di spazziu, riturnari nu dizziunariu dâ littra cu la ripitizzioni cchiù granni e chi cunteni lu cuntu currispunnenti. Se diversi littri hannu la stissa prisenza, riturnari tutti. Esempiu: istogramma""""""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,scn_Latn,python,"
def reverse_delete(s,c):
    """"""Cumpitu Ci sunnu dati dui stringhi s e c, tu hai a cancellari tutti li caratteri di s ca sunnu uguali a qualunqui caratteri di c e poi cuntrolla si la stringa risultanti è palindromu. Una stringa è chiamata palindromu si si leggi lu stissu avanti e arreri. Tu avissi a riturnari na tupla chi cunteni la stringa risultanti e True/False pi lu cuntrollu. Esempiu pi s = ""abcde"", c = ""ae"", lu risultatu avissi a èssiri ('bcd', False) Pi s = ""abcdef"", c = ""b"" lu risultatu avissi a èssiri ('acdef', False) Pi s = ""abcdedcba"", c = ""ab"", lu risultatu avissi a èssiri ('cdedc', True)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,scn_Latn,python,"
def odd_count(lst):
    """"""Datu na lista di strings, unni ogni stringa è cumposta sulu di cifri, riturnari na lista. Ogni elementu i di l'output avissi a èssiri ""lu nùmmiru di elementi dispari ntâ stringa i di l'input"". unni tutti li i avissi a èssiri rimpiazzati dû nùmmiru di cifri dispari ntâ i'th stringa di l'input. >>> odd_count['1234567']) [""lu nùmmiru di elementi dispari 4n la str4ng 4 di la 4nput.""] >>> odd_count['3',""111111""]) [""lu nùmmiru di elementi dispari 1n la str1ng 1 di la 1nput."", ""lu nùmmiru di elementi dispari 8n la str8ng 8 di la 8nput.""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,scn_Latn,python,"
def minSubArraySum(nums):
    """"""Datu nu matricu di n'entieri, trova la summa mìnima di ogni sutta matricu di n'entieri.""""""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,scn_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Vi hè data una griglia rettangolare di pozzi. Ogni fila rapprisenta un pozzu singulu, è ogni 1 in una fila rapprisenta una sola unità d'acqua. Ogni pozzu hà un seccu currispundente chì pò esse adupratu per estrarre acqua da ellu, è tutti i secchi anu a listessa capacità. U vostru compitu hè di aduprà i secchi per svuotà i pozzi. Esempiu 1: Input: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Output: 62: Input: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 Output: 53: Input: [[:0,0,0], [0,0,0]] bucket_capacity: 5 Output: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,scn_Latn,python,"
def sort_array(arr):
    """"""In stu Kata, si havi a ordinari na matrizzioni di nentieri nun nigativi secunnu lu nùmmiru di unu ntâ rapprisintazzioni binaria nta n'òrdini crescenti. pi nu nùmmiru simili di unu, si s'havi a ordinari basatu supra lu valuri dicimali.""""""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,scn_Latn,python,"
def select_words(s, n):
    """"""Datu na stringa s e nu nùmmuru naturali n, haiu statu incaricatu di implementari na funzioni ca ritorna na lista di tutti li palori dâ stringa s ca cuntèninu esattamente n cunsunanti, pi fari tali palori cumpariri ntâ stringa s. Se la stringa s è vacanti allura la funzioni avissi a riturnari na lista vacanti. Nota: si pò supponiri ca la stringa di input cunteni sulu littri e spazzi. Esempi: select_words (""Mary had a little lamb"", 4) ==> [""little""] select_words (""Mary had a little lamb"", 3) ==> [""Mary"", ""lamb""] select_words ""simple white space"", 2) ==> [] select_words (""Hello world"", 4) ==> [""world""] select_words (""Uncle sam"", 3) ==> [""Uncle""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,scn_Latn,python,"
def get_closest_vowel(word):
    """"""Vi è data na parola. Lu vostru compitu è truvari la vucali cchiù vicina ca sta tra dui cunsunanti dû latu drittu dâ parola (sensibbili a cassa). Li vucali all'inizziu e a la fini nun cuntanu. Ritorna na stringa vacanti si nun truvasti nuddu vucali ca cumporta la cundizioni supra. Puderete supponiri ca la stringa data cunteni sulu littri ngrisi. Esempiu: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" ((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,scn_Latn,python,"
def match_parens(lst):
    '''Vi veni datu na lista di dui stringhi, tutti dui consistinu sulu di parentizzi aperti '(' o parentizzi chiusi ') '. Lu vostru travagghiu è di cuntrollari si è pussìbbili cuncatinari li dui stringhi nta n'òrdini, e lu stringhi risultanti sarà bonu. Na stringha S è cunzidirata bona si e sulu si tutti li parentizzi di S sunnu abbalanciati. P'asempiu: la stringha '((())' è bona, mentri la stringha '())' nun è. Ritorna 'Yes' si c'è na manera di fari na bona stringha, e ritorna 'No' altrimenti. Esempi: match_parens[('() ', ') ']) == 'Yes' match_parens[(') ', ') ']) == 'No' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,scn_Latn,python,"
def maximum(arr, k):
    """"""Datu na matrizzioni arr di nterni e n'interu pusitivu k, riturnari na lista ordinata di lunghizza k cu li nummari massimi k ntâ matrizzioni arr. Esempiu 1: Input: arr = [-3, -4, 5], k = 3 Output: [-4, -3, 5] Esempiu 2: Input: arr = [4, -4, 4], k = 2 Output: [4, 4] Esempiu 3: Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Output: [2] Nota: 1. La lunghizza dâ matrizzioni sarà ntô raggu di [1, 1000]. 2. L'elimenti dâ matrizzioni saranu ntô raggu di [-1000, 1000]. 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,scn_Latn,python,"
def solution(lst):
    """"""Datu na lista di nùmmura nticci, riturnari la summa di tutti l'elementi dispari ca sunnu a pusizzioni pari.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,scn_Latn,python,"
def add_elements(arr, k):
    """"""Datu nu matricu nun vacanti di nùmmura interi arr e n'entieru k, riturnari la summa di l'elementi cu cchiù di dui cifri di li primi k elementi di arr. Esempiu: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # sum of 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr) """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,scn_Latn,python,"
def get_odd_collatz(n):
    """"""Datu nu nùmmuru n pusitivu, riturnamu na lista ordinata ca havi li numari dispari ntâ sequenza di Collatz. La cunicitura di Collatz è na cunicitura di matimàtica ca riguarda na sequenza difinita comu siguenti: accuminciamu cu n nùmmuru pusitivu. Poi ogni tèrmini si pigghia dû tèrmini pricidenti comu siguenti: si lu tèrmini pricidenti è pari, lu prossimu tèrmini è la mità dû tèrmini pricidenti. Si lu tèrmini pricidenti è dispari, lu prossimu tèrmini è 3 voti lu tèrmini pricidenti cchiù 1. La cunicitura è ca, nun importa quali valuri di n, la sequenza arrivi sempri a 1. Nota: 1. Collatz(1) è [1]. 2. la lista riturnata ordinata pi cresciri. P'asempiu: get_odd_collatz(5) riturna [1, 5] La sequenza di Collatz pi 5 è [5, 8, 16, 4, 2, 1], accussì li nùmmura dispari sunnu sulu 1, e 5. """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,scn_Latn,python,"
def valid_date(date):
    """"""A data è valida si tutti li cumandi siguenti sunnu soddisfatti: 1. A data nun è vacanti. 2. U nùmmuru di jorna nun è cchiù picca di 1 o cchiù granni di 31 jorna pi li misi 1,3,5,7,8,10,12. E lu nùmmuru di jorna nun è cchiù picca di 1 o cchiù granni di 30 jorna pi li misi 4,6,9,11. E, lu nùmmuru di jorna nun è cchiù picca di 1 o cchiù granni di 29 jorna pi lu misi 2. 3. Li misi nun hannu a èssiri cchiù picca di 1 o cchiù granni di 12. 4. La data avissi a èssiri ntô furmatu: mm-dd-yyyy p'asempiu: valid_date (('03-11-2000') => valid_date (('15-01-2012') => valid_date (('04-02040') => valid_date (('06-04-2020') => valid_date (('06/04/2020') => false""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,scn_Latn,python,"
def split_words(txt):
    '''Data na stringa di palori, riturnari na lista di palori spartuti supra lu spazziu biancu, si nun esisti nu spazziu biancu ntô testu si deve spartuti supra li virguletti ',' si nun esisti nu virgulettu si deve riturnari lu nùmmiru di littri minuri cu n'òrdini dispari ntô alfabetu, ord ((('a') = 0, ord ((('b') = 1, ... ord ((('z') = 25 Esempi spartuti_palori (((""Ciau munnu!"") â -> [""Ciau munnu!"", ""munnu!""] spartuti_palori (((""Ciau munnu!"") â -> [""Ciau munnu!"", ""munnu!""] spartuti_palori (((""abcdef"") == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,scn_Latn,python,"
def is_sorted(lst):
    '''Datu na lista di numari, torna si sunnu ordinati o nun in ordini crescenti. Se la lista havi cchiù di 1 duplicatu dû stissu nùmmaru, torna False. Assumi ca nun ci sunnu numari nigativi e sulu nterni. Esempi is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 3, 2, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,scn_Latn,python,"
def intersection(interval1, interval2):
    """"""Si ti danu dui intervalli, unni ogni intervallu è na para di nùmmari interi. P'asempiu, intervallu = (inizziu, fini) = (1, 2). L'intervalli dati sunnu chiusi, chi significa ca l'intervallu (inizziu, fini) cumprenni sia l'inizziu ca la fini. Pi ogni intervallu datu, si supponi ca lu so iniziu è menu o uguali a la fini. Lu tò compitu è di determinari si la lunghizza di l'intersezzioni di sti dui intervalli è nu nùmmaru primu. Esempiu, l'intersezzioni di l'intervalli (1, 3), (2, 4) è (2, 3) la cui lunghizza è 1, chi nun è nu nùmmaru primu. Si la lunghizza di l'intersezzioni è nu nùmmaru primu, torna ""SI"", altrimenti torna ""NO"". Si li dui intervalli nun si intersecciu, torna ""NO"". [input/output] samples: intersection (((1, 2), (2, 3) ==> ""intersection ((1, 1) ""NO"") ==> intersection ((1, 4) ==""intersection (NO) ==> 5 - (((1, 5), ""YES (-"", ""Y"" - ""Y"") ))""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,scn_Latn,python,"
def prod_signs(arr):
    """"""Vi veni datu nu matricu arr di nùmmura interi e vi tocca turnari la summa di li magnitudini di li nùmmura interi multiplicati pi lu pruduttu di tutti li segni di ogni nùmmuru nta l'array, rapprisintatu di 1, -1 o 0. Nota: turnari Nuddu pi l'arr vuotu. Esempiu: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == Nuddu """"""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,scn_Latn,python,"
def minPath(grid, k):
    """"""Datu na griglia cu N righe e N culonne (N >= 2) e na cellula interiori pusitivi k, ogni cellula di la griglia cunteni nu valuri. Ogni nternu ntô raggu [1, N * N] inclusivu appaia esattamente na vota ntê cellule dâ griglia. Tu hai a truvari lu percorsu minimu di lunghizza k ntâ griglia. Tu pò accuminzari da ogni cellula, e a ogni passu tu pò trasiri a qualunqui cellula vicinu, n'àutri paroli, tu pò jiri a celluli ca cumminciunu nu latu cu la tò cellula currenti. Nota ca nu percorsu di lunghizza k significa visitàri esattamente k celluli (nun è necessariamente distintu). Nun si po' jiri fora dâ griglia. Un percorsu A (di lunghizza k) è cunzidiratu cchiù picca di nu percorsu B (di lunghizza k) si doppu aviri fattu l'elenchi urdinati dî valuri ntê celluli A e B (chiammi li l_st e l_A_st), l_stBst), l_Ast_ è lessicamenti menu picca di l_st_Ast_Ast_A, n'à l'autri paroli, n'antri ntê palori nterni, n'interi, si pò trasiri n'antri cellu k, i cellu attuali. [A = 1, l_i, i = 1, l_j, i = 1, l_j, i = 1, l_j, i = [4, i = l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j, l_j] [4, l_i, l_j, l_i, l_i, l_i, l_j, l_i, ] ] [_i, [_i, ], [_i, ], [_i, ], [_i, ], [_i, ], [_i, ], [_i, ], [_i, ], []""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,scn_Latn,python,"
def tri(n):
    """"""Tutti canuscinu la siquenza di Fibonacci, fu studiata assai da li matimàtici nta l'ùrtimi dui sèculi. Ma chiddu chi la genti nun canusci è la siquenza di Tribonacci. La siquenza di Tribonacci è difinita da la ricurrenza: tri(1) = 3 tri(n) = 1 + n / 2, si n è pari. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n è paru. P'asempiu: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Vi sunnu dati nu nùmmuru nentieru nun nigativu, vi hannu a riturnari na lista dî primi n + 1 nùmmura dâ siquenza di Tribonacci. Esempi: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,scn_Latn,python,"
def digits(n):
    """"""Datu nu nùmmaru n, riturnamu lu pruduttu dî cifri pari. Riturnamu 0 si tutti li cifri sunnu pari.""""""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,scn_Latn,python,"
def is_nested(string):
    '''Crea na funzioni ca pigghia comu input na stringa ca cunteni sulu parentesi quatrate. La funzioni avissi a riturnari True si e sulu si c'è na suttasseguenza valida di parentesi unni almenu na parentesi ntâ suttasseguenza è nistata. is_nested '[[]]') â -> True is_nested '[[]]]]]]]]]]]]]][[[[[[[]') â -> False is_nested '[][]') â -> False is_nested '[]') â -> False is_nested '[[]]') â -> True is_nested '[[]]]]]]]]]] â -> True'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,scn_Latn,python,"

def sum_squares(lst):
    """"""Vi veni datu na lista di nummari. Bisogna riturnari la summa di li nummari squadrati dâ lista data, arrotondari ogni elementu dâ lista a l'int supranu ((Ceiling) prima. Esempi: pi lst = [1,2,3] lu risultatu avissi a èssiri 14 pi lst = [1,4,9] lu risultatu avissi a èssiri 98 pi lst = [1,3,5,7] lu risultatu avissi a èssiri 84 pi lst = [1.4,4.2,0] lu risultatu avissi a èssiri 29 pi lst = [-2.4,1,1] lu risultatu avissi a èssiri 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,scn_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Crea na funzioni ca torna True si l'ùrtimu caràttiri di na stringa data è nu caràttiri alfabbèticu e nun è na parti di na palora, e False altrimenti. Nota: ""word"" è nu gruppu di caràttiri siparati di spazziu. Esempi: check_if_last_char_is_a_letter (((""apple pie"") â -> False check_if_last_char_is_a_letter (((apple pi e"") â -> True check_if_last_char_is_a_letter (((apple pi e "") â -> False check_if_last_char_is_a_letter "" ((("") â -> False '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,scn_Latn,python,"
def can_arrange(arr):
    """"""Crea na funzioni ca ritorna l'indici cchiù granni di n'elimentu ca nun è cchiù granni o uguali all'elimentu ca lu precede. Se nu tali elementu nun esisti, ritorna -1. L'array datu nun cunteni valori duplicati. Esempi: can_arrange ([1,2,4,3,5]) = 3 can_arrange ([1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,scn_Latn,python,"
def largest_smallest_integers(lst):
    '''Crea na funzioni ca ritorna na tupla (a, b), unni 'a' è lu cchiù granni di li nterni nigativi, e 'b' è lu cchiù nicu di li nterni pusitivi nta na lista. Si nun ci sunnu nterni nigativi o pusitivi, li ritorna comu None. Esempi: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,scn_Latn,python,"
def compare_one(a, b):
    """"""Crea na funzioni ca pigghia nterni, floats, o stringhi ca rapprisintanu numari riali e torna la variabbili cchiù granni ntô sò tipu di variabbili. Ritorna Nuddu si li valuri sunnu uguali. Nota: Si nu nùmmaru riali è rapprisintatu comu na stringha, lu puntu fluttuanti pò èssiri . o , compare_one{1,2,5) â -> 2.5 compare_one{1, ""2,3"") â -> ""2,3"" compare_one{5,1"", ""6"") â -> ""6"" compare_one{1"", 1) â -> Nuddu """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,scn_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Valuta si lu nùmmuru datu n pò èssiri scrittu comu la summa di esattamente 4 nùmmura pari pusitivi Esempiu è_uguali_a_summa_pari (even) {4) == Falsu è_uguali_a_summa_pari (even) {6) == Falsu è_uguali_a_summa_pari (even) {8) == Vero """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,scn_Latn,python,"
def special_factorial(n):
    """"""Lu fatturialu brasilianu è difinutu comu: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! unni n > 0 P'asempiu: >>> special_factorial ((4) 288 La funzioni ricevi nu nùmmiru interu comu input e avissi a riturnari lu fatturialu spiciali di stu nùmmiru interu. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,scn_Latn,python,"
def fix_spaces(text):
    """"""_Esempiu-3ringa, sustituisci tutti li spazzi cu li suttanavi, e si na stringa havi cchiù di 2 spazzi cunsicuenti, sustituisci tutti li spazzi cunsicuenti cu - fix_spaces ((""Esempiu"") == ""Esempiu"" fix_spaces ((""Esempiu1"") == ""Esempiu1"" fix_spaces (((""Esempiu2"") == ""_Esempiu2"" fix_spaces ((""Esempiu 3"") == ""_Esempiu-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,scn_Latn,python,"
def file_name_check(file_name):
    """"""Crea na funzioni ca pigghia na stringa ca rapprisenta lu nomu di nu file, e torna 'Sì' si lu nomu di lu file è validu, e torna 'No' si nun è validu. Lu nomu di nu file è cunzidiratu validu si e sulu si tutti li cunnizzioni siguenti sunnu soddisfatti: - Nun ci avissi a èssiri cchiù di tri cifri ('0'-'9') ntô nomu di lu file. - Lu nomu di lu file cunteni esattamente nu puntu '.' - La sottostringa prima di lu puntu nun avissi a èssiri vacanti, e avissi a cuminciari cu na littra di l'alfabetu latinu ('a'-'z' e 'A'-Z'). - La sottostringa doppu lu puntu avissi a èssiri una di sti littri: ['txt', 'exe', 'lld'] Esempi: file_name_check""{example.txt.txt"") # => 'Sì' file_name_check""{example.dlld1} => 'No' (#' (lu nomu avissi a cuminciari cu na littra di l'alfabetu latinu)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,scn_Latn,python,"


def sum_squares(lst):
    """""""" Sta funzioni pigghia na lista di nùmmari interi. Pi tutti li voci dâ lista, la funzioni s'àbbia a squariariari la voce nteri si lu sò indici è nu multipli di 3 e s'àbbia a cubaliari la voce nteri si lu sò indici è nu multipli di 4 e nun di 3. La funzioni nun cancia li voci dâ lista li cui indici nun sunnu nu multipli di 3 o 4. La funzioni poi torna la summa di tutti li voci. Esempi: pi lst = [1,2,3] la uscita avissi a èssiri 6 pi lst = [] la uscita avissi a èssiri 0 pi lst = [-1,-5,2,-1,-5] la uscita avissi a èssiri -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,scn_Latn,python,"
def words_in_sentence(sentence):
    """"""Vi veni data na stringa ca rapprisenta na frasi, la frasi cunteni quarchi palora siparata di nu spazziu, e vi tocca turnari na stringa ca cunteni li palori dâ frasi urigginaria, la cui lunghizza sunnu nummari primi, l'òrdini dî palori dâ nova stringa avissi a èssiri lu stissu di chiddu urigginariu. Esempiu1: Input: sentence = ""This is a test"" Output: ""is"" Esempiu2: Input: sentence = ""let go for swimming"" Output: ""go for"" Constraints: * 1 <= len(sentence) <= 100 * sentence contains only letters """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,scn_Latn,python,"
def simplify(x, n):
    """"""Lu tò compitu è di implementari na funzioni ca simplifichi l'espressioni x * n. La funzioni torna True si x * n si valuta comu nu nùmmuru interu e False altrimenti. Sia x sia n, sunnu rapprisintazzioni stringhi di na frazzioni, e hannu lu formatu siguenti, <numeratore>/<denominatore> unni sia lu numeraturi ca lu denominatori sunnu nùmmura interu pusitivi. Si pò supponiri ca x e n sunnu frazzioni validi, e nun hannu nuli comu numinaturi. simplificà "" 1/5 "", ""5/1"") = True simplificà "" 1/6 "", ""2/1"") = False simplificà "" 7/10 "", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,scn_Latn,python,"
def order_by_points(nums):
    """"""Scrivite na funzioni ca ordinà la lista di nùmmari interi in ordini crescenti secunnu la summa dî sò cifri. Nota: si ci sunnu diversi elementi cu summa simili dî sò cifri, ordinàli secunnu l'indici dâ lista urigginaria. Esempiu: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points ([]) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,scn_Latn,python,"
def specialFilter(nums):
    """"""Scrivi na funzioni ca pigghia na matriz di nùmmura comu input e torna lu nùmmuru di elementi ntâ matriz chi sunnu cchiù granni di 10 e sia la prima ca l'ùrtima cifra di nu nùmmuru sunnu dispari (1, 3, 5, 7, 9).""""""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,scn_Latn,python,"
def get_max_triples(n):
    """"""Si ti duna nu nùmmaru interu pusitivu n. Hai a criari na matrizzioni di nùmmari interu a di lunghizza n. Pi ogni i (1 ‰¤ i ‰¤ n), lu valuri di a[i] = i * i - i + 1. Ritorna lu nùmmaru di trippi (a[i], a[j], a[k]) di a unni i < j < k, e a[i] + a[j] + a[k] è nu multiplu di 3. Esempiu: Input: n = 5 Output: 1 Spiegazioni: a = [1, 3, 7, 13, 21] L'unicu tripli validu è (1, 7, 13). """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,scn_Latn,python,"
def bf(planet1, planet2):
    '''Ci sunnu ottu pianeti ntô sistema sulari: lu cchiù vicinu ô suli è Mercuriu, lu prossimu è Vèniri, appoi Terra, Marti, Giovi, Saturnu, Uranu, Nettunu. Scrivi na funzioni ca pigghia dui nomi di pianeti comu stringi pianeta1 e pianeta2. La funzioni avissi a riturnari na tupla chi cunteni tutti li pianeti ca hannu l'urbita tra l'urbita di pianeta1 e l'urbita di pianeta2, ordinati pi la vicinanza ô suli. La funzioni avissi a riturnari na tupla vacanti si pianeta1 o pianeta2 nun sunnu nomi di pianeta curretti. Esempi bf""(Giovi"", ""Niptuni"") ==> (""Saturnu"", ""Uranu"") bf(""Terra"", ""Mercuriu"") ==> (""Vèniri"", ""Terra"", ""Mars"", ""Giovi"", ""Saturnu"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,scn_Latn,python,"
def sorted_list_sum(lst):
    """"""Scrivi na funzioni ca accetta na lista di stringhi comu paramatri, cancella li stringhi ca hannu lunghizza dispari e torna la lista risurtata cu n'òrdini ordinatu. La lista è sempri na lista di stringhi e mai na matrizzioni di numari, e pò cuntèniri duplicati. L'òrdini dâ lista avissi a èssiri a nzinu a lunghizza di ogni palora, e tu avissi a riturnari la lista ordinata cu sta règula. Si dui palori hannu la stissa lunghizza, ordinari la lista alfabeticamente. La funzioni avissi a riturnari na lista di stringhi ordinati. Si pò supponiri ca tutti li palori avìanu la stissa lunghizza. P'asempiu: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => [""ab"", ""cd""]""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,scn_Latn,python,"
def x_or_y(n, x, y):
    """"""Un prugramma simplice chì deve restituisce u valore di x se n hè un numeru primu è deve restituisce u valore di y altrimenti. Esempi: per x_or_y(7, 34, 12) == 34 per x_or_y(15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,scn_Latn,python,"
def double_the_difference(lst):
    '''Datu na lista di numari, riturnari la summa dî quadrati dî numari n'a lista ca sunnu pari. Ignorari li numari ca sunnu negativi o nun interi. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Si la lista di input è vacanti, riturnari 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,scn_Latn,python,"
def compare(game,guess):
    """"""Pensu chì tutti ricordemu quella sensazione quandu u risultatu di qualchì avvenimentu tantu attesu hè finalmente cunnisciutu. I sentimenti è i pinsamenti chì avete in quellu mumentu valenu sicuramente a pena di annotà è di paragunà. U vostru compitu hè di determinà se una persona hà indovinatu currettamente i risultati di un numeru di partite. Vi sò dati dui array di punteggi è indovinate di lunghezza uguale, induve ogni indice mostra una partita. Ritorna un array di a stessa lunghezza chì indica quantu luntanu era ogni indovinamentu. Se anu indovinatu currettamente, u valore hè 0, è se no, u valore hè a differenza assoluta trà l'indovinamentu è u punteggio. esempiu: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,0,3,3] compare (([0,5,0,4,0,1,0,1,0,6]) -> [4,0,1,0,6]""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,scn_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Ti sarà datu lu nomu di na classi (na stringa) e na lista di estensioni. L'estensioni sunnu pi usari pi caricari classi addiziunali a la classi. La forza di l'estensioni è la siguenti: Sia CAP lu nùmmiru di li littri maiusculi ntô nomu di l'estensioni, e sia SM lu nùmmiru di li littri minùsculi ntô nomu di l'estensioni, la forza è data dâ frazzioni CAP - SM. Tu avissi a truvari l'estensioni cchiù forti e riturnari na stringa nta stu furmatu: ClassName.StrongestExtensionName. Si ci sunnu dui o cchiù estensioni cu la stissa forza, tu avissi a scegghiri chidda ca veni prima ntâ lista. P'asempiu, si ti sunnu dati ""Slices"" comu la classi e na lista di l'estensioni: ['SEviviSliNGCes', 'Cheese', 'StufedF'] allura tu avissi a riturnari 'Slices.SEviSliNG.SEviSliCes' 'SliviCes'mySliNGCes' (mySliviSliSEviCes'mySliSE' is strongest extension) ', l' estensioni è la cchiù forti (es: 'Extension_AA' = Strongest', p'example: '_class_Be' for 'Strongest_class');""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,scn_Latn,python,"
def cycpattern_check(a , b):
    """"""Ti sunnu dati 2 palori. Tu hai a riturnari True si la secunna palora o qualunqui di li sò rotazzioni è na suttastinga ntâ prima palora cycpattern_check(""abcd"",""abd"") => False cycpattern_check(""hello"",""ell"") => True cycpattern_check(""whassup"",""psus"") => False cycpattern_check""abab"",""baa"") => True cycpattern_check(""efef"",""eeff"") => False cycpattern_check""(hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,scn_Latn,python,"
def even_odd_count(num):
    """"""Datu nu nùmmaru nternu, riturna na tupla ca havi rispettivamenti lu nùmmaru di cifri pari e dispari. Esempiu: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,scn_Latn,python,"
def int_to_mini_roman(number):
    """"""Datu nu nùmmaru interu pusitivu, otteni lu sò equivalenti numirali rumani comu na stringa, e riturnàlu cu li littri minuri.""""""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,scn_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Data la lunghizza dî tri lati di nu triàngulu. Ritorna Vero si li tri lati formanu nu triàngulu rettangulu, Falso altrimenti. Un triàngulu rettangulu è nu triàngulu unni un angulu è rettangulu o 90 gradi. Esempiu: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == Falso '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,scn_Latn,python,"
def find_max(words):
    """"""Scrivi na funzioni ca accetta na lista di strings. La lista cunteni palori diversi. Ritorna la palora cu lu nùmmiru massimu di caratteri ùnici. Si cchiù strings hannu lu nùmmiru massimu di caratteri ùnici, ritorna chiddu ca veni prima in urdinamentu lessicugràficu.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,scn_Latn,python,"
def eat(number, need, remaining):
    """"""Tu si nu cunigghiu affamati, e già hai mangiatu nu certu nùmmiru di caroti, ma ora hai bisognu di mangiari cchiù caroti pi cumminari li pranzi di lu jornu. tu avissi a turnari na matrizzioni di [numeru tutali di caroti mangiati doppu li pranzi, lu nùmmiru di caroti lassati doppu li pranzi ] si nun ci sunnu abbastanza caroti ristanti, tu ti mangi tutti i caroti ristanti, ma ancora avissi a essiri affamati. Esempiu: * manciari ((5, 6, 10) -> [11, 4] * manciari ((4, 8, 9) -> [12, 1] * manciari ((1, 10, 10) -> [11, 0] * manciari ((2, 11, 5) -> [7, 0] Variabili: @numeru: nùmmiru interi lu nùmmiru di caroti ca haiu mangiatu. @need:: nùmmiru interi lu nùmmiru di caroti ca haiu bisognu di mangiari. @remaining:: nùmmiru interi lu nùmmiru di caroti ristanti ca esisti nta stock: *constrain: 0 = <= 0 * restant = <= 1000 * restant = <= 1000""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,scn_Latn,python,"
def do_algebra(operator, operand):
    """"""Datu dui elenchi operatore, e operand. U primu elencu havi funzioni di l'algebra basica, e u secunnu elencu è na lista di intiri. Utilizà i dui elenchi dati pi custruiri l'espressioni algèbrica e riturnari la valutazzioni di sta espressioni. L'operazioni di l'algebra basica: Aggiunta (+) Sottrazione (-)) Multiplicazzioni (*) Divisioni pianu (//) Esponenzia (**) Esempiu: operatore['+', '*', '-'] array = [2, 3, 4, 5] risultatu = 2 + 3 * 4 - 5 => risultatu = 9 Nota: La lunghizza di l'elencu di l'operatore è uguali a la lunghizza di l'elencu di l'operand menu unu. L'operand è na lista di intiri nun-negativi. L'operatore havi armenu n'operatore, e l'operand havi armenu dui operandi. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,scn_Latn,python,"
def solve(s):
    """"""Se s[i] è na littra, si nni va a mmircari la cassa da la parti bassa a la parti supiriuri o viceversa, si nun è accussì, si nun c'è na littra, si nni va a mmircari la stringa. La funzioni avissi a riturnari la stringa risultante. Esempiu solve{""1234"") = ""4321""{""ab"") = ""AB""{""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,scn_Latn,python,"
def string_to_md5(text):
    """"""Data na stringa 'text', riturnari la stringa di hash md5 equivalenti. Si 'text' è na stringa vacanti, riturnari None. >>> string_to_md5('Ciao munnu') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,scn_Latn,python,"
def generate_integers(a, b):
    """"""Datu dui nterni pusitivi a e b, riturnari li cifri pari tra a e b, n ordini crescenti.""""""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
