task_id,nl,pl,prompt,canonical_solutions,test
HumanEval/0,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⵥⵎ ⵎⴽ ⴳ ⵓⵎⵉⴹⴰⵏ ⵏ ⵓⵎⵙⵙⴰⵢ, ⵉⵍⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵙⵉⵏ ⵢⴰⴹⵏ ⵢⵓⴳⵔⵏ ⵢⴰⵏ ⵙ ⵡⵉⵢⵢⴰⴹ ⵓⴳⴳⴰⵔ ⵏ ⵓⴽⵜⵜⵓⵔ. >>> has_close_elements{(std::vector<float>{((float)1.0f, (float)2.0f, (float)3.0f})), (0.5f)) (false) >>> has_close_elements{(std::vector<float>{(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f)) (true)
bool has_close_elements(std::vector<float> numbers, float threshold) {
","bool has_close_elements(std::vector<float> numbers, float threshold) {
    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order
    for (size_t i = 1; i < numbers.size(); i++) {
        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = has_close_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));
}
"
HumanEval/1,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⵛⵛⴰⵔⵉ ⵏ ⵜⴰⵣⵣⴰⵍⵜ ⴰⴷ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⵉⵍⵍⴰⵏ ⴳⵉⵙ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵏ ⵉⴽⵛⵛⵓⵎⵏ ⵉⵎⵣⴷⴰⵖⵏ. ⴰⵡⵜⵜⴰⵙ ⵏⵏⴽ ⵉⴳⴰ ⴰⴷ ⵜⴱⴹⵓ ⵜⵔⴰⴱⴱⵓⵜ ⴰⴷ ⴳ ⵉⴽⵛⵓⵎⵏ ⵉⵎⵣⴷⴰⵖⵏ ⵉⵎⵣⴷⴰⵖⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵉⵍⴰ ⵏ ⵡⵉⵏⵏⴰ. ⵜⵔⵓⴱⴱⴰ ⵉⵎⵣⴷⴰⵖⵏ ⴳⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ (ⵢⴰⵜ ⵓⴽⵛⵓⵎ ⵉⵕⵥⵎⵏ ⵉⵜⵜⵓⵙⴷⵓⵙ ⵙ ⵜⵖⴰⵔⴰⵙⵜ) ⴷ ⵓⵔ ⵜⴱⴹⵓ ⴳ ⵓⴳⵏⵙⵓ ⵏ ⵡⵉⵢⵢⴰⴹ. "" >>> separate_paren_groups("" ((( ) ) ((( ) "") (std::vector<std::string>({(std::string) "")"", ((((()) "" (std::string) ""
std::vector<std::string> separate_paren_groups(std::string paren_string) {
","std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> groups;
    std::string current_group;
    int balance = 0;

    for (char ch : paren_string) {
        if (ch == ' ') continue;  // Ignore spaces

        current_group += ch;
        if (ch == '(') {
            balance++;
        } else if (ch == ')') {
            balance--;
            if (balance == 0) {  // Found a balanced group
                groups.push_back(current_group);
                current_group.clear();
            }
        }
    }

    return groups;
}","}
int main() {
    auto candidate = separate_paren_groups;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<std::string>({(std::string)""(()())"", (std::string)""((()))"", (std::string)""()"", (std::string)""((())()())""})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""((()))"", (std::string)""(((())))""})));
    assert(candidate((""(()(())((())))"")) == (std::vector<std::string>({(std::string)""(()(())((())))""})));
    assert(candidate((""( ) (( )) (( )( ))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""(()())""})));
}
"
HumanEval/2,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⵖ ⵏⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ, ⵉⵖ ⴰⴷ ⵏⵙⴱⴹ ⵖⵔ ⵓⴳⵣⵣⵓⵎ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ (ⴰⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⵉⵎⵥⵥⵉⵢⵏ ⵙⴳ ⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ) ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⵔⴰⵡⵏ (ⴰⴳⵣⵣⵓⵎ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ ⵉⵎⵥⵉⵢⵏ ⵙⴳ 1). ⴰⵔ ⵏⴰⴽⴽⴰ ⴰⴳⵣⵣⵓⵎ ⴰⵎⵔⴰⵡ ⵏ ⵓⵟⵟⵓⵏ. >>> truncate_number((3.5f)) (0.5f)
float truncate_number(float number) {
","float truncate_number(float number) {
    return number - std::floor(number);
}","}
int main() {
    auto candidate = truncate_number;
    assert(candidate((3.5f)) == (0.5f));
    assert(candidate((1.25f)) == (0.25f));
    assert(candidate((123.0f)) == (0.0f));
}
"
HumanEval/3,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡⵏ ⵏ ⵜⵎⴳⴳⵉⵜⵉⵏ ⵏ ⵓⵙⵙⴰⵔⵓ ⴷ ⵓⵙⵙⴰⵢ ⴳ ⵓⵎⵉⴹⴰⵏ ⵏ ⵍⴱⴰⵏⴽ ⵏⵏⴰ ⵉⵜⵜⴱⴷⵓ ⵙ ⵓⵎⵢⴰ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏ ⵉⵙ ⴳ ⴽⵔⴰ ⵏ ⵜⵉⵣⵉ ⴷⴰ ⵢⴰⴽⵡⵣ ⵓⵎⵉⴹⴰⵏ ⵏ ⵓⵎⵉⴹⴰⵏ ⵏ ⵓⵎⵉⴹⴰⵏ ⴷⴷⴰⵡ ⵓⵎⵢⴰ, ⴷ ⴳ ⵜⵉⵣⵉ ⵏⵏⴰⵖ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ ⵜⵉⴷⵜ. ⵎⴽ ⵓⵔ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ ⵜⵉⴽⵏⵉⵡⵜ. >>> below_zero(((std::vector<long>({long) 1, (long) 2, (long) 3}))) (false) >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) -4, (long) 5}))) (true)
bool below_zero(std::vector<long> operations) {
","bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for (long op : operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = below_zero;
    assert(candidate((std::vector<long>())) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));
}
"
HumanEval/4,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉ ⵓⴱⵢⵛⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵏ ⵓⴽⵛⵛⵓⵎ, ⵙⵏⵓⵎⵎⵍ ⴰⵎⵏⵣⴰⵢ ⴰⵖⵣⵓⵔⴰⵏ ⴰⵎⵎⴰⵙ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵜⵔⴰⴱⴱⵓⵜ ⵏ ⵉⵙⵎⵎⴰⵍⵏ ⴰⴷ. ⴰⵎⵏⵣⴰⵢ ⴰⵖⵣⵓⵔⴰⵏ ⴰⵎⵎⴰⵙ ⵉⴳⴰ ⴰⵎⵣⴰⵔⴰⵢ ⴰⵖⵣⵓⵔⴰⵏ ⴰⵎⵎⴰⵙ ⴳⵔ ⴽⵓ ⵉⴼⵔⴷⵉⵙ ⴷ ⵜⵏⵇⵇⵉⴹⵜ ⵜⴰⵏⴰⵎⵎⴰⵙⵜ (ⴰⵎⵎⴰⵙ ⴳ ⵡⴰⴷⴷⴰⴷ ⴰⴷ): MAD = average ∙ x - x_mean ∙ >>> mean_absolute_deviation (((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) (1.0f)
float mean_absolute_deviation(std::vector<float> numbers) {
","float mean_absolute_deviation(std::vector<float> numbers) {
    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();
    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, 
                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) 
                / numbers.size();
    return mad;
}","}
int main() {
    auto candidate = mean_absolute_deviation;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));
}
"
HumanEval/5,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⵙⴽⵛⵎ ⵓⵟⵟⵓⵏ "" ⴷⵓⵍⵉⵎⵉⵜⵔ"" ⴳⵔ ⴽⵓ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴷⴰⵢⵏ ⵏ ⵓⵎⵙⵙⵉⴹⵏ ⵏ ⵓⴽⵛⵛⵓⵎ ""ⴹⵓⵏⵓⵎⴱⵉⵔⵙ"" >>> ⵉⵏⵜⵉⵔⵙⴱⵉⵔⵙ (((ⵙⵜⴷ:ⵎⵙⵙⵉⴹⵏ<ⴳⵣⵣⴰⵢ>)), (4)) (ⵙⵜⴷ:ⵎⵙⵙⵉⴹⵏ<ⴳⵣⵣⴰⵢ>)) >>> ⵉⵏⵜⵉⵔⵙⴱⵉⵔⵙ (((ⵙⵜⴷ:ⵎⵙⵙⵉⴹⵏ<ⴳⵣⵣⴰⵢ>{ⴳⵣⵣⴰⵢ) 1, (ⴳⵣⵣⴰⵢ) 2, (ⴳⵣⵣⴰⵢ) 3})), (4)) (ⵙⵜⴷ:ⵎⵙⵙⵉⴹⵏ<ⴳⵣⵣⴰⵢ>{ⴳⵣⵣⴰⵢ) 1, (ⴳⵣⵣⴰⵢ) 4, (ⴳⵣⵣⴰⵢ) 2, (ⴳⵣⵣⴰⵢ) 4, (ⴳⵣⵣⴰⵢ) 3}))
std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
","std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    if (numbers.empty()) return numbers;

    std::vector<long> result;
    for (size_t i = 0; i < numbers.size(); i++) {
        result.push_back(numbers[i]);
        if (i < numbers.size() - 1) {
            result.push_back(delimeter);
        }
    }
    return result;
}","}
int main() {
    auto candidate = intersperse;
    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));
    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));
}
"
HumanEval/6,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⵙⴽⴰⵔ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵡⵓⵔⵉ ⴰⴷ ⵙ ⵢⴰⵜ ⵜⵉⴼⵔⴽⵜ ⵉⵙⵎⴷⵢⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵉ ⵜⴱⵕⴰⵏⴽⵉⵙⵜⵉⵏ ⵉⵜⵜⵓⵙⵎⵓⵏⵏ ⵉⴱⴹⴰⵏ ⵙ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵉ ⴽⵓ ⵜⵔⴰⴱⴱⵓⵜ, ⵙⵙⵓⴼⵖ ⴰⵙⵡⵉⵔ ⵏ ⵓⵙⵎⵓⵏ ⵏ ⵜⴱⵕⴰⵏⴽⵉⵙⵜⵉⵏ. ⵙ ⵓⵎⴷⵢⴰ (() (()) ⵖⵓⵔⵙ ⵙⵉⵏ ⵉⵙⵡⵉⵔⵏ ⵏ ⵓⵙⵎⵓⵏ ⴳ ⵜⵉⵣⵉ ⵏⵏⴰ ⴳ ⵖⵓⵔ ((())) ⵖⵓⵔⵙ ⴽⵕⴰⴹ. >>> parse_nested_parens ((((((()) ((())) () (((()))))) (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))
std::vector<long> parse_nested_parens(std::string paren_string) {
","std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> depths;
    long current_depth = 0, max_depth = 0;

    for (char ch : paren_string) {
        if (ch == ' ') {
            if (max_depth > 0) {
                depths.push_back(max_depth);
                max_depth = 0;
            }
            current_depth = 0;
        } else if (ch == '(') {
            current_depth++;
            max_depth = std::max(max_depth, current_depth);
        } else if (ch == ')') {
            current_depth--;
        }
    }

    if (max_depth > 0) {
        depths.push_back(max_depth);
    }

    return depths;
}","}
int main() {
    auto candidate = parse_nested_parens;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((""(()(())((())))"")) == (std::vector<long>({(long)4})));
}
"
HumanEval/7,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⵙⴼⵉⵍⵜⵔ ⵉ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵏ ⴷⴷⴰⵡ ⵏ ⵓⴽⵙⴰⵢ >>> filter_by_substring(((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_substring((((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""cde"", (std::string) ""array""})), (""a"") (std::vector<std::string>(({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""array""}))
std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
","std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_substring;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""aaaxxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""aaaxxy"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""grunt"", (std::string)""trumpet"", (std::string)""prune"", (std::string)""gruesome""})), (""run"")) == (std::vector<std::string>({(std::string)""grunt"", (std::string)""prune""})));
}
"
HumanEval/8,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉ ⵓⵎⵉⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⴽⵛⵎ ⵜⴰⴱⵔⵣⴰ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵎⴹⴰⵏ ⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ. ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⴷⴷⴰⴷ 0 ⴷ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⴷⴷⴰⴷ ⴰⵎⴷⴷⴰⴷ 1. >>> sum_product((std::vector<long>())) (std::make_tuple(0, 1)) >>> sum_product(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple(10, 24))
std::tuple<long, long> sum_product(std::vector<long> numbers) {
","std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);
    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());
    return std::make_tuple(sum, product);
}","}
int main() {
    auto candidate = sum_product;
    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));
    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));
    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));
}
"
HumanEval/9,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴳ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⵓⴽⵙⴰⵢ ⴰⵎⵇⵔⴰⵏ ⵉⵜⵜⵢⴰⴼⴰⵏ ⴰⵔ ⵜⵉⵣⵉ ⵉⵜⵜⵢⴰⴼⴰⵏ ⴳ ⵓⵙⵏⵙⵍ. >>> rolling_max(((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 3, (long) 4, (long) 2}))) (std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4}))
std::vector<long> rolling_max(std::vector<long> numbers) {
","std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> result;
    long max_so_far = LONG_MIN;

    for (long num : numbers) {
        max_so_far = std::max(max_so_far, num);
        result.push_back(max_so_far);
    }

    return result;
}","}
int main() {
    auto candidate = rolling_max;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));
}
"
HumanEval/10,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴹⴼⵔ ⴰⵎⵣⵔⵓⵢ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵙ ⵜⵉⴼⵉⵏⴰⵖ. ⵜⴰⵡⵏⴳⵉⵎⵜ ⵏ ⴰⵍⴳⵓⵔⵉⵜⵎ ⵜⴳⴰ ⵜⵓⵏⵙⵉⵖⵜ: - ⴹⴼⵔ ⴰⵎⵣⵔⵓⵢ ⵏ ⵜⵢⵉⵔⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⵉⴳⴰⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ. - ⵔⵏⵓ ⵖⵔ ⵜⴳⵉⵔⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵜⴰⴳⴰⵍⵜ ⵏ ⵜⵢⵉⵔⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⵉⵜⵜⴰⴷⴼⵏ ⴷⴰⵜ ⵜⵢⵉⵔⴰ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ. >>> make_palindrome(("""")) ("""") >>> make_palindrome((""cat"")) (""catac"") >>> make_palindrome((""cata"")) (""catac"")
std::string make_palindrome(std::string string) {
","std::string make_palindrome(std::string string) {
    auto is_palindrome = [](const std::string &s) {
        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());
    };

    for (size_t i = 0; i < string.size(); ++i) {
        if (is_palindrome(string.substr(i))) {
            std::string prefix = string.substr(0, i);
            std::reverse(prefix.begin(), prefix.end());
            return string + prefix;
        }
    }

    return string;
}","}
int main() {
    auto candidate = make_palindrome;
    assert(candidate(("""")) == (""""));
    assert(candidate((""x"")) == (""x""));
    assert(candidate((""xyz"")) == (""xyzyx""));
    assert(candidate((""xyx"")) == (""xyx""));
    assert(candidate((""jerry"")) == (""jerryrrej""));
}
"
HumanEval/11,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⵉⵏⵜⵓⵔⵙ ⴳⴰⵏ ⵙⵉⵏ ⵉⵙⵉⴹⵏⵏ a ⴷ b ⴳ ⵍⵍⴰⵏ 1 ⴷ 0 ⴷⴰⵢ. ⵙⴽⵔ XOR ⴱⵉⵏⴰⵔⵉ ⵅⴼ ⵉⵙⵉⴹⵏⵏ ⴰⴷ ⴷ ⵜⵔⴰⵔⵓⵜ ⵏ ⵜⵢⴰⴼⵓⵜ ⴰⵡⴷ ⵏⵜⵜⴰⵜ ⵜⴳⴰ ⴰⵙⵉⴹⵏ. >>> string_xor((""010""), (""110"")) (""100"")
std::string string_xor(std::string a, std::string b) {
","std::string string_xor(std::string a, std::string b) {
    std::string result;
    for (size_t i = 0; i < a.size(); ++i) {
        result += (a[i] == b[i]) ? '0' : '1';
    }
    return result;
}","}
int main() {
    auto candidate = string_xor;
    assert(candidate((""111000""), (""101010"")) == (""010010""));
    assert(candidate((""1""), (""1"")) == (""0""));
    assert(candidate((""0101""), (""0000"")) == (""0101""));
}
"
HumanEval/12,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴳ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵙⵓⵍⵖ ⵓⵢⵣⵉⵣⵔ. ⵙⵓⵍⵖ ⵓⵢⵣⵉⵣⵔ ⴰⵎⵣⵡⴰⵔⵓ ⴳ ⵡⴰⴷⴷⴰⴷ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵏ ⵜⵉⵖⵣⵉ ⵉⵎⵎⵔⵡⴰⵙⵏ. ⵙⵓⵍⵖ ⵓⵍⴰ ⴳ ⵡⴰⴷⴷⴰⴷ ⵏ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⵉⴳⴰⵏ ⵡⴰⴽⴰⵍ. >>> longest(((std::vector<std::string>())) std::nullopt >>> longest(((std::vector<std::string>{((std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) ""a"" >>> longest(((std::vector<std::string>(((std::string) ""a"", (std::string) ""bb"", (stdstring) ""ccc""}))) ""ccc""
std::optional<std::string> longest(std::vector<std::string> strings) {
","std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) return std::nullopt;

    return *std::max_element(strings.begin(), strings.end(), 
                             [](const std::string& a, const std::string& b) {
                                 return a.size() < b.size();
                             });
}","}
int main() {
    auto candidate = longest;
    assert(candidate((std::vector<std::string>())) == std::nullopt);
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == ""x"");
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""yyy"", (std::string)""zzzz"", (std::string)""www"", (std::string)""kkkk"", (std::string)""abc""}))) == ""zzzz"");
}
"
HumanEval/13,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⴰⵎⵟⵟⵓ ⴰⵎⵢⵉⵡⵏ ⴰⵅⴰⵜⴰⵔ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⴷ b >>> greatest_common_divisor (((3), (5)) (1) >>> greatest_common_divisor (((25), (15)) (5)
long greatest_common_divisor(long a, long b) {
","long greatest_common_divisor(long a, long b) {
    return std::gcd(a, b);
}","}
int main() {
    auto candidate = greatest_common_divisor;
    assert(candidate((3), (7)) == (1));
    assert(candidate((10), (15)) == (5));
    assert(candidate((49), (14)) == (7));
    assert(candidate((144), (60)) == (12));
}
"
HumanEval/14,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⴽⵡⵣ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⴽⵓⵍⵍⵓ ⵉⵙⵏⴼⴰⵔⵏ ⵙⴳ ⵓⵥⵥⵉⵢⵏ ⴰⵔ ⵓⵣⵣⵓⴳⵣ ⵏ ⵜⵣⵍⵉⵜ ⵏ ⵓⵙⴽⵛⵎ >>> all_prefixes (((""abc"")) (std::vector<std::string>({(std::string) ""a"", (std::string) ""ab"", (std::string) ""abc""}))
std::vector<std::string> all_prefixes(std::string string) {
","std::vector<std::string> all_prefixes(std::string string) {
    std::vector<std::string> prefixes;
    for (size_t i = 1; i <= string.size(); ++i) {
        prefixes.push_back(string.substr(0, i));
    }
    return prefixes;
}","}
int main() {
    auto candidate = all_prefixes;
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""asdfgh"")) == (std::vector<std::string>({(std::string)""a"", (std::string)""as"", (std::string)""asd"", (std::string)""asdf"", (std::string)""asdfg"", (std::string)""asdfgh""})));
    assert(candidate((""WWW"")) == (std::vector<std::string>({(std::string)""W"", (std::string)""WW"", (std::string)""WWW""})));
}
"
HumanEval/15,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵙⵏⴼⵍⵓⵍ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵜⵜⵓⵙⵏⴱⴹⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ ⵙⴳ 0 ⴰⵔ n ⵙ ⵜⵓⵎⵔⵜ. >>> string_sequence((0)) (""0"") >>> string_sequence((5)) (""0 1 2 3 4 5"")
std::string string_sequence(long n) {
","std::string string_sequence(long n) {
    std::ostringstream oss;
    for (long i = 0; i <= n; ++i) {
        if (i > 0) oss << "" "";
        oss << i;
    }
    return oss.str();
}","}
int main() {
    auto candidate = string_sequence;
    assert(candidate((0)) == (""0""));
    assert(candidate((3)) == (""0 1 2 3""));
    assert(candidate((10)) == (""0 1 2 3 4 5 6 7 8 9 10""));
}
"
HumanEval/16,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴽⵙⵉⵣ"" (ⴽⵙⵉⵣ) (3) ""ⴽⵙⵉⵣ"" (ⴽⵙⵉⵣ) (4)
long count_distinct_characters(std::string string) {
","long count_distinct_characters(std::string string) {
    std::unordered_set<char> distinct_chars;
    for (char ch : string) {
        distinct_chars.insert(std::tolower(ch));
    }
    return distinct_chars.size();
}","}
int main() {
    auto candidate = count_distinct_characters;
    assert(candidate(("""")) == (0));
    assert(candidate((""abcde"")) == (5));
    assert(candidate((""abcdecadeCADE"")) == (5));
    assert(candidate((""aaaaAAAAaaaa"")) == (1));
    assert(candidate((""Jerry jERRY JeRRRY"")) == (5));
}
"
HumanEval/17,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⵛⵛⴰⵔⴻⵎ ⵏ ⵜⴰⵍⴻⵎⵙⴰ ⵜⴰ-ⴰ ⴻⵈⵈⴰⵍ ⴰⵛⴰⵔⴻⵎ ⵉⵙⵎⴰⵍ ⵏⴻⵏⵜ ⵎⵓⵙⵉⴾ ⴷⴰⵗ ⴰⵙⵛⵉⵉⴻ. ⴰⵛⴰⵔⴻⵎ ⵏⴻⵜ ⴻⵈⵈⴰⵍ ⴰⴾⴰⵉⴰⴷ ⵏ ⴰⵛⴰⵔⴻⵎ ⵏ ⴻⵜⴻⴶⵔⴻ ⵜⴰⵏ ⵓⵉ ⵉⴾⵏⴰⵏⴻⵏ ⴰⵋⴻⵏ ⵏ ⵜⵉⵛⵉⵋⵔⵉⵜⴻⵏ. ⴻⵂⴰ ⴰⴾⴰⵜⴰⴱ: 'o' ⵏⵓⵜⴻ, ⵓⵉ ⴰⵔⴰⴾⴰⵏⴻⵏ ⴰⴾⴾⵓⵣ ⵏ ⵜⵉⵛⵉⵋⵔⵉⵜⴻⵏ 'o"" ⵏⴻⵜ - ⵋⴰⵔⴰⵜ ⵏ ⵜⵉⵛⵉⵋⵔⵉⵜⴻⵏ, ⵓⵉ ⴰⵔⴰⴾⴰⵏⴻⵏ ⵙⴰⵏⴰⵜ ⵜⵉⵛⵉⵋⵔⵉⵜⴻⵏ - ⵋⴰⵔⴰⵜ ⵏ ⵜⵉⵛⵉⵋⵔⵉⵜⴻⵏ, ⵓⵉ ⴰⵔⴰⴾⴰⵏⴻⵏ ⵙⴰⵏⴰⵜ ⵜⵉⵛⵉⵋⵔⵉⵜⴻⵏ - ⵓⵉ ⴰⵔⴰⴾⴰⵏⴻⵏ ⵜⴰⴾⵓⵣⴻⵏ, ⵓⵉ ⴰⵔⴰⴾⴰⵏⴻⵏ ⵜⴰⴾⵓⵣⴻⵏ - ⵓⵉ ⴰⵔⴰⴾⴰⵏⴻⵏ, ⵓⵉ ⴰⵔⴰⴾⴰⵏⴻⵏ ⵜⴰⴾⴾⴾⴾⴰⵜⴰⴱⴰⵜⴻⵏ, ⵓⵉ ⴰⵔⴰⴾⴾⴾⴰⵏⴻⵏ ⵜⵉⴾⴰⵜⴰⴱⴰⵜⴻⵏ, ⵓⵉ ⴰⵔⴰⴾⴾⴰⵏ ⵜⵉⴾⴰⵜⴻⵏ""
std::vector<long> parse_music(std::string music_string) {
","std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::istringstream iss(music_string);
    std::string note;
    
    while (iss >> note) {
        if (note == ""o"") beats.push_back(4);
        else if (note == ""o|"") beats.push_back(2);
        else if (note == "".|"") beats.push_back(1);
    }

    return beats;
}","}
int main() {
    auto candidate = parse_music;
    assert(candidate(("""")) == (std::vector<long>()));
    assert(candidate((""o o o o"")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate(("".| .| .| .|"")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));
    assert(candidate((""o| o| .| .| o o o o"")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));
    assert(candidate((""o| .| o| .| o o| o o|"")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));
}
"
HumanEval/18,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⵥⵎ ⵎⴰⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵉⵖⵢ ⴰⴷ ⵢⵉⵍⵉ ⵓⵙⵏⴼⵍⵓⵍ ⴳ ⵜⵣⵍⵉⵜ ⵜⴰⵢⵎⵎⴰⵜ. ⵔⵥⵎ ⵉⵙⴽⴽⵉⵏⵏ ⵏⵏⴰ ⵉⵜⵜⵎⵙⴰⵙⴰⵏ. >>> how_many_times((""""), (""a"")) (0) >>> how_many_times(""aaa""), (""a"") (3) >>> how_many_times(""aaaa""), (""aa"") (3)
long how_many_times(std::string string, std::string substring) {
","long how_many_times(std::string string, std::string substring) {
    if (substring.empty()) return 0;
    
    long count = 0;
    size_t pos = 0;
    
    while ((pos = string.find(substring, pos)) != std::string::npos) {
        count++;
        pos++;  // Move one position forward to count overlapping occurrences
    }
    
    return count;
}","}
int main() {
    auto candidate = how_many_times;
    assert(candidate((""""), (""x"")) == (0));
    assert(candidate((""xyxyxyx""), (""x"")) == (4));
    assert(candidate((""cacacacac""), (""cac"")) == (4));
    assert(candidate((""john doe""), (""john"")) == (1));
}
"
HumanEval/19,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⵉⴽⴽⵉ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⵏⴱⴹⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ ⵙⴳ ""ⴰⵎⵢⴰ"" ⴰⵔ ""ⵜⵥⴰ"". ⵉⵙⵜⴰⵢⵏ ⵉⵣⵔⴼⴰⵏ ⴳⴰⵏ ""ⴰⵎⵢⴰ"", ""ⵢⵉⵡⵏ"", "" ⵙⵉⵏ"", "" ⴽⵕⴰⴹ"", ""ⴽⴽⴽⵓⵥ"", ""ⵎⵎⵓⵙ"", ""ⵚⴹⵉⵚ"", ""ⴰⵙⵙⴰ"", ""ⵜⴰⵎⵔⴰⵡ"" ⴷ ""ⵜⵥⴰ"". ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵓⴽⵙⵉⵍ ⵙ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙⴳ ⵓⵥⵥⴰⵏ ⴰⵔ ⵓⵅⴰⵜⴰⵔ >>> sort_numbers ((("" ⴽⵕⴰⴹ ⵢⴰⵏ ⵙⵎⵎⵓⵙ"")) ("" ⵢⴰⵏ ⴽⵕⴰⴹ ⵙⵎⵎⵓⵙ"")
std::string sort_numbers(std::string numbers) {
","std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, int> num_map = {
        {""zero"", 0}, {""one"", 1}, {""two"", 2}, {""three"", 3}, {""four"", 4},
        {""five"", 5}, {""six"", 6}, {""seven"", 7}, {""eight"", 8}, {""nine"", 9}
    };

    std::unordered_map<int, std::string> rev_map = {
        {0, ""zero""}, {1, ""one""}, {2, ""two""}, {3, ""three""}, {4, ""four""},
        {5, ""five""}, {6, ""six""}, {7, ""seven""}, {8, ""eight""}, {9, ""nine""}
    };

    std::istringstream iss(numbers);
    std::vector<int> num_list;
    std::string word;

    while (iss >> word) {
        num_list.push_back(num_map[word]);
    }

    std::sort(num_list.begin(), num_list.end());

    std::ostringstream oss;
    for (size_t i = 0; i < num_list.size(); ++i) {
        if (i > 0) oss << "" "";
        oss << rev_map[num_list[i]];
    }

    return oss.str();
}","}
int main() {
    auto candidate = sort_numbers;
    assert(candidate(("""")) == (""""));
    assert(candidate((""three"")) == (""three""));
    assert(candidate((""three five nine"")) == (""three five nine""));
    assert(candidate((""five zero four seven nine eight"")) == (""zero four five seven eight nine""));
    assert(candidate((""six five four three two one zero"")) == (""zero one two three four five six""));
}
"
HumanEval/20,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⵎⵔⴰⵙⵏ (ⵙ ⵜⵉⵖⵣⵉ ⵏⵏⵙ ⵓⵔ ⵉⴷⵔⵓⵙⵏ ⵙⵉⵏ), ⵙⵜⴰⵢ ⴷ ⵙⵏⵓⵍⴼⵓ ⵙⵉⵏ ⵡⵉⵏⵏⴰ ⵉⴳⴳⵓⴳⵏ ⴳⵔⵙⵏ ⴷ ⵙⵏⵓⵍⴼⵓ ⵙ ⵓⵙⵓⴷⵙ (ⵉⴹ ⴰⵎⵥⵥⵢⴰⵏ, ⵡⵉⴹ ⴰⵎⵇⵔⴰⵏ). >>> find_closest_elements{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}}{}{}{}{}{}{}{}}{}{}}{}}{}{}}{}{}}{}}{}{}}}{}{}}{}}}{}}{}{}}}{}}{}}{}}{}}{}}{}}{}}}{}}{}}{}}{}}{}}{}}}{}}{}}}{}}{}}{}}{}}}}{}}}{}}}{}{}}}}{}}{}}{}}}}{}}}{}}}{}{}}}{}}{}}}}}{}}}{}}}{}}}}{}}}{}}}}{}}}}{}}}}}{}}}{}}{}}{}}}}}{}}{}}}{}}}}{}}}{}}}}{}}}}}{}}{}}}{}}}}{}}}{}}}}}{}}{}}}}}{}{}}}}{}}}}{}{}}}}}{}}}}
std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
","std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    std::sort(numbers.begin(), numbers.end());
    float min_diff = std::numeric_limits<float>::max();
    float num1 = 0, num2 = 0;

    for (size_t i = 1; i < numbers.size(); ++i) {
        float diff = numbers[i] - numbers[i - 1];
        if (diff < min_diff) {
            min_diff = diff;
            num1 = numbers[i - 1];
            num2 = numbers[i];
        }
    }

    return std::make_tuple(num1, num2);
}","}
int main() {
    auto candidate = find_closest_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));
}
"
HumanEval/21,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵓⵎⵉⴹⴰⵏ ⵏ ⵓⵎⵙⵙⵉⴹⵏ (ⵙ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⴷⵖⴰⵔ), ⵙⵙⵎⵔⵙⵏ ⴰⵙⵏⴼⵍ ⴰⵎⵉⵔⵉⵡ ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⴷ, ⴰⵢⵏⵏⴰⵖ ⴰⵙ ⴰⵎⵉⴹⴰⵏ ⴰⵎⵥⵥⵢⴰⵏ ⴰⴷ ⵉⴳ 0 ⴷ ⴰⵎⵉⴹⴰⵏ ⴰⵎⵇⵔⴰⵏ ⴰⴷ ⵉⴳ 1 >>> rescale_to_unit ((((std::vector<float>(({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f}))) (std::vector<float>(({(float) 0.0f, (float) 0.25f, (float) 0.5f, (float) 0.75f, (float) 1.0f}))
std::vector<float> rescale_to_unit(std::vector<float> numbers) {
","std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    float min_val = *std::min_element(numbers.begin(), numbers.end());
    float max_val = *std::max_element(numbers.begin(), numbers.end());

    if (min_val == max_val) {
        std::fill(numbers.begin(), numbers.end(), 0.0f);
        return numbers;
    }

    for (float &num : numbers) {
        num = (num - min_val) / (max_val - min_val);
    }

    return numbers;
}","}
int main() {
    auto candidate = rescale_to_unit;
    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
}
"
HumanEval/22,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⴼⵉⵍⵜⵔ ⴼⵉⴽⵜⵓⵔ ⵏ ⴽⵓ ⵡⴰⵜⵉⴳ ⵏ ⴽⵓⴱⴱⵜⵓⵏ ⵉ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ >>> filter_integers((std::vector<std::any>({(std::string) ""a"", (std::string)3.14f, (std::string)5}))) (std::vector<long>({(long) 5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, ""abc"", std::<long,map>), std::vector<long>()))) (std::vector<long>({(long) 1, (long) 2, (long) 3}))
std::vector<long> filter_integers(std::vector<std::any> values) {
","std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (const auto& val : values) {
        if (val.type() == typeid(long)) {
            result.push_back(std::any_cast<long>(val));
        } else if (val.type() == typeid(int)) {
            result.push_back(std::any_cast<int>(val));
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_integers;
    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));
    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, ""adasd""}))) == (std::vector<long>({(long)4, (long)9})));
    assert(candidate((std::vector<std::any>({3, ""c"", 3, 3, ""a"", ""b""}))) == (std::vector<long>({(long)3, (long)3, (long)3})));
}
"
HumanEval/23,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⵖⵣⵉ ⵏ ⵜⵉⴼⵉⵏⴰⵖ >>> string_length(("""")) (0) >>> string_length((""abc"")) (3)
long string_length(std::string string) {
","long string_length(std::string string) {
    return string.length();
}","}
int main() {
    auto candidate = string_length;
    assert(candidate(("""")) == (0));
    assert(candidate((""x"")) == (1));
    assert(candidate((""asdasnakj"")) == (9));
}
"
HumanEval/24,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉ ⵓⵎⴹⴰⵏ n, ⴷⴼⴽ ⴰⵎⴹⴰⵏ ⴰⵅⴰⵜⴰⵔ ⵏⵏⴰ ⵉⵜⵜⴱⴹⵓⵏ n ⵙ ⵜⴰⵖⴹⴼⵜ, ⴷ ⵡⵉⵏⵏⴰ ⵎⵥⵥⵉⵢⵏ ⵙⴳ n >>> largest_divisor (((15)) (5)
long largest_divisor(long n) {
","long largest_divisor(long n) {
    for (long i = n / 2; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return 1;
}","}
int main() {
    auto candidate = largest_divisor;
    assert(candidate((3)) == (1));
    assert(candidate((7)) == (1));
    assert(candidate((10)) == (5));
    assert(candidate((100)) == (50));
    assert(candidate((49)) == (7));
}
"
HumanEval/25,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⵖⵓⵍ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴳⴳⵉⵜⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⴱⵔⵉⴷ ⵙⴳ ⵓⵥⵥⵉⵏ ⴰⵔ ⵓⵅⴰⵜⴰⵔ. ⴽⵓ ⵢⴰⵏ ⴳ ⵉⵎⴳⴳⵉⵜⵏ ⴰⴷ ⵉⵜⵜⵓⵙⴽⴰⵔ ⵙ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴷⴰ ⵉⵜⵜⵓⴳⴰ ⴳ ⵓⵙⴼⵙⵉ. ⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⴷ ⵉⴳ ⴰⵎⵎ ⵜⵢⴰⴼⵓⵜ ⵏ ⵉⵎⴳⴳⵉⵜⵏ ⴰⴽⴽⵡ >>> ⵉⵙⴽⵔ (((8)) (std::vector<long>({(long)2, (long)2, (long)2})) >>> ⵉⵙⴽⵔ (((25)) (std::vector<long>({(long)5, (long)5})) >>> ⵉⵙⴽⵔ ((((70)))
std::vector<long> factorize(long n) {
","std::vector<long> factorize(long n) {
    std::vector<long> factors;
    for (long i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;
}","}
int main() {
    auto candidate = factorize;
    assert(candidate((2)) == (std::vector<long>({(long)2})));
    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));
    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));
    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));
    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));
    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));
}
"
HumanEval/26,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⵉⴼⵔⴷⵉⵙⵏ ⴰⴽⴽⵡ ⵏⵏⴰ ⵉⵜⵜⵊⵕⴰⵏ ⵓⴳⴳⴰⵔ ⵏ ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ. ⵃⴹⵓ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵇⵇⵉⵎⵏ ⴰⵎⵎ ⵡⵉⵏⵏⴰ ⵉⵜⵜⵓⵣⵎⵎⴻⵎⵏ ⴳ ⵓⴽⵛⵛⵓⵎ. >>> remove_duplicates(((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 4}))) (std::vector<long>({(long) 1, (long) 3, (long) 4}))
std::vector<long> remove_duplicates(std::vector<long> numbers) {
","std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> freq;
    for (long num : numbers) {
        freq[num]++;
    }

    std::vector<long> result;
    for (long num : numbers) {
        if (freq[num] == 1) {
            result.push_back(num);
        }
    }

    return result;
}","}
int main() {
    auto candidate = remove_duplicates;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));
}
"
HumanEval/27,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ, ⵙⵙⵓⵜⵍ ⵉⵎⵙⴽⴰⵔⵏ ⵉⵎⵥⵥⵉⵏ ⵙ ⵉⵎⵥⵥⵉⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴷ ⵉⵎⵥⵥⵉⵏ ⵉⵎⵇⵔⴰⵏⵏ. >>> flip_case (((""Hello"")) (""HELLO"")
std::string flip_case(std::string string) {
","std::string flip_case(std::string string) {
    for (char &ch : string) {
        if (std::islower(ch)) {
            ch = std::toupper(ch);
        } else if (std::isupper(ch)) {
            ch = std::tolower(ch);
        }
    }
    return string;
}","}
int main() {
    auto candidate = flip_case;
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hello!"")) == (""hELLO!""));
    assert(candidate((""These violent delights have violent ends"")) == (""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""));
}
"
HumanEval/28,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴽⵓⵏⵛⴰⵜⵉⵏⴰⵜⵢ ⴼⵉⴽⵜⵓⵔ ⵏ ⵙⵜⵔⵉⵏⴳⵙ ⴳ ⵢⴰⵏ ⵙⵜⵔⵉⵏⴳ >>> ⴽⵓⵏⵛⴰⵜⵉⵏⴰⵜⵢ ((((ⵙⵜⴷ::ⴼⵉⴽⵜⵓⵔ<ⵙⵜⴷ::ⵙⵜⵔⵉⵏⴳ>())) ("""") >>> ⴽⵓⵏⵛⴰⵜⵉⵏⴰⵜⵢ (((ⵙⵜⴷ::ⴼⵉⴽⵜⵓⵔ<ⵙⵜⴷ::ⵙⵜⵔⵉⵏⴳ>({ⵙⵜⴷ::ⵙⵜⵔⵉⵏⴳ) ""ⴰ"", (ⵙⵜⴷ::ⵙⵜⵔⵉⵏⴳ) ""ⴱ"", (ⵙⵜⴷ::ⵙⵜⵔⵉⵏⴳ) ""ⵛ""}))) (""ⴰⴱⴽ"")
std::string concatenate(std::vector<std::string> strings) {
","std::string concatenate(std::vector<std::string> strings) {
    std::string result;
    for (const auto& str : strings) {
        result += str;
    }
    return result;
}","}
int main() {
    auto candidate = concatenate;
    assert(candidate((std::vector<std::string>())) == (""""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == (""xyz""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z"", (std::string)""w"", (std::string)""k""}))) == (""xyzwk""));
}
"
HumanEval/29,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵓⵎⵙⵙⵉⵣⵡⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵉⴼⵔⵉⵙⵉⵏ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⵉⵙⵙⵏⵜⵉⵢⵏ ⵙ ⵢⴰⵏ ⵓⵣⵡⵍ. >>> filter_by_prefix((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bcd"", (std::string)::""cde"", (stdstring) ""array""})), (""a"") (std::vector<std::string>({(std::string) ""abc"", (std::string) ""array""}))
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
","std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_prefix;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
}
"
HumanEval/30,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⴷⴰⵢ ⵉⵎⴹⴰⵏ ⵉⴳⴳⵓⴷⵉⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ. >>> get_positive((std::vector<long>({long) -1, (long) -2, (long) -4, (long) -5, (long) -6}))) (std::vector<long>({long) -2, (long) -5, (long) -6})) >>> get_positive((std::vector<long>({(long) -5, (long) -3, (long) -5, (long) -2, (long) -3, (long) -3, (long) -9, (long) -0, (long) -123, (long) -1, (long) -10}))) (std::vector<long>{(long) -5, (long) -3, (long) -2, (long) -3, (long) -9, (long) -123, (long) -1}))
std::vector<long> get_positive(std::vector<long> l) {
","std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> result;
    for (long num : l) {
        if (num > 0) {
            result.push_back(num);
        }
    }
    return result;
}","}
int main() {
    auto candidate = get_positive;
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));
    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/31,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⵍⵙ ⵜⵉⴷⵜ ⵉⵖ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⴽⴽⵡ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵜⵉⴱⴹⵉ ⵎⴽ ⵓⵔ ⵉⴳⵉ. >>> is_prime((6)) (false) >>> is_prime((101)) (true) >>> is_prime((11) (true) >>> is_prime((13441)) (true) >>> is_prime(61)) (true) >>> is_prime(4)) (false) >>> is_prime(1) (false)
bool is_prime(long n) {
","bool is_prime(long n) {
    if (n < 2) return false;
    if (n < 4) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_prime;
    assert(candidate((6)) == (false));
    assert(candidate((101)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((13441)) == (true));
    assert(candidate((61)) == (true));
    assert(candidate((4)) == (false));
    assert(candidate((1)) == (false));
    assert(candidate((5)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((17)) == (true));
    assert(candidate((85)) == (false));
    assert(candidate((77)) == (false));
    assert(candidate((255379)) == (false));
}
"
HumanEval/33,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⵎⵥ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵢⴰⵏ ⵓⴽⵜⵓⵔ l ⴰⵔ ⵜⵔⴰⵔ ⵢⴰⵏ ⵓⴽⵜⵓⵔ l' ⵣⵓⵏⴷ ⵉⵙ ⵉⴳⴰ l ⴰⵎⵎ ⵓⴽⵜⵓⵔ ⵏ l ⴳ ⵡⴰⵏⵙⵉⵡⵏ ⵏⵏⴰ ⵓⵔ ⵉⵜⵜⵓⵣⵟⵟⴰⵢⵏ ⵙ ⴽⵕⴰⴹ, ⵎⴰⵛⴰ ⵜⵉⵏⵉⴳⵉⵏ ⵏⵏⵙ ⴳ ⵡⴰⵏⵙⵉⵡⵏ ⵏⵏⴰ ⵉⵜⵜⵓⵣⵟⵟⴰⵢⵏ ⵙ ⴽⵕⴰⴹ ⴳⴰⵏ ⵡⴰⵜⵉⴳⵏ ⵏ ⵡⴰⵏⵙⵉⵡⵏ ⵏ l, ⵎⴰⵛⴰ ⵜⵜⵓⵙⵎⵉⵍⵏ. >>> sort_third(((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_third((std::vector<long>{(long) 5, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 2}))) (std::vector<(long>{(long>2, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 5}))
std::vector<long> sort_third(std::vector<long> l) {
","std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> third_indices;
    for (size_t i = 0; i < l.size(); i += 3) {
        third_indices.push_back(l[i]);
    }
    std::sort(third_indices.begin(), third_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 3) {
        l[i] = third_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_third;
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));
}
"
HumanEval/34,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⴷⴼ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵥⵍⴰⵢⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⴳ ⵓⵎⵙⵙⵉⵔⵉ >>> unique((std::vector<long>({(long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 0, (long) 2, (long) 3, (long) 5, (long) 9, (long) 123}))
std::vector<long> unique(std::vector<long> l) {
","std::vector<long> unique(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    l.erase(std::unique(l.begin(), l.end()), l.end());
    return l;
}","}
int main() {
    auto candidate = unique;
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));
}
"
HumanEval/35,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵎⵙⴽⴰⵔ ⴰⵎⵇⵔⴰⵏ ⴳ ⵓⵎⵙⴽⴰⵔ. >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long)-5, (long) 2, (long)-3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (123)
long max_element(std::vector<long> l) {
","long max_element(std::vector<long> l) {
    return *std::max_element(l.begin(), l.end());
}","}
int main() {
    auto candidate = max_element;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));
}
"
HumanEval/36,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵜⵜⴼⴼⵖ ⵓⵟⵟⵓⵏ 7 ⴳ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵥⵥⵉⵏ ⵏⵏⴰ ⵓⵔ ⵢⴰⴳⴳⵓⴳⵏ ⵏ n ⵏⵏⴰ ⵉⵜⵜⵓⵢⴱⴹⴰⵏ ⵙ 11 ⵏⵖⴷ 13. >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)
long fizz_buzz(long n) {
","long fizz_buzz(long n) {
    long count = 0;
    for (long i = 0; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            long temp = i;
            while (temp > 0) {
                if (temp % 10 == 7) count++;
                temp /= 10;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = fizz_buzz;
    assert(candidate((50)) == (0));
    assert(candidate((78)) == (2));
    assert(candidate((79)) == (3));
    assert(candidate((100)) == (3));
    assert(candidate((200)) == (6));
    assert(candidate((4000)) == (192));
    assert(candidate((10000)) == (639));
    assert(candidate((100000)) == (8026));
}
"
HumanEval/37,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⵎⵥ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵢⴰⵏ ⵓⴽⵜⵓⵔ l ⴰⵔ ⵜⵙⵙⴽⵛⵎ ⵢⴰⵏ ⵓⴽⵜⵓⵔ l' ⵣⵓⵏⴷ ⵉⵙ ⵉⴳⴰ l ⴰⵎⵎ ⵡⵉⵏ l ⴳ ⵡⴰⵏⵙⵉⵡⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵎⴰⵛⴰ ⵡⴰⵜⵉⴳⵏ ⵏⵏⵙ ⴳ ⵡⴰⵏⵙⵉⵡⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷ ⵡⴰⵜⵉⴳⵏ ⵏ ⵡⴰⵏⵙⵉⵡⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏ l, ⵎⴰⵛⴰ ⵜⵜⵓⵙⵎⵉⵍⵏ. >>> sort_even{(std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even{(std::vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std::vector<((long>{(long) 3, (long) 6, (long) 5, (long) 4}))
std::vector<long> sort_even(std::vector<long> l) {
","std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for (size_t i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 2) {
        l[i] = even_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_even;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));
}
"
HumanEval/39,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// prime_fib ⴷⴰ ⵉⵜⵜⴰⵊⵊⵓ ⵓⵟⵟⵓⵏ ⵏ ⵡⵉⵙⵙ ⵏ ⵎⵔⴰⵡ ⵉⴳⴰⵏ ⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ, ⴷ ⵉⴳⴰ ⴰⵡⴷ ⴰⵎⵣⵡⴰⵔⵓ. >>> prime_fib((1)) (2) >>> prime_fib((2)) (3) >>> prime_fib(3)) (5) >>> prime_fib((4)) (13) >>> prime_fib((5) (89)
long prime_fib(long n) {
","bool is_prime(long num) {
    if (num < 2) return false;
    if (num < 4) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;
    for (long i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}

long prime_fib(long n) {
    std::vector<long> prime_fibs;
    long a = 1, b = 1;
    while (prime_fibs.size() < n) {
        long next = a + b;
        a = b;
        b = next;
        if (is_prime(next)) {
            prime_fibs.push_back(next);
        }
    }
    return prime_fibs[n - 1];
}","}
int main() {
    auto candidate = prime_fib;
    assert(candidate((1)) == (2));
    assert(candidate((2)) == (3));
    assert(candidate((3)) == (5));
    assert(candidate((4)) == (13));
    assert(candidate((5)) == (89));
    assert(candidate((6)) == (233));
    assert(candidate((7)) == (1597));
    assert(candidate((8)) == (28657));
    assert(candidate((9)) == (514229));
    assert(candidate((10)) == (433494437));
}
"
HumanEval/40,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵥⵍⵉⵏ ⴳ ⵓⵎⵙⵙⵓⴷⵙ ⵏⵏⴰ ⵉⵜⵜⴳⴳⵏ ⵉ ⵓⵎⵢⴰ, ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ. >>> ⵜⵉⴷⵜ_ⵜⵉⵎⵉⴹⵉ_ⵜⵉⵎⵉⴹⵉ, ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵥⵍⵉⵏ ⴳ ⵓⵎⵙⵙⵓⴷⵙ ⵏⵏⴰ ⵉⵜⵜⴳⴳⵏ ⵉ ⵓⵎⵢⴰ, ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ. >>> ⵜⵉⴷⵜ_ⵜⵉⵎⵉⴹⵉ_ⵜⵉⵎⵉⴹⵉ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ ⵜⵉⴷⵜ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ, ⴷ,
bool triples_sum_to_zero(std::vector<long> l) {
","bool triples_sum_to_zero(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    for (size_t i = 0; i < n - 2; i++) {
        size_t left = i + 1, right = n - 1;
        while (left < right) {
            long sum = l[i] + l[left] + l[right];
            if (sum == 0) return true;
            else if (sum < 0) left++;
            else right--;
        }
    }
    
    return false;
}","}
int main() {
    auto candidate = triples_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));
    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));
}
"
HumanEval/41,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⴷⴰⵍⵉⵎⴰⵍ ⵉⵉⴰⴾⴰ ⵓⴰ ⵢⵈⴰⵍ ⴰⴱⴰⵔⴰ ⵓⴰ ⵓⴶⵓⴷ ⵓⴰⵔⴰⵏ ⵓⴶⵓⴷ. ⵏⴰⴾⴰⵍ ⴰⴾⴰⵉⴰⵏ ⵙⵓⵍⵓ ⵙⴰⵔⴰⵜ ⵙⴰⵎⴰⵍ ⵙ ⵙⴰⵎⴰⵍ; ⴷⴰⵗ ⴰⵍⵓⴰⵈ ⵉⵉⴰⵏ, ⵜⴰⵈⵈⵉⵎⵜ ⴰⵏ ⵏⴰⴾⴰⵍ ⴰⴾⴰⵉⴰⵏ ⵙⴰⵔⴰⵜ ⵙⴰⵎⴰⵍ ⵙ ⵙⴰⵎⴰⵍ. ⵙⴰⵏⴰⵜⴰⵜⴰⵜ ⵜⴰⵈⵈⵉⵎⵢⵏ ⴰⵏ ⵏⴰⴾⴰⵍ ⴰⵈⴰⵍⴰⵏ ⴰⵜⵉⵓⴰⵣⴰⵉⴰⵏ ⴷⴰⵗ ⴰⵋⴰⵎⴰ ⴰⵏ ⵜⴰⵔⵜⵉⵜ. ⴾⵓⵍ ⵏⴰⴾⴰⵍ ⴰⴾⴰⵉⴰⵏ ⵙⴰⵎⴰⵍ ⵙ ⵙⴰⵎⴰⵍ. ⵜⴰⵈⴰⵍ ⴰⴾⴰⵉⴰⵏ ⴰⵙ ⴰⴾⴰⵉⴰⵏ ⴰⵙ ⴰⴾⴰⵉⴰⵏ ⴰⵙ ⴰⴾⴰⵉⴰⵏ ⴰⴾⴰⵉⴰⵏ ⵙⴰⵎⴰⵍ ⵉⴾⴰⵉⴰⵏ ⴰⴾⴰⵉⴰⵏ ⵙⴰⵎⴰⵍ. ⵎⴰⵛⴰⵏ, ⴰⴾⴰⵉⴰⵏ ⴰⵈⴰⵍⴰⵏ ⴰⴾⴰⵉⴰⵏ ⴰⵙⵓⵂⵢⵏ ⴰⴷ ⴰⵙⵙⵓⵂⵢⵏ; ⴷⴰⵗ ⴰⵓⴰ, ⴰⴾⴰⵉⴰⵏ ⴷⴰⵗ ⵜⴰⴱⴰⵔⴰⵜ ⴰⵏⵢⵙ ⵛⵓⵏⴷ ⴰⵙ ⵓⴰⵔ ⴰⴾⴰⵉⴰⵏ.
long car_race_collision(long n) {
","long car_race_collision(long n) {
    return n * n;
}","}
int main() {
    auto candidate = car_race_collision;
    assert(candidate((2)) == (4));
    assert(candidate((3)) == (9));
    assert(candidate((4)) == (16));
    assert(candidate((8)) == (64));
    assert(candidate((10)) == (100));
}
"
HumanEval/42,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⴽⵡⵍ ⵓⴱⵉⴽⵜⵓⵔ ⵙ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵣⵣⵉⴳⵣⵏ ⵙ 1. >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 2, (long) 3, (long) 4})) >>> incr_list((std::vector<long>{long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))
std::vector<long> incr_list(std::vector<long> l) {
","std::vector<long> incr_list(std::vector<long> l) {
    for (long &num : l) {
        num++;
    }
    return l;
}","}
int main() {
    auto candidate = incr_list;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));
    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));
}
"
HumanEval/43,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵉⵜⵜⴳⴳⵏ ⵉ ⵓⵎⵢⴰ, ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ. >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 2, (long) 1} >>> (false) pairs_sum_to_zero(std::vector<long>(long) 1, (long) 2, (long) 3, (long) 7}))) (se) pairs >>>_sum_to_zero(std::vector<long>{long>(long>{long>{long>{long>{long>{long>} (long>long)) >>> (se) pairs >>>_sum_to_zero((std::vector<long>{long>{long>{long>long>} (long>long)) >>> (se) pairs >>>
bool pairs_sum_to_zero(std::vector<long> l) {
","bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> seen;
    for (long num : l) {
        if (seen.count(-num)) {
            return true;
        }
        seen.insert(num);
    }
    return false;
}","}
int main() {
    auto candidate = pairs_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));
}
"
HumanEval/44,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵏⴼⵍ ⵜⴰⵙⵉⵍⴰ ⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⵙⵙⴽⵛⵎ ⵏ ⵓⵟⵟⵓⵏ x ⵙ ⵜⴰⵙⵉⵍⴰ. ⵙⵏⴼⵍ ⴰⵙⵎⴷⵢⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵏⴼⵍ. ⵉⵎⴹⴰⵏ ⵏ ⵜⵙⵉⵍⴰ ⴷⵔⵓⵙⵏ ⵙⴳ 10. >>> change_base((8), (3)) (""22"") >>> change_base((8), (2)) (""1000"") >>> change_base((7), (2)) (""111"")
std::string change_base(long x, long base) {
","std::string change_base(long x, long base) {
    if (x == 0) return ""0"";
    
    std::string result;
    while (x > 0) {
        result += std::to_string(x % base);
        x /= base;
    }
    
    std::reverse(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = change_base;
    assert(candidate((8), (3)) == (""22""));
    assert(candidate((9), (3)) == (""100""));
    assert(candidate((234), (2)) == (""11101010""));
    assert(candidate((16), (2)) == (""10000""));
    assert(candidate((8), (2)) == (""1000""));
    assert(candidate((7), (2)) == (""111""));
    assert(candidate((2), (3)) == (""2""));
    assert(candidate((3), (4)) == (""3""));
    assert(candidate((4), (5)) == (""4""));
    assert(candidate((5), (6)) == (""5""));
    assert(candidate((6), (7)) == (""6""));
    assert(candidate((7), (8)) == (""7""));
}
"
HumanEval/45,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⴼⴽⴰ ⵓⵖⵣⵉ ⵏ ⵓⴳⴰⴼⴰ ⴷ ⵢⵉⴳⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵎⵇⵔⴰⵏ ⵉ ⵜⵔⵉⴰⵏⴳⵉⵍ. >>> triangle_area((5), (3)) (7.5f)
float triangle_area(long a, long h) {
","float triangle_area(long a, long h) {
    return 0.5f * a * h;
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((5), (3)) == (7.5f));
    assert(candidate((2), (2)) == (2.0f));
    assert(candidate((10), (8)) == (40.0f));
}
"
HumanEval/46,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵍⵖⴰ ⵏ ⵉⵎⴹⴰⵏ ⵏ Fib4 ⵜⴳⴰ ⵜⴰⵍⵖⴰ ⵢⴰⴽⵙⵓⵍⵏ ⵉ ⵜⴰⵍⵖⴰ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ ⵓⵎⴽ ⴰⴷ: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵉ ⵓⵙⵉⴹⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵜⵉⵙⵉⴹⵉ ⵏ ⵉⵎⴹⴰⵏ ⵏ fib4. ⵓⵔ ⵜⵙⵙⵎⵔⵙ ⵜⵉⵔⵔⴰ. >>> fib4((5)) (4) >>> fib4(6)) (8) >>>4((7)) (14)
long fib4(long n) {
","long fib4(long n) {
    if (n == 0 || n == 1 || n == 3) return 0;
    if (n == 2) return 2;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 2;

    for (long i = 4; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fib4;
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (28));
    assert(candidate((10)) == (104));
    assert(candidate((12)) == (386));
}
"
HumanEval/47,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔⴷ ⴷⴰ ⵉⵜⵜⴰⴽⵡⵍ ⵡⴰⵎⵎⴰⵙ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵎⵙⵙⵉⵔⵉ ⵍⵉ. >>> ⴰⵎⵙⵙⵉⵔⵉ ((((ⵙⵜⴷ: ⵓⵎⵙⵙⵉⵔⵉ<ⴳⵣⵣⴰⵢ> (((ⴳⵣⵣⴰⵢ) 3, (ⴳⵣⵣⴰⵢ) 1, (ⴳⵣⵣⴰⵢ) 2, (ⴳⵣⵣⴰⵢ) 4, (ⴳⵣⵣⴰⵢ) 5)))) (ⴳⵣⵣⴰⵢ)) >>> ⴰⵎⵙⵙⵉⵔⵉ (((((ⵙⵜⴷ: ⵓⵎⵙⵙⵉⵔⵉ<ⴳⵣⵣⴰⵢ> (((ⴳⵣⵣⴰⵢ) -10, (ⴳⵣⵣⴰⵢ) 4, (ⴳⵣⵣⴰⵢ) 6, (ⴳⵣⵣⴰⵢ) 1000, (ⴳⵣⵣⴰⵢ) 10, (ⴳⵣⵣⴰⵢ) 20)) (15.0f)
float median(std::vector<long> l) {
","float median(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    if (n % 2 == 1) {
        return static_cast<float>(l[n / 2]);
    } else {
        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;
    }
}","}
int main() {
    auto candidate = median;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));
    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));
    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));
    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));
    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));
}
"
HumanEval/48,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵉⵔⵉ ⵎⴰⵙⴷ ⵜⴰⴷⴷⴰⵔⵜ ⵜⵓⵎⵍⵉⵍⵜ ⵜⴰⵡⵉⵏⵙⵜ ⵜⴳⴰ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ >>> is_palindrome ((("""")) (true) >>> is_palindrome (((""aba"")) (true) >>> is_palindrome (((""aaaaa"")) (true) >>> is_palindrome (((""zbcd"")) (false)
bool is_palindrome(std::string text) {
","bool is_palindrome(std::string text) {
    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());
}","}
int main() {
    auto candidate = is_palindrome;
    assert(candidate(("""")) == (true));
    assert(candidate((""aba"")) == (true));
    assert(candidate((""aaaaa"")) == (true));
    assert(candidate((""zbcd"")) == (false));
    assert(candidate((""xywyx"")) == (true));
    assert(candidate((""xywyz"")) == (false));
    assert(candidate((""xywzx"")) == (false));
}
"
HumanEval/49,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⴽⵡⵍ 2^n ⵎⵓⴷⵓⵍⵓ p (ⵢⵉⵙⵙⵏ ⵙ ⵡⵓⵟⵟⵓⵏ). >>> ⵎⵓⴷⵓⵍⵓ ((((3), (5)) (3) >>> ⵎⵓⴷⵓⵍⵓ (((1101), (101)) (2) >>> ⵎⵓⴷⵓⵍⵓ (((0), (101)) (1) >>> ⵎⵓⴷⵓⵍⵓ (((3), (11)) (8) >>> ⵎⵓⴷⵓⵍⵓ (((100), (101)) (1)
long modp(long n, long p) {
","long modp(long n, long p) {
    return std::pow(2, n) % p;
}","}
int main() {
    auto candidate = modp;
    assert(candidate((3), (5)) == (3));
    assert(candidate((1101), (101)) == (2));
    assert(candidate((0), (101)) == (1));
    assert(candidate((3), (11)) == (8));
    assert(candidate((100), (101)) == (1));
    assert(candidate((30), (5)) == (4));
    assert(candidate((31), (5)) == (3));
}
"
HumanEval/51,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// remove_vowels ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴷ ⴰⵔ ⵢⴰⴽⴽⴰ ⵜⵉⴼⵉⵏⴰⵖ ⴱⵍⴰ ⵉⵎⵏⵉⵍⵏ. >>> remove_vowels(("""")) ("""") >>> remove_vowels((""abcdef"")) (""bcdf"") >>> remove_vowels((""aaaaa"")) ("""") >>> remove_vowels(""aaBAA"")) (""B"") >>> remove_vowels((""zbcd"")) (""zbcd"")
std::string remove_vowels(std::string text) {
","std::string remove_vowels(std::string text) {
    std::string result;
    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
    
    for (char ch : text) {
        if (vowels.find(ch) == vowels.end()) {
            result += ch;
        }
    }
    
    return result;
}","}
int main() {
    auto candidate = remove_vowels;
    assert(candidate(("""")) == (""""));
    assert(candidate((""abcdef\nghijklm"")) == (""bcdf\nghjklm""));
    assert(candidate((""fedcba"")) == (""fdcb""));
    assert(candidate((""eeeee"")) == (""""));
    assert(candidate((""acBAA"")) == (""cB""));
    assert(candidate((""EcBOO"")) == (""cB""));
    assert(candidate((""ybcd"")) == (""ybcd""));
}
"
HumanEval/52,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⵍⵙ true ⵉⴳ ⴳⴰⵏ ⵉⵎⴹⴰⵏ ⴰⴽⴽⵡ ⴳ ⵓⵎⵙⵙⵓⴷⵙ l ⴷⴷⴰⵡ ⵏ ⵓⴱⵔⵉⴷ t. >>> below_threshold(((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 10})), (100)) (true) >>> below_threshold((std::vector<long>({(long) 1, (long) 20, (long) 4, (long) 10})), (5)) (false)
bool below_threshold(std::vector<long> l, long t) {
","bool below_threshold(std::vector<long> l, long t) {
    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });
}","}
int main() {
    auto candidate = below_threshold;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));
}
"
HumanEval/53,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵓⵏ ⵙⵏⴰⵜ ⵜⴽⵓⴹⵉⵏ x ⴷ y >>> ⵙⵔⵓⵏ ((((2), (3)) (5) >>> ⵙⵔⵓⵏ (((5), (7)) (12)
long add(long x, long y) {
","long add(long x, long y) {
    return x + y;
}","}
int main() {
    auto candidate = add;
    assert(candidate((0), (1)) == (1));
    assert(candidate((1), (0)) == (1));
    assert(candidate((2), (3)) == (5));
    assert(candidate((5), (7)) == (12));
    assert(candidate((7), (5)) == (12));
}
"
HumanEval/54,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// <string name=""true_chars_eabcd_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_d_
bool same_chars(std::string s0, std::string s1) {
","bool same_chars(std::string s0, std::string s1) {
    std::unordered_set<char> set0(s0.begin(), s0.end());
    std::unordered_set<char> set1(s1.begin(), s1.end());
    return set0 == set1;
}","}
int main() {
    auto candidate = same_chars;
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(candidate((""abcd""), (""dddddddabc"")) == (true));
    assert(candidate((""dddddddabc""), (""abcd"")) == (true));
    assert(candidate((""eabcd""), (""dddddddabc"")) == (false));
    assert(candidate((""abcd""), (""dddddddabcf"")) == (false));
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(candidate((""aabb""), (""aaccc"")) == (false));
}
"
HumanEval/55,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵡⵉⵙⵙ n. >>> fib((10)) (55) >>> fib((1)) (1) >>> fib((8)) (21)
long fib(long n) {
","long fib(long n) {
    if (n <= 1) return n;
    
    long a = 0, b = 1, c;
    for (long i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    
    return b;
}","}
int main() {
    auto candidate = fib;
    assert(candidate((10)) == (55));
    assert(candidate((1)) == (1));
    assert(candidate((8)) == (21));
    assert(candidate((11)) == (89));
    assert(candidate((12)) == (144));
}
"
HumanEval/56,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⴱⵔⵉⴷ ⵏ ""<"" ⴷ "">"". ⴰⵔ ⵉⵜⵜⴰⵍⵙ true ⵎⴽ ⴷⴰⵔ ⴽⵓ bracket ⵉⵕⵥⵎⵏ ⵢⴰⵏ bracket ⵉⵇⵇⵏ. >>> correct_bracketing((""<"")) (false) >>> correct_bracketing(""<>"")) (true) >>> correct_bracketing(""<><>>"")) (true) >>> correct_bracketing("">(<>"") (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '<') balance++;
        else if (ch == '>') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""<>"")) == (true));
    assert(candidate((""<<><>>"")) == (true));
    assert(candidate((""<><><<><>><>"")) == (true));
    assert(candidate((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(candidate((""<<<><>>>>"")) == (false));
    assert(candidate((""><<>"")) == (false));
    assert(candidate((""<"")) == (false));
    assert(candidate((""<<<<"")) == (false));
    assert(candidate(("">"")) == (false));
    assert(candidate((""<<>"")) == (false));
    assert(candidate((""<><><<><>><>><<>"")) == (false));
    assert(candidate((""<><><<><>><>>><>"")) == (false));
}
"
HumanEval/57,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Return true ⵉⴳⴰⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⴷⴰ ⵙⵙⴽⵔⵏ ⵏⵖⴷ ⴷⴰ ⵙⵙⴽⵔⵏ ⵙ ⵜⴰⵍⵖⴰ ⵜⴰⵎⵢⵉⵡⴰⵏⵜ. >>> monotonic(((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 20}))) (true) >>> monotonic(((std::vector<long>{(long) 1, (long) 20, (long) 4, (long) 10}))) (false) >>> monotonic(((std::vector<long>{(long) 4, (long) 1, (long) 0, (long) -10}))) (true)
bool monotonic(std::vector<long> l) {
","bool monotonic(std::vector<long> l) {
    bool increasing = true, decreasing = true;
    
    for (size_t i = 1; i < l.size(); i++) {
        if (l[i] > l[i - 1]) decreasing = false;
        if (l[i] < l[i - 1]) increasing = false;
    }
    
    return increasing || decreasing;
}","}
int main() {
    auto candidate = monotonic;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));
    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));
}
"
HumanEval/58,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⵉⵡⴰⵏⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵉ ⵙⵉⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ. >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653})) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}), (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long>2, (long) 3))
std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
","std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::unordered_set<long> set1(l1.begin(), l1.end());
    std::unordered_set<long> result_set;
    
    for (long num : l2) {
        if (set1.count(num)) {
            result_set.insert(num);
        }
    }
    
    std::vector<long> result(result_set.begin(), result_set.end());
    std::sort(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = common;
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/59,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔⵏ ⵉⴽⴽⴰ ⵓⵎⴳⴳⴰⵔⵓ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ ⵏ n. ⵏⵙⵙⵉⵏ ⵉⵙ n > 1 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵎⵣⵡⴰⵔⵓ. >>> largest_prime_factor (((13195)) (29) >>> largest_prime_factor (((2048)) (2)
long largest_prime_factor(long n) {
","long largest_prime_factor(long n) {
    long largest = -1;
    
    while (n % 2 == 0) {
        largest = 2;
        n /= 2;
    }
    
    for (long i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            largest = i;
            n /= i;
        }
    }
    
    if (n > 1) largest = n;
    
    return largest;
}","}
int main() {
    auto candidate = largest_prime_factor;
    assert(candidate((15)) == (5));
    assert(candidate((27)) == (3));
    assert(candidate((63)) == (7));
    assert(candidate((330)) == (11));
    assert(candidate((13195)) == (29));
}
"
HumanEval/60,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// sum_to_n ⵜⴳⴰ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵎⵓⵏⵏ ⵉⵎⴹⴰⵏ ⵙⴳ 1 ⴰⵔ n. >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)
long sum_to_n(long n) {
","long sum_to_n(long n) {
    return n * (n + 1) / 2;
}","}
int main() {
    auto candidate = sum_to_n;
    assert(candidate((1)) == (1));
    assert(candidate((6)) == (21));
    assert(candidate((11)) == (66));
    assert(candidate((30)) == (465));
    assert(candidate((100)) == (5050));
}
"
HumanEval/61,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵜⵜⵓ ⵏ ""("" ⴷ "")"". ⴰⵔ ⵉⵜⵜⴰⵍⵙ true ⵎⴽ ⴷⴰⵔ ⴽⵓ bracket ⵉⵕⵥⵎⵏ ⵢⴰⵏ bracket ⵉⵇⵇⵏ. >>> correct_bracketing((""("")) (false) >>> correct_bracketing(""()"")) (true) >>> correct_bracketing(""(()))) (true) >>> correct_bracketing((""))) (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '(') balance++;
        else if (ch == ')') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""()"")) == (true));
    assert(candidate((""(()())"")) == (true));
    assert(candidate((""()()(()())()"")) == (true));
    assert(candidate((""()()((()()())())(()()(()))"")) == (true));
    assert(candidate((""((()())))"")) == (false));
    assert(candidate(("")(()"")) == (false));
    assert(candidate((""("")) == (false));
    assert(candidate((""(((("")) == (false));
    assert(candidate(("")"")) == (false));
    assert(candidate((""(()"")) == (false));
    assert(candidate((""()()(()())())(()"")) == (false));
    assert(candidate((""()()(()())()))()"")) == (false));
}
"
HumanEval/62,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// xs ⴷⴰ ⵉⵙⵎⴷⵢⴰ ⵉⵎⴳⴳⵉⵜⵏ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵡⵜⵜⴰ. xs[0] + xs[1] * x + xs[2] * x^2 + .... ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵎⵏⵣⴰⵢ ⵏ ⵓⵎⵏⵣⴰⵢ ⴰⴷ ⴳ ⵢⴰⵜ ⵜⴰⵍⵖⴰ ⵢⴰⴷⵏ. >>> derivative(((std::vector<long>({long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> derivative::std::vector<(long>{(long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))
std::vector<long> derivative(std::vector<long> xs) {
","std::vector<long> derivative(std::vector<long> xs) {
    std::vector<long> result;
    for (size_t i = 1; i < xs.size(); i++) {
        result.push_back(xs[i] * i);
    }
    return result;
}","}
int main() {
    auto candidate = derivative;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));
    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));
}
"
HumanEval/63,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵍⵖⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⴱⵓⵏⴰⵛⵉ ⵜⴳⴰ ⵜⴰⵍⵖⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ: ⴼⵉⴱⴱⵓⵏⴰⵛⵉ ((0) == 0 ⴼⵉⴱⴱⵓⵏⴰⴽⵉ ((1) == 0 ⴼⵉⴱⴱⵓⵏⴰⴽⵉ ((2) == 1 ⴼⵉⴱⵓⵏⴰⴽⵉ ((n) == ⴼⵉⴱⵓⵏⴰⴽⵉ ((n-1) + ⴼⵉⴱⵓⵏⴰⴽⵉ ((n-2) + ⴼⵉⴱⵓⵏⴰⴽⵉ ((n-3). ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏ ⵓⵙⵉⴹⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⴱⵓⵏⴰⴽⵉ ⵙ ⵜⵣⵎⵔⵜ. >>> ⴼⵉⴱⵓⵏⴰⴽⵉ (((1)) (0) >>> ⴼⵉⴱⵓⵏⴰⴽⵉ (((5)) (4) >>> ⴼⵉⴱⵓⵏⴰⴽⵉ ((8)) (24)
long fibfib(long n) {
","long fibfib(long n) {
    if (n == 0 || n == 1) return 0;
    if (n == 2) return 1;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 1;

    for (long i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fibfib;
    assert(candidate((2)) == (1));
    assert(candidate((1)) == (0));
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (24));
    assert(candidate((10)) == (81));
    assert(candidate((12)) == (274));
    assert(candidate((14)) == (927));
}
"
HumanEval/64,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⵔⴰⵎ ⵜⴰⵡⵓⵔⵉ vowels_count ⵏⵏⴰ ⵉⵙⵏⵓⵎⵎⵍⵏ ⵜⴰⴳⵓⵔⵉ ⵙ ⵡⴰⵏⴰⵡ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵙⵙⴽⵛⵎ ⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⴳ ⵜⴳⵓⵔⵉ. ⵉⵎⵓⵙⵙⵓⵜⵏ ⴳ ⵡⴰⴷⴷⴰⴷ ⴰⴷ ⴳⴰⵏ 'a', 'e', 'i', 'o', 'u'. ⴷⵖⴰ, 'y' ⵉⴳⴰ ⴰⵡⴷ ⵢⴰⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ, ⵎⴰⴽⴰ ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⵖ ⵜⴳⵉⵔⴰ ⵏ ⵜⴳⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⴼⴽⴰⵏ. ⴰⵎⴷⵢⴰ: >>> vowels_count (((""abcde"")) (2) >>> vowels_count (((""ACEDY"")) (3)
long vowels_count(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long vowels_count(std::string s) {
  long count = 0;
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  for (char c : s) {
    if (vowels.count(c)) {
      count++;
    }
  }
  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {
    count++;
  }
  return count;
}","}
int main() {
    auto candidate = vowels_count;
    assert(candidate((""abcde"")) == (2));
    assert(candidate((""Alone"")) == (3));
    assert(candidate((""key"")) == (2));
    assert(candidate((""bye"")) == (1));
    assert(candidate((""keY"")) == (2));
    assert(candidate((""bYe"")) == (1));
    assert(candidate((""ACEDY"")) == (3));
}
"
HumanEval/65,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵓⵙⵏⴼⵍ ⴰⵎⵎ ⵜⴰⵡⴰⵍⵜ, ⴷⴰ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵓⵍⴰ ⵙ ⵓⵥⵍⵎⴰⴹ ⵙ ⵓⵥⵍⵎⴰⴹ, ⴷⴰ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵓⵍⴰ ⵙ ⵓⵥⵍⵎⴰⴹ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵓⴹⴼⴰⵕ. ⵉⴳ ⵉⴳⴰ ⵓⵙⵏⴼⵍ > ⵓⵟⵟⵓⵏ ⵏ ⵉⵙⵏⴼⵍⵏ, ⴷⴰ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵓⵍⴰ ⵙ ⵓⴹⴼⴰⵕ. >>> circular_shift((12), (1)) (""21"") >>> circular_shift((12), (2)) (""12"")
std::string circular_shift(long x, long shift) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string circular_shift(long x, long shift) {
  std::string s = std::to_string(x);
  long n = s.length();
  if (n == 0) {
    return """";
  }
  shift %= n;
  if (shift < 0) {
    shift += n;
  }
  if (shift == 0) {
    return s;
  }
  if (shift > n) {
    std::reverse(s.begin(), s.end());
    return s;
  }
  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);
  return shifted_s;
}","}
int main() {
    auto candidate = circular_shift;
    assert(candidate((100), (2)) == (""001""));
    assert(candidate((12), (2)) == (""12""));
    assert(candidate((97), (8)) == (""79""));
    assert(candidate((12), (1)) == (""21""));
    assert(candidate((11), (101)) == (""11""));
}
"
HumanEval/66,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵡⵓⵔⵉ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵎⵔⵙⵜ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴰⴳⵓⵜ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵓⴼⵍⵍⴰ ⴷⴰⵢ. ⵉⵎⴷⵢⴰⵜⵏ: >>> digitSum(("""")) (0) >>> digitSum((""abAB"")) (131) >>> digitSum((""abcCd"")) (67) >>> digitSum((""helloE"")) (69) >>> digitSum((""woArBld"")) (131) >>> digitSum((""aAXaaaa"") (153)
long digitSum(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long digitSum(std::string s) {
  long sum = 0;
  for (char c : s) {
    if (isupper(c)) {
      sum += static_cast<long>(c);
    }
  }
  return sum;
}","}
int main() {
    auto candidate = digitSum;
    assert(candidate(("""")) == (0));
    assert(candidate((""abAB"")) == (131));
    assert(candidate((""abcCd"")) == (67));
    assert(candidate((""helloE"")) == (69));
    assert(candidate((""woArBld"")) == (131));
    assert(candidate((""aAaaaXa"")) == (153));
    assert(candidate(("" How are yOu?"")) == (151));
    assert(candidate((""You arE Very Smart"")) == (327));
}
"
HumanEval/67,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵜⵎⵙⴰⵔⵜ ⴰⴷ, ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵜ ⵜⵉⴼⵔⵜ ⵉⵙⵎⴷⵢⴰⵏ ⴰⵎⴹⴰⵏ ⵏ ⵜⴱⵔⵣⵉⵍⵉⵏ ⴷ ⵜⴱⵕⴰⵏⵊⵉⵏ ⵉⵜⵜⵓⵣⵟⵟⴰⵢⵏ ⴳ ⵢⴰⵜ ⵜⴽⵕⴹⴰ ⵏ ⵉⴼⴰⵔⵙⵏ ⵉⵍⵍⴰ ⴳ ⵜⴽⵕⴹⴰ ⴰⴷ ⵜⵉⴼⵔⴰⵙ ⴷ ⵜⴱⵕⴰⵏⵊⵉⵏ ⴷ ⵉⴼⴰⵔⵙⵏ ⵏ ⵍⵎⴰⵏⴳⵓ. ⴷⴼⴼⵉⵔ ⵏ ⵜⵉⴼⵔⵜ ⵉⵙⵎⴷⵢⴰⵏ ⴰⵎⴹⴰⵏ ⴰⴽⴽⵡ ⵏ ⵜⴱⵕⴰⵏⵊⵉⵏ ⴷ ⵜⴱⵔⵣⵉⵍⵉⵏ ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵙⵎⴷⵢⴰⵏⵏ ⴰⵎⴹⴰⵏ ⴰⴽⴽⵡ ⵏ ⵉⴼⴰⵔⵙⵏ ⴳ ⵜⴽⵕⴹⴰ, ⵙⵙⴽⵔ ⴰⵎⴹⴰⵏ ⵏ ⵉⴼⴰⵔⵙⵏ ⵏ ⵍⵎⴰⵏⴳⵓ ⴳ ⵜⴽⵕⴹⴰ. ⵙ ⵓⵎⴷⵢⴰ: >>> fruit_distribution ((((((""5 ⵜⵉⴼⵔⴰⵙ ⴷ 6 ⵜⵉⴼⵔⴰⵙ""), (19)) (8) >>> fruit_distribution ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
long fruit_distribution(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long fruit_distribution(std::string s, long n) {
  long apples = 0;
  long oranges = 0;
  size_t apples_pos = s.find(""apples"");
  if (apples_pos != std::string::npos) {
    size_t start = 0;
    while (!isdigit(s[start])) {
      start++;
    }
    apples = std::stoll(s.substr(start, apples_pos - start));
  }
  size_t oranges_pos = s.find(""oranges"");
  if (oranges_pos != std::string::npos) {
    size_t and_pos = s.find(""and"");
    size_t start = and_pos + 3;
    while (!isdigit(s[start])) {
      start++;
    }
    oranges = std::stoll(s.substr(start, oranges_pos - start));
  }
  return n - apples - oranges;
}","}
int main() {
    auto candidate = fruit_distribution;
    assert(candidate((""5 apples and 6 oranges""), (19)) == (8));
    assert(candidate((""5 apples and 6 oranges""), (21)) == (10));
    assert(candidate((""0 apples and 1 oranges""), (3)) == (2));
    assert(candidate((""1 apples and 0 oranges""), (3)) == (2));
    assert(candidate((""2 apples and 3 oranges""), (100)) == (95));
    assert(candidate((""2 apples and 3 oranges""), (5)) == (0));
    assert(candidate((""1 apples and 100 oranges""), (120)) == (19));
}
"
HumanEval/68,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⵛⴽⵓ ⵉⵍⵍⴰ ⵓⴱⵉⴽⵜⵓⵔ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵏ ⵓⵥⵟⵟⴰ ⵏ ⵜⵙⴽⵍⴰ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵃⵍⵉⵏ, ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵢⴰⵜ ⵜⵓⵏⵏⵓⵜ ⴷ ⴰⴷ ⵜⵔⴰⵔ. ⵜⵓⵏⵏⵓⵜ ⵉⵜⵜⵓⵙⴽⵛⵎ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⴳ ⵜⵓⵏⵏⵓⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⴰⵎⵎ ⵡⴰⵜⵉⴳ. ⵉⵖ ⵜⵜⵢⴰⴼⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⴰⵎⵎ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ, ⵙⴽⵛⵎ ⵜⵓⵏⵏⵓⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⴰⵎⵎ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ. ⵜⵓⵏⵏⵓⵜ ⵉⵜⵜⵓⵙⴽⵛⵎ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵔⴰⵔ ⴳ ⵓⴱⵉⴽⵜⵓⵔ, [smallest_value, its index], ⵉⵖ ⵓⵔ ⵍⵍⵉⵏ ⵡⴰⵜⵉⴳⵏ ⵉⵎⵎⵥⵢⴰⵏ ⵏⵖⴷ ⵉⴳ ⵓⴱⵉⴽⵜⵓⵔ ⵢⴰⴽⴽⴰⵏ ⵉⵍⵍⴰ, ⵙⴽⵛⵎ []. ⴰⵎⴷⵢⴰⴷ ⴰⵎⴷⵢⴰ 1: >>> pluck{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> pluck(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> pluck(std::vector<long> arr) {
  if (arr.empty()) {
    return {};
  }
  long min_even = -1;
  long min_index = -1;
  for (long i = 0; i < arr.size(); ++i) {
    if (arr[i] % 2 == 0) {
      if (min_even == -1 || arr[i] < min_even) {
        min_even = arr[i];
        min_index = i;
      }
    }
  }
  if (min_even == -1) {
    return {};
  }
  return {min_even, min_index};
}","}
int main() {
    auto candidate = pluck;
    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));
}
"
HumanEval/69,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵜⵓⵔ ⵓⵔ ⵉⴳⵉⵏ ⵡⴰⴽⴰⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙⵙⴽⵛⵎ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⴰⴽⴽⵡ ⵏⵏⴰ ⵢⵓⴳⵔⵏ ⵊⴰⵔ ⵏ ⵓⵎⵢⴰ, ⴷ ⵖⵓⵔⵙ ⵜⴰⴽⴼⵍⵜ ⵜⴰⵅⴰⵜⴰⵔⵜ ⵏⵖⴷ ⵉⵎⵣⴷⴰⵖⵜ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵙ ⵉⵅⴼ ⵏⵏⵙ. ⵜⴰⴽⴼⵍⵜ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵜⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⴷⴰ ⵉⵜⵜⴼⴼⵖ ⴳ ⵓⴽⵜⵓⵔ. ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⵜⵉⴳ ⴰⴷ, ⵙⵙⴽⵛⵎ -1.
long search(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long search(std::vector<long> lst) {
  std::map<long, long> counts;
  for (long x : lst) {
    counts[x]++;
  }
  long result = -1;
  for (auto const& [value, count] : counts) {
    if (value > 0 && count >= value) {
      result = std::max(result, value);
    }
  }
  return result;
}","}
int main() {
    auto candidate = search;
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));
    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));
    assert(candidate((std::vector<long>({(long)10}))) == (-1));
    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));
}
"
HumanEval/70,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⵖⵓⵍ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⵓⵔ ⵉⵃⵍⵉⵏ. ⴰⵙⵓⴷⵙ ⵓⵔ ⵉⵃⵍⵉⵏ, ⵉⴳ ⴷⴰ ⵜⵜⴱⴷⵓⴷ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ, ⴷⴼⴼⵉⵔ ⵓⴳⴳⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵇⵇⵉⵎⵏ, ⴷⴼⴼⵉⵔ ⵓⴳⴳⴰⵔ, ⴷ ⴰⵢⴰⴷ. ⵉⵎⴷⵢⴰⵜⵏ: >>> strange_sort_list{(((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 4, (long) 2, (long) 3})) >>> strange_sort_list{((std::vector<long>{(long) 5, (long) 5, (long) 5}))) (std::vector<(long>{(long) 5, (long) 5, (long) 5}))) >>> strange_sort_list<(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> strange_sort_list(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> strange_sort_list(std::vector<long> lst) {
  if (lst.empty()) {
    return {};
  }
  std::sort(lst.begin(), lst.end());
  std::vector<long> result;
  long left = 0;
  long right = lst.size() - 1;
  bool take_min = true;
  while (left <= right) {
    if (take_min) {
      result.push_back(lst[left++]);
    } else {
      result.push_back(lst[right--]);
    }
    take_min = !take_min;
  }
  return result;
}","}
int main() {
    auto candidate = strange_sort_list;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));
}
"
HumanEval/71,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵉⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⴽⵕⴰⴹⵜ ⵜⵉⴳⵣⵉⵔⵉⵏ. ⴷⴰ ⵜⵜⵓⵙⵙⴽⵡⴼⵍ ⵜⵎⵏⴰⴹⵜ ⵏ ⴽⵕⴰⴹⵜ ⵜⵉⴳⵣⵉⵔⵉⵏ ⵙ ⵙⵏⴰⵜ ⵏ ⵜⵏⵇⵇⵉⴹⵉⵏ ⵏ ⴷⴷⴰⵔⵉⴼ ⵎⴽ ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⴽⵕⴰⴹⵜ ⵜⵉⴳⵣⵉⵔⵉⵏ. ⵎⴽ ⵓⵔ ⵉⴳⵉ ⴷⴰ ⵜⵜⵓⵙⵙⴽⵡⴼⵍ -1 ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔⵏ ⴽⵕⴰⴹⵜ ⵜⵉⴳⵣⵉⵔⵉⵏ ⵏ ⴽⵕⴰⴹⵜ ⵜⵉⴳⵣⵉⵔⵉⵏ ⵎⴽ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⵜⴼⵓⵍⵜ ⵜⵉⵙⵙ ⴽⵕⴰⴹⵜ. ⴰⵎⴷⵢⴰ: >>> triangle_area(3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())
float triangle_area(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>
float triangle_area(long a, long b, long c) {
  if (a + b <= c || a + c <= b || b + c <= a) {
    return -1.0f;
  }
  double s = static_cast<double>(a + b + c) / 2.0;
  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));
  std::stringstream ss;
  ss << std::fixed << std::setprecision(2) << area;
  return std::stof(ss.str());
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((3), (4), (5)) == (6.0f));
    assert(candidate((1), (2), (10)) == (float(-1)));
    assert(candidate((4), (8), (5)) == (8.18f));
    assert(candidate((2), (2), (2)) == (1.73f));
    assert(candidate((1), (2), (3)) == (float(-1)));
    assert(candidate((10), (5), (7)) == (16.25f));
    assert(candidate((2), (6), (3)) == (float(-1)));
    assert(candidate((1), (1), (1)) == (0.43f));
    assert(candidate((2), (2), (10)) == (float(-1)));
}
"
HumanEval/72,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⵉⵜⵓⵔⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⴷⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⵜⵉⴷⵜ ⵉⵖ ⵔⴰⴷ ⵉⵢⵉ ⵓⴷⵎ q, ⴷ ⵜⵉⴽⵕⴹⵉ ⵎⴽ ⵓⵔ ⵉⴳⵉ. ⵔⴰⴷ ⵉⵢⵉ ⵓⴷⵎ q ⵉⵖ ⵉⴳⴰ ⴰⵎⵙⴰⵙⴰ (ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ) ⴷ ⵡⵓⴳⴳⴰⵔ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⵙ ⵏⵖⴷ ⵉⴳ ⴰⵎⵎ ⵓⴽⵙⴰⵢ ⴰⵅⴰⵜⴰⵔ ⵉⵖⵢⴰⵏ w. ⴰⵎⴷⵢⴰ: >>> will_it_fly(((std::vector<long>({long) 1, (long) 2}), (5)) (false) # 1+2 ⵉⴳⴰ ⴰⵎⵙⴰⵙⴰ ⴷ ⵉⴷⵔⵓⵙ ⵓⴳⴳⴰⵔ ⵏ ⵓⴽⵙⴰⵢ ⴰⵅⴰⵜⴰⵔ ⵉⵖⵢⴰⵏ, ⵎⴰⴽⴰ ⵓⵔ ⵉⴳⵉ ⴰⵎⵙⴰⵙⴰ. >>> will_it_fly(((((std::vector<long>{(long>3, (long) 2, (long) 3}), (1) (false) # ⵉⴳⴰ ⴰⵎⵙⴰⵙⴰ, ⵎⴰⴽⴰ 3+2 ⵓⴳⴳⴰⵔ ⵏ ⵓⴽⵙⴰⵢ ⴰⵅⴰⵜⴰⵔ ⵉⵖⵢⴰⵏ, ⵎⴰⴽⴰ ⵓⵔ ⵉⴳⵉ ⴰⵎⵙⴰⵙⴰ. >>> will_it_long_ (true) # 3+2 ⵉⴳ ⴰⵎⵙⴰⵙⴰ ⴷ ⵉⴷⵔⵓⵙ ⵓⴳⴳⴰⵔ ⵏ ⵓⴽⵙⴰⵢ ⵉⵖⵢⴰⵏ ⵉⵖⵢⴰⵏ, ⵎⴰⴽⵙⴰⵢ ⵉⵖⵢⴰⵏ.
bool will_it_fly(std::vector<long> q, long w) {
","#include<assert.h>
#include<bits/stdc++.h>
bool will_it_fly(std::vector<long> q, long w) {
  std::vector<long> reversed_q = q;
  std::reverse(reversed_q.begin(), reversed_q.end());
  if (q != reversed_q) {
    return false;
  }
  long sum = 0;
  for (long val : q) {
    sum += val;
  }
  return sum <= w;
}","}
int main() {
    auto candidate = will_it_fly;
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));
    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));
}
"
HumanEval/73,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⵙⴽⴰⵔ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ ⴷⴰ ⵉⵜⵜⵢⴰⴼⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵉⵅⵚⵚⴰ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⵍ ⴰⴼⴰⴷ ⴰⴷ ⵉⴳ ⵓⴽⵜⵓⵔ ⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉ. ⵉⴳⴰ ⵓⴽⵜⵓⵔ ⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙⵏ ⵙ ⵢⴰⵜ ⵜⵖⴰⵔⴰⵙⵜ ⵉⵔⵡⴰⵙⵏ ⵙ ⵓⵎⵏⵉⴷ ⴷ ⵙ ⵓⵣⵡⵍ. ⴳ ⵓⵙⵏⴼⵍⵓⵍ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴼⵍ ⴽⵓ ⵉⴼⵔⴷⵉⵙ ⵙ ⴽⵓ ⵉⴼⵔⴷⵉⵙ ⵢⴰⴹⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> smallest_change{(std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 5, (long) 4, (long) 7, (long) 9, (long) 6}))) (4) >>> smallest_change{(std::vector<long>{(long>{(long>1, (long) 2, (long) 3, (long) 2, (long) 1})))
long smallest_change(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long smallest_change(std::vector<long> arr) {
  long n = arr.size();
  long changes = 0;
  for (long i = 0; i < n / 2; ++i) {
    if (arr[i] != arr[n - 1 - i]) {
      changes++;
    }
  }
  return changes;
}","}
int main() {
    auto candidate = smallest_change;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
}
"
HumanEval/74,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⵢⵔⴾⴰⴱ ⵜⴰⵆⴰⵍⵜ ⵜⴰ ⵜⴰⴾⴼⴰ ⵙⴰⵏⴰⵜⴰⵜⴰⵜ ⴾⴰⵍⵜⵓⴾⴰⵍ ⵏ ⴾⴰⵍⵜⵓⴾⴰⵍ ⵜⵓⵍⴰⵙ ⵜⴰⵔⴰⵓ ⴾⴰⵍⵜⵓⴾⴰⵍ ⵓⴰ ⵉⵍⴰⵏ ⴰⵋⵓⵜⵏⵢⵏ ⵏ ⵛⵂⴰⵔⵙ ⴷⴰⵗ ⴾⴰⵍⵜⵓⴾⴰⵍ ⵏ ⴾⴰⵍ ⴾⴰⵍⵜⵓⴾⴰⵍ ⵓⴰ ⵉⴰⴷⴰⵏ. ⴰ ⴼⴰⵍ ⴾⴰⵍⵜⵓⴾⴰⵍ ⵙⴰⵏⴰⵜ ⵉⵍⴰⵏ ⴰⵋⵓⵜⵏⵢⵏ ⵏ ⵛⵂⴰⵔⵙ, ⵜⴰⵔⴰⵓ ⴾⴰⵍⵜⵓⴾⴰⵍ ⵓⴰ ⵢⵣⵣⴰⵔⴰⵏ. ⴰⵍⵎⵉⵜⴰⵍ >>> total_match (ⵜⴰⵎⵓⵙⵏⴰⵜ: ⴾⴰⵍⵜⵓⴾⴰⵍ)), (ⵜⴰⵎⵓⵙⵏⴰⵜ: ⴾⴰⵍⵜⵓⴾⴰⵍ) >>> (ⵜⴰⵎⵓⵙⵏⴰⵜ: ⴾⴰⵍⵜⵓⴾⴰⵍ) >>> (ⵜⴰⵎⵓⵙⵏⴰⵜ: ⴾⴰⵍⵜⵓⴾⴰⵍ) >>> (ⵜⴰⵎⵓⵙⵏⴰⵜ: ⴾⴰⵍⵜⵓⴾⴰⵍ)
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
  long count1 = 0;
  for (const std::string& s : lst1) {
    count1 += s.length();
  }
  long count2 = 0;
  for (const std::string& s : lst2) {
    count2 += s.length();
  }
  if (count1 <= count2) {
    return lst1;
  } else {
    return lst2;
  }
}","}
int main() {
    auto candidate = total_match;
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi"", (std::string)""admin"", (std::string)""project""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>({(std::string)""4""})), (std::vector<std::string>({(std::string)""1"", (std::string)""2"", (std::string)""3"", (std::string)""4"", (std::string)""5""}))) == (std::vector<std::string>({(std::string)""4""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hii""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)""this""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""this""})), (std::vector<std::string>())) == (std::vector<std::string>()));
}
"
HumanEval/75,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⴼⴽⴰⵏ ⴰⵙⵎⵓⵜⵜⵉ ⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ. ⵏⵙⵙⵏ ⵎⴰⵙⴷ (ⴰ) ⴷⵔⵓⵙ ⵙⴳ 100. ⴰⵎⴷⵢⴰ: >>> is_multiply_prime((30)) (ⵜⴰⴷⴷⵜ) 30 = 2 * 3 * 5
bool is_multiply_prime(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_multiply_prime(long a) {
  if (a <= 0) {
    return false;
  }
  std::vector<int> primes;
  std::vector<bool> is_prime(100, true);
  is_prime[0] = is_prime[1] = false;
  for (int p = 2; p * p < 100; p++) {
    if (is_prime[p]) {
      for (int i = p * p; i < 100; i += p)
        is_prime[i] = false;
    }
  }
  for (int p = 2; p < 100; p++) {
    if (is_prime[p]) {
      primes.push_back(p);
    }
  }
  int count = 0;
  for (int p1 : primes) {
    if (a % p1 == 0) {
      count++;
      int rem = a / p1;
      for (int p2 : primes) {
        if (rem % p2 == 0) {
          count++;
          int rem2 = rem / p2;
          for (int p3 : primes) {
            if (rem2 == p3) {
              count++;
              if (count == 3) {
                return true;
              }
              count--;
            }
          }
          count--;
        }
      }
      count--;
    }
  }
  return false;
}","}
int main() {
    auto candidate = is_multiply_prime;
    assert(candidate((5)) == (false));
    assert(candidate((30)) == (true));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (false));
    assert(candidate((125)) == (true));
    assert(candidate((105)) == (true));
    assert(candidate((126)) == (false));
    assert(candidate((729)) == (false));
    assert(candidate((891)) == (false));
    assert(candidate((1001)) == (true));
}
"
HumanEval/76,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴰⵔⵔⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴷⵜ ⵉⵖ ⵉⴳⴰ ⵓⵟⵟⵓⵏ x ⵜⴰⵣⴷⵓⵖⵜ ⵜⴰⵎⵢⵉⵡⴰⵏⵜ ⵏ n ⴷ ⵜⵉⴱⵔⵙⴳⴳⵡⴰⴷⵜ ⴳ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏ. x ⵜⴳⴰ ⵜⴰⵣⴷⵓⵖⵜ ⵜⴰⵎⵢⵉⵡⴰⵏⵜ ⵏ n ⵉⵖ n**int=x ⵙ ⵓⵎⴷⵢⴰ: >>> is_simple_power((1), (4)) (true) >>> is_simple_power(2), (2)) (true) >>> is_simple_power(8), (2)) (true) >>> is_simple_power(3), (2)) (false) >>> is_simple_power(3), (1)) (false) >>> is_simple_power(5), (3)) (false)
bool is_simple_power(long x, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_simple_power(long x, long n) {
  if (x == n) return true;
  if (n == 1) return x == 1;
  if (n == 0) return x == 0;
  if (x == 0) return false;
  if (x == 1) return true;
  long power = n;
  while (power < x) {
    if (x % n != 0) return false;
    if (power > x / n) return false;
    power *= n;
  }
  return power == x;
}","}
int main() {
    auto candidate = is_simple_power;
    assert(candidate((16), (2)) == (true));
    assert(candidate((143214), (16)) == (false));
    assert(candidate((4), (2)) == (true));
    assert(candidate((9), (3)) == (true));
    assert(candidate((16), (4)) == (true));
    assert(candidate((24), (2)) == (false));
    assert(candidate((128), (4)) == (false));
    assert(candidate((12), (6)) == (false));
    assert(candidate((1), (1)) == (true));
    assert(candidate((1), (12)) == (true));
}
"
HumanEval/77,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ a ⴰⵔ ⴷⴰ ⵢⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⴰⵏⵏⴰⵢ ⴰⴷ ⴰⵎⴷⵢⴰ ⴰⵎⴷⴷⴰⴷ ⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵜⴰⵏⵏⴰⵢⵜ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵍ ⵉⵙ ⵉⴳⴰ ⵡⴰⵏⵏⴰⵢ ⴰⴷⴷⴰⴷ ⴰⵀⴰ ⵉⴳⴰ ⵡⵉⵏⵏⴰⵢ. ⵉⵎⴷⵢⴰⵜⵏ: >>> iscube((1)) (true) >>> iscube((2)) (false) >>> iscube(-1)) (true) >>> iscube(64)) (true) >>> iscube((0)) (true) >>> iscube((180)) (false)
bool iscube(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool iscube(long a) {
  if (a == 0) return true;
  long abs_a = std::abs(a);
  long root = round(std::cbrt(abs_a));
  return root * root * root == abs_a;
}","}
int main() {
    auto candidate = iscube;
    assert(candidate((1)) == (true));
    assert(candidate((2)) == (false));
    assert(candidate((-1)) == (true));
    assert(candidate((64)) == (true));
    assert(candidate((180)) == (false));
    assert(candidate((1000)) == (true));
    assert(candidate((0)) == (true));
    assert(candidate((1729)) == (false));
}
"
HumanEval/78,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⵜⵜⵓⵙⴽⴰⵔ ⵖⴼⴽ ⴰⴷ ⵜⵔⵔⴰ ⵢⴰⵜ ⵜⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵀⵉⵊⴰⴷⵉⵛⵎⴰⵍ ⴰⵎⵎ ⵜⴰⴳⵔⵓⵎⵎⴰ ⴷ ⴷⴰ ⵉⵜⵜⵉⴹⵉ ⵉⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵕⴹⵉⵚ ⵎⵔⴰⵡ ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ (ⴰⵎⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⵏⵖ ⴰⵎⵣⵡⴰⵔⵓ, ⵉⴳⴰ ⴰⵎⴹⴰⵏ ⴰⴳⴰⵎⴰⵏ ⴰⵅⴰⵜⴰⵔ ⵙⴳ 1 ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⴰⵙⵢⴰⴼⵓ ⵏ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵉⵎⵥⵥⵉⵏ). ⵡⵓⵟⵟⵓⵏⵏ ⵏ ⵓⴽⵕⴹⵉⵚ ⵎⵔⴰⵡ ⴳⴰⵏ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴳⴰⵏ 2, 3, 5, 7, 11, 13, 17... . ⴰⵢⴰⴷ ⵉⴳⴰⵏ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⵜⴰⵢ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⴰⴷ: 2, 3, 5, 7, B (= ⵓⴽⵕⴹⵉⵚ ⵎⵔⴰⵡ 11), D (= ⵓⴽⵕⴹⵉⵚ ⵎⵔⴰⵡ 13). ⴰⵙⵖⵏ: ⵉⵖⵢ ⴰⴷ ⵜⵙⵙⵏⵎ ⵉⵙ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵕⴹⵉⵚ ⴰⵀⴰⴷⴰⴷ ⵏⵖⴷ ⴰⵎⴹⵉⵚ, ⴷ ⵉⵙⵎⵎⴰⵍⵏ A,B,C,D,E,F, ⴰⵀⴰ ⴰⵀⴰ ⴰⵀⴰ ⴳⴰⵏ ⵜⵉⵔⵔⴰ ⵜⵉⴼⴰⵏ.
long hex_key(std::string num) {
","#include<assert.h>
#include<bits/stdc++.h>
long hex_key(std::string num) {
  long count = 0;
  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};
  for (char c : num) {
    if (prime_hex.count(c)) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = hex_key;
    assert(candidate((""AB"")) == (1));
    assert(candidate((""1077E"")) == (2));
    assert(candidate((""ABED1A33"")) == (4));
    assert(candidate((""2020"")) == (2));
    assert(candidate((""123456789ABCDEF0"")) == (6));
    assert(candidate((""112233445566778899AABBCCDDEEFF00"")) == (12));
}
"
HumanEval/79,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵉⴽⴹ ⴳ ⵜⴰⵍⵖⴰ ⵏ ⵓⴽⵛⵛⵓⵎ ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⴼⵍ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵓⴽⵛⵛⵓⵎ. ⵔⴰⴷ ⵜⵕⵓⵡⴰⵍ ⵜⴰⵡⵓⵔⵉ ⵜⴰⵡⵔⵉⵔⵜ, ⴷ ⴽⵓ ⴰⴽⴽⵡ ⵉⵙⵎⴷⵢⴰⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵛⵛⵓⵎ. ⴽⵓ ⴰⴽⴽⵡ ⵉⵙⵎⴷⵢⴰⵏ ⴳ ⵜⴰⵍⵖⴰ ⵔⴰⴷ ⵉⴳ '0' ⵏⵖ '1'. ⵔⴰⴷ ⵉⵍⵉⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵛⵛⵓⵎ 'db' ⴳ ⵜⵉⵣⵡⵉⵔⵉ ⴷ ⵜⴳⵉⵔⴰ ⵏ ⵜⴰⵍⵖⴰ. ⵔⴰⴷ ⵉⵍⵉⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⴼⴰⴷ ⴰⴷ ⵜⵜⵓⵙⵏⴼⵍ ⵜⴰⵍⵖⴰ. ⵉⵎⴷⵢⴰⵜⵏ: >>> decimal_to_binary((15)) (""db1111db"") >>> decimal_to_binary(32) (""db100000db"")
std::string decimal_to_binary(long decimal) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string decimal_to_binary(long decimal) {
  if (decimal == 0) {
    return ""db0db"";
  }
  std::string binaryString = """";
  long temp = std::abs(decimal);
  while (temp > 0) {
    binaryString = (temp % 2 == 0 ? ""0"" : ""1"") + binaryString;
    temp /= 2;
  }
  return ""db"" + binaryString + ""db"";
}","}
int main() {
    auto candidate = decimal_to_binary;
    assert(candidate((0)) == (""db0db""));
    assert(candidate((32)) == (""db100000db""));
    assert(candidate((103)) == (""db1100111db""));
    assert(candidate((15)) == (""db1111db""));
}
"
HumanEval/80,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔ ⵜⴰⵖⴹⴼⵜ s. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵥⵕ ⵉⵙ ⵜⴳⴰ ⵜⴰⵖⴹⴼⵜ ⴰⴷⴷⵓⵔ ⵏⵖ ⵓⵔ ⵉⴳⵉ. ⵜⴰⵖⴹⴼⵜ ⴰⴷⴷⵓⵔ ⵉⴳ ⵉⵍⵍⴰ ⵓⴳⴳⴰⵔ ⵏ 3 ⴷ ⴽⵓ 3 ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⴱⵔⵉⴷ ⵏⵏⵙⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> is_happy((""a"")) (false) >>> is_happy((""aa"")) (false) >>> is_happy((""abcd"")) (true) >>> is_happy((""aabb"")) (false) >>> is_happy(""adb"")) (true) >>> is_happy((xyy"") (false)
bool is_happy(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_happy(std::string s) {
  if (s.length() < 3) {
    return false;
  }
  for (size_t i = 0; i <= s.length() - 3; ++i) {
    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_happy;
    assert(candidate((""a"")) == (false));
    assert(candidate((""aa"")) == (false));
    assert(candidate((""abcd"")) == (true));
    assert(candidate((""aabb"")) == (false));
    assert(candidate((""adb"")) == (true));
    assert(candidate((""xyy"")) == (false));
    assert(candidate((""iopaxpoi"")) == (true));
    assert(candidate((""iopaxioi"")) == (false));
}
"
HumanEval/81,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⵙⵙⴰ ⵓⴰ ⴷⴰⵔⴰⵜ, ⴰⴷⴷⴰⴱⴰⵔⴰ ⵏ ⵜⴰⵍⵗⴰ ⵏ ⵜⴰⵍⵗⴰ ⵜⴰ ⵜⴰⴾⵏⴰⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜ ⵜⴰⴾⴰⵍⵜⴰⵍⵜ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵍ
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
  std::vector<std::string> letter_grades;
  for (float gpa : grades) {
    if (gpa == 4.0f) {
      letter_grades.push_back(""A+"");
    } else if (gpa > 3.7f) {
      letter_grades.push_back(""A"");
    } else if (gpa > 3.3f) {
      letter_grades.push_back(""A-"");
    } else if (gpa > 3.0f) {
      letter_grades.push_back(""B+"");
    } else if (gpa > 2.7f) {
      letter_grades.push_back(""B"");
    } else if (gpa > 2.3f) {
      letter_grades.push_back(""B-"");
    } else if (gpa > 2.0f) {
      letter_grades.push_back(""C+"");
    } else if (gpa > 1.7f) {
      letter_grades.push_back(""C"");
    } else if (gpa > 1.3f) {
      letter_grades.push_back(""C-"");
    } else if (gpa > 1.0f) {
      letter_grades.push_back(""D+"");
    } else if (gpa > 0.7f) {
      letter_grades.push_back(""D"");
    } else if (gpa > 0.0f) {
      letter_grades.push_back(""D-"");
    } else {
      letter_grades.push_back(""E"");
    }
  }
  return letter_grades;
}","}
int main() {
    auto candidate = numerical_letter_grade;
    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)""A+"", (std::string)""B"", (std::string)""C-"", (std::string)""C"", (std::string)""A-""})));
    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)""D+""})));
    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)""D-""})));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)""E""})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)""D"", (std::string)""D-"", (std::string)""C-"", (std::string)""B"", (std::string)""B+""})));
    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)""E"", (std::string)""D-""})));
}
"
HumanEval/82,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⵔⵔⴰⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵖⵉⵍⵓⴼ ⴰⵔ ⵉⵜⵜⴰⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵓⵖⵉⵍⵓⴼ ⵓⵖⵉⵍⵓⴼ ⴰⵎⵣⵡⴰⵔⵓ ⵏⵖⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ ⴰⵎⴷⵢⴰ: "" prime_length (((""Hello"")) (true) >>> prime_length (((""abcdcba"")) (true) >>> prime_length (((""kittens"")) (true) >>> prime_length (((""orange"")) (false)
bool prime_length(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(int n) {
  if (n <= 1) return false;
  for (int i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

bool prime_length(std::string string) {
  return is_prime(string.length());
}","}
int main() {
    auto candidate = prime_length;
    assert(candidate((""Hello"")) == (true));
    assert(candidate((""abcdcba"")) == (true));
    assert(candidate((""kittens"")) == (true));
    assert(candidate((""orange"")) == (false));
    assert(candidate((""wow"")) == (true));
    assert(candidate((""world"")) == (true));
    assert(candidate((""MadaM"")) == (true));
    assert(candidate((""Wow"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""HI"")) == (true));
    assert(candidate((""go"")) == (true));
    assert(candidate((""gogo"")) == (false));
    assert(candidate((""aaaaaaaaaaaaaaa"")) == (false));
    assert(candidate((""Madam"")) == (true));
    assert(candidate((""M"")) == (false));
    assert(candidate((""0"")) == (false));
}
"
HumanEval/83,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵏⵓⵍⴼⵓ ⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵏⵉⴳⵏ ⵉⵎⵏⵉⴳⵏ ⵏ n-ⴰⵎⵉⴹⴰⵏ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵏⵖⴷ ⵉⵜⵜⵎⵜⵉⵏ ⵙ 1.
long starts_one_ends(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long starts_one_ends(long n) {
  if (n <= 0) {
    return 0;
  }
  if (n == 1) {
    return 1;
  }
  long starts_with_one = std::pow(10, n - 1);
  long ends_with_one = std::pow(10, n - 1);
  long starts_and_ends_with_one = std::pow(10, n - 2);
  return starts_with_one + ends_with_one - starts_and_ends_with_one;
}","}
int main() {
    auto candidate = starts_one_ends;
    assert(candidate((1)) == (1));
    assert(candidate((2)) == (18));
    assert(candidate((3)) == (180));
    assert(candidate((4)) == (1800));
    assert(candidate((5)) == (18000));
}
"
HumanEval/84,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⴷⵉ N, ⵙⵙⵓⴼⵖ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴳ ⵜⴱⵉⵏⴰⵔⵉⵜ. ⴰⵎⴷⵢⴰ >>> solve((1000)) (""1"") >>> solve((150)) (""110"") >>> solve((147)) (""1100"") ⵉⵎⵙⵏⴼⴰⵍⵏ: @N ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ: 0 ≤ N ≤ 10000. ⴰⵙⵓⴼⵖ: ⵜⴰⵣⵍⵉⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵏⴷⵉ
std::string solve(long N) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string solve(long N) {
  if (N < 0 || N > 10000) {
    return """"; // Or handle invalid input as needed
  }
  long sum = 0;
  std::string s = std::to_string(N);
  for (char c : s) {
    sum += c - '0';
  }
  if (sum == 0) {
    return ""0"";
  }
  std::string binary_sum = """";
  while (sum > 0) {
    binary_sum = (sum % 2 == 0 ? ""0"" : ""1"") + binary_sum;
    sum /= 2;
  }
  return binary_sum;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((1000)) == (""1""));
    assert(candidate((150)) == (""110""));
    assert(candidate((147)) == (""1100""));
    assert(candidate((333)) == (""1001""));
    assert(candidate((963)) == (""10010""));
}
"
HumanEval/85,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⵏⵙⴽⵔ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵓⵔ ⵉⴳⵉⵏ ⵓⵎⵥⵥⵢ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵏⵙⵙⴽⵔ ⴰⵙⵓⴳⴳⵣ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵉⵙⵓⴳⴳⵣⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵉⵎⴷⵢⴰⵜⵏ: >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7}))) (2)
long add(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long add(std::vector<long> lst) {
  long sum = 0;
  for (long i = 1; i < lst.size(); i += 2) {
    if (lst[i] % 2 == 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add;
    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));
    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));
    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));
}
"
HumanEval/86,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⵉⵏⵜⴼⵓⵏⵛⵉⵓⵏ ⵉⵜⴰⴾⴰⵏ ⵙⵜⵔⵢⵏⴶ ⵜⵓⵍⴰⵙ ⵉⴾⴼⴰ ⵙⵜⵔⵢⵏⴶ ⵉⴾⵏⴰⵏ ⴰⵍⵆⴰⵍ ⵏⵢⵜ ⴰⵍⵆⴰⵍ ⵏ ⵙⵜⵔⵢⵏⴶ ⵢⵈⵈⴰⵍ ⵙⵜⵔⵢⵏⴶ ⵙ ⵉⴶⵂⴰⵏⴷⴰⴶⴰⵏ ⴼⵓⴾ (ⵉⵣⵍⴰⵉⴰⵏ ⵙ ⵙⴱⵢⵛⵢ) ⴰⵂⴰⵏⵢⵏ ⵉⵙⵉⵎ ⵢⵉⵏⴰⵉⴰⵏ ⵙ ⵉⴾⵏⴰⵏ ⴰⵍⵆⴰⵍⴰⵏ ⴼⵓⴾ ⵙ ⴰⵍⵆⴰⵍ ⵉⴾⵏⴰⵏ ⵙ ⴰⵍⵈⵉⵎ ⵓⴰⵏ ⴰⵙⵛⵉⵉ ⴰⵜⵓⴰⵗⴱⴰⵍ: ⵉⵋⵋⴰ ⴰⴷ ⵉⴾⴼⴰ ⴰⵍⵆⴰⵍ ⵏ ⵉⵙⵎⴰⵓⴰⵏ ⴷ ⵉⵂⴰⵏⴷⴰⴶⴰⵏ ⵓⵉⵏ ⵜⴰⵗⵔⵉⵙⵜ ⴰⵍⵎⵉⵜⴰⵍ: >>> ⴰⵏⵜⵉ_ⵙⵂⴰⴼⵍⵢ (((""ⵂⵉ"")) (""ⵂⵉ"") >>> ⴰⵏⵜⵉ_ⵙⵂⴰⴼⵍⵢ (((""ⵂⵉⵍⵍⵓ"")) (""ⵢⵂⵍⵓ"") >>> ⴰⵏⵜⵉ_ⵙⵂⴰⴼⵍⵢ (((""ⵂⵉⵍⵍⵓ ⵓⵓⵔⵍⴷ!!)) (""ⵂⵉⵍⵍⵓ !!!Wⴷⵍⵓⵔ"")
std::string anti_shuffle(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string anti_shuffle(std::string s) {
  std::string result = """";
  std::string current_word = """";
  for (char c : s) {
    if (c == ' ') {
      std::sort(current_word.begin(), current_word.end());
      result += current_word;
      result += c;
      current_word = """";
    } else {
      current_word += c;
    }
  }
  std::sort(current_word.begin(), current_word.end());
  result += current_word;
  return result;
}","}
int main() {
    auto candidate = anti_shuffle;
    assert(candidate((""Hi"")) == (""Hi""));
    assert(candidate((""hello"")) == (""ehllo""));
    assert(candidate((""number"")) == (""bemnru""));
    assert(candidate((""abcd"")) == (""abcd""));
    assert(candidate((""Hello World!!!"")) == (""Hello !!!Wdlor""));
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hi. My name is Mister Robot. How are you?"")) == ("".Hi My aemn is Meirst .Rboot How aer ?ouy""));
}
"
HumanEval/87,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⵏⵖⵎⵉⵙⵏ ⵏ ⵙⵉⵏ ⵡⵓⴳⴳⵓⴳⵏ, ⴰⵎⵎ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵏ ⵓⴽⵙⴰⵢ, ⵏⵏⴰ ⵢⵓⵙⴰⵏ ⴰⵎⵎ ⵜⵎⵜⵜⵉ, ⵎⴰⵛⴰ, ⵓⵔ ⵢⴰⴽⵙⵓⵍ ⴰⵎⵎ ⵜⵎⵜⵜⵉ, ⴽⵓ ⵜⴰⵡⵔⵉⵔⵜ ⵜⵣⵎⵔ ⴰⴷ ⵜⵍⵍⴰ ⴳ ⵓⵟⵟⵓⵏ ⵏ ⵜⵔⵙⴰⵍ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⴷⴰⵜ lst, ⴷ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ x, ⵉⵔⵣⵣⵓ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ x ⴳ ⵓⵎⵓⵙⵙⵓ, ⴷ ⵓⵎⴹⴰⵏ ⵏ ⵓⴽⵙⴰⵢ ⵏ ⵓⴽⵙⴰⵢ, [(x1, y1), (x2, y2) ...] ⵣⵓⵏⴷ ⵎⴰⵙ ⵉⴳⴰ ⴽⵓ ⵜⴰⴱⵍⵍⵜ ⵢⴰⵏ ⵓⴽⵓⵉⴷⵉⵏⴰⵜ - (ⵜⴰⵙⵉⴹ, ⵜⵔⵙⴰⵍ), ⴰⵔⵜⴰⵢⵏ ⵙ 0. ⵙⵙⵓⴷⵙ ⵉⴽⵓⵉⴷⵉⵏⴰⵜⵏ ⴳ ⵜⵉⵣⵡⵉⵔⵉ ⵙ ⵜⵉⵔⵙⴰⵍ ⴳ ⵓⴱⵔⵉⴷ ⵏ ⵓⴽⵙⴰⵢ. ⴰⵡⴷ, ⵙⵙⵓⴷⵙ ⵉⴽⵓⵉⴷⵉⵏⴰⵜⵏ ⵏ ⵜⵔⵙⴰⵍ ⴳ ⵓⴱⵔⵉⴷ ⵏ ⵓⴽⵙⴰⵢ ⴳ ⵓⴱⵔⵉⴷ ⵏ ⵓⴽⵙⴰⵢ. ⵉⵎⴷⵢⴰⵜⵏ: >>> get_row((std::vector<stdvector<st>, long (long (long) {long) {long) {long) {long) {long) {long) {long) {long) {long) {long) {long) {long) {long) {long) {long) {long) long (long) {long) {long) {long) long {long) {long) {long) long {long {long) {long {long) long {long {long) long {long {long) long {long {long {long) long {long {long {long) long {long {long {long {long} {long {long {long} {long {long} long {long {long {long} long {long {long} long {long {long} long {long {long {long} long {long {long} long {long {long} long {long {long} long {long} long {long {long {long} long {long} long {long {long} long {long {long} long {long {long {long {long} long } {long {long {long
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
  std::vector<std::tuple<long, long>> coordinates;
  for (long i = 0; i < lst.size(); ++i) {
    std::vector<std::pair<long, long>> row_coords;
    for (long j = 0; j < lst[i].size(); ++j) {
      if (lst[i][j] == x) {
        row_coords.push_back({j, i});
      }
    }
    std::sort(row_coords.rbegin(), row_coords.rend());
    for (const auto& coord_pair : row_coords) {
      coordinates.emplace_back(coord_pair.second, coord_pair.first);
    }
  }
  return coordinates;
}","}
int main() {
    auto candidate = get_row;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));
    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));
}
"
HumanEval/88,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵎⴽ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵃⵍⵉⵏ, ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵎⵙⴰⵙⴰ, ⵔⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵓⵡⵉⴽⵜⵓⵔ ⵙ ⵓⵍⵖⵓ ⴰⵎⵇⵔⴰⵏ ⵎⴽ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⴰⵎⴳⴳⴰⵔⵓ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵏⵖⴷ ⵔⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵙ ⵓⵍⵖⵓ ⴰⵎⵣⴰⵔⴰⵢⵏ ⵎⴽ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⴰⵎⴳⴳⴰⵔⵓ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵜⵓⵏⵖⵉⵍⵜ: * ⵓⵔ ⵜⵙⵙⵏⴼⵍ ⵓⵡⵉⴽⵜⵓⵔ. ⵉⵎⴷⵢⴰⵜⵏ: >>> sort_array(std::vector<long>(())) (std::vector<long>(((5}))) (std::vector<long>) >>> sort_array:{(long>:{(long>{long} (long} (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)
std::vector<long> sort_array(std::vector<long> array) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> sort_array(std::vector<long> array) {
  std::vector<long> sorted_array = array;
  if (sorted_array.empty()) {
    return sorted_array;
  }
  long first = 0;
  long last = sorted_array.size() - 1;
  if ((first + last) % 2 != 0) {
    std::sort(sorted_array.begin(), sorted_array.end());
  } else {
    std::sort(sorted_array.rbegin(), sorted_array.rend());
  }
  return sorted_array;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));
    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));
    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));
    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));
}
"
HumanEval/89,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵗⵏⵓ ⵏ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏ ⴰⵏⵛⵔⵉⴱⵜ ⵜⴰ ⵢⵂⴰ ⵙⵜⵔⵉⵏⴶ ⵛⵂⵓⵏⴷ ⴰⵍⵎⴰⵗⵏⴰ ⵜⵓⵍⴰⵙ ⵜⴰⵔⴰⵓ ⵙⵜⵔⵉⵏⴶ ⵉⴾⵏⴰⵏ ⴰⵏⵛⵔⵉⴱⵜ ⵙ ⴰⵍⴾⴰⴷⴰⵏ ⵓⵉⵏ ⴰⵍⴾⴰⴷⴰⵏ ⴰⵈⵈⴰⵍⵏⵢⵏ ⴰⴾⴾⵓⵣⴰⵏⵢⵏ ⴰⵍⴾⴰⴷⴰⵏ ⵓⵉⵏ ⴰⵍⴾⴰⴷⴰⵏ ⵉⵋⵋⴰⵏⵢⵏ ⴰⴾⴾⵓⵣⴰⵏ ⵙ ⵉⵎⵎⵉⴾ ⵓⴰ ⵙ ⵉⵋⵋⴰⵏ ⴰⵍⴾⴰⴷⴰⵏ ⵓⵉⵏ ⵙⴰⵏⴰⵜⴰⵜⴰⵜ ⵂⴰⵔ ⵙⴰⵏⴰⵜ ⵉⴷⴰⴶⴰⵏ ⴰⵍⵎⵉⵜⴰⵍ: >>> ⴰⵏⵛⵔⵉⴱⵜ (((""ⵂⵉ"")) (""ⵍⵎ"") >>> ⴰⵏⵛⵔⵉⴱⵜ (((""ⴰⵙⴷⴼⵂⴶⵂⵢⴾⵍ"")) (""ⵢⵓⵂⵋⴾⵍⵏⵓⴱ"") >>> ⴰⵏⵛⵔⵉⴱⵜ (((""ⴶⴼ"")) (""ⴾ"") >>> ⴰⵏⵛⵔⵉⴱⵜ (((""ⵢⵜ"")) (""ⵉⵆ"")
std::string encrypt(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encrypt(std::string s) {
  std::string encrypted_s = """";
  int shift = 2 * 2;
  for (char c : s) {
    if (isalpha(c)) {
      char base = islower(c) ? 'a' : 'A';
      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);
    } else {
      encrypted_s += c;
    }
  }
  return encrypted_s;
}","}
int main() {
    auto candidate = encrypt;
    assert(candidate((""hi"")) == (""lm""));
    assert(candidate((""asdfghjkl"")) == (""ewhjklnop""));
    assert(candidate((""gf"")) == (""kj""));
    assert(candidate((""et"")) == (""ix""));
    assert(candidate((""faewfawefaewg"")) == (""jeiajeaijeiak""));
    assert(candidate((""hellomyfriend"")) == (""lippsqcjvmirh""));
    assert(candidate((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")) == (""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""));
    assert(candidate((""a"")) == (""e""));
}
"
HumanEval/90,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ next_smallest ((() ⵏⵏⴰ ⵉⵙⵏⴼⵍⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵡⵉⵙⵙ ⵙⵉⵏ ⵉⵎⵥⵥⵉⵏ ⴳ ⵓⴽⵜⵓⵔ. ⵙⵔⵙⵏ None ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴰⴷ. >>> next_smallest (((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) 2 >>> next_smallest (((std::vector<long>(long) 5, (long) 1, (long) 4, (long) 3, (long) 2))) >>> 2 next_smallest (((std::vector<long>())) std::nullopt >>> next_smallest (((std::vector<long>{(long) 1, (long) 1))) std::nullopt
std::optional<long> next_smallest(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> next_smallest(std::vector<long> lst) {
  if (lst.size() < 2) {
    return std::nullopt;
  }
  std::sort(lst.begin(), lst.end());
  if (lst[0] == lst[1]) {
    return std::nullopt;
  }
  return lst[1];
}","}
int main() {
    auto candidate = next_smallest;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);
    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);
}
"
HumanEval/91,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⴷ ⴰⵜⵓⴰⵣⴰⵣⴰⵍ ⵓⴰⵔⴷ ⵢⵈⵢⵍ ⴰⵉⴾⵏⴰⵏ ⴰⴾⴰⵍ, ⴰⴷ ⴰⵜⵓⴰⵣⴰⵍ ⵓⴰⵔⴷ ⵢⵈⵢⵍ ⴰⵉⴾⵏⴰⵏ ⴰⴾⴰⵍ. ⴰⴾⴰⵍ ⵢⵈⴰⵍ ⵜⴰⴷⴰⴱⵉⵜ ⵜⴰⴱⴷⴰⵏ ⵙ ⵉⵙⵉⵎ ⵓⴰⵏ """"ⵉ"""". ⵜⴰⴷⴰⴱⵉⵜ ⵜⴰⵈⴰⵍ ⴰⵉⴾⵏⴰⵏ ⵙ """""", """""" ⵎⵢⵗ """"!"""" ⴰⵍⵎⵉⵜⴰⵍ: >>> ⴰⵈⵢⵍ ⴰⵉⴾⵏⴰⵏ ⴰⵉⴾⵏⴰⵏ""""""""""""ⵂⴰⵍⵓ ⵓⵓⵔⵍⴷ"")) (0) >>> ⴰⵈⵢⵍ ⴰⵉⴾⵏⴰⵏ""""""""ⴰⵗⴰⵍⴰⵉ ⴰⵈⴰⵍ ⴰⵂⵓⴾⴰⵍ. ⴰⵂⵓⴾⴰⵍ ⴰⵈⴰⵍ ⴰⵉⴾⵏⴰⵏ. ⴰⵂⵓⴾⴰⵍ ⴰⵈⴰⵍ ⴰⵂⵓⴾⴰⵍ ⴰⵂⵓⴾⴰⵍ"")) (1)
long is_bored(std::string S) {
","#include<assert.h>
#include<bits/stdc++.h>
long is_bored(std::string S) {
  long boredom_count = 0;
  std::string current_sentence = """";
  for (char c : S) {
    current_sentence += c;
    if (c == '.' || c == '?' || c == '!') {
      std::stringstream ss(current_sentence);
      std::string first_word;
      ss >> first_word;
      if (first_word == ""I"") {
        boredom_count++;
      }
      current_sentence = """";
    }
  }
  return boredom_count;
}","}
int main() {
    auto candidate = is_bored;
    assert(candidate((""Hello world"")) == (0));
    assert(candidate((""Is the sky blue?"")) == (0));
    assert(candidate((""I love It !"")) == (1));
    assert(candidate((""bIt"")) == (0));
    assert(candidate((""I feel good today. I will be productive. will kill It"")) == (2));
    assert(candidate((""You and I are going for a walk"")) == (0));
}
"
HumanEval/92,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏ. ⴷⴰ ⵢⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵎⵎ ⵓⵖⵣⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵢⴰⴹⵏⵉⵏ, ⴷ ⵡⵓⵟⵟⵓⵏⵏ ⴰⴽⴽⵡ ⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⴷⴰ ⵢⴰⴽⴽⴰ ⵜⵉⴷⵜ ⴳ ⴽⵔⴰ ⵏ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏ. ⵉⵎⴷⵢⴰⵜⵏ >>> ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool any_int(float x, float y, float z) {
","#include<assert.h>
#include<bits/stdc++.h>
bool any_int(float x, float y, float z) {
  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {
    return false;
  }
  long ix = static_cast<long>(x);
  long iy = static_cast<long>(y);
  long iz = static_cast<long>(z);
  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);
}","}
int main() {
    auto candidate = any_int;
    assert(candidate((float(2)), (float(3)), (float(1))) == (true));
    assert(candidate((2.5f), (float(2)), (float(3))) == (false));
    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));
    assert(candidate((float(2)), (float(6)), (float(2))) == (false));
    assert(candidate((float(4)), (float(2)), (float(2))) == (true));
    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));
    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));
    assert(candidate((float(2)), (float(1)), (float(1))) == (true));
    assert(candidate((float(3)), (float(4)), (float(7))) == (true));
    assert(candidate((3.0f), (float(4)), (float(7))) == (false));
}
"
HumanEval/93,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⵢⵔⵔⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵜⴰⴱⵔⴰⵜ, ⴷ ⴷⴰ ⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⵙ ⵜⵖⴰⵔⴰⵙⵜ ⵏⵏⴰ ⵉⵙⵏⴼⴰⵍⵏ ⵜⵉⴼⵔⵉⵙⵉⵏ ⵏ ⵉⴼⵔⵉⵙⵏ, ⴷⴰ ⵉⵙⵏⴼⴰⵍ ⴽⵓⵍⵍⵓ ⵉⵎⵙⵍⵉ ⴳ ⵜⴱⵔⴰⵜ ⵙ ⵡⴰⵔⵔⴰ ⵏⵏⴰ ⵢⵓⵡⵉⵏ ⵙ 2 ⵏ ⵡⴰⵏⵙⴰ ⴷⴰⵜ ⵏ ⵓⵎⵙⵍⵉ ⴳ ⵓⴳⵎⵎⴰⵢ ⴰⴱⵔⵉⴷⵉ. ⴷⴰ ⵜⵜⵓⵙⵏⵎⵍⵏ ⵉⴼⵔⵉⵙⵏ ⴷⴰⵢ. ⵉⵎⴷⵢⴰⵜⵏ: >>> encode((""test"")) (""TGST"") >>> encode((""This is a message"")) (""tHKS KS C MGSSCGG"")
std::string encode(std::string message) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encode(std::string message) {
  std::string encoded_message = """";
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  std::map<char, char> vowel_map = {
      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},
      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};
  for (char c : message) {
    if (isalpha(c)) {
      char swapped_case = islower(c) ? toupper(c) : tolower(c);
      if (vowels.count(c)) {
        encoded_message += vowel_map[c];
      } else {
        encoded_message += swapped_case;
      }
    } else {
      encoded_message += c;
    }
  }
  return encoded_message;
}","}
int main() {
    auto candidate = encode;
    assert(candidate((""TEST"")) == (""tgst""));
    assert(candidate((""Mudasir"")) == (""mWDCSKR""));
    assert(candidate((""YES"")) == (""ygs""));
    assert(candidate((""This is a message"")) == (""tHKS KS C MGSSCGG""));
    assert(candidate((""I DoNt KnOw WhAt tO WrItE"")) == (""k dQnT kNqW wHcT Tq wRkTg""));
}
"
HumanEval/94,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⴷⴰ ⵜⵜⴰⵔⴰⵏ ⴰⴷ ⵜⴰⴼⴷ ⴰⵜⵉⴳ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ ⴷ ⴰⴷ ⵜⵔⴰⵔⵎ ⵜⴰⴳⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ. ⵉⵎⴷⵢⴰⵜⵏ: >>> skjkasdkd((std:: vector<long>((long) 0, (long) 3, (long) 2, (long) 1, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) (long) 3, (long) (long) 3, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long
long skjkasdkd(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

long sum_digits(long n) {
  long sum = 0;
  std::string s = std::to_string(n);
  for (char c : s) {
    sum += c - '0';
  }
  return sum;
}

long skjkasdkd(std::vector<long> lst) {
  long largest_prime = -1;
  for (long num : lst) {
    if (num > largest_prime && is_prime(num)) {
      largest_prime = num;
    }
  }
  if (largest_prime == -1) {
    return 0;
  }
  return sum_digits(largest_prime);
}","}
int main() {
    auto candidate = skjkasdkd;
    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));
    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));
    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));
    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)8191}))) == (19));
    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));
    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));
}
"
HumanEval/95,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⵛⵛⴰⵔⴻⵆ, ⴰⴷⴷoⴱⴰⵜ ⵜⵉⴷⵉⵜ ⵎⴻⴶⵂ ⴰⵙ ⵜⵉⵛⴰⵔⴻⵆ ⴼⵓⴾ ⵏⴰⵙⵏⴰⵜ ⴰⵈⵈⴰⵍⴰⵏ ⵙⵜⵔⵉⵏⴶⵙ ⴷⴰⵗ ⵎⴰⴷⵔⵓⵉⵏ ⵎⴻⵗ ⴼⵓⴾ ⵏⴰⵙⵏⴰⵜ ⵙⵜⵔⵉⵏⴶⵙ ⴷⴰⵗ ⵎⴰⴶⵔⴰⴷ ⵓⴰ ⵎⴰⵈⵈⵓⵔⵏⴻⵏ, ⵎⴻⵗ ⴰⴷⴷoⴱⴰⵜ ⵜⵉⴷⵉⵜ. ⵜⴰⵛⴰⵔⴻⵆ ⴰⴷⴷoⴱⴰⵜ ⵜⵉⴷⵉⵜ ⴰⵙ ⵙⵜⵔⵉⵏⴶⵙ ⵓⴰ ⵉⴾⴼⴰⵏ ⴻⵈⵈⴰⵍ ⵏⴰⵜ ⵙⵜⵔⵉⵏⴶⵙ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵎⵉⵜⴰⵍ: >>>ⵛⴻⴾ_ⴷⵉⵛⴻ_, """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
bool check_dict_case(std::map<std::string,std::string> dict) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_dict_case(std::map<std::string,std::string> dict) {
  if (dict.empty()) {
    return false;
  }
  bool first_key_lower = false;
  bool first_key_upper = false;
  auto it = dict.begin();
  if (!it->first.empty() && islower(it->first[0])) {
    first_key_lower = true;
  } else if (!it->first.empty() && isupper(it->first[0])) {
    first_key_upper = true;
  } else {
    return false;
  }
  for (const auto& pair : dict) {
    if (pair.first.empty()) {
      return false;
    }
    bool current_lower = true;
    bool current_upper = true;
    for (char c : pair.first) {
      if (!islower(c)) {
        current_lower = false;
      }
      if (!isupper(c)) {
        current_upper = false;
      }
    }
    if (first_key_lower && !current_lower) {
      return false;
    }
    if (first_key_upper && !current_upper) {
      return false;
    }
    if (!first_key_lower && !first_key_upper) {
        if (current_lower) first_key_lower = true;
        else if (current_upper) first_key_upper = true;
        else return false;
    }
  }
  return first_key_lower || first_key_upper;
}","}
int main() {
    auto candidate = check_dict_case;
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""b"", ""banana""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""A"", ""banana""}, {""B"", ""banana""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""5"", ""banana""}, {""a"", ""apple""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""STATE"", ""NC""}, {""ZIP"", ""12345""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""fruit"", ""Orange""}, {""taste"", ""Sweet""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>())) == (false));
}
"
HumanEval/96,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⵙⵎⵔⵙ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⵏⴳⴰⵍ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴷ ⵡⵉⵏ ⵡⴰⵔ n. ⵙ ⵓⵎⴷⵢⴰ: >>> count_up_to((5)) (std::vector<long>({long) 2, (long) 3})) >>> count_up_to(11) (std::vector<long>({long) 2, (long) 3, (long) 5, (long) 7)) >>> count_up_to(0)) (std::vector<long>)) >>> count_up_to(20)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7, (long) 11, (long) 1, (long) 3, (long) 17, (long) 19)) >>> count_up_1) (std:vector<long> >>> count_up_to(18): (std:vector<long>((3, (long)) 11, (long) 5, (long) 17)) (std: (long) 1, (long)) (long)
std::vector<long> count_up_to(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long num) {
  if (num <= 1) return false;
  for (long i = 2; i * i <= num; ++i) {
    if (num % i == 0) return false;
  }
  return true;
}

std::vector<long> count_up_to(long n) {
  std::vector<long> primes;
  if (n <= 2) {
    return primes;
  }
  for (long i = 2; i < n; ++i) {
    if (is_prime(i)) {
      primes.push_back(i);
    }
  }
  return primes;
}","}
int main() {
    auto candidate = count_up_to;
    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));
    assert(candidate((0)) == (std::vector<long>()));
    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));
    assert(candidate((1)) == (std::vector<long>()));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));
    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));
}
"
HumanEval/97,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴱⵔⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⴰⵔ ⵢⴰⴽⴽⴰ ⵜⴰⵢⴰⴼⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴰⴳⵣⵣⵓⵎⵜ ⵏⵏⵙⵏ. ⵏⵙⵙⵏ ⵉⵙ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⵙⴽⵛⵎ ⴰⵀⴰ ⵉⴳⴰ ⵜ ⵉⵖⵓⴷⴰⵏ. ⵉⵎⴷⵢⴰⵜⵏ: >>> ⵓⵙⵎⴽⵍ (((148), (412)) (16) >>> ⵓⵙⵎⴽⵍ (((19), (28)) (72) >>> ⵓⵙⵎⴽⵍ (((2020), (1851)) (0) >>> ⵓⵙⵎⴽⵍ (((14), (-15)) (20)
long multiply(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>
long multiply(long a, long b) {
  long unit_a = std::abs(a) % 10;
  long unit_b = std::abs(b) % 10;
  return unit_a * unit_b;
}","}
int main() {
    auto candidate = multiply;
    assert(candidate((148), (412)) == (16));
    assert(candidate((19), (28)) == (72));
    assert(candidate((2020), (1851)) == (0));
    assert(candidate((14), (-15)) == (20));
    assert(candidate((76), (67)) == (42));
    assert(candidate((17), (27)) == (49));
    assert(candidate((0), (1)) == (0));
    assert(candidate((0), (0)) == (0));
}
"
HumanEval/98,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙ ⵜⵢⵔⵣⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ s, ⴰⵟⵟⴰⵚ ⵏ ⵉⵎⵓⴽⴽⴰⵙⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> count_upper (((""aBCdEf"")) (1) >>> count_upper (((""abcdefg"")) (0) >>> count_upper (((""dBBE"")) (0)
long count_upper(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long count_upper(std::string s) {
  long count = 0;
  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};
  for (long i = 0; i < s.length(); ++i) {
    if (i % 2 == 0 && upper_vowels.count(s[i])) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_upper;
    assert(candidate((""aBCdEf"")) == (1));
    assert(candidate((""abcdefg"")) == (0));
    assert(candidate((""dBBE"")) == (0));
    assert(candidate((""B"")) == (0));
    assert(candidate((""U"")) == (1));
    assert(candidate(("""")) == (0));
    assert(candidate((""EEEE"")) == (2));
}
"
HumanEval/99,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵡⴰⵜⵉⴳ (ⵜⵉⵔⵉⵜ) ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ ⴰⵎⴹⴰⵏ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵏⵏⴰ ⵢⵓⴳⴳⵔⵏ ⵉ ⵡⴰⵏⵏⴰⵢ. ⵉⵖ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⴰⵔⴰⵢ ⴳⵔ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴷⵓⵏ ⴰⵙ ⵙⴳ ⵓⵎⵢⴰ. ⵉⵎⴷⵢⴰⵜⵏ >>> closest_integer (((""10"")) (10) >>> closest_integer (((""15.3"")) ⴰⵙⴳⵓⵎ (15): ⴰⵙⵎⵓⵜⵜⴳ ⴳ ⵓⴱⵔⴰⵔ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⵢⴰ ⵉⴳⴰ ⵡⵉⵏⵏⴰ ⵉⴳⴰⵏ ⴰⵎⵣⴰⵔⴰⵢ ⴳⵔ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵡⴰⵏⵏⴰⵢ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⵓⵖⵓⵍ ⵉⴳⴰ ⵡⴰⵏⵏⴰⵢ ⵢⵓⴳⴳⵔⵏ ⵙⴳ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ. ⵙ ⵓⵎⴷⵢⴰ closest_integer (((""14.5"") ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⵜⵜⴰⴽⴽⴰ 15 ⴷ closest_integer ((-14.5"") ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⵜⵜⵓⵙⵓⵖⵓⵍ -15.
long closest_integer(std::string value) {
","#include<assert.h>
#include<bits/stdc++.h>
long closest_integer(std::string value) {
  double num = std::stod(value);
  if (num >= 0) {
    if (num - std::floor(num) <= 0.5) {
      return static_cast<long>(std::floor(num));
    } else {
      return static_cast<long>(std::ceil(num));
    }
  } else {
    if (std::ceil(num) - num <= 0.5) {
      return static_cast<long>(std::ceil(num));
    } else {
      return static_cast<long>(std::floor(num));
    }
  }
}","}
int main() {
    auto candidate = closest_integer;
    assert(candidate((""10"")) == (10));
    assert(candidate((""14.5"")) == (15));
    assert(candidate((""-15.5"")) == (-16));
    assert(candidate((""15.3"")) == (15));
    assert(candidate((""0"")) == (0));
}
"
HumanEval/100,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⵏⴰⴽⴽⴰ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⴽⵔ ⵢⴰⵜ ⵜⵔⴱⴰⵜ ⵏ n ⵉⵙⵡⵉⵔⵏ ⵏ ⵉⵅⵅⴰⵎⵏ. ⴰⵙⵡⵉⵔ ⴰⵎⵣⵡⴰⵔⵓ ⵖⵓⵔⵙ n ⵉⵅⵅⴰⵎⵏ. ⴰⵎⴹⴰⵏ ⵏ ⵉⵅⵅⴰⵎⵏ ⴳ ⵓⵙⵡⵉⵔ ⴰⴹⵏⵉⵏ ⵉⴳⴰ: - ⴰⵎⴹⴰⵏ ⴰⵎⵣⴰⵔⴰⵢ ⴰⴹⵏⵉⵏ ⵉⵖ ⵉⴳⴰ n ⴰⵎⵣⴰⵔⴰⵢ. - ⴰⵎⴹⴰⵏ ⴰⵎⵣⴰⵔⴰⵢ ⴰⴹⵏⵉⵏ ⵉⵖ ⵉⴳⴰ n ⴰⵎⵣⴰⵔⴰⵢ. ⵙⵙⴽⵔ ⴰⵎⴹⴰⵏ ⵏ ⵉⵅⵅⴰⵎⵏ ⴳ ⴽⵓ ⴰⵙⵡⵉⵔ ⴳ ⵢⴰⵏ ⵓⴽⵜⵓⵔ, ⴳ ⵉⵍⵍⴰ ⵉⴼⵔⴷⵉⵙ ⴳ ⵓⵙⵖⵍ ⵏ i ⵉⵙⵎⴷⵢⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵅⵅⴰⵎⵏ ⴳ ⵓⵙⵡⵉⵔ (ⵉ+1). ⵉⵎⴷⵢⴰⵜⵏ: >>> make_a_pile(3) (std::vector<long>{long)3, (long)5, (long)7}))
std::vector<long> make_a_pile(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> make_a_pile(long n) {
  std::vector<long> pile;
  long current_stones = n;
  for (int i = 0; i < n; ++i) {
    pile.push_back(current_stones);
    if (current_stones % 2 != 0) {
      current_stones += 2;
    } else {
      current_stones += 2;
    }
  }
  return pile;
}","}
int main() {
    auto candidate = make_a_pile;
    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));
    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));
    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));
    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));
    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));
}
"
HumanEval/101,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⴷ ⴰⵜ ⵉⴼⴽⴰ ⵜⴰⵡⴰⵍⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵏⵏⴰ ⵉⵜⵜⵓⵢⴼⴹⵏ ⵙ ⵜⵉⴼⵔⴽⵉⵏ ⵏⵖ ⵉⵙⴰⵢⵔⴰⵔⵏ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴱⴹⵓ ⵜⴰⵡⴰⵍⵜ ⵙ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⴰⵍⵜ ⵏ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> words_string (((""ⵙⵍⵉⵎⵜ, ⵉⵙⵎ ⵉⵏⵓ ⵢⵓⵏ"")) (std::vector<std::string>({(std::string) ""ⵙⵍⵉⵎⵜ"", (std::string) ""ⵙⵍⵉⵎⵜ"", (std::string) ""ⵙⵍⵉⵎⵜ"", (std::string) ""ⵉⵙⵎ"", (std::string) ""ⵉⵙⵎ"", (std::string) ""ⵊⵓⵏ""})) >>> words_string ((((""ⵢⵉⴹ, ⵙⵉⵏ, ⴽⵕⴰⴹ, ⴽⴽⵓⵥ, ⵙⵎⵎⵓⵙ, ⵚⴹⵉⵚ"")) (std::vector<std::string>((((((stdstring) ""ⵢⵉⴹ, (st::string) "" (std::string) ""
std::vector<std::string> words_string(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> words_string(std::string s) {
  std::vector<std::string> words;
  std::string current_word;
  for (char c : s) {
    if (c == ',' || c == ' ') {
      if (!current_word.empty()) {
        words.push_back(current_word);
        current_word = """";
      }
    } else {
      current_word += c;
    }
  }
  if (!current_word.empty()) {
    words.push_back(current_word);
  }
  return words;
}","}
int main() {
    auto candidate = words_string;
    assert(candidate((""Hi, my name is John"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name"", (std::string)""is"", (std::string)""John""})));
    assert(candidate((""One, two, three, four, five, six"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate((""Hi, my name"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name""})));
    assert(candidate((""One,, two, three, four, five, six,"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""ahmed     , gamal"")) == (std::vector<std::string>({(std::string)""ahmed"", (std::string)""gamal""})));
}
"
HumanEval/102,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⴽⴽⴰ ⵜⵎⵔⵙⵜ ⴰⴷ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵉⴳⴳⵓⴷⵉⵏ x ⴷ y ⴰⵔ ⵜⵙⵙⴽⵛⵎ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵇⵇⵔⴰⵏ ⴳ ⵓⵙⵏⵙⵍ [x, y] ⴳ ⵓⵎⵎⴰⵙ. ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⵓⵟⵟⵓⵏ ⴰⴷ, ⵇⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵜⵎⵔⵙⵜ -1. ⵙ ⵓⵎⴷⵢⴰ: >>> choose_num((12), (15)) (14) >>> choose_num((13), (12)) (-1)
long choose_num(long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>
long choose_num(long x, long y) {
  if (x > y) {
    return -1;
  }
  long end = y;
  if (end % 2 != 0) {
    end--;
  }
  if (end < x) {
    return -1;
  }
  return end;
}","}
int main() {
    auto candidate = choose_num;
    assert(candidate((12), (15)) == (14));
    assert(candidate((13), (12)) == (-1));
    assert(candidate((33), (12354)) == (12354));
    assert(candidate((5234), (5233)) == (-1));
    assert(candidate((6), (29)) == (28));
    assert(candidate((27), (10)) == (-1));
    assert(candidate((7), (7)) == (-1));
    assert(candidate((546), (546)) == (546));
}
"
HumanEval/103,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵉⴷⵏ n ⴷ m, ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵉⵟⵏ ⴰⵎⵎⴰⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙⴳ n ⴰⵔ m (ⵙⴳ ⵏⵏ ⴷ ⵎ). ⵙⵙⵓⴷⵓⵏ ⵜⴰⵔⴰⵔⵓⵜ ⵖⵔ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⴽⴽⵡ ⵢⵓⴳⴳⵔⵏ ⴷ ⵜⵙⵏⴼⵍ ⵖⵔ ⴱⵉⵏⴰⵔⵉ. ⵎⴽ ⵉⴳⴰ n ⴰⵅⴰⵜⴰⵔ ⵙⴳ m, ⵙⵙⵓⴷⵓⵏ -1. ⴰⵎⴷⵢⴰ: >>> rounded_avg((1), (5)) ""0b11"" >>> rounded_avg(7), (5)) -1 >>> rounded_avg(10), (20)) ""0b1111"" >>> rounded_avg(20), (33) ""0b11010""
Union_std_string_long rounded_avg(long n, long m) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;
    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_string_long rounded_avg(long n, long m) {
  if (n > m) {
    return Union_std_string_long(-1);
  }
  double sum = 0;
  for (long i = n; i <= m; ++i) {
    sum += i;
  }
  double avg = sum / (m - n + 1);
  long rounded_avg_long = std::round(avg);
  if (rounded_avg_long == 0) {
    return Union_std_string_long(""0b0"");
  }
  std::string binary_string = """";
  long temp = std::abs(rounded_avg_long);
  while (temp > 0) {
    binary_string = (temp % 2 == 0 ? ""0"" : ""1"") + binary_string;
    temp /= 2;
  }
  return Union_std_string_long(""0b"" + binary_string);
}","}
int main() {
    auto candidate = rounded_avg;
    assert(candidate((1), (5)) == ""0b11"");
    assert(candidate((7), (13)) == ""0b1010"");
    assert(candidate((964), (977)) == ""0b1111001010"");
    assert(candidate((996), (997)) == ""0b1111100100"");
    assert(candidate((560), (851)) == ""0b1011000010"");
    assert(candidate((185), (546)) == ""0b101101110"");
    assert(candidate((362), (496)) == ""0b110101101"");
    assert(candidate((350), (902)) == ""0b1001110010"");
    assert(candidate((197), (233)) == ""0b11010111"");
    assert(candidate((7), (5)) == -1);
    assert(candidate((5), (1)) == -1);
    assert(candidate((5), (5)) == ""0b101"");
}
"
HumanEval/104,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵏⴰⵏⵏ x. ⴷⴰ ⵉⵜⵜⴰⵊⵊⴰ ⴰⴷ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴰⴽⴽⵡ ⵓⵔ ⵉⵍⵉⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵎⵔⴽⵙⵏ. ⵜⴰⵏⵏⴰⵢⵜ: ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵢⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⵢⵓⴳⴳⴰⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> unique_digits((std::vector<long>({(long) 15, (long) 33, (long) 1422, (long) 1}))) (std::vector<long>{(long) 1, (long) 15, (long) 33})) >>> unique_digits(std::vector<long>{(long) 152, (long) 323, (long) 1422, (long) 10}))) (std::vector<long>(long))
std::vector<long> unique_digits(std::vector<long> x) {
","#include<assert.h>
#include<bits/stdc++.h>
bool has_even_digit(long n) {
  std::string s = std::to_string(n);
  for (char c : s) {
    if ((c - '0') % 2 == 0) {
      return true;
    }
  }
  return false;
}

std::vector<long> unique_digits(std::vector<long> x) {
  std::vector<long> result;
  for (long val : x) {
    if (!has_even_digit(val)) {
      result.push_back(val);
    }
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = unique_digits;
    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));
    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));
    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));
}
"
HumanEval/105,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⴷⴰⴱⴰⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳⵔ 1 ⴷ 9 ⴳ ⵜⴰⵎⵎⵏⵜⵉⵍⵜ, ⵙⵙⵓⴷⵙ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳⵔ 1 ⴷ 9 ⴳ ⵜⴰⵎⵎⵏⵜⵉⵍⵜ, ⴷ ⵙⵙⴼⵍⴷ ⴰⵎⴹⴰⵏ ⴰⵎⴷⵢⴰ, ⴷ ⵙⵙⴼⵍⴷ ⴽⵓ ⵓⴽⵕⴰⴹ ⵙ ⵢⵉⵙⵎ ⵏⵏⵙ ⵙⴳ ""ⵢⵉⵡⵏ"", "" ⵙⵉⵏ"", "" ⴽⵕⴰⴹ"", "" ⴽⴽⵓⵥ"", "" ⵙⵎⵎⵓⵙ"", "" ⵚⴹⵉⵚ"", "" ⵙⴰ"", "" ⵜⴰⵎ"", "" ⵜⵥⴰ"". ⵙ ⵓⵎⴷⵢⴰ: >>> by_length(((std::string: vector<<(long>{{long}2, (long) 1, (long) 1, (long) 4, (long) 5, (long) 8, (long) 2, (long) 3}))) (std::string: vector<(string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string: string
std::vector<std::string> by_length(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> by_length(std::vector<long> arr) {
  std::vector<long> valid_numbers;
  std::vector<std::string> result;
  std::map<long, std::string> number_names = {
      {1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""}, {5, ""Five""},
      {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}};
  for (long num : arr) {
    if (num >= 1 && num <= 9) {
      valid_numbers.push_back(num);
    }
  }
  std::sort(valid_numbers.begin(), valid_numbers.end());
  std::reverse(valid_numbers.begin(), valid_numbers.end());
  for (long num : valid_numbers) {
    result.push_back(number_names[num]);
  }
  return result;
}","}
int main() {
    auto candidate = by_length;
    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)""Eight"", (std::string)""Five"", (std::string)""Four"", (std::string)""Three"", (std::string)""Two"", (std::string)""Two"", (std::string)""One"", (std::string)""One""})));
    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)""One""})));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)""Three"", (std::string)""Two"", (std::string)""One""})));
    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)""Nine"", (std::string)""Eight"", (std::string)""Four""})));
}
"
HumanEval/106,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⵎⵔⵙ ⵜⴰⵡⵓⵔⵉ f ⵏⵏⴰ ⵢⵓⵎⵥⵏ n ⴰⵎⵎ ⵓⵎⵙⴽⴰⵔ, ⴰⵔ ⵢⴰⴽⴽⴰ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ n, ⵣⵓⵏⴷ ⴰⵜⵉⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵙⵖⵍ ⵏ i ⵉⴳⴰ ⵜⴰⴳⴳⴰⵢⵜ ⵏ i ⵎⴽ ⵉⴳⴰ i ⴰⵎⵎ ⵓⵎⵢⴰⵖ ⵏⵖⴷ ⴰⵎⵔⵔⵓⴽ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ 1 ⴰⵔ i ⵎⴽ ⵓⵔ ⵉⴳⵉ. i ⴷⴰ ⵉⵜⵜⴱⴷⵓ ⵙⴳ 1. ⵜⴰⴳⴳⴰⵢⵜ ⵏ i ⵜⴳⴰ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ 1 ⴰⵔ i (1 * 2 * ... * i). ⴰⵎⴷⵢⴰ: >>> f((5)) (std::vector<long>{(long)1, (long)2, (long)6, (long)24, (long)15}))
std::vector<long> f(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> f(long n) {
  std::vector<long> result;
  for (long i = 1; i <= n; ++i) {
    if (i % 2 == 0) {
      long factorial = 1;
      for (long j = 1; j <= i; ++j) {
        factorial *= j;
      }
      result.push_back(factorial);
    } else {
      long sum = 0;
      for (long j = 1; j <= i; ++j) {
        sum += j;
      }
      result.push_back(sum);
    }
  }
  return result;
}","}
int main() {
    auto candidate = f;
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));
}
"
HumanEval/107,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⵏⵉⵜ ⵉⵍⵍⴰ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ n, ⵙⵙⴽⵛⵎ ⵜⴰⴱⵍⵜ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵓⵙⵏⵙⵍ ((1, n), ⵙ ⵓⴽⵛⵛⵓⵎ. ⴰⵎⴷⵢⴰ 1: >>> even_odd_palindrome (((3)) (std::make_tuple ((1, 2)) ⴰⵙⴼⵔⵓ: ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳⴰⵏ 1, 2, 3. ⵢⴰⵏ ⴳⵉⵙⵏ ⵉⴳⴰ ⴰⵎⴷⴷⴰⴷ, ⴷ ⵙⵉⵏ ⴳⵉⵙⵏ ⴳⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⴰⵎⴷⵢⴰ 2: >>> even_odd_palindrome (((12)) (std::make_tuple ((4, 6)) ⴰⵙⴼⵔⵓ: ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳⴰⵏ 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. ⴽⴽⵓⵥ ⴳⵉⵙⵏ ⴳⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ 6 ⴳⵉⵙⵏ ⴳⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵜⴰⵏⵏⴰⵢⵜ: 1 <= n= 10^3 2.
std::tuple<long, long> even_odd_palindrome(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_palindrome(long num) {
  std::string s = std::to_string(num);
  std::string reversed_s = s;
  std::reverse(reversed_s.begin(), reversed_s.end());
  return s == reversed_s;
}

std::tuple<long, long> even_odd_palindrome(long n) {
  long even_count = 0;
  long odd_count = 0;
  for (long i = 1; i <= n; ++i) {
    if (is_palindrome(i)) {
      if (i % 2 == 0) {
        even_count++;
      } else {
        odd_count++;
      }
    }
  }
  return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_palindrome;
    assert(candidate((123)) == (std::make_tuple(8, 13)));
    assert(candidate((12)) == (std::make_tuple(4, 6)));
    assert(candidate((3)) == (std::make_tuple(1, 2)));
    assert(candidate((63)) == (std::make_tuple(6, 8)));
    assert(candidate((25)) == (std::make_tuple(5, 6)));
    assert(candidate((19)) == (std::make_tuple(4, 6)));
    assert(candidate((9)) == (std::make_tuple(4, 5)));
    assert(candidate((1)) == (std::make_tuple(0, 1)));
}
"
HumanEval/108,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⵔⴰⵎ ⵜⴰⵡⵓⵔⵉ count_nums ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⴷⴰ ⵢⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⵔⵎⵉⵜ ⵏ ⵡⵓⵟⵟⵓⵏ > 0. ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵔⵓⵔ, ⵔⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵎⵔⵓⵔ: ⵙ ⵓⵎⴷⵢⴰ -123 ⵖⵓⵔⵙ ⵡⵓⵟⵟⵓⵏⵏ -1,2, ⴷ 3. >>> count_nums{((std::vector<long>())) (0) >>> count_nums{(std::vector<long>{(long) -1, (long) -11, (long) -11}))) (1) >>> count_nums::(std::vector<long>{(long) 1, (long) 1, (long) 2} (3))))
long count_nums(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_digits_signed(long n) {
  std::string s = std::to_string(n);
  long sum = 0;
  for (long i = 0; i < s.length(); ++i) {
    if (i == 0 && s[i] == '-') {
      if (s.length() > 1) {
        sum -= (s[i + 1] - '0');
        i++;
      }
    } else {
      sum += (s[i] - '0');
    }
  }
  return sum;
}

long count_nums(std::vector<long> arr) {
  long count = 0;
  for (long num : arr) {
    if (sum_digits_signed(num) > 0) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_nums;
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));
    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));
    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
}
"
HumanEval/109,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⵍⵍⴰ ⴷⴰⵔⴽ ⵓⵡⵉⴽⵜⵓⵔ 'ⴰⵔⵔ' ⵏ N ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ arr[1], arr[2], ..., arr[N]. ⴷⴰ ⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ ⵉⵎⴹⴰⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵙ ⵓⵙⴽⵙⵍ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵏ ⵉⵙ ⵉⵖⵢ ⴰⴷ ⵜⵜⵓⵙⵎⵉⵍ ⵓⵡⵉⴽⵜⵓⵔ ⵙ ⵓⵙⴽⵙⵍ ⵓⵔ ⵉⴷⴷⵓⵏ ⵙ ⵜⵎⴳⴳⵉⵜ ⴰⴷ ⴷ ⵢⵓⵛⴽⴰⵏ ⵅⴼ ⵓⵡⵉⴽⵜⵓⵔ: ⵉⵖⵢ ⴰⴷ ⵜⵜⵓⵙⵎⵉⵍ ⵓⵡⵉⴽⵜⵓⵔ ⵙ ⵓⴳⴰⴼⴰ ⵙ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ. ⵢⴰⵜ ⵜⵎⴳⴳⵉⵜ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵙ ⵓⴳⴰⴼⴰ ⵙ ⵓⴳⴰⴼⴰ ⵙ ⵓⴳⴰⴼⴰ ⵙ ⵓⴳⴰⴼⴰ ⵙ ⵢⴰⵏ ⵡⴰⴷⴷⴰⴷ ⴳ ⵓⴳⴰⴼⴰ ⵙ ⵓⴳⴰⴼⴰ. ⵔⴰⴷ ⵉⵜⵜⵓⵙⵎⵉⵍ ⵓⵡⵉⴽⵜⵓⵔ ⴰⵎⴳⴳⴰⵔⵓ ⵙ ⵡⴰⴷⴷⴰⴷ ⵏ ⵓⵣⵡⵉⵔⵉ ⴳ ⵓⵡⵉⴽⵜⵓⵔ, ⵉⴳ ⵉⵍⵍⴰ ⵓⵡⵉⴽⵜⵓⵔ ⴰⴷⴷⵓⵙ ⵙ ⵜⵎⴳⴳⵉⵜ ⵏ ⵓⴳⴰⴼⴰ ⵙ ⵓⴳⴰⴼⴰ ⵙ ⵓⴳⴰⴼⴰ ⵓⵔ ⵉⴷⴷⵓⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>>plan_one_ball_{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool move_one_ball(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
bool move_one_ball(std::vector<long> arr) {
  if (arr.empty()) {
    return true;
  }
  int n = arr.size();
  std::vector<long> sorted_arr = arr;
  std::sort(sorted_arr.begin(), sorted_arr.end());
  for (int shift = 0; shift < n; ++shift) {
    std::vector<long> shifted_arr(n);
    for (int i = 0; i < n; ++i) {
      shifted_arr[i] = arr[(i - shift + n) % n];
    }
    if (shifted_arr == sorted_arr) {
      return true;
    }
  }
  return false;
}","}
int main() {
    auto candidate = move_one_ball;
    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
}
"
HumanEval/110,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵜⵎⵓⴽⵔⵉⵙⵜ ⴰⴷ, ⵔⴰⴷ ⵜⵙⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵜ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵏ ⵡⵓⵟⵟⵓⵏ, ⴷ ⴰⵔ ⵉⵜⵜⵉⵔⵉ ⵉⵙ ⵉⵖⵉⵢ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵉⴼⵔⴷⵉⵙⵏ ⴳⵔⵙⵏ ⴰⴼⴰⴷ ⴰⴷ ⵉⴳ lst1 ⴰⵎⵓⵙⵙⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵓⵔ ⵉⵍⵍⵉ ⵓⵜⵜⵓ ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵙⵏⴼⵍⵏ ⴳⵔ lst1 ⴷ lst2. ⵉⵖ ⵉⵖ ⵉⵖⵉⵢ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵉⴼⵔⴷⵉⵙⵏ ⴳⵔ lst1 ⴷ lst2 ⴰⴼⴰⴷ ⴰⴷ ⴳⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ lst1 ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵙⵙⴽⵔ ""YES"". ⵎⵉ ⵓⵔ ⵉⴳⵉ, ⵙⵙⴽⵔ ""NO"". ⵙ ⵓⵎⴷⵢⴰ: >>> exchange((std::vector<>({long) 1, (long) 2, (long) 3, (long) 4}), (std::vector<>(long) 1, (long) 2, (long) 3, (long) 4} (yes) >>>(std::exchange<d vector>{(long>{long} (long) 1, (long) 2, (long) 3, (long) 4)) ⴷⴰ ⵉⵜⵜⵓⵙⴽⵔ ⴰⴷ ⵓⵔ ⵉⴳ ⵓⵙⴽⵛⵏ ⵏ ⵓⵎⵓⵙⵙⵏ ⵏ ⵓⵎⵓⵙⵙⵏⵏⵏⵏⵉⵜ (""ty long"")
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
  long odd_count_lst1 = 0;
  for (long num : lst1) {
    if (num % 2 != 0) {
      odd_count_lst1++;
    }
  }
  long even_count_lst2 = 0;
  for (long num : lst2) {
    if (num % 2 == 0) {
      even_count_lst2++;
    }
  }
  if (even_count_lst2 >= odd_count_lst1) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = exchange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (""YES""));
}
"
HumanEval/111,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰ ⴼⴰⵍ ⵉⵋⵋⴰ ⵙⵜⵔⵉⵏⴶ ⵉⴾⵏⴰⵏ ⴰⵍⴾⵉⵜⵜⴰⴱⴰⵏ ⵓⵉ ⵎⴰⴷⵔⵓⵉⵏⵢⵏ ⵙ ⵉⵋⵉ ⵏ ⵉⵙⵉⵎ, ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⵢⵔⵢⵎ ⵏ ⴰⵍⴾⵉⵜⵜⴰⴱ ⵓⴰ ⵉⵍⴰⵏ ⵜⵉⴾⴰⵔⵙⴰⵉ ⵜⵓⵍⴰⵙ ⵉⵍⴰ ⵉⴷⴷⵉⴾⵓⴷ ⵏⵢⵜ. ⴰ ⴼⴰⵍ ⵉⵍⴰⵏ ⴰⵍⴾⵉⵜⵜⴰⴱⴰⵏ ⴰⵋⵋⵓⵜⵏⵢⵏ ⵉⵍⴰⵏⵢⵏ ⵉⵋⵉ ⵏ ⵉⵉⵉⴰⵏ ⴼⵓⴾ, ⴰⴷ ⵢⵔⵢⵎ ⵏⴰⵙⴰⵏ ⴼⵓⴾ. ⴰⵍⵎⵉⵜⴰⵍ: >>> ⵂⵉⵙⵜⵓⴶⵔⴰⵎ:{""a"", 1}, {""b"", 1}, {""c"", 1}}) >>> ⵂⵉⵙⵜⵓⴶⵔⴰⵎ:{""a b a"")) (std::map:{""a b c a b"") >>> ⵂⵉⵙⵜⵓⴶⵔⴰⵎ:{""a b b b b b"") (std:{""a b b b b"", 2}, {""b"", 2}} >>> ⵂⵉⵙⵜⵓⴶⵔⴰⵎ:{""a b b b b b b b""} >>> ⵂⵉⵙⵜⵓⴶⵔⴰⵎ:{""a b b b b b""} (ⴰ"", 2}, {""b b b b b b b b "")) >>> ⵂⵉⵙⵜⵓⴶⵔⴰⵎⴱ:{"" b b b ""} >>> ⵂⵉⵙⵜⵓⴶⵔⴰⵎⴱ:{"" b b b b)
std::map<std::string,long> histogram(std::string test) {
","#include<assert.h>
#include<bits/stdc++.h>
std::map<std::string,long> histogram(std::string test) {
  std::map<std::string, long> counts;
  std::string current_word;
  std::stringstream ss(test);
  while (ss >> current_word) {
    counts[current_word]++;
  }
  if (counts.empty()) {
    return {};
  }
  long max_count = 0;
  for (const auto& pair : counts) {
    if (pair.second > max_count) {
      max_count = pair.second;
    }
  }
  std::map<std::string, long> result;
  for (const auto& pair : counts) {
    if (pair.second == max_count) {
      result[pair.first] = pair.second;
    }
  }
  return result;
}","}
int main() {
    auto candidate = histogram;
    assert(candidate((""a b b a"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c a b"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c d g"")) == (std::map<std::string,long>({{""a"", 1}, {""b"", 1}, {""c"", 1}, {""d"", 1}, {""g"", 1}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate((""b b b b a"")) == (std::map<std::string,long>({{""b"", 4}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate(("""")) == (std::map<std::string,long>()));
    assert(candidate((""a"")) == (std::map<std::string,long>({{""a"", 1}})));
}
"
HumanEval/112,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵣⴰⵔⵜ ⵏⵜⵜⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵏⴰⵜ ⵜⵉⴼⵔⵉⵙⵉⵏ s ⴷ c, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⴽⵓⵍⵍⵓ ⵜⵉⴼⵔⵉⵙⵉⵏ ⴳ s ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷ ⴽⵓ ⵜⵉⴼⵔⵉⵙⵜ ⴳ c ⴷ ⴰⴷ ⵜⵥⵕ ⵉⵙ ⵜⴳⴰ ⵜⵉⴼⵔⵉⵙⵜ ⵏ ⵜⵢⴰⴼⵓⵜ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ. ⴷⴰ ⵜⵜⵉⵏⵉⵏ ⵜⵉⴼⵔⵉⵙⵜ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ ⵉⵖ ⵜⴳⴰ ⵜⵉⴼⵔⵉⵙⵜ ⵏ ⵜⵢⴰⴼⵓⵜ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵜⵉⴼⵔⵉⵙⵜ ⵏ ⵜⵢⴰⴼⵓⵜ ⴷ ⵜⵉⴷⵜ/ ⵜⵉⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ ⵉ ⵓⵣⵣⵔⴰⵢ. ⴰⵎⴷⵢⴰ >>> reverse_delete{""abcde""), (""ae"")) (std::make_tuple{""bcd"", false)) >>> reverse_delete{""abcdef"", (""b"") (std::make_tuple{""acdef"", false)) >>> reverse_delete{""abcdef"", false"") >>> reverse_delete{""abcdef"", false"")
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
","#include<assert.h>
#include<bits/stdc++.h>
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
  std::string result = """";
  std::unordered_set<char> chars_to_delete(c.begin(), c.end());
  for (char ch : s) {
    if (chars_to_delete.find(ch) == chars_to_delete.end()) {
      result += ch;
    }
  }
  std::string reversed_result = result;
  std::reverse(reversed_result.begin(), reversed_result.end());
  return std::make_tuple(result, result == reversed_result);
}","}
int main() {
    auto candidate = reverse_delete;
    assert(candidate((""abcde""), (""ae"")) == (std::make_tuple(""bcd"", false)));
    assert(candidate((""abcdef""), (""b"")) == (std::make_tuple(""acdef"", false)));
    assert(candidate((""abcdedcba""), (""ab"")) == (std::make_tuple(""cdedc"", true)));
    assert(candidate((""dwik""), (""w"")) == (std::make_tuple(""dik"", false)));
    assert(candidate((""a""), (""a"")) == (std::make_tuple("""", true)));
    assert(candidate((""abcdedcba""), ("""")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""abcdedcba""), (""v"")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""vabba""), (""v"")) == (std::make_tuple(""abba"", true)));
    assert(candidate((""mamma""), (""mia"")) == (std::make_tuple("""", true)));
}
"
HumanEval/113,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⵛⵛⵉⵍ ⵏ ⵉⵙⵓⴳⴳⴰⵙⵏ, ⴳ ⴽⵓ ⴰⵙⵓⴳⴳⴰⵙ ⵓⵔ ⵉⴳⵉ ⵖⴰⵙ ⵏ ⵡⵓⵟⵟⵓⵏ, ⴷⴰ ⵉⵜⵜⴰⴷⴼ ⵢⴰⵏ ⵓⵙⵓⴳⴳⴰⵙ. ⴽⵓ ⵉⴼⵔⴷⵉⵙ i ⵏ ⵓⵙⵓⴼⵖ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⴳ ""ⵉⴹ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵙⵓⴳⴳⴰⵙ i ⵏ ⵓⵙⵓⴳⴳⴰⵙ. "" ⴳ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴽⵓⵍⵍⵓ i ⵙ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵙⵓⴳⴳⴰⵙ ⵡⵉⵙⵙ i ⵏ ⵓⵙⵓⴳⴳⴰⵙ. >>> odd_count((std::vector<std::string>(({std::string) ""1234567""}))) (std::vector<std::string>({std::string) ""ⵉⴹ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ 4n ⴰⵙⵓⴳⴳⴰⵙ 4 ⵏ ⵓⵙⵓⴳⴳⴰⵙ 4n. "")) >>> odd_count(std:{std:vector<std::string>{std::string>:{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> odd_count(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> odd_count(std::vector<std::string> lst) {
  std::vector<std::string> result;
  for (const std::string& s : lst) {
    int count = 0;
    for (char c : s) {
      if ((c - '0') % 2 != 0) {
        count++;
      }
    }
    std::string count_str = std::to_string(count);
    std::string modified_s = s;
    for (char& c : modified_s) {
      if (isdigit(c) && (c - '0') % 2 != 0) {
        c = count_str[0];
      }
    }
    result.push_back(""the number of odd elements "" + count_str + ""n the str"" + modified_s + ""ng "" + modified_s + "" of the "" + modified_s + ""nput."");
  }
  return result;
}","}
int main() {
    auto candidate = odd_count;
    assert(candidate((std::vector<std::string>({(std::string)""1234567""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 4n the str4ng 4 of the 4nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""3"", (std::string)""11111111""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (std::string)""the number of odd elements 8n the str8ng 8 of the 8nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""271"", (std::string)""137"", (std::string)""314""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 2n the str2ng 2 of the 2nput."", (std::string)""the number of odd elements 3n the str3ng 3 of the 3nput."", (std::string)""the number of odd elements 2n the str2ng 2 of the 2nput.""})));
}
"
HumanEval/114,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ ⴷⴰ ⵉⵜⵜⴰⴼ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⴽⵓ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵅⵡⴰⵏ. ⴰⵎⴷⵢⴰ >>> minSubArraySum((((std::vector<long>({long) 2, (long) 3, (long) 4, (long) 1, (long) 2, (long) 4}))) (1) >>> minSubArraySum((std::vector<long>{(long) -1, (long) -2, (long) -3)))) (-6)
long minSubArraySum(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>
long minSubArraySum(std::vector<long> nums) {
  if (nums.empty()) {
    throw std::invalid_argument(""Input vector cannot be empty."");
  }
  long min_so_far = nums[0];
  long current_min = nums[0];
  for (size_t i = 1; i < nums.size(); ++i) {
    current_min = std::min(nums[i], current_min + nums[i]);
    min_so_far = std::min(min_so_far, current_min);
  }
  return min_so_far;
}","}
int main() {
    auto candidate = minSubArraySum;
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));
    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));
    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));
    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));
    assert(candidate((std::vector<long>({(long)-10}))) == (-10));
    assert(candidate((std::vector<long>({(long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));
}
"
HumanEval/115,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⴾⴰⵉⴰⴷ ⵏ ⴾⴰⵔⵜⵉ ⵜⴰⵏ ⵓⵉⵏ ⵜⴰⵂⵔⵉⴾⴻ ⵜⴰⵈⵈⴰⵍⴰⵜ ⴾⴰⵔⵜⵉ ⵉⵉⵉⴰⵜ ⵏ ⴰⵎⴰⵏ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⵉⴰⵜ ⵉⵉⵉⵉⴰⵜ ⵉⵉⵉⵉⴰⵜ ⵉⵉⵉⵉⴰⵜ ⵉⵉⵉⵉⴰⵜ ⵉⵉⵉⵉⴰⵜ ⵉⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ ⵉⵉⴰⵜ
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
","#include<assert.h>
#include<bits/stdc++.h>
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
  long bucket_lowering_count = 0;
  for (const auto& row : grid) {
    long water_in_well = 0;
    for (long unit : row) {
      water_in_well += unit;
    }
    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;
  }
  return bucket_lowering_count;
}","}
int main() {
    auto candidate = max_fill;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));
}
"
HumanEval/116,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⴽⴰⵜⴰ ⴰⴷ, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵔⵉⵏⵉⵏ ⵙ ⵓⵟⵟⵓⵏ ⵏ ⵡⵉⵏⵏⴰ ⴳ ⵓⵙⵎⴷⵢⴰ ⵏⵏⵙⵏ ⴰⵎⵉⵏⵉ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵇⵔⴰⵏ. ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵉⵏⵏⴰ ⵉⵎⵎⵔⵡⴰⵙⵏ, ⵙⵙⵓⴷⵙⴷ ⵅⴼ ⵡⴰⵜⵉⴳ ⴰⵎⵔⴰⵡ. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵉⵜⵜⵓⵙⵎⵔⵙ ⵣⵓⵏⴷ ⴰⴷ: >>> sort_array(((std::vector<long>{(long) 1, (long) 5, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5})) >>> sort_array((std::vector<long>{(long>{(long}-2, (long) 3, (long) 4, (long) 5, (long) 6}))) (std::vector<(long>{(long>-6, (long) 5, (long) 4, (long) 3, (long) 2} >>>array_std::vector<(long>{(long>1, (long) 3, (long)) (long) 4, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long))
std::vector<long> sort_array(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
int count_set_bits(long n) {
  int count = 0;
  if (n < 0) {
    n = std::abs(n);
  }
  while (n > 0) {
    n &= (n - 1);
    count++;
  }
  return count;
}

bool compare(long a, long b) {
  int bits_a = count_set_bits(a);
  int bits_b = count_set_bits(b);
  if (bits_a != bits_b) {
    return bits_a < bits_b;
  }
  return a < b;
}

std::vector<long> sort_array(std::vector<long> arr) {
  std::sort(arr.begin(), arr.end(), compare);
  return arr;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));
    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
}
"
HumanEval/117,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵎⴽ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴼⵉⵏⴰⵖ s ⴷ ⵡⵓⵟⵟⵓⵏ ⴰⴳⴰⵎⴰⵏ n, ⵉⵜⵜⵓⵙⴽⴰⵔ ⵓⴱⵔⵉⴷ ⵏ ⵓⵙⵎⵔⵙ ⵏ ⵢⴰⵜ ⵜⵎⵔⵙⵜ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵢⴰⵖ ⵢⴰⵏ ⵓⴱⵔⵉⴷ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴽⴽⵡ ⵙⴳ ⵜⵉⴼⵉⵏⴰⵖ s ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⴽⵔⴰ ⵏ ⵉⵎⵏⵉⵍⵏ, ⴰⴼⴰⴷ ⴰⴷ ⵜⵜⵉⵍⵉⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴷ ⴳ ⵜⵉⴼⵉⵏⴰⵖ s. ⵎⴽ ⴷⴰ ⵜⵜⵉⵍⵉ ⵜⵉⴼⵉⵏⴰⵖ s, ⵀⴰⵜ ⵜⵎⵔⵙⵜ ⴰⴷ ⵜⵔⴰⵔ ⵢⴰⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ ⵓⵔ ⵉⵍⵉⵏ ⴽⵔⴰ. ⵜⴰⵏⵏⴰⵢⵜ: ⵉⵖⵢ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉ ⵉⵙ ⵜⵍⵍⴰ ⵜⵉⴼⵉⵏⴰⵖ ⵏ ⵓⴽⵛⵛⵓⵎ ⵖⴰⵙ ⵜⵉⴼⵉⵏⴰⵖ ⴷ ⵉⵎⵏⵉⵍⵏ. ⵉⵎⴷⵢⴰⵜⵏ: >>> select_words{""ⵙⴰⵔⵉⵎⴰ ⵉⵍⴰ ⵜⴰⵔⴱⴱⵓⵜ""), (4)) (std::vector<std::std::std::std::d::d::d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d
std::vector<std::string> select_words(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_consonant(char c) {
  c = tolower(c);
  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');
}

std::vector<std::string> select_words(std::string s, long n) {
  std::vector<std::string> result;
  std::string current_word;
  for (char c : s) {
    if (c == ' ') {
      long consonant_count = 0;
      for (char word_char : current_word) {
        if (is_consonant(word_char)) {
          consonant_count++;
        }
      }
      if (consonant_count == n) {
        result.push_back(current_word);
      }
      current_word = """";
    } else {
      current_word += c;
    }
  }
  long consonant_count = 0;
  for (char word_char : current_word) {
    if (is_consonant(word_char)) {
      consonant_count++;
    }
  }
  if (consonant_count == n) {
    result.push_back(current_word);
  }
  return result;
}","}
int main() {
    auto candidate = select_words;
    assert(candidate((""Mary had a little lamb""), (4)) == (std::vector<std::string>({(std::string)""little""})));
    assert(candidate((""Mary had a little lamb""), (3)) == (std::vector<std::string>({(std::string)""Mary"", (std::string)""lamb""})));
    assert(candidate((""simple white space""), (2)) == (std::vector<std::string>()));
    assert(candidate((""Hello world""), (4)) == (std::vector<std::string>({(std::string)""world""})));
    assert(candidate((""Uncle sam""), (3)) == (std::vector<std::string>({(std::string)""Uncle""})));
    assert(candidate((""""), (4)) == (std::vector<std::string>()));
    assert(candidate((""a b c d e f""), (1)) == (std::vector<std::string>({(std::string)""b"", (std::string)""c"", (std::string)""d"", (std::string)""f""})));
}
"
HumanEval/118,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔ ⵜⴰⴳⵓⵔⵉ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴰⴼⴷ ⵓⵖⵔⵉ ⴰⵎⴷⴷⴰⴷ ⴳⵔ ⵙⵉⵏ ⵉⵎⵏⵉⵍⵏ ⵙⴳ ⵜⵙⴳⴰ ⵏ ⵡⴰⴷⴷⵓⵔ ⵏ ⵜⴳⵓⵔⵉ (ⴰⵙⵙⵓⵃⵢⵓ ⵏ ⵡⴰⴷⴷⴰⴷ ⴰⵎⴷⴷⴰⴷ). ⵓⵔ ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⵎⵏⵉⵍⵏ ⴳ ⵜⵉⵣⵡⵉⵔⵉ ⴷ ⵜⴳⵉⵔⴰ. ⵔⵉⵏⵜⵔ ⴱⵓⵍⵉⵙ ⵙⵜⵔⵉⵏⴳ ⵎⴽ ⵓⵔ ⵜⵢⴰⴼⴰ ⴽⵔⴰ ⵏ ⵓⵎⵏⵉⵍ ⵉⵇⵇⵏ ⴰⴽⴷ ⵡⴰⴷⴷⴰⴷ ⵏ ⴰⴼⵍⵍⴰ. ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉ ⵉⵙ ⴳ ⵓⵖⵔⵉ ⴰⴷ ⵉⵍⵍⴰ ⵜⵉⵔⵔⴰ ⵏ ⵜⵓⵜⵍⴰⵢⵜ ⵜⴰⵏⴳⵍⵉⵣⵜ ⵖⴰⵙ. ⴰⵎⴷⵢⴰ: >>> get_closest_vowel (((""yogurt"")) (""u"") >>> get_closest_vowel (((""FULL"")) (""U"") >>> get_closest_vowel (((""quick"")) ("""") >>> get_closest_vowel ((((ab"") ("""")
std::string get_closest_vowel(std::string word) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_vowel(char c) {
  c = tolower(c);
  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');
}

bool is_consonant(char c) {
  return isalpha(c) && !is_vowel(c);
}

std::string get_closest_vowel(std::string word) {
  if (word.length() < 3) {
    return """";
  }
  for (int i = word.length() - 2; i >= 1; --i) {
    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {
      return std::string(1, word[i]);
    }
  }
  return """";
}","}
int main() {
    auto candidate = get_closest_vowel;
    assert(candidate((""yogurt"")) == (""u""));
    assert(candidate((""full"")) == (""u""));
    assert(candidate((""easy"")) == (""""));
    assert(candidate((""eAsy"")) == (""""));
    assert(candidate((""ali"")) == (""""));
    assert(candidate((""bad"")) == (""a""));
    assert(candidate((""most"")) == (""o""));
    assert(candidate((""ab"")) == (""""));
    assert(candidate((""ba"")) == (""""));
    assert(candidate((""quick"")) == (""""));
    assert(candidate((""anime"")) == (""i""));
    assert(candidate((""Asia"")) == (""""));
    assert(candidate((""Above"")) == (""o""));
}
"
HumanEval/119,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔ ⵉⴽⵜ ⵏ ⵙⵉⵏ ⵉⵙⵉⵍⵉⵡⵏ, ⵙⵉⵏ ⵉⵙⵉⵍⵉⵡⵏ ⴳⴰⵏ ⵉⴽⵜ ⵏ ⵓⴱⵕⴰⵏⴽⵉⵙⵏ ⵉⵕⵥⵎⵏ '(' ⵏⵖⴷ ⵉⴽⵜ ⵏ ⵓⴱⵕⴰⵏⴽⵉⵙⵏ ⵉⵇⵇⵏⵏ ') '. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵥⵕ ⵉⵙ ⵉⵖⵢ ⴰⴷ ⵜⵜⵓⵙⵎⵓⵏ ⵙⵉⵏ ⵉⵙⵉⵍⵉⵡⵏ ⵙ ⴽⵔⴰ ⵏ ⵓⴽⵓⴷ, ⵎⴰⵙ ⴷ ⵉⵙⵉⵍⵉ ⵉⵜⵜⵓⵙⵢⴰⴼⴰⵏ ⴰⴷ ⵉⴳ ⵉⵖⵓⴷⴰⵏ. ⵉⵙⵉⵍⵉ S ⴷⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⴳ ⵉⵙⵉⵍⵉ ⵉⵖⵓⴷⴰⵏ ⵉⴳ ⴽⵓⵍⵍⵓ ⵉⴽⵜ ⵏ ⵓⴱⵕⴰⵏⴽⵉⵙⵏ ⴳ S ⴳⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ. ⵙ ⵓⵎⴷⵢⴰ: ⵉⵙⵉⵍⵉ '((()) ' ⵉⵖⵓⴷⴰⵏ, ⵎⴰⵛ ⵉⵙⵉⵍⵉ '(()) ' ⵓⵔ ⵉⵖⵓⴷⴰⵏ. ⴰⵔ ⵜⵙⵙⴽⵛⵎ 'ⵉⵀⴰ' ⵉⴳ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⵙⴽⴰⵔ ⵏ ⵉⵙⵉⵍⵉ ⵉⵖⵓⴷⴰⵏ, ⴷ ⴰⵔ ⵜⵙⵙⴽⵛⵎ 'ⵓⵀⴰ' ⴳ ⵡⴰⴷⴷⴰⵢ ⵢⴰⴹⵏ. ⵉⵎⴷⵢⴰⵜⵏ: >>> match_parens((std::vector<std::sting>{(((sting}:{((sting)))))) (ⴰⴽⵜ ⵏ ⵓⵙⵉⵍⵉⵡⵏ ""No"") ""
std::string match_parens(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_good(const std::string& s) {
  int balance = 0;
  for (char c : s) {
    if (c == '(') {
      balance++;
    } else if (c == ')') {
      balance--;
    }
    if (balance < 0) {
      return false;
    }
  }
  return balance == 0;
}

std::string match_parens(std::vector<std::string> lst) {
  std::string s1 = lst[0];
  std::string s2 = lst[1];
  if (is_good(s1 + s2) || is_good(s2 + s1)) {
    return ""Yes"";
  } else {
    return ""No"";
  }
}","}
int main() {
    auto candidate = match_parens;
    assert(candidate((std::vector<std::string>({(std::string)""()("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)"")""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()(())"", (std::string)""())())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")())"", (std::string)""(()()(""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(())))"", (std::string)""(()())((""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""()"", (std::string)""())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()("", (std::string)""()))()""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(((("", (std::string)""((())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")(()"", (std::string)""(()(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")("", (std::string)"")(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)""(""}))) == (""Yes""));
}
"
HumanEval/120,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵡⵉⴽⵜⵓⵔ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵓⵡⵉⴽⵜⵓⵔ k ⴰⵎⵏⴷⵉ, ⵙⵙⵓⴼⵖ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⵉⵖⵣⵉ k ⵙ ⵓⴳⴳⴰⵔ ⵏ k ⵉⵎⴹⴰⵏ ⴳ arr. ⴰⵎⴷⵢⴰ 1: >>> maximum((std::vector<long>({long) -3, (long) -4, (long) -5,)), (3)) (std::vector<long>({long) -4, (long) -3, (long) 5}) ⴰⵎⴷⵢⴰ 2: >>> maximum((std::vector<long>({long) 4, (long) -4, (long) 4}), (2)) (std::vector<long>{(long) 4, (long) 4}) ⴰⵎⴷⵢⴰ 3: >>> maximum(std::vector<<(long>{long) -3, (long) 2, (long) 1, (long) 2, (long) -1, (long) 1), (1) (std::vector<(arr>2}) 1. ⵜⵉⵖⵣⵉ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵔⴰⴷ ⵜⴳ ⴳ ⵓⵙⵏⴼⵔⴰⵔ ⵏ 1000 ⵉⴼⵔⴷⵉⵙⵏ. [=1, len-1] 3.
std::vector<long> maximum(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> maximum(std::vector<long> arr, long k) {
  std::sort(arr.rbegin(), arr.rend());
  std::vector<long> result;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    result.push_back(arr[i]);
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = maximum;
    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));
    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));
    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));
    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));
    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));
}
"
HumanEval/121,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵓⵔ ⵉⴳⵉⵏ ⵓⵎⵥⵥⵢ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵜⴰⴳⵓⵜ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵡⴰⵏⵙⴰ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵉⵎⴷⵢⴰⵜⵏ >>> solution(((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) (12) >>> solution((((std::vector<long>({(long)3, (long)3, (long)3, (long)3}))) (9) >>> solution((((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) (0)
long solution(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long solution(std::vector<long> lst) {
  long sum = 0;
  for (long i = 0; i < lst.size(); i += 2) {
    if (lst[i] % 2 != 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = solution;
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));
    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));
    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));
    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));
}
"
HumanEval/122,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵓⵔ ⵉⴳⵉⵏ ⵓⵎⵏⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ arr ⴷ ⵢⴰⵏ ⵓⴽⵜⵓⵔ k, ⵙⵙⴽⵛⵎ ⵜⴰⴳⵓⵜ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵙⵏⴰⵜ ⵜⵓⵙⴽⵉⵡⵉⵏ ⴳ ⵓⴳⴳⴰⵔ ⵙⴳ ⵉⴼⵔⴷⵉⵙⵏ ⵏ arr ⵉⵎⵣⵡⵓⵔⴰ. ⴰⵎⴷⵢⴰ: >>> add_elements((std::vector<long>({long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) ⵜⵉⵎⵣⴰⵣⴰⵍ: 1. 1 <= len(arr) <= 100 2. 1 <= k <= lenarr)
long add_elements(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
long add_elements(std::vector<long> arr, long k) {
  long sum = 0;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    if (arr[i] >= -99 && arr[i] <= 99) {
      sum += arr[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add_elements;
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));
    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));
    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));
    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));
    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));
}
"
HumanEval/123,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⵏⵉⵜ ⵉⵍⵍⴰ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴷ n, ⵙⵙⵓⴷⵙ ⴳ ⵓⴱⵔⵉⴷ ⵏ ⵓⴽⵙⴰⵢ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵙⵏⵙⵍ ⵏ ⴽⵓⵍⴰⵜⵣ. ⵜⴰⴳⵏⵉⵜ ⵏ ⴽⵓⵍⴰⵜⵣ ⵜⴳⴰ ⵜⴰⴳⵏⵉⵜ ⴳ ⵜⵓⵙⵏⴰⴽⵜ ⵏⵏⴰ ⵉⵥⵍⵉⵏ ⵙ ⵓⵙⵏⵙⵍ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ ⵓⵎⴽ ⴰⴷ: ⵙⵙⵏⵜ ⵙ ⴽⵓ ⵉⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵉⴷⵏ n. ⴷⴼⴼⵉⵔ ⵏ ⵓⵢⴰ, ⴷⴰ ⵜⵜⵓⵢⴰⵡⵙⴽⴰⵔ ⴽⵓ ⵉⵎⵉⴹ ⵙⴳ ⵉⵎⵉⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵣⵔⵉⵏⵉⵏ: ⵉⴳ ⵉⵎⵉⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉⵣⵔⵉⵏ, ⵉⵎⵉⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷ ⵉⴷⴷⴰⵏ ⴳⴰⵏ ⵓⵣⴳⵏ ⵏ ⵉⵎⵉⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉⵣⵔⵉⵏ. ⵉⴳ ⵉⵎⵉⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉⵣⵔⵉⵏ, ⵉⵎⵉⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷ ⵉⴷⴷⴰⵏ ⴳⴰⵏ 3 ⵏ ⵉⵎⵉⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉⵣⵔⵉⵏ ⵓⴳⴳⴰⵔ 1. ⵜⴰⴳⵏⵉⵜ ⵜⴳⴰ ⵎⴰⵙ ⵓⵔ ⵉⵥⵍⵉ ⵙ ⵡⴰⵜⵉⴳⵔ ⵏ n, ⴷⴰ ⵜⵍⴽⵎⴹ ⴰⵀⴰ 1.
std::vector<long> get_odd_collatz(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> get_odd_collatz(long n) {
  std::vector<long> odd_numbers;
  std::unordered_set<long> seen;
  long current = n;
  while (seen.find(current) == seen.end()) {
    seen.insert(current);
    if (current % 2 != 0) {
      odd_numbers.push_back(current);
    }
    if (current == 1) {
      break;
    }
    if (current % 2 == 0) {
      current /= 2;
    } else {
      current = 3 * current + 1;
    }
  }
  std::sort(odd_numbers.begin(), odd_numbers.end());
  return odd_numbers;
}","}
int main() {
    auto candidate = get_odd_collatz;
    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));
    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
}
"
HumanEval/124,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵏⴰⵔⵉ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⴽⵍⵏ ⵙ ⵓⵖⵉⵍ ⵏ ⵡⴰⵙⵙ ⴷ ⴷⴰⴷ ⵉⵜⵜⴰⵊⵊⴰ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⴰⵙⵙ ⴰⵣⵔⴼⴰⵏ ⵏⵖⴷ ⵉⴳ ⵓⵔ ⵉⴳⵉ ⴰⵣⵔⴼⴰⵏ. ⴷⴰⴷ ⵉⵜⵜⵓⵙⵎⴽⵍ ⵡⴰⵙⵙ ⵎⴽ ⴳⴰⵏ ⴽⵓⵍⵍⵓ ⵉⵍⵓⴳⵏⵏ ⴰⴷ: 1. ⵓⵔ ⵉⴳⵉ ⵓⵖⵉⵍ ⵏ ⵡⴰⵙⵙ ⴰⵣⵔⴼⴰⵏ ⴰⵣⵔⴼⴰⵏ. 2. ⵓⵔ ⵉⴳⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⴷⴷⵔⵓⵙ ⵏ 1 ⵏⵖⴷ ⵓⴳⴳⴰⵔ ⵏ 31 ⵏ ⵡⴰⵙⵙ ⴳ ⵡⴰⵢⵢⵓⵔⵏ 1,3,5,7,8,10,12. ⴷ ⵓⵔ ⵉⴳⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⴷⴷⵔⵓⵙ ⵏ 1 ⵏⵖⴷ ⵓⴳⴳⴰⵔ ⵏ 30 ⵏ ⵡⴰⵙⵙ ⴳ ⵡⴰⵢⵢⵓⵔⵏ 4,6,9,11. ⴷ ⵓⵔ ⵉⴳⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⴷⴷⵔⵓⵙ ⵏ 1 ⵏⵖⴷ ⵓⴳⴳⴰⵔ ⵏ 29 ⴳ ⵡⴰⵢⵢⵓⵔ 2. 3. ⵓⵔ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⴰⵢⵢⵓⵔⵏ ⴷⴷⵔⵓⵙ ⵏ 1 ⵏⵖⴷ ⵓⴳⴳⴰⵔ ⵏ 12. 4. ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⵉⵍⵉ ⵡⴰⵙⵙ ⴳ ⵜⵍⵖⴰⵡⵜ: mm-dd-dd-yyyy >>> valid_date (((((((15-01-2012"")) (ⴷⴰⴷⴷⴰⴷ ⵉⴳ ⵡⴰⵙⵙ ⴰⵣⵔⴼⴰⵏ ⵏ ⵡⴰⵙⵙ ⴰⵣⵔⴼⴰⵏ) >>> valid_date (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool valid_date(std::string date) {
","#include<assert.h>
#include<bits/stdc++.h>
bool valid_date(std::string date) {
  if (date.empty()) {
    return false;
  }
  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {
    return false;
  }
  int month, day, year;
  try {
    month = std::stoi(date.substr(0, 2));
    day = std::stoi(date.substr(3, 2));
    year = std::stoi(date.substr(6, 4));
  } catch (const std::invalid_argument& e) {
    return false;
  } catch (const std::out_of_range& e) {
    return false;
  }
  if (month < 1 || month > 12) {
    return false;
  }
  if (day < 1) {
    return false;
  }
  if (month == 2) {
    if (day > 29) {
      return false;
    }
  } else if (month == 4 || month == 6 || month == 9 || month == 11) {
    if (day > 30) {
      return false;
    }
  } else {
    if (day > 31) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = valid_date;
    assert(candidate((""03-11-2000"")) == (true));
    assert(candidate((""15-01-2012"")) == (false));
    assert(candidate((""04-0-2040"")) == (false));
    assert(candidate((""06-04-2020"")) == (true));
    assert(candidate((""01-01-2007"")) == (true));
    assert(candidate((""03-32-2011"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""04-31-3000"")) == (false));
    assert(candidate((""06-06-2005"")) == (true));
    assert(candidate((""21-31-2000"")) == (false));
    assert(candidate((""04-12-2003"")) == (true));
    assert(candidate((""04122003"")) == (false));
    assert(candidate((""20030412"")) == (false));
    assert(candidate((""2003-04"")) == (false));
    assert(candidate((""2003-04-12"")) == (false));
    assert(candidate((""04-2003"")) == (false));
}
"
HumanEval/125,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// ⵎⴽ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵡⵔⵉⴽ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ, ⵙⵙⴽⵛⵎ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵜⵜⵓⵙⴱⴹⴰⵏ ⵅⴼ ⵡⴰⵢⴷⴰ, ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⵢⴷⴰ ⴳ ⵓⴹⵕⵉⵚ, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⴱⴹ ⵅⴼ ⵡⴰⵢⴷⴰ ',' ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⵢⴷⴰ, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⴽⵛⵎ ⵓⵟⵟⵓⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵢⵉⵡⴰⵏ ⴳ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ord ((('a') = 0, ord ((('b') = 1, ... ord ((('z') = 25 ⵉⵎⴷⵢⴰⵜⵏ >>> split_words ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
Union_std_vector_std_string__long split_words(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;
    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_vector_std_string__long split_words(std::string txt) {
  if (txt.find(' ') != std::string::npos) {
    std::vector<std::string> words;
    std::stringstream ss(txt);
    std::string word;
    while (ss >> word) {
      words.push_back(word);
    }
    return Union_std_vector_std_string__long(words);
  } else if (txt.find(',') != std::string::npos) {
    std::vector<std::string> words;
    std::string current_word;
    for (char c : txt) {
      if (c == ',') {
        words.push_back(current_word);
        current_word = """";
      } else {
        current_word += c;
      }
    }
    words.push_back(current_word);
    return Union_std_vector_std_string__long(words);
  } else {
    long odd_order_count = 0;
    for (char c : txt) {
      if (islower(c)) {
        if ((c - 'a') % 2 != 0) {
          odd_order_count++;
        }
      }
    }
    return Union_std_vector_std_string__long(odd_order_count);
  }
}","}
int main() {
    auto candidate = split_words;
    assert(candidate((""Hello world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello,world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello world,!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world,!""}));
    assert(candidate((""Hello,Hello,world !"")) == std::vector<std::string>({(std::string)""Hello,Hello,world"", (std::string)""!""}));
    assert(candidate((""abcdef"")) == 3);
    assert(candidate((""aaabb"")) == 2);
    assert(candidate((""aaaBb"")) == 1);
    assert(candidate(("""")) == 0);
}
"
HumanEval/126,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔ ⵓⵎⵙⵙⵉⴹⵏ ⵏ ⵉⵎⴹⴰⵏ, ⴷⴷⵔⵖ ⵉⵙ ⵜⵜⵓⵙⵎⵙⴰⵙⴰⵏ ⵙ ⵓⵍⴽⴰⵎ. ⵉⵖ ⴷⴰⵔ ⵓⵎⵙⵙⵉⴹⵏ ⵓⴳⴳⴰⵔ ⵏ 1 ⵓⵎⴹⴰⵏ ⴰⵎⵎ ⵢⴰⵏ, ⴷⴷⵔⵖ false. ⵏⵙⵙⵏ ⵉⵙ ⵓⵔ ⵍⵍⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵔⵉⵏⵉⵏ ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵉⵎⴷⵢⴰⵜⵏ >>> is_sorted{((std::vector<long>{(long) 5}))) (true) >>> is_sorted{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool is_sorted(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_sorted(std::vector<long> lst) {
  if (lst.size() <= 1) {
    return true;
  }
  std::map<long, int> counts;
  for (long x : lst) {
    counts[x]++;
  }
  for (auto const& [key, val] : counts) {
    if (val > 2) {
      return false;
    }
  }
  for (size_t i = 0; i < lst.size() - 1; ++i) {
    if (lst[i] > lst[i + 1]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_sorted;
    assert(candidate((std::vector<long>({(long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));
}
"
HumanEval/127,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵏⴱⵔⴰⵍⵏ, ⴳ ⴽⵓ ⵉⵏⴱⵔⴰⵍ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙ ⵓⵎⴷⵢⴰ, ⵉⵏⴱⵔⴰⵍ = (ⵜⴱⴷⵓ, ⵜⴳⵉⵔⴰ) = (1, 2). ⵉⵏⴱⵔⴰⵍⵏ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ ⴳⴰⵏ ⵉⵇⵇⵏⵏ, ⵎⴰⵢⴰⴷ ⵉⴳⴰⵏ ⵉⵙ ⴳⴰⵏ ⵉⵏⴱⵔⴰⵍⵏ (ⵜⴱⴷⵓ, ⵜⴳⵉⵔⴰ) ⵜⵉⵣⵡⵉⵔⵉ ⴷ ⵜⴳⵉⵔⴰ. ⴳ ⴽⵓ ⵉⵏⴱⵔⴰⵍ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ, ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔ ⵎⴰⵙ ⵉⴳⴰ ⵓⵣⵡⵉⵔⵉ ⵏⵏⵙ ⵉⵎⵥⵥⵉⵢⵏ ⵏⵖⴷ ⴰⵎⵎ ⵜⴳⵉⵔⴰ ⵏⵏⵙ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵏⵙⵙⴽⵏ ⵎⴰⵙⴷ ⵜⵉⵖⵣⵉ ⵏ ⵓⵙⵎⴽⵍ ⵏ ⵉⵏⴱⵔⴰⵍⵏ ⴰⴷ ⵙⵉⵏ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ. ⴰⵎⴷⵢⴰ, ⴰⵙⵎⴽⵍ ⵏ ⵉⵏⴱⵔⴰⵍⵏ (1, 3), (2, 4) ⵉⴳⴰ (2, 3) ⵏⵏⴰ ⵉⴳⴰⵏ ⵜⵉⵖⵣⵉ ⵏⵏⵙ 1, ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ. ⵉⴳ ⵜⵉⵖⵣⵉ ⵏ ⵓⵙⵎⴽⵍ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⵙⵓⵍ ""ⵉⵖ"", ⵎⴽⵓ ⵓⵔ ⵉⴳⵉ, ⵙⵓⵍⵍ ""ⵍⴰ"". ⵎⴽⵓⴷ ⵓⵔ ⴷⴰ ⵜⵜⵓⵙⴽⵍⵏ ⵙⵉⵏ ⵉⵏⴱⵔⴰⵍⵏ. [input/output] ⵙ ⵓⵎⴷⵢⴰ: >>> intersection: (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
  long start1 = std::get(interval1);
  long end1 = std::get(interval1);
  long start2 = std::get(interval2);
  long end2 = std::get(interval2);
  long intersection_start = std::max(start1, start2);
  long intersection_end = std::min(end1, end2);
  long intersection_length = intersection_end - intersection_start + 1;
  if (intersection_length <= 0) {
    return ""NO"";
  }
  if (is_prime(intersection_length)) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = intersection;
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (""NO""));
    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (""NO""));
    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (""YES""));
    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (""YES""));
    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (""NO""));
    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (""NO""));
}
"
HumanEval/128,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵜⵓⵔ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔⵎ ⵜⴰⴳⵓⵜ ⵏ ⵜⵉⵙⴽⴼⴰⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⵔⵏ ⵙ ⵓⵙⴼⴰⵔ ⵏ ⵉⵙⵎⴰⵡⵏ ⵏ ⴽⵓ ⵓⵟⵟⵓⵏ ⴳ ⵓⴽⵜⵓⵔ, ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⴷⵢⴰ ⵙ 1, -1 ⵏⵖⴷ 0. ⵜⴰⵏⵏⴰⵜ: ⵓⵔ ⵜⵔⴰⵔⵎ ⴽⵔⴰ ⵉⴽⵜⵓⵔ ⵓⵔ ⵉⵍⵉⵏ. ⴰⵎⴷⵢⴰ: >>> prod_signs(((std::vector<long>{(long)1, (long)2, (long)2, (long)-4}))) 9 >>> prod_signs(std::vector<long>({(long)0, (long)1}))) 0 >>> prod_signs((std::vector<long>(())) std::nopt
std::optional<long> prod_signs(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> prod_signs(std::vector<long> arr) {
  if (arr.empty()) {
    return std::nullopt;
  }
  long sum_magnitudes = 0;
  long product_of_signs = 1;
  for (long num : arr) {
    sum_magnitudes += std::abs(num);
    if (num > 0) {
      product_of_signs *= 1;
    } else if (num < 0) {
      product_of_signs *= -1;
    } else {
      product_of_signs *= 0;
    }
  }
  return sum_magnitudes * product_of_signs;
}","}
int main() {
    auto candidate = prod_signs;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);
}
"
HumanEval/129,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⵖ ⵏⴰⴽⴽⴰ ⵜⴰⵡⵔⵉⵔⵜ ⵙ N ⵏ ⵜⵉⵙⵉⴹⴼⵉⵏ ⴷ N ⵏ ⵜⵉⵔⵙⴰⵍ (N >= 2) ⴷ ⴽⵓ ⵜⴰⵖⵔⴰⵙⵜ ⵏ ⵜⴽⵍⵉⵜ, ⴽⵓ ⵜⴰⵖⵔⴰⵙⵜ ⵏ ⵜⴽⵍⵉⵜ ⵜⵍⵍⴰ ⴳⵉⵙ ⵢⴰⵜ ⵜⵉⵏⵉⴹⵜ. ⴽⵓ ⵜⵉⵏⵉⴹⵜ ⴳ ⵓⵙⵏⵓⵎⵎⵍ [1, N * N] ⵜⵍⵍⴰ ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ ⴳ ⵜⵖⵔⴰⵙⵉⵏ ⵏ ⵜⴽⵍⵉⵜ. ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵏⴰⴼ ⴰⴱⵔⵉⴷ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵜⵉⵖⵣⵉ k ⴳ ⵜⴽⵍⵉⵜ. ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⴱⴷⵓ ⵙⴳ ⴽⵓ ⵜⴰⵖⵔⴰⵙⵜ, ⴷ ⴳ ⴽⵓ ⵜⵉⴽⵍⵉⵜ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵓⵜⵍⵜ ⵙ ⴽⵓ ⵜⴰⵖⵔⴰⵙⵉⵏ ⵜⵉⵎⴰⴷⴷⵓⵏⵉⵏ, ⵙ ⵜⴳⵓⵔⵉ ⵢⴰⴹⵏ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵣⵔⵉⴷ ⵙ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⵢⵎⵓⵏⵏ ⴷ ⵜⴰⵖⵔⴰⵙⵜ ⵜⴰⵜⵔⴰⵔⵜ. ⵔⴰⵏⵜⵉⴱ ⵓⵔ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵣⵔⵉⴷ ⵙⴳ ⵜⴽⵍⵉⵜ. ⴰⴱⵔⵉⴷ A (ⵙ ⵜⵉⵖⵣⵉ ⵏ ⵜⴽⵍⵉⵜ) ⵉⴳⴰ ⴰⴱⵔⵉⴷ ⵏ ⵜⵉⵖⵣⵉ ⴱ (ⵙ ⵜⵉⵖⵣⵉ ⵏ ⵜⴽⵍⵉⵜ) ⵉⵖ ⴷⴼⴼⵖ ⵜⵉⵖⵔⴰⵙⵉⵏ ⵏ ⵜⴽⵍⵉⵜ ⴱ (ⵙⵉⴹⵉⵏ) ⵏ ⵡⴰⵜ ⵏ ⵡⴰⵜⵉⴳⵔⵏⵓⵜⵏ ⵏ ⵡⴰⵜⵏⵏⴰⵡⵉⵏ ⵏ ⵡⴰⵜⵉⴳⵔⵏⵏⴰⵡⵉⵏ ⴳ ⵜⵖⵔⴰⵙⵉⵏ A ⴷ ⴱ (ⴰⴷ ⵏⵜⵜⴰ ⵏⵉⴼⵏⵏⴰⵡ (ⴰⴷ ⵏⵉⵏ ⴰⵙ ⵏⵉⵏ ⴰⵙⵏ ⴰⵙⵏ l_ⴰ l_ⴰ ⴷ l_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ_ⴰ
std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
  int n = grid.size();
  std::vector<long> min_path;

  std::function<void(int, int, std::vector<long>)> dfs = 
    [&](int row, int col, std::vector<long> current_path) {
    if (current_path.size() == k) {
      if (min_path.empty() || current_path < min_path) {
        min_path = current_path;
      }
      return;
    }

    current_path.push_back(grid[row][col]);

    int dr= {-1, 1, 0, 0};
    int dc= {0, 0, -1, 1};

    for (int i = 0; i < 4; ++i) {
      int next_row = row + dr[i];
      int next_col = col + dc[i];
      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {
        dfs(next_row, next_col, current_path);
      }
    }
  };

  for (int start_row = 0; start_row < n; ++start_row) {
    for (int start_col = 0; start_col < n; ++start_col) {
      dfs(start_row, start_col, {});
    }
  }

  return min_path;
}","}
int main() {
    auto candidate = minPath;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
}
"
HumanEval/130,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⵙⵏⵎⵍ ⵓⵙⵏⵙⵍ ⵏ ⵟⵔⵉⴱⵓⵏⴰⵛⵉ ⵙ ⵓⵙⵏⴼⵍⵓⵍ ⵏ ⵜⵉⴽⵍⵉⵜ: tri(1) = 3 tri(n) = 1 + n / 2, ⵉⴳ n ⵉⴳⴰ ⴰⵎⵢⴰⴳ. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ⵉⴳ n ⵉⴳⴰ ⴰⵎⵢⴰⴳ. ⵙ ⵓⵎⴷⵢⴰ: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵓⴹ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⵢⴰⴳ, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔⴷ ⵢⴰⵏ ⵓⴽⵏⵓⴹ ⵏ ⵉⵎⵉⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ n + 1 ⵏ ⵓⵙⵏⵙⵍ ⵏ ⵟⵔⵉⴱⵓⵏⴰⵛⵉ. ⵉⵎⴷⵢⴰⵜⵏ: >>>((3) (dst tri (((long vector:{((long} (1,3,2,8))
std::vector<long> tri(long n) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> tri(long n) {
  std::vector<long> result;
  if (n >= 0) {
    result.push_back(1);
  }
  if (n >= 1) {
    result.push_back(3);
  }
  for (long i = 2; i <= n; ++i) {
    if (i % 2 == 0) {
      result.push_back(1 + i / 2);
    } else {
      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)
      {
          result.push_back(result[i-1] + result[i-2] + result[i]);
      }
      else if (i - 1 >= 0 && i - 2 >= 0)
      {
          result.push_back(result[i-1] + result[i-2]);
      }
      else if (i - 1 >= 0)
      {
          result.push_back(result[i-1]);
      }
      else
      {
          result.push_back(0);
      }
    }
  }
  return result;
}","}
int main() {
    auto candidate = tri;
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));
    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));
    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));
    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));
    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));
    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));
    assert(candidate((0)) == (std::vector<long>({(long)1})));
    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));
}
"
HumanEval/131,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⵏⴰⴽⴽⴰ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵏⵔⴰⵔ ⵜⴰⵢⴰⴼⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵏⵔⴰⵔ 0 ⵉⵖ ⴳⴰⵏ ⵡⵓⵟⵟⵓⵏ ⴰⴽⴽⵡ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> ⵡⵓⵟⵟⵓⵏ (((1)) (1) >>> ⵡⵓⵟⵟⵓⵏ (((4)) (0) >>> ⵡⵓⵟⵟⵓⵏ (((235)) (15)
long digits(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long digits(long n) {
  long product = 1;
  std::string s = std::to_string(n);
  bool has_odd = false;
  for (char c : s) {
    long digit = c - '0';
    if (digit % 2 != 0) {
      product *= digit;
      has_odd = true;
    }
  }
  if (!has_odd) {
    return 0;
  }
  return product;
}","}
int main() {
    auto candidate = digits;
    assert(candidate((5)) == (5));
    assert(candidate((54)) == (5));
    assert(candidate((120)) == (1));
    assert(candidate((5014)) == (5));
    assert(candidate((98765)) == (315));
    assert(candidate((5576543)) == (2625));
    assert(candidate((2468)) == (0));
}
"
HumanEval/132,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵗⵏⵓ ⵏ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵜⴰ ⵢⵂⴰ ⵙⵜⵔⵉⵏⴶ ⵛⵂⵓⵏⴷ ⵉⵏⵜⴰⵋ ⵓⴰ ⵉⵍⴰⵏ ⴱⵔⴰⵛⴻⵜⵙ ⵛⵓⴰⵔⴻ. ⴰⵍⵆⵉⴷⵎⴰⵜ ⵜⴰ ⵉⵋⵋⴰ ⴼⴰⵍ ⴰⵙ ⵜⵓⵍⴰⵙ ⵂⴰⵔⴰⵜ ⵉⵉⵉⴰⵏ ⵗⴰⵙ ⴰ ⴼⴰⵍ ⵉⵍⵍⴰ ⵙⵓⴱⵙⵛⵢⵛⵢⵏⵛⵢ ⵏ ⴱⵔⴰⵛⴻⵜⵙ ⵓⴰ ⵉⴷ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵉⵉⵉⴰⵜ ⴷⴰⵗ ⵙⵓⴱⵙⵛⵢⵛⵢⵏⵛⵢ ⵜ ⵉⵋⵋⴰ >>> ⴰⵈⵈⴰⵍ_ⴱⵔⴰⵛⴻⵜⵙ "" ([[]]"")) (ⵜⵂⵔⴻ) >>> ⴰⵈⵈⴰⵍ_ⴱⵔⴰⵛⴻⵜⵙ "" ([[]])) (ⴼⴰⵍⵙ) >>> ⴰⵈⵈⴰⵍ_ⴱⵔⴰⵛⴻⵜⵙ "" ([[]])) (ⴼⴰⵍⵙ) >>> ⴰⵈⵈⴰⵍ_ⴱⵔⴰⵛⴻⵜⵙ "" ([[]])) (ⵜⵂⵔⴻ) >>> ⴰⵈⵈⴰⵍ_ⴱⵔⴰⵛⴻⵜⵙ "" ([[]])) (ⵜⵂⵔⴻ)
bool is_nested(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_nested(std::string string) {
  int balance = 0;
  bool nested = false;
  for (char c : string) {
    if (c == '[') {
      balance++;
    } else if (c == ']') {
      if (balance > 1) {
        nested = true;
      }
      balance--;
      if (balance < 0) {
        return false;
      }
    }
  }
  return balance == 0 && nested;
}","}
int main() {
    auto candidate = is_nested;
    assert(candidate((""[[]]"")) == (true));
    assert(candidate((""[]]]]]]][[[[[]"")) == (false));
    assert(candidate((""[][]"")) == (false));
    assert(candidate((""[]"")) == (false));
    assert(candidate((""[[[[]]]]"")) == (true));
    assert(candidate((""[]]]]]]]]]]"")) == (false));
    assert(candidate((""[][][[]]"")) == (true));
    assert(candidate((""[[]"")) == (false));
    assert(candidate((""[]]"")) == (false));
    assert(candidate((""[[]][["")) == (true));
    assert(candidate((""[[][]]"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""[[[[[[[["")) == (false));
    assert(candidate((""]]]]]]]]"")) == (false));
}
"
HumanEval/133,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ. ⴷⴰ ⵜⵜⵓⵙⵔⴰⵙⵏ ⴰⴷ ⵜⵔⵎⵙⴷ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵓⴷⴰⵕ ⴳ ⵓⴽⵜⵓⵔ ⴰⴷ, ⴷ ⴰⴷ ⵜⵙⵙⵎⴷⵔⵎ ⴽⵓ ⵉⴼⵔⴷⵉⵙ ⴳ ⵓⴽⵜⵓⵔ ⵙ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵜⵓⵔ ⵏ ⵓⴼⵍⵍⴰ. ⵉⵎⴷⵢⴰⵜⵏ: >>> lst:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:{ⴽⵜⵓⵔ:{ⴽⵜⵓⵔ:{ⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ:}}}}
long sum_squares(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_squares(std::vector<float> lst) {
  long sum = 0;
  for (float num : lst) {
    long rounded_up = std::ceil(num);
    sum += rounded_up * rounded_up;
  }
  return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));
    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));
    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));
    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));
    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));
}
"
HumanEval/134,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⴰⵏⵙⴰ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵓⵖⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵢⴰⵏ ⵓⴽⵔⵉⴽ ⴰⴱⴰⵢⵢⵓⵔⴰⵏ ⵓⵔ ⵉⴳⵉ ⴰⴳⵣⵣⵓⵎ ⵏ ⵜⴳⵓⵔⵉ, ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ. ⵜⴰⵏⵏⴰⵢⵜ: ""ⵜⴳⵓⵔⵉ"" ⵜⴳⴰ ⵜⴰⵔⴰⴱⴱⵓⵜ ⵏ ⵡⴰⵏⵙⴰⵢⵏ ⵏⵏⴰ ⵉⴱⴹⴰⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ. ⵉⵎⴷⵢⴰⵜⵏ: >>> check_if_last_char_is_a_letter ((((""apple pie"")) (false) >>> check_if_last_char_is_a_letter (((""apple pi e"")) (true) >>> check_if_last_char_is_a_letter ((((""apple pi e "")) (false) >>> check_if_last_char_is_a_letter ((("""")) (false)
bool check_if_last_char_is_a_letter(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_if_last_char_is_a_letter(std::string txt) {
  if (txt.empty()) {
    return false;
  }
  if (!isalpha(txt.back())) {
    return false;
  }
  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {
    return false;
  }
  return true;
}","}
int main() {
    auto candidate = check_if_last_char_is_a_letter;
    assert(candidate((""apple"")) == (false));
    assert(candidate((""apple pi e"")) == (true));
    assert(candidate((""eeeee"")) == (false));
    assert(candidate((""A"")) == (true));
    assert(candidate((""Pumpkin pie "")) == (false));
    assert(candidate((""Pumpkin pie 1"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""eeeee e "")) == (false));
    assert(candidate((""apple pie"")) == (false));
    assert(candidate((""apple pi e "")) == (false));
}
"
HumanEval/135,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⴰⵎⵉⴹⴰⵏ ⴰⵎⵇⵔⴰⵏ ⵏ ⵢⴰⵏ ⵉⴼⵔⴷⵉⵙ ⵓⵔ ⵢⴰⴳⴳⵓⴳⵏ ⵏⵖ ⵓⵔ ⵢⴰⴽⵙⵓⵍⵏ ⴷ ⵉⴼⵔⴷⵉⵙ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⴷⴰⵜ ⵏⵏⵙ. ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵉⴼⵔⴷⵉⵙ ⴰⴷ, ⵙⴽⵔ -1. ⵓⵔ ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵡⴰⵜⵉⴳⵏ ⵉⵎⵢⴰⵍⵍⴰⵏ. ⵉⵎⴷⵢⴰⵜⵏ: >>> can_arrange{((std::vector<long>({long) 1, (long) 2, (long) 4, (long) 3, (long) 5}))) (3) >>> can_arrange{(std::vector<long>{(long) 1, (long) 2, (long) 3}))) (-1)
long can_arrange(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long can_arrange(std::vector<long> arr) {
  for (long i = 1; i < arr.size(); ++i) {
    if (arr[i] < arr[i - 1]) {
      return i;
    }
  }
  return -1;
}","}
int main() {
    auto candidate = can_arrange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));
    assert(candidate((std::vector<long>())) == (-1));
}
"
HumanEval/136,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⴰⴱⵍⵍⵜ (ⴰ,ⴱ), ⴳ ⵉⴳⴰ 'ⴰ' ⴰⵎⵇⵇⵔⴰⵏ ⴳ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴽⵙⵡⴰⵜⵏ, ⴷ 'ⴱ' ⴰⵎⵥⵥⵢⴰⵏ ⴳ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴽⵙⵡⴰⵜⵏ ⴳ ⵓⵎⵓⴷⴷⵓ. ⵉⵖ ⵓⵔ ⵍⵍⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴽⵙⵡⴰⵜⵏ ⵏⵖ ⵉⵎⴹⴰⵏⵏ ⵉⴽⵙⵡⴰⵜⵏ, ⵙⴽⵔ-ⴷ ⵉⵎⴹⴰⵏⵏ ⴰⴷ ⴰⵎⵎ None. ⵉⵎⴷⵢⴰⵜⵏ: >>> largest_smallest_integers(((std::vector<long>{long) 2, (long) 4, (long) 1, (long) 3, (long) 5, (long) 7))) std::make_tuplestd::optional<long>{long>), std::optional<long>{long>) >>> largest_smallest_integers{long>{stdull>:nopt}, std::optional<long>{long>{dull>}<opt>), stdlong><long><long>
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<tuple>
#include<vector>

std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> largest_negative = std::nullopt;
    std::optional<long> smallest_positive = std::nullopt;
    for (long num : lst) {
        if (num < 0) {
            if (!largest_negative.has_value() || num > largest_negative.value()) {
                largest_negative = num;
            }
        } else if (num > 0) {
            if (!smallest_positive.has_value() || num < smallest_positive.value()) {
                smallest_positive = num;
            }
        }
    }
    return std::make_tuple(largest_negative, smallest_positive);
}","}
int main() {
    auto candidate = largest_smallest_integers;
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));
    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));
    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));
}
"
HumanEval/137,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵖⴷ ⵉⵎⴹⴰⵏ ⵉⵎⵎⵓⴷⴷⵓⵏ ⵏⵖⴷ ⵜⵉⴼⵔⵉⵙⵉⵏ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏ ⵉⵎⴹⴰⵏ ⵏ ⵜⵉⴷⵜ, ⴰⵔ ⵉⵙⵙⴽⵛⵎ ⴰⵎⵙⵏⴼⵍⵓⵍ ⴰⵅⴰⵜⴰⵔ ⴳ ⵡⴰⵏⴰⵡ ⵏ ⵉⵎⵙⵏⴼⵍⵓⵍⵏ ⵏⵏⴰ ⵢⵓⵡⵉⵏ. ⵓⵔ ⵉⵙⵙⴽⵛⵎ ⴽⵔⴰ ⵎⴽ ⵜⴳⴰ ⵜⵉⴳⵎⵉⴹⵉ ⵏ ⵡⴰⵜⵉⴳⵏ. ⵜⴰⵏⵏⴰⵢⵜ: ⵎⴽ ⵉⵜⵜⵓⵙⵎⴷⵢ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴷⵜ ⵙ ⵜⵉⴼⵔⵉⵙⵜ ⵏ ⵜⵉⴼⵔⵉⵙⵜ, ⵉⵖⵢ ⴰⴷ ⵉⴳ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵏⵇⵇⵉⴹⵜ ⵜⴰⵎⵎⵓⴷⴷⵓⵜ . ⵏⵖⴷ , >>> compare_one{1, 2.5f) 2.5f >>> compare_one{1, ""2,3"") ""2,3"" >>> compare_one{5,1"", ""6"") ""6"" >>> compare_one{1"", 1) std::nullopt
Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<string>

union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;
    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;
    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};

double parse_real(const std::string& s) {
    std::string temp = s;
    std::replace(temp.begin(), temp.end(), ',', '.');
    try {
        return std::stod(temp);
    } catch (const std::invalid_argument& e) {
        return std::numeric_limits<double>::quiet_NaN();
    } catch (const std::out_of_range& e) {
        return std::numeric_limits<double>::quiet_NaN();
    }
}

Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a.f2.empty() && b.f2.empty()) {
        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {
            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {
            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);
            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {
            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {
            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);
            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);
        }
    } else {
        double val_a, val_b;
        if (!a.f2.empty()) val_a = parse_real(a.f2);
        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);
        else val_a = static_cast<double>(a.f1);

        if (!b.f2.empty()) val_b = parse_real(b.f2);
        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);
        else val_b = static_cast<double>(b.f1);

        if (!std::isnan(val_a) && !std::isnan(val_b)) {
            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);
            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);
        }
    }
    return Union_long_float_std_string_std_nullopt(std::nullopt{});
}","}
int main() {
    auto candidate = compare_one;
    assert(candidate(1, 2) == 2);
    assert(candidate(1, 2.5f) == 2.5f);
    assert(candidate(2, 3) == 3);
    assert(candidate(5, 6) == 6);
    assert(candidate(1, ""2,3"") == ""2,3"");
    assert(candidate(""5,1"", ""6"") == ""6"");
    assert(candidate(""1"", ""2"") == ""2"");
    assert(candidate(""1"", 1) == std::nullopt);
}
"
HumanEval/138,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵜⵉⴳ ⵏ ⵡⵓⵟⵟⵓⵏ n ⵉⵖⵢ ⴰⴷ ⵉⵜⵜⵢⴰⵔⴰ ⴰⵎⵎ ⵓⴳⵣⵓⵎ ⵏ ⴽⴽⵓⵥ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉⴼⵓⵍⴽⵉⵏ ⴰⵎⴷⵢⴰ >>> is_equal_to_sum_even (((4)) (false) >>> is_equal_to_sum_even (((6)) (false) >>> is_equal_to_sum_even (((8)) (true)
bool is_equal_to_sum_even(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_equal_to_sum_even(long n) {
    if (n <= 6 || n % 2 != 0) {
        return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_equal_to_sum_even;
    assert(candidate((4)) == (false));
    assert(candidate((6)) == (false));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (true));
    assert(candidate((11)) == (false));
    assert(candidate((12)) == (true));
    assert(candidate((13)) == (false));
    assert(candidate((16)) == (true));
}
"
HumanEval/139,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⵙⵏⵎⵍ ⵓⴼⴰⴽⵜⵓⵔⴰⵍ ⴰⴱⵕⴰⵣⵉⵍⵉ ⵙ: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! ⴳ ⵉⵍⵍⴰ n > 0 ⵙ ⵓⵎⴷⵢⴰ: >>> special_factorial (((4)) (288) ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⵓⵎⵥ ⴰⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⴽⴷ, ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵕⵓⵚⴼ ⵜⴰⴼⴰⴽⵜⵓⵔⴰⵍⵜ ⵜⴰⵎⴷⴷⴰⴷⵜ ⵏ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⴷ.
long special_factorial(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long factorial(long k) {
    long res = 1;
    for (long i = 2; i <= k; ++i) {
        res *= i;
    }
    return res;
}

long special_factorial(long n) {
    if (n <= 0) {
        return 1;
    }
    long result = 1;
    for (long i = 1; i <= n; ++i) {
        result *= factorial(i);
    }
    return result;
}","}
int main() {
    auto candidate = special_factorial;
    assert(candidate((4)) == (288));
    assert(candidate((5)) == (34560));
    assert(candidate((7)) == (125411328000));
    assert(candidate((1)) == (1));
}
"
HumanEval/140,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⴷⴰⴶ ⵉⵍⴰⵏ ⴰⴾⴰⵜⴰⴱ ⵏ ⵜⴰⵂⵔⵉⴾⴻ, ⴰⵙⵉⵎⵎⵓⵜⴰⵉ ⵉⵛⵛⵉⴾⵉⵍⴰⵏ ⴼⵓⴾ ⴷⴰⵗ ⴰⵙ ⵙ ⵉⵛⵛⵉⴾⵉⵍⴰⵏ ⵓⵉⵏ ⴷⴷⴰⴶ, ⴰⴷ ⴰ ⴼⴰⵍ ⵜⴰⵂⵔⵉⴾⴻ ⵉⵍⴰ ⵂⴰⵔ 2 ⵉⵛⵛⵉⴾⵉⵍⴰⵏ ⵓⵉⵏ ⴷⴰⵔⴰⵜ ⵏ ⴰⵓⴻⵏ ⴰⵙⵉⵎⵎⵓⵜⴰⵉ ⵉⵛⵛⵉⴾⵉⵍⴰⵏ ⴼⵓⴾ ⵓⵉⵏ ⴷⴰⵔⴰⵜ ⵙ - >>> fix_spaces(("" ⴰⵍⵎⵉⵜⴰⵍ"")) ("" ⴰⵍⵎⵉⵜⴰⵍ"") >>> fix_spaces(("" ⴰⵍⵎⵉⵜⴰⵍ 1"")) ("" ⴰⵍⵎⵉⵜⴰⵍ_1"") >>> fix_spaces(("" ⴰⵍⵎⵉⵜⴰⵍ 2"") (""_ ⴰⵍⵎⵉⵜⴰⵍ_2"") >>> fix_spaces(("" ⴰⵍⵎⵉⵜⴰⵍ 3"")) (""_ ⴰⵍⵎⵉⵜⴰⵍ-3"")
std::string fix_spaces(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string fix_spaces(std::string text) {
    std::string result = """";
    int space_count = 0;
    for (char c : text) {
        if (c == ' ') {
            space_count++;
        } else {
            if (space_count == 1) {
                result += '_';
            } else if (space_count > 1) {
                result += '-';
            }
            result += c;
            space_count = 0;
        }
    }
    if (space_count == 1 && !result.empty() && result.back() != '_') {
        result += '_';
    } else if (space_count > 1 && !result.empty() && result.back() != '-') {
        result += '-';
    } else if (space_count > 0 && result.empty()) {
        if (space_count > 2) result += '-';
        else if (space_count == 1) result += '_';
    } else if (space_count == 1 && result.empty()) {
        result += '_';
    }

    std::string trimmed_result = """";
    bool non_space_found = false;
    for (char c : result) {
        if (c != ' ') {
            non_space_found = true;
            trimmed_result += c;
        } else if (non_space_found) {
            trimmed_result += c;
        }
    }

    while (!trimmed_result.empty() && trimmed_result.front() == '_') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '_') {
        trimmed_result.pop_back();
    }
     while (!trimmed_result.empty() && trimmed_result.front() == '-') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '-') {
        trimmed_result.pop_back();
    }

    std::string final_result = """";
    space_count = 0;
    for (char c : trimmed_result) {
        if (c == '_') {
            space_count++;
        } else {
            if (space_count == 1) {
                final_result += '_';
            } else if (space_count > 1) {
                final_result += '-';
            }
            final_result += c;
            space_count = 0;
        }
    }
    if (space_count == 1) {
        final_result += '_';
    } else if (space_count > 1) {
        final_result += '-';
    }

    return final_result;
}","}
int main() {
    auto candidate = fix_spaces;
    assert(candidate((""Example"")) == (""Example""));
    assert(candidate((""Mudasir Hanif "")) == (""Mudasir_Hanif_""));
    assert(candidate((""Yellow Yellow  Dirty  Fellow"")) == (""Yellow_Yellow__Dirty__Fellow""));
    assert(candidate((""Exa   mple"")) == (""Exa-mple""));
    assert(candidate((""   Exa 1 2 2 mple"")) == (""-Exa_1_2_2_mple""));
}
"
HumanEval/141,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵗⵏⵓ ⵏ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵜⴰ ⵢⵂⴰⵏ ⵜⴰⵗⴰⵛⴰⴷⵜ ⵜⴰ ⵜⴰⵈⵈⴰⵍⴰⵜ ⵉⵙⵉⵎ ⵏ ⴼⴰⵉⵍ ⵜⵓⵍⴰⵙ ⵜⴰⵔⵂⴰ ""ⴷⴰⵗ"" ⴰ ⴼⴰⵍ ⵉⵙⵉⵎ ⵏ ⴼⴰⵉⵍ ⵓⴰⵔ ⵢⵈⵈⵢⵍ ⵓⵗⴰⴷ ⵜⵓⵍⴰⵙ ⵜⴰⵔⵂⴰ ""ⵓⴰⵔ ⵢⵈⵈⵢⵍ ⵓⵗⴰⴷ"" ⴰⵍⵓⴰⵈ ⵓⴰ ⵉⴷ ⵉⵙⵉⵎ ⵏ ⴼⴰⵉⵍ ⵓⴰⵔ ⵢⵈⵈⵢⵍ ⵓⵗⴰⴷ ⴰⵍⵓⴰⵈ ⵓⴰ ⵉⴷ ⵉⵋⵋⴰⵏ ⵉⵙⵉⵎ ⵏ ⴼⴰⵉⵍ ⵓⴰⵔ ⴰⴷ ⵉⵍⵍⴰ ⵓⵋⵋⴰⵔ ⵏ ⴾⴰⵔⴰⴷⴰⵜ ⵏ ⴾⴰⵔⴰⴷⴰⵜ ⵏ ⴾⴰⵔⴰⴷⴰⵜⴰⵏ ⴷⴰⵗ ⵉⵙⵉⵎ ⵏ ⴼⴰⵉⵍ - ⵉⵙⵉⵎ ⵏ ⴼⴰⵉⵍ ⵉⵍⴰ ⴱⵓⵓⵜ ' ⵉⵉⵉⴰⵏ - ⵙⵓⴱⵜⵔⵉⵏⴶ ⴷⴰⵜ ⴱⵓⵓⵜ ⵓⴰⵔ ⴰⴷ ⵢⵈⵈⵢⵍ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴷⵢⵗ ⵜⵓⵍⴰⵙ ⵜ ⵉⵜⴰⵣⴰⵔ ⵙ ⴰⵍⴾⵉⵜⵜⴰⴱ ⵏ ⴰⵍⴾⵉⵜⵜⴰⴱ ⵓⴰⵏ ⵍⴰⵜⵉⵏ ('ⴰ'-'ⵣ' ⴷ 'ⴰ'-ⵣ') - ⵙⵓⴱⵜⵔⵉⵏⴶ ⴷⴰⵔⴰⵜ ⴱⵓⵓⵜ ⵓⴰⵔ ⵢⵈⵈⵢ ⵢⵉⵉⵉⵉⵉⴰⵏ ⴷⴰⵗ ⵓⵉⵏ ⴷⴰⵗ ⵓⵉⵏ ⵏ ⵓⵉⵏ: ['ⵜⵛⵜⵙⵜ', 'ⵢ', 'ⵢ', 'ⵢ', 'ⵉⵍ']
std::string file_name_check(std::string file_name) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string file_name_check(std::string file_name) {
    int digit_count = 0;
    int dot_count = 0;
    size_t dot_pos = std::string::npos;

    for (size_t i = 0; i < file_name.length(); ++i) {
        if (isdigit(file_name[i])) {
            digit_count++;
        } else if (file_name[i] == '.') {
            dot_count++;
            dot_pos = i;
        }
    }

    if (digit_count > 3 || dot_count != 1) {
        return ""No"";
    }

    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {
        return ""No"";
    }

    std::string name_part = file_name.substr(0, dot_pos);
    std::string ext_part = file_name.substr(dot_pos + 1);

    if (name_part.empty() || !isalpha(name_part[0])) {
        return ""No"";
    }

    if (ext_part == ""txt"" || ext_part == ""exe"" || ext_part == ""dll"") {
        return ""Yes"";
    } else {
        return ""No"";
    }
}","}
int main() {
    auto candidate = file_name_check;
    assert(candidate((""example.txt"")) == (""Yes""));
    assert(candidate((""1example.dll"")) == (""No""));
    assert(candidate((""s1sdf3.asd"")) == (""No""));
    assert(candidate((""K.dll"")) == (""Yes""));
    assert(candidate((""MY16FILE3.exe"")) == (""Yes""));
    assert(candidate((""His12FILE94.exe"")) == (""No""));
    assert(candidate((""_Y.txt"")) == (""No""));
    assert(candidate((""?aREYA.exe"")) == (""No""));
    assert(candidate((""/this_is_valid.dll"")) == (""No""));
    assert(candidate((""this_is_valid.wow"")) == (""No""));
    assert(candidate((""this_is_valid.txt"")) == (""Yes""));
    assert(candidate((""this_is_valid.txtexe"")) == (""No""));
    assert(candidate((""#this2_i4s_5valid.ten"")) == (""No""));
    assert(candidate((""@this1_is6_valid.exe"")) == (""No""));
    assert(candidate((""this_is_12valid.6exe4.txt"")) == (""No""));
    assert(candidate((""all.exe.txt"")) == (""No""));
    assert(candidate((""I563_No.exe"")) == (""Yes""));
    assert(candidate((""Is3youfault.txt"")) == (""Yes""));
    assert(candidate((""no_one#knows.dll"")) == (""Yes""));
    assert(candidate((""1I563_Yes3.exe"")) == (""No""));
    assert(candidate((""I563_Yes3.txtt"")) == (""No""));
    assert(candidate((""final..txt"")) == (""No""));
    assert(candidate((""final132"")) == (""No""));
    assert(candidate((""_f4indsartal132."")) == (""No""));
    assert(candidate(("".txt"")) == (""No""));
    assert(candidate((""s."")) == (""No""));
}
"
HumanEval/142,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// "" ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⵕⵥⵎ ⵢⴰⵏ ⵓⴽⴼⴰⵢ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵉ ⴽⵓⵍⵍⵓ ⵜⵉⵎⵙⴽⵜⵉⵜⵉⵏ ⴳ ⵓⴽⴼⴰⵢ, ⵔⴰⴷ ⵜⴽⴽⵡⵙ ⵜⴰⵡⵓⵔⵉ ⴳ ⵓⵙⴽⴽⵉⵍ ⵏ ⵓⴽⴼⴰⵢ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵖ ⵉⴳⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⴳⴳⵓⴷ ⵏ 3 ⴷ ⵔⴰⴷ ⵜⴽⴼⵓ ⵜⴰⵡⵓⵔⵉ ⴳ ⵓⴽⴼⴰⵢ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵖ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⴳⴳⵓⴷ ⵏ 4 ⵓⵔ ⵉⴳⵉ ⴰⵎⴳⴳⵓⴷ ⵏ 3. ⵓⵔ ⵔⴰⴷ ⵜⵙⵏⴼⵍ ⵜⵉⵙⴽⵜⵉⵜⵉⵏ ⴳ ⵓⴽⴼⴰⵢ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⴳⴳⵓⴷ ⵏ 3 ⵏⵖⴷ 4. ⵔⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ ⵜⴰⴳⵓⵜ ⵏ ⵉⵎⵙⴽⵜⵉⵜⵏ ⴽⵓⵍⵍⵓ. ⵉⵎⴷⵢⴰⵜⵏ: >>> lst (long({(long) 1, (long) 2, (long) 3})) >>> lst ({(long) -1, (long) -5, (long) 2, (long) -1, (long) -5}))
long sum_squares(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for (size_t i = 0; i < lst.size(); ++i) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));
    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));
    assert(candidate((std::vector<long>({(long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));
    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));
    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));
}
"
HumanEval/143,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ ⵉⵙⵎⴷⵢⴰⵏⵏ ⵏ ⵜⴳⵓⵔⵉ, ⴳ ⵜⴳⵓⵔⵉ ⵉⵍⵍⴰ ⴽⵔⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵜⵜⵓⵢⴼⴼⴹⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ, ⴷ ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⴽⵛⵛⵓⵎⵜ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵏ ⵜⴳⵓⵔⵉ ⵏ ⵜⵉⵣⵡⵉⵔⵉ, ⵏⵏⴰ ⵉⴳⴰⵏ ⵜⵉⵖⵣⵉ ⵏⵏⵙ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⴳ ⵜⵉⵔⵔⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴳ ⵜⴽⵛⵛⵓⵎⵜ ⵜⴰⵎⴰⵢⵏⵓⵜ ⴰⵎⵎ ⵜⵉⴽⵛⵛⵓⵎⵜ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ. ⴰⵎⴷⵢⴰ 1: >>> words_in_sentence (((""This is a test"")) (""is"") ⴰⵎⴷⵢⴰ 2: >>> words_in_sentence (((""let go for swimming"")) (""go for"") ⵜⵉⵎⵥⵍⴰⵢ: * 1 <= len ((sentence) <= 100 * ⵜⴳⵓⵔⵉ ⵉⵍⵍⴰ ⴳⵉⵙ ⵜⵉⵔⵔⴰ ⵖⴰⵙ
std::string words_in_sentence(std::string sentence) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

std::string words_in_sentence(std::string sentence) {
    std::string result = """";
    std::stringstream ss(sentence);
    std::string word;
    while (ss >> word) {
        if (is_prime(word.length())) {
            if (!result.empty()) {
                result += "" "";
            }
            result += word;
        }
    }
    return result;
}","}
int main() {
    auto candidate = words_in_sentence;
    assert(candidate((""This is a test"")) == (""is""));
    assert(candidate((""lets go for swimming"")) == (""go for""));
    assert(candidate((""there is no place available here"")) == (""there is no place""));
    assert(candidate((""Hi I am Hussein"")) == (""Hi am Hussein""));
    assert(candidate((""go for it"")) == (""go for it""));
    assert(candidate((""here"")) == (""""));
    assert(candidate((""here is"")) == (""is""));
}
"
HumanEval/144,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵎⵔⵙ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵔⴰⴷ ⵉⵙⴱⴷⵉⴷ ⴰⵙⵏⵓⵎⵎⵍ x * n. ⴷⴰ ⵜⵙⴽⵔ ⵜⴰⵡⵡⵓⵔⵉ ⵜⵉⴷⵜ ⵎⴽⵍⵍⵉ x * n ⵉⴳⴰ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ, ⴷ ⵜⵉⴷⵜ ⵎⴰⵛⴰ. ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔⵏ ⵙ ⵙⵏⴰⵜ ⵜⵉⴼⵔⴽⵉⵡⵉⵏ ⵏ ⵓⴽⵙⴰⵢ, ⴷ ⵖⵓⵔⵙⵏ ⵜⴰⵍⵖⴰ ⴷ ⵢⵓⵛⴽⴰⵏ, <ⴰⵎⴹⴰⵏ>/<ⴰⵎⵙⵙⴰⵖ>, ⴳ ⴳⴰⵏ ⵙⵏⴰⵜ ⵜⵉⴼⵔⴽⵉⵡⵉⵏ ⴷ ⵓⵎⵙⵙⴰⵖ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽ ⵎⴰⵙ ⴷ x ⴷ n ⴳⴰⵏ ⵉⴼⵔⴽⵉⵙⵏ ⵉⵣⵔⴼⴰⵏ, ⴷ ⵓⵔ ⵖⵓⵔⵙⵏ ⴰⵎⵢⴰ ⴰⵎⵙⵙⴰⵖ. >>> ⵙⵙⵓⴷⵙⵓ (((""1/5""), (""5/1"")) (ⵜⴰⴷⴷⵓⵜ) >>> ⵙⵙⵓⴷⵙⵓ (((""1/6""), (""2/1"") (ⵜⴰⵍⵖⴰ) >>> ⵙⵙⵓⴷⵙⵓ (((""7/10""), (""10/2"") (ⵜⴰⵍⵖⴰ)
bool simplify(std::string x, std::string n) {
","#include<assert.h>
#include<bits/stdc++.h>

long gcd(long a, long b) {
    while (b) {
        a %= b;
        std::swap(a, b);
    }
    return a;
}

bool simplify(std::string x, std::string n) {
    long x_num, x_den, n_num, n_den;
    size_t slash_pos = x.find('/');
    x_num = std::stol(x.substr(0, slash_pos));
    x_den = std::stol(x.substr(slash_pos + 1));

    slash_pos = n.find('/');
    n_num = std::stol(n.substr(0, slash_pos));
    n_den = std::stol(n.substr(slash_pos + 1));

    long num = x_num * n_num;
    long den = x_den * n_den;

    long common_divisor = gcd(num, den);
    den /= common_divisor;

    return den == 1;
}","}
int main() {
    auto candidate = simplify;
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/6""), (""2/1"")) == (false));
    assert(candidate((""5/1""), (""3/1"")) == (true));
    assert(candidate((""7/10""), (""10/2"")) == (false));
    assert(candidate((""2/10""), (""50/10"")) == (true));
    assert(candidate((""7/2""), (""4/2"")) == (true));
    assert(candidate((""11/6""), (""6/1"")) == (true));
    assert(candidate((""2/3""), (""5/2"")) == (false));
    assert(candidate((""5/2""), (""3/5"")) == (false));
    assert(candidate((""2/4""), (""8/4"")) == (true));
    assert(candidate((""2/4""), (""4/2"")) == (true));
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/5""), (""1/5"")) == (false));
}
"
HumanEval/145,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ. ⴰⵖⵕⴹ: ⵎⴽ ⵍⵍⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵎ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ, ⵙⵙⵓⴷⵙ ⴳ ⵓⵙⵙⵓⴷⵙ ⵏⵏⵙⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⴰⵎⵣⵡⴰⵔⵓ. ⵙ ⵓⵎⴷⵢⴰ: >>> order_by_points(((std::vector<long>({long) 1, (long) 11, (long) -1, (long) -1, (long) -12}))) (std::vector<long>({long) -1, (long) -11, (long) 1, (long) -12, (long) 11})) >>> order_by_points((std::vector<long>())) (std::vector<long>(long))
std::vector<long> order_by_points(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_digits(long n) {
    long sum = 0;
    std::string s = std::to_string(std::abs(n));
    for (char c : s) {
        sum += c - '0';
    }
    return sum;
}

std::vector<long> order_by_points(std::vector<long> nums) {
    std::vector<std::pair<long, size_t>> indexed_nums;
    for (size_t i = 0; i < nums.size(); ++i) {
        indexed_nums.push_back({nums[i], i});
    }

    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {
        long sum_a = sum_digits(a.first);
        long sum_b = sum_digits(b.first);
        if (sum_a != sum_b) {
            return sum_a < sum_b;
        }
        return a.second < b.second;
    });

    std::vector<long> result;
    for (const auto& pair : indexed_nums) {
        result.push_back(pair.first);
    }
    return result;
}","}
int main() {
    auto candidate = order_by_points;
    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));
    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));
    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));
}
"
HumanEval/146,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵙⵙⴽⵛⵎ ⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵢⵓⴼⵏ 10 ⴷ ⵡⴰⵏⵏⴰⵢ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⴰⵏⵏⴰⵢ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⴳⴰⵏ ⵉⵎⵉⴹ (1, 3, 5, 7, 9). ⵙ ⵓⵎⴷⵢⴰ: >>> specialFilter(((std::vector<long>({(long) 15, (long) -73, (long) 14, (long) -15}))) (1) >>> specialFilter(((std::vector<long>({(long) 33, (long) -2, (long) -3, (long) 45, (long) 21, (long) 109} (2))))
long specialFilter(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_odd_digit(char c) {
    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');
}

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for (long num : nums) {
        if (std::abs(num) > 10) {
            std::string s = std::to_string(std::abs(num));
            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {
                count++;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = specialFilter;
    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));
    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));
    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));
    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));
    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>())) == (0));
}
"
HumanEval/147,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵓ ⵉⵎⵉⴹ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⴷⵉ n. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵜⵓⵙⴽⴰⵔⴷ ⵢⴰⵏ ⵓⵎⵉⴹ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⴷⵉ a ⵏ ⵜⵉⵖⵣⵉ n. ⵉ ⴽⵓ i (1 ≤ i ≤ n), ⴰⵜⵉⴳ ⵏ a[i] = i * i - i + 1. ⴷⴰ ⵜⵜⵓⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵔⴱⵉⵍⵉⵏ (a[i], a[j], a[k]) ⵏ a ⴳ i < j < k, ⴷ a[i] + a[j] + a[k] ⵉⴳⴰ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3. ⴰⵎⴷⵢⴰ: >>> get_max_triples((5)) (1) ⴰⵙⴼⵔⵓ: a = [1, 3, 7, 13, 21] ⵜⵔⴱⵉⵍⵉⵏ ⵜⵉⴷⵙⵍⴰⵏⵉⵏ ⴷⴰⵢ ⵜⴳⴰ (1, 7, 13).
long get_max_triples(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long get_max_triples(long n) {
    if (n < 3) {
        return 0;
    }
    std::vector<long> a(n);
    for (long i = 0; i < n; ++i) {
        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;
    }

    long count = 0;
    for (long i = 0; i < n; ++i) {
        for (long j = i + 1; j < n; ++j) {
            for (long k = j + 1; k < n; ++k) {
                if ((a[i] + a[j] + a[k]) % 3 == 0) {
                    count++;
                }
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = get_max_triples;
    assert(candidate((5)) == (1));
    assert(candidate((6)) == (4));
    assert(candidate((10)) == (36));
    assert(candidate((100)) == (53361));
}
"
HumanEval/148,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⵍⵍⴰⵏ 8 ⵏ ⵉⵜⵔⴰⵏ ⴳ ⵓⵏⴳⵔⴰⵡ ⵏ ⵜⴰⴼⵓⴽⵜ ⵏⵏⵖ: ⵡⴰⵏⵏⴰ ⵢⵓⴳⵔⵏ ⵉ ⵜⴰⴼⵓⴽⵜ ⵉⴳⴰ ⵎⵉⵔⴽⵓⵔⵉ, ⵡⴰⵏⵏⴰ ⵢⵓⴹⵏ ⵉⴳⴰ ⵡⵉⵏⵓⵙ, ⴷⴼⴼⵉⵔ ⵏ ⵓⵢⴰ ⵉⴳⴰ ⵡⴰⴽⴰⵍ, ⵎⴰⵕⵙ, ⵊⵓⴱⵉⵜⵔ, ⵙⴰⵜⵓⵔⵏ, ⵓⵕⴰⵏⵓⵙ, ⵏⵉⴱⵜⵓⵏ. ⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵉⵙⵎⴰⵡⵏ ⵏ ⵙⵉⵏ ⵉⵜⵔⴰⵏ ⵣⵓⵏⴷ ⵜⵉⵙⵉⵔⴽⴰⵍ ⵉⵜⵔⵉ1 ⴷ ⵉⵜⵔⵉ2. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵢⴰⵜ ⵜⴱⵍⵉⵜ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⴰⴽⴽⵡ ⵉⵜⵔⴰⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⵜⵉⵙⵉⵔⴽⴰⵍ ⵏⵏⵙⵏ ⴳⵔ ⵜⴱⵍⵉⵜ ⵏ ⵉⵜⵔⵉ1 ⴷ ⵜⴱⵍⵉⵜ ⵏ ⵉⵜⵔⵉ2, ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵢⵏ ⵙ ⵜⴰⵎⴰ ⵏ ⵜⴰⴼⵓⴽⵜ. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵢⴰⵜ ⵜⴱⵍⵉⵜ ⵜⴰⵅⵅⴰⵔⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵉⵜⵔⵉ1 ⵏⵖⴷ ⵉⵜⵔⵉ2 ⵉⵙⵎⴰⵡⵏ ⵏ ⵉⵜⵔⴰⵏ ⵉⴽⵓⴷⴰⵏ. ⵉⵎⴷⵢⴰⵜⵏ >>> bf((""ⵊⵓⴱⵉⵜⵔ""), (""ⵏⵢⵓⵏ"") (std::stdstring) ""ⵙⴰⵜⵓⵔⵏ"", (st:dstring) (st: (st:dstring) (Jup ("", (string) (string) ("",
std::vector<std::string> bf(std::string planet1, std::string planet2) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);

    if (it1 == planets.end() || it2 == planets.end()) {
        return {};
    }

    int index1 = std::distance(planets.begin(), it1);
    int index2 = std::distance(planets.begin(), it2);

    if (index1 == index2) {
        return {};
    }

    int start = std::min(index1, index2) + 1;
    int end = std::max(index1, index2);

    std::vector<std::string> result;
    for (int i = start; i < end; ++i) {
        result.push_back(planets[i]);
    }
    return result;
}","}
int main() {
    auto candidate = bf;
    assert(candidate((""Jupiter""), (""Neptune"")) == (std::vector<std::string>({(std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Mercury"")) == (std::vector<std::string>({(std::string)""Venus""})));
    assert(candidate((""Mercury""), (""Uranus"")) == (std::vector<std::string>({(std::string)""Venus"", (std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn""})));
    assert(candidate((""Neptune""), (""Venus"")) == (std::vector<std::string>({(std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Mars""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Jupiter""), (""Makemake"")) == (std::vector<std::string>()));
}
"
HumanEval/149,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⵢⵔⴾⴰⴱ ⵜⴰⵆⴰⵍⵜ ⵜⴰ ⵜⴰⴾⴼⴰ ⵜⴰⵂⵔⵉⴾⵢ ⵏ ⵙⵜⵔⵉⵏⴶ ⵜⴰⵏ ⵛⵂⵓⵏⴷ ⴱⴰⵔⴰⵎⴰⵜⵢⵔ, ⵜⴰⴾⴼⴰ ⵙⵜⵔⵉⵏⴶ ⵜⴰⵏ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⵜⴰⵂⵔⵉⴾⵢ ⵜⵓⵍⴰⵙ ⵜⴰⵔⴰⵓ ⵙⵜⵔⵉⵏⴶ ⵓⴰ ⵢⵓⴰⴷⴰⵏ ⵙ ⴰⵍⴾⴰⴷ ⵉⴾⵏⴰⵏ, ⵙⵜⵔⵉⵏⴶ ⴰⵈⵈⴰⵍ ⵂⴰⵔⴾⵓⴾ ⵙⵜⵔⵉⵏⴶ ⵏ ⵙⵜⵔⵉⵏⴶ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⴾⵓⴷ ⵜⵓⵍⴰⵙ ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⵢⵂⴰⵉ ⴷⵓⴱⵍⵉⵛⴰⵜⵉⵓⵏ ⵜⴰⵏ. ⴰⵍⴾⴰⴷ ⵏ ⵙⵜⵔⵉⵏⴶ ⴰⴷ ⵉⴾⴼⴰ ⵙ ⵜⴰⵂⵔⵉⴾⵢ ⵏ ⴰⵓⴰ ⵙ ⵉⵋⵋⴰ ⴰⵓⵢⵏ, ⵜⵓⵍⴰⵙ ⴰⴷ ⵉⵔⴾⵢ ⵙⵜⵔⵉⵏⴶ ⵙ ⴰⵍⵆⴰⴾⵓⵎⴰⵜ ⵓⵢⵏ. ⴰⵆⴰⴷⴰⵎ ⴰⴷ ⵉⴾⴼⴰ ⵙⵜⵔⵉⵏⴶ ⵏ ⵙⵜⵔⵉⵏⴶ ⵜⴰⵏ ⵙ ⴰⵍⴾⴰⴷ ⵉⴾⵏⴰⵏ. ⴰⵍⵎⵉⵜⴰⵍ: >>> list_sort{""}stdort{""}stdc:string{""}st:std:{""}st:d""{""st:d""a:d""a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a:a
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    std::vector<std::string> even_length_strings;
    for (const std::string& s : lst) {
        if (s.length() % 2 == 0) {
            even_length_strings.push_back(s);
        }
    }

    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {
        if (a.length() != b.length()) {
            return a.length() < b.length();
        }
        return a < b;
    });

    return even_length_strings;
}","}
int main() {
    auto candidate = sorted_list_sum;
    assert(candidate((std::vector<std::string>({(std::string)""aa"", (std::string)""a"", (std::string)""aaa""}))) == (std::vector<std::string>({(std::string)""aa""})));
    assert(candidate((std::vector<std::string>({(std::string)""school"", (std::string)""AI"", (std::string)""asdf"", (std::string)""b""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""asdf"", (std::string)""school""})));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""b"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""dcba"", (std::string)""abcd"", (std::string)""a""}))) == (std::vector<std::string>({(std::string)""abcd"", (std::string)""dcba""})));
    assert(candidate((std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""})));
    assert(candidate((std::vector<std::string>({(std::string)""a"", (std::string)""b"", (std::string)""b"", (std::string)""c"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""aaaa"", (std::string)""bbbb"", (std::string)""dd"", (std::string)""cc""}))) == (std::vector<std::string>({(std::string)""cc"", (std::string)""dd"", (std::string)""aaaa"", (std::string)""bbbb""})));
}
"
HumanEval/150,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵖⴰⵡⴰⵙ ⴰⵎⵙⴷⵓⵙ ⵏⵏⴰ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⴰ ⵡⴰⵜⵉⴳ ⵏ x ⵎⴽ ⵉⴳⴰ n ⴰⵎⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⴰ ⵡⴰⵜⵉⴳ ⵏ y ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵡⴰⵜⵉⴳ ⴰⴷ ⴰⵎⵣⵡⴰⵔⵓ. ⵉⵎⴷⵢⴰⵜⵏ: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)
long x_or_y(long n, long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(long n) {
    if (n <= 1) return false;
    for (long i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

long x_or_y(long n, long x, long y) {
    if (is_prime(n)) {
        return x;
    } else {
        return y;
    }
}","}
int main() {
    auto candidate = x_or_y;
    assert(candidate((7), (34), (12)) == (34));
    assert(candidate((15), (8), (5)) == (5));
    assert(candidate((3), (33), (5212)) == (33));
    assert(candidate((1259), (3), (52)) == (3));
    assert(candidate((7919), (-1), (12)) == (-1));
    assert(candidate((3609), (1245), (583)) == (583));
    assert(candidate((91), (56), (129)) == (129));
    assert(candidate((6), (34), (1234)) == (1234));
    assert(candidate((1), (2), (0)) == (0));
    assert(candidate((2), (2), (0)) == (2));
}
"
HumanEval/151,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵙⴽⵔ ⴰⵙⵎⵓⵜⵜⴳ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵓⵥ ⵏ ⵡⵓⵟⵟⵓⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵓⵔ ⵉⵎⵙⴰⵙⴰⵏ. ⵙⵙⵓⴼⵖ ⵡⵓⵟⵟⵓⵏ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. >>> double_the_difference{(((std::vector<float>({(long) 1, (long) 3, (long) 2, (long) 0}))) (10) >>> double_the_difference{((std::vector<float>{(long)-1, (long)-2, (long) 0}))) (0) >>> double_the_difference{(std::vector<float>{(long) 9, (long) - 2}))) (81) >>> double_the_difference{((std::vector<float>{(long) 0)) (0) ⵎⴽ ⵉⴳⴰ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵣⴳⵡⵣⴳⵡⵣⴳ, ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ 0.
long double_the_difference(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long double_the_difference(std::vector<float> lst) {
    long sum_of_squares = 0;
    for (float num : lst) {
        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {
            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);
        }
    }
    return sum_of_squares;
}","}
int main() {
    auto candidate = double_the_difference;
    assert(candidate((std::vector<float>())) == (0));
    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));
    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));
    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));
    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));
}
"
HumanEval/152,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵆⵓⴷⴷⵢⵗ ⴰⵙ ⵏ ⴰⵜⵜⴰⵔⵢⵆ ⵉⴾⵏⴰⵏ ⴰⵏⵉⴼⵂⴰⵎ ⵓⵢⵏ ⴰⵍⵓⴰⵈ ⵓⴰ ⵉⴷ ⵉⵜⴰⵓⴰⵏ ⴰⵍⵓⴰⵈ ⵓⵢⵏ. ⴰⵍⵓⴰⵈ ⵓⵢⵏ ⵉⴾⵏⴰⵏ ⴰⵙⵉⵎⴰⵏ ⴷ ⴰⵎⵢⴷⵔⴰⵏ ⵓⴰ ⵉⵍⴰⵏ ⴷⴰⵗ ⴰⵍⵓⴰⵈ ⵓⵢⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⴰⵜⵓⴰⵣⴰⵉⴰⵏ ⴰⴷ ⴰⴾⵉⵉⴰⴷ. ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ ⴰⴾⵉⴰⴷ ⴰⵙ ⴰⵓⴰⴷⵉⵎ ⵉⴾⵏⴰⵏ ⴰⵍⵓⴰⵈ ⵓⵢⵏ ⵉⴾⵏⴰⵏ ⴰⵙⵉⵎⴰⵏ ⵏ ⵉⴾⵏⴰⵏ ⵓⵉⵏ ⵉⴾⵏⴰⵏ. ⴰⵜⵓⴰⴾⴼⴰⵏ ⵙⵉⵏ ⴾⵢⵍ ⵓⵉⴷⴰⵋⴰⵏ ⴷ ⵉⴾⵏⴰⵏ ⵓⵉⵏ ⵉⴾⵏⴰⵏ ⵓⵉⴷⴰⵋ ⵓⴰ ⵉⴾⵏⴰⵏ ⴰⵙⵉⵎⴰⵏ. ⴰⵍⵓⴰⵈ ⵓⵢⵏ ⵉⴾⵏⴰⵏ ⴰⵙⵉⵎⴰⵏ ⵓⵢⵏ, ⴰⵍⵈⵉⵎ ⵓⵢⵏ ⵢⵈⵈⴰⵍ 0, ⴷ ⴰⵍⵈⵉⵎ ⵓⵢⵏ ⵓⴰⵔ ⵉⴾⵏⴰⵏ ⴰⵍⵆⵉⴷⵎⴰⵜ ⴰⵎⵓⵙ ⴰⵏⵎⵉⵣⵍⴰⵉ ⵋⵉⵔ ⵉⴾⵏⴰⵏ ⵓⵉⵏ ⵉⴾⵏⴰⵏ ⴷ ⵉⴾⵏⴰⵏ ⴰⵍⵆⵉⴷⵎⴰⵜ. ⴰⵍⵎⵉⵜⴰⵍ: >>> (ⴰⴾⵢⵔⵢⵗ:ⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰⴾⴰ
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    std::vector<long> diff;
    for (size_t i = 0; i < game.size(); ++i) {
        diff.push_back(std::abs(game[i] - guess[i]));
    }
    return diff;
}","}
int main() {
    auto candidate = compare;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));
    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));
}
"
HumanEval/153,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵢⵉⵙⵎ ⵏ ⵜⵔⵎⵉⵜ (ⵜⵔⵎⵉⵜ) ⴷ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵙⵖⵣⵏ. ⵔⴰⴷ ⵜⵜⵓⵙⵎⵔⴰⵙⵏ ⵉⵙⵖⵣⵏⵏ ⴳ ⵓⵙⵙⴽⵛⵎ ⵏ ⵜⵔⵎⵉⵜⵉⵏ ⵢⴰⴹⵏⵉⵏ ⴳ ⵜⵔⵎⵉⵜ. ⵜⴰⴷⵓⵙⵉ ⵏ ⵓⵙⵖⵣⵏ ⵜⴳⴰ ⵣⵓⵏⴷ ⴰⵢⴰⴷ: ⴰⴷ ⵜⴳ CAP ⵓⵟⵟⵓⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵏ, ⴷ ⴰⴷ ⵜⴳ SM ⵓⵟⵟⵓⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵎⵥⵥⵉⵏ ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵏ, ⵜⴰⴷⵓⵙⵉ ⵜⵜⵓⴼⴽⴰ ⵙ ⵜⵔⵎⵉⵜ CAP - SM. ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⴰⵙⵖⵣⵏ ⵉⴷⵓⵙⵏ ⴷ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵜⵔⵎⵉⵜ ⴳ ⵜⵍⵖⴰ ⴰⴷ: ClassName.StrongestExtensionName. ⵉⵖ ⴳⴰⵏ ⵙⵉⵏ ⵉⵙⵖⵣⵏⵏ ⵏ ⵜⵔⵎⵉⵜ ⵉⵎⵎⵣⴰⵔⴰⵢⵏ, ⵔⴰⴷ ⵜⵜⵓⵙⵜⴰⵢⵏ ⵡⴰⵏⵏⴰ ⵉⵜⵜⵓⵣⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ. ⵙ ⵓⵎⴷⵢⴰ, ⵉⵖ ⵜⵜⵓⴼⴽⴰ ""ⵙⵍⴰⵢⵙ"" ⴰⵎⵎⴽⵉⵍ ⴷ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵙⵖⵣⵏ: ['SErviSliNGCes','Cheese', 'Stufed'], 'StuFF' ⴷ ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰⵔ 'Slives.SviSviC'viC'viC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC:SviC
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
","#include<assert.h>
#include<bits/stdc++.h>

int calculate_strength(const std::string& extension) {
    int cap_count = 0;
    int sm_count = 0;
    for (char c : extension) {
        if (isupper(c)) {
            cap_count++;
        } else if (islower(c)) {
            sm_count++;
        }
    }
    return cap_count - sm_count;
}

std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    if (extensions.empty()) {
        return class_name;
    }

    std::string strongest_extension = extensions[0];
    int max_strength = calculate_strength(extensions[0]);

    for (size_t i = 1; i < extensions.size(); ++i) {
        int current_strength = calculate_strength(extensions[i]);
        if (current_strength > max_strength) {
            max_strength = current_strength;
            strongest_extension = extensions[i];
        }
    }

    return class_name + ""."" + strongest_extension;
}","}
int main() {
    auto candidate = Strongest_Extension;
    assert(candidate((""Watashi""), (std::vector<std::string>({(std::string)""tEN"", (std::string)""niNE"", (std::string)""eIGHt8OKe""}))) == (""Watashi.eIGHt8OKe""));
    assert(candidate((""Boku123""), (std::vector<std::string>({(std::string)""nani"", (std::string)""NazeDa"", (std::string)""YEs.WeCaNe"", (std::string)""32145tggg""}))) == (""Boku123.YEs.WeCaNe""));
    assert(candidate((""__YESIMHERE""), (std::vector<std::string>({(std::string)""t"", (std::string)""eMptY"", (std::string)""nothing"", (std::string)""zeR00"", (std::string)""NuLl__"", (std::string)""123NoooneB321""}))) == (""__YESIMHERE.NuLl__""));
    assert(candidate((""K""), (std::vector<std::string>({(std::string)""Ta"", (std::string)""TAR"", (std::string)""t234An"", (std::string)""cosSo""}))) == (""K.TAR""));
    assert(candidate((""__HAHA""), (std::vector<std::string>({(std::string)""Tab"", (std::string)""123"", (std::string)""781345"", (std::string)""-_-""}))) == (""__HAHA.123""));
    assert(candidate((""YameRore""), (std::vector<std::string>({(std::string)""HhAas"", (std::string)""okIWILL123"", (std::string)""WorkOut"", (std::string)""Fails"", (std::string)""-_-""}))) == (""YameRore.okIWILL123""));
    assert(candidate((""finNNalLLly""), (std::vector<std::string>({(std::string)""Die"", (std::string)""NowW"", (std::string)""Wow"", (std::string)""WoW""}))) == (""finNNalLLly.WoW""));
    assert(candidate((""_""), (std::vector<std::string>({(std::string)""Bb"", (std::string)""91245""}))) == (""_.Bb""));
    assert(candidate((""Sp""), (std::vector<std::string>({(std::string)""671235"", (std::string)""Bb""}))) == (""Sp.671235""));
}
"
HumanEval/154,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ 2 ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⵜⴳⴰ ⵜⴳⵓⵔⵉ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⵏⵖ ⴽⵔⴰ ⵏ ⵜⵙⵓⵜⵍⵜ ⵏⵏⵙ ⵜⴰⴳⵓⵔⵉ ⵜⴰⴷⵙⵍⴰⵏⵜ ⴳ ⵜⴳⵓⵔⵉ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ >>> cycpattern_check((""abcd""), (""abd"")) (false) >>> cycpattern_check((""hello""), (""ell"") (true) >>> cycpattern_check(""whassup""), (""psus"")) (false) >>> cycpattern_check(""abab""), (""baa"") (true) >>> cycpattern_(check""efef""), (""eeff"") cy (false) >>> cycpattern_check((""himens""), (""simen"") (true)
bool cycpattern_check(std::string a, std::string b) {
","#include<assert.h>
#include<bits/stdc++.h>

bool cycpattern_check(std::string a, std::string b) {
    if (b.empty()) {
        return true;
    }
    if (a.length() < b.length()) {
        return false;
    }
    for (int i = 0; i < b.length(); ++i) {
        std::rotate(b.begin(), b.begin() + 1, b.end());
        if (a.find(b) != std::string::npos) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = cycpattern_check;
    assert(candidate((""xyzw""), (""xyw"")) == (false));
    assert(candidate((""yello""), (""ell"")) == (true));
    assert(candidate((""whattup""), (""ptut"")) == (false));
    assert(candidate((""efef""), (""fee"")) == (true));
    assert(candidate((""abab""), (""aabb"")) == (false));
    assert(candidate((""winemtt""), (""tinem"")) == (true));
}
"
HumanEval/155,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ, ⴷⵔⵓⵏ ⵜⴰⴱⵍⵜ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵎⵓⴹⵉⵏ ⴷ ⵉⵎⵎⵓⴹⵉⵏ ⵙ ⵓⵎⵣⴰⵔⴰⵢ. ⴰⵎⴷⵢⴰ: >>> even_odd_count((-12)) (std::make_tuple(1, 1)) >>> even_odd_count((123)) (std::make_tuple(1, 2)
std::tuple<long, long> even_odd_count(long num) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<tuple>

std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0;
    long odd_count = 0;
    std::string s = std::to_string(std::abs(num));
    for (char c : s) {
        int digit = c - '0';
        if (digit % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
    }
    return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_count;
    assert(candidate((7)) == (std::make_tuple(0, 1)));
    assert(candidate((-78)) == (std::make_tuple(1, 1)));
    assert(candidate((3452)) == (std::make_tuple(2, 2)));
    assert(candidate((346211)) == (std::make_tuple(3, 3)));
    assert(candidate((-345821)) == (std::make_tuple(3, 3)));
    assert(candidate((-2)) == (std::make_tuple(1, 0)));
    assert(candidate((-45347)) == (std::make_tuple(2, 3)));
    assert(candidate((0)) == (std::make_tuple(1, 0)));
}
"
HumanEval/156,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ, ⴷⴷⵓ ⵏ ⵓⴽⵙⴰⵢ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵕⵓⵎⵉⵢⵏ ⴰⵎⵎ ⵜⴰⴳⵔⵓⵎⵎⴰ, ⴷ ⵙⵙⵓⴼⵖ ⵙ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ. ⵜⵉⵎⵥⴰⴳⵉⵏ: 1 <= num <= 1000 ⵉⵎⴷⵢⴰⵜⵏ: >>> int_to_mini_roman((19)) (""xix"") >>> int_to_mini_roman((152)) (""clii"") >>> int_to_mini_roman(426)) (""cdxxvi"")
std::string int_to_mini_roman(long number) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string int_to_mini_roman(long number) {
    std::string roman = """";
    std::vector<std::pair<int, std::string>> roman_map = {
        {1000, ""m""}, {900, ""cm""}, {500, ""d""}, {400, ""cd""}, {100, ""c""},
        {90, ""xc""}, {50, ""l""}, {40, ""xl""}, {10, ""x""}, {9, ""ix""}, {5, ""v""},
        {4, ""iv""}, {1, ""i""}
    };

    for (const auto& pair : roman_map) {
        while (number >= pair.first) {
            roman += pair.second;
            number -= pair.first;
        }
    }
    return roman;
}","}
int main() {
    auto candidate = int_to_mini_roman;
    assert(candidate((19)) == (""xix""));
    assert(candidate((152)) == (""clii""));
    assert(candidate((251)) == (""ccli""));
    assert(candidate((426)) == (""cdxxvi""));
    assert(candidate((500)) == (""d""));
    assert(candidate((1)) == (""i""));
    assert(candidate((4)) == (""iv""));
    assert(candidate((43)) == (""xliii""));
    assert(candidate((90)) == (""xc""));
    assert(candidate((94)) == (""xciv""));
    assert(candidate((532)) == (""dxxxii""));
    assert(candidate((900)) == (""cm""));
    assert(candidate((994)) == (""cmxciv""));
    assert(candidate((1000)) == (""m""));
}
"
HumanEval/157,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵉⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⴽⵕⴰⴹⵜ ⵜⵉⴳⵎⵉⵍⵉⵏ. ⴷⴰ ⵜⵜⵓⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⴽⵕⴰⴹⵜ ⵜⵉⴳⵎⵉⵍⵉⵏ ⵜⵉⴷⵙⵜ, ⵜⵉⴽⵕⴹⵉ ⵎⴽ ⵓⵔ ⵉⴳⵉ. ⴽⵕⴰⴹⵜ ⵜⵉⴳⵎⵉⵍⵉⵏ ⵜⵉⴷⵙⵜ ⵜⴳⴰ ⴽⵕⴰⴹⵜ ⵜⵉⴳⵎⵉⵍⵉⵏ ⴳ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴽⵡⵜⴰⵢ ⵏ ⵜⵥⵍⴰⵢⵜ ⵏⵖⴷ 90 ⵏ ⵜⵙⴽⵡⴼⵍⵜ. ⴰⵎⴷⵢⴰ: >>> right_angle_triangle((3), (4), (5)) (true) >>> right_angle_triangle(1), (2), (3)) (false)
bool right_angle_triangle(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>

bool right_angle_triangle(long a, long b, long c) {
    std::vector<long> sides = {a, b, c};
    std::sort(sides.begin(), sides.end());
    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);
}","}
int main() {
    auto candidate = right_angle_triangle;
    assert(candidate((3), (4), (5)) == (true));
    assert(candidate((1), (2), (3)) == (false));
    assert(candidate((10), (6), (8)) == (true));
    assert(candidate((2), (2), (2)) == (false));
    assert(candidate((7), (24), (25)) == (true));
    assert(candidate((10), (5), (7)) == (false));
    assert(candidate((5), (12), (13)) == (true));
    assert(candidate((15), (8), (17)) == (true));
    assert(candidate((48), (55), (73)) == (true));
    assert(candidate((1), (1), (1)) == (false));
    assert(candidate((2), (2), (10)) == (false));
}
"
HumanEval/158,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⵢⵔⴾⴰⴱ ⵜⴰⵆⴰⵍⵜ ⵜⴰ ⵜⴰⴾⴼⴰ ⵜⴰⴾⴰⵍⵜ ⵏ ⵜⵉⴼⵢⵔ ⵜⴰⵏ. ⵜⵉⴼⵢⵔ ⵜ ⴰⵂⴰⵏ ⵜⵉⴼⵢⵔ ⵜⴰⵏ ⴰⵋⵋⵓⵜⵏⵢⵏ. ⵢⵔⵢⵜⵔⵢ ⵓⴰ ⵉⵍⴰⵏ ⴰⵍⵎⴰⵗⵏⴰ ⵜⴰⵏ ⴰⵋⵋⵓⵜⵏⵢⵏ. ⴰ ⴼⴰⵍ ⵜⵉⴼⵢⵔ ⵜⴰⵏ ⴰⵋⵋⵓⵜⵏⵢⵏ ⵉⵍⴰⵏ ⴰⵍⵎⴰⵗⵏⴰ ⵜⴰⵏ ⵓⵉⵏ ⴰⵋⵋⵓⵜⵏⵢⵏ, ⵢⵔⵢⵜⵔⵢ ⵓⴰ ⵢⵣⵣⴰⵔⴰⵏ ⴷⴰⵗ ⴰⵍⵎⴰⵗⵏⴰ ⵏ ⴰⵍⵎⴰⵗⵏⴰ ⵜⴰⵏ. >>>ⴰⴼ_ⵎⵆ""
std::string find_max(std::vector<std::string> words) {
","#include<assert.h>
#include<bits/stdc++.h>

int count_unique_chars(const std::string& s) {
    std::set<char> unique_chars;
    for (char c : s) {
        unique_chars.insert(c);
    }
    return unique_chars.size();
}

std::string find_max(std::vector<std::string> words) {
    if (words.empty()) {
        return """";
    }

    std::string max_unique_word = words[0];
    int max_unique_count = count_unique_chars(words[0]);

    for (size_t i = 1; i < words.size(); ++i) {
        int current_unique_count = count_unique_chars(words[i]);
        if (current_unique_count > max_unique_count) {
            max_unique_count = current_unique_count;
            max_unique_word = words[i];
        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {
            max_unique_word = words[i];
        }
    }
    return max_unique_word;
}","}
int main() {
    auto candidate = find_max;
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""of"", (std::string)""string""}))) == (""string""));
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""enam"", (std::string)""game""}))) == (""enam""));
    assert(candidate((std::vector<std::string>({(std::string)""aaaaaaa"", (std::string)""bb"", (std::string)""cc""}))) == (""aaaaaaa""));
    assert(candidate((std::vector<std::string>({(std::string)""abc"", (std::string)""cba""}))) == (""abc""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""this"", (std::string)""game"", (std::string)""of"", (std::string)""footbott""}))) == (""footbott""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""gonna"", (std::string)""rock""}))) == (""gonna""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""a"", (std::string)""mad"", (std::string)""nation""}))) == (""nation""));
    assert(candidate((std::vector<std::string>({(std::string)""this"", (std::string)""is"", (std::string)""a"", (std::string)""prrk""}))) == (""this""));
    assert(candidate((std::vector<std::string>({(std::string)""b""}))) == (""b""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""play"", (std::string)""play""}))) == (""play""));
}
"
HumanEval/159,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵀⴰⵜ ⴷⵉⵛⵛⵉⵛⵉⵛ, ⴷⵉⵛⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉⵛⵉ
std::vector<long> eat(long number, long need, long remaining) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> eat(long number, long need, long remaining) {
    long eaten = 0;
    long left = remaining;
    long to_eat = need;

    if (left >= to_eat) {
        eaten = to_eat;
        left -= to_eat;
    } else {
        eaten = left;
        left = 0;
    }

    return {(long)number + eaten, left};
}","}
int main() {
    auto candidate = eat;
    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));
    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));
    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));
    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));
    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));
    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));
}
"
HumanEval/160,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵎⵙⵙⵉⴳⴳⴰⵍⵏ ⴷ ⵓⵎⵙⵡⵓⵔⵉ. ⴰⵎⵙⵙⵉⴳⴳⴰⵍ ⴰⵎⵣⵡⴰⵔⵓ ⴷⴰⵔⵙ ⵜⵉⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ ⵜⵉⴷⵙⵍⴰⵏⵉⵏ, ⴷ ⵓⵎⵙⵙⵉⴳⴳⵍ ⵡⵉⵙⵙ ⵙⵉⵏ ⵉⴳⴰ ⴰⵎⵙⵙⵉⴳⴳⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙⵙⵎⵔⴰⵙ ⵙⵉⵏ ⵉⵎⵙⵙⵉⴳⴳⴰⵍⵏ ⵉⵜⵜⵓⴼⴽⴰⵏ ⴰⴼⴰⴷ ⴰⴷ ⵜⴱⵏⵓ ⵜⴼⵔⵉⵜ ⵏ ⵍⵊⵉⴱⵔ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵖⵜⴰⵙⵜ ⵏ ⵜⴼⵔⵉⵜ ⴰⴷ. ⵜⵉⵎⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ ⵜⵉⴷⵙⵍⴰⵏⵉⵏ: ⴰⵙⵎⵓⵏ (+) ⴰⵙⵏⵣⴳⵉ (-) ⴰⵙⵎⵓⵟⵟⵓⵏ (*) ⵜⴰⴱⵟⵟⵓⵜ ⵏ ⵡⴰⵍⵍⴰⵍ (//) ⴰⵙⵎⵓⵟⵟⵓⵏ (**) ⴰⵎⴷⵢⴰ: ⴰⵎⵙⵙⵉⴳⴳⴰⵍ['+', '*', '-'] ⵓⵎⵙⵙⵉⴳⴳⵍ = [2, 3, 4, 5] ⵜⵢⴰⴼⵓⵜ = 2 + 3 * 4 - 5 => ⵜⵢⴰⴼⵓⵜ = 9 ⵜⴰⵏⵏⴰⵢⵜ: ⵜⵉⵖⵣⵉ ⵏ ⵓⵎⵙⵙⵉⴳⴳⴰⵍ ⴰⵎⵙⵙⵉⴳⴳⵍ ⵉⴳⴰ ⴰⵎⵙⵉⴳⴳⵍ ⵏ ⵓⵎⵙⵙⵉⴳⴳⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⴳⵉⴳⴳⴰⵍⵏ. ⴰⵎⵙⵙⵉⴳⴳⴰⵍ ⴰⵎⵙⵙⵉⴳⴳⴰⵍ ⴷⴰⵔⵙⵉⴳⴳⴰⵍ ⴷⴰⵔⵙ ⵢⴰⵏ ⵓⵎⵙⵙⵉⴳⴳⵍ, ⴷ ⵓⵎⵙⵙⵉⴳⴳⴰⵍ ⴰⵎⵙⵙⵉⴳⴳⴰⵍ ⴷⴰⵔⵙⵉⴳⴳⴰⵍ ⴷⴰⵔⵙⵉⴳⴳⴰⵍ ⵙ ⵙⵉⵏ ⵉⵎⵏⴰⵡ ⵏ ⵉⵎⵙⵙⵉⴳⴳⴰⵍⵏⵏⴰⵡⵉⵏ ⵉⵎⵙⵙⵉⴳⴳⴰⵍⵏⵣⵉⵏ.
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
","#include<assert.h>
#include<bits/stdc++.h>

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    std::vector<long> current_operand = operand;
    std::vector<std::string> current_operator = op;

    auto apply_op = [&](long a, long b, const std::string& o) {
        if (o == ""+"") return a + b;
        if (o == ""-"") return a - b;
        if (o == ""*"") return a * b;
        if (o == ""//"") return a / b;
        if (o == ""**"") return static_cast<long>(pow(a, b));
        return 0L; // Should not happen
    };

    std::vector<std::string> precedence1 = {""**""};
    std::vector<std::string> precedence2 = {""*"", ""//""};
    std::vector<std::string> precedence3 = {""+"", ""-""};

    auto evaluate = [&](const std::vector<std::string>& prec) {
        size_t i = 0;
        while (i < current_operator.size()) {
            bool found = false;
            for (const auto& o : prec) {
                if (current_operator[i] == o) {
                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);
                    current_operand.erase(current_operand.begin() + i + 1);
                    current_operator.erase(current_operator.begin() + i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                i++;
            }
        }
    };

    evaluate(precedence1);
    evaluate(precedence2);
    evaluate(precedence3);

    return current_operand[0];
}","}
int main() {
    auto candidate = do_algebra;
    assert(candidate((std::vector<std::string>({(std::string)""**"", (std::string)""*"", (std::string)""+""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));
    assert(candidate((std::vector<std::string>({(std::string)""+"", (std::string)""*"", (std::string)""-""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));
    assert(candidate((std::vector<std::string>({(std::string)""//"", (std::string)""*""})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));
}
"
HumanEval/161,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ s. ⵉⵖ ⵉⴳⴰ s[i] ⴰⵙⴽⴽⵉⵍ, ⵙⵙⵓⵜⵔ ⵜⴰⵖⴰⵔⴰⵙⵜ ⵏⵏⵙ ⵙⴳ ⴷⴷⴰⵡ ⴰⵔ ⴰⴼⵍⵍⴰ ⵏⵖⴷ ⵙ ⵓⴱⵔⴰⵔ, ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵀⴰⵜ ⵃⴹⵓ ⵖⵉⴽⵍⵍⵉ ⵉⴳⴰ. ⵉⵖ ⵓⵔ ⵉⵍⵍⵉ ⴳ ⵓⴽⵛⵛⵓⵎ ⴽⵔⴰ ⵏ ⵉⵙⴽⴽⵉⵍⵏ, ⵙⵙⵓⵜⵔ ⵉⴽⵛⵛⵓⵎⵏ. ⵇⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ ⵜⴰⴽⵛⵛⵓⵎⵜ ⵉⵜⵜⵓⵢⴰⴼⴰ. ⵉⵎⴷⵢⴰⵜⵏ >>> ⵙⵙⵓⵜⵔ ((((""1234"")) (""4321"") >>> ⵙⵙⵓⵜⵔ (((""ab"")) (""AB"") >>> ⵙⵙⵓⵜⵔ (((""#a@C"")) (""#A@c"")
std::string solve(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string solve(std::string s) {
    bool has_letter = false;
    for (char c : s) {
        if (isalpha(c)) {
            has_letter = true;
            break;
        }
    }

    if (has_letter) {
        for (char& c : s) {
            if (islower(c)) {
                c = toupper(c);
            } else if (isupper(c)) {
                c = tolower(c);
            }
        }
    } else {
        std::reverse(s.begin(), s.end());
    }
    return s;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((""AsDf"")) == (""aSdF""));
    assert(candidate((""1234"")) == (""4321""));
    assert(candidate((""ab"")) == (""AB""));
    assert(candidate((""#a@C"")) == (""#A@c""));
    assert(candidate((""#AsdfW^45"")) == (""#aSDFw^45""));
    assert(candidate((""#6@2"")) == (""2@6#""));
    assert(candidate((""#$a^D"")) == (""#$A^d""));
    assert(candidate((""#ccc"")) == (""#CCC""));
}
"
HumanEval/162,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⴳ ⵜⵍⵍⴰ ⵜⵣⵔⵉⴳⵜ 'text', ⵙⵓⵍ ⴰⵖ ⵜⵙⵙⴽⵛⵎ ⵜⴰⵣⵔⵉⴳⵜ ⵏ ⵓⵃⴰⵛⴰⵢ md5 ⵏⵏⵙ. ⵎⴽ ⵜⴳⴰ ⵜⵣⵔⵉⴳⵜ 'text' ⵜⴰⵣⵔⵉⴳⵜ ⵜⴰⵅⵅⴰⵔⵜ, ⵙⵓⵍ ⴰⵖ ⵓⵔ ⵜⵙⵙⴽⵛⵎ. >>> string_to_md5(((""Hello world"")) ""3e25960a79dbc69b674cd4ec67a72c62""
std::optional<std::string> string_to_md5(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>
#include <optional>

#include <openssl/md5.h>
#include <iomanip>
#include <sstream>

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return std::nullopt;
    }

    unsigned char digest[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), digest);

    std::stringstream ss;
    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];
    }
    return ss.str();
}","}
int main() {
    auto candidate = string_to_md5;
    assert(candidate((""Hello world"")) == ""3e25960a79dbc69b674cd4ec67a72c62"");
    assert(candidate(("""")) == std::nullopt);
    assert(candidate((""A B C"")) == ""0ef78513b0cb8cef12743f5aeb35f888"");
    assert(candidate((""password"")) == ""5f4dcc3b5aa765d61d8327deb882cf99"");
}
"
HumanEval/163,taq_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⵓⴷⵏ a ⴷ b, ⵙⵙⴽⵛⵎ ⵉⵎⴹⴰⵏ ⵉⵎⵎⵔⴽⵙⵏ ⴳⵔ a ⴷ b, ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵇⵔⴰⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> generate_integers((2), (8)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((8), (2)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers::(10), (14)) (std::vector<long>())
std::vector<long> generate_integers(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    long start = std::min(a, b);
    long end = std::max(a, b);
    for (long i = start; i <= end; ++i) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;
}","}
int main() {
    auto candidate = generate_integers;
    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((17), (89)) == (std::vector<long>()));
}
"
