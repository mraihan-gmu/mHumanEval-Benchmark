[
    {
        "task_id": "HumanEval/0",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"প্রদত্ত সংখ্যার তালিকায়, প্রদত্ত প্রান্তিকের চেয়ে অন্য দুটি সংখ্যা একে অপরের কাছাকাছি রয়েছে কিনা তা পরীক্ষা করুন। উদাহরণঃ >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) মিথ্যা >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) সত্য \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"এই ফাংশনের ইনপুট হল একটি স্ট্রিং যা নেস্টেড বন্ধনীগুলির একাধিক গ্রুপ ধারণ করে। আপনার লক্ষ্য হল সেই গ্রুপগুলিকে পৃথক স্ট্রিংগুলিতে আলাদা করা এবং সেগুলির তালিকাটি ফেরত দেওয়া। পৃথক গ্রুপগুলি ভারসাম্যযুক্ত (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ থাকে) এবং একে অপরের মধ্যে নেস্টেড নয় ইনপুট স্ট্রিংয়ের কোনও স্থান উপেক্ষা করুন। উদাহরণঃ >>> separate_paren_groups'(( ) (() (( ) ) ) ) ) ) ' (,') ', ' ()) ', ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()) ' ()))) ' ()))) ' ()))))) ' ())))))))))\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"একটি ধনাত্মক ভাসমান বিন্দুর সংখ্যা দেওয়া হলে, এটি একটি পূর্ণসংখ্যা অংশে (প্রদত্ত সংখ্যার চেয়ে বৃহত্তম পূর্ণসংখ্যা ছোট) এবং দশমিকগুলিতে (বাকি অংশটি সর্বদা 1 এর চেয়ে ছোট) বিভক্ত করা যেতে পারে। সংখ্যার দশমিক অংশটি ফেরত দিন। উদাহরণঃ >>> truncate_number ((3.5) 0.5 \"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"আপনাকে একটি ব্যাংক অ্যাকাউন্টে জমা এবং উত্তোলন ক্রিয়াকলাপের একটি তালিকা দেওয়া হয় যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। আপনার কাজটি হ'ল কোনও সময়ে অ্যাকাউন্টের ব্যালেন্স শূন্যের নীচে পড়ে কিনা তা সনাক্ত করা এবং সেই সময়ে ফাংশনটি সত্য ফিরে আসা উচিত। অন্যথায় এটি মিথ্যা ফিরে আসা উচিত। উদাহরণঃ >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"ইনপুট সংখ্যাগুলির একটি প্রদত্ত তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি গণনা করুন। গড় পরম বিচ্যুতি প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দু (এই ক্ষেত্রে গড়) এর মধ্যে গড় পরম পার্থক্যঃ এমএডি = গড় । x - x_mean । উদাহরণঃ >>> mean_absolute_deviation (([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"ইনপুট তালিকার প্রতিটি দুটি পরপর উপাদানগুলির মধ্যে একটি সংখ্যা 'ডিমিটার' সন্নিবেশ করান `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"এই ফাংশনের ইনপুট হল একটি স্ট্রিং যা স্পেস দ্বারা পৃথক করা বন্ধনীগুলির জন্য একাধিক গ্রুপের প্রতিনিধিত্ব করে। প্রতিটি গ্রুপের জন্য, বন্ধনীগুলির নিস্তেজকরণের গভীরতম স্তরটি আউটপুট করুন। উদাহরণস্বরূপ (() (()) এর সর্বাধিক দুটি স্তরের নেস্টিং রয়েছে যখন ((())) এর তিনটি রয়েছে। >>> parse_nested_parens('((()) ((())) () (((()) (((()) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"একটি ইনপুট স্ট্রিং তালিকা ফিল্টার করুন শুধুমাত্র সেইগুলির জন্য যা প্রদত্ত সাবস্ট্রিং >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"পূর্ণসংখ্যার একটি তালিকা প্রদানের জন্য, একটি তালিকার সমস্ত পূর্ণসংখ্যার একটি যোগফল এবং একটি পণ্যের সমন্বয়ে একটি টিউপেল ফেরত দিন। খালি যোগফল 0 এর সমান হওয়া উচিত এবং খালি পণ্য 1 এর সমান হওয়া উচিত। >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) ।\"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"পূর্ণসংখ্যার একটি প্রদত্ত তালিকা থেকে, ক্রমের প্রদত্ত মুহুর্ত পর্যন্ত পাওয়া রোলিং সর্বোচ্চ উপাদানগুলির একটি তালিকা তৈরি করুন। >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"একটি প্রদত্ত স্ট্রিং দিয়ে শুরু হওয়া সবচেয়ে ছোট প্যালিনড্রোমটি সন্ধান করুন। অ্যালগরিদম ধারণাটি সহজঃ - প্রদত্ত স্ট্রিংয়ের দীর্ঘতম পোস্টফিক্সটি সন্ধান করুন যা একটি প্যালিনড্রোম। - স্ট্রিংয়ের শেষে একটি স্ট্রিং উপসর্গটির বিপরীতটি সংযুক্ত করুন যা প্যালিনড্রোমিক প্রত্যয়ের আগে আসে। >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('catac') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"প্রদত্ত স্ট্রিংটি যদি প্যালিনড্রোম হয় তবে পরীক্ষা করুন \"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"ইনপুট দুটি স্ট্রিং a এবং b যা শুধুমাত্র 1 এবং 0 এর সমন্বয়ে গঠিত। এই ইনপুটগুলিতে বাইনারি এক্সওআর সম্পাদন করুন এবং ফলাফলটি একটি স্ট্রিং হিসাবেও ফেরত দিন। >>> string_xor('010', '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"স্ট্রিংয়ের তালিকা থেকে, দীর্ঘতমটি ফেরত দিন। একই দৈর্ঘ্যের একাধিক স্ট্রিংয়ের ক্ষেত্রে প্রথমটি ফেরত দিন। ইনপুট তালিকা খালি থাকলে None ফেরত দিন। >>> দীর্ঘতম (([]) >>> দীর্ঘতম ((['a', 'b', 'c']) 'a' >>> দীর্ঘতম ((['a', 'bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"দুটি পূর্ণসংখ্যার a এবং b এর বৃহত্তম সাধারণ বিভাজককে ফেরত দিন >>> বৃহত্তম_সাধারণ_বিভাজক ((3, 5) 1 >>> বৃহত্তম_সাধারণ_বিভাজক ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"ইনপুট স্ট্রিং এর সবকটি প্রিফিক্সের তালিকা ফেরত দিন >>> all_prefixes (('abc') ['a', 'ab', 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"একটি স্ট্রিং প্রদান করে যার মধ্যে 0 থেকে শুরু করে n পর্যন্ত স্থান-সীমাবদ্ধ সংখ্যা রয়েছে। >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"একটি স্ট্রিং দেওয়া, কতগুলি স্বতন্ত্র অক্ষর (কেস নির্বিশেষে) এটি >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"এই ফাংশন ইনপুট একটি বিশেষ ASCII বিন্যাসে বাদ্যযন্ত্রের নোট প্রতিনিধিত্বকারী একটি স্ট্রিং হয়. আপনার কাজ হল অনেক বিট অনুরূপ পূর্ণসংখ্যা স্ট্রিং তালিকা পার্স করা হয় না. এখানে একটি কিংবদন্তি হলঃ 'ও' নোট, শেষ চার বিট 'ও' - অর্ধ নোট, শেষ দুই বিট 'ও' - quater নোট, শেষ এক বিট >>> parse_music. 'ও' ও 'ও' . . ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' ও 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও' 'ও\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"মূল স্ট্রিংয়ে একটি প্রদত্ত সাবস্ট্রিং কতবার পাওয়া যায় তা সন্ধান করুন। ওভারল্যাপিং কেসগুলি গণনা করুন। >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"ইনপুট হল 'শূন্য' থেকে 'নয়' পর্যন্ত সংখ্যার একটি স্থান-সীমাবদ্ধ স্ট্রিং। বৈধ পছন্দগুলি হল 'শূন্য', 'এক', 'দুই', 'তিন', 'চার', 'পাঁচ', 'ছয়', 'সাত', 'আট' এবং 'নয়'। সংখ্যার সাথে স্ট্রিংটি ছোট থেকে বৃহত্তম >>> sort_numbers (('তিন এক পাঁচ') 'এক তিন পাঁচ' দিয়ে সাজানো ফেরত দিন \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"সংখ্যাগুলির একটি সরবরাহিত তালিকা থেকে (দৈর্ঘ্যের কমপক্ষে দুটি) দুটি নির্বাচন করুন এবং দুটি ফেরত দিন যা একে অপরের নিকটতম এবং তাদের ক্রমে ফেরত দিন (ছোট সংখ্যা, বৃহত্তর সংখ্যা) । >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"সংখ্যার তালিকা দেওয়া (অন্তত দুটি উপাদানের), সেই তালিকায় একটি রৈখিক রূপান্তর প্রয়োগ করুন, যাতে ক্ষুদ্রতম সংখ্যাটি 0 হয়ে যায় এবং বৃহত্তমটি 1 হয়ে যায় >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"ফিল্টার প্রদত্ত তালিকা যে কোন পাইথন মান শুধুমাত্র পূর্ণসংখ্যা জন্য >>> ফিল্টার_ইন্টারজার্স ((['a', 3.14, 5]) [5] >>> ফিল্টার_ইন্টারজার্স (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"প্রদত্ত স্ট্রিং এর রিটার্ন দৈর্ঘ্য >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"একটি প্রদত্ত সংখ্যা n এর জন্য, সবচেয়ে বড় সংখ্যাটি খুঁজে বের করুন যা n কে সমানভাবে ভাগ করে, n এর চেয়ে ছোট >>> বৃহত্তম_বিভাজক ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"প্রদত্ত পূর্ণসংখ্যার প্রধান গুণকগুলির তালিকা ছোট থেকে বড় পর্যন্ত অর্ডার করে ফেরত দিন। প্রতিটি কারণের সংখ্যাটি কতবার ফ্যাক্টরাইজেশনে উপস্থিত হয় তার সাথে সামঞ্জস্যপূর্ণ হওয়া উচিত। ইনপুট নম্বরটি সমস্ত কারণের পণ্যের সমান হওয়া উচিত >>> ফ্যাক্টরাইজ করুন ((8) [2, 2, 2] >>> ফ্যাক্টরাইজ করুন ((25) [5, 5] >>> ফ্যাক্টরাইজ করুন ((70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"পূর্ণসংখ্যার তালিকা থেকে, একবারের বেশি উপস্থিত সমস্ত উপাদান সরান। উপাদানগুলির ক্রম ইনপুট হিসাবে একই রাখুন। >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"একটি প্রদত্ত স্ট্রিং এর জন্য, ছোট অক্ষরকে বড় অক্ষরে এবং বড় অক্ষরকে ছোট অক্ষরে ফ্লিপ করুন। >>> flip_case ((('Hello') 'HELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"একক স্ট্রিংয়ে স্ট্রিংগুলির তালিকা সংযুক্ত করুন >>> concatenate([]) '' >>> concatenate(['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"একটি প্রদত্ত উপসর্গ দিয়ে শুরু হওয়া স্ট্রিংগুলির জন্য কেবলমাত্র একটি ইনপুট স্ট্রিংয়ের তালিকা ফিল্টার করুন। >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"তালিকা থেকে শুধুমাত্র ধনাত্মক সংখ্যা ফেরত দিন। >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"প্রদত্ত সংখ্যাটি যদি অগ্রিম হয় তবে সত্য এবং অন্যথায় মিথ্যা ফেরত দিন। >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs একটি বহুপদ এর সহগ. find_zero find x such that poly(x) = 0. find_zero শুধুমাত্র শুধুমাত্র শূন্য বিন্দু ফেরত দেয়, এমনকি যদি অনেকগুলি থাকে। উপরন্তু, find_zero শুধুমাত্র তালিকা xs গ্রহণ করে যার সমসংখ্যার সংখ্যা এবং বৃহত্তম অ-শূন্য সহগ রয়েছে কারণ এটি একটি সমাধানের গ্যারান্টি দেয়। >>> বৃত্তাকার (((find_zero[1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> বৃত্তাকার (((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"xs বিন্দুতে xs সহগ সহ বহুপদকে মূল্যায়ন করে। xs[0] + xs [1] * x + xs [1] * x ^ 2 + .... xs [n] * x ^ n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"এই ফাংশনটি একটি তালিকা l নেয় এবং একটি তালিকা l' ফেরত দেয় যাতে l' সূচকগুলির মধ্যে l এর সাথে একই হয় যা তিন দ্বারা বিভক্ত নয়, যখন তিনটি দ্বারা বিভক্ত সূচকগুলির মানগুলি l এর সংশ্লিষ্ট সূচকের মানগুলির সমান, তবে সাজানো হয়। >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"একটি তালিকার সাজানো অনন্য উপাদানগুলিকে ফেরত দিন >>> অনন্য (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"তালিকা থেকে সর্বোচ্চ উপাদান ফেরত দিন। >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"n এর চেয়ে কম সংখ্যক পূর্ণসংখ্যায় 7 এর সংখ্যাটি ফেরত দিন যা 11 বা 13 দ্বারা বিভাজ্য। >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"এই ফাংশনটি একটি তালিকা l নেয় এবং একটি তালিকা l' ফেরত দেয় যাতে l' অদ্ভুত সূচকগুলিতে l এর সাথে একই হয়, যখন এমনকি সূচকগুলিতে এর মানগুলি l এর এমনকি সূচকগুলির মানগুলির সমান হয় তবে সাজানো হয়। >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"ইনপুট স্ট্রিং হিসাবে এনকোড_সাইক্লিক ফাংশন দিয়ে এনকোড করা হয়। ডিকোড স্ট্রিং ফেরত দেয়। \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"তিন অক্ষরের চক্রীয় গ্রুপ দ্বারা এনকোডযুক্ত স্ট্রিং প্রদান করে।\"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib n-তম সংখ্যা প্রদান করে যা একটি ফিবোনাচি সংখ্যা এবং এটিও একটি প্রধান। >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero একটি পূর্ণসংখ্যার তালিকাকে ইনপুট হিসাবে গ্রহণ করে। এটি সত্য ফেরত দেয় যদি তালিকায় তিনটি স্বতন্ত্র উপাদান থাকে যা শূন্যের সমষ্টি হয় এবং অন্যথায় মিথ্যা। >>> triples_sum_to_zero([1, 3, 5, 0]) মিথ্যা >>> triples_sum_to_zero[(1, 3, -2, 1]) সত্য >>> triples_sum_to_zero([1, 2, 3, 7]) মিথ্যা >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) সত্য >>> triples_sum_to_zero[1]) মিথ্যা \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"একটি রাস্তা কল্পনা করুন যা একটি নিখুঁত সোজা অসীম দীর্ঘ লাইন। n গাড়ি বাম থেকে ডানে চলছে; একই সাথে, n গাড়িগুলির একটি ভিন্ন সেট ডান থেকে বামে চলছে। গাড়িগুলির দুটি সেট একে অপরের থেকে খুব দূরে শুরু হয়। সমস্ত গাড়ি একই গতিতে চলে। দুটি গাড়িকে বলা হয় যে যখন বাম থেকে ডানে চলাচলকারী গাড়িটি ডান থেকে বামে চলাচলকারী গাড়িকে আঘাত করে তখন দুটি গাড়ি সংঘর্ষ করে। তবে গাড়িগুলি অসীম দৃঢ় এবং শক্তিশালী; ফলস্বরূপ, তারা তাদের গতিপথের সাথে চলাচল চালিয়ে যায় যেন তারা সংঘর্ষ করে না। এই ফাংশনটি এই জাতীয় সংঘর্ষের সংখ্যা প্রকাশ করে। \"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"১ দ্বারা বর্ধিত উপাদানগুলির সাথে তালিকা ফেরত দিন। >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] \"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero একটি পূর্ণসংখ্যার তালিকাকে ইনপুট হিসাবে গ্রহণ করে। এটি সত্য ফেরত দেয় যদি তালিকায় দুটি স্বতন্ত্র উপাদান থাকে যা শূন্যের সমষ্টি হয় এবং অন্যথায় মিথ্যা। >>> pairs_sum_to_zero (([1, 3, 5, 0]) মিথ্যা >>> pairs_sum_to_zero (([1, 3, -2, 1]) মিথ্যা >>> pairs_sum_to_zero (([1, 2, 3, 7]) মিথ্যা >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) সত্য >>> pairs_sum_to_zero ([1, 3, 5]) মিথ্যা \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"ইনপুট সংখ্যা x এর সংখ্যাসূচক ভিত্তিকে ভিত্তিতে পরিবর্তন করুন। রূপান্তর করার পরে স্ট্রিং উপস্থাপনা ফেরত দিন। বেস সংখ্যা 10 এর চেয়ে কম। >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"একটি ত্রিভুজের জন্য একটি পাশের দৈর্ঘ্য এবং উচ্চ প্রত্যাবর্তন ক্ষেত্র। >>> triangle_area ((5, 3) 7.5 \"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Fib4 সংখ্যা ক্রমটি Fibbonacci sequence এর অনুরূপ একটি ক্রম যা নিম্নরূপ সংজ্ঞায়িত করা হয়: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). fib4 সংখ্যা ক্রমের n-তম উপাদানকে দক্ষতার সাথে গণনা করার জন্য একটি ফাংশন লিখুন। পুনরাবৃত্তি ব্যবহার করবেন না। >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"তালিকা l. >>> মধ্যম (([3, 1, 2, 4, 5]) 3 >>> মধ্যম (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"প্রদত্ত স্ট্রিংটি একটি প্যালিনড্রোম >>> is_palindrome (('') সত্য >>> is_palindrome (('aba') সত্য >>> is_palindrome (('aaaaa') সত্য >>> is_palindrome (('zbcd') মিথ্যা \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"2^n মডুলো পি (সংখ্যাগত বিষয়ের ব্যাপারে সচেতন থাকুন) ফেরত দিন। >>> মডুলো 3 , 5) 3 >>> মডুলো 1101, 101) 2 >>> মডুলো 0, 101) 1 >>> মডুলো 3, 11) 8 >>> মডুলো 100, 101) 1 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"ইনপুট স্ট্রিং হিসাবে এনকোড_শিফ্ট ফাংশন দিয়ে এনকোড করা হয়। ডিকোড স্ট্রিং ফেরত দেয়। \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"অক্ষরের প্রতিটি অক্ষরকে ৫ দ্বারা স্থানান্তর করে এনকোড করা স্ট্রিং প্রদান করে।\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels একটি ফাংশন যা স্ট্রিং নেয় এবং স্বরবর্ণ ছাড়া স্ট্রিং ফেরত দেয়। >>> remove_vowels('') '' >>> remove_vowels(\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"যদি তালিকা l এর সকল সংখ্যা থ্রেশহোল্ড t এর নিচে থাকে তবে True রিটার্ন করুন। >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"দুইটি সংখ্যা x এবং y যোগ করুন >>> যোগ করুন ((2, 3) 5 >>> যোগ করুন ((5, 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"দুটি শব্দের একই অক্ষর আছে কিনা তা পরীক্ষা করুন। >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') True >>> same_chars (('abcd', 'dddddddabc') True >>> same_chars (('dddddddabc', 'abcd') True >>> same_chars (('eabcd', 'dddddddabc') False >>> same_chars ((('abcd', 'dddddddabc') False >>> same_chars ((('abcdzzzz', 'dddzzzzzzdddabc') False \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"n-তম ফিবোনাচি সংখ্যা প্রদান করে। >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets হল \"<\" এবং \">\" এর একটি স্ট্রিং। প্রত্যাবর্তন সত্য যদি প্রতিটি খোলার বন্ধনীটির একটি সংশ্লিষ্ট বন্ধনী থাকে। >>> correct_bracketing ((\"<\") মিথ্যা >>> correct_bracketing ((\"<>\") সত্য >>> correct_bracketing ((\"<><>>\") সত্য >>> correct_bracketing ((\"><<>\") মিথ্যা \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"True হল তালিকা উপাদানগুলি একতরফাভাবে বৃদ্ধি বা হ্রাস পাচ্ছে। >>> একতরফা (([1, 2, 4, 20]) True >>> একতরফা (([1, 20, 4, 10]) False >>> একতরফা (([4, 1, 0, -10]) True \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"দুটি তালিকার জন্য সাজানো অনন্য সাধারণ উপাদানগুলি ফেরত দিন। >>> সাধারণ (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> সাধারণ (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"n এর বৃহত্তম প্রধান ফ্যাক্টরটি ফেরত দিন। n > 1 ধরে নিন এবং এটি একটি প্রধান নয়। >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n একটি ফাংশন যা 1 থেকে n পর্যন্ত সংখ্যার যোগফল দেয়। >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets হল \"(\" এবং \"\") এর একটি স্ট্রিং। প্রত্যাবর্তন সত্য যদি প্রতিটি খোলার বন্ধনীটির একটি সংশ্লিষ্ট বন্ধনী থাকে। >>> correct_bracketing(\"(\") মিথ্যা >>> correct_bracketing(\"() সত্য >>> correct_bracketing(\"() \") সত্য >>> correct_bracketing(\") মিথ্যা \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs একটি বহুপদীয়ের সহগকে প্রতিনিধিত্ব করে। xs[0] + xs[1] * x + xs[2] * x^2 + .... এই বহুপদের একই ফর্মের ডেরিভেটিভটি ফেরত দিন। >>> derivative (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivative[(1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"ফিবফিব সংখ্যা ক্রমটি ফিবোনাচি ক্রমের অনুরূপ একটি ক্রম যা নিম্নরূপ সংজ্ঞায়িত করা হয়ঃ fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3। অনুগ্রহ করে একটি ফাংশন লিখুন যাতে fibfib সংখ্যা ক্রমের n-তম উপাদানটি দক্ষতার সাথে গণনা করা যায়। >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"একটি ফাংশন লিখুন vowels_count যা একটি শব্দকে প্রতিনিধিত্বকারী একটি স্ট্রিংকে ইনপুট হিসাবে নেয় এবং স্ট্রিংয়ের স্বরবর্ণের সংখ্যা প্রদান করে। এই ক্ষেত্রে স্বরবর্ণগুলি হল 'a', 'e', 'i', 'o', 'u'। এখানে, 'y' একটি স্বরবর্ণও, তবে কেবল যখন এটি প্রদত্ত শব্দের শেষে থাকে। উদাহরণঃ >>> vowels_count ((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"আরও পরীক্ষা কেস যুক্ত করুন।\"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"সার্কুলার অক্ষর x এর অঙ্ক স্থানান্তর, স্থানান্তর দ্বারা অঙ্ক ডান দিকে স্থানান্তর এবং একটি স্ট্রিং হিসাবে ফলাফল ফেরত। যদি স্থানান্তর > অঙ্ক সংখ্যা, বিপরীত অঙ্ক ফেরত। >>> circular_shift(12, 1) \"21\" >>> circular_shift(12, 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"একটি ফাংশন লিখুন যা ইনপুট হিসাবে একটি স্ট্রিং নেয় এবং কেবলমাত্র উপরের অক্ষরের যোগফল ফেরত দেয়' ASCII কোডগুলি। উদাহরণঃ digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"এই কাজটিতে, আপনাকে একটি স্ট্রিং দেওয়া হবে যা ফলগুলির একটি ঝুড়িতে বিতরণ করা আপেল এবং কমলা সংখ্যাকে উপস্থাপন করে এই ঝুড়িতে আপেল, কমলা এবং আমফলার ফল রয়েছে। স্ট্রিং দেওয়া যা কমলা এবং আপেলের মোট সংখ্যা এবং একটি পূর্ণসংখ্যা যা ঝুড়িতে ফলগুলির মোট সংখ্যা উপস্থাপন করে ঝুড়িতে আমফলার ফলগুলির সংখ্যা ফেরত দিন। উদাহরণস্বরূপঃ fruit_distribution\"5(আপেল এবং 6 কমলা\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 আপেল এবং 1 কমলা\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 আপেল এবং 3 কমলা\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 আপেল এবং 120) \",1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"একটি অ্যারে দেওয়া যা একটি গাছের একটি শাখার প্রতিনিধিত্ব করে যার অ-নেতিবাচক পূর্ণসংখ্যা নোড রয়েছে আপনার কাজটি হ'ল একটি নোড বাছাই করা এবং এটি ফিরিয়ে দেওয়া। বাছাই করা নোডটি সবচেয়ে ছোট এমনকি মান সহ নোড হওয়া উচিত। যদি একই ছোট এমনকি মান সহ একাধিক নোড পাওয়া যায় তবে সবচেয়ে ছোট সূচক সহ নোডটি ফিরিয়ে দিন। বাছাই করা নোডটি একটি তালিকায় ফিরিয়ে দেওয়া উচিত, [smallest_value, এর সূচক] যদি কোনও এমনকি মান না থাকে বা প্রদত্ত অ্যারেটি খালি থাকে তবে [] ফেরত দিন। উদাহরণ 1: ইনপুটঃ [4,2,3] আউটপুটঃ [2, 1] ব্যাখ্যাঃ 2 এর সবচেয়ে ছোট এমনকি মান রয়েছে এবং 2 এর সবচেয়ে ছোট সূচক রয়েছে। উদাহরণ 2: ইনপুটঃ [1,2,3] আউটপুটঃ [2, 1] ব্যাখ্যাঃ 2 এর সবচেয়ে ছোট মান রয়েছে এবং 2 এর সবচেয়ে ছোট সূচক রয়েছে। উদাহরণ 3: ইনপুটঃ [] আউটপুটঃ [] ইনপুটঃ [4, 5, 3, 4, 2] আউটপুটঃ 1 [0, 0] আউটপুটঃ 1 নডঃ সবচেয়ে ছোট সূচক রয়েছে, তবে এর মানটি শূন্যতম, সুতরাং আমরা প্রথম নোডটি বেছে, যার দৈর্ধে শূন্যতম মান <= 10000 * = শূন্য, সুতরাং আমরা প্রথম নোডটি বেছে।\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''আপনাকে ধনাত্মক পূর্ণসংখ্যার একটি অ-খালি তালিকা দেওয়া হয়েছে। সর্বাধিক পূর্ণসংখ্যাটি ফেরত দিন যা শূন্যের চেয়ে বড় এবং পূর্ণসংখ্যাটির মানের চেয়ে বড় বা সমান। একটি পূর্ণসংখ্যাটির ফ্রিকোয়েন্সি হল তালিকায় এটি প্রদর্শিত হওয়ার সংখ্যা। যদি এমন কোনও মান না থাকে তবে -১ ফেরত দিন। উদাহরণঃ search (([4, 1, 2, 2, 3, 1]) == 2 search ([1, 2, 2, 3, 3, 3, 4, 4]) == 3 search ([5, 5, 4, 4, 4]) == -1 '''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''পূর্ণসংখ্যার তালিকা দেওয়া হলে, অদ্ভুত ক্রমে তালিকা ফেরত দিন। অদ্ভুত বাছাই, যখন আপনি সর্বনিম্ন মান দিয়ে শুরু করেন, তারপরে অবশিষ্ট পূর্ণসংখ্যার সর্বাধিক, তারপরে সর্বনিম্ন এবং তাই। উদাহরণঃ strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''একটি ত্রিভুজের তিনটি পাশের দৈর্ঘ্য দেওয়া হয়েছে। ত্রিভুজের ক্ষেত্রফলটি ২ দশমিক বিন্দুতে গোলাকার করে ফেরত দিন যদি তিনটি পাশ একটি বৈধ ত্রিভুজ গঠন করে। অন্যথায় -1 ফেরত দিন তিনটি পক্ষ একটি বৈধ ত্রিভুজ তৈরি করে যখন কোনও দুটি পক্ষের যোগফল তৃতীয় পক্ষের চেয়ে বেশি হয়। উদাহরণঃ ত্রিভুজ_ ক্ষেত্রফল ((3, 4, 5) == 6.00 ত্রিভুজ_ ক্ষেত্রফল ((1, 2, 10) == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''একটি ফাংশন লিখুন যা সত্য ফেরত দেয় যদি বস্তু q উড়ে যায়, এবং অন্যথায় মিথ্যা। বস্তুটি q উড়ে যাবে যদি এটি সুষম হয় (এটি একটি প্যালিনড্রোমিক তালিকা) এবং এর উপাদানগুলির যোগফল সর্বোচ্চ সম্ভাব্য ওজনের চেয়ে কম বা সমান হয় w। উদাহরণঃ will_it_fly (([1, 2], 5) â -> মিথ্যা # 1+2 সর্বোচ্চ সম্ভাব্য ওজনের চেয়ে কম, তবে এটি ভারসাম্যহীন। will_it_fly (([3, 2, 3], 1) â -> মিথ্যা # এটি সুষম, তবে 3+2+3 সর্বোচ্চ সম্ভাব্য ওজনের চেয়ে বেশি। will_it_fly (([3, 2, 3], 9) â -> সত্য # 3+23 সর্বোচ্চ সম্ভাব্য ওজনের চেয়ে কম, এবং এটি সুষম। will_it_fly ((([3], 5) â -> সত্য # 3 সর্বোচ্চ সম্ভাব্য ওজনের চেয়ে কম, এবং এটি ভারসাম্য।'''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"একটি অ্যারে দেওয়া পূর্ণসংখ্যা arr, অ্যারে palindromic করতে পরিবর্তন করা প্রয়োজন যে উপাদান ন্যূনতম সংখ্যা খুঁজে বের করুন। একটি palindromic অ্যারে একটি অ্যারে যে একই পিছনে এবং সামনে পড়া হয়। এক পরিবর্তন, আপনি অন্য কোন উপাদান এক উপাদান পরিবর্তন করতে পারেন। উদাহরণস্বরূপঃ smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 \"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''একটি ফাংশন লিখুন যা স্ট্রিংয়ের দুটি তালিকা গ্রহণ করে এবং সেই তালিকাটি ফেরত দেয় যার তালিকার সমস্ত স্ট্রিংয়ে অক্ষরের মোট সংখ্যা অন্য তালিকার চেয়ে কম। যদি দুটি তালিকায় অক্ষরের একই সংখ্যা থাকে তবে প্রথম তালিকাটি ফেরত দিন। উদাহরণ total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4'', '5' -> ['4'])'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"একটি ফাংশন লিখুন যা সত্য ফেরত দেয় যদি প্রদত্ত সংখ্যাটি 3 টি প্রধান সংখ্যার গুণ এবং অন্যথায় মিথ্যা হয়। জেনে রাখা যে (ক) 100 এর চেয়ে কম। উদাহরণঃ is_multiply_prime(30) == সত্য 30 = 2 * 3 * 5 \"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"আপনার কাজ হল এমন একটি ফাংশন লিখতে যা সত্য ফেরত দেয় যদি একটি সংখ্যা x n এর একটি সাধারণ শক্তি হয় এবং অন্য ক্ষেত্রে মিথ্যা হয়। x n এর একটি সাধারণ শক্তি যদি n**int=x উদাহরণস্বরূপঃ is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''একটি ফাংশন লিখুন যা একটি পূর্ণসংখ্যা a নেয় এবং True প্রদান করে যদি এই ingeger কোন পূর্ণসংখ্যা সংখ্যার একটি ঘনক হয়। দ্রষ্টব্যঃ আপনি ধরে নিতে পারেন যে ইনপুটটি সর্বদা বৈধ। উদাহরণঃ iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"আপনাকে একটি ফাংশন লিখতে বলা হয়েছে যা একটি স্ট্রিং হিসাবে একটি ষাট দশমিক সংখ্যা গ্রহণ করে এবং ষাট দশমিক সংখ্যার সংখ্যা গণনা করে যা প্রাইম (প্রাইম নম্বর, বা একটি প্রাইম, 1 এর চেয়ে বড় একটি প্রাকৃতিক সংখ্যা যা দুটি ছোট প্রাকৃতিক সংখ্যার একটি পণ্য নয়) । ষাট দশমিক সংখ্যাগুলি হ'ল 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F। প্রাইম সংখ্যাগুলি হল 2, 3, 5, 7, 11, 13, 17,... সুতরাং আপনাকে নিম্নলিখিত সংখ্যার একটি সংখ্যা নির্ধারণ করতে হবেঃ 2, 3, 5, 7, B (= দশমিক 11), D (= দশমিক 13) নোটঃ আপনি ধরে নিতে পারেন যে ইনপুটটি সর্বদা সঠিক বা ফাঁকা স্ট্রিং এবং চিহ্নগুলি A, B, C, D, E, F সর্বদা বড় হাতের অক্ষর। উদাহরণঃ \"num\" = AB এর জন্য আউটপুটটি num = 1. \"num\" = AB1077E এর জন্য আউটপুটটি 2 হওয়া উচিত। \"num\" = AB331EDA এর জন্য num = 4. \"num\" = 4. \"num\" = ABC1234567D এর জন্য আউটপুটটি num = 2. \"2020\" হওয়া উচিত।\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"আপনাকে দশমিক আকারে একটি সংখ্যা দেওয়া হবে এবং আপনার কাজটি এটিকে বাইনারি ফর্ম্যাটে রূপান্তর করা। ফাংশনটি একটি স্ট্রিং প্রদান করবে, যেখানে প্রতিটি অক্ষর একটি বাইনারি সংখ্যা প্রতিনিধিত্ব করবে। স্ট্রিংয়ের প্রতিটি অক্ষর হবে '0' বা '1'। স্ট্রিংয়ের শুরুতে এবং শেষে অতিরিক্ত কয়েকটি অক্ষর 'db' থাকবে। অতিরিক্ত অক্ষরগুলি ফর্ম্যাটে সহায়তা করার জন্য রয়েছে। উদাহরণঃ decimal_to_binary(15) # রিটার্ন করে \"db1111db\" decimal_to_binary32) # রিটার্ন করে \"db100000db\" \"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"আপনাকে একটি স্ট্রিং s দেওয়া হয়েছে। আপনার কাজ হল স্ট্রিংটি সুখী কিনা তা পরীক্ষা করা। একটি স্ট্রিং সুখী হয় যদি এর দৈর্ঘ্য কমপক্ষে 3 এবং প্রতিটি 3 টি পরপর অক্ষর পৃথক হয় উদাহরণস্বরূপঃ is_happy ((a) => False is_happy ((aa) => False is_happy ((abcd) => True is_happy ((aabb) => False is_happy ((adb) => True is_happy ((xyy)) => False \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"সেমিস্টারের শেষ সপ্তাহ এবং শিক্ষকের শিক্ষার্থীদের গ্রেড দিতে হবে। শিক্ষিকা গ্রেডিংয়ের জন্য তার নিজস্ব অ্যালগরিদম তৈরি করছেন। একমাত্র সমস্যা হল, তিনি গ্রেডিংয়ের জন্য ব্যবহৃত কোডটি হারিয়ে ফেলেছেন। তিনি আপনাকে কিছু শিক্ষার্থীর জন্য জিপিএগুলির একটি তালিকা দিয়েছেন এবং আপনাকে একটি ফাংশন লিখতে হবে যা নিম্নলিখিত টেবিল ব্যবহার করে চিঠি গ্রেডের একটি তালিকা আউটপুট করতে পারেঃ জিপিএ ⇒ চিঠি গ্রেড 4.0 এ + > 3.7 এ > 3.3 এ- > 3.0 বি + > 2.7 বি > 2.3 বি- > 2.3 বি + > 2.0 সি + > 1.7 সি > 1.3 সি- > 1.0 ডি + > 0.7 ডি > 0.0 ডি- 0.0 ইঃ গ্রেড_ সমীকরণ উদাহরণঃ (([4.0, 3, 1.7, 2, 3.5]) ==> ['এ+', 'বি', 'সি-', 'সি', 'এ'] -'\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"একটি ফাংশন লিখুন যা একটি স্ট্রিং নেয় এবং স্ট্রিং দৈর্ঘ্য একটি প্রধান সংখ্যা হলে সত্য বা মিথ্যা ফেরত দেয় অন্যথায় উদাহরণ prime_length (('হ্যালো') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('অরেঞ্জ') == False \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"একটি ধনাত্মক পূর্ণসংখ্যা n দেওয়া হলে, n-অঙ্কের ধনাত্মক পূর্ণসংখ্যাগুলির সংখ্যা ফেরত দিন যা 1 দিয়ে শুরু বা শেষ হয়।\"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"একটি ধনাত্মক পূর্ণসংখ্যা N দেওয়া হলে, বাইনারি আকারে এর অঙ্কগুলির মোট যোগফলটি ফেরত দিন। উদাহরণস্বরূপ N = 1000 এর জন্য, অঙ্কগুলির যোগফল 1 হবে আউটপুটটি \"1\" হওয়া উচিত। N = 150 এর জন্য, অঙ্কগুলির যোগফল 6 হবে আউটপুটটি \"110\" হওয়া উচিত। N = 147 এর জন্য, অঙ্কগুলির যোগফল 12 হবে আউটপুটটি \"1100\" হওয়া উচিত। পরিবর্তনশীলঃ @N পূর্ণসংখ্যা সীমাবদ্ধতাঃ 0 â‰¤ N â‰¤ 10000. আউটপুটঃ বাইনারি সংখ্যার একটি স্ট্রিং \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"পূর্ণসংখ্যার একটি অ-খালি তালিকা দেওয়া lst. অদ্ভুত সূচকগুলিতে থাকা এমনকি উপাদানগুলি যোগ করুন। উদাহরণঃ যোগ করুন (([4, 2, 6, 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"একটি স্ট্রিং নিয়ে একটি ফাংশন লিখুন এবং এর একটি অর্ডারড সংস্করণ ফেরত দিন। স্ট্রিংয়ের অর্ডারড সংস্করণ, এমন একটি স্ট্রিং যেখানে সমস্ত শব্দ (স্পেস দ্বারা পৃথক) একটি নতুন শব্দ দ্বারা প্রতিস্থাপিত হয় যেখানে সমস্ত অক্ষর ascii মানের উপর ভিত্তি করে ক্রমবর্ধমান ক্রমে সাজানো হয়। দ্রষ্টব্যঃ আপনার বাক্যে শব্দ এবং ফাঁকা স্পেসের ক্রম রাখা উচিত। উদাহরণস্বরূপঃ anti_shuffle ((('Hi') ফেরত দেয় 'Hi' anti_shuffle ((('hello') ফেরত দেয় 'ehllo' anti_shuffle (('Hello World!!!') ফেরত দেয় 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"আপনাকে একটি ২-মাত্রিক ডেটা দেওয়া হয়েছে, একটি নেস্টেড তালিকা হিসাবে, যা ম্যাট্রিক্সের অনুরূপ, তবে ম্যাট্রিক্সের বিপরীতে, প্রতিটি সারিতে বিভিন্ন সংখ্যক কলাম থাকতে পারে। lst এবং পূর্ণসংখ্যা x দেওয়া, তালিকায় পূর্ণসংখ্যা x সন্ধান করুন এবং টুপলগুলির তালিকা ফেরত দিন, [(x1, y1), (x2, y2) ...] যেমন প্রতিটি টিপল একটি সমন্বয় - (সারি, কলাম), 0 দিয়ে শুরু হয়। সমন্বয়গুলি প্রথমে ক্রমবর্ধমান ক্রম অনুসারে সারি দ্বারা বাছাই করুন। এছাড়াও, ক্রমবর্ধমান ক্রম অনুসারে কলাম দ্বারা সারিটির সমন্বয় বাছাই করুন। উদাহরণঃ get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0, 0, 0, 0, 1, 4], 0 (1, 4), 0 (2, 5), (2, 0) get_(], 1) [] == [[সারি 1, 1, 2, 3]], 2) []]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"একটি অ-নতিবাচক পূর্ণসংখ্যার অ্যারে দেওয়া, সাজানোর পরে প্রদত্ত অ্যারের একটি অনুলিপি ফেরত দিন, আপনি প্রদত্ত অ্যারেটি ক্রমবর্ধমান ক্রমে বাছাই করবেন যদি যোগফল ((প্রথম সূচক মান, শেষ সূচক মান) অদ্ভুত হয়, বা যদি যোগফল ((প্রথম সূচক মান, শেষ সূচক মান) এমনকি হয় তবে এটিকে নিম্নগামী ক্রমে বাছাই করুন। দ্রষ্টব্যঃ * প্রদত্ত অ্যারেটি পরিবর্তন করবেন না। উদাহরণঃ * sort_array[(]) => [] * sort_array[[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"একটি ফাংশন এনক্রিপ্ট তৈরি করুন যা একটি স্ট্রিংকে আর্গুমেন্ট হিসাবে নেয় এবং বর্ণমালা ঘোরানো হচ্ছে এমন একটি স্ট্রিং এনক্রিপ্ট করে ফেরত দেয়। বর্ণমালাটি এমনভাবে ঘোরানো উচিত যাতে অক্ষরগুলি দুটি দ্বারা দ্বিগুণ করে দুটি স্থানে স্থানান্তরিত হয়। উদাহরণস্বরূপঃ এনক্রিপ্ট (('hi') রিটার্নস 'lm' এনক্রিপ্ট (('asdfghjkl') রিটার্নস 'ewhjklnop' এনক্রিপ্ট (('gf') রিটার্নস 'kj' এনক্রিপ্ট (('et') রিটার্নস 'ix' \"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"আপনাকে পূর্ণসংখ্যার একটি তালিকা দেওয়া হয়েছে। একটি ফাংশন next_smallest লিখুন যা তালিকার দ্বিতীয় ক্ষুদ্রতম উপাদানটি ফেরত দেয়। যদি এমন কোনও উপাদান না থাকে তবে None ফেরত দিন। next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"আপনাকে একটি শব্দ স্ট্রিং দেওয়া হবে, এবং আপনার কাজটি হচ্ছে বিরক্তিকর সংখ্যা গণনা করা। বিরক্তিকর এমন একটি বাক্য যা \"আমি\" শব্দ দিয়ে শুরু হয়। বাক্যগুলি '.', '?' বা '! ' দ্বারা সীমিত। উদাহরণস্বরূপঃ >>> is_bored ((\"হ্যালো ওয়ার্ল্ড\") 0 >>> is_bored ((\"আকাশ নীল। সূর্য জ্বলছে। আমি এই আবহাওয়া পছন্দ করি\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''একটি ফাংশন তৈরি করুন যা 3 টি সংখ্যা গ্রহণ করে। যদি একটি সংখ্যা অন্য দুটি সংখ্যার যোগফলের সমান হয় এবং সমস্ত সংখ্যা পূর্ণসংখ্যা হয় তবে সত্য ফেরত দেয়। অন্য কোনও ক্ষেত্রে মিথ্যা ফেরত দেয়। উদাহরণ any_int ((5, 2, 7) â -> True any_int ((3, 2, 2) â -> False any_int ((3, -2, 1) â -> True any_int ((3.6, -2.2, 2) â -> False '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"এমন একটি ফাংশন লিখুন যা একটি বার্তা নেয় এবং এমনভাবে এনকোড করে যাতে এটি সমস্ত অক্ষরের কেস পরিবর্তন করে, বার্তার সমস্ত স্বরকে ইংরেজি বর্ণমালার সেই স্বরটির 2 টি স্থান এগিয়ে উপস্থিত অক্ষরের সাথে প্রতিস্থাপন করে। কেবলমাত্র অক্ষরগুলি ধরে নিন। উদাহরণঃ >>> এনকোড (('পরীক্ষা') 'টিজিএসটি' >>> এনকোড (('এটি একটি বার্তা') 'টিএইচকেএস কেএস সি এমজিএসসিজিজি' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"আপনাকে পূর্ণসংখ্যার একটি তালিকা দেওয়া হয়েছে। আপনাকে সবচেয়ে বড় অক্ষর মান খুঁজে বের করতে হবে এবং তার অঙ্কগুলির যোগফল ফেরত দিতে হবে। উদাহরণঃ lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] এর জন্য আউটপুট 10 হওয়া উচিত lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] এর জন্য আউটপুট 25 হওয়া উচিত lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] এর জন্য 13 হওয়া উচিত lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] এর জন্য 11 হওয়া উচিত lst = [0,81,12,3,21,1] এর জন্য 3 হওয়া উচিত lst = [0,1,8,1,2,7] এর জন্য 7 হওয়া উচিত \"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"একটি অভিধান দেওয়া হলে, True ফেরত দিন যদি সমস্ত কীগুলি ছোট হাতের অক্ষরে স্ট্রিং হয় বা সমস্ত কীগুলি বড় হাতের অক্ষরে স্ট্রিং হয়, অন্যথায় False ফেরত দিন। ফাংশনটি False ফেরত দিতে হবে যদি প্রদত্ত অভিধানটি খালি থাকে। উদাহরণঃ check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) True ফেরত দিতে হবে। check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) False ফেরত দিতে হবে। check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) False ফেরত দিতে হবে। check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) False ফেরত দিতে হবে। check_dict_case{\"NC\":\"STATE\", \"Z\":\"IP\"12345}) True ফেরত দিতে হবে।\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"একটি ফাংশন বাস্তবায়ন করুন যা একটি অ-নতিবাচক পূর্ণসংখ্যা নেয় এবং প্রথম n পূর্ণসংখ্যাগুলির একটি অ্যারে ফেরত দেয় যা অগ্রিম সংখ্যা এবং n এর চেয়ে কম। উদাহরণস্বরূপঃ count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"দুটি পূর্ণসংখ্যা গ্রহণ করে এবং তাদের একক অঙ্কগুলির গুণফল প্রদান করে এমন ফাংশনটি সম্পূর্ণ করুন। ধরে নিন যে ইনপুটটি সর্বদা বৈধ। উদাহরণঃ গুণক ((148, 412) 16 ফিরিয়ে দেবে। গুণক ((19, 28) 72 ফিরিয়ে দেবে। গুণক ((2020, 1851) 0 ফিরিয়ে দেবে। গুণক ((14,-15) 20 ফিরিয়ে দেবে। \"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"একটি স্ট্রিং s দেওয়া হলে, এমনকি সূচকগুলিতে বড় হাতের স্বরগুলির সংখ্যা গণনা করুন। উদাহরণস্বরূপঃ count_upper (('aBCdEf') 1 count_upper (('abcdefg') 0 count_upper (('dBBE') 0 ফেরত দেয় \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''একটি ফাংশন তৈরি করুন যা একটি সংখ্যা প্রতিনিধিত্ব করে এমন একটি মান (স্ট্রিং) নেয় এবং এর নিকটতম পূর্ণসংখ্যাটি ফেরত দেয়। যদি সংখ্যাটি দুটি পূর্ণসংখ্যা থেকে সমান দূরত্বে থাকে তবে এটি শূন্য থেকে দূরে ঘোরান। উদাহরণ >>> closest_integer ((\"10\") 10 >>> closest_integer ((\"15.3\") 15 নোটঃ শূন্য থেকে দূরে ঘোরানো মানে যদি প্রদত্ত সংখ্যাটি দুটি পূর্ণসংখ্যা থেকে সমান দূরত্বে থাকে তবে আপনার যেটি ফেরত দেওয়া উচিত তা শূন্য থেকে সবচেয়ে দূরে। উদাহরণস্বরূপ closest_integer \" ((14.5\") 15 এবং closest_integer \" ((-14.5\") -15. '''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"একটি ধনাত্মক পূর্ণসংখ্যা n দেওয়া হলে, আপনাকে n স্তরের পাথর দিয়ে একটি গাদা তৈরি করতে হবে। প্রথম স্তরে n পাথর রয়েছে। পরবর্তী স্তরের পাথরের সংখ্যা হলঃ - পরবর্তী অদ্ভুত সংখ্যা যদি n অদ্ভুত হয়। - পরবর্তী এমনকি সংখ্যা যদি n হয়। একটি তালিকায় প্রতিটি স্তরের পাথরের সংখ্যা ফেরত দিন, যেখানে সূচক i এ উপাদানটি স্তরের পাথরের সংখ্যা (i+1) প্রতিনিধিত্ব করে। উদাহরণঃ >>> make_a_pile (৩) [৩, ৫, ৭] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"আপনাকে কমা বা স্পেস দ্বারা পৃথক করা শব্দের একটি স্ট্রিং দেওয়া হবে। আপনার কাজ হল স্ট্রিংটিকে শব্দের মধ্যে বিভক্ত করা এবং শব্দের একটি অ্যারে ফেরত দেওয়া। উদাহরণস্বরূপঃ words_string ((\"হাই, আমার নাম জন\") == [\"হাই\", \"আমার\", \"নাম\", \"ইস\", \"জন\"] words_string ((\"এক, দুই, তিন, চার, পাঁচ, ছয়\") == [\"এক\", \"দুই\", \"তিন\", \"চার\", \"পাঁচ\", \"ছয়\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"এই ফাংশনটি দুটি ধনাত্মক সংখ্যা x এবং y গ্রহণ করে এবং [x, y] সহ পরিসরের বৃহত্তম এমনকি পূর্ণসংখ্যাটি প্রদান করে। যদি এমন কোনও সংখ্যা না থাকে তবে ফাংশনটি -1 প্রদান করা উচিত। উদাহরণস্বরূপঃ choose_num ((12, 15) = 14 choose_num ((13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"আপনাকে দুটি ধনাত্মক পূর্ণসংখ্যা n এবং m দেওয়া হয়েছে, এবং আপনার কাজ হল n থেকে m পর্যন্ত পূর্ণসংখ্যাগুলির গড় গণনা করা (n এবং m সহ) । উত্তরটি নিকটতম পূর্ণসংখ্যা পর্যন্ত গোল করুন এবং এটিকে বাইনারি রূপান্তর করুন। যদি n m এর চেয়ে বড় হয় তবে -১ ফেরত দিন। উদাহরণঃ rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b1111\" rounded_avg ((20, 33) => \"0b11010\" \"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"ধনাত্মক পূর্ণসংখ্যার একটি তালিকা দেওয়া x. সমস্ত উপাদানগুলির একটি সাজানো তালিকা ফেরত দিন যার কোনও এমনকি অঙ্ক নেই। দ্রষ্টব্যঃ ফেরত তালিকা ক্রমবর্ধমান ক্রমে সাজানো উচিত। উদাহরণস্বরূপঃ >>> অনন্য_অঙ্কগুলি (([১৫, ৩৩, ১৪২২, ১]) [১, ১৫, ৩৩] >>> অনন্য_অঙ্কগুলি (([১৫২, ৩২৩, ১৪২২, ১০]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"একটি পূর্ণসংখ্যা অ্যারে দেওয়া হলে, 1 এবং 9 এর মধ্যে পূর্ণসংখ্যাগুলি বাছাই করুন, ফলাফল অ্যারেটি বিপরীত করুন, এবং তারপরে প্রতিটি অঙ্ককে তার অনুরূপ নাম দিয়ে প্রতিস্থাপন করুন \"এক\", \"দুই\", \"তিন\", \"চার\", \"পাঁচ\", \"ছয়\", \"সাত\", \"আট\", \"নয়\" থেকে। উদাহরণস্বরূপঃ arr = [2, 1, 1, 4, 5, 8, 2, 3] -> সাজান arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> বিপরীত arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"আট\", \"চার\", \"তিন\", \"দুই\", \"দুই\", \"এক\", \"এক\"] যদি অ্যারেটি খালি থাকে তবে একটি খালি রিটার্নঃ arr = [] return [] যদি অ্যারেটিতে কোনও অদ্ভুত সংখ্যা থাকে তবে এটি উপেক্ষা করুনঃ arr = [1, -1 , 55] -> arr -> [-1, 1, 55] -> reverse arr = [55,1] return - ['One' 1,'] \"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"ফাংশন f প্রয়োগ করুন যা n কে প্যারামিটার হিসাবে নেয় এবং n আকারের একটি তালিকা প্রদান করে, যেমন সূচক i এ উপাদানটির মান i এর ফ্যাক্টরিয়াল যদি i এমনকি হয় বা অন্যথায় 1 থেকে i পর্যন্ত সংখ্যার যোগফল হয়। i 1 থেকে শুরু হয়। i এর ফ্যাক্টরিয়াল 1 থেকে i পর্যন্ত সংখ্যার গুণন (1 * 2 * ... * i) । উদাহরণঃ f ((5) == [1, 2, 6, 24, 15] \"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"একটি ধনাত্মক পূর্ণসংখ্যা n দেওয়া হলে, একটি টিপল ফেরত দিন যার মধ্যে রয়েছে এমন সম এবং অস্বাভাবিক পূর্ণসংখ্যা প্যালিনড্রোমের সংখ্যা যা পরিসীমা ((1, n), সহ। উদাহরণ 1: ইনপুটঃ 3 আউটপুটঃ (1, 2) ব্যাখ্যাঃ পূর্ণসংখ্যা প্যালিনড্রোম হল 1, 2, 3. তাদের মধ্যে একটি সম এবং তাদের মধ্যে দুটি অস্বাভাবিক। উদাহরণ 2: ইনপুটঃ 12 আউটপুটঃ (4, 6) ব্যাখ্যাঃ পূর্ণসংখ্যা প্যালিনড্রোম হল 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. তাদের মধ্যে চারটি সম এবং তাদের মধ্যে 6 টি অস্বাভাবিক। দ্রষ্টব্যঃ 1. 1 <= n <= 10^3 2. টিপলটি যথাক্রমে সম এবং অস্বাভাবিক পূর্ণসংখ্যা প্যালিনড্রোমের সংখ্যা ফেরত দিয়েছে। \"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"একটি ফাংশন লিখুন count_nums যা পূর্ণসংখ্যাগুলির একটি অ্যারে নেয় এবং উপাদানগুলির সংখ্যা প্রদান করে যার সংখ্যাগুলি > 0। যদি একটি সংখ্যা নেতিবাচক হয়, তবে তার প্রথম স্বাক্ষরিত অঙ্কটি নেতিবাচক হবেঃ উদাহরণস্বরূপ -123 স্বাক্ষরিত অঙ্কগুলি -1, 2, এবং 3 আছে। >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"আমাদের একটি অ্যারে 'arr' আছে N পূর্ণসংখ্যা arr[1], arr[2], ..., arr[N]। অ্যারেতে সংখ্যাগুলি এলোমেলোভাবে অর্ডার করা হবে। আপনার কাজ হল নির্ধারণ করা যে প্রদত্ত অ্যারেতে নিম্নলিখিত অপারেশনটি সম্পাদন করে অ-হ্রাসমান ক্রমে একটি অ্যারে সাজানো সম্ভব কিনাঃ আপনাকে যে কোনও সংখ্যক বার ডানদিকে স্থানান্তর অপারেশন করার অনুমতি দেওয়া হয়েছে। একটি ডানদিকে স্থানান্তর অপারেশন মানে অ্যারের সমস্ত উপাদানকে ডান দিকে এক অবস্থানে স্থানান্তর করা। অ্যারের শেষ উপাদানটি অ্যারেতে শুরুতে অবস্থানে স্থানান্তরিত হবে অর্থাৎ 0th সূচক। যদি উপরের অপারেশনটি সম্পাদন করে সাজানো অ্যারেটি পাওয়া সম্ভব হয় তবে সত্য ফেরত অন্যথায় মিথ্যা ফেরত। যদি প্রদত্ত অ্যারেটি খালি থাকে তবে সত্য ফেরত। দ্রষ্টব্যঃ প্রদত্ত তালিকায় অনন্য উপাদান থাকার গ্যারান্টি রয়েছে। উদাহরণস্বরূপঃ move_one_(ball[3, 4, 5, 2]==> সত্য ব্যাখ্যাঃ 2 ডানদিকে স্থানান্তর অপারেশন দ্বারা, অ-হ্রাসমান ক্রমে অ্যারে জন্য অর্ডার করা সম্ভব।[3, 4, 5, 2] এটি প্রদত্ত অ্যারেতে কোনও স্থানান্তর অপারেশন সম্পাদন করার জন্য সম্ভব নয়।\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"এই সমস্যায়, আপনি একটি ফাংশন বাস্তবায়ন করবেন যা দুটি সংখ্যার তালিকা নেয় এবং নির্ধারণ করে যে তাদের মধ্যে উপাদানগুলির বিনিময় করা সম্ভব কিনা lst1 কেবলমাত্র এমনকি সংখ্যার একটি তালিকা তৈরি করতে। lst1 এবং lst2 এর মধ্যে বিনিময় করা উপাদানগুলির সংখ্যার কোনও সীমা নেই। যদি lst1 এবং lst2 এর মধ্যে উপাদানগুলি বিনিময় করা সম্ভব হয় lst1 এর সমস্ত উপাদানগুলিকে এমনকি করতে, \"হ্যাঁ\" ফেরত দিন। অন্যথায়, \"না\" ফেরত দিন। উদাহরণস্বরূপঃ বিনিময় [(1, 2, 3, 4], [1, 2, 3, 4]) => \"হ্যাঁ\" বিনিময় [(1, 2, 3, 4], [1, 5, 3, 4]) => \"না\" এটি ধরে নেওয়া হয় যে ইনপুট তালিকাটি অ-খালি হবে। \"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"একটি স্ট্রিং দেওয়া যা একটি স্পেস পৃথক ছোট হাতের অক্ষর প্রতিনিধিত্ব করে, সর্বাধিক পুনরাবৃত্তি সহ অক্ষরের একটি অভিধান ফেরত দিন এবং সংশ্লিষ্ট গণনা রয়েছে। যদি বেশ কয়েকটি অক্ষরের একই ঘটনা থাকে তবে সেগুলি সব ফেরত দিন। উদাহরণঃ হিস্টোগ্রাম (('a b c') == {'a': 1, 'b': 1, 'c': 1} হিস্টোগ্রাম (('a b b a') == {'a': 2, 'b': 2} হিস্টোগ্রাম (('a b c a b') == {'a': 2, 'b': 2} হিস্টোগ্রাম (('b b a') == {'b 4}': হিস্টোগ্রাম (('a') == {'b 4}'}\"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"কাজ আমাদের দুটি স্ট্রিং s এবং c দেওয়া হয়েছে, আপনাকে s এর সমস্ত অক্ষর মুছে ফেলতে হবে যা c এর যে কোনও অক্ষরের সমান তারপর ফলাফল স্ট্রিংটি প্যালিনড্রোম কিনা তা পরীক্ষা করুন। একটি স্ট্রিংকে প্যালিনড্রোম বলা হয় যদি এটি একই পিছনে এবং সামনে পড়ে। আপনাকে চেক করার জন্য ফলাফল স্ট্রিং এবং সত্য/মিথ্যা ধারণকারী একটি টিউপল ফিরিয়ে দিতে হবে। উদাহরণস্বরূপ s = \"abcde\", c = \"ae\", ফলাফলটি হওয়া উচিত ('bcd', False) s = \"abcdef\", c = \"b\" ফলাফলটি হওয়া উচিত ('acdef', False) s = \"abcdedcba\", c = \"ab\", ফলাফলটি হওয়া উচিত ('cdedc', True) \"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"স্ট্রিংগুলির একটি তালিকা দেওয়া হয়েছে, যেখানে প্রতিটি স্ট্রিং কেবলমাত্র অঙ্ক নিয়ে গঠিত, একটি তালিকা ফেরত দিন। আউটপুটের প্রতিটি উপাদান i হওয়া উচিত \"ইনপুটের স্ট্রিং i এর অদ্ভুত উপাদানগুলির সংখ্যা।\" যেখানে সমস্ত i's ইনপুটের i'th স্ট্রিংয়ের অদ্ভুত অঙ্কগুলির সংখ্যা দ্বারা প্রতিস্থাপিত হওয়া উচিত। >>> odd_count['1234567']) [\"odd_count 4n the str4ng 4 of the 4nput.\"] >>> odd_count['3',\"111111\"]) [\"odd_count 1n the str1ng 1 of the 1nput.\", \"odd elements 8n the str8ng 8 of the 8nput.\"] \"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"পূর্ণসংখ্যা n এর একটি অ্যারে দেওয়া হলে, n এর যে কোনও খালি উপ-অ্যারেটির সর্বনিম্ন যোগফলটি সন্ধান করুন। উদাহরণ minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"আপনার কাছে একটি আয়তক্ষেত্রাকার গ্রিড দেওয়া আছে। প্রতিটি সারি একটি একক কূপকে উপস্থাপন করে এবং প্রতিটি সারি 1 একটি একক ইউনিট জলকে উপস্থাপন করে। প্রতিটি কূপের একটি সংশ্লিষ্ট বালতি রয়েছে যা এটি থেকে জল বের করতে ব্যবহার করা যেতে পারে এবং সমস্ত বালতিতে একই ক্ষমতা রয়েছে। আপনার কাজ হ'ল বালতিগুলি ব্যবহার করে কূপগুলি খালি করা। আপনার যে পরিমাণ বার বালতিগুলি নামানোর প্রয়োজন তা আউটপুট করুন। উদাহরণ 1: ইনপুটঃ গ্রিডঃ [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 আউটপুটঃ 6 উদাহরণ 2: ইনপুটঃ গ্রিডঃ [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 আউটপুটঃ 5 উদাহরণ 3: ইনপুটঃ [[:0,0,0], [0,0]] bucket_capacity: 5 আউটপুটঃ 0 * constraints: 1 * * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 10 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 2 * 1 * 2 * 1 * 2 * 2 * 2 * 1 * 2 * 2 * 2 * 2 * 3 * 2 * 2 * 3 * 2 * 2 * 2 * 3 * 2 * 2 * 3 * 4 * 2 * 2 * 3 * 4 * 4 * 6 * 6 * 6 * 6 * 6 * 6 * 6 * 6 * 6 * 7 * 7 * 7 * 7 * 7 * 7 * 7 * 8 * 9 * 9 * 9 * 9 * 9 * 9 * 10 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"এই কটাতে, আপনাকে একটি অ-নেগেটিভ পূর্ণসংখ্যার অ্যারেকে তাদের বাইনারি উপস্থাপনার সংখ্যা অনুসারে ক্রমবর্ধমান ক্রমে সাজাতে হবে। অনুরূপ সংখ্যার জন্য, দশমিক মানের উপর ভিত্তি করে সাজান। এটি এভাবে বাস্তবায়িত হতে হবেঃ >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"একটি স্ট্রিং s এবং একটি প্রাকৃতিক সংখ্যা n দেওয়া হলে, আপনাকে একটি ফাংশন বাস্তবায়ন করার জন্য বলা হয়েছে যা স্ট্রিং s থেকে সমস্ত শব্দের একটি তালিকা ফেরত দেয় যাতে এই শব্দের স্ট্রিং s এ উপস্থিত হয়। যদি স্ট্রিং s খালি থাকে তবে ফাংশনটি একটি খালি তালিকা ফেরত দেবে। দ্রষ্টব্যঃ আপনি ধরে নিতে পারেন যে ইনপুট স্ট্রিংটিতে কেবলমাত্র অক্ষর এবং স্পেস রয়েছে। উদাহরণঃ select_words ((\"মেরি একটি ছোট মেষশাবক ছিল\", 4) ==> [\"little\"] select_words ((\"মেরি একটি ছোট মেষশাবক ছিল\", 3) ==> [\"মেরি\", \"মেষশাবক\"] select_words\" (((সাধারণ সাদা স্থান\", 2) ==> [] select_words ((\"হ্যালো ওয়ার্ল্ড\", 4) ==> [\"world\"] select_words ((\"আঙ্কেল স্যাম\", 3) ==> [\"আঙ্কেল\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"আপনাকে একটি শব্দ দেওয়া হয়েছে। আপনার কাজ হল শব্দটির ডান দিক থেকে দুটি ব্যঞ্জনবর্ণের মধ্যে সবচেয়ে কাছের স্বরবর্ণ খুঁজে বের করা (case sensitive) । শুরুর এবং শেষের স্বরবর্ণ গণনা করা হয় না। যদি আপনি উপরের শর্ত পূরণ করে কোন স্বরবর্ণ খুঁজে না পান তবে খালি স্ট্রিংটি ফেরত দিন। আপনি ধরে নিতে পারেন যে প্রদত্ত স্ট্রিংটিতে কেবল ইংরেজি অক্ষর রয়েছে। উদাহরণঃ get_closest_vowel ((\"yogurt\") ==> \"u\" get_closest_vowel ((\"F\") ==> \"U\" get_closest_vowel ((\"quick\") ==> \"\" get_closest_vowel\" ((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''আপনাকে দুটি স্ট্রিংয়ের একটি তালিকা দেওয়া হয়েছে, উভয় স্ট্রিংই কেবল খোলা বন্ধনী '(' বা বন্ধ বন্ধনী ') ' দিয়ে গঠিত। আপনার কাজটি হ'ল দুটি স্ট্রিংকে কোনও ক্রমে সংযুক্ত করা সম্ভব কিনা তা পরীক্ষা করা, যে ফলস্বরূপ স্ট্রিংটি ভাল হবে। একটি স্ট্রিং এসকে ভাল বলে বিবেচনা করা হয় যদি এবং কেবলমাত্র যদি এস এর সমস্ত বন্ধনী ভারসাম্যপূর্ণ হয়। উদাহরণস্বরূপঃ স্ট্রিং '((()) 'ভাল হয়, যখন স্ট্রিং '()) 'না। একটি ভাল স্ট্রিং তৈরির উপায় থাকলে 'হ্যাঁ' ফেরত দিন, এবং অন্যথায় 'না' ফেরত দিন। উদাহরণঃ match_parens[('() ', ') ']) == 'হ্যাঁ' match_parens[(') ', ') ']) == 'না' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"একটি পূর্ণসংখ্যা আরআর এবং একটি ধনাত্মক পূর্ণসংখ্যা কে দেওয়া হয়েছে, আরআর এর সর্বোচ্চ k সংখ্যার সাথে দৈর্ঘ্য k এর একটি সাজানো তালিকা ফেরত দিন। উদাহরণ 1: ইনপুটঃ আরআর = [-3, -4, 5], কে = 3 আউটপুটঃ [-4, -3, 5] উদাহরণ 2: ইনপুটঃ আরআর = [4, -4, 4], কে = 2 আউটপুটঃ [4, 4] উদাহরণ 3: ইনপুটঃ আরআর = [-3, 2, 1, 2, -1, -2, 1], কে = 1 আউটপুটঃ [2] নোটঃ 1. অ্যারের দৈর্ঘ্য [1, 1000] এর মধ্যে থাকবে। 2. অ্যারের উপাদানগুলি [-1000, 1000] এর মধ্যে থাকবে। 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"পূর্ণসংখ্যার একটি অ-খালি তালিকা দেওয়া হলে, এমন সমস্ত বিজোড় উপাদানের যোগফল ফেরত দিন যা এমনকি অবস্থানে রয়েছে। উদাহরণ সমাধান (([5, 8, 7, 1]) ==> 12 সমাধান (([3, 3, 3, 3, 3]) ==> 9 সমাধান (([30, 13, 24, 321]) ==> 0 \"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"একটি পূর্ণসংখ্যা arr এবং একটি পূর্ণসংখ্যা k দিয়ে একটি অ-খালি অ্যারে দেওয়া হয়েছে, arr এর প্রথম k উপাদান থেকে সর্বাধিক দুটি অঙ্ক সহ উপাদানগুলির যোগফলটি ফেরত দিন। উদাহরণঃ ইনপুটঃ arr = [111,21,3,4000,5,6,7,8,9], k = 4 আউটপুটঃ 24 # 21 + 3 এর যোগফল সীমাবদ্ধতাঃ 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr) \"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"একটি ধনাত্মক পূর্ণসংখ্যা n দেওয়া হলে, একটি সাজানো তালিকা ফেরত দিন যাতে কলাৎজ ক্রমের মধ্যে অদ্ভুত সংখ্যা রয়েছে। কলাৎজ অনুমান গণিতের একটি অনুমান যা নিম্নরূপ সংজ্ঞায়িত একটি ক্রমকে উদ্বেগ করেঃ যে কোনও ধনাত্মক পূর্ণসংখ্যা n দিয়ে শুরু করুন। তারপরে প্রতিটি পদ পূর্ববর্তী পদ থেকে নিম্নরূপ প্রাপ্ত হয়ঃ যদি পূর্ববর্তী পদটি সম, পরবর্তী পদটি পূর্ববর্তী পদটির অর্ধেক হয়। যদি পূর্ববর্তী পদটি অদ্ভুত হয়, পরবর্তী পদটি পূর্ববর্তী পদটির 3 গুণ এবং 1। অনুমানটি হ'ল n এর মান যাই হোক না কেন, ক্রমটি সর্বদা 1 এ পৌঁছে যাবে। দ্রষ্টব্যঃ 1. Collatz(1) হল [1]। 2. ফেরত তালিকা ক্রমবর্ধমান ক্রমে সাজানো হয়েছে। উদাহরণস্বরূপঃ get_odd_collatz(5) ফেরত দেয় [1, 5] 5 এর জন্য কলাৎজ ক্রমটি হল [5, 8, 16, 4, 2, 1], সুতরাং অদ্ভুত সংখ্যাগুলি কেবল 1, এবং 5 ।\"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"আপনাকে একটি ফাংশন লিখতে হবে যা একটি প্রদত্ত তারিখের স্ট্রিংকে বৈধতা দেয় এবং তারিখটি বৈধ হলে সত্য ফেরত দেয় অন্যথায় মিথ্যা। তারিখটি বৈধ যদি নিম্নলিখিত সমস্ত নিয়মগুলি সন্তুষ্ট হয়: 1. তারিখের স্ট্রিংটি খালি নয়। 2. মাসের জন্য দিনের সংখ্যা 1 এর চেয়ে কম বা 31 দিনের বেশি নয় 1,3,5,7,8,10,12। এবং মাসের জন্য দিনের সংখ্যা 1 এর চেয়ে কম বা 30 দিনের বেশি নয় 4,6,9,11। এবং মাসের জন্য দিনের সংখ্যা 1 এর চেয়ে কম বা 29 এর চেয়ে বেশি নয় 2। 3. মাসগুলি 1 এর চেয়ে কম বা 12 এর চেয়ে বেশি হওয়া উচিত নয় 4। তারিখটি ফর্ম্যাটে হওয়া উচিতঃ mm-dd-yyyy উদাহরণস্বরূপঃ valid_date (('03-11-2000') => true_date (('15-01-2012') => false_date (('04-01-2040') => false_date (('06-04-2020') => true_date (('06-04/2020') => false\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''একটি শব্দ স্ট্রিং দেওয়া, শূন্যস্থান দ্বারা বিভক্ত শব্দের একটি তালিকা ফেরত দিন, যদি টেক্সট কোন শূন্যস্থান বিদ্যমান আপনি কমা ',' যদি কোন কমা বিদ্যমান আপনি বর্ণমালার অদ্ভুত ক্রম সঙ্গে ছোট হাতের অক্ষর সংখ্যা ফেরত দেওয়া উচিত, ord (('a') = 0, ord (('b') = 1, ... ord (('z') = 25 উদাহরণ split_words ((\"হ্যালো বিশ্ব! \") â -> [\"হ্যালো\", \"বিশ্ব! \") split_words ((\"হ্যালো, বিশ্ব! \") â -> [\"হ্যালো\", \"বিশ্ব! \") split_words ((\"abcdef\") == 3 '''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''সংখ্যাগুলির একটি তালিকা দেওয়া হলে, তারা ক্রমবর্ধমান ক্রমে বা না সাজানো হোক না কেন, ফেরত দিন। যদি তালিকায় একই সংখ্যার 1 টিরও বেশি সদৃশ থাকে তবে মিথ্যা ফেরত দিন। কোনও নেতিবাচক সংখ্যা এবং কেবলমাত্র পূর্ণসংখ্যা ধরে নিন। উদাহরণ is_sorted ((([5]) â -> সত্য is_sorted (([1, 2, 3, 4, 5]) â -> সত্য is_sorted (([1, 2, 3, 4, 5, 6]) â -> মিথ্যা is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> সত্য is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> মিথ্যা is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> মিথ্যা is_sorted (([1, 2, 2, 2, 3, 3, 4]) â -> সত্য is_sorted (([1, 2, 2, 3, 4 -> মিথ্যা ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"আপনাকে দুটি অন্তর দেওয়া হয়েছে, যেখানে প্রতিটি অন্তরটি একটি পূর্ণসংখ্যা জোড়া। উদাহরণস্বরূপ, অন্তর = (শুরু, শেষ) = (1, 2) । প্রদত্ত অন্তরগুলি বন্ধ করা হয়েছে যার অর্থ হল যে অন্তর (শুরু, শেষ) উভয় শুরু এবং শেষ অন্তর্ভুক্ত করে। প্রতিটি প্রদত্ত অন্তরটির জন্য, এটি ধরে নেওয়া হয় যে এর শুরুটি এর শেষের চেয়ে কম বা সমান। আপনার কাজটি হ'ল এই দুটি অন্তরগুলির ছেদটির দৈর্ঘ্য একটি অগ্রিম সংখ্যা কিনা তা নির্ধারণ করা। উদাহরণস্বরূপ, অন্তরগুলির ছেদ (1, 3), (2, 4) হল (2, 3) যার দৈর্ঘ্য 1 যা একটি অগ্রিম সংখ্যা নয়। যদি ছেদটির দৈর্ঘ্য একটি অগ্রিম সংখ্যা হয় তবে \"হ্যাঁ\" ফেরত দিন, অন্যথায় \"না\" ফেরত দিন। যদি দুটি অন্তর ছেদ না করে তবে \"না\" ফেরত দিন। [ইনপুট / আউটপুট] নমুনাঃ ছেদ (((1, 2), (2, 3) ==> \"আন্তরসরণ-1, ((1), 4) ==> \"আন্তরসরণ-1, ((1) \" (<br>) ==> \"না - ((5, - ((((((((((((())))\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"আপনাকে পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে এবং আপনাকে পূর্ণসংখ্যার পরিমাণের যোগফলটি অ্যারেতে প্রতিটি সংখ্যার সমস্ত চিহ্নের পণ্য দ্বারা গুণিত করতে হবে, যা 1, -1 বা 0 দ্বারা প্রতিনিধিত্ব করা হয়। দ্রষ্টব্যঃ খালি অ্যারের জন্য None ফেরত দিন। উদাহরণঃ >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == None \"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"একটি গ্রিডের N সারি এবং N কলাম (N >= 2) এবং একটি ধনাত্মক পূর্ণসংখ্যা k দেওয়া হলে, গ্রিডের প্রতিটি কোষে একটি মান থাকে। [1, N * N] অন্তর্ভুক্তির মধ্যে প্রতিটি পূর্ণসংখ্যা গ্রিডের কোষে ঠিক একবার প্রদর্শিত হয়। আপনাকে গ্রিডের দৈর্ঘ্যের k এর সর্বনিম্ন পথটি খুঁজে বের করতে হবে। আপনি যে কোনও কোষ থেকে শুরু করতে পারেন এবং প্রতিটি পদক্ষেপে আপনি প্রতিবেশী কোষগুলির যে কোনওটিতে যেতে পারেন, অন্য কথায়, আপনি যে কোনও কোষের সাথে আপনার বর্তমান কোষের সাথে একটি প্রান্ত ভাগ করে নিতে পারেন। দয়া করে নোট করুন যে k এর দৈর্ঘ্যের একটি পথের অর্থ ঠিক k কোষগুলি (অবশ্যই আলাদা নয়) পরিদর্শন করা। আপনি গ্রিডের বাইরে যেতে পারবেন না। একটি পথ A (k এর দৈর্ঘ্য) একটি পথ B (k এর দৈর্ঘ্য) এর চেয়ে কম বলে বিবেচিত হয় যদি A এবং B এর মাধ্যমে যাওয়া কোষগুলির মানগুলির অর্ডারযুক্ত তালিকা তৈরি করার পরে (আসুন আমরা তাদের l_st এবং l_stA বলে থাকি), l_stA শব্দার্থিকভাবে l_stA এর চেয়ে কম হয়, অন্য কথায়, l_stB এর দৈর্ঘ্যের k এর সর্বনিম্ন পথটি খুঁজে বের করতে হবে। আপনি যে কোনও কোষ থেকে শুরু করতে পারেন, এবং প্রতিটি ধাপে আপনি যে কোনও প্রতিবেশী কোষের সাথে একটি প্রান্তিক প্রান্তিক পথ ভাগ করতে পারেন, অন্য কথায়, আপনি যে কোন কোষের সাথে একটি প্রান্তিক প্রান্তিক কোষের সাথে মিল রয়েছে এমন কোষের মধ্যে, যা আপনার বর্তমান কোষের সাথে একটি প্রান্তিক প্রান্তিক প্রান্তিক প্রান্তিক প্রান্তিক প্রান্তিক প্রান্তিক প্রান্তিক প্রান্তিক প্রান্তিক (অন্ত) একটি প্রান্তিক প্রান্তিক প্রান্তিক (অন্ত) । আপনি যে k = [4, [4, [4, k = l_1, l_1, l_1, l_1, l_1, l_2, l_2, l_2, l_2, l_2, l_2, l_2, l_2, l_2, l_2, [4, l_2, l_2, l_2, l_3, l_2, [] [] [] [] [] [] [] [] [] [] [\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"ফিবোনাচি ক্রমের কথা সবাই জানে, গত কয়েক শতাব্দীতে গণিতবিদরা এটি গভীরভাবে অধ্যয়ন করেছেন। তবে, যা মানুষ জানে না তা হল ট্রিবোনাচি ক্রম। ট্রিবোনাচি ক্রমটি পুনরাবৃত্তি দ্বারা সংজ্ঞায়িত করা হয়ঃ tri(1) = 3 tri(n) = 1 + n / 2, যদি n জোড়া হয়। tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), যদি n অদ্ভুত হয়। উদাহরণস্বরূপঃ tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 আপনাকে একটি অ-নতিবাচক পূর্ণসংখ্যা n দেওয়া হয়েছে, আপনাকে ট্রিবোনাচি ক্রমের প্রথম n + 1 সংখ্যার একটি তালিকা ফেরত দিতে হবে। উদাহরণঃ tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"একটি ধনাত্মক পূর্ণসংখ্যা n দেওয়া হলে, অদ্ভুত অঙ্কগুলির গুণফলটি ফেরত দিন। যদি সমস্ত অঙ্কগুলি জোড়া হয় তবে 0 ফেরত দিন। উদাহরণস্বরূপঃ অঙ্কগুলি ((1) == 1 অঙ্ক ((4) == 0 অঙ্ক ((235) == 15 \"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''একটি ফাংশন তৈরি করুন যা কেবল বর্গাকার বন্ধনীযুক্ত একটি স্ট্রিংকে ইনপুট হিসাবে নেয়। ফাংশনটি সত্য ফিরে আসতে হবে যদি এবং কেবলমাত্র যদি বন্ধনীগুলির একটি বৈধ উপসারণ থাকে যেখানে উপসারণের কমপক্ষে একটি বন্ধনী নেস্টেড থাকে। is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]]]]]]]]]]]]'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"আপনাকে একটি সংখ্যার তালিকা দেওয়া হয়েছে। আপনাকে প্রদত্ত তালিকার বর্গক্ষেত্রের সংখ্যার যোগফলটি ফেরত দিতে হবে, প্রথমে তালিকার প্রতিটি উপাদানকে উপরের int ((Ceiling) এ গোল করুন। উদাহরণঃ lst = [1,2,3] এর আউটপুট 14 হওয়া উচিত lst = [1,4,9] এর আউটপুট 98 হওয়া উচিত lst = [1,3,5,7] এর আউটপুট 84 হওয়া উচিত lst = [1.4,4.2,0] এর আউটপুট 29 হওয়া উচিত lst = [-2.4,1,1] এর আউটপুট 6 হওয়া উচিত \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''একটি ফাংশন তৈরি করুন যা সত্য ফেরত দেয় যদি প্রদত্ত স্ট্রিংয়ের শেষ অক্ষরটি একটি বর্ণমালা অক্ষর হয় এবং কোনও শব্দের অংশ নয়, এবং অন্যথায় মিথ্যা। দ্রষ্টব্যঃ \"শব্দ\" হ'ল স্পেস দ্বারা পৃথক অক্ষরের একটি গ্রুপ। উদাহরণঃ check_if_last_char_is_a_letter ((\"apple pie\") â -> False check_if_last_char_is_a_letter ((\"apple pi e\") â -> True check_if_last_char_is_a_letter ((\"apple pi e\") â -> False check_if_last_char_is_a_letter\" (((\") â -> False '''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"একটি ফাংশন তৈরি করুন যা এমন একটি উপাদানের বৃহত্তম সূচকটি ফেরত দেয় যা এর আগে থাকা উপাদানটির চেয়ে বড় বা সমান নয়। যদি এমন কোনও উপাদান না থাকে তবে -1 ফিরিয়ে দিন। প্রদত্ত অ্যারেটিতে ডুপ্লিকেট মান থাকবে না। উদাহরণঃ can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''একটি ফাংশন তৈরি করুন যা একটি টিপল (a, b) প্রদান করে, যেখানে 'a' হল নেগেটিভ পূর্ণসংখ্যার মধ্যে বৃহত্তম, এবং 'b' হল একটি তালিকার ইতিবাচক পূর্ণসংখ্যার মধ্যে ক্ষুদ্রতম। যদি কোন নেগেটিভ বা ইতিবাচক পূর্ণসংখ্যা না থাকে, তবে তাদের None হিসাবে ফেরত দিন। উদাহরণঃ largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"একটি ফাংশন তৈরি করুন যা পূর্ণসংখ্যা, ভাসমান, বা বাস্তব সংখ্যা প্রতিনিধিত্বকারী স্ট্রিং গ্রহণ করে এবং তার প্রদত্ত ভেরিয়েবল টাইপের বৃহত্তর পরিবর্তনশীলটি ফেরত দেয়। মানগুলি সমান হলে None ফেরত দিন। দ্রষ্টব্যঃ যদি একটি বাস্তব সংখ্যা একটি স্ট্রিং হিসাবে প্রতিনিধিত্ব করা হয়, তবে ভাসমান বিন্দু হতে পারে . অথবা , compare_one{1, 2.5) â -> 2.5 compare_one{1, \"2,3\") â -> \"2,3\" compare_one{5,1\", \"6\") â -> \"6\" compare_one{1\", 1) â -> None \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"প্রদত্ত সংখ্যা n কে ঠিক 4 টি ধনাত্মক সম সংখ্যার যোগফল হিসাবে লিখতে পারে কিনা তা মূল্যায়ন করুন উদাহরণ is_equal_to_sum_even ((4) == মিথ্যা is_equal_to_sum_even ((6) == মিথ্যা is_equal_to_sum_even ((8) == সত্য \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"ব্রাজিলিয়ান ফ্যাক্টরিয়ালটি সংজ্ঞায়িত করা হয়েছেঃ ব্রাজিলিয়ান_ফ্যাক্টরিয়াল ((n) = n! * (n-1)! * (n-2)! * ... * 1! যেখানে n > 0 উদাহরণস্বরূপঃ >>> special_factorial ((4) 288 ফাংশনটি ইনপুট হিসাবে একটি পূর্ণসংখ্যা গ্রহণ করবে এবং এই পূর্ণসংখ্যাটির বিশেষ ফ্যাক্টরিয়ালটি ফিরিয়ে দেবে। \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_উদাহরণ-৩সট দেওয়া হলে, এর মধ্যে সমস্ত স্পেসকে আন্ডারস্কোর দিয়ে প্রতিস্থাপন করুন, এবং যদি একটি স্ট্রিংয়ে 2 টিরও বেশি পরপর স্পেস থাকে তবে সমস্ত পরপর স্পেসকে - fix_spaces দিয়ে প্রতিস্থাপন করুন। (উদাহরণস্বরূপ) == \"উদাহরণস্বরূপ\" fix_spaces (উদাহরণস্বরূপ) == \"উদাহরণস্বরূপ\" fix_spaces (উদাহরণস্বরূপ) == \"উদাহরণস্বরূপ\" fix_spaces (উদাহরণস্বরূপ) == \"উদাহরণস্বরূপ\" fix_spaces (উদাহরণস্বরূপ) == \"উদাহরণস্বরূপ\" fix_spaces (উদাহরণস্বরূপ) == \"উদাহরণস্বরূপ\" (উদাহরণস্বরূপ) == \"উদাহরণস্বরূপ\" (উদাহরণস্বরূপ) == \"উদাহরণস্বরূপ\" (উদাহরণস্বরূপ) == \"উদাহরণস্বরূপ\" (উদাহরণস্বরূপ) == \"উদাহরণস্বরূপ\" (উদাহরণস্বরূপ) == \"উদাহরণস্বরূপ\" (উদাহরণস্বরূপ) == \"উদাহরণস্বরূপ\")\"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"একটি ফাংশন তৈরি করুন যা একটি ফাইলের নামের প্রতিনিধিত্বকারী একটি স্ট্রিং নেয় এবং যদি ফাইলের নামটি বৈধ হয় তবে 'হ্যাঁ' ফেরত দেয় এবং অন্যথায় 'না' ফেরত দেয়। একটি ফাইলের নামটি বৈধ বলে বিবেচিত হয় যদি এবং কেবলমাত্র যদি ফাইলের নামের মধ্যে তিনটি অঙ্কের বেশি ('0'-'9') থাকে তবে এবং যদি নিম্নলিখিত শর্তগুলি পূরণ করা হয়ঃ - ফাইলের নামটিতে ঠিক একটি বিন্দু '.' - ফাইলের নামের আগে সাবস্ট্রিংটি খালি হওয়া উচিত নয় এবং এটি ল্যাটিন আলফাবেটের একটি অক্ষর দিয়ে শুরু হওয়া উচিত ('a'-'z' এবং 'A'Z'-) । - বিন্দুটির পরে সাবস্ট্রিংটি এইগুলির মধ্যে একটি হওয়া উচিতঃ ['txt', 'exe', 'll'] উদাহরণঃ file_name_check\"{example.txt.txt\") # => 'হ্যাঁ' file_name_check\"{example.txt.tll1} => 'না' (নামটি ল্যাটিন আলফা দিয়ে শুরু হওয়া উচিত) #\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" এই ফাংশনটি পূর্ণসংখ্যার একটি তালিকা গ্রহণ করবে। তালিকার সমস্ত এন্ট্রিগুলির জন্য, ফাংশনটি পূর্ণসংখ্যা এন্ট্রিটি বর্গক্ষেত্র করবে যদি এর সূচকটি 3 এর একটি গুণক হয় এবং পূর্ণসংখ্যা এন্ট্রিটি ঘন করবে যদি এর সূচকটি 4 এর একটি গুণক হয় এবং 3 এর একটি গুণক নয়। ফাংশনটি তালিকার এন্ট্রিগুলি পরিবর্তন করবে না যার সূচকগুলি 3 বা 4 এর একটি গুণক নয়। ফাংশনটি তারপরে সমস্ত এন্ট্রিগুলির যোগফলটি ফিরিয়ে দেবে। উদাহরণঃ lst = [1,2,3] এর জন্য আউটপুট 6 হওয়া উচিত lst = [] এর জন্য আউটপুট 0 হওয়া উচিত lst = [-1,-5,2,-1,-5] এর জন্য আউটপুট -126 হওয়া উচিত \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"আপনাকে একটি বাক্য প্রতিনিধিত্বকারী একটি স্ট্রিং দেওয়া হয়েছে, বাক্যে একটি স্পেস দ্বারা পৃথক কিছু শব্দ রয়েছে এবং আপনাকে একটি স্ট্রিং ফিরিয়ে দিতে হবে যাতে মূল বাক্যের শব্দ রয়েছে, যার দৈর্ঘ্যগুলি অগ্রিম সংখ্যা, নতুন স্ট্রিংয়ের শব্দের ক্রমটি মূলটির মতো একই হওয়া উচিত Example1: ইনপুটঃ বাক্য = \"এটি একটি পরীক্ষা\" আউটপুটঃ \"is\" Example2: ইনপুটঃ বাক্য = \"চলুন সাঁতার কাটতে যাই\" আউটপুটঃ \"go for\" সীমাবদ্ধতাঃ * 1 <= len(sentence) <= 100 * বাক্যটিতে কেবলমাত্র অক্ষর রয়েছে \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"আপনার কাজ হল এমন একটি ফাংশন বাস্তবায়ন করা যা এক্সপ্রেশন x * nকে সরল করে দেবে। ফাংশনটি True ফেরত দেয় যদি x * n একটি পূর্ণসংখ্যা এবং False অন্যথায়। x এবং n উভয়ই একটি ভগ্নাংশের স্ট্রিং উপস্থাপনা এবং নিম্নলিখিত বিন্যাস রয়েছে, <numerator>/<denominator> যেখানে উভয় সংখ্যা এবং নাম্বার ধনাত্মক পূর্ণসংখ্যা। আপনি ধরে নিতে পারেন যে x এবং n বৈধ ভগ্নাংশ এবং নাম্বার হিসাবে শূন্য নেই। সরল করুন (((\"1/5\", \"5/1\") = সত্য সরল করুন (((\"1/6\", \"2/1\") = মিথ্যা সরল করুন (((\"7/10\", \"10/2\") = মিথ্যা \"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"একটি ফাংশন লিখুন যা পূর্ণসংখ্যার তালিকাকে তাদের অঙ্কগুলির সমষ্টি অনুসারে ক্রমবর্ধমান ক্রমে সাজায়। দ্রষ্টব্যঃ যদি তাদের অঙ্কগুলির অনুরূপ সমষ্টি সহ বেশ কয়েকটি আইটেম থাকে তবে তাদের মূল তালিকার সূচকের ভিত্তিতে তাদের অর্ডার করুন। উদাহরণস্বরূপঃ >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"একটি ফাংশন লিখুন যা সংখ্যার একটি অ্যারেকে ইনপুট হিসাবে নেয় এবং অ্যারেতে এমন উপাদানগুলির সংখ্যা ফেরত দেয় যা 10 এর চেয়ে বেশি এবং একটি সংখ্যার প্রথম এবং শেষ উভয় অঙ্কই অদ্ভুত (1, 3, 5, 7, 9) । উদাহরণস্বরূপঃ specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"আপনাকে একটি ধনাত্মক পূর্ণসংখ্যা n দেওয়া হয়েছে। আপনাকে দৈর্ঘ্য n এর একটি পূর্ণসংখ্যা অ্যারে তৈরি করতে হবে। প্রতিটি i (1 ‰¤ i ‰¤ n) এর জন্য, a[i] = i * i - i + 1 এর মান। a এর ট্রিপলগুলির সংখ্যা (a[i], a[j], a[k]) ফেরত দিন যেখানে i < j < k, এবং a[i] + a[j] + a[k] 3 এর গুণিতক। উদাহরণঃ ইনপুটঃ n = 5 আউটপুটঃ 1 ব্যাখ্যাঃ a = [1, 3, 7, 13, 21] একমাত্র বৈধ ট্রিপল হল (1, 7, 13) ।\"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''আমাদের সৌরজগতের আটটি গ্রহ রয়েছেঃ সূর্যের নিকটতম গ্রহটি হ'ল বুধ, পরবর্তীটি হ'ল শুক্র, তারপরে পৃথিবী, মঙ্গল, বৃহস্পতি, শনি, ইউরেনাস, নেপচুন। এমন একটি ফাংশন লিখুন যা দুটি গ্রহের নামকে স্ট্রিং প্ল্যানেট 1 এবং প্ল্যানেট 2 হিসাবে গ্রহণ করে। ফাংশনটি একটি টিউপেল ফিরিয়ে দেবে যার সমস্ত গ্রহের কক্ষপথ গ্রহ 1 এর কক্ষপথ এবং গ্রহ 2 এর কক্ষপথের মধ্যে অবস্থিত, সূর্যের নিকটবর্তীতার ভিত্তিতে সাজানো। যদি গ্রহ 1 বা গ্রহ 2 সঠিক গ্রহের নাম না হয় তবে ফাংশনটি একটি খালি টিউপেল ফিরিয়ে দেবে। উদাহরণ bf \"(জুপিতার\", \"নেপচুন\") ==> (\"শনি\", \"ইউরেনাস\") bf (((\"পৃথিবী\", \"বুধ\") ==> (\"ভানুস\", \"পৃথিবী\", \"মঙ্গল\", \"জুপিতার\", \"সৌর\") ]]'''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"একটি ফাংশন লিখুন যা স্ট্রিংগুলির একটি তালিকা প্যারামিটার হিসাবে গ্রহণ করে, এর থেকে অদ্ভুত দৈর্ঘ্যের স্ট্রিংগুলি মুছে ফেলে এবং ফলাফল তালিকাটি একটি সাজানো ক্রম সহ ফেরত দেয়। তালিকাটি সর্বদা স্ট্রিংগুলির একটি তালিকা এবং কখনও সংখ্যার অ্যারে নয় এবং এতে ডুপ্লিকেট থাকতে পারে। তালিকার ক্রমটি প্রতিটি শব্দের দৈর্ঘ্যের দ্বারা উত্থিত হওয়া উচিত এবং আপনাকে সেই নিয়ম অনুসারে সাজানো তালিকাটি ফেরত দিতে হবে। যদি দুটি শব্দের একই দৈর্ঘ্য থাকে তবে তালিকাটি বর্ণানুক্রমিকভাবে সাজান। ফাংশনটি সাজানো ক্রমের একটি স্ট্রিংয়ের তালিকা ফেরত দিতে হবে। আপনি ধরে নিতে পারেন যে সমস্ত শব্দের একই দৈর্ঘ্য থাকবে। উদাহরণস্বরূপঃ assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"a\", \"aaa\", \"cd\" => \"cd \"]\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"একটি সহজ প্রোগ্রাম যা n একটি প্রধান সংখ্যা হলে x এর মান ফেরত দিতে হবে এবং অন্যথায় y এর মান ফেরত দিতে হবে। উদাহরণঃ x_or_y(7, 34, 12) == 34 x_or_y(15, 8, 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''সংখ্যাগুলির একটি তালিকা দেওয়া হলে, তালিকার অদ্ভুত সংখ্যার বর্গক্ষেত্রের যোগফলটি ফেরত দিন। নেতিবাচক বা অ-পূর্ণ সংখ্যা উপেক্ষা করুন। double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 ইনপুট তালিকাটি খালি থাকলে, 0 ফেরত দিন '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"আমি মনে করি আমরা সবাই সেই অনুভূতিটি মনে করি যখন কিছু দীর্ঘ প্রতীক্ষিত ঘটনার ফলাফল অবশেষে জানা যায়। সেই মুহুর্তে আপনার যে অনুভূতি এবং চিন্তাভাবনা রয়েছে তা অবশ্যই নোট করা এবং তুলনা করার মতো। আপনার কাজটি হ'ল একজন ব্যক্তি বেশ কয়েকটি ম্যাচের ফলাফল সঠিকভাবে অনুমান করেছেন কিনা তা নির্ধারণ করা। আপনাকে সমান দৈর্ঘ্যের স্কোর এবং অনুমানের দুটি অ্যারে দেওয়া হয়, যেখানে প্রতিটি সূচক একটি মিল দেখায়। একই দৈর্ঘ্যের একটি অ্যারে ফেরত দিন যা প্রতিটি অনুমান কতটা দূরে ছিল তা নির্দেশ করে। যদি তারা সঠিকভাবে অনুমান করে থাকে তবে মানটি 0 হয় এবং যদি তা না হয় তবে মানটি অনুমান এবং স্কোরের মধ্যে নিখুঁত পার্থক্য। উদাহরণঃ (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,0,3,3] তুলনা করুন (([0,5,0,4,0,1,0,2,4]) -> [4,4,0,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"আপনাকে একটি ক্লাসের নাম (একটি স্ট্রিং) এবং এক্সটেনশনের একটি তালিকা দেওয়া হবে। এক্সটেনশনের শক্তি নিম্নরূপ: CAP এক্সটেনশনের নামের বড় অক্ষরের সংখ্যা হতে দিন, এবং SM এক্সটেনশনের নামের ছোট অক্ষরের সংখ্যা হতে দিন, শক্তিটি ভগ্নাংশ CAP - SM দ্বারা দেওয়া হয়। আপনার সবচেয়ে শক্তিশালী এক্সটেনশনটি খুঁজে বের করা উচিত এবং এই ফরম্যাটে একটি স্ট্রিং ফেরত দেওয়া উচিতঃ ClassName.StrongestExtensionName। যদি একই শক্তির সাথে দুটি বা ততোধিক এক্সটেনশন থাকে তবে আপনাকে তালিকায় প্রথম আসাটি বেছে নিতে হবে। উদাহরণস্বরূপ, যদি আপনাকে ক্লাস এবং এক্সটেনশনের একটি তালিকা হিসাবে \"স্লাইস\" দেওয়া হয়ঃ ['SEviviSNGliCes', 'Cheese', 'StuFfed'] তবে আপনাকে 'Slices.SEviSNGliCes' ফেরত দিতে হবে কারণ 'SviSNGliCes' 'mySviSNGliCes' (mySviSNGliCes') এক্সটেনশনটি সবচেয়ে শক্তিশালী (অর্থাৎ 'AA'_Class' StrongestExtension_', উদাহরণস্বরূপ 'AA'_Class' }}) ।\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"আপনাকে ২টি শব্দ দেওয়া হয়েছে। আপনাকে True ফেরত দিতে হবে যদি দ্বিতীয় শব্দ বা এর যেকোন ঘূর্ণন প্রথম শব্দের একটি সাবস্ট্রিং হয় cycpattern_check(\"abcd\",\"abd\") => False cycpattern_check(\"hello\",\"ell\") => True cycpattern_check(\"whassup\",\"psus\") => False cycpattern_check\"abab\",\"baa\") => True cycpattern_check(\"efef\",\"eeff\") => False cycpattern_check\"(hims\",\"simen\") => True \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"একটি পূর্ণসংখ্যা দেওয়া হলে, একটি টিপল ফেরত দিন যার যথাক্রমে জোড়া এবং অজোড়া অঙ্ক রয়েছে। উদাহরণঃ এমনকি_অদ্ভুত_সংখ্যা ((-12) ==> (1, 1) এমনকি_অদ্ভুত_সংখ্যা ((123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"একটি ধনাত্মক পূর্ণসংখ্যা দেওয়া হলে, তার রোমান সংখ্যা সমতুল্য একটি স্ট্রিং হিসাবে পান এবং এটি ছোট হাতের অক্ষরে ফেরত দিন। সীমাবদ্ধতাঃ 1 <= num <= 1000 উদাহরণঃ >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''একটি ত্রিভুজের তিনটি পাশের দৈর্ঘ্য দেওয়া হয়েছে। যদি তিনটি পাশ একটি ডান কোণযুক্ত ত্রিভুজ গঠন করে তবে সত্য ফেরত দিন, অন্যথায় মিথ্যা। একটি ডান কোণযুক্ত ত্রিভুজ এমন একটি ত্রিভুজ যা একটি কোণ ডান কোণ বা 90 ডিগ্রি। উদাহরণঃ right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"একটি ফাংশন লিখুন যা স্ট্রিংগুলির একটি তালিকা গ্রহণ করে। তালিকায় বিভিন্ন শব্দ রয়েছে। সর্বাধিক সংখ্যক অনন্য অক্ষর সহ শব্দটি ফেরত দিন। যদি একাধিক স্ট্রিংগুলিতে সর্বাধিক সংখ্যক অনন্য অক্ষর থাকে তবে এটি পাঠ্যক্রমের ক্রমে প্রথম আসে। find_max (([\"name\", \"of\", \"string\"]) == \"string\" find_max (([\"name\", \"enam\", \"game\"]) == \"enam\" find_max (([\"aaaaaaa\", \"bb\" , \"cc\"]) == \"\"aaaaaaa\" \"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"আপনি একটি ক্ষুধার্ত খরগোশ, এবং আপনি ইতিমধ্যে গাজর একটি নির্দিষ্ট সংখ্যা খাওয়া হয়েছে, কিন্তু এখন আপনি আরো গাজর খাওয়া প্রয়োজন দিনের খাবার সম্পূর্ণ করতে. আপনি একটি অ্যারে ফিরে আসা উচিত [আপনার খাবার পরে খাওয়া গাজর মোট সংখ্যা, আপনার খাবার পরে বাকি গাজর সংখ্যা ] যদি যথেষ্ট বাকি গাজর নেই, আপনি সব বাকি গাজর খাওয়া হবে, কিন্তু এখনও ক্ষুধার্ত হবে. উদাহরণঃ * খাওয়া ((5, 6, 10) -> [11, 4] * খাওয়া ((4, 8, 9) -> [12, 1] * খাওয়া ((1, 10, 10) -> [11, 0] * খাওয়া ((2, 11, 5) -> [7, 0] ভেরিয়েবলঃ @number: গাজর সংখ্যা যে আপনি খাওয়া হয়েছে পূর্ণসংখ্যা. @need: গাজর সংখ্যা যে আপনি খেতে হবে পূর্ণসংখ্যা. @remaining:: অবশিষ্ট গাজর সংখ্যা যে স্টক বিদ্যমান পূর্ণসংখ্যা. Constrain: * 0= <= 0 * 1000 <= 0 * 0 = <= 1000 অবশিষ্ট গাজর প্রয়োজন <= 1000 মজা আছে = 1000:)\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"দুটি তালিকা অপারেটর এবং অপারেন্ড দেওয়া হয়েছে। প্রথম তালিকায় মৌলিক বীজগণিত অপারেশন রয়েছে এবং দ্বিতীয় তালিকায় পূর্ণসংখ্যার একটি তালিকা রয়েছে। বীজগণিতের এক্সপ্রেশন তৈরি করতে এবং এই এক্সপ্রেশনের মূল্যায়নটি ফেরত দিতে দুটি প্রদত্ত তালিকা ব্যবহার করুন। মৌলিক বীজগণিত অপারেশনঃ সংযোজন (+) বিয়োগ (-)) গুণ ( *) তল বিভাজন ( // ) এক্সপোনেন্টিশন ( ** উদাহরণ) অপারেটর['+', '*', '-'] অ্যারে = [2, 3, 4, 5] ফলাফল = 2 + 3 * 4 - 5 => ফলাফল = 9 নোটঃ অপারেটর তালিকার দৈর্ঘ্য অপারেন্ড তালিকা বিয়োগ একের সমান। অপারেন্ডটি অ-নেগেটিভ পূর্ণসংখ্যার একটি তালিকা। অপারেটর তালিকার কমপক্ষে একটি অপারেটর রয়েছে এবং অপারেন্ড তালিকার কমপক্ষে দুটি অপারেন্ড রয়েছে। \"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"আপনাকে একটি স্ট্রিং s দেওয়া হয়েছে। যদি s[i] একটি অক্ষর হয়, তবে এর কেসটি নিম্ন থেকে উপরের দিকে বা বিপরীতভাবে বিপরীত করুন, অন্যথায় এটি যেমন আছে তেমন রাখুন। যদি স্ট্রিংটিতে কোনও অক্ষর না থাকে তবে স্ট্রিংটি বিপরীত করুন। ফাংশনটি ফলাফলযুক্ত স্ট্রিংটি ফিরিয়ে দেবে। উদাহরণ solve ((\"1234\") = \"4321\" solve ((\"ab\") = \"AB\" solve ((\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"একটি স্ট্রিং 'text' দেওয়া হলে, এর md5 হ্যাশ সমতুল্য স্ট্রিং ফেরত দিন। যদি 'text' একটি খালি স্ট্রিং হয়, None ফেরত দিন। >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "ben_Beng",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"দুটি ধনাত্মক পূর্ণসংখ্যা a এবং b দেওয়া হলে, a এবং b এর মধ্যে এমনকি অঙ্কগুলিকে ক্রমবর্ধমান ক্রমে ফেরত দিন। উদাহরণস্বরূপঃ generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]