[{"task_id":"HumanEval_0","nl":"pan_Guru","pl":"pl","prompt":"# ਦਿੱਤਾ ਗਿਆ ਥ੍ਰੈਸ਼ਹੋਲਡ।# ਜਾਂਚ ਕਰੋ ਕਿ ਕੀ ਦਿੱਤੇ ਗਏ ਨੰਬਰਾਂ ਦੇ ਐਰੇ ਵਿੱਚ, ਕੋਈ ਦੋ ਨੰਬਰ ਇੱਕ ਦੂਜੇ ਦੇ ਨੇੜੇ ਹਨ # >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n# \"\"\n# >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# 1\nsub has_close_elements {\n    my($numbers, $threshold) = @_;\n","canonical_solution":"sub has_close_elements {\n    my($numbers, $threshold) = @_;\n    \n    for my $i (0 .. @$numbers - 2) {\n        for my $j ($i + 1 .. @$numbers - 1) {\n            if (abs($numbers->[$i] - $numbers->[$j]) < $threshold) {\n                return 1;\n            }\n        }\n    }\n    return \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&has_close_elements;\n        if(eq_deeply($candidate->([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 5.9, 4.0, 5.0], 0.95),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 5.9, 4.0, 5.0], 0.8),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.1, 2.2, 3.1, 4.1, 5.1], 1.0),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_1","nl":"pan_Guru","pl":"pl","prompt":"# ਇਨਪੁਟ ਸਤਰ ਵਿੱਚ ਕਿਸੇ ਵੀ ਸਪੇਸ ਨੂੰ ਅਣਡਿੱਠਾ ਕਰੋ।# ਵੱਖਰੇ ਸਮੂਹ ਸੰਤੁਲਿਤ ਹਨ (ਹਰੇਕ ਖੁੱਲ੍ਹੇ ਬਰੇਸ ਸਹੀ ਤਰ੍ਹਾਂ ਬੰਦ ਹੈ) ਅਤੇ ਇਕ ਦੂਜੇ ਦੇ ਅੰਦਰ ਨਹੀਂ ਹਨ # ਉਹਨਾਂ ਨੂੰ ਵੱਖਰੇ ਸਤਰਾਂ ਵਿੱਚ ਵੰਡੋ ਅਤੇ ਉਹਨਾਂ ਦੀ ਐਰੇ ਵਾਪਸ ਕਰੋ.# ਇਸ ਫੰਕਸ਼ਨ ਲਈ ਇਨਪੁਟ ਇੱਕ ਸਤਰ ਹੈ ਜਿਸ ਵਿੱਚ ਨੇਸਟਡ ਬਰੈਂਚੈੱਸ ਦੇ ਕਈ ਸਮੂਹ ਹਨ. ਤੁਹਾਡਾ ਟੀਚਾ ਹੈ # >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n# [\"()\", \"(())\", \"(()())\"]\nsub separate_paren_groups {\n    my($paren_string) = @_;\n","canonical_solution":"sub separate_paren_groups {\n    my ($paren_string) = @_;\n    $paren_string =~ s\/\\s+\/\/g;  # Remove all spaces\n    my @groups;\n    my $balance = 0;\n    my $current_group = \"\";\n    \n    foreach my $char (split \/\/, $paren_string) {\n        if ($char eq '(') {\n            $balance++;\n        }\n        if ($char eq ')') {\n            $balance--;\n        }\n        $current_group .= $char;\n        if ($balance == 0 && $current_group ne \"\") {\n            push @groups, $current_group;\n            $current_group = \"\";\n        }\n    }\n    \n    return \\@groups;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&separate_paren_groups;\n        if(eq_deeply($candidate->(\"(()()) ((())) () ((())()())\"),[\"(()())\", \"((()))\", \"()\", \"((())()())\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"() (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"(()(())((())))\"),[\"(()(())((())))\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"( ) (( )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_2","nl":"pan_Guru","pl":"pl","prompt":"# ਸੰਖਿਆ ਦਾ ਦਸ਼ਮਲਵ ਹਿੱਸਾ ਵਾਪਸ ਕਰੋ।# (ਬਚਿਆ ਹਿੱਸਾ ਹਮੇਸ਼ਾ 1 ਤੋਂ ਛੋਟਾ ਹੁੰਦਾ ਹੈ) ।# ਅਤੇ ਪੂਰਨ ਅੰਕ ਭਾਗ (ਦਿੱਤੇ ਗਏ ਨੰਬਰ ਤੋਂ ਛੋਟਾ ਸਭ ਤੋਂ ਵੱਡਾ ਪੂਰਨ ਅੰਕ) ਅਤੇ ਦਸ਼ਮਲਵ # ਇੱਕ ਸਕਾਰਾਤਮਕ ਫਲੋਟਿੰਗ ਪੁਆਇੰਟ ਨੰਬਰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸ ਨੂੰ  ਵਿੱਚ ਵੰਡਿਆ ਜਾ ਸਕਦਾ ਹੈ# >>> truncate_number(3.5)\n# 0.5\nsub truncate_number {\n    my($number) = @_;\n","canonical_solution":"sub truncate_number {\n    my($number) = @_;\n    my $integer_part = int($number);\n    my $decimal_part = $number - $integer_part;\n    return $decimal_part;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&truncate_number;\n        if(eq_deeply($candidate->(3.5),0.5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1.25),0.25)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(123.0),0.0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_3","nl":"pan_Guru","pl":"pl","prompt":"# ਉਸ ਬਿੰਦੂ ਤੇ ਫੰਕਸ਼ਨ ਨੂੰ 1 ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ. ਨਹੀਂ ਤਾਂ ਇਹ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ''.# ਜ਼ੀਰੋ ਸੰਤੁਲਨ. ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਪਤਾ ਲਗਾਉਣਾ ਹੈ ਕਿ ਕਿਸੇ ਵੀ ਸਮੇਂ ਖਾਤੇ ਦਾ ਸੰਤੁਲਨ ਜ਼ੀਰੋ ਤੋਂ ਹੇਠਾਂ ਆ ਜਾਂਦਾ ਹੈ, ਅਤੇ # ਤੁਹਾਨੂੰ ਇੱਕ ਬੈਂਕ ਖਾਤੇ ਵਿੱਚ ਜਮ੍ਹਾਂ ਅਤੇ ਕਢਵਾਉਣ ਦੀਆਂ ਕਾਰਵਾਈਆਂ ਦੀ ਇੱਕ ਲੜੀ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ ਜੋ  ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦੀ ਹੈ# >>> below_zero([1, 2, 3])\n# \"\"\n# >>> below_zero([1, 2, -4, 5])\n# 1\nsub below_zero {\n    my($operations) = @_;\n","canonical_solution":"sub below_zero {\n    my ($operations) = @_;\n    my $balance = 0;\n    \n    for my $operation (@$operations) {\n        $balance += $operation;\n        if ($balance < 0) {\n            return 1;\n        }\n    }\n    \n    return '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&below_zero;\n        if(eq_deeply($candidate->([]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, -3, 1, 2, -3]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, -4, 5, 6]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -1, 2, -2, 5, -5, 4, -4]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -1, 2, -2, 5, -5, 4, -5]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -2, 2, -2, 5, -5, 4, -4]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_4","nl":"pan_Guru","pl":"pl","prompt":"# MAD = ਔਸਤ ∙ x - x_mean ∙# ਤੱਤ ਅਤੇ ਇੱਕ ਕੇਂਦਰ ਬਿੰਦੂ (ਇਸ ਕੇਸ ਵਿੱਚ ਮਤਲਬ): # ਮੱਧਮ ਅਸਲੀ ਭਟਕਣਾ ਹਰੇਕ ਵਿਚਕਾਰ ਔਸਤ ਅਸਲੀ ਅੰਤਰ ਹੈ।# ਇਸ ਡੇਟਾ ਸੈੱਟ ਦੇ ਮੱਧ ਦੇ ਆਲੇ ਦੁਆਲੇ.# ਇਨਪੁਟ ਨੰਬਰਾਂ ਦੀ ਇੱਕ ਦਿੱਤੀ ਗਈ ਐਰੇ ਲਈ, ਮੱਧਮ ਪੂਰਨ ਭਟਕਣ ਦੀ ਗਣਨਾ ਕਰੋ।# >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n# 1.0\nsub mean_absolute_deviation {\n    my($numbers) = @_;\n","canonical_solution":"sub mean_absolute_deviation {\n    my ($numbers) = @_;\n    my $n = scalar @$numbers;\n    return 0 if $n == 0;\n\n    # Calculate mean\n    my $sum = 0;\n    $sum += $_ for @$numbers;\n    my $mean = $sum \/ $n;\n\n    # Calculate mean absolute deviation\n    my $total_deviation = 0;\n    $total_deviation += abs($_ - $mean) for @$numbers;\n    return $total_deviation \/ $n;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&mean_absolute_deviation;\n        if(eq_deeply($candidate->([1.0, 2.0]),0.5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0]),1.0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0]),1.2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_5","nl":"pan_Guru","pl":"pl","prompt":"# ਇਨਪੁਟ ਐਰੇ ਦੇ ਹਰ ਦੋ ਲਗਾਤਾਰ ਤੱਤਾਂ ਵਿਚਕਾਰ ਇੱਕ ਨੰਬਰ 'ਡਿਲਿਮੀਟਰ' ਪਾਓ ∀numbers' # >>> intersperse([], 4)\n# []\n# >>> intersperse([1, 2, 3], 4)\n# [1, 4, 2, 4, 3]\nsub intersperse {\n    my($numbers, $delimeter) = @_;\n","canonical_solution":"my @result;\n    for (my $i = 0; $i < @$numbers; $i++) {\n        push @result, $numbers->[$i];\n        push @result, $delimeter if $i < @$numbers - 1;\n    }\n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&intersperse;\n        if(eq_deeply($candidate->([], 7),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 3, 2], 8),[5, 8, 6, 8, 3, 8, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 2, 2], 2),[2, 2, 2, 2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_6","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਵਜੋਂ (() (()) ਵਿੱਚ ਵੱਧ ਤੋਂ ਵੱਧ ਦੋ ਪੱਧਰ ਦੇ ਨੇਸਟਿੰਗ ਹੁੰਦੇ ਹਨ ਜਦੋਂ ਕਿ ((())) ਵਿੱਚ ਤਿੰਨ ਹੁੰਦੇ ਹਨ। # ਹਰੇਕ ਸਮੂਹ ਲਈ, ਬਰੈਂਚਜ਼ ਦੇ ਗੁੰਝਲਦਾਰ ਪੱਧਰ ਦਾ ਸਭ ਤੋਂ ਡੂੰਘਾ ਪੱਧਰ ਆਉਟਪੁੱਟ ਕਰੋ.# ਇਸ ਫੰਕਸ਼ਨ ਦਾ ਇੰਪੁੱਟ ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਗਏ ਨੇਸਟਡ ਬਰੈਂਚੈਸ ਲਈ ਮਲਟੀਪਲ ਗਰੁੱਪਾਂ ਦੀ ਨੁਮਾਇੰਦਗੀ ਕਰਨ ਵਾਲੀ ਇੱਕ ਸਤਰ ਹੈ।# >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n# [2, 3, 1, 3]\nsub parse_nested_parens {\n    my($paren_string) = @_;\n","canonical_solution":"sub parse_nested_parens {\n    my($paren_string) = @_;\n    my @groups = split \/ \/, $paren_string;\n    my @depths;\n\n    foreach my $group (@groups) {\n        my $max_depth = 0;\n        my $current_depth = 0;\n        foreach my $char (split \/\/, $group) {\n            if ($char eq '(') {\n                $current_depth++;\n                if ($current_depth > $max_depth) {\n                    $max_depth = $current_depth;\n                }\n            } elsif ($char eq ')') {\n                $current_depth--;\n            }\n        }\n        push @depths, $max_depth;\n    }\n    \n    return \\@depths;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&parse_nested_parens;\n        if(eq_deeply($candidate->(\"(()()) ((())) () ((())()())\"),[2, 3, 1, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"() (()) ((())) (((())))\"),[1, 2, 3, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"(()(())((())))\"),[4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_7","nl":"pan_Guru","pl":"pl","prompt":"# ਸਤਰਾਂ ਦੀ ਇਨਪੁਟ ਐਰੇ ਨੂੰ ਕੇਵਲ ਉਹਨਾਂ ਲਈ ਫਿਲਟਰ ਕਰੋ ਜਿਨ੍ਹਾਂ ਵਿੱਚ ਦਿੱਤੀ ਗਈ ਸਬਸਟ੍ਰਿੰਗ ਹੈ # >>> filter_by_substring([], \"a\")\n# []\n# >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"bacd\", \"array\"]\nsub filter_by_substring {\n    my($strings, $substring) = @_;\n","canonical_solution":"sub filter_by_substring {\n    my ($strings, $substring) = @_;\n    my @filtered = grep { index($_, $substring) != -1 } @$strings;\n    return \\@filtered;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&filter_by_substring;\n        if(eq_deeply($candidate->([], \"john\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"),[\"xxx\", \"xxxAAA\", \"xxx\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"),[\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"),[\"grunt\", \"prune\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_8","nl":"pan_Guru","pl":"pl","prompt":"# ਖਾਲੀ ਜੋੜ 0 ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ ਅਤੇ ਖਾਲੀ ਉਤਪਾਦ 1 ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।# ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਦਿੱਤੇ ਐਰੇ ਲਈ, ਇੱਕ ਐਰੇ ਵਿੱਚ ਸਾਰੇ ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਜੋੜ ਅਤੇ ਇੱਕ ਉਤਪਾਦ ਤੋਂ ਬਣਿਆ ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰੋ.# >>> sum_product([])\n# [0, 1]\n# >>> sum_product([1, 2, 3, 4])\n# [10, 24]\nsub sum_product {\n    my($numbers) = @_;\n","canonical_solution":"sub sum_product {\n    my ($numbers) = @_;\n    my $sum = 0;\n    my $product = 1;\n    \n    foreach my $num (@$numbers) {\n        $sum += $num;\n        $product *= $num;\n    }\n    \n    return [$sum, $product];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sum_product;\n        if(eq_deeply($candidate->([]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1, 1]),[3, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100, 0]),[100, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 5, 7]),[15, 105])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([10]),[10, 10])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_9","nl":"pan_Guru","pl":"pl","prompt":"# ਕ੍ਰਮ ਵਿੱਚ।# ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਦਿੱਤੀ ਗਈ ਐਰੇ ਤੋਂ, ਇੱਕ ਦਿੱਤੇ ਪਲ ਤੱਕ ਮਿਲੀਆਂ ਵੱਧ ਤੋਂ ਵੱਧ ਤੱਤਾਂ ਦੀ ਇੱਕ ਐਰੇ ਤਿਆਰ ਕਰੋ।# >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\nsub rolling_max {\n    my($numbers) = @_;\n","canonical_solution":"sub rolling_max {\n    my ($numbers) = @_;\n    my @result;\n    my $max = $numbers->[0];\n    \n    for my $num (@$numbers) {\n        $max = $num if $num > $max;\n        push @result, $max;\n    }\n    \n    return \\@result;\n}\n\n# Example usage\nmy $result = rolling_max([1, 2, 3, 2, 3, 4, 2]);\nprint \"@$result\\n\";  # Outputs: 1 2 3 3 3 4 4","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&rolling_max;\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4]),[1, 2, 3, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 2, 1]),[4, 4, 4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 3, 100, 3]),[3, 3, 3, 100, 100])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_10","nl":"pan_Guru","pl":"pl","prompt":"# - ਸਤਰ ਦੇ ਅੰਤ ਵਿੱਚ ਇੱਕ ਸਤਰ ਪ੍ਰੀਫਿਕਸ ਦੇ ਉਲਟ ਜੋੜੋ ਜੋ ਪਾਲੀਂਡਰੋਮਿਕ ਪਿਛੇਤਰ ਤੋਂ ਪਹਿਲਾਂ ਆਉਂਦਾ ਹੈ।# - ਸਪਲਾਈ ਕੀਤੀ ਸਤਰ ਦਾ ਸਭ ਤੋਂ ਲੰਬਾ ਪੋਸਟਫਿਕਸ ਲੱਭੋ ਜੋ ਇਕ ਪਾਲੀਂਡਰੋਮ ਹੈ. # ਐਲਗੋਰਿਥਮ ਦਾ ਵਿਚਾਰ ਸਰਲ ਹੈਃ # ਸਭ ਤੋਂ ਛੋਟਾ ਪੈਲਿੰਡਰੋਮ ਲੱਭੋ ਜੋ ਸਪਲਾਈ ਕੀਤੀ ਸਤਰ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ.# >>> make_palindrome(\"\")\n# \"\"\n# >>> make_palindrome(\"cat\")\n# \"catac\"\n# >>> make_palindrome(\"cata\")\n# \"catac\"\nsub make_palindrome {\n    my($string) = @_;\n","canonical_solution":"sub make_palindrome {\n    my($string) = @_;\n\n    # Helper function to check if a substring is a palindrome\n    sub is_palindrome {\n        my ($sub) = @_;\n        return $sub eq reverse $sub;\n    }\n\n    # If the whole string is a palindrome, return it\n    if (is_palindrome($string)) {\n        return $string;\n    }\n\n    # Check for the longest palindromic suffix\n    my $length = length($string);\n    for (my $i = $length; $i >= 0; $i--) {\n        my $suffix = substr($string, $i);\n        if (is_palindrome($suffix)) {\n            my $prefix = substr($string, 0, $i);\n            return $string . reverse($prefix);\n        }\n    }\n\n    # If no palindromic suffix is found, append the reverse of entire string minus the first character\n    return $string . reverse(substr($string, 1));\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&make_palindrome;\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"x\"),\"x\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xyz\"),\"xyzyx\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xyx\"),\"xyx\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"jerry\"),\"jerryrrej\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_11","nl":"pan_Guru","pl":"pl","prompt":"# ਇਹਨਾਂ ਇੰਪੁੱਟਾਂ ਤੇ ਬਾਈਨਰੀ XOR ਕਰੋ ਅਤੇ ਨਤੀਜਾ ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਵੀ ਵਾਪਸ ਕਰੋ।# ਇਨਪੁਟ ਦੋ ਸਤਰਾਂ ਹਨ a ਅਤੇ b ਜਿਨ੍ਹਾਂ ਵਿੱਚ ਸਿਰਫ 1 ਅਤੇ 0 ਹਨ।# >>> string_xor(\"010\", \"110\")\n# \"100\"\nsub string_xor {\n    my($a, $b) = @_;\n","canonical_solution":"my @a_bits = split \/\/, $a;\n    my @b_bits = split \/\/, $b;\n    my $result = '';\n\n    for my $i (0 .. $#a_bits) {\n        $result .= $a_bits[$i] ^ $b_bits[$i];\n    }\n\n    return $result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&string_xor;\n        if(eq_deeply($candidate->(\"111000\", \"101010\"),\"010010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1\", \"1\"),\"0\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"0101\", \"0000\"),\"0101\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_12","nl":"pan_Guru","pl":"pl","prompt":"# ਇੱਕੋ ਲੰਬਾਈ ਦੀਆਂ ਸਤਰਾਂ. ਇਨਪੁਟ ਐਰੇ ਖਾਲੀ ਹੋਣ ਦੀ ਸਥਿਤੀ ਵਿੱਚ undef ਵਾਪਸ ਕਰੋ.# ਸਤਰਾਂ ਦੀ ਐਰੇ ਵਿੱਚੋਂ, ਸਭ ਤੋਂ ਲੰਬਾ ਵਾਪਸ ਕਰੋ। ਮਲਟੀਪਲ  ਦੇ ਮਾਮਲੇ ਵਿੱਚ ਪਹਿਲਾ ਵਾਪਸ ਕਰੋ# >>> longest([])\n# undef\n# >>> longest([\"a\", \"b\", \"c\"])\n# \"a\"\n# >>> longest([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\nsub longest {\n    my($strings) = @_;\n","canonical_solution":"sub longest {\n    my ($strings) = @_;\n    return undef if !@$strings;\n\n    my $longest = $strings->[0];\n    foreach my $string (@$strings) {\n        if (length($string) > length($longest)) {\n            $longest = $string;\n        }\n    }\n    return $longest;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&longest;\n        if(eq_deeply($candidate->([]),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"x\", \"y\", \"z\"]),\"x\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]),\"zzzz\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_13","nl":"pan_Guru","pl":"pl","prompt":"# ਦੋ ਪੂਰਨ ਅੰਕ a ਅਤੇ b ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਸਾਂਝਾ ਭਾਗੀਦਾਰ ਵਾਪਸ ਕਰੋ # >>> greatest_common_divisor(3, 5)\n# 1\n# >>> greatest_common_divisor(25, 15)\n# 5\nsub greatest_common_divisor {\n    my($a, $b) = @_;\n","canonical_solution":"sub greatest_common_divisor {\n    my ($a, $b) = @_;\n    while ($b != 0) {\n        my $t = $b;\n        $b = $a % $b;\n        $a = $t;\n    }\n    return $a;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&greatest_common_divisor;\n        if(eq_deeply($candidate->(3, 7),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10, 15),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(49, 14),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(144, 60),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_14","nl":"pan_Guru","pl":"pl","prompt":"# ਇਨਪੁਟ ਸਤਰ ਦੇ ਸਭ ਤੋਂ ਛੋਟੇ ਤੋਂ ਲੰਬੇ ਤੱਕ ਸਾਰੇ ਪ੍ਰੀਫਿਕਸ ਦੀ ਐਰੇ ਵਾਪਸ ਕਰਦਾ ਹੈ# >>> all_prefixes(\"abc\")\n# [\"a\", \"ab\", \"abc\"]\nsub all_prefixes {\n    my($string) = @_;\n","canonical_solution":"my($string) = @_;\n    my @prefixes;\n    for my $i (1 .. length($string)) {\n        push @prefixes, substr($string, 0, $i);\n    }\n    return @prefixes;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&all_prefixes;\n        if(eq_deeply($candidate->(\"\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"asdfgh\"),[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"WWW\"),[\"W\", \"WW\", \"WWW\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_15","nl":"pan_Guru","pl":"pl","prompt":"# 0 ਤੋਂ ਲੈ ਕੇ n ਤੱਕ ਸਮੇਤ ਸਪੇਸ-ਸੀਮਿਤ ਸੰਖਿਆਵਾਂ ਵਾਲੀ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰੋ।# >>> string_sequence(0)\n# \"0\"\n# >>> string_sequence(5)\n# \"0 1 2 3 4 5\"\nsub string_sequence {\n    my($n) = @_;\n","canonical_solution":"sub string_sequence {\n    my($n) = @_;\n    return join ' ', 0..$n;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&string_sequence;\n        if(eq_deeply($candidate->(0),\"0\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),\"0 1 2 3\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),\"0 1 2 3 4 5 6 7 8 9 10\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_16","nl":"pan_Guru","pl":"pl","prompt":"# ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ, ਪਤਾ ਕਰੋ ਕਿ ਕਿੰਨੇ ਵੱਖਰੇ ਅੱਖਰ (ਕਿਸੇ ਵੀ ਕੇਸ ਦੇ) ਇਸ ਵਿੱਚ ਸ਼ਾਮਲ ਹਨ# >>> count_distinct_characters(\"xyzXYZ\")\n# 3\n# >>> count_distinct_characters(\"Jerry\")\n# 4\nsub count_distinct_characters {\n    my($string) = @_;\n","canonical_solution":"sub count_distinct_characters {\n    my($string) = @_;\n    my %chars;\n    $string = lc $string;  # Convert the string to lowercase\n    $chars{$_} = 1 for split \/\/, $string;  # Add each character to the hash\n    return scalar keys %chars;  # Return the number of distinct keys\n}\n\n# Example usage:\nprint count_distinct_characters(\"xyzXYZ\"), \"\\n\";  # Output: 3\nprint count_distinct_characters(\"Jerry\"), \"\\n\";   # Output: 4","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&count_distinct_characters;\n        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcde\"),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdecadeCADE\"),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aaaaAAAAaaaa\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Jerry jERRY JeRRRY\"),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_17","nl":"pan_Guru","pl":"pl","prompt":"# 'ਛੇਹ' - ਚੌਥਾ ਨੋਟ, ਇੱਕ ਧੜਕਣ ਤੱਕ ਰਹਿੰਦਾ ਹੈ।# 'ਓ-ਡਿਜ਼ਲ' - ਅੱਧਾ ਨੋਟ, ਦੋ ਧੜਕਣਾਂ ਤੱਕ ਚਲਦਾ ਹੈ।# 'ਓ' - ਪੂਰਾ ਨੋਟ, ਚਾਰ ਧੜਕਣਾਂ ਤੱਕ ਚਲਦਾ ਹੈ।# ਇੱਥੇ ਇੱਕ ਦੰਤਕਥਾ ਹੈਃ # ਆਖਰੀ ਨਹੀਂ।# ਤੁਹਾਡਾ ਕੰਮ ਇਸ ਸਤਰ ਨੂੰ ਪਾਰਸ ਕਰਨਾ ਹੈ ਅਤੇ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰਨਾ ਹੈ ਜੋ ਹਰੇਕ ਨੂੰ ਕਿੰਨੇ ਬੀਟ ਕਰਦਾ ਹੈ# ਇਸ ਫੰਕਸ਼ਨ ਦਾ ਇੰਪੁੱਟ ਇੱਕ ਵਿਸ਼ੇਸ਼ ਏਐਸਸੀਆਈਆਈ ਫਾਰਮੈਟ ਵਿੱਚ ਸੰਗੀਤ ਨੋਟਾਂ ਨੂੰ ਦਰਸਾਉਂਦੀ ਇੱਕ ਸਤਰ ਹੈ।# >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nsub parse_music {\n    my($music_string) = @_;\n","canonical_solution":"sub parse_music {\n    my ($music_string) = @_;\n    my @notes = split ' ', $music_string;\n    my @beats;\n\n    foreach my $note (@notes) {\n        if ($note eq 'o') {\n            push @beats, 4;\n        } elsif ($note eq 'o|') {\n            push @beats, 2;\n        } elsif ($note eq '.|') {\n            push @beats, 1;\n        }\n    }\n\n    return @beats;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&parse_music;\n        if(eq_deeply($candidate->(\"\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"o o o o\"),[4, 4, 4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\".| .| .| .|\"),[1, 1, 1, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"o| o| .| .| o o o o\"),[2, 2, 1, 1, 4, 4, 4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"o| .| o| .| o o| o o|\"),[2, 1, 2, 1, 4, 2, 4, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_18","nl":"pan_Guru","pl":"pl","prompt":"# ਪਤਾ ਕਰੋ ਕਿ ਅਸਲ ਸਤਰ ਵਿੱਚ ਇੱਕ ਦਿੱਤੀ ਗਈ ਸਬਸਟ੍ਰਿੰਗ ਕਿੰਨੀ ਵਾਰ ਮਿਲ ਸਕਦੀ ਹੈ। ਓਵਰਲੈਪਿੰਗ ਕੇਸਾਂ ਦੀ ਗਿਣਤੀ ਕਰੋ।# >>> how_many_times(\"\", \"a\")\n# 0\n# >>> how_many_times(\"aaa\", \"a\")\n# 3\n# >>> how_many_times(\"aaaa\", \"aa\")\n# 3\nsub how_many_times {\n    my($string, $substring) = @_;\n","canonical_solution":"sub how_many_times {\n    my ($string, $substring) = @_;\n    return 0 if $substring eq '';\n    my $count = 0;\n    while ($string =~ \/(?=$substring)\/g) {\n        $count++;\n    }\n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&how_many_times;\n        if(eq_deeply($candidate->(\"\", \"x\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xyxyxyx\", \"x\"),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"cacacacac\", \"cac\"),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"john doe\", \"john\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_19","nl":"pan_Guru","pl":"pl","prompt":"# ਸਭ ਤੋਂ ਛੋਟੀ ਤੋਂ ਵੱਡੀ ਤੱਕ ਕ੍ਰਮਬੱਧ ਕੀਤੇ ਗਏ ਨੰਬਰਾਂ ਨਾਲ ਸਤਰ ਵਾਪਸ ਕਰੋ# ਵੈਧ ਚੋਣਾਂ ਹਨ 'ਜ਼ੀਰੋ', 'ਇੱਕ', 'ਦੋ', 'ਤਿੰਨ', 'ਚਾਰ', 'ਪੰਜ', 'ਛੇ', 'ਸੱਤ', 'ਅੱਠ' ਅਤੇ 'ਨੌ'।# ਇਨਪੁਟ 'ਜ਼ੀਰੋ' ਤੋਂ 'ਨੌ' ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦੀ ਸਪੇਸ-ਡਿਮਿਨੀਟਿਡ ਸਤਰ ਹੈ।# >>> sort_numbers(\"three one five\")\n# \"one three five\"\nsub sort_numbers {\n    my($numbers) = @_;\n","canonical_solution":"sub sort_numbers {\n    my ($numbers) = @_;\n    my %word_to_num = (\n        'zero'  => 0,\n        'one'   => 1,\n        'two'   => 2,\n        'three' => 3,\n        'four'  => 4,\n        'five'  => 5,\n        'six'   => 6,\n        'seven' => 7,\n        'eight' => 8,\n        'nine'  => 9,\n    );\n    my %num_to_word = reverse %word_to_num;\n    my @sorted_numbers = \n        map { $num_to_word{$_} } \n        sort { $a <=> $b } \n        map { $word_to_num{$_} } \n        split ' ', $numbers;\n    return join ' ', @sorted_numbers;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_numbers;\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"three\"),\"three\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"three five nine\"),\"three five nine\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"five zero four seven nine eight\"),\"zero four five seven eight nine\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"six five four three two one zero\"),\"zero one two three four five six\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_20","nl":"pan_Guru","pl":"pl","prompt":"# ਹੋਰ ਅਤੇ ਉਹਨਾਂ ਨੂੰ ਕ੍ਰਮ ਵਿੱਚ ਵਾਪਸ ਕਰੋ (ਘੱਟ ਗਿਣਤੀ, ਵੱਡੀ ਗਿਣਤੀ).# ਦਿੱਤੇ ਗਏ ਨੰਬਰਾਂ ਦੇ ਐਰੇ ਵਿੱਚੋਂ (ਘੱਟੋ ਘੱਟ ਦੋ ਦੀ ਲੰਬਾਈ) ਚੁਣੋ ਅਤੇ ਦੋ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜੋ ਹਰੇਕ ਦੇ ਸਭ ਤੋਂ ਨੇੜੇ ਹਨ # >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\nsub find_closest_elements {\n    my($numbers) = @_;\n","canonical_solution":"sub find_closest_elements {\n    my ($numbers) = @_;\n    my @sorted_numbers = sort { $a <=> $b } @$numbers;\n    my $min_diff = undef;\n    my @closest_pair;\n\n    for my $i (0 .. $#sorted_numbers - 1) {\n        my $diff = $sorted_numbers[$i + 1] - $sorted_numbers[$i];\n        if (!defined($min_diff) || $diff < $min_diff) {\n            $min_diff = $diff;\n            @closest_pair = ($sorted_numbers[$i], $sorted_numbers[$i + 1]);\n        }\n    }\n\n    return @closest_pair;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&find_closest_elements;\n        if(eq_deeply($candidate->([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 5.9, 4.0, 5.0]),[5.0, 5.9])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),[2.0, 2.2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),[2.0, 2.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2, 3.1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_21","nl":"pan_Guru","pl":"pl","prompt":"# ਇਸ ਤਰ੍ਹਾਂ ਸਭ ਤੋਂ ਛੋਟੀ ਸੰਖਿਆ 0 ਬਣ ਜਾਵੇਗੀ ਅਤੇ ਸਭ ਤੋਂ ਵੱਡੀ 1 ਬਣ ਜਾਵੇਗੀ।# ਸੰਖਿਆਵਾਂ ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ (ਘੱਟੋ ਘੱਟ ਦੋ ਤੱਤਾਂ ਦੀ), ਉਸ ਐਰੇ ਨੂੰ ਇੱਕ ਰੇਖਿਕ ਪਰਿਵਰਤਨ ਲਾਗੂ ਕਰੋ, # >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\nsub rescale_to_unit {\n    my($numbers) = @_;\n","canonical_solution":"sub rescale_to_unit {\n    my($numbers) = @_;\n    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my @rescaled = map { ($_ - $min) \/ ($max - $min) } @$numbers;\n    return \\@rescaled;\n}\n\nsub min {\n    my(@list) = @_;\n    my $min = $list[0];\n    foreach my $num (@list) {\n        if ($num < $min) {\n            $min = $num;\n        }\n    }\n    return $min;\n}\n\nsub max {\n    my(@list) = @_;\n    my $max = $list[0];\n    foreach my $num (@list) {\n        if ($num > $max) {\n            $max = $num;\n        }\n    }\n    return $max;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&rescale_to_unit;\n        if(eq_deeply($candidate->([2.0, 49.9]),[0.0, 1.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100.0, 49.9]),[1.0, 0.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5, 0.75, 1.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0, 0.5, 0.75])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([12.0, 11.0, 15.0, 13.0, 14.0]),[0.25, 0.0, 1.0, 0.5, 0.75])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_22","nl":"pan_Guru","pl":"pl","prompt":"# ਕਿਸੇ ਵੀ ਪਲਟਨ ਮੁੱਲਾਂ ਦੇ ਦਿੱਤੇ ਗਏ ਐਰੇ ਨੂੰ ਸਿਰਫ ਪੂਰਨ ਅੰਕ ਲਈ ਫਿਲਟਰ ਕਰੋ# >>> filter_integers([\"a\", 3.14, 5])\n# [5]\n# >>> filter_integers([1, 2, 3, \"abc\", {}, []])\n# [1, 2, 3]\nsub filter_integers {\n    my($values) = @_;\n","canonical_solution":"sub filter_integers {\n    my ($values) = @_;\n    return [grep { \/^-?\\d+$\/ && !ref($_) } @$values];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&filter_integers;\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, {}, [], 23.2, 9, \"adasd\"]),[4, 9])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, \"c\", 3, 3, \"a\", \"b\"]),[3, 3, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_23","nl":"pan_Guru","pl":"pl","prompt":"# ਦਿੱਤੀ ਗਈ ਸਤਰ ਦੀ ਲੰਬਾਈ ਵਾਪਸ ਕਰੋ # >>> strlen(\"\")\n# 0\n# >>> strlen(\"abc\")\n# 3\nsub strlen {\n    my($string) = @_;\n","canonical_solution":"sub strlen {\n    my($string) = @_;\n    return length($string);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&strlen;\n        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"x\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"asdasnakj\"),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_24","nl":"pan_Guru","pl":"pl","prompt":"# ਇੱਕ ਦਿੱਤੇ ਗਏ ਨੰਬਰ n ਲਈ, ਸਭ ਤੋਂ ਵੱਡੀ ਸੰਖਿਆ ਲੱਭੋ ਜੋ n ਨੂੰ ਬਰਾਬਰ ਵੰਡਦੀ ਹੈ, n ਤੋਂ ਛੋਟੀ ਹੈ # >>> largest_divisor(15)\n# 5\nsub largest_divisor {\n    my($n) = @_;\n","canonical_solution":"sub largest_divisor {\n    my($n) = @_;\n    for (my $i = $n - 1; $i > 0; $i--) {\n        if ($n % $i == 0) {\n            return $i;\n        }\n    }\n    return undef; # In case n is 1, there is no divisor less than n\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&largest_divisor;\n        if(eq_deeply($candidate->(3),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),50)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(49),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_25","nl":"pan_Guru","pl":"pl","prompt":"# ਇੰਪੁੱਟ ਨੰਬਰ ਸਾਰੇ ਕਾਰਕਾਂ ਦੇ ਉਤਪਾਦ ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ # ਹਰੇਕ ਕਾਰਕ ਨੂੰ ਕਈ ਵਾਰ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ ਜੋ ਕਿ ਕਈ ਵਾਰ ਕਾਰਕਣ ਵਿੱਚ ਪ੍ਰਗਟ ਹੁੰਦਾ ਹੈ.# ਸਭ ਤੋਂ ਛੋਟੇ ਤੋਂ ਵੱਡੇ ਕ੍ਰਮ ਵਿੱਚ ਦਿੱਤੇ ਗਏ ਪੂਰਨ ਅੰਕ ਦੇ ਪ੍ਰਾਇਮ ਫੈਕਟਰਾਂ ਦੀ ਐਰੇ ਵਾਪਸ ਕਰਦਾ ਹੈ।# >>> factorize(8)\n# [2, 2, 2]\n# >>> factorize(25)\n# [5, 5]\n# >>> factorize(70)\n# [2, 5, 7]\nsub factorize {\n    my($n) = @_;\n","canonical_solution":"sub factorize {\n    my ($n) = @_;\n    my @factors;\n    for my $i (2 .. int(sqrt($n))) {\n        while ($n % $i == 0) {\n            push @factors, $i;\n            $n \/= $i;\n        }\n    }\n    push @factors, $n if $n > 1;\n    return @factors;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&factorize;\n        if(eq_deeply($candidate->(2),[2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),[2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),[2, 2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(57),[3, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3249),[3, 3, 19, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(185193),[3, 3, 3, 19, 19, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(20577),[3, 19, 19, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(18),[2, 3, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_26","nl":"pan_Guru","pl":"pl","prompt":"# ਇੰਪੁੱਟ ਵਿੱਚ ਦਿੱਤੇ ਗਏ ਤੱਤਾਂ ਦਾ ਕ੍ਰਮ ਉਸੇ ਤਰ੍ਹਾਂ ਹੀ ਰੱਖੋ।# ਪੂਰਨ ਅੰਕ ਦੇ ਇੱਕ ਐਰੇ ਤੋਂ, ਸਾਰੇ ਤੱਤ ਹਟਾਓ ਜੋ ਇੱਕ ਤੋਂ ਵੱਧ ਵਾਰ ਵਾਪਰਦੇ ਹਨ.# >>> remove_duplicates([1, 2, 3, 2, 4])\n# [1, 3, 4]\nsub remove_duplicates {\n    my($numbers) = @_;\n","canonical_solution":"sub remove_duplicates {\n    my ($numbers) = @_;\n    my %count;\n    $count{$_}++ for @$numbers;\n    return [grep { $count{$_} == 1 } @$numbers];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&remove_duplicates;\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4]),[1, 2, 3, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 2, 4, 3, 5]),[1, 4, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_27","nl":"pan_Guru","pl":"pl","prompt":"# ਇੱਕ ਦਿੱਤੀ ਗਈ ਸਤਰ ਲਈ, ਛੋਟੇ ਅੱਖਰਾਂ ਨੂੰ ਵੱਡੇ ਅੱਖਰਾਂ ਵਿੱਚ ਅਤੇ ਵੱਡੇ ਅੱਖਰਾਂ ਨੂੰ ਛੋਟੇ ਅੱਖਰਾਂ ਵਿੱਚ ਬਦਲੋ।# >>> flip_case(\"Hello\")\n# \"hELLO\"\nsub flip_case {\n    my($string) = @_;\n","canonical_solution":"sub flip_case {\n    my($string) = @_;\n    $string =~ tr\/A-Za-z\/a-zA-Z\/;\n    return $string;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&flip_case;\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello!\"),\"hELLO!\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"These violent delights have violent ends\"),\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_28","nl":"pan_Guru","pl":"pl","prompt":"# ਸਤਰਾਂ ਦੇ ਐਰੇ ਨੂੰ ਇੱਕ ਸਤਰ ਵਿੱਚ ਜੋੜੋ# >>> concatenate([])\n# \"\"\n# >>> concatenate([\"a\", \"b\", \"c\"])\n# \"abc\"\nsub concatenate {\n    my($strings) = @_;\n","canonical_solution":"sub concatenate {\n    my($strings) = @_;\n    return join('', @$strings);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&concatenate;\n        if(eq_deeply($candidate->([]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"x\", \"y\", \"z\"]),\"xyz\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"x\", \"y\", \"z\", \"w\", \"k\"]),\"xyzwk\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_29","nl":"pan_Guru","pl":"pl","prompt":"# ਸਤਰਾਂ ਦੀ ਇੱਕ ਇਨਪੁਟ ਐਰੇ ਨੂੰ ਸਿਰਫ ਉਹਨਾਂ ਲਈ ਫਿਲਟਰ ਕਰੋ ਜੋ ਇੱਕ ਦਿੱਤੇ ਪ੍ਰੀਫਿਕਸ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦੇ ਹਨ।# >>> filter_by_prefix([], \"a\")\n# []\n# >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"array\"]\nsub filter_by_prefix {\n    my($strings, $prefix) = @_;\n","canonical_solution":"sub filter_by_prefix {\n    my ($strings, $prefix) = @_;\n    return [grep { \/^\\Q$prefix\\E\/ } @$strings];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&filter_by_prefix;\n        if(eq_deeply($candidate->([], \"john\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"),[\"xxx\", \"xxxAAA\", \"xxx\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_30","nl":"pan_Guru","pl":"pl","prompt":"# ਐਰੇ ਵਿੱਚ ਕੇਵਲ ਸਕਾਰਾਤਮਕ ਸੰਖਿਆਵਾਂ ਵਾਪਸ ਕਰਦਾ ਹੈ।# >>> get_positive([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\nsub get_positive {\n    my($l) = @_;\n","canonical_solution":"sub get_positive {\n    my($l) = @_;\n    my @positive_numbers = grep { $_ > 0 } @$l;\n    return \\@positive_numbers;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_positive;\n        if(eq_deeply($candidate->([-1, -2, 4, 5, 6]),[4, 5, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]),[5, 3, 2, 3, 3, 9, 123, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -2]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_31","nl":"pan_Guru","pl":"pl","prompt":"# ਜੇਕਰ ਇੱਕ ਦਿੱਤੀ ਗਈ ਸੰਖਿਆ ਪ੍ਰਾਇਮ ਹੈ ਤਾਂ ਸਹੀ ਵਾਪਸ ਕਰੋ, ਅਤੇ ਹੋਰ ਗਲਤ ਹੈ।# >>> is_prime(6)\n# \"\"\n# >>> is_prime(101)\n# 1\n# >>> is_prime(11)\n# 1\n# >>> is_prime(13441)\n# 1\n# >>> is_prime(61)\n# 1\n# >>> is_prime(4)\n# \"\"\n# >>> is_prime(1)\n# \"\"\nsub is_prime {\n    my($n) = @_;\n","canonical_solution":"sub is_prime {\n    my($n) = @_;\n    return \"\" if $n <= 1;\n    return 1 if $n == 2;\n    return \"\" if $n % 2 == 0;\n    for (my $i = 3; $i * $i <= $n; $i += 2) {\n        return \"\" if $n % $i == 0;\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_prime;\n        if(eq_deeply($candidate->(6),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(13441),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(61),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(17),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(85),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(77),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(255379),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_33","nl":"pan_Guru","pl":"pl","prompt":"# l ਦੇ ਅਨੁਸਾਰੀ ਸੂਚਕਾਂਕ ਦੇ ਮੁੱਲਾਂ ਨੂੰ, ਪਰ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਗਿਆ ਹੈ.# l' ਇੰਡੈਕਸ ਵਿੱਚ l ਦੇ ਸਮਾਨ ਹੈ ਜੋ ਤਿੰਨ ਨਾਲ ਵੰਡਣ ਯੋਗ ਨਹੀਂ ਹਨ, ਜਦੋਂ ਕਿ ਇਸਦੇ ਮੁੱਲ ਇੰਡੈਕਸ ਵਿੱਚ ਜੋ ਤਿੰਨ ਨਾਲ ਵੰਡਣ ਯੋਗ ਹਨ, ਬਰਾਬਰ ਹਨ # ਇਹ ਫੰਕਸ਼ਨ ਇੱਕ ਐਰੇ l ਲੈਂਦਾ ਹੈ ਅਤੇ ਇੱਕ ਐਰੇ l' ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਵੇਂ ਕਿ # >>> sort_third([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n# [2, 6, 3, 4, 8, 9, 5]\nsub sort_third {\n    my($l) = @_;\n","canonical_solution":"sub sort_third {\n    my ($l) = @_;\n    my @to_sort = map { $l->[$_] } grep { $_ % 3 == 0 } 0..$#$l;\n    @to_sort = sort { $a <=> $b } @to_sort;\n    my @result = @$l;\n    my $index = 0;\n\n    foreach my $i (0..$#{$l}) {\n        if ($i % 3 == 0) {\n            $result[$i] = $to_sort[$index++];\n        }\n    }\n    \n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_third;\n        if(eq_deeply($candidate->([5, 6, 3, 4, 8, 9, 2]),[2, 6, 3, 4, 8, 9, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 8, 3, 4, 6, 9, 2]),[2, 8, 3, 4, 6, 9, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 9, 4, 8, 3, 2]),[2, 6, 9, 4, 8, 3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 3, 4, 8, 9, 2, 1]),[2, 6, 3, 4, 8, 9, 5, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_34","nl":"pan_Guru","pl":"pl","prompt":"# ਇੱਕ ਐਰੇ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕੀਤੇ ਅਨੌਖੇ ਤੱਤ ਵਾਪਸ ਕਰੋ# >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\nsub unique {\n    my($l) = @_;\n","canonical_solution":"sub unique {\n    my ($l) = @_;\n    my %seen;\n    my @unique_sorted = sort { $a <=> $b } grep { !$seen{$_}++ } @$l;\n    return \\@unique_sorted;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&unique;\n        if(eq_deeply($candidate->([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9, 123])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_35","nl":"pan_Guru","pl":"pl","prompt":"# ਐਰੇ ਵਿੱਚ ਅਧਿਕਤਮ ਤੱਤ ਵਾਪਸ ਕਰਦਾ ਹੈ।# >>> max_element([1, 2, 3])\n# 3\n# >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\nsub max_element {\n    my($l) = @_;\n","canonical_solution":"sub max_element {\n    my($l) = @_;\n    my $max = $l->[0];\n    foreach my $value (@$l) {\n        if ($value > $max) {\n            $max = $value;\n        }\n    }\n    return $max;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_element;\n        if(eq_deeply($candidate->([1, 2, 3]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]),124)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_36","nl":"pan_Guru","pl":"pl","prompt":"# ਅੰਕ 7 ਦੀ ਗਿਣਤੀ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜੋ ਕਿ n ਤੋਂ ਘੱਟ ਪੂਰਨ ਅੰਕ ਵਿੱਚ ਪ੍ਰਗਟ ਹੁੰਦਾ ਹੈ ਜੋ 11 ਜਾਂ 13 ਨਾਲ ਵੰਡਿਆ ਜਾਂਦਾ ਹੈ.# >>> fizz_buzz(50)\n# 0\n# >>> fizz_buzz(78)\n# 2\n# >>> fizz_buzz(79)\n# 3\nsub fizz_buzz {\n    my($n) = @_;\n","canonical_solution":"sub fizz_buzz {\n    my($n) = @_;\n    my $count = 0;\n    for my $i (1 .. $n-1) {\n        if ($i % 11 == 0 || $i % 13 == 0) {\n            $count++ if $i =~ \/7\/;\n        }\n    }\n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fizz_buzz;\n        if(eq_deeply($candidate->(50),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(78),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(79),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(200),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4000),192)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10000),639)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100000),8026)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_37","nl":"pan_Guru","pl":"pl","prompt":"# l ਦੇ ਵੀ ਸੂਚਕਾਂਕ ਦੇ ਮੁੱਲਾਂ ਨੂੰ, ਪਰ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਗਿਆ ਹੈ.# l' ਅਣਗਿਣਤ ਸੂਚਕਾਂ ਵਿੱਚ l ਦੇ ਸਮਾਨ ਹੈ, ਜਦੋਂ ਕਿ ਇਸ ਦੇ ਮੁੱਲ ਜੋੜੇ ਸੂਚਕਾਂ ਵਿੱਚ ਬਰਾਬਰ ਹਨ # ਇਹ ਫੰਕਸ਼ਨ ਇੱਕ ਐਰੇ l ਲੈਂਦਾ ਹੈ ਅਤੇ ਇੱਕ ਐਰੇ l' ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਵੇਂ ਕਿ # >>> sort_even([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_even([5, 6, 3, 4])\n# [3, 6, 5, 4]\nsub sort_even {\n    my($l) = @_;\n","canonical_solution":"sub sort_even {\n    my($l) = @_;\n    my @even_indices;\n\n    for (my $i = 0; $i < @$l; $i += 2) {\n        push @even_indices, $l->[$i];\n    }\n\n    @even_indices = sort { $a <=> $b } @even_indices;\n\n    my @result = @$l;\n    \n    for (my $i = 0; $i < @even_indices; $i++) {\n        $result[$i * 2] = $even_indices[$i];\n    }\n    \n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_even;\n        if(eq_deeply($candidate->([1, 2, 3]),[1, 2, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_39","nl":"pan_Guru","pl":"pl","prompt":"# prime_fib n-th ਨੰਬਰ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੋ ਕਿ ਇੱਕ ਫਿਬੋਨੈਕਸੀ ਨੰਬਰ ਹੈ ਅਤੇ ਇਹ ਵੀ ਪ੍ਰਾਇਮਰੀ ਹੈ. # >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n# 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n# 89\nsub prime_fib {\n    my($n) = @_;\n","canonical_solution":"sub is_prime {\n    my($num) = @_;\n    return 0 if $num < 2;\n    for my $i (2 .. sqrt($num)) {\n        return 0 if $num % $i == 0;\n    }\n    return 1;\n}\n\nsub prime_fib {\n    my($n) = @_;\n    my ($a, $b) = (1, 1);\n    my $count = 0;\n\n    while (1) {\n        my $fib = $a + $b;\n        $a = $b;\n        $b = $fib;\n        if (is_prime($fib)) {\n            $count++;\n            return $fib if $count == $n;\n        }\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&prime_fib;\n        if(eq_deeply($candidate->(1),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),13)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),89)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),233)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),1597)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),28657)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(9),514229)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),433494437)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_40","nl":"pan_Guru","pl":"pl","prompt":"# ਰਕਮ ਨੂੰ ਜ਼ੀਰੋ ਕਰਨ ਲਈ, ਅਤੇ '' ਹੋਰ.# ਇਹ 1 ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਐਰੇ ਵਿੱਚ ਤਿੰਨ ਵੱਖਰੇ ਤੱਤ ਹਨ ਜੋ # triples_sum_to_zero ਇੱਕ ਇੰਪੁੱਟ ਦੇ ਤੌਰ ਤੇ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ ਲੈਂਦਾ ਹੈ।# >>> triples_sum_to_zero([1, 3, 5, 0])\n# \"\"\n# >>> triples_sum_to_zero([1, 3, -2, 1])\n# 1\n# >>> triples_sum_to_zero([1, 2, 3, 7])\n# \"\"\n# >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n# 1\n# >>> triples_sum_to_zero([1])\n# \"\"\nsub triples_sum_to_zero {\n    my($l) = @_;\n","canonical_solution":"sub triples_sum_to_zero {\n    my($l) = @_;\n    my $n = scalar @$l;\n    for my $i (0 .. $n-3) {\n        for my $j ($i+1 .. $n-2) {\n            for my $k ($j+1 .. $n-1) {\n                if ($l->[$i] + $l->[$j] + $l->[$k] == 0) {\n                    return 1;\n                }\n            }\n        }\n    }\n    return '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&triples_sum_to_zero;\n        if(eq_deeply($candidate->([1, 3, 5, 0]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 5, -1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, -2, 1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 7]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 5, 7]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, -5, 3, 9, 7]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 5, -100]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100, 3, 5, -100]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_41","nl":"pan_Guru","pl":"pl","prompt":"# ਇਹ ਫੰਕਸ਼ਨ ਅਜਿਹੇ ਟੱਕਰਾਂ ਦੀ ਗਿਣਤੀ ਨੂੰ ਆਉਟਪੁੱਟ ਦਿੰਦਾ ਹੈ।# ਜਿਵੇਂ ਕਿ ਉਹ ਟਕਰਾਅ ਨਾ ਹੋਏ ਹੋਣ।# ਹਾਲਾਂਕਿ, ਕਾਰਾਂ ਬੇਅੰਤ ਮਜ਼ਬੂਤ ਅਤੇ ਮਜ਼ਬੂਤ ਹਨ; ਨਤੀਜੇ ਵਜੋਂ, ਉਹ ਚਲਦੇ ਰਹਿੰਦੇ ਹਨ # ਜਦੋਂ ਇੱਕ ਕਾਰ ਜੋ ਖੱਬੇ ਤੋਂ ਸੱਜੇ ਵੱਲ ਜਾ ਰਹੀ ਹੈ ਇੱਕ ਕਾਰ ਨੂੰ ਟੱਕਰ ਦਿੰਦੀ ਹੈ ਜੋ ਸੱਜੇ ਤੋਂ ਖੱਬੇ ਵੱਲ ਜਾ ਰਹੀ ਹੈ।# ਇੱਕ ਦੂਜੇ ਨੂੰ. ਸਾਰੀਆਂ ਕਾਰਾਂ ਇੱਕੋ ਗਤੀ ਨਾਲ ਚਲਦੀਆਂ ਹਨ. ਦੋ ਕਾਰਾਂ ਨੂੰ ਟਕਰਾਉਣ ਲਈ ਕਿਹਾ ਜਾਂਦਾ ਹੈ.# ਕਾਰਾਂ ਦੇ ਦੋ ਸੈੱਟ ਸ਼ੁਰੂ ਹੁੰਦੇ ਹਨ ਜੋ ਕਿ ਬਹੁਤ ਦੂਰ ਹੁੰਦੇ ਹਨ# n ਕਾਰਾਂ ਖੱਬੇ ਤੋਂ ਸੱਜੇ ਵੱਲ ਜਾ ਰਹੀਆਂ ਹਨ; ਇੱਕੋ ਸਮੇਂ, n ਕਾਰਾਂ ਦਾ ਇੱਕ ਵੱਖਰਾ ਸਮੂਹ # ਇੱਕ ਅਜਿਹੀ ਸੜਕ ਦੀ ਕਲਪਨਾ ਕਰੋ ਜੋ ਇੱਕ ਅਨੰਤ ਲੰਬੀ ਸਿੱਧੀ ਲਾਈਨ ਹੋਵੇ।sub car_race_collision {\n    my($n) = @_;\n","canonical_solution":"sub car_race_collision {\n    my($n) = @_;\n    return $n;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&car_race_collision;\n        if(eq_deeply($candidate->(2),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),16)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),64)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),100)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_42","nl":"pan_Guru","pl":"pl","prompt":"# 1 ਨਾਲ ਵਧੇ ਹੋਏ ਤੱਤਾਂ ਦੇ ਨਾਲ ਐਰੇ ਵਾਪਸ ਕਰੋ।# >>> incr_list([1, 2, 3])\n# [2, 3, 4]\n# >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6, 4, 6, 3, 4, 4, 10, 1, 124]\nsub incr_list {\n    my($l) = @_;\n","canonical_solution":"sub incr_list {\n    my($l) = @_;\n    return [map { $_ + 1 } @$l];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&incr_list;\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 1]),[4, 3, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 2, 5, 2, 3, 3, 9, 0, 123]),[6, 3, 6, 3, 4, 4, 10, 1, 124])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_43","nl":"pan_Guru","pl":"pl","prompt":"# ਰਕਮ ਨੂੰ ਜ਼ੀਰੋ ਕਰਨ ਲਈ, ਅਤੇ '' ਹੋਰ.# ਇਹ 1 ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਐਰੇ ਵਿੱਚ ਦੋ ਵੱਖਰੇ ਤੱਤ ਹਨ ਜੋ # pairs_sum_to_zero ਇੰਪੁੱਟ ਦੇ ਤੌਰ ਤੇ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ ਲੈਂਦਾ ਹੈ।# >>> pairs_sum_to_zero([1, 3, 5, 0])\n# \"\"\n# >>> pairs_sum_to_zero([1, 3, -2, 1])\n# \"\"\n# >>> pairs_sum_to_zero([1, 2, 3, 7])\n# \"\"\n# >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n# 1\n# >>> pairs_sum_to_zero([1])\n# \"\"\nsub pairs_sum_to_zero {\n    my($l) = @_;\n","canonical_solution":"sub pairs_sum_to_zero {\n    my ($l) = @_;\n    my %seen;\n    for my $num (@$l) {\n        if ($seen{-1 * $num}) {\n            return 1;\n        }\n        $seen{$num} = 1;\n    }\n    return '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pairs_sum_to_zero;\n        if(eq_deeply($candidate->([1, 3, 5, 0]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, -2, 1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 7]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, -5, 3, 5, 7]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3, 9, -1, 3, 2, 30]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3, 9, -1, 3, 2, 31]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3, 9, -1, 4, 2, 30]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3, 9, -1, 4, 2, 31]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_44","nl":"pan_Guru","pl":"pl","prompt":"# ਅਧਾਰ ਸੰਖਿਆਵਾਂ 10 ਤੋਂ ਘੱਟ ਹਨ।# ਪਰਿਵਰਤਨ ਤੋਂ ਬਾਅਦ ਸਤਰ ਪ੍ਰਤੀਨਿਧਤਾ ਵਾਪਸ ਕਰੋ।# ਇਨਪੁਟ ਨੰਬਰ x ਦਾ ਅੰਕੀ ਅਧਾਰ ਨੂੰ ਅਧਾਰ ਵਿੱਚ ਬਦਲੋ।# >>> change_base(8, 3)\n# \"22\"\n# >>> change_base(8, 2)\n# \"1000\"\n# >>> change_base(7, 2)\n# \"111\"\nsub change_base {\n    my($x, $base) = @_;\n","canonical_solution":"sub change_base {\n    my ($x, $base) = @_;\n    my $result = '';\n    \n    if ($base < 2 || $base > 9) {\n        die \"Base must be between 2 and 9\";\n    }\n\n    while ($x > 0) {\n        my $remainder = $x % $base;\n        $result = $remainder . $result;\n        $x = int($x \/ $base);\n    }\n\n    return $result eq '' ? '0' : $result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&change_base;\n        if(eq_deeply($candidate->(8, 3),\"22\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(9, 3),\"100\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(234, 2),\"11101010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(16, 2),\"10000\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8, 2),\"1000\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 2),\"111\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 3),\"2\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3, 4),\"3\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 5),\"4\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 6),\"5\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6, 7),\"6\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 8),\"7\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_45","nl":"pan_Guru","pl":"pl","prompt":"# ਇੱਕ ਤਿਕੋਣ ਲਈ ਇੱਕ ਪਾਸੇ ਦੀ ਲੰਬਾਈ ਅਤੇ ਉੱਚ ਵਾਪਸੀ ਖੇਤਰ ਦਿੱਤਾ ਗਿਆ ਹੈ.# >>> triangle_area(5, 3)\n# 7.5\nsub triangle_area {\n    my($a, $h) = @_;\n","canonical_solution":"sub triangle_area {\n    my ($a, $h) = @_; \n    return 0.5 * $a * $h;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&triangle_area;\n        if(eq_deeply($candidate->(5, 3),7.5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 2),2.0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10, 8),40.0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_46","nl":"pan_Guru","pl":"pl","prompt":"# ਕਿਰਪਾ ਕਰਕੇ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ fib4 ਨੰਬਰ ਸੀਕਵੈਂਸ ਦੇ n-ਵੇਂ ਐਲੀਮੈਂਟ ਦੀ ਕੁਸ਼ਲਤਾ ਨਾਲ ਗਣਨਾ ਕਰੇ। ਰੀਕੌਰਸ਼ਨ ਦੀ ਵਰਤੋਂ ਨਾ ਕਰੋ।# fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).# fib4(3) -> 0 # fib4(2) -> 2 # fib4(1) -> 0 # fib4(0) -> 0 # Fib4 ਨੰਬਰ ਸੀਕਵੈਂਸ ਫਿਬੋਨੈਕਸੀ ਸੀਕਵੈਂਸ ਵਰਗੀ ਸੀਕਵੈਂਸ ਹੈ ਜੋ ਹੇਠ ਲਿਖੇ ਅਨੁਸਾਰ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤੀ ਗਈ ਹੈਃ # >>> fib4(5)\n# 4\n# >>> fib4(6)\n# 8\n# >>> fib4(7)\n# 14\nsub fib4 {\n    my($n) = @_;\n","canonical_solution":"sub fib4 {\n    my ($n) = @_;\n    return 0 if $n == 0 || $n == 1 || $n == 3;\n    return 2 if $n == 2;\n    \n    my @fib4 = (0, 0, 2, 0);\n    \n    for my $i (4 .. $n) {\n        $fib4[$i] = $fib4[$i-1] + $fib4[$i-2] + $fib4[$i-3] + $fib4[$i-4];\n    }\n    \n    return $fib4[$n];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fib4;\n        if(eq_deeply($candidate->(5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),28)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),104)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),386)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_47","nl":"pan_Guru","pl":"pl","prompt":"# ਐਰੇ ਵਿੱਚ ਤੱਤਾਂ ਦਾ ਮੱਧਮਾਨ ਵਾਪਸ ਕਰੋ l. # >>> median([3, 1, 2, 4, 5])\n# 3\n# >>> median([-10, 4, 6, 1000, 10, 20])\n# 15.0\nsub median {\n    my($l) = @_;\n","canonical_solution":"sub median {\n    my($l) = @_;\n    my @sorted = sort { $a <=> $b } @$l;\n    my $len = @sorted;\n    if ($len % 2 == 1) {\n        return $sorted[int($len\/2)];\n    } else {\n        return ($sorted[$len\/2 - 1] + $sorted[$len\/2]) \/ 2;\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&median;\n        if(eq_deeply($candidate->([3, 1, 2, 4, 5]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-10, 4, 6, 1000, 10, 20]),8.0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5]),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([6, 5]),5.5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([8, 1, 3, 9, 9, 2, 7]),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_48","nl":"pan_Guru","pl":"pl","prompt":"# ਜਾਂਚ ਕਰਦਾ ਹੈ ਕਿ ਕੀ ਦਿੱਤੀ ਗਈ ਸਤਰ ਇੱਕ ਪਾਲੀਂਡਰੋਮ ਹੈ # >>> is_palindrome(\"\")\n# 1\n# >>> is_palindrome(\"aba\")\n# 1\n# >>> is_palindrome(\"aaaaa\")\n# 1\n# >>> is_palindrome(\"zbcd\")\n# \"\"\nsub is_palindrome {\n    my($text) = @_;\n","canonical_solution":"sub is_palindrome {\n    my ($text) = @_;\n    return $text eq reverse($text) ? 1 : \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_palindrome;\n        if(eq_deeply($candidate->(\"\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aba\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aaaaa\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"zbcd\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xywyx\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xywyz\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xywzx\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_49","nl":"pan_Guru","pl":"pl","prompt":"# 2^n ਮਾਡੂਲੋ ਪੀ ਵਾਪਸ ਕਰੋ (ਅੰਕਾਂ ਨੂੰ ਧਿਆਨ ਵਿੱਚ ਰੱਖੋ) ।# >>> modp(3, 5)\n# 3\n# >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100, 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n","canonical_solution":"sub modp {\n    my($n, $p) = @_;\n    return (2 ** $n) % $p;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n        if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0, 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30, 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31, 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_51","nl":"pan_Guru","pl":"pl","prompt":"# remove_vowels ਇੱਕ ਫੰਕਸ਼ਨ ਹੈ ਜੋ ਸਤਰ ਲੈਂਦਾ ਹੈ ਅਤੇ ਸਤਰ ਨੂੰ ਬਿਨਾਂ ਵੋਕਲ ਦੇ ਵਾਪਸ ਕਰਦਾ ਹੈ. # >>> remove_vowels(\"\")\n# \"\"\n# >>> remove_vowels(\"abcdef\")\n# \"bcdf\"\n# >>> remove_vowels(\"aaaaa\")\n# \"\"\n# >>> remove_vowels(\"aaBAA\")\n# \"B\"\n# >>> remove_vowels(\"zbcd\")\n# \"zbcd\"\nsub remove_vowels {\n    my($text) = @_;\n","canonical_solution":"sub remove_vowels {\n    my($text) = @_;\n    $text =~ s\/[aeiouAEIOU]\/\/g;\n    return $text;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&remove_vowels;\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdef\nghijklm\"),\"bcdf\nghjklm\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"fedcba\"),\"fdcb\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eeeee\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"acBAA\"),\"cB\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"EcBOO\"),\"cB\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ybcd\"),\"ybcd\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_52","nl":"pan_Guru","pl":"pl","prompt":"# 1 ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਐਰੇ l ਦੇ ਸਾਰੇ ਨੰਬਰ ਥ੍ਰੈਸ਼ਹੋਲਡ t ਤੋਂ ਹੇਠਾਂ ਹਨ।# >>> below_threshold([1, 2, 4, 10], 100)\n# 1\n# >>> below_threshold([1, 20, 4, 10], 5)\n# \"\"\nsub below_threshold {\n    my($l, $t) = @_;\n","canonical_solution":"sub below_threshold {\n    my($l, $t) = @_;\n    foreach my $num (@$l) {\n        return \"\" if $num >= $t;\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&below_threshold;\n        if(eq_deeply($candidate->([1, 2, 4, 10], 100),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 20, 4, 10], 5),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 20, 4, 10], 21),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 20, 4, 10], 22),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 8, 4, 10], 11),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 8, 4, 10], 10),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_53","nl":"pan_Guru","pl":"pl","prompt":"# ਦੋ ਨੰਬਰ x ਅਤੇ y ਜੋੜੋ # >>> add(2, 3)\n# 5\n# >>> add(5, 7)\n# 12\nsub add {\n    my($x, $y) = @_;\n","canonical_solution":"return $x + $y;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&add;\n        if(eq_deeply($candidate->(0, 1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 0),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 3),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 7),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 5),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_54","nl":"pan_Guru","pl":"pl","prompt":"# ਜਾਂਚ ਕਰੋ ਕਿ ਕੀ ਦੋ ਸ਼ਬਦਾਂ ਵਿੱਚ ਇੱਕੋ ਜਿਹੇ ਅੱਖਰ ਹਨ।# >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n# 1\n# >>> same_chars(\"abcd\", \"dddddddabc\")\n# 1\n# >>> same_chars(\"dddddddabc\", \"abcd\")\n# 1\n# >>> same_chars(\"eabcd\", \"dddddddabc\")\n# \"\"\n# >>> same_chars(\"abcd\", \"dddddddabce\")\n# \"\"\n# >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n# \"\"\nsub same_chars {\n    my($s0, $s1) = @_;\n","canonical_solution":"sub same_chars {\n    my($s0, $s1) = @_;\n    \n    my %chars_s0 = map { $_ => 1 } split \/\/, $s0;\n    my %chars_s1 = map { $_ => 1 } split \/\/, $s1;\n\n    foreach my $char (keys %chars_s0) {\n        return \"\" unless exists $chars_s1{$char};\n    }\n\n    foreach my $char (keys %chars_s1) {\n        return \"\" unless exists $chars_s0{$char};\n    }\n\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&same_chars;\n        if(eq_deeply($candidate->(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcd\", \"dddddddabc\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"dddddddabc\", \"abcd\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eabcd\", \"dddddddabc\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcd\", \"dddddddabcf\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aabb\", \"aaccc\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_55","nl":"pan_Guru","pl":"pl","prompt":"# n-th ਫਿਬੋਨੈਕਸੀ ਨੰਬਰ ਵਾਪਸ ਕਰੋ।# >>> fib(10)\n# 55\n# >>> fib(1)\n# 1\n# >>> fib(8)\n# 21\nsub fib {\n    my($n) = @_;\n","canonical_solution":"sub fib {\n    my ($n) = @_;\n    return $n if $n <= 1;\n    my ($a, $b) = (0, 1);\n    for (2..$n) {\n        ($a, $b) = ($b, $a + $b);\n    }\n    return $b;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fib;\n        if(eq_deeply($candidate->(10),55)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),21)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11),89)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),144)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_56","nl":"pan_Guru","pl":"pl","prompt":"# 1 ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਹਰੇਕ ਖੁੱਲਣ ਵਾਲੇ ਬਰੈਕਟ ਵਿੱਚ ਇੱਕ ਅਨੁਸਾਰੀ ਬੰਦ ਕਰਨ ਵਾਲਾ ਬਰੈਕਟ ਹੋਵੇ।# ਬਰੈਕਟ \"<\" ਅਤੇ \">\" ਦੀ ਇੱਕ ਸਤਰ ਹੈ।# >>> correct_bracketing(\"<\")\n# \"\"\n# >>> correct_bracketing(\"<>\")\n# 1\n# >>> correct_bracketing(\"<<><>>\")\n# 1\n# >>> correct_bracketing(\"><<>\")\n# \"\"\nsub correct_bracketing {\n    my($brackets) = @_;\n","canonical_solution":"sub correct_bracketing {\n    my($brackets) = @_;\n    my $balance = 0;\n\n    foreach my $char (split \/\/, $brackets) {\n        if ($char eq '<') {\n            $balance++;\n        } elsif ($char eq '>') {\n            $balance--;\n            if ($balance < 0) {\n                return \"\";\n            }\n        }\n    }\n    \n    return $balance == 0 ? 1 : \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&correct_bracketing;\n        if(eq_deeply($candidate->(\"<>\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<<><>>\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<><><<><>><>\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<><><<<><><>><>><<><><<>>>\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<<<><>>>>\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"><<>\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<<<<\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\">\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<<>\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<><><<><>><>><<>\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"<><><<><>><>>><>\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_57","nl":"pan_Guru","pl":"pl","prompt":"# ਵਾਪਸੀ 1 ਐਰੇ ਤੱਤ ਇਕਸਾਰਤਾ ਨਾਲ ਵੱਧ ਰਹੇ ਹਨ ਜਾਂ ਘਟ ਰਹੇ ਹਨ।# >>> monotonic([1, 2, 4, 20])\n# 1\n# >>> monotonic([1, 20, 4, 10])\n# \"\"\n# >>> monotonic([4, 1, 0, -10])\n# 1\nsub monotonic {\n    my($l) = @_;\n","canonical_solution":"sub monotonic {\n    my($l) = @_;\n    return 1 if @$l <= 1;\n    \n    my $increasing = 1;\n    my $decreasing = 1;\n    \n    for my $i (1 .. $#$l) {\n        if ($l->[$i] > $l->[$i - 1]) {\n            $decreasing = 0;\n        } elsif ($l->[$i] < $l->[$i - 1]) {\n            $increasing = 0;\n        }\n    }\n    \n    return $increasing || $decreasing ? 1 : '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&monotonic;\n        if(eq_deeply($candidate->([1, 2, 4, 10]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 4, 20]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 20, 4, 10]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 1, 0, -10]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 1, 1, 0]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 2, 5, 60]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 60]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([9, 9, 9, 9]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_58","nl":"pan_Guru","pl":"pl","prompt":"# ਦੋ ਐਰੇ ਲਈ ਕ੍ਰਮਬੱਧ ਵਿਲੱਖਣ ਸਾਂਝੇ ਤੱਤ ਵਾਪਸ ਕਰੋ.# >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5, 3, 2, 8], [3, 2])\n# [2, 3]\nsub common {\n    my($l1, $l2) = @_;\n","canonical_solution":"sub common {\n    my($l1, $l2) = @_;\n    my %count;\n    $count{$_}++ for @$l1;\n    $count{$_}++ for grep { exists $count{$_} } @$l2;\n    return [ sort { $a <=> $b } grep { $count{$_} > 1 } keys %count ];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&common;\n        if(eq_deeply($candidate->([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 3, 2, 8], [3, 2]),[2, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 2, 8], [3, 2, 4]),[2, 3, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 2, 8], []),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_59","nl":"pan_Guru","pl":"pl","prompt":"# n ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਪ੍ਰਾਇਮ ਫੈਕਟਰ ਵਾਪਸ ਕਰੋ. ਮੰਨ ਲਓ ਕਿ n > 1 ਹੈ ਅਤੇ ਪ੍ਰਾਇਮ ਨਹੀਂ ਹੈ। # >>> largest_prime_factor(13195)\n# 29\n# >>> largest_prime_factor(2048)\n# 2\nsub largest_prime_factor {\n    my($n) = @_;\n","canonical_solution":"sub largest_prime_factor {\n    my($n) = @_;\n    my $largest_factor = 1;\n    my $factor = 2;\n\n    while ($n > 1) {\n        if ($n % $factor == 0) {\n            $largest_factor = $factor;\n            $n \/= $factor;\n        } else {\n            $factor++;\n        }\n    }\n    \n    return $largest_factor;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&largest_prime_factor;\n        if(eq_deeply($candidate->(15),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(27),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(63),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(330),11)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(13195),29)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_60","nl":"pan_Guru","pl":"pl","prompt":"# sum_to_n ਇੱਕ ਫੰਕਸ਼ਨ ਹੈ ਜੋ 1 ਤੋਂ n ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦਾ ਜੋੜ ਕਰਦਾ ਹੈ।# >>> sum_to_n(30)\n# 465\n# >>> sum_to_n(100)\n# 5050\n# >>> sum_to_n(5)\n# 15\n# >>> sum_to_n(10)\n# 55\n# >>> sum_to_n(1)\n# 1\nsub sum_to_n {\n    my($n) = @_;\n","canonical_solution":"sub sum_to_n {\n    my ($n) = @_;\n    return $n * ($n + 1) \/ 2;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sum_to_n;\n        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),21)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11),66)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30),465)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),5050)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_61","nl":"pan_Guru","pl":"pl","prompt":"# 1 ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਹਰੇਕ ਖੁੱਲਣ ਵਾਲੇ ਬਰੈਕਟ ਵਿੱਚ ਇੱਕ ਅਨੁਸਾਰੀ ਬੰਦ ਕਰਨ ਵਾਲਾ ਬਰੈਕਟ ਹੋਵੇ।# ਬਰੈਕਟ \"(\" ਅਤੇ \"\") ਦੀ ਇੱਕ ਸਤਰ ਹੈ।# >>> correct_bracketing(\"(\")\n# \"\"\n# >>> correct_bracketing(\"()\")\n# 1\n# >>> correct_bracketing(\"(()())\")\n# 1\n# >>> correct_bracketing(\")(()\")\n# \"\"\nsub correct_bracketing {\n    my($brackets) = @_;\n","canonical_solution":"sub correct_bracketing {\n    my ($brackets) = @_;\n    my $balance = 0;\n\n    foreach my $char (split \/\/, $brackets) {\n        if ($char eq '(') {\n            $balance++;\n        } elsif ($char eq ')') {\n            $balance--;\n        }\n        # If balance is negative, it means there's a closing bracket without a matching opening\n        if ($balance < 0) {\n            return '';\n        }\n    }\n\n    # If balance is zero, all brackets are correctly matched\n    return $balance == 0 ? 1 : '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&correct_bracketing;\n        if(eq_deeply($candidate->(\"()\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"(()())\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"()()(()())()\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"()()((()()())())(()()(()))\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"((()())))\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\")(()\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"(\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"((((\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\")\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"(()\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"()()(()())())(()\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"()()(()())()))()\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_62","nl":"pan_Guru","pl":"pl","prompt":"# ਇਸ ਬਹੁ-ਅੰਕ ਦਾ ਉਸੇ ਰੂਪ ਵਿੱਚ ਡੈਰੀਵੇਟਿਵ ਵਾਪਸ ਕਰੋ.# xs[0] + xs[1] * x + xs[2] * x^2 + .... # xs ਇੱਕ ਬਹੁ-ਅੰਕ ਦੇ ਗੁਣਾਂਕ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ।# >>> derivative([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative([1, 2, 3])\n# [2, 6]\nsub derivative {\n    my($xs) = @_;\n","canonical_solution":"sub derivative {\n    my($xs) = @_;\n    my @derivative;\n    \n    for my $i (1 .. $#{$xs}) {\n        push @derivative, $xs->[$i] * $i;\n    }\n    \n    return \\@derivative;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&derivative;\n        if(eq_deeply($candidate->([3, 1, 2, 4, 5]),[1, 4, 12, 20])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 1]),[2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 1, 0, 4]),[2, 2, 0, 16])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_63","nl":"pan_Guru","pl":"pl","prompt":"# ਕਿਰਪਾ ਕਰਕੇ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਕਿ ਫਿਬਫਿਬ ਨੰਬਰ ਸੀਕਵੈਂਸ ਦੇ n-ਵੇਂ ਐਲੀਮੈਂਟ ਦੀ ਕੁਸ਼ਲਤਾ ਨਾਲ ਗਣਨਾ ਕਰੇ।# ਫਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿਬਿ# ਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫ# ਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫ# ਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫਿਫ# ਫਿਬਫਿਬ ਨੰਬਰ ਸੀਕਵੈਂਸ ਫਿਬੋਨੈਕਸੀ ਸੀਕਵੈਂਸ ਵਰਗੀ ਇਕ ਸੀਕਵੈਂਸ ਹੈ ਜੋ ਹੇਠ ਲਿਖੇ ਅਨੁਸਾਰ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤੀ ਗਈ ਹੈਃ # >>> fibfib(1)\n# 0\n# >>> fibfib(5)\n# 4\n# >>> fibfib(8)\n# 24\nsub fibfib {\n    my($n) = @_;\n","canonical_solution":"sub fibfib {\n    my($n) = @_;\n    return 0 if $n == 0;\n    return 0 if $n == 1;\n    return 1 if $n == 2;\n\n    my @fibfib = (0, 0, 1);\n    for my $i (3..$n) {\n        $fibfib[$i] = $fibfib[$i-1] + $fibfib[$i-2] + $fibfib[$i-3];\n    }\n    return $fibfib[$n];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fibfib;\n        if(eq_deeply($candidate->(2),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),24)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),81)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),274)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(14),927)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_64","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # ਵੋਕਲ, ਪਰ ਕੇਵਲ ਉਦੋਂ ਜਦੋਂ ਇਹ ਦਿੱਤੇ ਗਏ ਸ਼ਬਦ ਦੇ ਅੰਤ ਵਿੱਚ ਹੋਵੇ।# ਇਸ ਮਾਮਲੇ ਵਿੱਚ ਧੁਨੀ 'a', 'e', 'i', 'o', 'u' ਹਨ। ਇੱਥੇ, 'y' ਵੀ ਇੱਕ ਹੈ।# ਇੱਕ ਸ਼ਬਦ ਨੂੰ ਇੰਪੁੱਟ ਦੇ ਤੌਰ ਤੇ ਅਤੇ ਸਤਰ ਵਿੱਚ ਵੋਕਲ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰਦਾ ਹੈ. # ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ# >>> vowels_count(\"abcde\")\n# 2\n# >>> vowels_count(\"ACEDY\")\n# 3\nsub vowels_count {\n    my($s) = @_;\n","canonical_solution":"sub vowels_count {\n    my($s) = @_;\n    my $count = 0;\n    my @chars = split \/\/, lc $s;\n    my $length = scalar @chars;\n\n    for my $i (0..$#chars) {\n        if ($chars[$i] =~ \/[aeiou]\/ || ($chars[$i] eq 'y' && $i == $length - 1)) {\n            $count++;\n        }\n    }\n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&vowels_count;\n        if(eq_deeply($candidate->(\"abcde\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Alone\"),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"key\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"bye\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"keY\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"bYe\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ACEDY\"),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_65","nl":"pan_Guru","pl":"pl","prompt":"# ਜੇ ਸ਼ਿਫਟ > ਅੰਕ ਦੀ ਗਿਣਤੀ, ਰਿਟਰਨ ਅੰਕ ਉਲਟ. # ਅਤੇ ਨਤੀਜਾ ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਵਾਪਸ ਕਰ ਦਿੰਦਾ ਹੈ।# ਸਰਕੂਲਰ ਪੂਰਨ ਅੰਕ x ਦੇ ਅੰਕ ਨੂੰ ਹਿਲਾਓ, ਹਿਲਾਓ ਦੇ ਕੇ ਅੰਕ ਨੂੰ ਸੱਜੇ ਪਾਸੇ ਹਿਲਾਓ # >>> circular_shift(12, 1)\n# \"21\"\n# >>> circular_shift(12, 2)\n# \"12\"\nsub circular_shift {\n    my($x, $shift) = @_;\n","canonical_solution":"sub circular_shift {\n    my($x, $shift) = @_;\n    my $digits = length($x);\n    \n    if ($shift > $digits) {\n        return reverse $x;\n    }\n    \n    $shift = $shift % $digits;\n    my $shifted = substr($x, -$shift) . substr($x, 0, $digits - $shift);\n    \n    return $shifted;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&circular_shift;\n        if(eq_deeply($candidate->(100, 2),\"001\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12, 2),\"12\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(97, 8),\"79\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12, 1),\"21\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11, 101),\"11\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_66","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਏਐੱਸਸੀਆਈਆਈ ਕੋਡ# ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਇਨਪੁਟ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ ਅਤੇ ਸਿਰਫ ਉਪਰਲੇ ਅੱਖਰਾਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰਦਾ ਹੈ' # ਕੰਮ # >>> digitSum(\"\")\n# 0\n# >>> digitSum(\"abAB\")\n# 131\n# >>> digitSum(\"abcCd\")\n# 67\n# >>> digitSum(\"helloE\")\n# 69\n# >>> digitSum(\"woArBld\")\n# 131\n# >>> digitSum(\"aAaaaXa\")\n# 153\nsub digitSum {\n    my($s) = @_;\n","canonical_solution":"sub digitSum {\n    my($s) = @_;\n    my $sum = 0;\n    foreach my $char (split \/\/, $s) {\n        if ($char =~ \/[A-Z]\/) {\n            $sum += ord($char);\n        }\n    }\n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&digitSum;\n        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abAB\"),131)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcCd\"),67)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"helloE\"),69)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"woArBld\"),131)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aAaaaXa\"),153)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\" How are yOu?\"),151)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"You arE Very Smart\"),327)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_67","nl":"pan_Guru","pl":"pl","prompt":"# ਲਈ ਐਕਸਾਮਬਲਃ # ਟੋਕਰੀ ਵਿੱਚ ਟੋਕਰੀ ਵਿੱਚ ਅੰਬ ਦੇ ਫਲਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ।# ਸੰਤਰੇ ਅਤੇ ਸੇਬ ਅਤੇ ਇੱਕ ਪੂਰਨ ਅੰਕ ਜੋ ਫਲ ਦੀ ਕੁੱਲ ਸੰਖਿਆ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ # ਸੇਬ, ਸੰਤਰੇ ਅਤੇ ਅੰਬ ਦੇ ਫਲ ਦਿੱਤੇ ਗਏ ਸਤਰ ਜੋ ਕਿ  ਦੀ ਕੁੱਲ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ# ਜੋ ਕਿ ਇੱਕ ਟੋਕਰੀ ਵਿੱਚ ਵੰਡਿਆ ਜਾਂਦਾ ਹੈ ਇਸ ਟੋਕਰੀ ਵਿੱਚ ਫਲਾਂ ਦੀ ਟੋਕਰੀ ਹੁੰਦੀ ਹੈ # ਇਸ ਕੰਮ ਵਿੱਚ, ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਜਾਵੇਗੀ ਜੋ ਕਿ ਸੇਬ ਅਤੇ ਸੰਤਰੇ ਦੀ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ।# >>> fruit_distribution(\"5 apples and 6 oranges\", 19)\n# 8\n# >>> fruit_distribution(\"0 apples and 1 oranges\", 3)\n# 2\n# >>> fruit_distribution(\"2 apples and 3 oranges\", 100)\n# 95\n# >>> fruit_distribution(\"100 apples and 1 oranges\", 120)\n# 19\nsub fruit_distribution {\n    my($s, $n) = @_;\n","canonical_solution":"sub fruit_distribution {\n    my($s, $n) = @_;\n    \n    # Extract numbers from the input string\n    my ($apples, $oranges) = $s =~ \/(\\d+) apples and (\\d+) oranges\/;\n    \n    # Calculate total apples and oranges\n    my $total_apples_oranges = $apples + $oranges;\n    \n    # Calculate number of mangoes\n    my $mangoes = $n - $total_apples_oranges;\n    \n    return $mangoes;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fruit_distribution;\n        if(eq_deeply($candidate->(\"5 apples and 6 oranges\", 19),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"5 apples and 6 oranges\", 21),10)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"0 apples and 1 oranges\", 3),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1 apples and 0 oranges\", 3),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2 apples and 3 oranges\", 100),95)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2 apples and 3 oranges\", 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1 apples and 100 oranges\", 120),19)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_68","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨ 1: # ਜੇ ਕੋਈ ਵੀ ਜੋੜ ਮੁੱਲ ਨਹੀਂ ਹਨ ਜਾਂ ਦਿੱਤਾ ਗਿਆ ਐਰੇ ਖਾਲੀ ਹੈ, ਵਾਪਸ ਕਰੋ [].# ਚੁਣਿਆ ਗਿਆ ਨੋਡ ਨੂੰ ਇੱਕ ਐਰੇ ਵਿੱਚ ਵਾਪਸ ਕੀਤਾ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ, [ smalest_value, ਇਸ ਦਾ ਇੰਡੈਕਸ ], # ਜੇਕਰ ਇੱਕੋ ਜਿਹੇ ਸਭ ਤੋਂ ਛੋਟੇ ਬਰਾਬਰ ਮੁੱਲ ਵਾਲੇ ਕਈ ਨੋਡ ਮਿਲਦੇ ਹਨ ਤਾਂ ਨੋਡ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜਿਸਦਾ ਸਭ ਤੋਂ ਛੋਟਾ ਇੰਡੈਕਸ ਹੈ।# ਚੁਣਿਆ ਗਿਆ ਨੋਡ ਸਭ ਤੋਂ ਛੋਟਾ ਜੋੜਾ ਮੁੱਲ ਵਾਲਾ ਨੋਡ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।# ਤੁਹਾਡਾ ਕੰਮ ਨੋਡਾਂ ਵਿੱਚੋਂ ਇੱਕ ਨੂੰ ਕੱਢਣਾ ਅਤੇ ਇਸਨੂੰ ਵਾਪਸ ਕਰਨਾ ਹੈ।# \"ਇੱਕ ਦਰੱਖਤ ਦੀ ਇੱਕ ਸ਼ਾਖਾ ਨੂੰ ਦਰਸਾਉਂਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ ਜਿਸ ਵਿੱਚ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਨੋਡ ਹਨ # >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n","canonical_solution":"sub pluck {\n    my ($arr) = @_;\n    my $min_even_value = undef;\n    my $min_index = undef;\n\n    for my $i (0 .. @$arr - 1) {\n        my $value = $arr->[$i];\n        if ($value % 2 == 0) {\n            if (!defined($min_even_value) || $value < $min_even_value) {\n                $min_even_value = $value;\n                $min_index = $i;\n            }\n        }\n    }\n\n    return defined($min_even_value) ? [$min_even_value, $min_index] : [];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_69","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਜੇ ਅਜਿਹਾ ਕੋਈ ਮੁੱਲ ਮੌਜੂਦ ਨਹੀਂ ਹੈ, ਤਾਂ -1 ਵਾਪਸ ਕਰੋ।# ਇੱਕ ਪੂਰਨ ਅੰਕ ਦੀ ਬਾਰੰਬਾਰਤਾ ਉਹ ਵਾਰ ਹੈ ਜਦੋਂ ਇਹ ਐਰੇ ਵਿੱਚ ਪ੍ਰਗਟ ਹੁੰਦਾ ਹੈ।# ਜ਼ੀਰੋ ਹੈ, ਅਤੇ ਇਸ ਦੀ ਬਾਰੰਬਾਰਤਾ ਪੂਰਨ ਅੰਕ ਦੇ ਮੁੱਲ ਤੋਂ ਵੱਧ ਜਾਂ ਬਰਾਬਰ ਹੈ।# ਤੁਹਾਨੂੰ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ. ਸਭ ਤੋਂ ਵੱਡਾ ਪੂਰਨ ਅੰਕ ਵਾਪਸ ਕਰੋ ਜੋ  ਤੋਂ ਵੱਡਾ ਹੈ# >>> search([4, 1, 2, 2, 3, 1])\n# 2\n# >>> search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n# 3\n# >>> search([5, 5, 4, 4, 4])\n# -1\nsub search {\n    my($lst) = @_;\n","canonical_solution":"sub search {\n    my($lst) = @_;\n    my %frequency;\n\n    foreach my $num (@$lst) {\n        $frequency{$num}++;\n    }\n\n    my $result = -1;\n    foreach my $num (keys %frequency) {\n        if ($num > 0 && $frequency{$num} >= $num) {\n            if ($num > $result) {\n                $result = $num;\n            }\n        }\n    }\n\n    return $result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&search;\n        if(eq_deeply($candidate->([5, 5, 5, 5, 1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 1, 4, 1, 4, 4]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 3]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([8, 8, 8, 8, 8, 8, 8, 8]),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 3, 3, 2, 2]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 8, 2]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([8, 8, 3, 6, 5, 6, 4]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 9, 10, 1, 3]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([10]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 10, 10, 9, 2]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_70","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਫਿਰ ਬਾਕੀ ਪੂਰਨ ਅੰਕ ਦਾ ਅਧਿਕਤਮ, ਫਿਰ ਘੱਟੋ ਘੱਟ ਅਤੇ ਇਸ ਤਰ੍ਹਾਂ ਜਾਰੀ ਹੈ।# ਅਜੀਬ ਤਰਤੀਬ, ਜਦੋਂ ਤੁਸੀਂ ਘੱਟੋ ਘੱਟ ਮੁੱਲ ਨਾਲ ਸ਼ੁਰੂ ਕਰਦੇ ਹੋ, # ਪੂਰਨ ਅੰਕ ਦੀ ਦਿੱਤੀ ਗਈ ਐਰੇ, ਅਜੀਬ ਕ੍ਰਮ ਵਿੱਚ ਐਰੇ ਵਾਪਸ ਕਰੋ.# >>> strange_sort_list([1, 2, 3, 4])\n# [1, 4, 2, 3]\n# >>> strange_sort_list([5, 5, 5, 5])\n# [5, 5, 5, 5]\n# >>> strange_sort_list([])\n# []\nsub strange_sort_list {\n    my($lst) = @_;\n","canonical_solution":"sub strange_sort_list {\n    my($lst) = @_;\n    my @result;\n    my @sorted = sort {$a <=> $b} @$lst;\n    \n    while (@sorted) {\n        push @result, shift @sorted;\n        push @result, pop @sorted if @sorted;\n    }\n    \n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&strange_sort_list;\n        if(eq_deeply($candidate->([1, 2, 3, 4]),[1, 4, 2, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 7, 8, 9]),[5, 9, 6, 8, 7])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5]),[1, 5, 2, 4, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 7, 8, 9, 1]),[1, 9, 5, 8, 6, 7])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 5, 5, 5]),[5, 5, 5, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6, 7, 8]),[1, 8, 2, 7, 3, 6, 4, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 2, 2, 2, 5, 5, -5, -5]),[-5, 5, -5, 5, 0, 2, 2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([111111]),[111111])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_71","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # ਤੀਜੇ ਪਾਸੇ ਤੋਂ ਵੱਧ.# ਤਿੰਨ ਪਾਸੇ ਇੱਕ ਜਾਇਜ਼ ਤਿਕੋਣ ਬਣਾਉਂਦੇ ਹਨ ਜਦੋਂ ਕਿਸੇ ਵੀ ਦੋ ਪਾਸਿਆਂ ਦਾ ਜੋੜ ਵੱਡਾ ਹੁੰਦਾ ਹੈ।# ਨਹੀਂ ਤਾਂ ਵਾਪਸੀ -1 # ਤਿਕੋਣ ਨੂੰ 2 ਦਸ਼ਮਲਵ ਬਿੰਦੂਆਂ ਤੱਕ ਗੋਲ ਕੀਤਾ ਜਾਂਦਾ ਹੈ ਜੇ ਤਿੰਨ ਪਾਸੇ ਇੱਕ ਪ੍ਰਮਾਣਿਕ ਤਿਕੋਣ ਬਣਾਉਂਦੇ ਹਨ।# ਇੱਕ ਤਿਕੋਣ ਦੇ ਤਿੰਨ ਪਾਸੇ ਦੀ ਲੰਬਾਈ ਦਿੱਤੀ ਗਈ ਹੈ.  ਦਾ ਖੇਤਰ ਵਾਪਸ ਕਰੋ# >>> triangle_area(3, 4, 5)\n# 6.0\n# >>> triangle_area(1, 2, 10)\n# -1\nsub triangle_area {\n    my($a, $b, $c) = @_;\n","canonical_solution":"sub triangle_area {\n    my($a, $b, $c) = @_;\n    \n    # Check if the sides form a valid triangle\n    unless ($a + $b > $c && $a + $c > $b && $b + $c > $a) {\n        return -1;\n    }\n    \n    # Calculate the semi-perimeter\n    my $s = ($a + $b + $c) \/ 2;\n    \n    # Calculate the area using Heron's formula\n    my $area = sqrt($s * ($s - $a) * ($s - $b) * ($s - $c));\n    \n    # Return the area rounded to 2 decimal points\n    return sprintf(\"%.2f\", $area);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&triangle_area;\n        if(eq_deeply($candidate->(3, 4, 5),6.0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 2, 10),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 8, 5),8.18)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 2, 2),1.73)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 2, 3),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10, 5, 7),16.25)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 6, 3),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 1, 1),0.43)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 2, 10),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_72","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # ਵਸਤੂ q ਉੱਡ ਜਾਵੇਗੀ ਜੇ ਇਹ ਸੰਤੁਲਿਤ ਹੈ (ਇਹ ਇੱਕ ਪਾਲੀਂਡਰੋਮਿਕ ਐਰੇ ਹੈ) ਅਤੇ ਇਸਦੇ ਤੱਤਾਂ ਦਾ ਜੋੜ ਵੱਧ ਤੋਂ ਵੱਧ ਸੰਭਵ ਭਾਰ w ਤੋਂ ਘੱਟ ਜਾਂ ਬਰਾਬਰ ਹੈ।# ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ 1 ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇ ਵਸਤੂ q ਉਡ ਜਾਵੇਗੀ, ਅਤੇ '' ਨਹੀਂ ਤਾਂ.# >>> will_it_fly([1, 2], 5)\n# \"\"\n# # 1+2 is less than the maximum possible weight, but it's unbalanced.\n# >>> will_it_fly([3, 2, 3], 1)\n# \"\"\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n# >>> will_it_fly([3, 2, 3], 9)\n# 1\n# # 3+2+3 is less than the maximum possible weight, and it's balanced.\n# >>> will_it_fly([3], 5)\n# 1\n# # 3 is less than the maximum possible weight, and it's balanced.\nsub will_it_fly {\n    my($q, $w) = @_;\n","canonical_solution":"sub will_it_fly {\n    my($q, $w) = @_;\n    # Check if the array is palindromic\n    my @reversed = reverse @$q;\n    return '' unless \"@$q\" eq \"@reversed\";\n\n    # Check if the sum of elements is within weight limit\n    my $sum = 0;\n    $sum += $_ for @$q;\n    return $sum <= $w ? 1 : '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&will_it_fly;\n        if(eq_deeply($candidate->([3, 2, 3], 9),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2], 5),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3], 5),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 3], 1),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3], 6),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5], 5),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_73","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਇੱਕ ਤਬਦੀਲੀ ਵਿੱਚ, ਤੁਸੀਂ ਇੱਕ ਤੱਤ ਨੂੰ ਕਿਸੇ ਹੋਰ ਤੱਤ ਵਿੱਚ ਬਦਲ ਸਕਦੇ ਹੋ।# ਐਰੇ ਨੂੰ ਪਾਲੀਂਡਰੋਮਿਕ ਬਣਾਉਣ ਲਈ ਬਦਲਣ ਦੀ ਲੋੜ ਹੈ। ਇੱਕ ਪਾਲੀਂਡਰੋਮਿਕ ਐਰੇ ਇੱਕ ਐਰੇ ਹੈ ਜੋ # ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ ਨੂੰ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤੱਤ ਦੀ ਘੱਟੋ ਘੱਟ ਗਿਣਤੀ ਲੱਭੋ ਜੋ # >>> smallest_change([1, 2, 3, 5, 4, 7, 9, 6])\n# 4\n# >>> smallest_change([1, 2, 3, 4, 3, 2, 2])\n# 1\n# >>> smallest_change([1, 2, 3, 2, 1])\n# 0\nsub smallest_change {\n    my($arr) = @_;\n","canonical_solution":"sub smallest_change {\n    my($arr) = @_;\n    my $count = 0;\n    my $n = scalar @$arr;\n    \n    for my $i (0 .. int($n \/ 2) - 1) {\n        if ($arr->[$i] != $arr->[$n - $i - 1]) {\n            $count++;\n        }\n    }\n    \n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&smallest_change;\n        if(eq_deeply($candidate->([1, 2, 3, 5, 4, 7, 9, 6]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 3, 2, 2]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 4, 2]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 4, 4, 2]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 2, 1]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 1, 1, 3]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_74","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਾਂ # ਜੇ ਦੋ ਐਰੇ ਵਿੱਚ ਅੱਖਰਾਂ ਦੀ ਇੱਕੋ ਜਿਹੀ ਗਿਣਤੀ ਹੈ, ਤਾਂ ਪਹਿਲੀ ਐਰੇ ਵਾਪਸ ਕਰੋ.# ਐਰੇ ਦੇ ਸਾਰੇ ਸਤਰਾਂ ਵਿੱਚ ਚਾਰਾਂ ਦੀ ਕੁੱਲ ਗਿਣਤੀ ਦੂਜੇ ਐਰੇ ਨਾਲੋਂ ਘੱਟ ਹੈ।# ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਤਰਾਂ ਦੇ ਦੋ ਐਰੇ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ ਅਤੇ ਐਰੇ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ # >>> total_match([], [])\n# []\n# >>> total_match([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n# [\"hI\", \"Hi\"]\n# >>> total_match([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n# [\"hi\", \"admin\"]\n# >>> total_match([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n# [\"hI\", \"hi\", \"hi\"]\n# >>> total_match([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n# [\"4\"]\nsub total_match {\n    my($lst1, $lst2) = @_;\n","canonical_solution":"sub total_match {\n    my ($lst1, $lst2) = @_;\n    \n    my $len1 = sum_chars($lst1);\n    my $len2 = sum_chars($lst2);\n\n    return $len1 <= $len2 ? $lst1 : $lst2;\n}\n\nsub sum_chars {\n    my ($array) = @_;\n    my $total = 0;\n    foreach my $string (@$array) {\n        $total += length($string);\n    }\n    return $total;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&total_match;\n        if(eq_deeply($candidate->([], []),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"hi\", \"admin\"], [\"hi\", \"hi\"]),[\"hi\", \"hi\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]),[\"hi\", \"admin\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]),[\"4\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"hi\", \"admin\"], [\"hI\", \"Hi\"]),[\"hI\", \"Hi\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]),[\"hI\", \"hi\", \"hi\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]),[\"hi\", \"admin\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([], [\"this\"]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"this\"], []),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_75","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # ਇਹ ਜਾਣ ਕੇ ਕਿ (a) 100 ਤੋਂ ਘੱਟ ਹੈ।# ਅਤੇ ਹੋਰ ਗਲਤ ਹੈ।# ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ ਜੇਕਰ ਦਿੱਤੀ ਗਈ ਸੰਖਿਆ 3 ਪ੍ਰਾਇਮ ਨੰਬਰਾਂ ਦਾ ਗੁਣਾ ਹੈ# >>> is_multiply_prime(30)\n# 1\n# 30 = 2 * 3 * 5\nsub is_multiply_prime {\n    my($a) = @_;\n","canonical_solution":"sub is_multiply_prime {\n    my($a) = @_;\n\n    return 0 if $a >= 100;\n\n    my @primes = grep { is_prime($_) } 2..int($a\/2);\n\n    for my $i (0..$#primes) {\n        for my $j ($i..$#primes) {\n            for my $k ($j..$#primes) {\n                if ($primes[$i] * $primes[$j] * $primes[$k] == $a) {\n                    return 1;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nsub is_prime {\n    my($n) = @_;\n    return 0 if $n < 2;\n    for my $i (2..sqrt($n)) {\n        return 0 if $n % $i == 0;\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_multiply_prime;\n        if(eq_deeply($candidate->(5),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(125),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(105),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(126),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(729),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(891),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1001),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_76","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # x n ਦੀ ਇੱਕ ਸਧਾਰਨ ਸ਼ਕਤੀ ਹੈ ਜੇਕਰ n**int=x # n ਦੀ ਸ਼ਕਤੀ ਅਤੇ ਹੋਰ ਮਾਮਲਿਆਂ ਵਿੱਚ ਗਲਤ ਹੈ।# ਤੁਹਾਡਾ ਕੰਮ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣਾ ਹੈ ਜੋ ਸਹੀ ਵਾਪਿਸ ਆਉਂਦੀ ਹੈ ਜੇਕਰ ਇੱਕ ਨੰਬਰ x ਇੱਕ ਸਧਾਰਨ ਹੈ # >>> is_simple_power(1, 4)\n# 1\n# >>> is_simple_power(2, 2)\n# 1\n# >>> is_simple_power(8, 2)\n# 1\n# >>> is_simple_power(3, 2)\n# \"\"\n# >>> is_simple_power(3, 1)\n# \"\"\n# >>> is_simple_power(5, 3)\n# \"\"\nsub is_simple_power {\n    my($x, $n) = @_;\n","canonical_solution":"sub is_simple_power {\n    my($x, $n) = @_;\n    \n    return 0 if $n <= 0;\n    return \"\" if $x < 1;\n    \n    if ($x == 1) {\n        return 1;\n    }\n\n    while ($x > 1) {\n        if ($x % $n != 0) {\n            return \"\";\n        }\n        $x \/= $n;\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_simple_power;\n        if(eq_deeply($candidate->(16, 2),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(143214, 16),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 2),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(9, 3),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(16, 4),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(24, 2),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(128, 4),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12, 6),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 12),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_77","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਨੋਟਃ ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਇਨਪੁਟ ਹਮੇਸ਼ਾ ਵੈਧ ਹੈ।# ਜੇਕਰ ਇਹ ਇੰਗੇਜਰ ਕਿਸੇ ਪੂਰਨ ਅੰਕ ਦਾ ਘਣ ਹੈ।# ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਪੂਰਨ ਅੰਕ a ਲੈਂਦਾ ਹੈ ਅਤੇ 1 ਵਾਪਸ ਕਰਦਾ ਹੈ।# >>> iscube(1)\n# 1\n# >>> iscube(2)\n# \"\"\n# >>> iscube(-1)\n# 1\n# >>> iscube(64)\n# 1\n# >>> iscube(0)\n# 1\n# >>> iscube(180)\n# \"\"\nsub iscube {\n    my($a) = @_;\n","canonical_solution":"sub iscube {\n    my($a) = @_;\n    my $cube_root = int($a ** (1\/3));\n    return 1 if $cube_root ** 3 == $a;\n    return 1 if ($cube_root + 1) ** 3 == $a; # handle small floating-point errors\n    return \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&iscube;\n        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(64),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(180),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1000),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1729),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_78","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਅਤੇ ਪ੍ਰਤੀਕ ਏ, ਬੀ, ਸੀ, ਡੀ, ਈ, ਐਫ ਹਮੇਸ਼ਾ ਵੱਡੇ ਅੱਖਰਾਂ ਵਿੱਚ ਹੁੰਦੇ ਹਨ।# ਨੋਟਃ ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਇਨਪੁਟ ਹਮੇਸ਼ਾ ਸਹੀ ਜਾਂ ਖਾਲੀ ਸਤਰ ਹੈ, # ਬੀ (= ਦਸਮ ਅੰਕ 11), ਡੀ (= ਦਸਮ ਅੰਕ 13). # ਇਸ ਲਈ ਤੁਹਾਨੂੰ ਹੇਠ ਲਿਖੇ ਅੰਕ ਦੀ ਗਿਣਤੀ ਪਤਾ ਕਰਨੀ ਪਵੇਗੀ: 2, 3, 5, 7, # ਪ੍ਰਾਇਮ ਨੰਬਰ 2, 3, 5, 7, 11, 13, 17,... ਹਨ।# ਹੈਕਸਾਡੇਸਿਮਲ ਅੰਕ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ਏ, ਬੀ, ਸੀ, ਡੀ, ਈ, ਐਫ ਹਨ।# 1 ਤੋਂ ਵੱਡਾ ਹੈ ਜੋ ਕਿ ਦੋ ਛੋਟੇ ਕੁਦਰਤੀ ਸੰਖਿਆਵਾਂ ਦਾ ਉਤਪਾਦ ਨਹੀਂ ਹੈ) ।# ਅੰਕ ਜੋ ਪ੍ਰਾਇਮ ਹਨ (ਪ੍ਰਾਇਮ ਨੰਬਰ, ਜਾਂ ਪ੍ਰਾਇਮ, ਇੱਕ ਕੁਦਰਤੀ ਸੰਖਿਆ ਹੈ)# ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਇੱਕ ਹੈਕਸਾਡੇਸੀਮਲ ਨੰਬਰ ਅਤੇ ਹੈਕਸਾਡੇਸੀਮਲ ਦੀ ਗਿਣਤੀ ਗਿਣਦਾ ਹੈ # ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣ ਲਈ ਕਿਹਾ ਗਿਆ ਹੈ ਜੋ ਪ੍ਰਾਪਤ ਕਰਦਾ ਹੈ# >>> hex_key(\"AB\")\n# 1\n# >>> hex_key(\"1077E\")\n# 2\n# >>> hex_key(\"ABED1A33\")\n# 4\n# >>> hex_key(\"123456789ABCDEF0\")\n# 6\n# >>> hex_key(\"2020\")\n# 2\nsub hex_key {\n    my($num) = @_;\n","canonical_solution":"sub hex_key {\n    my($num) = @_;\n    my %prime_hex_digits = map { $_ => 1 } ('2', '3', '5', '7', 'B', 'D');\n    my $prime_count = 0;\n    \n    foreach my $char (split \/\/, $num) {\n        $prime_count++ if exists $prime_hex_digits{$char};\n    }\n    \n    return $prime_count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&hex_key;\n        if(eq_deeply($candidate->(\"AB\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1077E\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ABED1A33\"),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2020\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"123456789ABCDEF0\"),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"112233445566778899AABBCCDDEEFF00\"),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_79","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਵਾਧੂ ਅੱਖਰ ਫਾਰਮੈਟ ਵਿੱਚ ਮਦਦ ਲਈ ਹਨ।# ਸਤਰ ਦੇ ਸ਼ੁਰੂ ਅਤੇ ਅੰਤ ਵਿੱਚ ਇੱਕ ਵਾਧੂ ਦੋ ਅੱਖਰ 'db' ਹੋਣਗੇ।# ਸਤਰ ਵਿੱਚ ਹਰੇਕ ਅੱਖਰ '0' ਜਾਂ '1' ਹੋਵੇਗਾ।# ਬਾਈਨਰੀ ਫਾਰਮੈਟ. ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ, ਜਿਸ ਵਿੱਚ ਹਰੇਕ ਅੱਖਰ ਇੱਕ ਬਾਈਨਰੀ  ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ।# ਤੁਹਾਨੂੰ ਦਸ਼ਮਲਵ ਰੂਪ ਵਿੱਚ ਇੱਕ ਨੰਬਰ ਦਿੱਤਾ ਜਾਵੇਗਾ ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ ਇਸ ਨੂੰ ਬਦਲਣਾ ਹੈ # >>> decimal_to_binary(15)\n# \"db1111db\"\n# >>> decimal_to_binary(32)\n# \"db100000db\"\nsub decimal_to_binary {\n    my($decimal) = @_;\n","canonical_solution":"sub decimal_to_binary {\n    my($decimal) = @_;\n    my $binary = sprintf(\"%b\", $decimal);\n    return \"db\" . $binary . \"db\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&decimal_to_binary;\n        if(eq_deeply($candidate->(0),\"db0db\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(32),\"db100000db\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(103),\"db1100111db\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(15),\"db1111db\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_80","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਇੱਕ ਸਤਰ ਖੁਸ਼ ਹੈ ਜੇ ਇਸਦੀ ਲੰਬਾਈ ਘੱਟੋ ਘੱਟ 3 ਹੈ ਅਤੇ ਹਰ 3 ਲਗਾਤਾਰ ਅੱਖਰ ਵੱਖਰੇ ਹਨ # ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਜਾਂਚਣਾ ਹੈ ਕਿ ਸਤਰ ਹੈਲਪ ਹੈ ਜਾਂ ਨਹੀਂ।# ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ s ਦਿੱਤੀ ਗਈ ਹੈ।# >>> is_happy(\"a\")\n# \"\"\n# >>> is_happy(\"aa\")\n# \"\"\n# >>> is_happy(\"abcd\")\n# 1\n# >>> is_happy(\"aabb\")\n# \"\"\n# >>> is_happy(\"adb\")\n# 1\n# >>> is_happy(\"xyy\")\n# \"\"\nsub is_happy {\n    my($s) = @_;\n","canonical_solution":"sub is_happy {\n    my($s) = @_;\n    return \"\" if length($s) < 3;\n    for my $i (0 .. length($s) - 3) {\n        my $substr = substr($s, $i, 3);\n        my %chars;\n        $chars{$_}++ for split \/\/, $substr;\n        return \"\" if keys(%chars) != 3;\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_happy;\n        if(eq_deeply($candidate->(\"a\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aa\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcd\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aabb\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"adb\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"xyy\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"iopaxpoi\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"iopaxioi\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_81","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # 0.0 ਈ# > 0.0 D- # > 0.7 D # > 1.0 ਡੀ+ # > 1.3 C- # > 1.7 C # > 2.0 C+ # > 2.3 ਬੀ- # > 2.7 B # > 3.0 ਬੀ+ # > 3.3 ਏ- # > 3.7 ਏ # 4.0 ਏ+ # GPA। ਪੱਤਰ ਗ੍ਰੇਡ।# ਇੱਕ ਫੰਕਸ਼ਨ ਜੋ ਹੇਠਲੀ ਸਾਰਣੀ ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਅੱਖਰ ਗ੍ਰੇਡਾਂ ਦੀ ਇੱਕ ਐਰੇ ਨੂੰ ਆਉਟਪੁੱਟ ਕਰ ਸਕਦਾ ਹੈਃ # ਉਸਨੇ ਤੁਹਾਨੂੰ ਕੁਝ ਵਿਦਿਆਰਥੀਆਂ ਲਈ ਗਰੇਡਾਂ ਦੀ ਇੱਕ ਲੜੀ ਦਿੱਤੀ ਹੈ ਅਤੇ ਤੁਹਾਨੂੰ ਲਿਖਣਾ ਹੈ ।# ਸਿਰਫ ਸਮੱਸਿਆ ਇਹ ਹੈ ਕਿ, ਉਸਨੇ ਗਰੇਡਿੰਗ ਲਈ ਵਰਤਿਆ ਕੋਡ ਗੁਆ ਦਿੱਤਾ ਹੈ।# ਵਿਦਿਆਰਥੀਆਂ ਨੂੰ ਗ੍ਰੇਡ ਦੇਣ ਲਈ ਅਧਿਆਪਕ ਆਪਣਾ ਅਲਗੋਰਿਦਮ ਬਣਾ ਰਿਹਾ ਹੈ।# ਇਹ ਸਮੈਸਟਰ ਦਾ ਆਖਰੀ ਹਫ਼ਤਾ ਹੈ ਅਤੇ ਅਧਿਆਪਕ ਨੂੰ ਗ੍ਰੇਡ ਦੇਣਾ ਹੈ # >>> grade_equation([4.0, 3, 1.7, 2, 3.5])\n# [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nsub numerical_letter_grade {\n    my($grades) = @_;\n","canonical_solution":"sub numerical_letter_grade {\n    my ($gpas) = @_;\n    my @letters;\n\n    foreach my $gpa (@$gpas) {\n        if ($gpa == 4.0) {\n            push @letters, 'A+';\n        } elsif ($gpa > 3.7) {\n            push @letters, 'A';\n        } elsif ($gpa > 3.3) {\n            push @letters, 'A-';\n        } elsif ($gpa > 3.0) {\n            push @letters, 'B+';\n        } elsif ($gpa > 2.7) {\n            push @letters, 'B';\n        } elsif ($gpa > 2.3) {\n            push @letters, 'B-';\n        } elsif ($gpa > 2.0) {\n            push @letters, 'C+';\n        } elsif ($gpa > 1.7) {\n            push @letters, 'C';\n        } elsif ($gpa > 1.3) {\n            push @letters, 'C-';\n        } elsif ($gpa > 1.0) {\n            push @letters, 'D+';\n        } elsif ($gpa > 0.7) {\n            push @letters, 'D';\n        } elsif ($gpa > 0.0) {\n            push @letters, 'D-';\n        } else {\n            push @letters, 'E';\n        }\n    }\n\n    return \\@letters;\n}\n\nmy $gpas = [4.0, 3, 1.7, 2, 3.5];\nmy $letter_grades = numerical_letter_grade($gpas);\nprint join(\", \", @$letter_grades);","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&numerical_letter_grade;\n        if(eq_deeply($candidate->([4.0, 3, 1.7, 2, 3.5]),[\"A+\", \"B\", \"C-\", \"C\", \"A-\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.2]),[\"D+\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.5]),[\"D-\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.0]),[\"E\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 0.3, 1.5, 2.8, 3.3]),[\"D\", \"D-\", \"C-\", \"B\", \"B+\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.0, 0.7]),[\"E\", \"D-\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_82","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਾਂ # ਲੰਬਾਈ ਇੱਕ ਪ੍ਰਾਇਮ ਨੰਬਰ ਹੈ ਜਾਂ ਨਹੀਂ ਤਾਂ # ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਲੈਂਦਾ ਹੈ ਅਤੇ 1 ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇ ਸਤਰ # >>> prime_length(\"Hello\")\n# 1\n# >>> prime_length(\"abcdcba\")\n# 1\n# >>> prime_length(\"kittens\")\n# 1\n# >>> prime_length(\"orange\")\n# \"\"\nsub prime_length {\n    my($string) = @_;\n","canonical_solution":"sub prime_length {\n    my ($string) = @_;\n    my $length = length($string);\n\n    return '' if $length < 2;\n    for my $i (2 .. sqrt($length)) {\n        return '' if $length % $i == 0;\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&prime_length;\n        if(eq_deeply($candidate->(\"Hello\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdcba\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"kittens\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"orange\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"wow\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"world\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"MadaM\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Wow\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"HI\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"go\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"gogo\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aaaaaaaaaaaaaaa\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Madam\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"M\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"0\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_83","nl":"pan_Guru","pl":"pl","prompt":"# ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਜੋ 1 ਨਾਲ ਸ਼ੁਰੂ ਜਾਂ ਖ਼ਤਮ ਹੁੰਦੇ ਹਨ।# ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, n-ਅੰਕਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ sub starts_one_ends {\n    my($n) = @_;\n","canonical_solution":"sub starts_one_ends {\n    my($n) = @_;\n    \n    # If n is 1, the numbers are 1, 2, 3, ..., 9 (single digit numbers starting\n    # or ending with 1), hence return 1 (only the number 1).\n    return 1 if $n == 1;\n\n    # Calculate the count of numbers starting with 1\n    # Numbers from 1..9 (n-1 zeros) give us 10^(n-1) choices\n    my $start_one_count = 10 ** ($n - 1);\n\n    # Calculate the count of numbers ending with 1\n    # Numbers from 10..10^(n-1) give us 10^(n-1) choices\n    my $end_one_count = 10 ** ($n - 1);\n\n    # However, numbers that both start and end with 1 (like 111...1)\n    # are counted twice so we need to add them in only once.\n    my $both_count = 1; # There's exactly one such number: 10^(n-1) + 1\n\n    # Total unique count\n    my $total_count = $start_one_count + $end_one_count - $both_count;\n\n    return $total_count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&starts_one_ends;\n        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2),18)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),180)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),1800)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),18000)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_84","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨ # ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ N ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸ ਦੇ ਅੰਕਾਂ ਦਾ ਕੁੱਲ ਜੋੜ ਬਾਈਨਰੀ ਵਿੱਚ ਵਾਪਸ ਕਰੋ।# >>> solve(1000)\n# \"1\"\n# >>> solve(150)\n# \"110\"\n# >>> solve(147)\n# \"1100\"\n# Variables:\n# @N integer\n# Constraints: 0 ≤ N ≤ 10000.\n# Output:\n# a string of binary number\nsub solve {\n    my($N) = @_;\n","canonical_solution":"sub solve {\n    my($N) = @_;\n    my $sum = 0;\n    $sum += $_ for split \/\/, $N;\n    return sprintf(\"%b\", $sum);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&solve;\n        if(eq_deeply($candidate->(1000),\"1\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(150),\"110\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(147),\"1100\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(333),\"1001\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(963),\"10010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_85","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਐਰੇ ਦਿੱਤੀ ਗਈ lst. ਜੋੜੇ ਤੱਤ ਜੋ ਅਜੀਬ ਸੂਚਕਾਂਕ ਤੇ ਹਨ ਜੋੜੋ .. # >>> add([4, 2, 6, 7])\n# 2\nsub add {\n    my($lst) = @_;\n","canonical_solution":"sub add {\n    my ($lst) = @_;\n    my $sum = 0;\n\n    for (my $i = 1; $i < @$lst; $i += 2) {\n        $sum += $lst->[$i] if $lst->[$i] % 2 == 0;\n    }\n\n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&add;\n        if(eq_deeply($candidate->([4, 88]),88)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 5, 6, 7, 2, 122]),122)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 0, 6, 7]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 4, 6, 8]),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_86","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਨੋਟਃ ਤੁਹਾਨੂੰ ਵਾਕ ਵਿੱਚ ਸ਼ਬਦਾਂ ਅਤੇ ਖਾਲੀ ਥਾਂਵਾਂ ਦੀ ਤਰਤੀਬ ਨੂੰ ਰੱਖਣਾ ਚਾਹੀਦਾ ਹੈ।# ਅਸਕੀ ਮੁੱਲ ਦੇ ਆਧਾਰ 'ਤੇ ਵਧਦਾ ਕ੍ਰਮ।# ਇੱਕ ਨਵੇਂ ਸ਼ਬਦ ਨਾਲ ਬਦਲਿਆ ਜਾਂਦਾ ਹੈ ਜਿੱਥੇ ਸਾਰੇ ਅੱਖਰ  ਵਿੱਚ ਵਿਵਸਥਿਤ ਹੁੰਦੇ ਹਨ# ਸਤਰ ਦਾ ਆਰਡਰਡ ਵਰਜਨ, ਇੱਕ ਸਤਰ ਹੈ ਜਿੱਥੇ ਸਾਰੇ ਸ਼ਬਦ (ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ) # ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਤਰ ਲੈਂਦਾ ਹੈ ਅਤੇ ਇਸਦਾ ਇੱਕ ਕ੍ਰਮਬੱਧ ਸੰਸਕਰਣ ਵਾਪਸ ਕਰਦਾ ਹੈ।# >>> anti_shuffle(\"Hi\")\n# \"Hi\"\n# >>> anti_shuffle(\"hello\")\n# \"ehllo\"\n# >>> anti_shuffle(\"Hello World!!!\")\n# \"Hello !!!Wdlor\"\nsub anti_shuffle {\n    my($s) = @_;\n","canonical_solution":"sub anti_shuffle {\n    my($s) = @_;\n    $s =~ s\/(\\S+)\/join('', sort split \/\/, $1)\/ge;\n    return $s;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&anti_shuffle;\n        if(eq_deeply($candidate->(\"Hi\"),\"Hi\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"hello\"),\"ehllo\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"number\"),\"bemnru\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcd\"),\"abcd\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello World!!!\"),\"Hello !!!Wdlor\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hi. My name is Mister Robot. How are you?\"),\".Hi My aemn is Meirst .Rboot How aer ?ouy\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_87","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਨਾਲ ਹੀ, ਕਤਾਰ ਦੇ ਕੋਆਰਡੀਨੇਟ ਨੂੰ ਕਾਲਮਾਂ ਦੇ ਅਨੁਸਾਰ ਘਟਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰੋ।# ਸ਼ੁਰੂ ਵਿੱਚ ਕਤਾਰਾਂ ਵਿੱਚ ਨਿਰਦੇਸ਼-ਅੰਕ ਨੂੰ ਵੱਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰੋ।# ਹਰ ਐਰੇ ਇੱਕ ਕੋਆਰਡੀਨੇਟ ਹੈ - (ਕਤਾਰ, ਕਾਲਮ), 0 ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ।# ਅਤੇ ਐਰੇ ਦੇ ਐਰੇ ਵਾਪਸ ਕਰੋ, [(x1, y1), (x2, y2) ...] ਅਜਿਹੇ ਕਿ # lst, ਅਤੇ ਪੂਰਨ ਅੰਕ x ਦਿੱਤੇ ਗਏ ਹਨ, ਐਰੇ ਵਿੱਚ ਪੂਰਨ ਅੰਕ x ਲੱਭੋ, # ਹਰੇਕ ਕਤਾਰ ਵਿੱਚ ਵੱਖ-ਵੱਖ ਗਿਣਤੀ ਦੇ ਕਾਲਮ ਹੋ ਸਕਦੇ ਹਨ।# ਜੋ ਕਿ ਮੈਟ੍ਰਿਕਸ ਦੇ ਸਮਾਨ ਹੈ, ਹਾਲਾਂਕਿ, ਮੈਟ੍ਰਿਕਸ ਦੇ ਉਲਟ, # ਤੁਹਾਨੂੰ ਇੱਕ 2 ਅਯਾਮੀ ਡਾਟਾ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇੱਕ ਨੇਸਟਡ ਐਰੇ ਦੇ ਰੂਪ ਵਿੱਚ, # >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n# >>> get_row([], 1)\n# []\n# >>> get_row([[], [1], [1, 2, 3]], 3)\n# [[2, 2]]\nsub get_row {\n    my($lst, $x) = @_;\n","canonical_solution":"sub get_row {\n    my ($lst, $x) = @_;\n    my @result;\n\n    for my $i (0 .. @$lst - 1) {\n        my @row_result;\n        for my $j (0 .. @{$lst->[$i]} - 1) {\n            if ($lst->[$i][$j] == $x) {\n                push @row_result, [$i, $j];\n            }\n        }\n        # Sort the coordinates of the row by columns in descending order\n        @row_result = sort { $b->[1] <=> $a->[1] } @row_result;\n        push @result, @row_result;\n    }\n\n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_row;\n        if(eq_deeply($candidate->([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([], 1),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1]], 2),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[], [1], [1, 2, 3]], 3),[[2, 2]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_88","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # * ਦਿੱਤੇ ਗਏ ਐਰੇ ਨੂੰ ਨਾ ਬਦਲੋ. # ਨੋਟਃ # ਜਾਂ ਇਸਨੂੰ ਘਟਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰੋ ਜੇਕਰ ਜੋੜ ((ਪਹਿਲਾ ਇੰਡੈਕਸ ਮੁੱਲ, ਆਖਰੀ ਇੰਡੈਕਸ ਮੁੱਲ) ਜੋੜਾ ਹੈ।# ਤੁਸੀਂ ਦਿੱਤੇ ਗਏ ਐਰੇ ਨੂੰ ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕਰੋਗੇ ਜੇ ਜੋੜ ((ਪਹਿਲਾ ਇੰਡੈਕਸ ਮੁੱਲ, ਆਖਰੀ ਇੰਡੈਕਸ ਮੁੱਲ) ਅਜੀਬ ਹੈ, # ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਕ੍ਰਮਬੱਧ ਕਰਨ ਤੋਂ ਬਾਅਦ ਦਿੱਤੀ ਗਈ ਐਰੇ ਦਾ ਇੱਕ ਕੋਪਲ ਵਾਪਸ ਕਰੋ, # >>> sort_array([])\n# []\n# >>> sort_array([5])\n# [5]\n# >>> sort_array([2, 4, 3, 0, 1, 5])\n# [0, 1, 2, 3, 4, 5]\n# >>> sort_array([2, 4, 3, 0, 1, 5, 6])\n# [6, 5, 4, 3, 2, 1, 0]\nsub sort_array {\n    my($array) = @_;\n","canonical_solution":"sub sort_array {\n    my ($array) = @_;\n    return [] if !@$array;  # Return empty array if input is empty\n\n    my $first = $array->[0];\n    my $last = $array->[-1];\n    my $sum = $first + $last;\n\n    if ($sum % 2 == 0) {\n        # Sort in descending order if the sum is even\n        return [sort { $b <=> $a } @$array];\n    } else {\n        # Sort in ascending order if the sum is odd\n        return [sort { $a <=> $b } @$array];\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_array;\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5]),[5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 3, 0, 1, 5]),[0, 1, 2, 3, 4, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 3, 0, 1, 5, 6]),[6, 5, 4, 3, 2, 1, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 1]),[1, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([15, 42, 87, 32, 11, 0]),[0, 11, 15, 32, 42, 87])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([21, 14, 23, 11]),[23, 21, 14, 11])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_89","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਦੋ ਗੁਣਾ ਕਰਕੇ ਦੋ ਸਥਾਨਾਂ 'ਤੇ ਹੇਠਾਂ ਜਾਣ।# ਅੱਖਰ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਘੁੰਮਾਇਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ ਕਿ ਅੱਖਰ # ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਦੀ ਹੈ ਜੋ ਅੱਖਰ ਨੂੰ ਘੁੰਮਾਉਣ ਦੇ ਨਾਲ ਏਨਕ੍ਰਿਪਟ ਕੀਤੀ ਗਈ ਹੈ।# ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਇੱਕ ਆਰਗੂਮੈਂਟ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ ਅਤੇ # >>> encrypt(\"hi\")\n# \"lm\"\n# >>> encrypt(\"asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt(\"gf\")\n# \"kj\"\n# >>> encrypt(\"et\")\n# \"ix\"\nsub encrypt {\n    my($s) = @_;\n","canonical_solution":"sub encrypt {\n    my($s) = @_;\n    my $shift = 2 * 2;  # Alphabet shifted by two multiplied by two places (4 places)\n    $s =~ tr\/a-zA-Z\/n-za-mN-ZA-M\/;  # Perform a Caesar cipher with a shift of 13 places\n    return $s;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&encrypt;\n        if(eq_deeply($candidate->(\"hi\"),\"lm\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"asdfghjkl\"),\"ewhjklnop\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"gf\"),\"kj\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"et\"),\"ix\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"faewfawefaewg\"),\"jeiajeaijeiak\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"hellomyfriend\"),\"lippsqcjvmirh\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"),\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"a\"),\"e\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_90","nl":"pan_Guru","pl":"pl","prompt":"# undef ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਅਜਿਹਾ ਕੋਈ ਤੱਤ ਨਹੀਂ ਹੈ।# ਇੱਕ ਫੰਕਸ਼ਨ next_smallest ਲਿਖੋ ਜੋ ਐਰੇ ਦੇ ਦੂਜੇ ਸਭ ਤੋਂ ਛੋਟੇ ਤੱਤ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ।# ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਲੜੀ ਦਿੱਤੀ ਗਈ ਹੈ।# >>> next_smallest([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest([5, 1, 4, 3, 2])\n# 2\n# >>> next_smallest([])\n# undef\n# >>> next_smallest([1, 1])\n# undef\nsub next_smallest {\n    my($lst) = @_;\n","canonical_solution":"sub next_smallest {\n    my($lst) = @_;\n    \n    # Return undef if the list has less than two elements\n    return undef unless @$lst >= 2;\n    \n    # Sort the unique elements of the list\n    my @sorted_unique = sort { $a <=> $b } keys %{{ map { $_ => 1 } @$lst }};\n    \n    # If there is only one unique element, return undef, else return the second smallest\n    return @sorted_unique >= 2 ? $sorted_unique[1] : undef;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&next_smallest;\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 1, 4, 3, 2]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1]),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1, 1, 1, 0]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1]),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-35, 34, 12, -45]),-35)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_91","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਵਾਕਾਂ ਨੂੰ '', '?' ਜਾਂ '!' ਨਾਲ ਸੀਮਿਤ ਕੀਤਾ ਜਾਂਦਾ ਹੈ।# ਇੱਕ ਬੋਰਡ ਇੱਕ ਵਾਕ ਹੈ ਜੋ \"I\" ਸ਼ਬਦ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ।# ਤੁਹਾਨੂੰ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਲੜੀ ਦਿੱਤੀ ਜਾਵੇਗੀ, ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ ਨੰਬਰ ਗਿਣਨਾ ਹੈ।# >>> is_bored(\"Hello world\")\n# 0\n# >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\nsub is_bored {\n    my($S) = @_;\n","canonical_solution":"my($S) = @_;\n    my $count = 0;\n    my @sentences = split \/(?<=[.?!])\\s*\/, $S;\n    foreach my $sentence (@sentences) {\n        $sentence =~ s\/^\\s+|\\s+$\/\/g;\n        $count++ if $sentence =~ \/^I\\b\/i;\n    }\n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_bored;\n        if(eq_deeply($candidate->(\"Hello world\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Is the sky blue?\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"I love It !\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"bIt\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"I feel good today. I will be productive. will kill It\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"You and I are going for a walk\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_92","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਾਂ # ਕਿਸੇ ਵੀ ਹੋਰ ਮਾਮਲਿਆਂ ਵਿੱਚ ਗਲਤ ਵਾਪਿਸ ਕਰਦਾ ਹੈ।# ਸਹੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਇੱਕ ਨੰਬਰ ਦੂਜੇ ਦੋ ਦੇ ਜੋੜ ਦੇ ਬਰਾਬਰ ਹੈ, ਅਤੇ ਸਾਰੇ ਨੰਬਰ ਪੂਰਨ ਅੰਕ ਹਨ.# ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ 3 ਨੰਬਰ ਲੈਂਦਾ ਹੈ.# >>> any_int(5, 2, 7)\n# 1\n# >>> any_int(3, 2, 2)\n# \"\"\n# >>> any_int(3, -2, 1)\n# 1\n# >>> any_int(3.6, -2.2, 2)\n# \"\"\nsub any_int {\n    my($x, $y, $z) = @_;\n","canonical_solution":"sub any_int {\n    my($x, $y, $z) = @_;\n    \n    # Check if all inputs are integers\n    return \"\" unless defined $x && defined $y && defined $z;\n    return \"\" unless $x =~ \/^-?\\d+$\/ && $y =~ \/^-?\\d+$\/ && $z =~ \/^-?\\d+$\/;\n    \n    # Check if any number is the sum of the other two\n    return 1 if $x == $y + $z;\n    return 1 if $y == $x + $z;\n    return 1 if $z == $x + $y;\n    \n    return \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&any_int;\n        if(eq_deeply($candidate->(2, 3, 1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2.5, 2, 3),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1.5, 5, 3.5),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 6, 2),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 2, 2),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2.2, 2.2, 2.2),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-4, 6, 2),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 1, 1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3, 4, 7),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3.0, 4, 7),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_93","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਕੇਵਲ ਅੱਖਰਾਂ ਨੂੰ ਹੀ ਮੰਨ ਲਓ।# ਅੰਗਰੇਜ਼ੀ ਵਰਣਮਾਲਾ ਵਿੱਚ ਧੁਨੀ।# ਉਸ ਤੋਂ ਦੋ ਸਥਾਨ ਅੱਗੇ ਦਿਖਾਈ ਦੇਣ ਵਾਲੇ ਅੱਖਰ ਵਾਲਾ ਸੰਦੇਸ਼ # ਇਸ ਤਰ੍ਹਾਂ ਇਹ ਸਾਰੇ ਅੱਖਰਾਂ ਦੇ ਕੇਸ ਬਦਲਦਾ ਹੈ,  ਵਿੱਚ ਸਾਰੇ ਵੋਕਲਸ ਨੂੰ ਬਦਲਦਾ ਹੈ# ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸੰਦੇਸ਼ ਲੈਂਦਾ ਹੈ, ਅਤੇ ਅਜਿਹੇ ਵਿੱਚ ਏਨਕੋਡ ਕਰਦਾ ਹੈ # >>> encode(\"test\")\n# \"TGST\"\n# >>> encode(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\nsub encode {\n    my($message) = @_;\n","canonical_solution":"sub encode {\n    my($message) = @_;\n    $message =~ tr\/A-Za-z\/N-ZA-Mn-za-m\/;\n    $message =~ tr\/aeiouAEIOU\/cgkqwCGKQW\/;\n    return $message;\n}\n\n# Example usage\nprint encode(\"test\"), \"\\n\";       # Output: TGST\nprint encode(\"This is a message\"), \"\\n\"; # Output: tHKS KS C MGSSCGG","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&encode;\n        if(eq_deeply($candidate->(\"TEST\"),\"tgst\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mudasir\"),\"mWDCSKR\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"YES\"),\"ygs\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"This is a message\"),\"tHKS KS C MGSSCGG\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"I DoNt KnOw WhAt tO WrItE\"),\"k dQnT kNqW wHcT Tq wRkTg\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_94","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਤੁਹਾਨੂੰ ਸਭ ਤੋਂ ਵੱਡਾ ਪ੍ਰਾਇਮ ਵੈਲਯੂ ਲੱਭਣ ਦੀ ਲੋੜ ਹੈ ਅਤੇ ਇਸਦੇ ਅੰਕ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰੋ.# ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਲੜੀ ਦਿੱਤੀ ਗਈ ਹੈ।# >>> skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n# 10\n# >>> skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n# 25\n# >>> skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n# 13\n# >>> skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n# 11\n# >>> skjkasdkd([0, 81, 12, 3, 1, 21])\n# 3\n# >>> skjkasdkd([0, 8, 1, 2, 1, 7])\n# 7\nsub skjkasdkd {\n    my($lst) = @_;\n","canonical_solution":"sub skjkasdkd {\n    my ($lst) = @_;\n\n    # Helper function to determine if a number is prime\n    sub is_prime {\n        my ($num) = @_;\n        return 0 if $num < 2;\n        for my $i (2 .. sqrt($num)) {\n            return 0 if $num % $i == 0;\n        }\n        return 1;\n    }\n\n    # Find the largest prime in the array\n    my $largest_prime = -1;\n    foreach my $num (@$lst) {\n        if (is_prime($num)) {\n            $largest_prime = $num if $num > $largest_prime;\n        }\n    }\n\n    # Return the sum of the digits of the largest prime\n    if ($largest_prime > 0) {\n        my $sum_of_digits = 0;\n        $sum_of_digits += $_ for split \/\/, $largest_prime;\n        return $sum_of_digits;\n    }\n\n    return 0;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&skjkasdkd;\n        if(eq_deeply($candidate->([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]),10)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]),25)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]),13)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]),11)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 81, 12, 3, 1, 21]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 8, 1, 2, 1, 7]),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([8191]),19)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([8191, 123456, 127, 7]),19)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([127, 97, 8192]),10)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_95","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਫੰਕਸ਼ਨ ਨੂੰ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ '' ਦਿੱਤਾ ਗਿਆ ਹੈਸ਼ ਖਾਲੀ ਹੈ. # ਵੱਡੇ ਅੱਖਰਾਂ ਵਿੱਚ ਸਤਰਾਂ ਹਨ, ਨਹੀਂ ਤਾਂ ਵਾਪਸੀ ''.# ਇੱਕ ਹੈਸ਼ ਦਿੱਤਾ ਗਿਆ ਹੈ, 1 ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਸਾਰੀਆਂ ਕੁੰਜੀਆਂ ਹੇਠਲੇ ਵਿੱਚ ਸਤਰਾਂ ਹਨ # >>> check_dict_case({\"a\" => \"apple\", \"b\" => \"banana\"})\n# 1\n# >>> check_dict_case({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# \"\"\n# >>> check_dict_case({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# \"\"\n# >>> check_dict_case({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# \"\"\n# >>> check_dict_case({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# 1\nsub check_dict_case {\n    my($dict) = @_;\n","canonical_solution":"sub check_dict_case {\n    my($dict) = @_;\n    return '' unless %$dict;\n\n    my $all_lower = 1;\n    my $all_upper = 1;\n\n    for my $key (keys %$dict) {\n        if ($key !~ \/^[a-z]+$\/) {\n            $all_lower = 0;\n        }\n        if ($key !~ \/^[A-Z]+$\/) {\n            $all_upper = 0;\n        }\n    }\n    \n    return ($all_lower || $all_upper) ? 1 : '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&check_dict_case;\n        if(eq_deeply($candidate->({\"p\" => \"pineapple\", \"b\" => \"banana\"}),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({}),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_96","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਪੂਰਨ ਅੰਕ ਜੋ ਪ੍ਰਾਇਮ ਨੰਬਰ ਹਨ ਅਤੇ n ਤੋਂ ਘੱਟ ਹਨ।# ਇੱਕ ਫੰਕਸ਼ਨ ਲਾਗੂ ਕਰੋ ਜੋ ਇੱਕ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਲੈਂਦਾ ਹੈ ਅਤੇ ਪਹਿਲੇ n ਦੀ ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰਦਾ ਹੈ।# >>> count_up_to(5)\n# [2, 3]\n# >>> count_up_to(11)\n# [2, 3, 5, 7]\n# >>> count_up_to(0)\n# []\n# >>> count_up_to(20)\n# [2, 3, 5, 7, 11, 13, 17, 19]\n# >>> count_up_to(1)\n# []\n# >>> count_up_to(18)\n# [2, 3, 5, 7, 11, 13, 17]\nsub count_up_to {\n    my($n) = @_;\n","canonical_solution":"sub count_up_to {\n    my($n) = @_;\n    my @primes;\n    for my $num (2 .. $n - 1) {\n        my $is_prime = 1;\n        for my $div (2 .. sqrt($num)) {\n            if ($num % $div == 0) {\n                $is_prime = 0;\n                last;\n            }\n        }\n        push @primes, $num if $is_prime;\n    }\n    return @primes;\n}\n\n# Example usage:\n# my @result = count_up_to(11);\n# print \"@result\\n\";  # Output: 2 3 5 7","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&count_up_to;\n        if(eq_deeply($candidate->(5),[2, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),[2, 3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),[2, 3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),[2, 3, 5, 7])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(22),[2, 3, 5, 7, 11, 13, 17, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(18),[2, 3, 5, 7, 11, 13, 17])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(47),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(101),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_97","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਮੰਨ ਲਓ ਕਿ ਇਨਪੁਟ ਹਮੇਸ਼ਾ ਵੈਧ ਹੈ।# ਉਹਨਾਂ ਦੇ ਯੂਨਿਟ ਅੰਕ ਦੇ ਉਤਪਾਦ.# ਫੰਕਸ਼ਨ ਨੂੰ ਪੂਰਾ ਕਰੋ ਜੋ ਦੋ ਪੂਰਨ ਅੰਕ ਲੈਂਦਾ ਹੈ ਅਤੇ ਵਾਪਿਸ ਆਉਂਦਾ ਹੈ # >>> multiply(148, 412)\n# 16\n# >>> multiply(19, 28)\n# 72\n# >>> multiply(2020, 1851)\n# 0\n# >>> multiply(14, -15)\n# 20\nsub multiply {\n    my($a, $b) = @_;\n","canonical_solution":"sub multiply {\n    my($a, $b) = @_;\n    my $unit_digit_a = abs($a) % 10;\n    my $unit_digit_b = abs($b) % 10;\n    return $unit_digit_a * $unit_digit_b;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&multiply;\n        if(eq_deeply($candidate->(148, 412),16)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(19, 28),72)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2020, 1851),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(14, -15),20)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(76, 67),42)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(17, 27),49)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0, 1),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0, 0),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_98","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਇੱਕ ਸਤਰ s ਦਿੱਤੀ ਗਈ ਹੈ, ਜੋ ਕਿ ਵੀ ਸੂਚਕਾਂਕ ਵਿੱਚ ਵੱਡੇ ਅੱਖਰ ਦੇ ਵੋਕਲ ਦੀ ਗਿਣਤੀ ਗਿਣੋ.# >>> count_upper(\"aBCdEf\")\n# 1\n# >>> count_upper(\"abcdefg\")\n# 0\n# >>> count_upper(\"dBBE\")\n# 0\nsub count_upper {\n    my($s) = @_;\n","canonical_solution":"sub count_upper {\n    my($s) = @_;\n    my $count = 0;\n    my @chars = split \/\/, $s;\n    \n    for (my $i = 0; $i < @chars; $i += 2) {\n        if ($chars[$i] =~ \/[AEIOU]\/) {\n            $count++;\n        }\n    }\n    \n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&count_upper;\n        if(eq_deeply($candidate->(\"aBCdEf\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdefg\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"dBBE\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"B\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"U\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"EEEE\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_99","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਾਂ # ਦੋ ਪੂਰਨ ਅੰਕ ਤੋਂ, ਇਸ ਨੂੰ ਜ਼ੀਰੋ ਤੋਂ ਦੂਰ ਕਰ ਦਿਓ।# ਅਤੇ ਇਸ ਦੇ ਸਭ ਤੋਂ ਨਜ਼ਦੀਕੀ ਪੂਰਨ ਅੰਕ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ. ਜੇਕਰ ਨੰਬਰ ਬਰਾਬਰ ਹੈ # ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਨੰਬਰ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ (ਸਟ੍ਰਿੰਗ)# >>> closest_integer(\"10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\nsub closest_integer {\n    my($value) = @_;\n","canonical_solution":"sub closest_integer {\n    my($value) = @_;\n    \n    # Convert the string value to a number\n    my $number = 0 + $value;\n    \n    # Compute the floor and ceiling of the number\n    my $floor = int($number);\n    my $ceiling = $number > $floor ? $floor + 1 : $floor;\n    \n    # Determine the integer to round to\n    if ($number < 0) {\n        # For negative numbers, closer to zero means returning the lower number\n        return ($number - $floor <= $ceiling - $number) ? $floor : $ceiling;\n    } else {\n        # For positive numbers, closer to zero means returning the lower number\n        return ($ceiling - $number <= $number - $floor) ? $ceiling : $floor;\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&closest_integer;\n        if(eq_deeply($candidate->(\"10\"),10)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"14.5\"),15)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"-15.5\"),-16)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"15.3\"),15)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"0\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_100","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # i ਪੱਧਰ (i+1) ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਸੰਖਿਆ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ।# ਇੱਕ ਐਰੇ ਵਿੱਚ ਹਰੇਕ ਪੱਧਰ ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ, ਜਿੱਥੇ ਤੱਤ ਇੰਡੈਕਸ # - ਅਗਲੀ ਜੋੜੀ ਸੰਖਿਆ ਜੇ n ਜੋੜੀ ਹੈ।# - ਅਗਲਾ ਅਜੀਬ ਨੰਬਰ ਜੇ n ਅਜੀਬ ਹੈ.# ਅਗਲੇ ਪੱਧਰ ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਹੈਃ # ਪਹਿਲੇ ਪੱਧਰ ਵਿੱਚ n ਪੱਥਰ ਹਨ।# ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤੁਹਾਨੂੰ ਪੱਥਰਾਂ ਦੇ n ਪੱਧਰਾਂ ਦਾ ਇੱਕ ਢੇਰ ਬਣਾਉਣਾ ਹੋਵੇਗਾ।# >>> make_a_pile(3)\n# [3, 5, 7]\nsub make_a_pile {\n    my($n) = @_;\n","canonical_solution":"sub make_a_pile {\n    my ($n) = @_;\n    my @pile;\n    my $current_stones = $n;\n    \n    for my $level (1..$n) {\n        push @pile, $current_stones;\n        if ($n % 2 == 0) {\n            $current_stones += 2;  # Increment by next even number\n        } else {\n            $current_stones += 2;  # Increment by next odd number (which is also +2)\n        }\n    }\n    \n    return @pile;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&make_a_pile;\n        if(eq_deeply($candidate->(3),[3, 5, 7])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),[4, 6, 8, 10])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),[5, 7, 9, 11, 13])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),[6, 8, 10, 12, 14, 16])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),[8, 10, 12, 14, 16, 18, 20, 22])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_101","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਸਤਰ ਨੂੰ ਸ਼ਬਦਾਂ ਵਿੱਚ ਵੰਡਣ ਅਤੇ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰਨ ਲਈ।# ਤੁਹਾਨੂੰ ਕਾਮੇ ਜਾਂ ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਜਾਵੇਗੀ। ਤੁਹਾਡਾ ਕੰਮ ਹੈ # >>> words_string(\"Hi, my name is John\")\n# [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# >>> words_string(\"One, two, three, four, five, six\")\n# [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nsub words_string {\n    my($s) = @_;\n","canonical_solution":"sub words_string {\n    my ($s) = @_;\n    my @words = split \/[,\\s]+\/, $s;\n    return \\@words;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&words_string;\n        if(eq_deeply($candidate->(\"Hi, my name is John\"),[\"Hi\", \"my\", \"name\", \"is\", \"John\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"One, two, three, four, five, six\"),[\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hi, my name\"),[\"Hi\", \"my\", \"name\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"One,, two, three, four, five, six,\"),[\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ahmed     , gamal\"),[\"ahmed\", \"gamal\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_102","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਕੋਈ ਅਜਿਹੀ ਗਿਣਤੀ ਨਹੀਂ ਹੈ, ਤਾਂ ਫੰਕਸ਼ਨ ਨੂੰ -1 ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ.# ਸਭ ਤੋਂ ਵੱਡੀ ਪੂਰਨ ਸੰਖਿਆ ਜੋ ਕਿ [x, y] ਦੀ ਰੇਂਜ ਵਿੱਚ ਹੈ।# ਇਹ ਫੰਕਸ਼ਨ ਦੋ ਸਕਾਰਾਤਮਕ ਨੰਬਰ x ਅਤੇ y ਲੈਂਦਾ ਹੈ ਅਤੇ  ਵਾਪਸ ਕਰਦਾ ਹੈ# >>> choose_num(12, 15)\n# 14\n# >>> choose_num(13, 12)\n# -1\nsub choose_num {\n    my($x, $y) = @_;\n","canonical_solution":"sub choose_num {\n    my($x, $y) = @_;\n    return -1 if $x > $y;\n    \n    # Swap x and y if x is greater than y\n    ($x, $y) = ($y, $x) if $x > $y;\n    \n    for (my $i = $y; $i >= $x; $i--) {\n        return $i if $i % 2 == 0;\n    }\n    return -1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&choose_num;\n        if(eq_deeply($candidate->(12, 15),14)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(13, 12),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(33, 12354),12354)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5234, 5233),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6, 29),28)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(27, 10),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 7),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(546, 546),546)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_103","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # ਜੇ n m ਤੋਂ ਵੱਡਾ ਹੈ, ਤਾਂ -1 ਵਾਪਸ ਕਰੋ।# ਉੱਤਰ ਨੂੰ ਸਭ ਤੋਂ ਨਜ਼ਦੀਕੀ ਪੂਰਨ ਅੰਕ ਤੇ ਗੋਲ ਕਰੋ ਅਤੇ ਇਸਨੂੰ ਬਾਈਨਰੀ ਵਿੱਚ ਤਬਦੀਲ ਕਰੋ।# n ਤੋਂ m ਤੱਕ ਦੇ ਪੂਰਨ ਅੰਕ ਦਾ ਔਸਤ (n ਅਤੇ m ਸਮੇਤ) ।# ਤੁਹਾਨੂੰ ਦੋ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਅਤੇ m ਦਿੱਤੇ ਗਏ ਹਨ, ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ  ਦੀ ਗਣਨਾ ਕਰਨਾ ਹੈ# >>> rounded_avg(1, 5)\n# \"0b11\"\n# >>> rounded_avg(7, 5)\n# -1\n# >>> rounded_avg(10, 20)\n# \"0b1111\"\n# >>> rounded_avg(20, 33)\n# \"0b11010\"\nsub rounded_avg {\n    my($n, $m) = @_;\n","canonical_solution":"sub rounded_avg {\n    my ($n, $m) = @_;\n    \n    return -1 if $n > $m;\n    \n    my $sum = 0;\n    my $count = $m - $n + 1;\n    \n    for my $i ($n .. $m) {\n        $sum += $i;\n    }\n    \n    my $average = int(($sum \/ $count) + 0.5);\n    return sprintf(\"0b%b\", $average);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&rounded_avg;\n        if(eq_deeply($candidate->(1, 5),\"0b11\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 13),\"0b1010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(964, 977),\"0b1111001010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(996, 997),\"0b1111100100\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(560, 851),\"0b1011000010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(185, 546),\"0b101101110\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(362, 496),\"0b110101101\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(350, 902),\"0b1001110010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(197, 233),\"0b11010111\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 5),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 1),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 5),\"0b101\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_104","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਨੋਟਃ ਵਾਪਸ ਕੀਤੇ ਗਏ ਐਰੇ ਨੂੰ ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ।# ਉਹ ਤੱਤ ਜਿਸ ਵਿੱਚ ਕੋਈ ਵੀ ਅੰਕ ਨਾ ਹੋਵੇ।# ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ x ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ. ਸਾਰੇ  ਦੀ ਇੱਕ ਕ੍ਰਮਬੱਧ ਐਰੇ ਵਾਪਸ ਕਰੋ# >>> unique_digits([15, 33, 1422, 1])\n# [1, 15, 33]\n# >>> unique_digits([152, 323, 1422, 10])\n# []\nsub unique_digits {\n    my($x) = @_;\n","canonical_solution":"sub unique_digits {\n    my ($x) = @_;\n    my @result;\n\n    foreach my $num (@$x) {\n        if ($num !~ \/[02468]\/) {\n            push @result, $num;\n        }\n    }\n    \n    return sort { $a <=> $b } @result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&unique_digits;\n        if(eq_deeply($candidate->([15, 33, 1422, 1]),[1, 15, 33])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([152, 323, 1422, 10]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([12345, 2033, 111, 151]),[111, 151])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([135, 103, 31]),[31, 135])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_105","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # \"ਇੱਕ\", \"ਦੋ\", \"ਤਿੰਨ\", \"ਚਾਰ\", \"ਪੰਜ\", \"ਛੇ\", \"ਸੱਤ\", \"ਅੱਠ\", \"ਨੌ\" # ਨਤੀਜਾ ਐਰੇ ਨੂੰ ਉਲਟਾਓ, ਅਤੇ ਫਿਰ ਹਰੇਕ ਅੰਕ ਨੂੰ ਇਸਦੇ ਅਨੁਸਾਰੀ ਨਾਮ ਨਾਲ ਬਦਲੋ # ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਪੂਰਨ ਅੰਕ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕਰੋ ਜੋ 1 ਅਤੇ 9 ਦੇ ਵਿਚਕਾਰ ਹਨ,# >>> by_length([2, 1, 1, 4, 5, 8, 2, 3])\n# [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n# If the array is empty, return an empty array:\n# >>> by_length([])\n# []\n# If the array has any strange number ignore it:\n# >>> by_length([1, -1, 55])\n# [\"One\"]\nsub by_length {\n    my($arr) = @_;\n","canonical_solution":"sub by_length {\n    my ($arr) = @_;\n    my @names = qw(Zero One Two Three Four Five Six Seven Eight Nine);\n    \n    my @filtered_sorted_reversed = reverse sort { $a <=> $b } grep { $_ >= 1 && $_ <= 9 } @$arr;\n    my @result = map { $names[$_] } @filtered_sorted_reversed;\n    \n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&by_length;\n        if(eq_deeply($candidate->([2, 1, 1, 4, 5, 8, 2, 3]),[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -1, 55]),[\"One\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -1, 3, 2]),[\"Three\", \"Two\", \"One\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([9, 4, 8]),[\"Nine\", \"Eight\", \"Four\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_106","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # i ਦਾ ਫੈਕਟੋਰਿਅਲ 1 ਤੋਂ i ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦਾ ਗੁਣਾ ਹੈ (1 * 2 * ... * i).# i 1 ਤੋਂ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ।# ਜਾਂ 1 ਤੋਂ i ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦਾ ਜੋੜ।# ਅਤੇ ਅਕਾਰ n ਦੀ ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰਦਾ ਹੈ, ਜਿਵੇਂ ਕਿ ਸੂਚਕਾਂਕ i ਤੇ ਤੱਤ ਦਾ ਮੁੱਲ i ਦਾ ਫੈਕਟਰੀਅਲ ਹੈ ਜੇ i ਵੀ ਹੈ # ਫੰਕਸ਼ਨ ਨੂੰ ਲਾਗੂ ਕਰੋ f ਜੋ ਕਿ n ਨੂੰ ਇੱਕ ਪੈਰਾਮੀਟਰ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ, # >>> f(5)\n# [1, 2, 6, 24, 15]\nsub f {\n    my($n) = @_;\n","canonical_solution":"sub f {\n    my($n) = @_;\n    my @result;\n\n    for my $i (1..$n) {\n        if ($i % 2 == 0) {\n            my $factorial = 1;\n            $factorial *= $_ for 1..$i;\n            push @result, $factorial;\n        } else {\n            my $sum = 0;\n            $sum += $_ for 1..$i;\n            push @result, $sum;\n        }\n    }\n    \n    return @result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&f;\n        if(eq_deeply($candidate->(5),[1, 2, 6, 24, 15])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),[1, 2, 6, 24, 15, 720, 28])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),[1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),[1, 2, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_107","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨ 1: # ਪੂਰਨ ਅੰਕ ਪੈਲਿੰਡਰੋਮ ਜੋ ਕਿ ਰੇਂਜ ਦੇ ਅੰਦਰ ਆਉਂਦੇ ਹਨ ((1, n), ਸਮੇਤ.# ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਵੀ ਅਤੇ ਅਜੀਬ ਦੀ ਗਿਣਤੀ ਹੈ # >>> even_odd_palindrome(3)\n# [1, 2]\n# Explanation:\n# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# >>> even_odd_palindrome(12)\n# [4, 6]\n# Explanation:\n# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n# 1. 1 <= n <= 10^3\n# 2. returned array has the number of even and odd integer palindromes respectively.\nsub even_odd_palindrome {\n    my($n) = @_;\n","canonical_solution":"sub even_odd_palindrome {\n    my($n) = @_;\n    my $even_count = 0;\n    my $odd_count = 0;\n    for my $i (1..$n) {\n        if ($i == reverse $i) {\n            if ($i % 2 == 0) {\n                $even_count++;\n            } else {\n                $odd_count++;\n            }\n        }\n    }\n    return [$even_count, $odd_count];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&even_odd_palindrome;\n        if(eq_deeply($candidate->(123),[8, 13])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),[4, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),[1, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(63),[6, 8])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(25),[5, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(19),[4, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(9),[4, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_108","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨ ਲਈ -123 ਦੇ ਅੰਕ -1, 2 ਅਤੇ 3 ਹਨ।# ਜੇਕਰ ਕੋਈ ਸੰਖਿਆ ਨਕਾਰਾਤਮਕ ਹੈ, ਤਾਂ ਇਸਦਾ ਪਹਿਲਾ ਦਸਤਖਤ ਕੀਤਾ ਅੰਕ ਨਕਾਰਾਤਮਕ ਹੋਵੇਗਾ: # ਤੱਤਾਂ ਦੀ ਸੰਖਿਆ ਜਿਸ ਦੇ ਅੰਕ ਦਾ ਜੋੜ > 0 ਹੈ।# ਇੱਕ ਫੰਕਸ਼ਨ count_nums ਲਿਖੋ ਜੋ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ ਲੈਂਦਾ ਹੈ ਅਤੇ ਵਾਪਿਸ ਆਉਂਦਾ ਹੈ # >>> count_nums([])\n# 0\n# >>> count_nums([-1, 11, -11])\n# 1\n# >>> count_nums([1, 1, 2])\n# 3\nsub count_nums {\n    my($arr) = @_;\n","canonical_solution":"sub count_nums {\n    my($arr) = @_;\n    my $count = 0;\n\n    foreach my $num (@$arr) {\n        my $sum_of_digits = 0;\n        my @digits = split \/\/, $num;\n        $sum_of_digits += shift @digits; # add the signed digit\n        $sum_of_digits += $_ for @digits;\n        $count++ if $sum_of_digits > 0;\n    }\n\n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&count_nums;\n        if(eq_deeply($candidate->([]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -2, 0]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1, 2, -2, 3, 4, 5]),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 6, 9, -6, 0, 1, 5]),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 100, 98, -7, 1, -1]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([12, 23, 34, -45, -56, 0]),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_109","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਨੋਟਃ ਦਿੱਤੇ ਗਏ ਐਰੇ ਵਿੱਚ ਵਿਲੱਖਣ ਤੱਤ ਹੋਣ ਦੀ ਗਾਰੰਟੀ ਹੈ।# ਜੇ ਦਿੱਤਾ ਗਿਆ ਐਰੇ ਖਾਲੀ ਹੈ ਤਾਂ 1 ਵਾਪਸ ਕਰੋ.# ਫਿਰ 1 ਨੂੰ ਵਾਪਸ ਕਰੋ ਅਤੇ ਫਿਰ '' ਨੂੰ ਵਾਪਸ ਕਰੋ.# ਜੇਕਰ ਉਪਰੋਕਤ ਕਾਰਵਾਈ ਕਰ ਕੇ ਕ੍ਰਮਬੱਧ ਐਰੇ ਪ੍ਰਾਪਤ ਕਰਨਾ ਸੰਭਵ ਹੈ # ਐਰੇ ਵਿੱਚ ਸ਼ੁਰੂਆਤੀ ਸਥਿਤੀ ਯਾਨੀ 0th ਇੰਡੈਕਸ।# ਸਹੀ ਦਿਸ਼ਾ ਵਿੱਚ ਸਥਿਤੀ. ਐਰੇ ਦਾ ਆਖਰੀ ਤੱਤ  ਵਿੱਚ ਭੇਜਿਆ ਜਾਵੇਗਾ# ਇੱਕ ਸੱਜੇ ਪਾਸੇ ਜਾਣ ਦਾ ਮਤਲਬ ਹੈ ਕਿ ਐਰੇ ਦੇ ਸਾਰੇ ਤੱਤਾਂ ਨੂੰ ਇੱਕ ਨਾਲ ਬਦਲਣਾ।# ਤੁਹਾਨੂੰ ਸੱਜੇ ਸ਼ਿਫਟ ਆਪਰੇਸ਼ਨ ਨੂੰ ਕਿਸੇ ਵੀ ਗਿਣਤੀ ਵਿੱਚ ਵਾਰ ਕਰਨ ਦੀ ਆਗਿਆ ਹੈ।# ਦਿੱਤੇ ਗਏ ਐਰੇ 'ਤੇ ਹੇਠ ਲਿਖੀ ਕਾਰਵਾਈਃ # ਇਹ ਸੰਭਵ ਹੈ ਕਿ ਇੱਕ ਐਰੇ ਨੂੰ ਗੈਰ-ਘਟਾਉਣ ਵਾਲੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਜਾਏ # ਐਰੇ ਵਿੱਚ ਨੰਬਰ ਬੇਤਰਤੀਬੇ ਕ੍ਰਮਬੱਧ ਕੀਤੇ ਜਾਣਗੇ. ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਨਿਰਧਾਰਤ ਕਰਨਾ ਹੈ ਕਿ ਕੀ # ਸਾਡੇ ਕੋਲ N ਪੂਰਨ ਅੰਕ arr[1], arr[2], ..., arr[N] ਦੀ ਇੱਕ ਐਰੇ 'arr' ਹੈ।# >>> move_one_ball([3, 4, 5, 1, 2])\n# 1\n# Explanation: By performin 2 right shift operations, non-decreasing order can\n# be achieved for the given array.\n# >>> move_one_ball([3, 5, 4, 1, 2])\n# \"\"\n# Explanation:It is not possible to get non-decreasing order for the given\n# array by performing any number of right shift operations.\nsub move_one_ball {\n    my($arr) = @_;\n","canonical_solution":"sub move_one_ball {\n    my ($arr) = @_;\n    my $n = scalar @$arr;\n    return 1 if $n == 0;\n\n    for my $i (0 .. $n - 1) {\n        my @shifted = (@$arr[$i .. $n - 1], @$arr[0 .. $i - 1]);\n        if (is_sorted(\\@shifted)) {\n            return 1;\n        }\n    }\n    return '';\n}\n\nsub is_sorted {\n    my ($arr) = @_;\n    for my $i (0 .. $#$arr - 1) {\n        return 0 if $arr->[$i] > $arr->[$i + 1];\n    }\n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&move_one_ball;\n        if(eq_deeply($candidate->([3, 4, 5, 1, 2]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 5, 10, 1, 2]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 1, 2]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 5, 4, 1, 2]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_110","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਨਹੀਂ ਤਾਂ, \"NO\" ਵਾਪਸ ਕਰੋ।# lst1 ਦੇ ਸਾਰੇ ਤੱਤ ਨੂੰ ਵੀ ਹੋਣ ਲਈ, \"YES\" ਵਾਪਸ ਕਰੋ.# ਜੇ ਇਹ ਸੰਭਵ ਹੈ ਕਿ lst1 ਅਤੇ lst2 ਵਿਚਕਾਰ ਤੱਤ ਨੂੰ ਬਦਲਣ ਲਈ # lst1 ਅਤੇ lst2 ਦੇ ਵਿਚਕਾਰ ਵਟਾਂਦਰੇ ਵਾਲੇ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ ਦੀ ਕੋਈ ਸੀਮਾ ਨਹੀਂ ਹੈ।# lst1 ਨੂੰ ਸਿਰਫ ਬਰਾਬਰ ਸੰਖਿਆਵਾਂ ਦਾ ਇੱਕ ਐਰੇ ਬਣਾਉਣ ਲਈ.# ਅਤੇ ਇਹ ਨਿਰਧਾਰਤ ਕਰਦਾ ਹੈ ਕਿ ਕੀ ਤੱਤਾਂ ਦਾ ਆਦਾਨ-ਪ੍ਰਦਾਨ ਕਰਨਾ ਸੰਭਵ ਹੈ # ਇਸ ਸਮੱਸਿਆ ਵਿੱਚ, ਤੁਸੀਂ ਇੱਕ ਫੰਕਸ਼ਨ ਲਾਗੂ ਕਰੋਗੇ ਜੋ ਦੋ ਐਰੇ ਨੰਬਰ ਲੈਂਦਾ ਹੈ, # >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])\n# \"YES\"\n# >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n# \"NO\"\n# It is assumed that the input arrays will be non-empty.\nsub exchange {\n    my($lst1, $lst2) = @_;\n","canonical_solution":"sub exchange {\n    my ($lst1, $lst2) = @_;\n    \n    # Check if lst1 is already all-even\n    my $all_even = 1;\n    foreach my $num (@$lst1) {\n        if ($num % 2 != 0) {\n            $all_even = 0;\n            last;\n        }\n    }\n    return \"YES\" if $all_even;\n\n    # Check if there is at least one even number in lst2\n    my $can_exchange = 0;\n    foreach my $num (@$lst2) {\n        if ($num % 2 == 0) {\n            $can_exchange = 1;\n            last;\n        }\n    }\n\n    # Calculate the count of odd numbers in lst1\n    my $odd_count_lst1 = 0;\n    foreach my $num (@$lst1) {\n        $odd_count_lst1++ if ($num % 2 != 0);\n    }\n\n    # If there are even numbers in lst2 and odd numbers in lst1, we can exchange\n    if ($can_exchange && $odd_count_lst1 > 0) {\n        return \"YES\";\n    }\n\n    return \"NO\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&exchange;\n        if(eq_deeply($candidate->([1, 2, 3, 4], [1, 2, 3, 4]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4], [1, 5, 3, 4]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4], [2, 1, 4, 3]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 7, 3], [2, 6, 4]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 7, 3], [2, 6, 3]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100, 200], [200, 200]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_111","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # ਜੇ ਕਈ ਅੱਖਰਾਂ ਵਿੱਚ ਇੱਕੋ ਜਿਹੀ ਘਟਨਾ ਹੋਵੇ, ਤਾਂ ਉਨ੍ਹਾਂ ਸਾਰਿਆਂ ਨੂੰ ਵਾਪਸ ਕਰੋ।# ਸਭ ਤੋਂ ਵੱਧ ਵਾਰ ਦੁਹਰਾਉਣ ਵਾਲੇ ਅਤੇ ਅਨੁਸਾਰੀ ਗਿਣਤੀ ਵਾਲੇ ਅੱਖਰ ਦਾ.# ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ ਜੋ ਇੱਕ ਸਪੇਸ ਵੱਖ ਕੀਤੇ ਛੋਟੇ ਅੱਖਰਾਂ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ, ਇੱਕ ਹੈਸ਼ ਵਾਪਸ ਕਰੋ # >>> histogram(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" => 1}\n# >>> histogram(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram(\"a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram(\"b b b b a\")\n# {\"b\" => 4}\n# >>> histogram(\"\")\n# {}\nsub histogram {\n    my($test) = @_;\n","canonical_solution":"sub histogram {\n    my ($test) = @_;\n    my %count;\n\n    # Split the input string by spaces and count occurrences of each letter\n    $count{$_}++ for split ' ', $test;\n\n    # Determine the maximum count\n    my $max_count = 0;\n    $max_count = $count{$_} > $max_count ? $count{$_} : $max_count for keys %count;\n\n    # Collect all letters with the maximum count\n    my %result = map { $_ => $count{$_} } grep { $count{$_} == $max_count } keys %count;\n\n    return \\%result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&histogram;\n        if(eq_deeply($candidate->(\"a b b a\"),{\"a\" => 2, \"b\" => 2})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"a b c a b\"),{\"a\" => 2, \"b\" => 2})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"a b c d g\"),{\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1, \"g\" => 1})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"r t g\"),{\"r\" => 1, \"t\" => 1, \"g\" => 1})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"b b b b a\"),{\"b\" => 4})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"r t g\"),{\"r\" => 1, \"t\" => 1, \"g\" => 1})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),{})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"a\"),{\"a\" => 1})) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_112","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨ # ਤੁਹਾਨੂੰ ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਨਤੀਜਾ ਸਤਰ ਅਤੇ ਚੈਕ ਲਈ 1\/' ਸ਼ਾਮਲ ਹੈ.# ਇੱਕ ਸਤਰ ਨੂੰ ਪਾਲੀਂਡਰੋਮ ਕਿਹਾ ਜਾਂਦਾ ਹੈ ਜੇਕਰ ਇਹ ਅੱਗੇ ਵਾਂਗ ਹੀ ਪਿੱਛੇ ਵੱਲ ਪੜ੍ਹਦਾ ਹੈ।# ਫਿਰ ਜਾਂਚ ਕਰੋ ਕਿ ਕੀ ਨਤੀਜਾ ਸਤਰ ਪਾਲੀਂਡਰੋਮ ਹੈ।# ਸਾਨੂੰ ਦੋ ਸਤਰਾਂ s ਅਤੇ c ਦਿੱਤੀਆਂ ਗਈਆਂ ਹਨ, ਤੁਹਾਨੂੰ s ਵਿੱਚ ਸਾਰੇ ਅੱਖਰਾਂ ਨੂੰ ਮਿਟਾਉਣਾ ਹੈ ਜੋ c ਵਿੱਚ ਕਿਸੇ ਵੀ ਅੱਖਰ ਦੇ ਬਰਾਬਰ ਹਨ # ਕੰਮ # >>> reverse_delete(\"abcde\", \"ae\")\n# [\"bcd\", \"\"]\n# >>> reverse_delete(\"abcdef\", \"b\")\n# [\"acdef\", \"\"]\n# >>> reverse_delete(\"abcdedcba\", \"ab\")\n# [\"cdedc\", 1]\nsub reverse_delete {\n    my($s, $c) = @_;\n","canonical_solution":"sub reverse_delete {\n    my($s, $c) = @_;\n    \n    # Create a hash of characters to be deleted for quick lookup\n    my %chars_to_delete = map { $_ => 1 } split \/\/, $c;\n    \n    # Remove characters that need to be deleted\n    $s =~ s\/[$c]\/\/g;\n    \n    # Check if the resulting string is a palindrome\n    my $is_palindrome = ($s eq reverse $s) ? 1 : '';\n\n    # Return the resulting string and palindrome check\n    return [$s, $is_palindrome];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&reverse_delete;\n        if(eq_deeply($candidate->(\"abcde\", \"ae\"),[\"bcd\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdef\", \"b\"),[\"acdef\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"ab\"),[\"cdedc\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"dwik\", \"w\"),[\"dik\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"a\", \"a\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"v\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"vabba\", \"v\"),[\"abba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"mamma\", \"mia\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_113","nl":"pan_Guru","pl":"pl","prompt":"# ਇੰਪੁੱਟ ਦੇ i'th ਸਤਰ ਵਿੱਚ ਅਜੀਬ ਅੰਕ ਦੇ.# ਇੰਪੁੱਟ ਦੀ ਸਤਰ i. \" ਜਿੱਥੇ ਸਾਰੇ i ਨੂੰ ਨੰਬਰ ਨਾਲ ਬਦਲਿਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ # ਆਉਟਪੁੱਟ ਦੇ ਹਰੇਕ ਤੱਤ i ਨੂੰ \"ਇੱਕ ਵਿੱਚ ਅਜੀਬ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ# ਸਤਰਾਂ ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਜਿੱਥੇ ਹਰ ਸਤਰ ਵਿੱਚ ਸਿਰਫ ਅੰਕ ਹੁੰਦੇ ਹਨ, ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰੋ.# >>> odd_count([\"1234567\"])\n# [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n# >>> odd_count([\"3\", \"11111111\"])\n# [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nsub odd_count {\n    my($lst) = @_;\n","canonical_solution":"sub odd_count {\n    my ($lst) = @_;\n    my @output;\n    foreach my $str (@$lst) {\n        my $odd_count = 0;\n        $odd_count++ while $str =~ \/[13579]\/g;\n        push @output, \"the number of odd elements ${odd_count}n the str${odd_count}ng ${odd_count} of the ${odd_count}nput.\";\n    }\n    return \\@output;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&odd_count;\n        if(eq_deeply($candidate->([\"1234567\"]),[\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"3\", \"11111111\"]),[\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"271\", \"137\", \"314\"]),[\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_114","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨ # # ਪੂਰਨ ਅੰਕ n ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਕਿਸੇ ਵੀ ਗੈਰ-ਖਾਲੀ ਸਬ-ਐਰੇ ਦਾ ਘੱਟੋ ਘੱਟ ਜੋੜ ਲੱਭੋ # >>> minSubArraySum([2, 3, 4, 1, 2, 4])\n# 1\n# >>> minSubArraySum([-1, -2, -3])\n# -6\nsub minSubArraySum {\n    my($nums) = @_;\n","canonical_solution":"sub minSubArraySum {\n    my($nums) = @_;\n    my $minSum = $nums->[0];\n    my $currentSum = 0;\n    \n    foreach my $num (@$nums) {\n        $currentSum += $num;\n        if ($currentSum < $minSum) {\n            $minSum = $currentSum;\n        }\n        if ($currentSum > 0) {\n            $currentSum = 0;\n        }\n    }\n    \n    return $minSum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&minSubArraySum;\n        if(eq_deeply($candidate->([2, 3, 4, 1, 2, 4]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -2, -3]),-6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -2, -3, 2, -10]),-14)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-9999999999999999]),-9999999999999999)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 10, 20, 1000000]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -2, -3, 10, -5]),-6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100, -1, -2, -3, 10, -5]),-6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([10, 11, 13, 8, 3, 4]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100, -33, 32, -1, 0, -2]),-33)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-10]),-10)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7]),7)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -1]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_115","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨ 1: # ਬਕਸੇ ਨੂੰ ਘੱਟ ਕਰਨ ਲਈ ਤੁਹਾਨੂੰ ਕਿੰਨੀ ਵਾਰ ਲੋੜ ਹੈ ਆਉਟਪੁੱਟ ਦਿਓ.# ਤੁਹਾਡਾ ਕੰਮ ਖੂਹਾਂ ਨੂੰ ਖਾਲੀ ਕਰਨ ਲਈ ਡੱਬਿਆਂ ਦੀ ਵਰਤੋਂ ਕਰਨਾ ਹੈ।# ਅਤੇ ਸਾਰੇ ਡੱਬਿਆਂ ਦੀ ਸਮਰੱਥਾ ਇੱਕੋ ਜਿਹੀ ਹੈ।# ਹਰੇਕ ਖੂਹ ਵਿੱਚ ਇੱਕ ਬਕਵਾਸ ਹੈ ਜਿਸਦੀ ਵਰਤੋਂ ਇਸ ਤੋਂ ਪਾਣੀ ਕੱਢਣ ਲਈ ਕੀਤੀ ਜਾ ਸਕਦੀ ਹੈ, # ਅਤੇ ਹਰ ਇੱਕ ਕਤਾਰ ਵਿੱਚ 1 ਪਾਣੀ ਦੀ ਇੱਕ ਇਕਾਈ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ।# ਤੁਹਾਨੂੰ ਖੂਹਾਂ ਦਾ ਇੱਕ ਆਇਤਾਕਾਰ ਗਰਿੱਡ ਦਿੱਤਾ ਜਾਂਦਾ ਹੈ। ਹਰ ਕਤਾਰ ਇੱਕ ਸਿੰਗਲ ਖੂਹ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ, # >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n    my($grid, $capacity) = @_;\n","canonical_solution":"sub max_fill {\n    my($grid, $capacity) = @_;\n    my $total_water_units = 0;\n    \n    for my $row (@$grid) {\n        for my $unit (@$row) {\n            $total_water_units += $unit;\n        }\n    }\n    \n    my $bucket_uses = int(($total_water_units + $capacity - 1) \/ $capacity);\n    return $bucket_uses;\n}\n\n# Examples\nprint max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1) . \"\\n\"; # 6\nprint max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2) . \"\\n\"; # 5\nprint max_fill([[0, 0, 0], [0, 0, 0]], 5) . \"\\n\"; # 0","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_116","nl":"pan_Guru","pl":"pl","prompt":"# ਇਸ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਲਾਗੂ ਕੀਤਾ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈਃ # ਇੱਕੋ ਜਿਹੀ ਗਿਣਤੀ ਦੇ ਲਈ, ਦਸ਼ਮਲਵ ਮੁੱਲ ਦੇ ਆਧਾਰ ਤੇ ਕ੍ਰਮਬੱਧ ਕਰੋ।# ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਉਹਨਾਂ ਦੀ ਬਾਈਨਰੀ ਪ੍ਰਤੀਨਿਧਤਾ ਵਿੱਚ ਇੱਕਾਂ ਦੀ ਗਿਣਤੀ।# ਇਸ ਕਾਟਾ ਵਿੱਚ, ਤੁਹਾਨੂੰ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕਰਨਾ ਹੈ # >>> sort_array([1, 5, 2, 3, 4])\n# [1, 2, 3, 4, 5]\n# >>> sort_array([-2, -3, -4, -5, -6])\n# [-6, -5, -4, -3, -2]\n# >>> sort_array([1, 0, 2, 3, 4])\n# [0, 1, 2, 3, 4]\nsub sort_array {\n    my($arr) = @_;\n","canonical_solution":"sub sort_array {\n    my($arr) = @_;\n    return [sort { sprintf(\"%b\", $a) =~ tr\/1\/\/ <=> sprintf(\"%b\", $b) =~ tr\/1\/\/ || $a <=> $b } @$arr];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sort_array;\n        if(eq_deeply($candidate->([1, 5, 2, 3, 4]),[1, 2, 4, 3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-2, -3, -4, -5, -6]),[-4, -2, -6, -5, -3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 0, 2, 3, 4]),[0, 1, 2, 4, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]),[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 6, 44, 12, 32, 5]),[32, 3, 5, 6, 12, 44])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_117","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਨੋਟਃ ਤੁਸੀਂ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਇਨਪੁਟ ਸਤਰ ਵਿੱਚ ਸਿਰਫ ਅੱਖਰ ਅਤੇ ਸਪੇਸ ਹਨ।# ਜੇਕਰ ਸਤਰ s ਖਾਲੀ ਹੈ ਤਾਂ ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਖਾਲੀ ਐਰੇ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।# n ਧੁਨੀ, ਕ੍ਰਮ ਵਿੱਚ ਇਹ ਸ਼ਬਦ ਸਤਰ s ਵਿੱਚ ਪ੍ਰਗਟ ਹੁੰਦੇ ਹਨ।# ਇੱਕ ਫੰਕਸ਼ਨ ਜੋ ਸਤਰ s ਤੋਂ ਸਾਰੇ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਬਿਲਕੁਲ # ਇੱਕ ਸਤਰ s ਅਤੇ ਇੱਕ ਕੁਦਰਤੀ ਸੰਖਿਆ n ਦਿੱਤੀ ਗਈ ਹੈ, ਤੁਹਾਨੂੰ ਲਾਗੂ ਕਰਨ ਦਾ ਕੰਮ ਦਿੱਤਾ ਗਿਆ ਹੈ # >>> select_words(\"Mary had a little lamb\", 4)\n# [\"little\"]\n# >>> select_words(\"Mary had a little lamb\", 3)\n# [\"Mary\", \"lamb\"]\n# >>> select_words(\"simple white space\", 2)\n# []\n# >>> select_words(\"Hello world\", 4)\n# [\"world\"]\n# >>> select_words(\"Uncle sam\", 3)\n# [\"Uncle\"]\nsub select_words {\n    my($s, $n) = @_;\n","canonical_solution":"sub select_words {\n    my($s, $n) = @_;\n    return [] if $s eq '';\n    \n    my @words = split(\/\\s+\/, $s);\n    my @result;\n    \n    foreach my $word (@words) {\n        my $consonant_count = () = $word =~ \/[^aeiouAEIOU]\/g;\n        push @result, $word if $consonant_count == $n;\n    }\n    \n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&select_words;\n        if(eq_deeply($candidate->(\"Mary had a little lamb\", 4),[\"little\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mary had a little lamb\", 3),[\"Mary\", \"lamb\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"simple white space\", 2),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello world\", 4),[\"world\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Uncle sam\", 3),[\"Uncle\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\", 4),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"a b c d e f\", 1),[\"b\", \"c\", \"d\", \"f\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_118","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਦਿੱਤੇ ਗਏ ਸਤਰ ਵਿੱਚ ਕੇਵਲ ਅੰਗਰੇਜ਼ੀ ਅੱਖਰ ਹਨ।# ਉਪਰੋਕਤ ਸ਼ਰਤ ਨੂੰ ਪੂਰਾ ਕਰਨ ਵਾਲਾ ਕੋਈ ਵੀ ਸਵੈ-ਹਵਾਲਾ ਲੱਭੋ.# ਸ਼ੁਰੂ ਅਤੇ ਅੰਤ ਵਿੱਚ ਅਖਰ ਗਿਣਦੇ ਨਹੀਂ ਹਨ। ਜੇਕਰ ਤੁਸੀਂ ਨਹੀਂ ਕੀਤਾ ਤਾਂ ਖਾਲੀ ਸਤਰ ਵਾਪਸ ਕਰੋ # ਸ਼ਬਦ ਦੇ ਸੱਜੇ ਪਾਸੇ ਤੋਂ ਦੋ ਧੁਨੀ (ਕੇਸ ਸੰਵੇਦਨਸ਼ੀਲ) ।# ਤੁਹਾਨੂੰ ਇੱਕ ਸ਼ਬਦ ਦਿੱਤਾ ਗਿਆ ਹੈ. ਤੁਹਾਡਾ ਕੰਮ ਸਭ ਤੋਂ ਨਜ਼ਦੀਕੀ ਸਵੈਰ ਲੱਭਣਾ ਹੈ ਜੋ ਵਿਚਕਾਰ ਖੜ੍ਹਾ ਹੈ # >>> get_closest_vowel(\"yogurt\")\n# \"u\"\n# >>> get_closest_vowel(\"FULL\")\n# \"U\"\n# >>> get_closest_vowel(\"quick\")\n# \"\"\n# >>> get_closest_vowel(\"ab\")\n# \"\"\nsub get_closest_vowel {\n    my($word) = @_;\n","canonical_solution":"sub get_closest_vowel {\n    my($word) = @_;\n    my @chars = split \/\/, $word;\n    my $vowel = '';\n    my @vowels = qw(a e i o u A E I O U);\n    my %vowel_hash = map { $_ => 1 } @vowels;\n\n    for (my $i = $#chars - 1; $i > 0; $i--) {\n        if ($vowel_hash{$chars[$i]} && !$vowel_hash{$chars[$i - 1]} && !$vowel_hash{$chars[$i + 1]}) {\n            $vowel = $chars[$i];\n            last;\n        }\n    }\n\n    return $vowel;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_closest_vowel;\n        if(eq_deeply($candidate->(\"yogurt\"),\"u\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"full\"),\"u\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"easy\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eAsy\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ali\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"bad\"),\"a\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"most\"),\"o\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ab\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ba\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"quick\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"anime\"),\"i\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Asia\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Above\"),\"o\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_119","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # 'ਹਾਂ' ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਇੱਕ ਚੰਗੀ ਸਤਰ ਬਣਾਉਣ ਦਾ ਕੋਈ ਤਰੀਕਾ ਹੈ, ਅਤੇ 'ਨਹੀਂ' ਵਾਪਸ ਕਰੋ ਨਹੀਂ ਤਾਂ.# \"()) \" ਨਹੀਂ ਹੈ।# ਸੰਤੁਲਿਤ ਹਨ. ਉਦਾਹਰਣ ਲਈਃ ਸਤਰ '(()))) ਚੰਗੀ ਹੈ, ਜਦੋਂ ਕਿ ਸਤਰ # ਇੱਕ ਸਤਰ S ਨੂੰ ਚੰਗੀ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਜੇ ਅਤੇ ਕੇਵਲ ਤਾਂ ਹੀ ਜੇ S ਵਿੱਚ ਸਾਰੇ ਬਰੈਂਚੈਸ # ਕੁਝ ਕ੍ਰਮ, ਜੋ ਕਿ ਨਤੀਜੇ ਸਤਰ ਚੰਗਾ ਹੋ ਜਾਵੇਗਾ.# ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਜਾਂਚਣਾ ਹੈ ਕਿ ਕੀ ਦੋ ਸਤਰਾਂ ਨੂੰ ਜੋੜਨਾ ਸੰਭਵ ਹੈ # ਸਿਰਫ ' (_) ' ਜਾਂ ') ' parentheses ਵਿੱਚ ਹੀ ਪਾਓ।# ਤੁਹਾਨੂੰ ਦੋ ਸਤਰਾਂ ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਦੋਵੇਂ ਸਤਰਾਂ ਵਿੱਚ ਖੁੱਲਾ ਹੁੰਦਾ ਹੈ# >>> match_parens([\"()(\", \")\"])\n# \"Yes\"\n# >>> match_parens([\")\", \")\"])\n# \"No\"\nsub match_parens {\n    my($lst) = @_;\n","canonical_solution":"sub match_parens {\n    my($lst) = @_;\n    my ($a, $b) = @$lst;\n    \n    # Helper to check if a string is good (i.e., parentheses balanced)\n    sub is_good {\n        my ($str) = @_;\n        my $balance = 0;\n        for my $ch (split \/\/, $str) {\n            $balance++ if $ch eq '(';\n            $balance-- if $ch eq ')';\n            return 0 if $balance < 0; # Too many closing parens\n        }\n        return $balance == 0; # Balanced if zero\n    }\n    \n    # Check both combinations\n    return \"Yes\" if is_good($a . $b) || is_good($b . $a);\n    return \"No\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&match_parens;\n        if(eq_deeply($candidate->([\"()(\", \")\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\")\", \")\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"(()(())\", \"())())\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\")())\", \"(()()(\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"(())))\", \"(()())((\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"()\", \"())\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"(()(\", \"()))()\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"((((\", \"((())\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\")(()\", \"(()(\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\")(\", \")(\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"(\", \")\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\")\", \"(\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_120","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨ 1: # ਲੰਬਾਈ k ਦੇ ਨਾਲ ਵੱਧ ਤੋਂ ਵੱਧ k ਨੰਬਰਾਂ ਦੇ ਨਾਲ.# ਪੂਰਨ ਅੰਕ ਅਤੇ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ k ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਇੱਕ ਕ੍ਰਮਬੱਧ ਐਰੇ ਵਾਪਸ ਕਰੋ # >>> maximum([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum([4, -4, 4], 2)\n# [4, 4]\n# Example 3:\n# >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n# [2]\n# Note:\n# 1. The length of the array will be in the range of [1, 1000].\n# 2. The elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\nsub maximum {\n    my($arr, $k) = @_;\n","canonical_solution":"sub maximum {\n    my($arr, $k) = @_;\n    my @sorted = sort { $b <=> $a } @$arr;  # Sort in descending order\n    my @result = sort { $a <=> $b } @sorted[0..$k-1];  # Take first k elements and sort them\n    return \\@result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&maximum;\n        if(eq_deeply($candidate->([-3, -4, 5], 3),[-4, -3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, -4, 4], 2),[4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3, 2, 1, 2, -1, -2, 1], 1),[2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([123, -123, 20, 0, 1, 2, -3], 3),[2, 20, 123])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-123, 20, 0, 1, 2, -3], 4),[0, 1, 2, 20])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 15, 0, 3, -13, -8, 0], 7),[-13, -8, 0, 0, 3, 5, 15])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 0, 2, 5, 3, -10], 2),[3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 0, 5, -7], 1),[5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, -4], 2),[-4, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-10, 10], 2),[-10, 10])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, -23, 243, -400, 0], 0),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_121","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਾਂ # ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਸਾਰੇ ਅਜੀਬ ਤੱਤਾਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰੋ ਜੋ ਕਿ ਬਰਾਬਰ ਅਹੁਦਿਆਂ ਤੇ ਹਨ. # >>> solution([5, 8, 7, 1])\n# 12\n# >>> solution([3, 3, 3, 3, 3])\n# 9\n# >>> solution([30, 13, 24, 321])\n# 0\nsub solution {\n    my($lst) = @_;\n","canonical_solution":"sub solution {\n    my($lst) = @_;\n    my $sum = 0;\n    for (my $i = 0; $i < @$lst; $i += 2) {\n        $sum += $lst->[$i] if $lst->[$i] % 2 != 0;\n    }\n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&solution;\n        if(eq_deeply($candidate->([5, 8, 7, 1]),12)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 3, 3, 3, 3]),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([30, 13, 24, 321]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 9]),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 8]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([30, 13, 23, 32]),23)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 13, 2, 9]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_122","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # arr ਦੇ ਪਹਿਲੇ k ਤੱਤਾਂ ਦੇ ਵੱਧ ਤੋਂ ਵੱਧ ਦੋ ਅੰਕਾਂ ਵਾਲੇ ਤੱਤਾਂ ਦਾ ਜੋੜ।# ਪੂਰਨ ਅੰਕ arr ਅਤੇ ਪੂਰਨ ਅੰਕ k ਦੀ ਇੱਕ ਗੈਰ-ਖਾਲੀ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਵਾਪਸੀ # >>> add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n# 24\n# Constraints:\n# 1. 1 <= len(arr) <= 100\n# 2. 1 <= k <= len(arr)\nsub add_elements {\n    my($arr, $k) = @_;\n","canonical_solution":"sub add_elements {\n    my ($arr, $k) = @_;\n    my $sum = 0;\n    for my $i (0..$k-1) {\n        $sum += $arr->[$i] if $arr->[$i] >= -99 && $arr->[$i] <= 99;\n    }\n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&add_elements;\n        if(eq_deeply($candidate->([1, -2, -3, 41, 57, 76, 87, 88, 99], 3),-4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([111, 121, 3, 4000, 5, 6], 2),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([11, 21, 3, 90, 5, 6, 7, 8, 9], 4),125)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4),24)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1], 1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_123","nl":"pan_Guru","pl":"pl","prompt":"# get_odd_collatz(5) ਵਾਪਸ ਕਰਦਾ ਹੈ [1, 5] # 5 ਲਈ collatz ਲੜੀ [5, 16, 8, 4, 2, 1], ਇਸ ਲਈ ਅਜੀਬ ਨੰਬਰ ਸਿਰਫ 1, ਅਤੇ 5 ਹਨ. # ਉਦਾਹਰਣ ਲਈ: # 2. ਵਾਪਸ ਕੀਤੀ ਗਈ ਐਰੇ ਨੂੰ ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਕ੍ਰਮਬੱਧ ਕੀਤਾ ਗਿਆ ਹੈ।# 1. Collatz(1) [1] ਹੈ।# ਨੋਟਃ # ਇਹ ਅਨੁਮਾਨ ਹੈ ਕਿ n ਦਾ ਕੋਈ ਵੀ ਮੁੱਲ ਹੋਵੇ, ਤਰਤੀਬ ਹਮੇਸ਼ਾ 1 ਤੱਕ ਪਹੁੰਚੇਗੀ।# ਜੇ ਪਿਛਲਾ ਸ਼ਬਦ ਅਜੀਬ ਹੈ, ਤਾਂ ਅਗਲਾ ਸ਼ਬਦ 3 ਗੁਣਾ ਹੈ।# ਪਿਛਲੀ ਅਵਧੀ ਇਸ ਪ੍ਰਕਾਰ ਹੈਃ ਜੇ ਪਿਛਲੀ ਅਵਧੀ ਜਮ੍ਹਾ ਹੈ, ਅਗਲੀ ਅਵਧੀ  ਦਾ ਅੱਧਾ ਹਿੱਸਾ ਹੈ# ਹੇਠ ਲਿਖੇ ਅਨੁਸਾਰਃ ਕਿਸੇ ਵੀ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਨਾਲ ਸ਼ੁਰੂ ਕਰੋ। ਫਿਰ ਹਰ ਸ਼ਬਦ ਨੂੰ  ਤੋਂ ਪ੍ਰਾਪਤ ਕੀਤਾ ਜਾਂਦਾ ਹੈ।# ਕੋਲੈਟਜ਼ ਅਨੁਮਾਨ ਗਣਿਤ ਵਿੱਚ ਇੱਕ ਅਨੁਮਾਨ ਹੈ ਜੋ ਪਰਿਭਾਸ਼ਿਤ ਕ੍ਰਮ ਨਾਲ ਸਬੰਧਤ ਹੈ # ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇੱਕ ਕ੍ਰਮਬੱਧ ਐਰੇ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਕਾਲੈਟਜ਼ ਕ੍ਰਮ ਵਿੱਚ ਅਜੀਬ ਨੰਬਰ ਹਨ।# >>> get_odd_collatz(5)\n# [1, 5]\nsub get_odd_collatz {\n    my($n) = @_;\n","canonical_solution":"sub get_odd_collatz {\n    my ($n) = @_;\n    my %odd_numbers;\n    \n    while ($n != 1) {\n        $odd_numbers{$n} = 1 if $n % 2 != 0;\n        if ($n % 2 == 0) {\n            $n = $n \/ 2;\n        } else {\n            $n = 3 * $n + 1;\n        }\n    }\n    $odd_numbers{1} = 1;\n    \n    return sort { $a <=> $b } keys %odd_numbers;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_odd_collatz;\n        if(eq_deeply($candidate->(14),[1, 5, 7, 11, 13, 17])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),[1, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),[1, 3, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),[1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_124","nl":"pan_Guru","pl":"pl","prompt":"# 4. ਤਾਰੀਖ ਨੂੰ ਇਸ ਫਾਰਮੈਟ ਵਿੱਚ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈਃ ਐਮ.ਐਮ.ਡੀ.ਡੀ.ਐਮ.# 3. ਮਹੀਨਿਆਂ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 12 ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੋਣੀ ਚਾਹੀਦੀ।# 2. ਮਹੀਨਿਆਂ 1,3,5,7,8,10,12 ਲਈ ਦਿਨ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 31 ਦਿਨਾਂ ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੈ ਅਤੇ ਮਹੀਨਿਆਂ 4,6,9,11 ਲਈ ਦਿਨ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 30 ਦਿਨਾਂ ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੈ ਅਤੇ ਮਹੀਨੇ 2 ਲਈ ਦਿਨ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 29 ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੈ।# 1. ਤਾਰੀਖ ਸਤਰ ਖਾਲੀ ਨਹੀਂ ਹੈ।# ਤਾਰੀਖ ਉਦੋਂ ਵੈਧ ਹੁੰਦੀ ਹੈ ਜਦੋਂ ਹੇਠ ਲਿਖੇ ਸਾਰੇ ਨਿਯਮ ਪੂਰੇ ਹੋਣ:# 1 ਵਾਪਿਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਤਾਰੀਖ ਵੈਧ ਹੈ ਨਹੀਂ ਤਾਂ ''.# ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣਾ ਪਵੇਗਾ ਜੋ ਇੱਕ ਦਿੱਤੀ ਗਈ ਤਾਰੀਖ ਸਤਰ ਨੂੰ ਪ੍ਰਮਾਣਿਤ ਕਰਦਾ ਹੈ ਅਤੇ # >>> valid_date(\"03-11-2000\")\n# 1\n# >>> valid_date(\"15-01-2012\")\n# \"\"\n# >>> valid_date(\"04-0-2040\")\n# \"\"\n# >>> valid_date(\"06-04-2020\")\n# 1\n# >>> valid_date(\"06\/04\/2020\")\n# \"\"\nsub valid_date {\n    my($date) = @_;\n","canonical_solution":"sub valid_date {\n    my ($date) = @_;\n    \n    # Check if date is empty\n    return '' if !$date;\n    \n    # Date pattern for mm-dd-yyyy\n    if ($date =~ \/^(\\d{2})-(\\d{2})-(\\d{4})$\/) {\n        my ($month, $day, $year) = ($1, $2, $3);\n        \n        # Check month validity\n        return '' if $month < 1 || $month > 12;\n        \n        # Check day validity based on the month\n        my %days_in_month = (\n            1 => 31, 2 => 29, 3 => 31, 4 => 30,\n            5 => 31, 6 => 30, 7 => 31, 8 => 31,\n            9 => 30, 10 => 31, 11 => 30, 12 => 31\n        );\n        \n        return '' if $day < 1 || $day > $days_in_month{$month};\n        \n        # If all conditions are satisfied, return 1\n        return 1;\n    }\n    \n    # If date does not match the pattern, return ''\n    return '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&valid_date;\n        if(eq_deeply($candidate->(\"03-11-2000\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"15-01-2012\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"04-0-2040\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"06-04-2020\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"01-01-2007\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"03-32-2011\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"04-31-3000\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"06-06-2005\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"21-31-2000\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"04-12-2003\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"04122003\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"20030412\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2003-04\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2003-04-12\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"04-2003\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_125","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਾਂ # ਅੱਖਰ, ਆਰਡਰ 'a') = 0, ਆਰਡਰ 'b') = 1, ... ਆਰਡਰ 'z') = 25 # ਜੇਕਰ ਕੋਈ ਕਾਮੇ ਮੌਜੂਦ ਨਹੀਂ ਹਨ ਤਾਂ ਤੁਹਾਨੂੰ  ਵਿੱਚ ਅਣਗਿਣਤ ਕ੍ਰਮ ਨਾਲ ਛੋਟੇ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ।# ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ, ਜੇਕਰ ਤੁਸੀਂ ਟੈਕਸਟ ਵਿੱਚ ਕੋਈ ਵੀ ਵਾਈਟਸਪੇਸ ਮੌਜੂਦ ਨਹੀਂ ਹੈ ਤਾਂ ਵਾਈਟਸਪੇਸ ਤੇ ਵੰਡਿਆ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰੋ # >>> split_words(\"Hello world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words(\"Hello,world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words(\"abcdef\")\n# 3\nsub split_words {\n    my($txt) = @_;\n","canonical_solution":"sub split_words {\n    my($txt) = @_;\n    \n    # Check if whitespace exists in the string\n    if ($txt =~ \/\\s\/) {\n        my @words = split(\/\\s+\/, $txt);\n        return \\@words;\n    }\n    # If no whitespace, check for commas\n    elsif ($txt =~ \/,\/) {\n        my @words = split(\/,\/, $txt);\n        return \\@words;\n    }\n    # If neither whitespace nor commas exist, calculate odd ordered lowercase letters\n    else {\n        my @chars = split(\/\/, $txt);\n        my $count = 0;\n        foreach my $char (@chars) {\n            if ($char ge 'a' && $char le 'z' && (ord($char) - ord('a')) % 2 == 0) {\n                $count++;\n            }\n        }\n        return $count;\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&split_words;\n        if(eq_deeply($candidate->(\"Hello world!\"),[\"Hello\", \"world!\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello,world!\"),[\"Hello\", \"world!\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello world,!\"),[\"Hello\", \"world,!\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hello,Hello,world !\"),[\"Hello,Hello,world\", \"!\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdef\"),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aaabb\"),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"aaaBb\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_126","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਾਂ # ਨੰਬਰ, ਵਾਪਸ ਕਰੋ '_' ਕੋਈ ਨਕਾਰਾਤਮਕ ਨੰਬਰ ਅਤੇ ਸਿਰਫ ਪੂਰਨ ਅੰਕ ਮੰਨ ਲਓ.# ਜੇ ਐਰੇ ਵਿੱਚ ਇੱਕ ਤੋਂ ਵੱਧ ਡੁਪਲੀਕੇਟ ਹਨ ਤਾਂ ਉਹੀ ਹੈ# ਨੰਬਰਾਂ ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਵਾਪਸ ਕਰੋ ਕਿ ਕੀ ਉਹ ਕ੍ਰਮਬੱਧ ਹਨ ਜਾਂ ਨਹੀਂ।# >>> is_sorted([5])\n# 1\n# >>> is_sorted([1, 2, 3, 4, 5])\n# 1\n# >>> is_sorted([1, 3, 2, 4, 5])\n# \"\"\n# >>> is_sorted([1, 2, 3, 4, 5, 6])\n# 1\n# >>> is_sorted([1, 2, 3, 4, 5, 6, 7])\n# 1\n# >>> is_sorted([1, 3, 2, 4, 5, 6, 7])\n# \"\"\n# >>> is_sorted([1, 2, 2, 3, 3, 4])\n# 1\n# >>> is_sorted([1, 2, 2, 2, 3, 4])\n# \"\"\nsub is_sorted {\n    my($lst) = @_;\n","canonical_solution":"sub is_sorted {\n    my($lst) = @_;\n    my %count;\n    \n    for (my $i = 0; $i < @$lst; $i++) {\n        $count{$lst->[$i]}++;\n        \n        # Check for more than one duplicate\n        if ($count{$lst->[$i]} > 2) {\n            return '';\n        }\n        \n        # Check if the array is not sorted\n        if ($i > 0 && $lst->[$i] < $lst->[$i - 1]) {\n            return '';\n        }\n    }\n    \n    return 1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_sorted;\n        if(eq_deeply($candidate->([5]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 2, 4, 5]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6, 7]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 2, 4, 5, 6, 7]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3, 2, 1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 2, 2, 3, 4]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 3, 3, 4]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 2, 3, 3, 4]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_127","nl":"pan_Guru","pl":"pl","prompt":"# [ਇੰਪੁੱਟ\/ਆਉਟਪੁੱਟ] ਨਮੂਨੇਃ # ਜੇ ਦੋ ਅੰਤਰਾਲਾਂ ਨੂੰ ਕੱਟਿਆ ਨਹੀਂ ਜਾਂਦਾ, ਤਾਂ \"NO\" ਵਾਪਸ ਕਰੋ.# ਨਹੀਂ ਤਾਂ, \"NO\" ਵਾਪਸ ਕਰੋ।# ਜੇ ਇੰਟਰਸੈਕਸ਼ਨ ਦੀ ਲੰਬਾਈ ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਨੰਬਰ ਹੈ, ਤਾਂ \"YES\" ਵਾਪਸ ਕਰੋ, # ਜਿਸਦੀ ਲੰਬਾਈ 1 ਹੈ, ਜੋ ਕਿ ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਨੰਬਰ ਨਹੀਂ ਹੈ।# ਉਦਾਹਰਨ ਲਈ, ਅੰਤਰਾਲਾਂ (1, 3), (2, 4) ਦਾ ਅੰਤਰਾਲ (2, 3) ਹੈ।# ਅੰਤਰਾਲ ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਨੰਬਰ ਹੈ।# ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਨਿਰਧਾਰਤ ਕਰਨਾ ਹੈ ਕਿ ਕੀ ਇਹਨਾਂ ਦੋਵਾਂ ਦੀ ਲਾਂਘੇ ਦੀ ਲੰਬਾਈ # ਹਰੇਕ ਦਿੱਤੇ ਅੰਤਰਾਲ ਲਈ, ਇਹ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਕਿ ਇਸ ਦੀ ਸ਼ੁਰੂਆਤ ਇਸ ਦੇ ਅੰਤ ਤੋਂ ਘੱਟ ਜਾਂ ਬਰਾਬਰ ਹੈ।# ਸ਼ੁਰੂ ਅਤੇ ਅੰਤ ਦੋਵੇਂ ਸ਼ਾਮਲ ਹਨ।# ਦਿੱਤੇ ਗਏ ਅੰਤਰਾਲ ਬੰਦ ਹਨ ਜਿਸਦਾ ਮਤਲਬ ਹੈ ਕਿ ਅੰਤਰਾਲ (ਸ਼ੁਰੂਆਤ, ਅੰਤ) # ਜਿੱਥੇ ਹਰ ਅੰਤਰਾਲ ਪੂਰਨ ਅੰਕ ਦਾ ਇੱਕ ਜੋੜਾ ਹੁੰਦਾ ਹੈ। ਉਦਾਹਰਣ ਲਈ, ਅੰਤਰਾਲ = (ਸ਼ੁਰੂਆਤ, ਅੰਤ) = (1, 2).# ਤੁਹਾਨੂੰ ਦੋ ਅੰਤਰਾਲ ਦਿੱਤੇ ਗਏ ਹਨ, # >>> intersection([1, 2], [2, 3])\n# \"NO\"\n# >>> intersection([-1, 1], [0, 4])\n# \"NO\"\n# >>> intersection([-3, -1], [-5, 5])\n# \"YES\"\nsub intersection {\n    my($interval1, $interval2) = @_;\n","canonical_solution":"sub is_prime {\n    my $num = shift;\n    return 0 if $num <= 1;\n    for my $i (2 .. sqrt($num)) {\n        return 0 if $num % $i == 0;\n    }\n    return 1;\n}\n\nsub intersection {\n    my ($interval1, $interval2) = @_;\n\n    my $start1 = $interval1->[0];\n    my $end1 = $interval1->[1];\n    my $start2 = $interval2->[0];\n    my $end2 = $interval2->[1];\n\n    my $intersection_start = ($start1 > $start2) ? $start1 : $start2;\n    my $intersection_end = ($end1 < $end2) ? $end1 : $end2;\n\n    if ($intersection_start <= $intersection_end) {\n        my $intersection_length = $intersection_end - $intersection_start;\n        return is_prime($intersection_length) ? \"YES\" : \"NO\";\n    }\n\n    return \"NO\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&intersection;\n        if(eq_deeply($candidate->([1, 2], [2, 3]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 1], [0, 4]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3, -1], [-5, 5]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-2, 2], [-4, 0]),\"YES\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-11, 2], [-1, -1]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2], [3, 5]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2], [1, 2]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-2, -2], [-3, -2]),\"NO\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_128","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # ਨੋਟਃ ਖਾਲੀ ਆਰਰ ਲਈ undef ਵਾਪਸ ਕਰੋ।# ਐਰੇ ਵਿੱਚ ਹਰੇਕ ਨੰਬਰ ਦੀ, 1, -1 ਜਾਂ 0 ਦੁਆਰਾ ਦਰਸਾਏ ਗਏ.# ਪੂਰਨ ਅੰਕ ਦੇ ਆਕਾਰ ਦਾ ਜੋੜ ਸਾਰੇ ਸੰਕੇਤਾਂ ਦੇ ਉਤਪਾਦ ਨਾਲ ਗੁਣਾ ਕੀਤਾ ਗਿਆ ਹੈ # ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ ਅਤੇ ਤੁਹਾਨੂੰ ਵਾਪਸ ਕਰਨ ਦੀ ਲੋੜ ਹੈ # >>> prod_signs([1, 2, 2, -4])\n# 9\n# >>> prod_signs([0, 1])\n# 0\n# >>> prod_signs([])\n# undef\nsub prod_signs {\n    my($arr) = @_;\n","canonical_solution":"sub prod_signs {\n    my($arr) = @_;\n    return undef if scalar(@$arr) == 0;\n\n    my $sum_magnitudes = 0;\n    my $product_signs = 1;\n\n    for my $num (@$arr) {\n        $sum_magnitudes += abs($num);\n        \n        if ($num > 0) {\n            $product_signs *= 1;\n        } elsif ($num < 0) {\n            $product_signs *= -1;\n        } else {\n            $product_signs *= 0;\n        }\n    }\n\n    return $sum_magnitudes * $product_signs;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&prod_signs;\n        if(eq_deeply($candidate->([1, 2, 2, -4]),-9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 1]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1, 1, 2, 3, -1, 1]),-10)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 1, 2, -1, -1, 9]),20)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 1, -1, 1]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 1, 1, 1]),-4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 1, 1, 0]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_129","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਸੈੱਲਾਂ ਦੇ ਮੁੱਲਾਂ ਦੀ ਇੱਕ ਕ੍ਰਮਬੱਧ ਐਰੇ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚੋਂ ਘੱਟੋ ਘੱਟ ਮਾਰਗ ਲੰਘਦਾ ਹੈ।# ਇਸ ਦਾ ਜਵਾਬ ਗਾਰੰਟੀਸ਼ੁਦਾ ਹੈ ਕਿ ਵਿਲੱਖਣ ਹੈ।# lst_A[j] = lst_B[j]. # ਅਜਿਹੇ lst_A[i] < lst_B[i] ਅਤੇ ਕਿਸੇ ਵੀ j (1 <= j <i) ਲਈ ਸਾਡੇ ਕੋਲ # lst_B ਤੋਂ, ਦੂਜੇ ਸ਼ਬਦਾਂ ਵਿੱਚ, ਇੱਕ ਪੂਰਨ ਅੰਕ ਸੂਚਕ i (1 <= i <= k) ਮੌਜੂਦ ਹੈ।# ਦੁਆਰਾ (ਆਓ ਉਨ੍ਹਾਂ ਨੂੰ lst_A ਅਤੇ lst_B ਕਹਿੰਦੇ ਹਾਂ), lst_A ਲੈਕਸੀਕੋਗ੍ਰਾਫਿਕ ਤੌਰ ਤੇ ਘੱਟ ਹੈ # ਸੈੱਲਾਂ 'ਤੇ ਮੁੱਲਾਂ ਦੇ ਕ੍ਰਮਬੱਧ ਐਰੇ ਬਣਾਉਣ ਤੋਂ ਬਾਅਦ ਕਿ A ਅਤੇ B ਜਾਂਦੇ ਹਨ # ਇੱਕ ਮਾਰਗ A (ਲੰਬਾਈ k) ਨੂੰ ਇੱਕ ਮਾਰਗ B (ਲੰਬਾਈ k) ਤੋਂ ਛੋਟਾ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਜੇਕਰ # ਤੁਸੀਂ ਗ੍ਰੀਡ ਤੋਂ ਬਾਹਰ ਨਹੀਂ ਜਾ ਸਕਦੇ।# ਜ਼ਰੂਰੀ ਤੌਰ ਤੇ ਵੱਖਰੇ).# ਕਿਰਪਾ ਕਰਕੇ ਨੋਟ ਕਰੋ ਕਿ ਲੰਬਾਈ k ਦੇ ਮਾਰਗ ਦਾ ਮਤਲਬ ਹੈ ਕਿ ਬਿਲਕੁਲ k ਸੈੱਲਾਂ ਦਾ ਦੌਰਾ ਕਰਨਾ (ਨਾ ਕਿ # ਮੋਬਾਈਲ# ਦੂਜੇ ਸ਼ਬਦਾਂ ਵਿੱਚ, ਤੁਸੀਂ ਉਹਨਾਂ ਸੈੱਲਾਂ ਵਿੱਚ ਜਾ ਸਕਦੇ ਹੋ ਜੋ ਤੁਹਾਡੇ ਨਾਲ ਇੱਕ ਕਿਨਾਰੇ ਸਾਂਝੇ ਕਰਦੇ ਹਨ।# ਕਿਸੇ ਵੀ ਸੈੱਲ ਤੋਂ, ਅਤੇ ਹਰ ਕਦਮ ਵਿੱਚ ਤੁਸੀਂ ਕਿਸੇ ਵੀ ਗੁਆਂਢੀ ਸੈੱਲਾਂ ਵਿੱਚ ਜਾ ਸਕਦੇ ਹੋ, # ਤੁਹਾਨੂੰ ਗਰਿੱਡ ਵਿੱਚ ਲੰਬਾਈ k ਦਾ ਘੱਟੋ ਘੱਟ ਮਾਰਗ ਲੱਭਣਾ ਹੈ. ਤੁਸੀਂ ਸ਼ੁਰੂ ਕਰ ਸਕਦੇ ਹੋ # ਗ੍ਰੇਡ ਦੇ ਸੈੱਲਾਂ ਵਿੱਚ ਬਿਲਕੁਲ ਇੱਕ ਵਾਰ ਸ਼ਾਮਲ ਹੁੰਦਾ ਹੈ।# ਗਰਿੱਡ ਦੇ ਹਰੇਕ ਸੈੱਲ ਵਿੱਚ ਇੱਕ ਮੁੱਲ ਹੁੰਦਾ ਹੈ। [1, N * N] ਦੀ ਸੀਮਾ ਵਿੱਚ ਹਰ ਪੂਰਨ ਅੰਕ # N ਕਤਾਰਾਂ ਅਤੇ N ਕਾਲਮਾਂ (N >= 2) ਅਤੇ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ k, ਨਾਲ ਇੱਕ ਗਰਿੱਡ ਦਿੱਤੀ ਗਈ ਹੈ, # >>> minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n# [1, 2, 1]\n# >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n# [1]\nsub minPath {\n    my($grid, $k) = @_;\n","canonical_solution":"sub minPath {\n    my ($grid, $k) = @_;\n    my $n = scalar @$grid;\n\n    # Create direction vectors for up, down, left, right moves\n    my @directions = ([0, 1], [1, 0], [0, -1], [-1, 0]);\n\n    # Priority queue to store paths using a lexicographically ordered array\n    my @queue;\n    for my $i (0..$n-1) {\n        for my $j (0..$n-1) {\n            push @queue, [[$grid->[$i][$j]], $i, $j];\n        }\n    }\n\n    # Sort the initial cells based on their values to start with minimum paths\n    @queue = sort { $a->[0][0] <=> $b->[0][0] } @queue;\n\n    # Implement a breadth-first search that continues until we have a path of length k\n    while (@queue) {\n        my $current = shift @queue;\n        my ($path, $x, $y) = @$current;\n\n        # Return the first path of length k since paths are checked in lexicographical order\n        return @$path if scalar @$path == $k;\n\n        # Explore neighboring cells\n        for my $direction (@directions) {\n            my ($dx, $dy) = @$direction;\n            my ($nx, ny) = ($x + $dx, $y + $dy);\n            \n            # Check for valid cell\n            if ($nx >= 0 && $nx < $n && $ny >= 0 && $ny < $n) {\n                my @new_path = (@$path, $grid->[$nx][$ny]);\n                push @queue, [\\@new_path, $nx, $ny];\n            }\n        }\n        # Keep the queue ordered by lexicographical order of paths\n        @queue = sort { \n            my ($a_path, $b_path) = ($a->[0], $b->[0]);\n            for my $i (0..$#$a_path) {\n                return $a_path->[$i] <=> $b_path->[$i] if $a_path->[$i] != $b_path->[$i];\n            }\n        } @queue;\n    }\n}\n\n# Example usage:\n#print join(\", \", minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)), \"\\n\";  # [1, 2, 1]\n#print join(\", \", minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)), \"\\n\";  # [1]","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&minPath;\n        if(eq_deeply($candidate->([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1),[1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10, 1, 10, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1, 6, 1, 6, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1, 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_130","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਟ੍ਰਿਬੋਨੈਕਸੀ ਲੜੀ ਦੇ ਪਹਿਲੇ n + 1 ਨੰਬਰ. # ਤੁਹਾਨੂੰ ਇੱਕ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤੁਹਾਨੂੰ ਇੱਕ ਐਰੇ ਨੂੰ ਵਾਪਸ ਕਰਨਾ ਪਵੇਗਾ # = 2 + 3 + 3 = 8 # ਤ੍ਰਿਏਕ (3) = ਤ੍ਰਿਏਕ (2) + ਤ੍ਰਿਏਕ (1) + ਤ੍ਰਿਏਕ (4)# ਤ੍ਰਿ) = 3 # tri(2) = 1 + (2 \/ 2) = 2 # ਉਦਾਹਰਣ ਲਈ: # tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ਜੇ n ਅਜੀਬ ਹੈ. # tri (n) = 1 + n \/ 2, ਜੇ n ਜਮ੍ਹਾ ਹੈ. # tri(1) = 3 # ਟ੍ਰਿਬੋਨੈਕਸੀ ਕ੍ਰਮ ਨੂੰ ਮੁੜ-ਉਪਲੱਬਧਤਾ ਦੁਆਰਾ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤਾ ਗਿਆ ਹੈਃ # ਪਰ, ਜੋ ਲੋਕ ਨਹੀਂ ਜਾਣਦੇ ਉਹ ਹੈ ਟ੍ਰਿਬੋਨੈਕਸੀ ਕ੍ਰਮ।# ਹਰ ਕੋਈ ਫਿਬੋਨਾਚੀ ਕ੍ਰਮ ਨੂੰ ਜਾਣਦਾ ਹੈ, ਇਸ ਦਾ ਗਣਿਤ ਵਿਗਿਆਨੀਆਂ ਦੁਆਰਾ ੧ ਵਿੱਚ ਡੂੰਘਾ ਅਧਿਐਨ ਕੀਤਾ ਗਿਆ ਸੀ # >>> tri(3)\n# [1, 3, 2, 8]\nsub tri {\n    my($n) = @_;\n","canonical_solution":"sub tri {\n    my ($n) = @_;\n    my @sequence = (3);  # starting with tri(1) = 3\n\n    for my $i (1 .. $n) {\n        if ($i % 2 == 0) {\n            push @sequence, 1 + $i \/ 2;\n        } else {\n            my $val = $sequence[$i - 1] + $sequence[$i - 2] + ($i + 1 <= $n ? (1 + ($i + 1) \/ 2) : 0);\n            push @sequence, $val;\n        }\n    }\n\n    return @sequence;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&tri;\n        if(eq_deeply($candidate->(3),[1, 3, 2, 8])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),[1, 3, 2, 8, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),[1, 3, 2, 8, 3, 15])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),[1, 3, 2, 8, 3, 15, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),[1, 3, 2, 8, 3, 15, 4, 24])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),[1, 3, 2, 8, 3, 15, 4, 24, 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(9),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(20),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0),[1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),[1, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_131","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # 0 ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਸਾਰੇ ਅੰਕ ਜੋੜੇ ਹਨ।# ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਅਜੀਬ ਅੰਕ ਦੇ ਉਤਪਾਦ ਨੂੰ ਵਾਪਸ ਕਰੋ. # >>> digits(1)\n# 1\n# >>> digits(4)\n# 0\n# >>> digits(235)\n# 15\nsub digits {\n    my($n) = @_;\n","canonical_solution":"my @digits = split \/\/, $n;\n    my $product = 1;\n    my $has_odd = 0;\n\n    foreach my $digit (@digits) {\n        if ($digit % 2 != 0) {\n            $product *= $digit;\n            $has_odd = 1;\n        }\n    }\n\n    return $has_odd ? $product : 0;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&digits;\n        if(eq_deeply($candidate->(5),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(54),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(120),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5014),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(98765),315)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5576543),2625)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2468),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_132","nl":"pan_Guru","pl":"pl","prompt":"# ਜਿੱਥੇ ਕਿ ਘੱਟੋ-ਘੱਟ ਇੱਕ ਬ੍ਰੇਕ ਵਿੱਚ ਉਪ-ਕ੍ਰਮ ਵਿੱਚ ਘੇਰਿਆ ਹੋਇਆ ਹੈ।# ਫੰਕਸ਼ਨ ਨੂੰ 1 ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੇਕਰ ਅਤੇ ਕੇਵਲ ਜੇਕਰ ਬਰੈਕਟਾਂ ਦਾ ਇੱਕ ਵੈਧ ਉਪ-ਕ੍ਰਮ ਹੈ # ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਸਤਰ ਨੂੰ ਇੰਪੁੱਟ ਦੇ ਤੌਰ ਤੇ ਲੈਂਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਸਿਰਫ ਵਰਗ ਬਰੈਕਟ ਹੁੰਦੇ ਹਨ.# >>> is_nested(\"[[]]\")\n# 1\n# >>> is_nested(\"[]]]]]]][[[[[]\")\n# \"\"\n# >>> is_nested(\"[][]\")\n# \"\"\n# >>> is_nested(\"[]\")\n# \"\"\n# >>> is_nested(\"[[][]]\")\n# 1\n# >>> is_nested(\"[[]][[\")\n# 1\nsub is_nested {\n    my($string) = @_;\n","canonical_solution":"sub is_nested {\n    my ($string) = @_;\n    my @stack;\n\n    for my $char (split \/\/, $string) {\n        if ($char eq '[') {\n            push @stack, $char;\n        } elsif ($char eq ']') {\n            if (@stack && $stack[-1] eq '[') {\n                pop @stack;\n                return 1 if @stack; # Check for nesting\n            } else {\n                return \"\"; # Unbalanced brackets\n            }\n        }\n    }\n\n    return \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_nested;\n        if(eq_deeply($candidate->(\"[[]]\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[]]]]]]][[[[[]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[][]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[[[[]]]]\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[]]]]]]]]]]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[][][[]]\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[[]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[]]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[[]][[\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[[][]]\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"[[[[[[[[\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"]]]]]]]]\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_133","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਐਰੇ ਵਿੱਚ ਹਰੇਕ ਤੱਤ ਨੂੰ ਸਭ ਤੋਂ ਪਹਿਲਾਂ ਉਪਰਲੇ int ((Ceiling) ਤੱਕ ਗੋਲ ਕਰੋ।# ਤੁਹਾਨੂੰ ਦਿੱਤੇ ਗਏ ਐਰੇ ਵਿੱਚ ਵਰਗ ਦੇ ਅੰਕ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰਨ ਦੀ ਲੋੜ ਹੈ, # ਤੁਹਾਨੂੰ ਇੱਕ ਨੰਬਰ ਦੀ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ।# >>> lst([1.0, 2.0, 3.0])\n# 14\n# >>> lst([1.0, 4.0, 9.0])\n# 98\n# >>> lst([1.0, 3.0, 5.0, 7.0])\n# 84\n# >>> lst([1.4, 4.2, 0.0])\n# 29\n# >>> lst([-2.4, 1.0, 1.0])\n# 6\nsub sum_squares {\n    my($lst) = @_;\n","canonical_solution":"sub sum_squares {\n    my($lst) = @_;\n    my $sum = 0;\n    foreach my $num (@$lst) {\n        my $ceil_num = int($num) + ($num > int($num) ? 1 : 0);\n        $sum += $ceil_num ** 2;\n    }\n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sum_squares;\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0]),14)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0]),14)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.0, 3.0, 5.0, 7.0]),84)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1.4, 4.2, 0.0]),29)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-2.4, 1.0, 1.0]),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100.0, 1.0, 15.0, 2.0]),10230)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([10000.0, 10000.0]),200000000)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.4, 4.6, 6.3]),75)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.4, 17.9, 18.9, 19.9]),1086)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.0]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.0]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.0, 1.0, 0.0]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_134","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਨੋਟਃ \"ਵਰਡ\" ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਅੱਖਰਾਂ ਦਾ ਸਮੂਹ ਹੈ।# ਇੱਕ ਸ਼ਬਦ ਦਾ ਇੱਕ ਹਿੱਸਾ, ਅਤੇ '' ਹੋਰ.# ਇੱਕ ਦਿੱਤੇ ਗਏ ਸਤਰ ਦਾ ਇੱਕ ਵਰਣਮਾਲਾ ਅੱਖਰ ਹੈ ਅਤੇ  ਨਹੀਂ ਹੈ# ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ 1 ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ ਆਖਰੀ ਅੱਖਰ  ਹੈ# >>> check_if_last_char_is_a_letter(\"apple pie\")\n# \"\"\n# >>> check_if_last_char_is_a_letter(\"apple pi e\")\n# 1\n# >>> check_if_last_char_is_a_letter(\"apple pi e \")\n# \"\"\n# >>> check_if_last_char_is_a_letter(\"\")\n# \"\"\nsub check_if_last_char_is_a_letter {\n    my($txt) = @_;\n","canonical_solution":"sub check_if_last_char_is_a_letter {\n    my ($txt) = @_;\n    $txt =~ s\/\\s+$\/\/; # Trim trailing spaces\n    return '' if $txt eq ''; \n\n    if ($txt =~ \/([^a-zA-Z])([a-zA-Z])$\/ && $1 eq ' ') {\n        return 1;\n    }\n    \n    return '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&check_if_last_char_is_a_letter;\n        if(eq_deeply($candidate->(\"apple\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"apple pi e\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eeeee\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"A\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Pumpkin pie \"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Pumpkin pie 1\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"eeeee e \"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"apple pie\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"apple pi e \"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_135","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਡੁਪਲੀਕੇਟ ਮੁੱਲ।# ਕੋਈ ਅਜਿਹਾ ਤੱਤ ਮੌਜੂਦ ਨਹੀਂ ਹੈ ਤਾਂ ਵਾਪਸੀ -1. ਦਿੱਤੀ ਗਈ ਐਰੇ ਵਿੱਚ ਸ਼ਾਮਲ ਨਹੀਂ ਹੋਵੇਗਾ # ਤੋਂ ਵੱਧ ਜਾਂ ਬਰਾਬਰ ਨਹੀਂ ਹੈ।# ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਕਿਸੇ ਐਲੀਮੈਂਟ ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਇੰਡੈਕਸ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੋ # >>> can_arrange([1, 2, 4, 3, 5])\n# 3\n# >>> can_arrange([1, 2, 3])\n# -1\nsub can_arrange {\n    my($arr) = @_;\n","canonical_solution":"sub can_arrange {\n    my ($arr) = @_;\n    for my $i (1 .. $#$arr) {\n        if ($arr->[$i] < $arr->[$i - 1]) {\n            return $i;\n        }\n    }\n    return -1;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&can_arrange;\n        if(eq_deeply($candidate->([1, 2, 4, 3, 5]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 4, 5]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 4, 2, 5, 6, 7, 8, 9, 10]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 8, 5, 7, 3]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_136","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਜੇਕਰ ਕੋਈ ਨਕਾਰਾਤਮਕ ਜਾਂ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਨਾ ਹੋਣ ਤਾਂ ਉਹਨਾਂ ਨੂੰ undef ਦੇ ਰੂਪ ਵਿੱਚ ਵਾਪਸ ਕਰੋ।# ਇੱਕ ਐਰੇ ਵਿੱਚ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੇ. # ਸਭ ਤੋਂ ਵੱਡਾ ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਹੈ, ਅਤੇ 'ਬੀ' ਸਭ ਤੋਂ ਛੋਟਾ ਹੈ # ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਐਰੇ (a, b) ਵਾਪਸ ਕਰਦਾ ਹੈ, ਜਿੱਥੇ 'a'  ਹੈ# >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n# [undef, 1]\n# >>> largest_smallest_integers([])\n# [undef, undef]\n# >>> largest_smallest_integers([0])\n# [undef, undef]\nsub largest_smallest_integers {\n    my($lst) = @_;\n","canonical_solution":"sub largest_smallest_integers {\n    my ($lst) = @_;\n    my ($largest_neg, $smallest_pos);\n\n    foreach my $num (@$lst) {\n        if ($num < 0) {\n            $largest_neg = $num if !defined($largest_neg) || $num > $largest_neg;\n        } elsif ($num > 0) {\n            $smallest_pos = $num if !defined($smallest_pos) || $num < $smallest_pos;\n        }\n    }\n    \n    return ($largest_neg, $smallest_pos);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&largest_smallest_integers;\n        if(eq_deeply($candidate->([2, 4, 1, 3, 5, 7]),[undef, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, 1, 3, 5, 7, 0]),[undef, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 2, 4, 5, 6, -2]),[-2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4, 5, 3, 6, 2, 7, -7]),[-7, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7, 3, 8, 4, 9, 2, 5, -9]),[-9, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[undef, undef])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0]),[undef, undef])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -3, -5, -6]),[-1, undef])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -3, -5, -6, 0]),[-1, undef])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-6, -4, -4, -3, 1]),[-3, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-6, -4, -4, -3, -100, 1]),[-3, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_137","nl":"pan_Guru","pl":"pl","prompt":"# ਨੋਟਃ ਜੇਕਰ ਇੱਕ ਅਸਲੀ ਸੰਖਿਆ ਨੂੰ ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਦਰਸਾਇਆ ਗਿਆ ਹੈ, ਤਾਂ ਫਲੋਟਿੰਗ ਪੁਆਇੰਟ ਹੋ ਸਕਦਾ ਹੈ . ਜਾਂ , # undef ਵਾਪਸ ਕਰੋ ਜੇਕਰ ਮੁੱਲ ਬਰਾਬਰ ਹਨ।# ਅਸਲ ਨੰਬਰ, ਅਤੇ ਇਸ ਦੇ ਦਿੱਤੇ ਗਏ ਵੇਰੀਏਬਲ ਕਿਸਮ ਵਿੱਚ ਵੱਡਾ ਵੇਰੀਏਬਲ ਵਾਪਸ ਕਰਦਾ ਹੈ. # ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਪੂਰਨ ਅੰਕ, ਫਲੋਟਸ, ਜਾਂ ਸਤਰਾਂ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ # >>> compare_one(1, 2.5)\n# 2.5\n# >>> compare_one(1, \"2,3\")\n# \"2,3\"\n# >>> compare_one(\"5,1\", \"6\")\n# \"6\"\n# >>> compare_one(\"1\", 1)\n# undef\nsub compare_one {\n    my($a, $b) = @_;\n","canonical_solution":"sub compare_one {\n    my ($a, $b) = @_;\n\n    # Convert potential string numbers with ',' into float representation\n    $a =~ s\/,\/.\/g if $a =~ \/,\/;\n    $b =~ s\/,\/.\/g if $b =~ \/,\/;\n\n    # Auto-detect type by checking if string has non-numeric parts\n    my $a_is_num = $a =~ \/^\\d+(\\.\\d+)?$\/;\n    my $b_is_num = $b =~ \/^\\d+(\\.\\d+)?$\/;\n\n    if ($a_is_num && $b_is_num) {\n        # Compare as numbers\n        if ($a < $b) {\n            return $b;\n        } elsif ($a > $b) {\n            return $a;\n        } else {\n            return undef;\n        }\n    } else {\n        # Compare as strings\n        if ($a lt $b) {\n            return $b;\n        } elsif ($a gt $b) {\n            return $a;\n        } else {\n            return undef;\n        }\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&compare_one;\n        if(eq_deeply($candidate->(1, 2),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 2.5),2.5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 3),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 6),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, \"2,3\"),\"2,3\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"5,1\", \"6\"),\"6\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1\", \"2\"),\"2\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1\", 1),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_138","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨ # ਮੁਲਾਂਕਣ ਕਰੋ ਕਿ ਕੀ ਦਿੱਤੀ ਗਈ ਸੰਖਿਆ n ਨੂੰ ਬਿਲਕੁਲ 4 ਸਕਾਰਾਤਮਕ ਜੋੜ ਸੰਖਿਆਵਾਂ ਦੇ ਜੋੜ ਦੇ ਰੂਪ ਵਿੱਚ ਲਿਖਿਆ ਜਾ ਸਕਦਾ ਹੈ # >>> is_equal_to_sum_even(4)\n# \"\"\n# >>> is_equal_to_sum_even(6)\n# \"\"\n# >>> is_equal_to_sum_even(8)\n# 1\nsub is_equal_to_sum_even {\n    my($n) = @_;\n","canonical_solution":"sub is_equal_to_sum_even {\n    my($n) = @_;\n\n    # A number can be expressed as the sum of four positive even numbers\n    # if and only if it is greater than or equal to 8 and is even\n    if ($n >= 8 && $n % 2 == 0) {\n        return 1;\n    } else {\n        return \"\";\n    }\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_equal_to_sum_even;\n        if(eq_deeply($candidate->(4),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(11),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(12),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(13),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(16),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_139","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਜਿੱਥੇ n > 0 # ਬ੍ਰਾਜ਼ੀਲੀਅਨ_ਫੈਕਟੋਰੀਅਲ (n) = n! * (n-1)! * (n-2)! * ... * 1! # ਬ੍ਰਾਜ਼ੀਲ ਦੇ ਫੈਕਟਰੀਅਲ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤਾ ਗਿਆ ਹੈਃ # >>> special_factorial(4)\n# 288\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\nsub special_factorial {\n    my($n) = @_;\n","canonical_solution":"sub special_factorial {\n    my($n) = @_;\n    my $result = 1;\n    \n    for my $i (1 .. $n) {\n        $result *= factorial($i);\n    }\n    \n    return $result;\n}\n\nsub factorial {\n    my($num) = @_;\n    my $fact = 1;\n\n    for my $i (1 .. $num) {\n        $fact *= $i;\n    }\n\n    return $fact;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&special_factorial;\n        if(eq_deeply($candidate->(4),288)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),34560)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7),125411328000)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_140","nl":"pan_Guru","pl":"pl","prompt":"# ਫਿਰ ਸਾਰੇ ਲਗਾਤਾਰ ਸਪੇਸਾਂ ਨੂੰ -  ਨਾਲ ਬਦਲੋ# ਅਤੇ ਜੇਕਰ ਇੱਕ ਸਤਰ ਵਿੱਚ 2 ਤੋਂ ਵੱਧ ਲਗਾਤਾਰ ਸਪੇਸ ਹਨ, # ਇੱਕ ਟੈਕਸਟ ਸਤਰ ਦਿੱਤੀ ਗਈ ਹੈ, ਇਸ ਵਿੱਚ ਸਾਰੇ ਸਪੇਸਾਂ ਨੂੰ ਅੰਡਰਸਕੋਰ ਨਾਲ ਬਦਲੋ, # >>> fix_spaces(\" Example\")\n# \"Example\"\n# >>> fix_spaces(\" Example 1\")\n# \"Example_1\"\n# >>> fix_spaces(\" Example 2\")\n# \"_Example_2\"\n# >>> fix_spaces(\" Example 3\")\n# \"_Example-3\"\nsub fix_spaces {\n    my($text) = @_;\n","canonical_solution":"sub fix_spaces {\n    my($text) = @_;\n    $text =~ s\/ {3,}\/-\/g;   # Replace 3 or more spaces with a hyphen\n    $text =~ s\/ \/_\/g;       # Replace remaining spaces with underscores\n    return $text;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&fix_spaces;\n        if(eq_deeply($candidate->(\"Example\"),\"Example\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mudasir Hanif \"),\"Mudasir_Hanif_\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Yellow Yellow  Dirty  Fellow\"),\"Yellow_Yellow__Dirty__Fellow\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Exa   mple\"),\"Exa-mple\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"   Exa 1 2 2 mple\"),\"-Exa_1_2_2_mple\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_141","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # - ਡੌਟ ਤੋਂ ਬਾਅਦ ਸਬਸਟ੍ਰਿੰਗ ਇਹਨਾਂ ਵਿੱਚੋਂ ਇੱਕ ਹੋਣੀ ਚਾਹੀਦੀ ਹੈਃ ['txt', 'exe', 'dll'] # ਲਾਤੀਨੀ ਅੱਖਰ ('a'-'z' ਅਤੇ 'A'-'Z').# - ਡੌਟ ਤੋਂ ਪਹਿਲਾਂ ਸਬਸਟ੍ਰਿੰਗ ਖਾਲੀ ਨਹੀਂ ਹੋਣੀ ਚਾਹੀਦੀ, ਅਤੇ ਇਹ  ਤੋਂ ਇੱਕ ਅੱਖਰ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦੀ ਹੈ# - ਫਾਈਲ ਦੇ ਨਾਮ ਵਿੱਚ ਬਿਲਕੁਲ ਇੱਕ ਬਿੰਦੀ ਹੈ '.'# - ਫਾਈਲ ਦੇ ਨਾਮ ਵਿੱਚ ਤਿੰਨ ਤੋਂ ਵੱਧ ਅੰਕ ('0'-'9') ਨਹੀਂ ਹੋਣੇ ਚਾਹੀਦੇ।# ਨੂੰ ਪੂਰਾ ਕੀਤਾ ਜਾਂਦਾ ਹੈ: # ਇੱਕ ਫਾਈਲ ਦਾ ਨਾਮ ਵੈਧ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਜੇਕਰ ਅਤੇ ਕੇਵਲ ਜੇਕਰ ਹੇਠ ਲਿਖੀਆਂ ਸਾਰੀਆਂ ਸ਼ਰਤਾਂ ਪੂਰੀਆਂ ਹੁੰਦੀਆਂ ਹਨ # 'ਹਾਂ' ਜੇ ਫਾਈਲ ਦਾ ਨਾਮ ਠੀਕ ਹੈ, ਅਤੇ 'ਨਹੀਂ' ਵਾਪਸ ਕਰਦਾ ਹੈ।# ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਫਾਈਲ ਦੇ ਨਾਮ ਨੂੰ ਦਰਸਾਉਂਦੀ ਇੱਕ ਸਤਰ ਲੈਂਦੀ ਹੈ, ਅਤੇ ਵਾਪਸ ਕਰਦੀ ਹੈ # >>> file_name_check(\"example.txt\")\n# \"Yes\"\n# >>> file_name_check(\"1example.dll\")\n# \"No\"\nsub file_name_check {\n    my($file_name) = @_;\n","canonical_solution":"sub file_name_check {\n    my($file_name) = @_;\n    \n    # Check if there's exactly one dot and split the string\n    my @parts = split(\/\\.\/, $file_name);\n    return 'No' unless scalar(@parts) == 2;\n\n    # Extract the name and the extension\n    my ($name, $extension) = @parts;\n\n    # Check if the extension is valid\n    return 'No' unless $extension =~ \/^(txt|exe|dll)$\/;\n\n    # Check if the name starts with a letter\n    return 'No' unless $name =~ \/^[a-zA-Z]\/;\n\n    # Check the number of digits in the name\n    my $digit_count = () = $name =~ \/[0-9]\/g;\n    return 'No' if $digit_count > 3;\n\n    # If all conditions are met, return 'Yes'\n    return 'Yes';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&file_name_check;\n        if(eq_deeply($candidate->(\"example.txt\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1example.dll\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"s1sdf3.asd\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"K.dll\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"MY16FILE3.exe\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"His12FILE94.exe\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"_Y.txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"?aREYA.exe\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\/this_is_valid.dll\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"this_is_valid.wow\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"this_is_valid.txt\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"this_is_valid.txtexe\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#this2_i4s_5valid.ten\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"@this1_is6_valid.exe\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"this_is_12valid.6exe4.txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"all.exe.txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"I563_No.exe\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Is3youfault.txt\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"no_one#knows.dll\"),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1I563_Yes3.exe\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"I563_Yes3.txtt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"final..txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"final132\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"_f4indsartal132.\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\".txt\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"s.\"),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_142","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਐਰੇ ਵਿੱਚ ਐਂਟਰੀਆਂ ਨੂੰ ਬਦਲੋ ਜਿਨ੍ਹਾਂ ਦੇ ਇੰਡੈਕਸ 3 ਜਾਂ 4 ਦੇ ਗੁਣਾ ਨਹੀਂ ਹਨ. ਫੰਕਸ਼ਨ ਨੂੰ ਫਿਰ ਸਾਰੀਆਂ ਐਂਟਰੀਆਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ.# 3 ਦਾ ਬਹੁਲ ਹੈ ਅਤੇ ਪੂਰਨ ਅੰਕ ਇੰਦਰਾਜ਼ ਨੂੰ ਘਣ ਕਰੇਗਾ ਜੇਕਰ ਇਸ ਦਾ ਸੂਚਕ 4 ਦਾ ਬਹੁਲ ਹੈ ਅਤੇ 3 ਦਾ ਬਹੁਲ ਨਹੀਂ ਹੈ. ਫੰਕਸ਼ਨ ਨਹੀਂ ਕਰੇਗਾ # ਇਹ ਫੰਕਸ਼ਨ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ ਲਵੇਗਾ। ਐਰੇ ਵਿੱਚ ਸਾਰੀਆਂ ਐਂਟਰੀਆਂ ਲਈ, ਫੰਕਸ਼ਨ ਪੂਰਨ ਅੰਕ ਐਂਟਰੀ ਨੂੰ ਵਰਗ ਦੇਵੇਗੀ ਜੇ ਇਸਦਾ ਇੰਡੈਕਸ ਇੱਕ  ਹੈ।# \" # >>> lst\n# [1, 2, 3]\n# >>> lst\n# []\n# >>> lst\n# [-1, -5, 2, -1, -5]\nsub sum_squares {\n    my($lst) = @_;\n","canonical_solution":"sub sum_squares {\n    my ($lst) = @_;\n    my $sum = 0;\n\n    for my $i (0 .. @$lst - 1) {\n        if ($i % 3 == 0) {\n            $sum += $lst->[$i] ** 2;\n        } elsif ($i % 4 == 0) {\n            $sum += $lst->[$i] ** 3;\n        } else {\n            $sum += $lst->[$i];\n        }\n    }\n\n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sum_squares;\n        if(eq_deeply($candidate->([1, 2, 3]),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 4, 9]),14)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1, 1, 1, 1, 1, 1, 1, 1]),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -1, -1, -1, -1, -1, -1, -1, -1]),-3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -5, 2, -1, -5]),-126)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-56, -99, 1, 0, -2]),3030)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, 0, 0, 0, 0, 0, 0, 0, -1]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]),-14196)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]),-1448)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_143","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨ 1: # ਨਵੇਂ ਸਤਰ ਵਿੱਚ ਸ਼ਬਦਾਂ ਦਾ ਕ੍ਰਮ ਮੂਲ ਸਤਰ ਦੇ ਸਮਾਨ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।# ਜਿਸ ਦੀ ਲੰਬਾਈ ਪ੍ਰਾਇਮ ਨੰਬਰ ਹਨ, # ਅਤੇ ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਪਵੇਗੀ ਜਿਸ ਵਿੱਚ ਮੂਲ ਵਾਕ ਦੇ ਸ਼ਬਦ ਸ਼ਾਮਲ ਹਨ, # ਵਾਕ ਵਿੱਚ ਕੁਝ ਸ਼ਬਦ ਹਨ ਜੋ ਇੱਕ ਸਪੇਸ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਗਏ ਹਨ, # ਤੁਹਾਨੂੰ ਇੱਕ ਵਾਕ ਨੂੰ ਦਰਸਾਉਣ ਵਾਲੀ ਇੱਕ ਸਤਰ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ, # >>> words_in_sentence(\"This is a test\")\n# \"is\"\n# Example 2:\n# >>> words_in_sentence(\"lets go for swimming\")\n# \"go for\"\n# Constraints:\n# * 1 <= len(sentence) <= 100\n# * sentence contains only letters\nsub words_in_sentence {\n    my($sentence) = @_;\n","canonical_solution":"sub words_in_sentence {\n    my($sentence) = @_;\n    \n    # Function to check if a number is prime\n    sub is_prime {\n        my $num = shift;\n        return 0 if $num < 2;\n        for (my $i = 2; $i * $i <= $num; ++$i) {\n            return 0 if $num % $i == 0;\n        }\n        return 1;\n    }\n    \n    my @words = split(' ', $sentence);\n    my @prime_length_words;\n    \n    foreach my $word (@words) {\n        my $length = length($word);\n        if (is_prime($length)) {\n            push(@prime_length_words, $word);\n        }\n    }\n    \n    return join(' ', @prime_length_words);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&words_in_sentence;\n        if(eq_deeply($candidate->(\"This is a test\"),\"is\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"lets go for swimming\"),\"go for\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"there is no place available here\"),\"there is no place\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hi I am Hussein\"),\"Hi am Hussein\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"go for it\"),\"go for it\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"here\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"here is\"),\"is\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_144","nl":"pan_Guru","pl":"pl","prompt":"# ਤੁਸੀਂ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ x, ਅਤੇ n ਜਾਇਜ਼ ਭਿੰਨ ਹਨ, ਅਤੇ ਨਾਮਾਤਰ ਦੇ ਤੌਰ ਤੇ ਜ਼ੀਰੋ ਨਹੀਂ ਹੈ.# <ਅੰਕ>\/<ਅੰਕ> ਜਿੱਥੇ ਕਿ ਦੋਵੇਂ ਅੰਕਾਂ ਅਤੇ ਨਾਮਾਂਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਹਨ।# x ਅਤੇ n, ਦੋਵੇਂ ਹੀ ਇੱਕ ਭੰਡਾਰ ਦੀ ਸਤਰ ਪ੍ਰਤੀਨਿਧਤਾ ਹਨ, ਅਤੇ ਇਹਨਾਂ ਦਾ ਹੇਠਲਾ ਫਾਰਮੈਟ ਹੈ, # x * n. ਫੰਕਸ਼ਨ 1 ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇਕਰ x * n ਇੱਕ ਪੂਰਨ ਅੰਕ ਅਤੇ ' ' # ਤੁਹਾਡਾ ਕੰਮ ਇੱਕ ਫੰਕਸ਼ਨ ਨੂੰ ਲਾਗੂ ਕਰਨਾ ਹੈ ਜੋ ਸਮੀਕਰਨ ਨੂੰ ਸਰਲ ਬਣਾਏਗਾ # >>> simplify(\"1\/5\", \"5\/1\")\n# 1\n# >>> simplify(\"1\/6\", \"2\/1\")\n# \"\"\n# >>> simplify(\"7\/10\", \"10\/2\")\n# \"\"\nsub simplify {\n    my($x, $n) = @_;\n","canonical_solution":"sub simplify {\n    my ($x, $n) = @_;\n    \n    # Parse the fractions\n    my ($x_num, $x_den) = split('\/', $x);\n    my ($n_num, $n_den) = split('\/', $n);\n    \n    # Cross-multiply to find the product of the fractions\n    # x * n = (x_num * n_num) \/ (x_den * n_den)\n    my $prod_num = $x_num * $n_num;\n    my $prod_den = $x_den * $n_den;\n    \n    # Check if the product is a whole number\n    return ($prod_num % $prod_den == 0) ? 1 : '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&simplify;\n        if(eq_deeply($candidate->(\"1\/5\", \"5\/1\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1\/6\", \"2\/1\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"5\/1\", \"3\/1\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"7\/10\", \"10\/2\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2\/10\", \"50\/10\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"7\/2\", \"4\/2\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"11\/6\", \"6\/1\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2\/3\", \"5\/2\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"5\/2\", \"3\/5\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2\/4\", \"8\/4\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"2\/4\", \"4\/2\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1\/5\", \"5\/1\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1\/5\", \"1\/5\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_145","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਉਹਨਾਂ ਨੂੰ ਉਹਨਾਂ ਦੇ ਮੂਲ ਐਰੇ ਵਿੱਚ ਇੰਡੈਕਸ ਦੇ ਆਧਾਰ ਤੇ ਕ੍ਰਮਬੱਧ ਕਰੋ।# ਨੋਟਃ ਜੇ ਕਈ ਆਈਟਮਾਂ ਹਨ ਜਿਨ੍ਹਾਂ ਦੇ ਅੰਕ ਦਾ ਜੋੜ ਸਮਾਨ ਹੈ, # ਉਨ੍ਹਾਂ ਦੇ ਅੰਕਾਂ ਦੇ ਜੋੜ ਦੇ ਅਨੁਸਾਰ ਵੱਧਦੇ ਕ੍ਰਮ ਵਿੱਚ।# ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਦਿੱਤੇ ਗਏ ਪੂਰਨ ਅੰਕ ਦੇ ਐਰੇ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕਰੇ # >>> order_by_points([1, 11, -1, -11, -12])\n# [-1, -11, 1, -12, 11]\n# >>> order_by_points([])\n# []\nsub order_by_points {\n    my($nums) = @_;\n","canonical_solution":"sub order_by_points {\n    my ($nums) = @_;\n    \n    # Function to calculate the sum of the digits of a number\n    sub digit_sum {\n        my $num = shift;\n        my $sum = 0;\n        $sum += $_ for split \/\/, abs($num);\n        return $sum;\n    }\n\n    # Sort the array first by sum of digits, then by index for ties\n    my @sorted = sort {\n        digit_sum($a) <=> digit_sum($b) ||\n        $a <=> $b\n    } @$nums;\n\n    return \\@sorted;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&order_by_points;\n        if(eq_deeply($candidate->([1, 11, -1, -11, -12]),[-1, -11, 1, -12, 11])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98, -11, 1, 2, 43, 54])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_146","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਇੱਕ ਸੰਖਿਆ ਦੇ ਪਹਿਲੇ ਅਤੇ ਆਖਰੀ ਅੰਕ ਅਜੀਬ ਹਨ (1, 3, 5, 7, 9).# ਐਰੇ ਵਿੱਚ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ ਜੋ 10 ਤੋਂ ਵੱਧ ਹੈ ਅਤੇ ਦੋਵੇਂ # ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਨੰਬਰਾਂ ਦੀ ਇੱਕ ਐਰੇ ਨੂੰ ਇਨਪੁਟ ਅਤੇ ਰਿਟਰਨ ਵਜੋਂ ਲੈਂਦਾ ਹੈ # >>> specialFilter([15, -73, 14, -15])\n# 1\n# >>> specialFilter([33, -2, -3, 45, 21, 109])\n# 2\nsub specialFilter {\n    my($nums) = @_;\n","canonical_solution":"sub specialFilter {\n    my($nums) = @_;\n    my $count = 0;\n    foreach my $num (@$nums) {\n        if ($num > 10) {\n            my $str_num = abs($num) . \"\";\n            my $first_digit = substr($str_num, 0, 1);\n            my $last_digit = substr($str_num, -1, 1);\n            if ($first_digit % 2 != 0 && $last_digit % 2 != 0) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&specialFilter;\n        if(eq_deeply($candidate->([5, -2, 1, -5]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([15, -73, 14, -15]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([33, -2, -3, 45, 21, 109]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([43, -12, 93, 125, 121, 109]),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([71, -2, -33, 75, 21, 19]),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_147","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨ:# ਅਤੇ a[i] + a[j] + a[k] 3 ਦਾ ਗੁਣਾ ਹੈ।# a ਦੇ ਤ੍ਰਿਪੋਲਾਂ ਦੀ ਗਿਣਤੀ (a[i], a[j], a[k]) ਵਾਪਸ ਕਰੋ ਜਿੱਥੇ i < j < k, # ਹਰੇਕ i (1 ≤ i ≤ n) ਲਈ, a[i] = i * i - i + 1 ਦਾ ਮੁੱਲ।# ਤੁਹਾਨੂੰ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ. ਤੁਹਾਨੂੰ ਲੰਬਾਈ n ਦੀ ਇੱਕ ਪੂਰਨ ਅੰਕ ਐਰੇ ਬਣਾਉਣਾ ਹੈ.# >>> get_max_triples(5)\n# 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7, 13).\nsub get_max_triples {\n    my($n) = @_;\n","canonical_solution":"sub get_max_triples {\n    my($n) = @_;\n    my @a;\n    \n    # Generate the array a\n    for my $i (1..$n) {\n        $a[$i - 1] = $i * $i - $i + 1;\n    }\n    \n    my $count = 0;\n    \n    # Check all triples (a[i], a[j], a[k]) where i < j < k\n    for my $i (0..$n-3) {\n        for my $j ($i+1..$n-2) {\n            for my $k ($j+1..$n-1) {\n                if (($a[$i] + $a[$j] + $a[$k]) % 3 == 0) {\n                    $count++;\n                }\n            }\n        }\n    }\n    \n    return $count;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_max_triples;\n        if(eq_deeply($candidate->(5),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),36)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),53361)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_148","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਾਂ # ਸਹੀ ਗ੍ਰਹਿ ਨਾਂ ਨਹੀਂ ਹਨ।# ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਖਾਲੀ ਐਰੇ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੇਕਰ planet1 ਜਾਂ planet2 # ਸੂਰਜ ਦੇ ਨੇੜੇ ਹੋਣਾ।# ਗ੍ਰਹਿ 1 ਦੀ ਘੁੰਮਣ-ਘੇਰੀ ਅਤੇ ਗ੍ਰਹਿ 2 ਦੀ ਘੁੰਮਣ-ਘੇਰੀ ਦੇ ਵਿਚਕਾਰ ਸਥਿਤ,  ਦੁਆਰਾ ਕ੍ਰਮਬੱਧ# ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਉਹ ਸਾਰੇ ਗ੍ਰਹਿ ਸ਼ਾਮਲ ਹਨ ਜਿਨ੍ਹਾਂ ਦੀਆਂ ਚੱਕਰਾਂ # ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਦੋ ਗ੍ਰਹਿ ਨਾਮਾਂ ਨੂੰ ਸਤਰਾਂ ਦੇ ਰੂਪ ਵਿੱਚ ਗ੍ਰਹਿ 1 ਅਤੇ ਗ੍ਰਹਿ 2 ਦੇ ਰੂਪ ਵਿੱਚ ਲੈਂਦਾ ਹੈ.# ਯੂਰੇਨਸ, ਨੈਪਚੂਨ।# ਹੈ, ਅਗਲਾ ਹੈ, ਫਿਰ ਧਰਤੀ, ਮੰਗਲ, ਜੁਪੀਟਰ, ਸ਼ਨੀ,# ਸਾਡੇ ਸੂਰਜੀ ਪ੍ਰਣਾਲੀ ਵਿੱਚ ਅੱਠ ਗ੍ਰਹਿ ਹਨ: ਸੂਰਜ ਦੇ ਸਭ ਤੋਂ ਨੇੜੇ# >>> bf(\"Jupiter\", \"Neptune\")\n# [\"Saturn\", \"Uranus\"]\n# >>> bf(\"Earth\", \"Mercury\")\n# \"Venus\"\n# >>> bf(\"Mercury\", \"Uranus\")\n# [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nsub bf {\n    my($planet1, $planet2) = @_;\n","canonical_solution":"sub bf {\n    my ($planet1, $planet2) = @_;\n    my @planets = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune');\n\n    my %planet_indices = map { $planets[$_] => $_ } (0..$#planets);\n\n    return [] unless exists $planet_indices{$planet1} && exists $planet_indices{$planet2};\n\n    my ($start, $end) = ($planet_indices{$planet1}, $planet_indices{$planet2});\n\n    ($start, $end) = ($end, $start) if $start > $end;\n\n    return [@planets[$start+1 .. $end-1]];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&bf;\n        if(eq_deeply($candidate->(\"Jupiter\", \"Neptune\"),[\"Saturn\", \"Uranus\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Earth\", \"Mercury\"),[\"Venus\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mercury\", \"Uranus\"),[\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Neptune\", \"Venus\"),[\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Earth\", \"Earth\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mars\", \"Earth\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Jupiter\", \"Makemake\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_149","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਤੁਸੀਂ ਇਹ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਸਾਰੇ ਸ਼ਬਦਾਂ ਦੀ ਲੰਬਾਈ ਇੱਕੋ ਜਿਹੀ ਹੋਵੇਗੀ।# ਫੰਕਸ਼ਨ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕ੍ਰਮ ਵਿੱਚ ਸਤਰਾਂ ਦੀ ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ।# ਜੇਕਰ ਦੋ ਸ਼ਬਦਾਂ ਦੀ ਲੰਬਾਈ ਇੱਕੋ ਜਿਹੀ ਹੈ, ਤਾਂ ਐਰੇ ਨੂੰ ਵਰਣਮਾਲਾ ਅਨੁਸਾਰ ਕ੍ਰਮਬੱਧ ਕਰੋ।# ਉਸ ਨਿਯਮ ਦੁਆਰਾ ਕ੍ਰਮਬੱਧ ਐਰੇ ਨੂੰ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ.# ਐਰੇ ਦਾ ਕ੍ਰਮ ਹਰ ਸ਼ਬਦ ਦੀ ਲੰਬਾਈ ਦੇ ਨਾਲ ਵੱਧਣਾ ਚਾਹੀਦਾ ਹੈ, ਅਤੇ ਤੁਸੀਂ # ਅਤੇ ਇਸ ਵਿੱਚ ਡੁਪਲੀਕੇਟ ਹੋ ਸਕਦੇ ਹਨ।# ਐਰੇ ਹਮੇਸ਼ਾ ਸਤਰਾਂ ਦਾ ਐਰੇ ਹੁੰਦਾ ਹੈ ਅਤੇ ਕਦੇ ਵੀ ਸੰਖਿਆਵਾਂ ਦਾ ਐਰੇ ਨਹੀਂ ਹੁੰਦਾ,# ਅਤੇ ਇੱਕ ਕ੍ਰਮਬੱਧ ਕ੍ਰਮ ਨਾਲ ਨਤੀਜੇ ਵਾਲੇ ਐਰੇ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ, # ਉਹ ਸਤਰਾਂ ਨੂੰ ਮਿਟਾ ਦਿੰਦਾ ਹੈ ਜਿਨ੍ਹਾਂ ਦੀ ਲੰਬਾਈ ਇਸ ਤੋਂ ਅਣਗਿਣਤ ਹੈ, # ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਪੈਰਾਮੀਟਰ ਦੇ ਤੌਰ ਤੇ ਸਤਰਾਂ ਦੀ ਇੱਕ ਐਰੇ ਨੂੰ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ,# >>> list_sort([\"aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n# [\"ab\", \"cd\"]\nsub sorted_list_sum {\n    my($lst) = @_;\n","canonical_solution":"sub list_sort {\n    my ($lst) = @_;\n\n    # Filter out strings with odd length\n    my @filtered = grep { length($_) % 2 == 0 } @$lst;\n\n    # Sort strings first by length, then alphabetically\n    my @sorted = sort { length($a) <=> length($b) || $a cmp $b } @filtered;\n\n    return \\@sorted;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&sorted_list_sum;\n        if(eq_deeply($candidate->([\"aa\", \"a\", \"aaa\"]),[\"aa\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"school\", \"AI\", \"asdf\", \"b\"]),[\"AI\", \"asdf\", \"school\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"d\", \"b\", \"c\", \"a\"]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"d\", \"dcba\", \"abcd\", \"a\"]),[\"abcd\", \"dcba\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"AI\", \"ai\", \"au\"]),[\"AI\", \"ai\", \"au\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]),[\"cc\", \"dd\", \"aaaa\", \"bbbb\"])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_150","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਇੱਕ ਪ੍ਰਾਇਮਰੀ ਨੰਬਰ ਹੈ ਅਤੇ y ਦਾ ਮੁੱਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਨਹੀਂ ਤਾਂ.# ਇੱਕ ਸਧਾਰਨ ਪ੍ਰੋਗਰਾਮ ਜਿਸ ਨੂੰ x ਦਾ ਮੁੱਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੇਕਰ n  ਹੈ# >>> x_or_y(7, 34, 12)\n# 34\n# >>> x_or_y(15, 8, 5)\n# 5\nsub x_or_y {\n    my($n, $x, $y) = @_;\n","canonical_solution":"sub is_prime {\n    my $num = shift;\n    return 0 if $num < 2;\n    for (my $i = 2; $i * $i <= $num; $i++) {\n        return 0 if $num % $i == 0;\n    }\n    return 1;\n}\n\nsub x_or_y {\n    my ($n, $x, $y) = @_;\n    return is_prime($n) ? $x : $y;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&x_or_y;\n        if(eq_deeply($candidate->(7, 34, 12),34)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(15, 8, 5),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3, 33, 5212),33)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1259, 3, 52),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7919, -1, 12),-1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3609, 1245, 583),583)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(91, 56, 129),129)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(6, 34, 1234),1234)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 2, 0),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 2, 0),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_151","nl":"pan_Guru","pl":"pl","prompt":"# ਐਰੇ ਵਿੱਚ ਜੋ ਅਜੀਬ ਹਨ. ਉਹ ਨੰਬਰ ਅਣਡਿੱਠ ਕਰੋ ਜੋ ਨਕਾਰਾਤਮਕ ਹਨ ਜਾਂ ਪੂਰਨ ਅੰਕ ਨਹੀਂ ਹਨ.# ਨੰਬਰਾਂ ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਨੰਬਰਾਂ ਦੇ ਵਰਗ ਦੇ ਜੋੜ ਨੂੰ ਵਾਪਸ ਕਰੋ # >>> double_the_difference([1, 3, 2, 0])\n# 10\n# >>> double_the_difference([-1, -2, 0])\n# 0\n# >>> double_the_difference([9, -2])\n# 81\n# >>> double_the_difference([0])\n# 0\n# If the input array is empty, return 0.\nsub double_the_difference {\n    my($lst) = @_;\n","canonical_solution":"sub double_the_difference {\n    my ($lst) = @_;\n    my $sum = 0;\n\n    foreach my $num (@$lst) {\n        if ($num =~ \/^\\d+$\/ && $num % 2 != 0) {\n            $sum += $num ** 2;\n        }\n    }\n    \n    return $sum;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&double_the_difference;\n        if(eq_deeply($candidate->([]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5.0, 4.0]),25)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.1, 0.2, 0.3]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-10.0, -20.0, -30.0]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1.0, -2.0, 8.0]),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0.2, 3.0, 5.0]),34)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]),165)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_152","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # ਮੁੱਲ 0 ਹੈ ਅਤੇ ਜੇਕਰ ਨਹੀਂ, ਤਾਂ ਮੁੱਲ ਅਨੁਮਾਨ ਅਤੇ ਸਕੋਰ ਦੇ ਵਿਚਕਾਰ ਪੂਰਨ ਅੰਤਰ ਹੈ।# ਇੱਕੋ ਲੰਬਾਈ ਦੀ ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰੋ ਜੋ ਦਰਸਾਉਂਦੀ ਹੈ ਕਿ ਹਰ ਅੰਦਾਜ਼ਾ ਕਿੰਨਾ ਦੂਰ ਸੀ. ਜੇ ਉਨ੍ਹਾਂ ਨੇ ਸਹੀ ਅੰਦਾਜ਼ਾ ਲਗਾਇਆ ਹੈ, # ਤੁਹਾਨੂੰ ਬਰਾਬਰ ਲੰਬਾਈ ਦੇ ਸਕੋਰ ਅਤੇ ਅਨੁਮਾਨਾਂ ਦੇ ਦੋ ਐਰੇ ਦਿੱਤੇ ਗਏ ਹਨ, ਜਿੱਥੇ ਹਰੇਕ ਇੰਡੈਕਸ ਇੱਕ ਮੈਚ ਦਿਖਾਉਂਦਾ ਹੈ।# ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਤੈਅ ਕਰਨਾ ਹੈ ਕਿ ਕੀ ਕਿਸੇ ਵਿਅਕਤੀ ਨੇ ਕਈ ਮੈਚਾਂ ਦੇ ਨਤੀਜਿਆਂ ਦਾ ਸਹੀ ਅੰਦਾਜ਼ਾ ਲਗਾਇਆ ਹੈ।# ਨਿਸ਼ਚਿਤ ਤੌਰ ਤੇ ਨੋਟ ਕਰਨ ਅਤੇ ਤੁਲਨਾ ਕਰਨ ਦੇ ਯੋਗ ਹੈ।# ਇਸ ਘਟਨਾ ਬਾਰੇ ਅੰਤ ਵਿੱਚ ਪਤਾ ਲੱਗ ਜਾਂਦਾ ਹੈ। ਉਸ ਸਮੇਂ ਤੁਹਾਡੇ ਕੋਲ ਜੋ ਭਾਵਨਾਵਾਂ ਅਤੇ ਵਿਚਾਰ ਹਨ ਉਹ ਹਨ # ਮੈਨੂੰ ਲਗਦਾ ਹੈ ਕਿ ਸਾਨੂੰ ਸਾਰਿਆਂ ਨੂੰ ਉਹ ਭਾਵਨਾ ਯਾਦ ਹੈ ਜਦੋਂ ਕਿਸੇ ਲੰਬੇ ਸਮੇਂ ਤੋਂ ਉਡੀਕਿਆ ਹੋਇਆ ਨਤੀਜਾ# >>> compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n# [0, 0, 0, 0, 3, 3]\n# >>> compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n# [4, 4, 1, 0, 0, 6]\nsub compare {\n    my($game, $guess) = @_;\n","canonical_solution":"sub compare {\n    my($game, $guess) = @_;\n    my @result;\n    \n    for my $i (0..$#$game) {\n        my $difference = abs($game->[$i] - $guess->[$i]);\n        push @result, $difference;\n    }\n    \n    return @result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&compare;\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]),[0, 0, 0, 0, 3, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]),[0, 0, 0, 0, 0, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3], [-1, -2, -3]),[2, 4, 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 5], [-1, 2, 3, 4]),[2, 0, 0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_153","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # (ਇਸਦੀ ਤਾਕਤ -1) ਹੈ।# return 'Slices.SErviNGSliCes' ਕਿਉਂਕਿ 'SErviNGSliCes' ਸਭ ਤੋਂ ਮਜ਼ਬੂਤ ਐਕਸਟੈਂਸ਼ਨ ਹੈ # ਐਕਸਟੈਂਸ਼ਨਾਂਃ ['SErviNGSliCes', 'Cheese', 'StuFfed'] ਤਾਂ ਤੁਹਾਨੂੰ ਚਾਹੀਦਾ ਹੈ # ਉਦਾਹਰਨ ਲਈ, ਜੇ ਤੁਹਾਨੂੰ ਕਲਾਸ ਦੇ ਤੌਰ ਤੇ \"ਸਲਾਈਸ\" ਦਿੱਤਾ ਜਾਂਦਾ ਹੈ ਅਤੇ  ਦੀ ਇੱਕ ਐਰੇ# ਉਹ ਇੱਕ ਚੁਣੋ ਜੋ ਐਰੇ ਵਿੱਚ ਪਹਿਲਾਂ ਆਵੇ।# ਜੇ ਦੋ ਜਾਂ ਜ਼ਿਆਦਾ ਐਕਸਟੈਂਸ਼ਨਾਂ ਇੱਕੋ ਜਿਹੀ ਤਾਕਤ ਨਾਲ ਹਨ, ਤਾਂ ਤੁਹਾਨੂੰ # ਫਾਰਮੈਟਃ ClassName.StrongestExtensionName. # ਤੁਹਾਨੂੰ ਸਭ ਤੋਂ ਮਜ਼ਬੂਤ ਐਕਸਟੈਂਸ਼ਨ ਲੱਭਣੀ ਚਾਹੀਦੀ ਹੈ ਅਤੇ ਇਸ ਵਿੱਚ ਇੱਕ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ # ਐਕਸਟੈਂਸ਼ਨ ਦੇ ਨਾਮ ਵਿੱਚ, ਤਾਕਤ CAP - SM ਫ੍ਰੈਕਸ਼ਨ ਦੁਆਰਾ ਦਿੱਤੀ ਗਈ ਹੈ।# ਐਕਸਟੈਂਸ਼ਨ ਦੇ ਨਾਮ ਵਿੱਚ ਅੱਖਰ, ਅਤੇ SM ਨੂੰ ਛੋਟੇ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਮੰਨ ਲਓ # ਐਕਸਟੈਂਸ਼ਨ ਦੀ ਤਾਕਤ ਇਸ ਪ੍ਰਕਾਰ ਹੈਃ CAP ਨੂੰ ਵੱਡੇ ਅੱਖਰ ਦੀ ਸੰਖਿਆ ਮੰਨ ਲਓ # ਐਕਸਟੈਂਸ਼ਨਾਂ ਦੀ ਵਰਤੋਂ ਕਲਾਸ ਵਿੱਚ ਵਾਧੂ ਕਲਾਸਾਂ ਨੂੰ ਲੋਡ ਕਰਨ ਲਈ ਕੀਤੀ ਜਾਣੀ ਹੈ।# ਤੁਹਾਨੂੰ ਇੱਕ ਕਲਾਸ ਦਾ ਨਾਮ (ਇੱਕ ਸਤਰ) ਅਤੇ ਐਕਸਟੈਂਸ਼ਨਾਂ ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਜਾਵੇਗੀ।# >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n# \"my_class.AA\"\nsub Strongest_Extension {\n    my($class_name, $extensions) = @_;\n","canonical_solution":"sub Strongest_Extension {\n    my ($class_name, $extensions) = @_;\n    my $strongest = '';\n    my $max_strength = -1e9;\n\n    foreach my $extension (@$extensions) {\n        my $cap = 0;\n        my $sm = 0;\n\n        foreach my $char (split \/\/, $extension) {\n            if ($char =~ \/[A-Z]\/) {\n                $cap++;\n            } elsif ($char =~ \/[a-z]\/) {\n                $sm++;\n            }\n        }\n\n        my $strength = $cap - $sm;\n        \n        if ($strength > $max_strength) {\n            $max_strength = $strength;\n            $strongest = $extension;\n        }\n    }\n\n    return \"$class_name.$strongest\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&Strongest_Extension;\n        if(eq_deeply($candidate->(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]),\"Watashi.eIGHt8OKe\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]),\"Boku123.YEs.WeCaNe\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]),\"__YESIMHERE.NuLl__\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]),\"K.TAR\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]),\"__HAHA.123\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]),\"YameRore.okIWILL123\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]),\"finNNalLLly.WoW\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"_\", [\"Bb\", \"91245\"]),\"_.Bb\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Sp\", [\"671235\", \"Bb\"]),\"Sp.671235\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_154","nl":"pan_Guru","pl":"pl","prompt":"# ਤੁਹਾਨੂੰ 2 ਸ਼ਬਦ ਦਿੱਤੇ ਗਏ ਹਨ. ਤੁਹਾਨੂੰ 1 ਵਾਪਸ ਕਰਨ ਦੀ ਲੋੜ ਹੈ ਜੇ ਦੂਜਾ ਸ਼ਬਦ ਜਾਂ ਇਸਦੇ ਕਿਸੇ ਵੀ ਘੁੰਮਣ ਦਾ ਪਹਿਲਾ ਸ਼ਬਦ ਵਿੱਚ ਇੱਕ ਸਬਸਟ੍ਰਿੰਗ ਹੈ # >>> cycpattern_check(\"abcd\", \"abd\")\n# \"\"\n# >>> cycpattern_check(\"hello\", \"ell\")\n# 1\n# >>> cycpattern_check(\"whassup\", \"psus\")\n# \"\"\n# >>> cycpattern_check(\"abab\", \"baa\")\n# 1\n# >>> cycpattern_check(\"efef\", \"eeff\")\n# \"\"\n# >>> cycpattern_check(\"himenss\", \"simen\")\n# 1\nsub cycpattern_check {\n    my($a, $b) = @_;\n","canonical_solution":"sub cycpattern_check {\n    my($a, $b) = @_;\n    my $len = length($b);\n\n    for my $i (0 .. $len - 1) {\n        my $rotation = substr($b, $i) . substr($b, 0, $i);\n        return 1 if index($a, $rotation) != -1;\n    }\n\n    return \"\";\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&cycpattern_check;\n        if(eq_deeply($candidate->(\"xyzw\", \"xyw\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"yello\", \"ell\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"whattup\", \"ptut\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"efef\", \"fee\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"abab\", \"aabb\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"winemtt\", \"tinem\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_155","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # ਇੱਕ ਪੂਰਨ ਅੰਕ ਦਿੱਤਾ ਗਿਆ ਹੈ. ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਕ੍ਰਮਵਾਰ ਜੋੜ ਅਤੇ ਅਜੀਬ ਅੰਕ ਦੀ ਗਿਣਤੀ ਹੈ. # >>> even_odd_count(-12)\n# [1, 1]\n# >>> even_odd_count(123)\n# [1, 2]\nsub even_odd_count {\n    my($num) = @_;\n","canonical_solution":"my $evens = 0;\n    my $odds = 0;\n    $num = abs($num); # Handle negative numbers\n    foreach my $digit (split \/\/, $num) {\n        if ($digit % 2 == 0) {\n            $evens++;\n        } else {\n            $odds++;\n        }\n    }\n    return [$evens, $odds];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&even_odd_count;\n        if(eq_deeply($candidate->(7),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-78),[1, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3452),[2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(346211),[3, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-345821),[3, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-2),[1, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(-45347),[2, 3])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0),[1, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_156","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਃ # ਪਾਬੰਦੀਆਂ: 1 <= num <= 1000 # ਅਤੇ ਇਸਨੂੰ ਛੋਟੇ ਅੱਖਰਾਂ ਵਿੱਚ ਵਾਪਸ ਕਰੋ।# ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸ ਦੇ ਰੋਮਨ ਅੰਕਾਂ ਦੇ ਬਰਾਬਰ ਨੂੰ ਇੱਕ ਸਤਰ ਦੇ ਰੂਪ ਵਿੱਚ ਪ੍ਰਾਪਤ ਕਰੋ, # >>> int_to_mini_roman(19)\n# \"xix\"\n# >>> int_to_mini_roman(152)\n# \"clii\"\n# >>> int_to_mini_roman(426)\n# \"cdxxvi\"\nsub int_to_mini_roman {\n    my($number) = @_;\n","canonical_solution":"my @roman_numerals = (\n        [1000, 'm'],\n        [900, 'cm'],\n        [500, 'd'],\n        [400, 'cd'],\n        [100, 'c'],\n        [90, 'xc'],\n        [50, 'l'],\n        [40, 'xl'],\n        [10, 'x'],\n        [9, 'ix'],\n        [5, 'v'],\n        [4, 'iv'],\n        [1, 'i'],\n    );\n\n    my $result = '';\n\n    for my $pair (@roman_numerals) {\n        my ($value, $roman) = @$pair;\n        while ($number >= $value) {\n            $result .= $roman;\n            $number -= $value;\n        }\n    }\n\n    return $result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&int_to_mini_roman;\n        if(eq_deeply($candidate->(19),\"xix\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(152),\"clii\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(251),\"ccli\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(426),\"cdxxvi\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(500),\"d\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),\"i\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),\"iv\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(43),\"xliii\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(90),\"xc\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(94),\"xciv\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(532),\"dxxxii\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(900),\"cm\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(994),\"cmxciv\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1000),\"m\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_157","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # 90 ਡਿਗਰੀ।# ਇੱਕ ਸਿੱਧਾ ਕੋਣ ਵਾਲਾ ਤਿਕੋਣਾ ਇੱਕ ਤਿਕੋਣਾ ਹੈ ਜਿਸ ਵਿੱਚ ਇੱਕ ਕੋਣ ਸਿੱਧਾ ਕੋਣ ਹੈ ਜਾਂ# ਪਾਸੇ ਇੱਕ ਸਿੱਧਾ ਕੋਣ ਵਾਲਾ ਤਿਕੋਣਾ ਬਣਾਉਂਦੇ ਹਨ, '' ਨਹੀਂ ਤਾਂ.# ਇੱਕ ਤਿਕੋਣ ਦੇ ਤਿੰਨ ਪਾਸੇ ਦੀ ਲੰਬਾਈ ਦਿੱਤੀ ਗਈ ਹੈ. 1 ਵਾਪਸ ਕਰੋ ਜੇ ਤਿੰਨ # >>> right_angle_triangle(3, 4, 5)\n# 1\n# >>> right_angle_triangle(1, 2, 3)\n# \"\"\nsub right_angle_triangle {\n    my($a, $b, $c) = @_;\n","canonical_solution":"sub right_angle_triangle {\n    my($a, $b, $c) = @_;\n    # Sort the sides to identify the potential hypotenuse\n    my @sides = sort { $a <=> $b } ($a, $b, $c);\n    # Check if the triangle satisfies Pythagorean theorem\n    return ($sides[0] ** 2 + $sides[1] ** 2 == $sides[2] ** 2) ? 1 : '';\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&right_angle_triangle;\n        if(eq_deeply($candidate->(3, 4, 5),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 2, 3),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10, 6, 8),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 2, 2),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7, 24, 25),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10, 5, 7),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5, 12, 13),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(15, 8, 17),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(48, 55, 73),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 1, 1),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 2, 10),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_158","nl":"pan_Guru","pl":"pl","prompt":"# ਅੱਖਰ, ਉਹ ਵਾਪਸ ਕਰੋ ਜੋ ਸ਼ਬਦਕੋਸ਼ਿਕ ਕ੍ਰਮ ਵਿੱਚ ਪਹਿਲਾਂ ਆਉਂਦਾ ਹੈ. # ਵਿਲੱਖਣ ਅੱਖਰਾਂ ਦੀ ਵੱਧ ਤੋਂ ਵੱਧ ਗਿਣਤੀ ਹੈ।# ਐਰੇ ਵਿੱਚ ਵੱਖਰੇ ਸ਼ਬਦ ਹਨ। ਸ਼ਬਦ ਨੂੰ ਵੱਧ ਤੋਂ ਵੱਧ ਗਿਣਤੀ ਦੇ ਨਾਲ ਵਾਪਸ ਕਰੋ # ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਤਰਾਂ ਦੀ ਇੱਕ ਐਰੇ ਨੂੰ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ।# >>> find_max([\"name\", \"of\", \"string\"])\n# \"string\"\n# >>> find_max([\"name\", \"enam\", \"game\"])\n# \"enam\"\n# >>> find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\nsub find_max {\n    my($words) = @_;\n","canonical_solution":"sub find_max {\n    my ($words) = @_;\n    my $max_word = '';\n    my $max_unique_chars = 0;\n    \n    foreach my $word (@$words) {\n        my %unique_chars = map { $_ => 1 } split \/\/, $word;\n        my $unique_count = keys %unique_chars;\n        \n        if ($unique_count > $max_unique_chars || ($unique_count == $max_unique_chars && $word lt $max_word)) {\n            $max_word = $word;\n            $max_unique_chars = $unique_count;\n        }\n    }\n    \n    return $max_word;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&find_max;\n        if(eq_deeply($candidate->([\"name\", \"of\", \"string\"]),\"string\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"name\", \"enam\", \"game\"]),\"enam\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"aaaaaaa\", \"bb\", \"cc\"]),\"aaaaaaa\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"abc\", \"cba\"]),\"abc\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"play\", \"this\", \"game\", \"of\", \"footbott\"]),\"footbott\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"we\", \"are\", \"gonna\", \"rock\"]),\"gonna\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"we\", \"are\", \"a\", \"mad\", \"nation\"]),\"nation\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"this\", \"is\", \"a\", \"prrk\"]),\"this\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"b\"]),\"b\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"play\", \"play\", \"play\"]),\"play\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_159","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਨਃ # ਜੇ ਤੁਹਾਡੇ ਕੋਲ ਕਾਫ਼ੀ ਗਾਜਰ ਨਹੀਂ ਬਚੇ ਹਨ, ਤਾਂ ਤੁਸੀਂ ਬਾਕੀ ਸਾਰੇ ਗਾਜਰ ਖਾ ਲਓਗੇ, ਪਰ ਫਿਰ ਵੀ ਭੁੱਖੇ ਰਹੋਗੇ।# ਤੁਹਾਡੇ ਖਾਣੇ ਤੋਂ ਬਾਅਦ ਬਚੇ ਹੋਏ ਗਾਜਰ ਦੀ ਗਿਣਤੀ ] # ਤੁਹਾਨੂੰ ਖਾਣੇ ਤੋਂ ਬਾਅਦ ਖਾਧੇ ਗਏ ਗਾਜਰਾਂ ਦੀ ਕੁੱਲ ਗਿਣਤੀ, ਦੀ ਇੱਕ ਲੜੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ।# ਪਰ ਹੁਣ ਤੁਹਾਨੂੰ ਦਿਨ ਦੇ ਖਾਣੇ ਨੂੰ ਪੂਰਾ ਕਰਨ ਲਈ ਹੋਰ ਗਾਜਰ ਖਾਣ ਦੀ ਲੋੜ ਹੈ।# ਤੁਸੀਂ ਇੱਕ ਭੁੱਖਾ ਖਰਗੋਸ਼ ਹੋ, ਅਤੇ ਤੁਸੀਂ ਪਹਿਲਾਂ ਹੀ ਕੁਝ ਗਾਜਰ ਖਾ ਚੁੱਕੇ ਹੋ, # >>> eat(5, 6, 10)\n# [11, 4]\n# >>> eat(4, 8, 9)\n# [12, 1]\n# >>> eat(1, 10, 10)\n# [11, 0]\n# >>> eat(2, 11, 5)\n# [7, 0]\n# Variables:\n# @number : integer\n# the number of carrots that you have eaten.\n# @need : integer\n# the number of carrots that you need to eat.\n# @remaining : integer\n# the number of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\nsub eat {\n    my($number, $need, $remaining) = @_;\n","canonical_solution":"sub eat {\n    my($number, $need, $remaining) = @_;\n    my $total_eaten = $number + $need;\n    if ($remaining >= $need) {\n        $remaining -= $need;\n    } else {\n        $total_eaten = $number + $remaining;\n        $remaining = 0;\n    }\n    return [$total_eaten, $remaining];\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&eat;\n        if(eq_deeply($candidate->(5, 6, 10),[11, 4])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 8, 9),[12, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1, 10, 10),[11, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(2, 11, 5),[7, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 5, 7),[9, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4, 5, 1),[5, 0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_160","nl":"pan_Guru","pl":"pl","prompt":"# ਆਪਰੇਟਰ ਐਰੇ ਵਿੱਚ ਘੱਟੋ-ਘੱਟ ਇੱਕ ਆਪਰੇਟਰ ਹੁੰਦਾ ਹੈ, ਅਤੇ ਓਪਰੇਂਡ ਐਰੇ ਵਿੱਚ ਘੱਟੋ-ਘੱਟ ਦੋ ਓਪਰੇਂਡ ਹੁੰਦੇ ਹਨ।# ਓਪਰੇਂਡ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ ਹੈ।# ਆਪਰੇਟਰ ਐਰੇ ਦੀ ਲੰਬਾਈ ਓਪਰੇਂਡ ਐਰੇ ਦੀ ਲੰਬਾਈ ਘਟਾਓ ਇੱਕ ਦੇ ਬਰਾਬਰ ਹੈ।# ਨੋਟਃ # => ਨਤੀਜਾ = 9 # ਨਤੀਜਾ = 2 + 3 * 4 - 5 # ਐਰੇ = [2, 3, 4, 5] # ਆਪਰੇਟਰ['+', '*', '-'] # ਉਦਾਹਰਨਃ # ਐਕਸਪੋਨੈਂਸ਼ਨ (**) # ਮੰਜ਼ਿਲ ਵੰਡ ( \/\/ ) # ਗੁਣਾ (*) # ਘਟਾਓ ( - ) # ਜੋੜ (+) # ਬੁਨਿਆਦੀ ਅਲਜਬਰਾ ਕਾਰਜ: # ਸਮੀਕਰਨ ਅਤੇ ਇਸ ਸਮੀਕਰਨ ਦਾ ਮੁਲਾਂਕਣ ਵਾਪਸ ਕਰੋ.# ਦੂਜੀ ਐਰੇ ਪੂਰਨ ਅੰਕ ਦੀ ਇੱਕ ਐਰੇ ਹੈ. ਅਲਜਬ੍ਰਿਕ ਬਣਾਉਣ ਲਈ ਦੋ ਦਿੱਤੇ ਐਰੇ ਦੀ ਵਰਤੋਂ ਕਰੋ # ਦੋ ਐਰੇ ਆਪਰੇਟਰ ਅਤੇ ਓਪਰੇਂਡ ਦਿੱਤੇ ਗਏ ਹਨ। ਪਹਿਲੇ ਐਰੇ ਵਿੱਚ ਬੁਨਿਆਦੀ ਅਲਜਬਰਾ ਓਪਰੇਸ਼ਨ ਹਨ, ਅਤੇ sub do_algebra {\n    my($operator, $operand) = @_;\n","canonical_solution":"sub do_algebra {\n    my ($operator, $operand) = @_;\n    my $expression = $operand->[0];\n    \n    for my $i (0 .. $#$operator) {\n        my $op = $operator->[$i];\n        my $num = $operand->[$i + 1];\n        \n        if ($op eq '\/\/') {\n            $expression = \"int($expression \/ $num)\";\n        } else {\n            $expression .= \" $op $num\";\n        }\n    }\n    \n    return eval $expression;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&do_algebra;\n        if(eq_deeply($candidate->([\"**\", \"*\", \"+\"], [2, 3, 4, 5]),37)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"+\", \"*\", \"-\"], [2, 3, 4, 5]),9)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\/\/\", \"*\"], [7, 3, 4]),8)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_161","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣਾਂ # ਫੰਕਸ਼ਨ ਨੂੰ ਨਤੀਜੇ ਵਾਲੀ ਸਤਰ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ।# ਜੇਕਰ ਸਤਰ ਵਿੱਚ ਕੋਈ ਅੱਖਰ ਨਹੀਂ ਹਨ, ਤਾਂ ਸਤਰ ਨੂੰ ਉਲਟਾ ਦਿਓ।# ਨਹੀਂ ਤਾਂ ਇਸ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਹੀ ਰੱਖੋ।# ਜੇ s[i] ਇੱਕ ਅੱਖਰ ਹੈ, ਤਾਂ ਇਸਦੇ ਕੇਸ ਨੂੰ ਹੇਠਲੇ ਤੋਂ ਉੱਪਰਲੇ ਜਾਂ ਉਲਟ ਰੂਪ ਵਿੱਚ ਬਦਲੋ, # ਤੁਹਾਨੂੰ ਇੱਕ ਸਤਰ s ਦਿੱਤੀ ਗਈ ਹੈ।# >>> solve(\"1234\")\n# \"4321\"\n# >>> solve(\"ab\")\n# \"AB\"\n# >>> solve(\"#a@C\")\n# \"#A@c\"\nsub solve {\n    my($s) = @_;\n","canonical_solution":"sub solve {\n    my($s) = @_;\n    if ($s =~ \/[a-zA-Z]\/) {\n        $s =~ s\/([a-z])|([A-Z])\/defined $1 ? uc($1) : lc($2)\/ge;\n    } else {\n        $s = reverse($s);\n    }\n    return $s;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&solve;\n        if(eq_deeply($candidate->(\"AsDf\"),\"aSdF\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1234\"),\"4321\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"ab\"),\"AB\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#a@C\"),\"#A@c\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#AsdfW^45\"),\"#aSDFw^45\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#6@2\"),\"2@6#\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#$a^D\"),\"#$A^d\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"#ccc\"),\"#CCC\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_162","nl":"pan_Guru","pl":"pl","prompt":"# ਜੇ 'text' ਇੱਕ ਖਾਲੀ ਸਤਰ ਹੈ, undef ਵਾਪਸ ਕਰੋ।# ਇੱਕ ਸਤਰ 'text' ਦਿੱਤੀ ਗਈ ਹੈ, ਇਸਦੀ md5 ਹੈਸ਼ ਬਰਾਬਰ ਸਤਰ ਵਾਪਸ ਕਰੋ।# >>> string_to_md5(\"Hello world\")\n# \"3e25960a79dbc69b674cd4ec67a72c62\"\nsub string_to_md5 {\n    my($text) = @_;\n","canonical_solution":"use Digest::MD5 qw(md5_hex);\n\n    if ($text eq '') {\n        return undef;\n    }\n\n    return md5_hex($text);\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&string_to_md5;\n        if(eq_deeply($candidate->(\"Hello world\"),\"3e25960a79dbc69b674cd4ec67a72c62\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\"),undef)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"A B C\"),\"0ef78513b0cb8cef12743f5aeb35f888\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"password\"),\"5f4dcc3b5aa765d61d8327deb882cf99\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"},{"task_id":"HumanEval_163","nl":"pan_Guru","pl":"pl","prompt":"# ਉਦਾਹਰਣ ਲਈ: # ਅਤੇ b, ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ।# ਦੋ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ a ਅਤੇ b ਦਿੱਤੇ ਗਏ ਹਨ, a  ਦੇ ਵਿਚਕਾਰ ਜੋੜੇ ਅੰਕ ਵਾਪਸ ਕਰੋ# >>> generate_integers(2, 8)\n# [2, 4, 6, 8]\n# >>> generate_integers(8, 2)\n# [2, 4, 6, 8]\n# >>> generate_integers(10, 14)\n# []\nsub generate_integers {\n    my($a, $b) = @_;\n","canonical_solution":"sub generate_integers {\n    my($a, $b) = @_;\n    my @result;\n    my ($start, $end) = $a < $b ? ($a, $b) : ($b, $a);\n    \n    for my $i ($start..$end) {\n        push @result, $i if $i % 2 == 0;\n    }\n    \n    return @result;\n}","tests":"use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&generate_integers;\n        if(eq_deeply($candidate->(2, 10),[2, 4, 6, 8])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10, 2),[2, 4, 6, 8])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(132, 2),[2, 4, 6, 8])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(17, 89),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"}]