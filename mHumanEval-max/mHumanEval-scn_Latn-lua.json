[{"task_id":"HumanEval_0","nl":"scn_Latn","pl":"lua","prompt":"- data la soglia. - Verificate se in data tavula di numeri, ci sò dui numeri più vicini l'unu à l'altru chè -- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\n-- false\n-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n-- true\nlocal function has_close_elements(numbers, threshold)\n","canonical_solution":"local function has_close_elements(numbers, threshold)\n    for i = 1, #numbers do\n        for j = i + 1, #numbers do\n            if math.abs(numbers[i] - numbers[j]) < threshold then\n                return true\n            end\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = has_close_elements\n    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), true)\n    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), false)\n    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), true)\n    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), false)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), true)\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), true)\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_1","nl":"scn_Latn","pl":"lua","prompt":"- Ignorate ogni spaziu in a stringa d'entrata.- Gruppi separati sò equilibrati (ogni brace apertu hè ben chjusu) è ùn sò micca annidati l'unu in l'altru - siparà sti gruppi in strings siparati è torna a tavula di quelli. - L'input di sta funzioni è na stringa chi cunteni tanti gruppi di parentesi annidati. Lu tò scopu è di -- >>> separate_paren_groups('( ) (( )) (( )( ))')\n-- {'()', '(())', '(()())'}\nlocal function separate_paren_groups(paren_string)\n","canonical_solution":"local function separate_paren_groups(paren_string)\n    local result = {}\n    local balance = 0\n    local current_group = {}\n\n    for i = 1, #paren_string do\n        local char = paren_string:sub(i, i)\n        \n        if char == '(' then\n            balance = balance + 1\n        elseif char == ')' then\n            balance = balance - 1\n        end\n\n        if char ~= ' ' then\n            table.insert(current_group, char)\n        end\n        \n        if balance == 0 and #current_group > 0 then\n            table.insert(result, table.concat(current_group))\n            current_group = {}\n        end\n    end\n\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = separate_paren_groups\n    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {'(()())', '((()))', '()', '((())()())'})\n    lu.assertEquals(candidate('() (()) ((())) (((())))'), {'()', '(())', '((()))', '(((())))'})\n    lu.assertEquals(candidate('(()(())((())))'), {'(()(())((())))'})\n    lu.assertEquals(candidate('( ) (( )) (( )( ))'), {'()', '(())', '(()())'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_2","nl":"scn_Latn","pl":"lua","prompt":"- Rinnirizza la parti dicimali dû nùmmuru. - (a parti ristanti è sempri cchiù nica di 1).- e parti di nùmmaru nternu (u nùmmaru nternu cchiù granni cchiù nicu di lu nùmmaru datu) e decimali - Datu nu nùmmuru di puntu fluttuanti pusitivu, si pò scumudari 'n -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n","canonical_solution":"local function truncate_number(number)\n    local integer_part = math.floor(number)\n    local decimal_part = number - integer_part\n    return decimal_part\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_3","nl":"scn_Latn","pl":"lua","prompt":"- a ddu puntu la funzioni avissi a riturnari true. altrimenti avissi a riturnari false. - saldu zeru. U vostru compitu è di rilevà s'è in ogni mumentu u saldu di u contu casca sottu à zeru, è - Vi dugnu na tabella di depòsiti e ritiri di un cuntu bancari ca accumincia cu -- >>> below_zero({1, 2, 3})\n-- false\n-- >>> below_zero({1, 2, -4, 5})\n-- true\nlocal function below_zero(operations)\n","canonical_solution":"local function below_zero(operations)\n    local balance = 0\n    for _, operation in ipairs(operations) do\n        balance = balance + operation\n        if balance < 0 then\n            return true\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = below_zero\n    lu.assertEquals(candidate({}), false)\n    lu.assertEquals(candidate({1, 2, -3, 1, 2, -3}), false)\n    lu.assertEquals(candidate({1, 2, -4, 5, 6}), true)\n    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -4}), false)\n    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -5}), true)\n    lu.assertEquals(candidate({1, -2, 2, -2, 5, -5, 4, -4}), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_4","nl":"scn_Latn","pl":"lua","prompt":"- MAD = media. x - x_mean. - elementu è un puntu cintrali (media in stu casu): - La deviatazzioni assoluta media è la diffirenza assoluta media tra ogni - attornu a la media di stu gruppu di dati. - Pi na data tàvula di numari d'intrata, calculà la deviazzioni assoluta media -- >>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n-- 1.0\nlocal function mean_absolute_deviation(numbers)\n","canonical_solution":"local function mean_absolute_deviation(numbers)\n    local sum = 0\n    local count = #numbers\n    \n    -- Calculate the mean\n    for _, number in ipairs(numbers) do\n        sum = sum + number\n    end\n    local mean = sum \/ count\n    \n    -- Calculate the mean absolute deviation\n    local total_deviation = 0\n    for _, number in ipairs(numbers) do\n        total_deviation = total_deviation + math.abs(number - mean)\n    end\n    \n    return total_deviation \/ count\nend\n\n-- Example usage\n-- print(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})) -- Output: 1.0","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = mean_absolute_deviation\n    lu.assertEquals(candidate({1.0, 2.0}), 0.5)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0}), 1.0)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}), 1.2)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_5","nl":"scn_Latn","pl":"lua","prompt":"- Inserisci un numaru \"delimitatore\" trà ogni dui elementi consecutivi di a tavula di input ∀numeri\" -- >>> intersperse({}, 4)\n-- {}\n-- >>> intersperse({1, 2, 3}, 4)\n-- {1, 4, 2, 4, 3}\nlocal function intersperse(numbers, delimeter)\n","canonical_solution":"local function intersperse(numbers, delimeter)\n    local result = {}\n    for i = 1, #numbers do\n        table.insert(result, numbers[i])\n        if i < #numbers then\n            table.insert(result, delimeter)\n        end\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersperse\n    lu.assertEquals(candidate({}, 7), {})\n    lu.assertEquals(candidate({5, 6, 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})\n    lu.assertEquals(candidate({2, 2, 2}, 2), {2, 2, 2, 2, 2})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_6","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu (() (()) hà un massimu di dui livelli di nidificazione mentre chì ((())) hà trè. - Pi ogni gruppu, scrìviri lu liveddu cchiù funnu di nistamentu di parintesi. - Input di sta funzioni è na stringa rapprisintata di gruppi multipli pi parentizzi annidati siparati di spazzi. -- >>> parse_nested_parens('(()()) ((())) () ((())()())')\n-- {2, 3, 1, 3}\nlocal function parse_nested_parens(paren_string)\n","canonical_solution":"local function parse_nested_parens(paren_string)\n    local results = {}\n    for group in paren_string:gmatch(\"%S+\") do\n        local max_depth = 0\n        local current_depth = 0\n        for char in group:gmatch(\".\") do\n            if char == '(' then\n                current_depth = current_depth + 1\n                if current_depth > max_depth then\n                    max_depth = current_depth\n                end\n            elseif char == ')' then\n                current_depth = current_depth - 1\n            end\n        end\n        table.insert(results, max_depth)\n    end\n    return results\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = parse_nested_parens\n    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {2, 3, 1, 3})\n    lu.assertEquals(candidate('() (()) ((())) (((())))'), {1, 2, 3, 4})\n    lu.assertEquals(candidate('(()(())((())))'), {4})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_7","nl":"scn_Latn","pl":"lua","prompt":"- Filtrà na tàvula di input di stringhi sulu pi chiddi ca cuntèninu data substring -- >>> filter_by_substring({}, 'a')\n-- {}\n-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')\n-- {'abc', 'bacd', 'array'}\nlocal function filter_by_substring(strings, substring)\n","canonical_solution":"local function filter_by_substring(strings, substring)\n    local result = {}\n    for _, str in ipairs(strings) do\n        if string.find(str, substring) then\n            table.insert(result, str)\n        end\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_by_substring\n    lu.assertEquals(candidate({}, 'john'), {})\n    lu.assertEquals(candidate({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})\n    lu.assertEquals(candidate({'xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'}, 'xx'), {'xxx', 'aaaxxy', 'xxxAAA', 'xxx'})\n    lu.assertEquals(candidate({'grunt', 'trumpet', 'prune', 'gruesome'}, 'run'), {'grunt', 'prune'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_8","nl":"scn_Latn","pl":"lua","prompt":"- La summa vacanti avissi a èssiri uguali a 0 e lu pruduttu vacanti avissi a èssiri uguali a 1.- Pi na data tàvula di nùmmura interi, riturnari na tàvula ca cunsisti di na summa e di nu pruduttu di tutti li nùmmura interi di na tàvula. -- >>> sum_product({})\n-- {0, 1}\n-- >>> sum_product({1, 2, 3, 4})\n-- {10, 24}\nlocal function sum_product(numbers)\n","canonical_solution":"local function sum_product(numbers)\n    local sum = 0\n    local product = 1\n\n    for _, number in ipairs(numbers) do\n        sum = sum + number\n        product = product * number\n    end\n\n    return {sum, product}\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_product\n    lu.assertEquals(candidate({}), {0, 1})\n    lu.assertEquals(candidate({1, 1, 1}), {3, 1})\n    lu.assertEquals(candidate({100, 0}), {100, 0})\n    lu.assertEquals(candidate({3, 5, 7}), {15, 105})\n    lu.assertEquals(candidate({10}), {10, 10})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_9","nl":"scn_Latn","pl":"lua","prompt":"- nta la sequenza.- Da una tabella data di numeri interi, genera una tabella di l'elementu massimu di rotulu trovu finu à un mumentu datu -- >>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n-- {1, 2, 3, 3, 3, 4, 4}\nlocal function rolling_max(numbers)\n","canonical_solution":"local function rolling_max(numbers)\n    local result = {}\n    local max_so_far = numbers[1]\n    \n    for i = 1, #numbers do\n        if numbers[i] > max_so_far then\n            max_so_far = numbers[i]\n        end\n        table.insert(result, max_so_far)\n    end\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rolling_max\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 2, 3, 4})\n    lu.assertEquals(candidate({4, 3, 2, 1}), {4, 4, 4, 4})\n    lu.assertEquals(candidate({3, 2, 3, 100, 3}), {3, 3, 3, 100, 100})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_10","nl":"scn_Latn","pl":"lua","prompt":"- - Aggiungi a la fini dâ stringa lu cuntrariu di nu prefissu stringa ca veni prima dû suffissu palindromu. - - Trova lu postfix cchiù longu dâ stringa furnuta ca è nu palindromu. - L'idea di l'algoritmu è sèmplice: - Trova lu palindromu cchiù curtu ca accumincia cu na stringa furnuta. -- >>> make_palindrome('')\n-- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n-- 'catac'\nlocal function make_palindrome(string)\n","canonical_solution":"local function make_palindrome(s)\n    -- Function to check if a given string is a palindrome\n    local function is_palindrome(str)\n        local len = #str\n        for i = 1, len \/\/ 2 do\n            if str:sub(i, i) ~= str:sub(len - i + 1, len - i + 1) then\n                return false\n            end\n        end\n        return true\n    end\n\n    local len = #s\n    -- Find the longest postfix of the string that is a palindrome\n    for i = len, 1, -1 do\n        if is_palindrome(s:sub(i)) then\n            local prefix = s:sub(1, i - 1)\n            -- Reverse the prefix and append to the original string\n            return s .. prefix:reverse()\n        end\n    end\n\n    -- If the string is empty or no palindrome is found (shouldn't happen as \n    -- an empty or single character string is a palindrome), return the string itself\n    return s\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_11","nl":"scn_Latn","pl":"lua","prompt":"- Fate XOR binariu nantu à sti input è ritornu u risultatu ancu cum'è una stringa. - L'input sunnu dui stringhi a e b ca custituiscinu sulu di 1 e 0.-- >>> string_xor('010', '110')\n-- '100'\nlocal function string_xor(a, b)\n","canonical_solution":"local function string_xor(a, b)\n    local result = {}\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            table.insert(result, '0')\n        else\n            table.insert(result, '1')\n        end\n    end\n    return table.concat(result)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_12","nl":"scn_Latn","pl":"lua","prompt":"- stringhe di a stessa lunghezza. Ritorna null s'è a tavula d'entrata hè vacante. - Da a tavula di i fili, riturnà u più longu.-- >>> longest({})\n-- None\n-- >>> longest({'a', 'b', 'c'})\n-- 'a'\n-- >>> longest({'a', 'bb', 'ccc'})\n-- 'ccc'\nlocal function longest(strings)\n","canonical_solution":"local function longest(strings)\n    if #strings == 0 then\n        return nil\n    end\n\n    local max_len = 0\n    local longest_str = nil\n\n    for _, str in ipairs(strings) do\n        if #str > max_len then\n            max_len = #str\n            longest_str = str\n        end\n    end\n\n    return longest_str\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = longest\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({'x', 'y', 'z'}), 'x')\n    lu.assertEquals(candidate({'x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc'}), 'zzzz')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_13","nl":"scn_Latn","pl":"lua","prompt":"- Ritorna nu maggiuri cumuni divisori di dui nterni a e b -- >>> greatest_common_divisor(3, 5)\n-- 1\n-- >>> greatest_common_divisor(25, 15)\n-- 5\nlocal function greatest_common_divisor(a, b)\n","canonical_solution":"local function greatest_common_divisor(a, b)\n    while b ~= 0 do\n        local temp = b\n        b = a % b\n        a = temp\n    end\n    return a\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = greatest_common_divisor\n    lu.assertEquals(candidate(3, 7), 1)\n    lu.assertEquals(candidate(10, 15), 5)\n    lu.assertEquals(candidate(49, 14), 7)\n    lu.assertEquals(candidate(144, 60), 12)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_14","nl":"scn_Latn","pl":"lua","prompt":"- Tabella di ritornu di tutti i prefissi da u più cortu à u più longu di a stringa d'entrata -- >>> all_prefixes('abc')\n-- {'a', 'ab', 'abc'}\nlocal function all_prefixes(string)\n","canonical_solution":"local function all_prefixes(string)\n    local prefixes = {}\n    for i = 1, #string do\n        table.insert(prefixes, string:sub(1, i))\n    end\n    return prefixes\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = all_prefixes\n    lu.assertEquals(candidate(''), {})\n    lu.assertEquals(candidate('asdfgh'), {'a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'})\n    lu.assertEquals(candidate('WWW'), {'W', 'WW', 'WWW'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_15","nl":"scn_Latn","pl":"lua","prompt":"- Rinnisci na stringa chi cunteni nummari dilimitati di spazziu chi cumincia da 0 nzinu a n nclusivi. -- >>> string_sequence(0)\n-- '0'\n-- >>> string_sequence(5)\n-- '0 1 2 3 4 5'\nlocal function string_sequence(n)\n","canonical_solution":"local function string_sequence(n)\n    local result = {}\n    for i = 0, n do\n        table.insert(result, tostring(i))\n    end\n    return table.concat(result, \" \")\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_sequence\n    lu.assertEquals(candidate(0), '0')\n    lu.assertEquals(candidate(3), '0 1 2 3')\n    lu.assertEquals(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_16","nl":"scn_Latn","pl":"lua","prompt":"- Datu na stringa, scuprìri di quanti caràttiri distinti (indipendentamenti dâ cassa) si cumponi -- >>> count_distinct_characters('xyzXYZ')\n-- 3\n-- >>> count_distinct_characters('Jerry')\n-- 4\nlocal function count_distinct_characters(string)\n","canonical_solution":"local function count_distinct_characters(string)\n    local char_set = {}\n    local lower_string = string:lower()\n    for i = 1, #lower_string do\n        local char = lower_string:sub(i, i)\n        char_set[char] = true\n    end\n    local count = 0\n    for _ in pairs(char_set) do\n        count = count + 1\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_distinct_characters\n    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('abcde'), 5)\n    lu.assertEquals(candidate('abcdecadeCADE'), 5)\n    lu.assertEquals(candidate('aaaaAAAAaaaa'), 1)\n    lu.assertEquals(candidate('Jerry jERRY JeRRRY'), 5)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_17","nl":"scn_Latn","pl":"lua","prompt":"- 'Ncece' - 'na nota 'e quatrino, dura na battuta.- 'o 'ncecece' - mezza nota, dura du' battiti- 'O' - nota intera, dura quattru battiti - Eccu na leggenda:- nun è l'ùrtimu.- U vostru compitu è di analizzà sta stringa è di riturnà a tavula di numeri interi currispundenti à quantu battiti fa ognunu - L'ingressu di sta funzioni è na stringa ca rapprisenta li noti musicali nta nu furmatu ASCII spiciali.-- >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n-- {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nlocal function parse_music(music_string)\n","canonical_solution":"local function parse_music(music_string)\n    local beats = {}\n    for note in music_string:gmatch(\"%S+\") do\n        if note == 'o' then\n            table.insert(beats, 4)\n        elseif note == 'o|' then\n            table.insert(beats, 2)\n        elseif note == '.|' then\n            table.insert(beats, 1)\n        end\n    end\n    return beats\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = parse_music\n    lu.assertEquals(candidate(''), {})\n    lu.assertEquals(candidate('o o o o'), {4, 4, 4, 4})\n    lu.assertEquals(candidate('.| .| .| .|'), {1, 1, 1, 1})\n    lu.assertEquals(candidate('o| o| .| .| o o o o'), {2, 2, 1, 1, 4, 4, 4, 4})\n    lu.assertEquals(candidate('o| .| o| .| o o| o o|'), {2, 1, 2, 1, 4, 2, 4, 2})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_18","nl":"scn_Latn","pl":"lua","prompt":"- Trova quantu voti na data sutta-stringa pò èssiri attruvata ntâ stringa urigginaria.-- >>> how_many_times('', 'a')\n-- 0\n-- >>> how_many_times('aaa', 'a')\n-- 3\n-- >>> how_many_times('aaaa', 'aa')\n-- 3\nlocal function how_many_times(string, substring)\n","canonical_solution":"local function how_many_times(string, substring)\n    if substring == '' then return 0 end\n    local count = 0\n    local start = 1\n\n    while true do\n        local found = string:find(substring, start, true)\n        if not found then\n            break\n        end\n        count = count + 1\n        start = found + 1\n    end\n\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = how_many_times\n    lu.assertEquals(candidate('', 'x'), 0)\n    lu.assertEquals(candidate('xyxyxyx', 'x'), 4)\n    lu.assertEquals(candidate('cacacacac', 'cac'), 4)\n    lu.assertEquals(candidate('john doe', 'john'), 1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_19","nl":"scn_Latn","pl":"lua","prompt":"- Rinniri la stringa cu li nummari ordinati da lu cchiù nicu a lu cchiù granni - Li scelte validi sunnu \"zero\", \"uno\", \"dui\", \"tre\", \"quattru\", \"cinque\", \"sei\", \"sette\", \"ottu\" e \"nove\". - L'input è na stringa di numirali dilimitati di spazziu da \"zero\" a \"nove\".-- >>> sort_numbers('three one five')\n-- 'one three five'\nlocal function sort_numbers(numbers)\n","canonical_solution":"local function sort_numbers(numbers)\n    local number_map = {\n        zero = 0,\n        one = 1,\n        two = 2,\n        three = 3,\n        four = 4,\n        five = 5,\n        six = 6,\n        seven = 7,\n        eight = 8,\n        nine = 9\n    }\n\n    local number_names = {\n        [0] = 'zero',\n        [1] = 'one',\n        [2] = 'two',\n        [3] = 'three',\n        [4] = 'four',\n        [5] = 'five',\n        [6] = 'six',\n        [7] = 'seven',\n        [8] = 'eight',\n        [9] = 'nine'\n    }\n\n    local words = {}\n    for word in numbers:gmatch(\"%S+\") do\n        table.insert(words, word)\n    end\n\n    table.sort(words, function(a, b)\n        return number_map[a] < number_map[b]\n    end)\n\n    local sorted_numbers = {}\n    for _, word in ipairs(words) do\n        table.insert(sorted_numbers, number_names[number_map[word]])\n    end\n\n    return table.concat(sorted_numbers, \" \")\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_numbers\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('three'), 'three')\n    lu.assertEquals(candidate('three five nine'), 'three five nine')\n    lu.assertEquals(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')\n    lu.assertEquals(candidate('six five four three two one zero'), 'zero one two three four five six')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_20","nl":"scn_Latn","pl":"lua","prompt":"- altri e li rimetti in ordine (numeru cchiù nicu, numeru cchiù granni).- Da una tavula di numeri furnita (di lunghezza almenu dui) selezziunate è restituite dui chì sò i più vicini à ognunu -- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n-- {2.0, 2.2}\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n-- {2.0, 2.0}\nlocal function find_closest_elements(numbers)\n","canonical_solution":"local function find_closest_elements(numbers)\n    table.sort(numbers)\n    local min_diff = math.huge\n    local result = {}\n\n    for i = 1, #numbers - 1 do\n        local diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff then\n            min_diff = diff\n            result = {numbers[i], numbers[i + 1]}\n        end\n    end\n\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_closest_elements\n    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), {3.9, 4.0})\n    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}), {5.0, 5.9})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), {2.0, 2.2})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), {2.0, 2.0})\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}), {2.2, 3.1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_21","nl":"scn_Latn","pl":"lua","prompt":"- accussì ca lu cchiù nicu nummaru addiventa 0 e lu cchiù granni addiventa 1 - Data na tàvula di nùmmura (di armenu dui elementi), appricà na trasfurmazzioni liniari a dda tàvula,-- >>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n-- {0.0, 0.25, 0.5, 0.75, 1.0}\nlocal function rescale_to_unit(numbers)\n","canonical_solution":"local function rescale_to_unit(numbers)\n    local min_val = math.huge\n    local max_val = -math.huge\n\n    -- Find the min and max values in the table\n    for _, num in ipairs(numbers) do\n        if num < min_val then\n            min_val = num\n        end\n        if num > max_val then\n            max_val = num\n        end\n    end\n\n    local scale = max_val - min_val\n\n    -- Apply the transformation\n    local transformed = {}\n    for i, num in ipairs(numbers) do\n        transformed[i] = (num - min_val) \/ scale\n    end\n\n    return transformed\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rescale_to_unit\n    lu.assertEquals(candidate({2.0, 49.9}), {0.0, 1.0})\n    lu.assertEquals(candidate({100.0, 49.9}), {1.0, 0.0})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}), {0.0, 0.25, 0.5, 0.75, 1.0})\n    lu.assertEquals(candidate({2.0, 1.0, 5.0, 3.0, 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\n    lu.assertEquals(candidate({12.0, 11.0, 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_22","nl":"scn_Latn","pl":"lua","prompt":"- Filtru datu tabella di ogni valori di luoghi sulu pi nùmmura interi -- >>> filter_integers({'a', 3.14, 5})\n-- {5}\n-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})\n-- {1, 2, 3}\nlocal function filter_integers(values)\n","canonical_solution":"local function filter_integers(values)\n    local result = {}\n    for _, value in ipairs(values) do\n        if type(value) == \"number\" and math.type(value) == \"integer\" then\n            table.insert(result, value)\n        end\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_integers\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({4, {}, {}, 23.2, 9, 'adasd'}), {4, 9})\n    lu.assertEquals(candidate({3, 'c', 3, 3, 'a', 'b'}), {3, 3, 3})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_23","nl":"scn_Latn","pl":"lua","prompt":"- Ritornu lunghizza di data string -- >>> strlen('')\n-- 0\n-- >>> strlen('abc')\n-- 3\nlocal function strlen(string)\n","canonical_solution":"local function strlen(string)\n    return #string\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = strlen\n    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('x'), 1)\n    lu.assertEquals(candidate('asdasnakj'), 9)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_24","nl":"scn_Latn","pl":"lua","prompt":"- Pi nu datu nùmmuru n, trova lu nùmmuru cchiù granni ca si dividi n, cchiù nicu di n -- >>> largest_divisor(15)\n-- 5\nlocal function largest_divisor(n)\n","canonical_solution":"local function largest_divisor(n)\n    for i = n - 1, 1, -1 do\n        if n % i == 0 then\n            return i\n        end\n    end\n    return nil -- In case no divisor is found, though this will not happen for n > 1\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_divisor\n    lu.assertEquals(candidate(3), 1)\n    lu.assertEquals(candidate(7), 1)\n    lu.assertEquals(candidate(10), 5)\n    lu.assertEquals(candidate(100), 50)\n    lu.assertEquals(candidate(49), 7)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_25","nl":"scn_Latn","pl":"lua","prompt":"- U numaru d'entrata deve esse uguale à u pruduttu di tutti i fattori - Ogni fatturi deve esse prisentatu u numeru di volte chì currisponde à u numeru di volte chì si prisenta in a fatturazione.- Tabella di ritornu di fatturi primi di un datu nùmmaru intiru in ordine da u più chjucu à u più grande. -- >>> factorize(8)\n-- {2, 2, 2}\n-- >>> factorize(25)\n-- {5, 5}\n-- >>> factorize(70)\n-- {2, 5, 7}\nlocal function factorize(n)\n","canonical_solution":"local function factorize(n)\n    local factors = {}\n    local divisor = 2\n    while n > 1 do\n        while n % divisor == 0 do\n            table.insert(factors, divisor)\n            n = n \/ divisor\n        end\n        divisor = divisor + 1\n    end\n    return factors\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = factorize\n    lu.assertEquals(candidate(2), {2})\n    lu.assertEquals(candidate(4), {2, 2})\n    lu.assertEquals(candidate(8), {2, 2, 2})\n    lu.assertEquals(candidate(57), {3, 19})\n    lu.assertEquals(candidate(3249), {3, 3, 19, 19})\n    lu.assertEquals(candidate(185193), {3, 3, 3, 19, 19, 19})\n    lu.assertEquals(candidate(20577), {3, 19, 19, 19})\n    lu.assertEquals(candidate(18), {2, 3, 3})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_26","nl":"scn_Latn","pl":"lua","prompt":"- Mantene l'ordine di l'elementi lasciati listessi à quelli di l'ingressu.- Da una tavula di numeri interi, rimuovi tutti l'elementi chì si trovanu più di una volta.-- >>> remove_duplicates({1, 2, 3, 2, 4})\n-- {1, 3, 4}\nlocal function remove_duplicates(numbers)\n","canonical_solution":"local function remove_duplicates(numbers)\n    local counts = {}\n    -- Count occurrences of each element\n    for _, num in ipairs(numbers) do\n        counts[num] = (counts[num] or 0) + 1\n    end\n    -- Collect elements that occur exactly once\n    local result = {}\n    for _, num in ipairs(numbers) do\n        if counts[num] == 1 then\n            table.insert(result, num)\n        end\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = remove_duplicates\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 2, 3, 4})\n    lu.assertEquals(candidate({1, 2, 3, 2, 4, 3, 5}), {1, 4, 5})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_27","nl":"scn_Latn","pl":"lua","prompt":"- Pi na data stringa, trasfurmari li caratteri minuri a maiusculi e li maiusculi a minuri. -- >>> flip_case('Hello')\n-- 'hELLO'\nlocal function flip_case(string)\n","canonical_solution":"local function flip_case(str)\n    return (str:gsub(\"%a\", function(c)\n        if c:lower() == c then\n            return c:upper()\n        else\n            return c:lower()\n        end\n    end))\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = flip_case\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('Hello!'), 'hELLO!')\n    lu.assertEquals(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_28","nl":"scn_Latn","pl":"lua","prompt":"- Cuntinatu a tavula di stringhi 'n na sula stringha -- >>> concatenate({})\n-- ''\n-- >>> concatenate({'a', 'b', 'c'})\n-- 'abc'\nlocal function concatenate(strings)\n","canonical_solution":"local function concatenate(strings)\n    return table.concat(strings, \"\")\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = concatenate\n    lu.assertEquals(candidate({}), '')\n    lu.assertEquals(candidate({'x', 'y', 'z'}), 'xyz')\n    lu.assertEquals(candidate({'x', 'y', 'z', 'w', 'k'}), 'xyzwk')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_29","nl":"scn_Latn","pl":"lua","prompt":"- Filtrà una tavula d'ingressu di stringhe solu per quelli chì cumincianu cù un prefissu datu. -- >>> filter_by_prefix({}, 'a')\n-- {}\n-- >>> filter_by_prefix({'abc', 'bcd', 'cde', 'array'}, 'a')\n-- {'abc', 'array'}\nlocal function filter_by_prefix(strings, prefix)\n","canonical_solution":"local function filter_by_prefix(strings, prefix)\n    local result = {}\n    for _, str in ipairs(strings) do\n        if str:sub(1, #prefix) == prefix then\n            table.insert(result, str)\n        end\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_by_prefix\n    lu.assertEquals(candidate({}, 'john'), {})\n    lu.assertEquals(candidate({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_30","nl":"scn_Latn","pl":"lua","prompt":"- Rinnirizza sulu nummari pusitivi ntâ tàvula.-- >>> get_positive({-1, 2, -4, 5, 6})\n-- {2, 5, 6}\n-- >>> get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n-- {5, 3, 2, 3, 9, 123, 1}\nlocal function get_positive(l)\n","canonical_solution":"local function get_positive(l)\n    local positives = {}\n    for _, v in ipairs(l) do\n        if v > 0 then\n            table.insert(positives, v)\n        end\n    end\n    return positives\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_positive\n    lu.assertEquals(candidate({-1, -2, 4, 5, 6}), {4, 5, 6})\n    lu.assertEquals(candidate({5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), {5, 3, 2, 3, 3, 9, 123, 1})\n    lu.assertEquals(candidate({-1, -2}), {})\n    lu.assertEquals(candidate({}), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_31","nl":"scn_Latn","pl":"lua","prompt":"- Ritorna veru si nu nùmmaru datu è primu, e falsu altrimenti. -- >>> is_prime(6)\n-- false\n-- >>> is_prime(101)\n-- true\n-- >>> is_prime(11)\n-- true\n-- >>> is_prime(13441)\n-- true\n-- >>> is_prime(61)\n-- true\n-- >>> is_prime(4)\n-- false\n-- >>> is_prime(1)\n-- false\nlocal function is_prime(n)\n","canonical_solution":"local function is_prime(n)\n    if n <= 1 then\n        return false\n    end\n    if n <= 3 then\n        return true\n    end\n    if n % 2 == 0 or n % 3 == 0 then\n        return false\n    end\n    local i = 5\n    while i * i <= n do\n        if n % i == 0 or n % (i + 2) == 0 then\n            return false\n        end\n        i = i + 6\n    end\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_prime\n    lu.assertEquals(candidate(6), false)\n    lu.assertEquals(candidate(101), true)\n    lu.assertEquals(candidate(11), true)\n    lu.assertEquals(candidate(13441), true)\n    lu.assertEquals(candidate(61), true)\n    lu.assertEquals(candidate(4), false)\n    lu.assertEquals(candidate(1), false)\n    lu.assertEquals(candidate(5), true)\n    lu.assertEquals(candidate(11), true)\n    lu.assertEquals(candidate(17), true)\n    lu.assertEquals(candidate(85), false)\n    lu.assertEquals(candidate(77), false)\n    lu.assertEquals(candidate(255379), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_33","nl":"scn_Latn","pl":"lua","prompt":"- à i valori di l'indici currispundenti, ma ordinati.- l' è idènticu a l ntê indici ca nun sunnu divisibili pi tri, mentri li sò valuri ntê indici ca sunnu divisibili pi tri sunnu uguali - Sta funzioni pigghia na tàvula l e torna na tàvula l' tali ca -- >>> sort_third({1, 2, 3})\n-- {1, 2, 3}\n-- >>> sort_third({5, 6, 3, 4, 8, 9, 2})\n-- {2, 6, 3, 4, 8, 9, 5}\nlocal function sort_third(l)\n","canonical_solution":"local function sort_third(l)\n    local divisible_by_three = {}\n    \n    -- Collect elements at indices divisible by three\n    for i = 3, #l, 3 do\n        table.insert(divisible_by_three, l[i])\n    end\n\n    -- Sort collected elements\n    table.sort(divisible_by_three)\n    \n    -- Create a copy of the original table\n    local l_prime = {}\n    for i = 1, #l do\n        l_prime[i] = l[i]\n    end\n\n    -- Replace elements at indices divisible by three with sorted elements\n    local sorted_index = 1\n    for i = 3, #l, 3 do\n        l_prime[i] = divisible_by_three[sorted_index]\n        sorted_index = sorted_index + 1\n    end\n\n    return l_prime\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_third\n    lu.assertEquals(candidate({5, 6, 3, 4, 8, 9, 2}), {2, 6, 3, 4, 8, 9, 5})\n    lu.assertEquals(candidate({5, 8, 3, 4, 6, 9, 2}), {2, 8, 3, 4, 6, 9, 5})\n    lu.assertEquals(candidate({5, 6, 9, 4, 8, 3, 2}), {2, 6, 9, 4, 8, 3, 5})\n    lu.assertEquals(candidate({5, 6, 3, 4, 8, 9, 2, 1}), {2, 6, 3, 4, 8, 9, 5, 1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_34","nl":"scn_Latn","pl":"lua","prompt":"- Rinnirizza l'elementi urdinati ùnici nta na tàvula -- >>> unique({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {0, 2, 3, 5, 9, 123}\nlocal function unique(l)\n","canonical_solution":"local function unique(l)\n    local seen = {}\n    local result = {}\n    \n    for _, value in ipairs(l) do\n        if not seen[value] then\n            table.insert(result, value)\n            seen[value] = true\n        end\n    end\n    \n    table.sort(result)\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = unique\n    lu.assertEquals(candidate({5, 3, 5, 2, 3, 3, 9, 0, 123}), {0, 2, 3, 5, 9, 123})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_35","nl":"scn_Latn","pl":"lua","prompt":"- Ritorna l'elementu massimu in a tavula. -- >>> max_element({1, 2, 3})\n-- 3\n-- >>> max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n-- 123\nlocal function max_element(l)\n","canonical_solution":"local function max_element(l)\n    local max = l[1]\n    for i = 2, #l do\n        if l[i] > max then\n            max = l[i]\n        end\n    end\n    return max\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_element\n    lu.assertEquals(candidate({1, 2, 3}), 3)\n    lu.assertEquals(candidate({5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), 124)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_36","nl":"scn_Latn","pl":"lua","prompt":"- Rinnirizza lu nùmmuru di voti ca la cifra 7 appari nta nùmmura interi minuri di n ca sunnu divisibili pi 11 o 13. -- >>> fizz_buzz(50)\n-- 0\n-- >>> fizz_buzz(78)\n-- 2\n-- >>> fizz_buzz(79)\n-- 3\nlocal function fizz_buzz(n)\n","canonical_solution":"local function fizz_buzz(n)\n    local count = 0\n    for i = 1, n - 1 do\n        if i % 11 == 0 or i % 13 == 0 then\n            local str_i = tostring(i)\n            if str_i:find(\"7\") then\n                count = count + 1\n            end\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fizz_buzz\n    lu.assertEquals(candidate(50), 0)\n    lu.assertEquals(candidate(78), 2)\n    lu.assertEquals(candidate(79), 3)\n    lu.assertEquals(candidate(100), 3)\n    lu.assertEquals(candidate(200), 6)\n    lu.assertEquals(candidate(4000), 192)\n    lu.assertEquals(candidate(10000), 639)\n    lu.assertEquals(candidate(100000), 8026)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_37","nl":"scn_Latn","pl":"lua","prompt":"- a li valuri di l'indici pari, ma ordinati.- l' è idènticu a l 'n l' indici dispari, mentri li so valori a l' indici pari sunnu uguali - Sta funzioni pigghia na tàvula l e torna na tàvula l' tali ca -- >>> sort_even({1, 2, 3})\n-- {1, 2, 3}\n-- >>> sort_even({5, 6, 3, 4})\n-- {3, 6, 5, 4}\nlocal function sort_even(l)\n","canonical_solution":"local function sort_even(l)\n    -- Extract the even indexed elements\n    local even_elements = {}\n    for i = 2, #l, 2 do\n        table.insert(even_elements, l[i])\n    end\n\n    -- Sort the extracted even elements\n    table.sort(even_elements)\n\n    -- Create a new table for the result and fill it with the appropriate elements\n    local result = {}\n    local even_index = 1\n    for i = 1, #l do\n        if i % 2 == 0 then\n            result[i] = even_elements[even_index]\n            even_index = even_index + 1\n        else\n            result[i] = l[i]\n        end\n    end\n\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_even\n    lu.assertEquals(candidate({1, 2, 3}), {1, 2, 3})\n    lu.assertEquals(candidate({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123})\n    lu.assertEquals(candidate({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_39","nl":"scn_Latn","pl":"lua","prompt":"- prime_fib torna nu nùmmuru n-esimu ca è nu nùmmuru di Fibonacci e è puru primu. -- >>> prime_fib(1)\n-- 2\n-- >>> prime_fib(2)\n-- 3\n-- >>> prime_fib(3)\n-- 5\n-- >>> prime_fib(4)\n-- 13\n-- >>> prime_fib(5)\n-- 89\nlocal function prime_fib(n)\n","canonical_solution":"local function is_prime(num)\n    if num <= 1 then return false end\n    if num <= 3 then return true end\n    if num % 2 == 0 or num % 3 == 0 then return false end\n    local i = 5\n    while i * i <= num do\n        if num % i == 0 or num % (i + 2) == 0 then\n            return false\n        end\n        i = i + 6\n    end\n    return true\nend\n\nlocal function fibonacci()\n    local a, b = 0, 1\n    return function()\n        local temp = a\n        a, b = b, a + b\n        return temp\n    end\nend\n\nlocal function prime_fib(n)\n    local count = 0\n    local fib_gen = fibonacci()\n    while true do\n        local fib_num = fib_gen()\n        if is_prime(fib_num) then\n            count = count + 1\n            if count == n then\n                return fib_num\n            end\n        end\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = prime_fib\n    lu.assertEquals(candidate(1), 2)\n    lu.assertEquals(candidate(2), 3)\n    lu.assertEquals(candidate(3), 5)\n    lu.assertEquals(candidate(4), 13)\n    lu.assertEquals(candidate(5), 89)\n    lu.assertEquals(candidate(6), 233)\n    lu.assertEquals(candidate(7), 1597)\n    lu.assertEquals(candidate(8), 28657)\n    lu.assertEquals(candidate(9), 514229)\n    lu.assertEquals(candidate(10), 433494437)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_40","nl":"scn_Latn","pl":"lua","prompt":"- summa a zeru, e falsu altrimenti. - torna veru si ci sunnu tri elementi distinti nta la tàvula ca - triples_sum_to_zero pigghia na tavula di nùmmura interi comu input. -- >>> triples_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> triples_sum_to_zero({1, 3, -2, 1})\n-- true\n-- >>> triples_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})\n-- true\n-- >>> triples_sum_to_zero({1})\n-- false\nlocal function triples_sum_to_zero(l)\n","canonical_solution":"local function triples_sum_to_zero(l)\n    table.sort(l)\n    for i = 1, #l - 2 do\n        local a = l[i]\n        local left = i + 1\n        local right = #l\n        while left < right do\n            local b = l[left]\n            local c = l[right]\n            local sum = a + b + c\n            if sum == 0 then\n                return true\n            elseif sum < 0 then\n                left = left + 1\n            else\n                right = right - 1\n            end\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = triples_sum_to_zero\n    lu.assertEquals(candidate({1, 3, 5, 0}), false)\n    lu.assertEquals(candidate({1, 3, 5, -1}), false)\n    lu.assertEquals(candidate({1, 3, -2, 1}), true)\n    lu.assertEquals(candidate({1, 2, 3, 7}), false)\n    lu.assertEquals(candidate({1, 2, 5, 7}), false)\n    lu.assertEquals(candidate({2, 4, -5, 3, 9, 7}), true)\n    lu.assertEquals(candidate({1}), false)\n    lu.assertEquals(candidate({1, 3, 5, -100}), false)\n    lu.assertEquals(candidate({100, 3, 5, -100}), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_41","nl":"scn_Latn","pl":"lua","prompt":"- Sta funzioni trasmetti lu nùmmiru di tali collisioni. - nta la so traggitoria comu si nun si culligassiru.- Ma i carusi sunnu forti e forti, e pi chistu cuntinuanu a muvirisi.- quannu na machina ca si sposta da manca a destra s'infronta a na machina ca si sposta da destra a manca.Tutti li màchini si muovunu â stissa vilucitati.- si nni vannu di destra a sinistra.- n vitturi sò guidà à manca à diritta; simultaneamente, un gruppu diversu di n vitturi - Immagina na strata ca è na linia perfetta dritta e longa all'infinitu.local function car_race_collision(n)\n","canonical_solution":"local function car_race_collision(n)\n    -- Since each car from the left to right collides with each car from the right to left,\n    -- the number of collisions will be n*n.\n    return n * n\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = car_race_collision\n    lu.assertEquals(candidate(2), 4)\n    lu.assertEquals(candidate(3), 9)\n    lu.assertEquals(candidate(4), 16)\n    lu.assertEquals(candidate(8), 64)\n    lu.assertEquals(candidate(10), 100)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_42","nl":"scn_Latn","pl":"lua","prompt":"- Tabella di ritornu cù elementi incrementati di 1. -- >>> incr_list({1, 2, 3})\n-- {2, 3, 4}\n-- >>> incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {6, 4, 6, 3, 4, 4, 10, 1, 124}\nlocal function incr_list(l)\n","canonical_solution":"local function incr_list(l)\n    local result = {}\n    for i = 1, #l do\n        result[i] = l[i] + 1\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = incr_list\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({3, 2, 1}), {4, 3, 2})\n    lu.assertEquals(candidate({5, 2, 5, 2, 3, 3, 9, 0, 123}), {6, 3, 6, 3, 4, 4, 10, 1, 124})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_43","nl":"scn_Latn","pl":"lua","prompt":"- summa a zeru, e falsu altrimenti. - torna veru si ci sunnu dui elementi distinti nta la tàvula ca - pairs_sum_to_zero pigghia na tavula di nùmmura interi comu input. -- >>> pairs_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> pairs_sum_to_zero({1, 3, -2, 1})\n-- false\n-- >>> pairs_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})\n-- true\n-- >>> pairs_sum_to_zero({1})\n-- false\nlocal function pairs_sum_to_zero(l)\n","canonical_solution":"local function pairs_sum_to_zero(l)\n    local seen = {}\n    for _, value in ipairs(l) do\n        if seen[-value] then\n            return true\n        end\n        seen[value] = true\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = pairs_sum_to_zero\n    lu.assertEquals(candidate({1, 3, 5, 0}), false)\n    lu.assertEquals(candidate({1, 3, -2, 1}), false)\n    lu.assertEquals(candidate({1, 2, 3, 7}), false)\n    lu.assertEquals(candidate({2, 4, -5, 3, 5, 7}), true)\n    lu.assertEquals(candidate({1}), false)\n    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 30}), true)\n    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 31}), true)\n    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 30}), false)\n    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 31}), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_44","nl":"scn_Latn","pl":"lua","prompt":"- i numari di basi sunnu menu di 10.- riprisentazioni stringa ritornu doppu la cunversione. - Cambia a basa numerica di u numeru d'entrata x à a basa. -- >>> change_base(8, 3)\n-- '22'\n-- >>> change_base(8, 2)\n-- '1000'\n-- >>> change_base(7, 2)\n-- '111'\nlocal function change_base(x, base)\n","canonical_solution":"local function change_base(x, base)\n    if base < 2 or base > 9 then\n        error(\"Base must be between 2 and 9\")\n    end\n\n    if x == 0 then\n        return \"0\"\n    end\n\n    local result = \"\"\n    while x > 0 do\n        local remainder = x % base\n        result = tostring(remainder) .. result\n        x = math.floor(x \/ base)\n    end\n\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = change_base\n    lu.assertEquals(candidate(8, 3), '22')\n    lu.assertEquals(candidate(9, 3), '100')\n    lu.assertEquals(candidate(234, 2), '11101010')\n    lu.assertEquals(candidate(16, 2), '10000')\n    lu.assertEquals(candidate(8, 2), '1000')\n    lu.assertEquals(candidate(7, 2), '111')\n    lu.assertEquals(candidate(2, 3), '2')\n    lu.assertEquals(candidate(3, 4), '3')\n    lu.assertEquals(candidate(4, 5), '4')\n    lu.assertEquals(candidate(5, 6), '5')\n    lu.assertEquals(candidate(6, 7), '6')\n    lu.assertEquals(candidate(7, 8), '7')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_45","nl":"scn_Latn","pl":"lua","prompt":"- Datu la lunghizza di nu latu e l'area di ritornu di nu triàngulu.-- >>> triangle_area(5, 3)\n-- 7.5\nlocal function triangle_area(a, h)\n","canonical_solution":"local function triangle_area(a, h)\n    return 0.5 * a * h\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = triangle_area\n    lu.assertEquals(candidate(5, 3), 7.5)\n    lu.assertEquals(candidate(2, 2), 2.0)\n    lu.assertEquals(candidate(10, 8), 40.0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_46","nl":"scn_Latn","pl":"lua","prompt":"- Scrivite una funzione per calculà in modu efficace l'elementu n-esimu di a sequenza numerica fib4.- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). - fib4(3) -> 0 - fib4(2) -> 2 - fib4(1) -> 0 - fib4(0) -> 0 - La sequenza numerica Fib4 è na sequenza simili a la sequenza di Fibbonacci ca è difinuta comu siguenti: -- >>> fib4(5)\n-- 4\n-- >>> fib4(6)\n-- 8\n-- >>> fib4(7)\n-- 14\nlocal function fib4(n)\n","canonical_solution":"local function fib4(n)\n    if n == 0 then return 0 end\n    if n == 1 then return 0 end\n    if n == 2 then return 2 end\n    if n == 3 then return 0 end\n\n    local a, b, c, d = 0, 0, 2, 0\n\n    for i = 4, n do\n        local temp = a + b + c + d\n        a, b, c, d = b, c, d, temp\n    end\n\n    return d\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fib4\n    lu.assertEquals(candidate(5), 4)\n    lu.assertEquals(candidate(8), 28)\n    lu.assertEquals(candidate(10), 104)\n    lu.assertEquals(candidate(12), 386)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_47","nl":"scn_Latn","pl":"lua","prompt":"- Ritornu mediana di l'elementi di a tavula l. -- >>> median({3, 1, 2, 4, 5})\n-- 3\n-- >>> median({-10, 4, 6, 1000, 10, 20})\n-- 15.0\nlocal function median(l)\n","canonical_solution":"local function median(l)\n    table.sort(l)\n    local n = #l\n    if n % 2 == 1 then\n        return l[(n + 1) \/ 2]\n    else\n        local mid1 = n \/ 2\n        local mid2 = mid1 + 1\n        return (l[mid1] + l[mid2]) \/ 2\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = median\n    lu.assertEquals(candidate({3, 1, 2, 4, 5}), 3)\n    lu.assertEquals(candidate({-10, 4, 6, 1000, 10, 20}), 8.0)\n    lu.assertEquals(candidate({5}), 5)\n    lu.assertEquals(candidate({6, 5}), 5.5)\n    lu.assertEquals(candidate({8, 1, 3, 9, 9, 2, 7}), 7)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_48","nl":"scn_Latn","pl":"lua","prompt":"- Verifica si na stringa data è nu palindromu -- >>> is_palindrome('')\n-- true\n-- >>> is_palindrome('aba')\n-- true\n-- >>> is_palindrome('aaaaa')\n-- true\n-- >>> is_palindrome('zbcd')\n-- false\nlocal function is_palindrome(text)\n","canonical_solution":"local function is_palindrome(text)\n    return text == string.reverse(text)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_palindrome\n    lu.assertEquals(candidate(''), true)\n    lu.assertEquals(candidate('aba'), true)\n    lu.assertEquals(candidate('aaaaa'), true)\n    lu.assertEquals(candidate('zbcd'), false)\n    lu.assertEquals(candidate('xywyx'), true)\n    lu.assertEquals(candidate('xywyz'), false)\n    lu.assertEquals(candidate('xywzx'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_49","nl":"scn_Latn","pl":"lua","prompt":"- Ritorna 2^n modulo p (s'avvicina di i numeri).-- >>> modp(3, 5)\n-- 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n-- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n","canonical_solution":"local function modp(n, p)\n    return (2^n) % p\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_51","nl":"scn_Latn","pl":"lua","prompt":"- remove_vowels è na funzioni ca pigghia stringhi e torna stringhi senza vucali. -- >>> remove_vowels('')\n-- ''\n-- >>> remove_vowels('abcdef')\n-- 'bcdf'\n-- >>> remove_vowels('aaaaa')\n-- ''\n-- >>> remove_vowels('aaBAA')\n-- 'B'\n-- >>> remove_vowels('zbcd')\n-- 'zbcd'\nlocal function remove_vowels(text)\n","canonical_solution":"local function remove_vowels(text)\n    return text:gsub(\"[aeiouAEIOU]\", \"\")\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = remove_vowels\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('abcdef\\nghijklm'), 'bcdf\\nghjklm')\n    lu.assertEquals(candidate('fedcba'), 'fdcb')\n    lu.assertEquals(candidate('eeeee'), '')\n    lu.assertEquals(candidate('acBAA'), 'cB')\n    lu.assertEquals(candidate('EcBOO'), 'cB')\n    lu.assertEquals(candidate('ybcd'), 'ybcd')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_52","nl":"scn_Latn","pl":"lua","prompt":"- Ritorna veru si tutti i numari di la tavula l sunnu sutta la soglia t. -- >>> below_threshold({1, 2, 4, 10}, 100)\n-- true\n-- >>> below_threshold({1, 20, 4, 10}, 5)\n-- false\nlocal function below_threshold(l, t)\n","canonical_solution":"local function below_threshold(l, t)\n    for _, number in ipairs(l) do\n        if number >= t then\n            return false\n        end\n    end\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = below_threshold\n    lu.assertEquals(candidate({1, 2, 4, 10}, 100), true)\n    lu.assertEquals(candidate({1, 20, 4, 10}, 5), false)\n    lu.assertEquals(candidate({1, 20, 4, 10}, 21), true)\n    lu.assertEquals(candidate({1, 20, 4, 10}, 22), true)\n    lu.assertEquals(candidate({1, 8, 4, 10}, 11), true)\n    lu.assertEquals(candidate({1, 8, 4, 10}, 10), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_53","nl":"scn_Latn","pl":"lua","prompt":"- Aggiungi dui numari x e y -- >>> add(2, 3)\n-- 5\n-- >>> add(5, 7)\n-- 12\nlocal function add(x, y)\n","canonical_solution":"local function add(x, y)\n    return x + y\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = add\n    lu.assertEquals(candidate(0, 1), 1)\n    lu.assertEquals(candidate(1, 0), 1)\n    lu.assertEquals(candidate(2, 3), 5)\n    lu.assertEquals(candidate(5, 7), 12)\n    lu.assertEquals(candidate(7, 5), 12)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_54","nl":"scn_Latn","pl":"lua","prompt":"- Verificà si duie parolle anu i listessi caratteri. -- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n-- true\n-- >>> same_chars('abcd', 'dddddddabc')\n-- true\n-- >>> same_chars('dddddddabc', 'abcd')\n-- true\n-- >>> same_chars('eabcd', 'dddddddabc')\n-- false\n-- >>> same_chars('abcd', 'dddddddabce')\n-- false\n-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n-- false\nlocal function same_chars(s0, s1)\n","canonical_solution":"local function same_chars(s0, s1)\n    local function char_set(str)\n        local set = {}\n        for c in str:gmatch(\".\") do\n            set[c] = true\n        end\n        return set\n    end\n\n    local set0 = char_set(s0)\n    local set1 = char_set(s1)\n\n    for c in pairs(set0) do\n        if not set1[c] then\n            return false\n        end\n    end\n\n    for c in pairs(set1) do\n        if not set0[c] then\n            return false\n        end\n    end\n\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = same_chars\n    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), true)\n    lu.assertEquals(candidate('abcd', 'dddddddabc'), true)\n    lu.assertEquals(candidate('dddddddabc', 'abcd'), true)\n    lu.assertEquals(candidate('eabcd', 'dddddddabc'), false)\n    lu.assertEquals(candidate('abcd', 'dddddddabcf'), false)\n    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), false)\n    lu.assertEquals(candidate('aabb', 'aaccc'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_55","nl":"scn_Latn","pl":"lua","prompt":"- Ritorna lu nùmmuru n-esimu di Fibonacci. -- >>> fib(10)\n-- 55\n-- >>> fib(1)\n-- 1\n-- >>> fib(8)\n-- 21\nlocal function fib(n)\n","canonical_solution":"local function fib(n)\n    if n <= 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n    else\n        local a, b = 0, 1\n        for i = 2, n do\n            a, b = b, a + b\n        end\n        return b\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fib\n    lu.assertEquals(candidate(10), 55)\n    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(8), 21)\n    lu.assertEquals(candidate(11), 89)\n    lu.assertEquals(candidate(12), 144)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_56","nl":"scn_Latn","pl":"lua","prompt":"- torna veru si ogni bracket apertura hà un bracket chiusura currispundenti. - parenti è na stringa di \"<\" e \">\". -- >>> correct_bracketing('<')\n-- false\n-- >>> correct_bracketing('<>')\n-- true\n-- >>> correct_bracketing('<<><>>')\n-- true\n-- >>> correct_bracketing('><<>')\n-- false\nlocal function correct_bracketing(brackets)\n","canonical_solution":"local function correct_bracketing(brackets)\n    local balance = 0\n    \n    for i = 1, #brackets do\n        local char = brackets:sub(i, i)\n        if char == '<' then\n            balance = balance + 1\n        elseif char == '>' then\n            balance = balance - 1\n        end\n        \n        if balance < 0 then\n            return false\n        end\n    end\n    \n    return balance == 0\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = correct_bracketing\n    lu.assertEquals(candidate('<>'), true)\n    lu.assertEquals(candidate('<<><>>'), true)\n    lu.assertEquals(candidate('<><><<><>><>'), true)\n    lu.assertEquals(candidate('<><><<<><><>><>><<><><<>>>'), true)\n    lu.assertEquals(candidate('<<<><>>>>'), false)\n    lu.assertEquals(candidate('><<>'), false)\n    lu.assertEquals(candidate('<'), false)\n    lu.assertEquals(candidate('<<<<'), false)\n    lu.assertEquals(candidate('>'), false)\n    lu.assertEquals(candidate('<<>'), false)\n    lu.assertEquals(candidate('<><><<><>><>><<>'), false)\n    lu.assertEquals(candidate('<><><<><>><>>><>'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_57","nl":"scn_Latn","pl":"lua","prompt":"- Ritorna veru è elementi di tavula sò monotonicamente crescenti o diminuenti. -- >>> monotonic({1, 2, 4, 20})\n-- true\n-- >>> monotonic({1, 20, 4, 10})\n-- false\n-- >>> monotonic({4, 1, 0, -10})\n-- true\nlocal function monotonic(l)\n","canonical_solution":"local function monotonic(l)\n    if #l < 2 then\n        return true\n    end\n\n    local increasing = true\n    local decreasing = true\n\n    for i = 2, #l do\n        if l[i] > l[i - 1] then\n            decreasing = false\n        elseif l[i] < l[i - 1] then\n            increasing = false\n        end\n    end\n\n    return increasing or decreasing\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = monotonic\n    lu.assertEquals(candidate({1, 2, 4, 10}), true)\n    lu.assertEquals(candidate({1, 2, 4, 20}), true)\n    lu.assertEquals(candidate({1, 20, 4, 10}), false)\n    lu.assertEquals(candidate({4, 1, 0, -10}), true)\n    lu.assertEquals(candidate({4, 1, 1, 0}), true)\n    lu.assertEquals(candidate({1, 2, 3, 2, 5, 60}), false)\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 60}), true)\n    lu.assertEquals(candidate({9, 9, 9, 9}), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_58","nl":"scn_Latn","pl":"lua","prompt":"- Ritorna elementi cumuni unichi ordinati pi dui tàvuli. -- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})\n-- {1, 5, 653}\n-- >>> common({5, 3, 2, 8}, {3, 2})\n-- {2, 3}\nlocal function common(l1, l2)\n","canonical_solution":"local function common(l1, l2)\n    local set1 = {}\n    local set2 = {}\n    local result = {}\n\n    -- Create a set for the first list\n    for _, value in ipairs(l1) do\n        set1[value] = true\n    end\n\n    -- Create a set for the second list, noting only common elements\n    for _, value in ipairs(l2) do\n        if set1[value] then\n            set2[value] = true\n        end\n    end\n\n    -- Collect the keys from the set into a results table\n    for key in pairs(set2) do\n        table.insert(result, key)\n    end\n\n    -- Sort the results table\n    table.sort(result)\n\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = common\n    lu.assertEquals(candidate({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}), {1, 5, 653})\n    lu.assertEquals(candidate({5, 3, 2, 8}, {3, 2}), {2, 3})\n    lu.assertEquals(candidate({4, 3, 2, 8}, {3, 2, 4}), {2, 3, 4})\n    lu.assertEquals(candidate({4, 3, 2, 8}, {}), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_59","nl":"scn_Latn","pl":"lua","prompt":"- Ritorna lu cchiù granni fatturi primu di n. Assumi n > 1 e nun è un primu. -- >>> largest_prime_factor(13195)\n-- 29\n-- >>> largest_prime_factor(2048)\n-- 2\nlocal function largest_prime_factor(n)\n","canonical_solution":"local function largest_prime_factor(n)\n    local factor = 2\n    while n > 1 do\n        if n % factor == 0 then\n            n = n \/ factor\n        else\n            factor = factor + 1\n        end\n    end\n    return factor\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_prime_factor\n    lu.assertEquals(candidate(15), 5)\n    lu.assertEquals(candidate(27), 3)\n    lu.assertEquals(candidate(63), 7)\n    lu.assertEquals(candidate(330), 11)\n    lu.assertEquals(candidate(13195), 29)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_60","nl":"scn_Latn","pl":"lua","prompt":"- sum_to_n è na funzioni ca addica nummari da 1 a n. -- >>> sum_to_n(30)\n-- 465\n-- >>> sum_to_n(100)\n-- 5050\n-- >>> sum_to_n(5)\n-- 15\n-- >>> sum_to_n(10)\n-- 55\n-- >>> sum_to_n(1)\n-- 1\nlocal function sum_to_n(n)\n","canonical_solution":"local function sum_to_n(n)\n    return n * (n + 1) \/\/ 2\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_to_n\n    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(6), 21)\n    lu.assertEquals(candidate(11), 66)\n    lu.assertEquals(candidate(30), 465)\n    lu.assertEquals(candidate(100), 5050)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_61","nl":"scn_Latn","pl":"lua","prompt":"- torna veru si ogni bracket apertura hà un bracket chiusura currispundenti. - parentesi è na stringa di \"(\" e \")\". -- >>> correct_bracketing('(')\n-- false\n-- >>> correct_bracketing('()')\n-- true\n-- >>> correct_bracketing('(()())')\n-- true\n-- >>> correct_bracketing(')(()')\n-- false\nlocal function correct_bracketing(brackets)\n","canonical_solution":"local function correct_bracketing(brackets)\n    local balance = 0\n    for i = 1, #brackets do\n        local char = brackets:sub(i, i)\n        if char == \"(\" then\n            balance = balance + 1\n        elseif char == \")\" then\n            balance = balance - 1\n        end\n        if balance < 0 then\n            return false\n        end\n    end\n    return balance == 0\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = correct_bracketing\n    lu.assertEquals(candidate('()'), true)\n    lu.assertEquals(candidate('(()())'), true)\n    lu.assertEquals(candidate('()()(()())()'), true)\n    lu.assertEquals(candidate('()()((()()())())(()()(()))'), true)\n    lu.assertEquals(candidate('((()())))'), false)\n    lu.assertEquals(candidate(')(()'), false)\n    lu.assertEquals(candidate('('), false)\n    lu.assertEquals(candidate('(((('), false)\n    lu.assertEquals(candidate(')'), false)\n    lu.assertEquals(candidate('(()'), false)\n    lu.assertEquals(candidate('()()(()())())(()'), false)\n    lu.assertEquals(candidate('()()(()())()))()'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_62","nl":"scn_Latn","pl":"lua","prompt":"- Ritorna la dirivata di stu pulinomiu nta la stissa forma. - xs[0] + xs[1] * x + xs[2] * x^2 + .... - xs rapprisintanu li cuefficienti di nu polinomiu. -- >>> derivative({3, 1, 2, 4, 5})\n-- {1, 4, 12, 20}\n-- >>> derivative({1, 2, 3})\n-- {2, 6}\nlocal function derivative(xs)\n","canonical_solution":"local function derivative(xs)\n    local result = {}\n    for i = 2, #xs do\n        result[i - 1] = xs[i] * (i - 1)\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = derivative\n    lu.assertEquals(candidate({3, 1, 2, 4, 5}), {1, 4, 12, 20})\n    lu.assertEquals(candidate({1, 2, 3}), {2, 6})\n    lu.assertEquals(candidate({3, 2, 1}), {2, 2})\n    lu.assertEquals(candidate({3, 2, 1, 0, 4}), {2, 2, 0, 16})\n    lu.assertEquals(candidate({1}), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_63","nl":"scn_Latn","pl":"lua","prompt":"- Scrivite una funzione per calculà in modu efficace l'elementu n-esimu di a sequenza numerica fibfib. - fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3). - fib fib ((2) == 1 - fib fib ((1) == 0 - fibfib ((0) == 0 - La sequenza numerica FibFib è na sequenza simili a la sequenza di Fibbonacci ca è difinuta comu siguenti: -- >>> fibfib(1)\n-- 0\n-- >>> fibfib(5)\n-- 4\n-- >>> fibfib(8)\n-- 24\nlocal function fibfib(n)\n","canonical_solution":"local function fibfib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 0\n    elseif n == 2 then\n        return 1\n    else\n        local a, b, c = 0, 0, 1\n        for i = 3, n do\n            local next_fibfib = a + b + c\n            a, b, c = b, c, next_fibfib\n        end\n        return c\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fibfib\n    lu.assertEquals(candidate(2), 1)\n    lu.assertEquals(candidate(1), 0)\n    lu.assertEquals(candidate(5), 4)\n    lu.assertEquals(candidate(8), 24)\n    lu.assertEquals(candidate(10), 81)\n    lu.assertEquals(candidate(12), 274)\n    lu.assertEquals(candidate(14), 927)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_64","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - vucali, ma sulu quannu è a fini di na parola data.- Li vucali 'nta stu casu sunnu 'a', 'e', 'i', 'o', 'u'.- na parola comu input e torna lu nùmmiru di vucali ntâ stringa. - Scrivi na funzioni vowels_count ca pigghia na stringa rapprisintanti -- >>> vowels_count('abcde')\n-- 2\n-- >>> vowels_count('ACEDY')\n-- 3\nlocal function vowels_count(s)\n","canonical_solution":"local function vowels_count(s)\n    local count = 0\n    local vowels = {a = true, e = true, i = true, o = true, u = true, \n                    A = true, E = true, I = true, O = true, U = true}\n                    \n    for i = 1, #s do\n        local char = s:sub(i, i)\n        if vowels[char] or (char == 'y' or char == 'Y') and i == #s then\n            count = count + 1\n        end\n    end\n    \n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = vowels_count\n    lu.assertEquals(candidate('abcde'), 2)\n    lu.assertEquals(candidate('Alone'), 3)\n    lu.assertEquals(candidate('key'), 2)\n    lu.assertEquals(candidate('bye'), 1)\n    lu.assertEquals(candidate('keY'), 2)\n    lu.assertEquals(candidate('bYe'), 1)\n    lu.assertEquals(candidate('ACEDY'), 3)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_65","nl":"scn_Latn","pl":"lua","prompt":"- Se shift > numaru di cifre, cifre di ritornu invertite. - e torna lu risurtatu comu na stringa. - Circular move i cifri di u nùmmaru intiru x, move i cifri dritta da u cambiamentu -- >>> circular_shift(12, 1)\n-- '21'\n-- >>> circular_shift(12, 2)\n-- '12'\nlocal function circular_shift(x, shift)\n","canonical_solution":"local function circular_shift(x, shift)\n    local num_str = tostring(x)\n    local num_digits = #num_str\n    if shift > num_digits then\n        return num_str:reverse()\n    else\n        local shift_pos = num_digits - (shift % num_digits)\n        return num_str:sub(shift_pos + 1) .. num_str:sub(1, shift_pos)\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = circular_shift\n    lu.assertEquals(candidate(100, 2), '001')\n    lu.assertEquals(candidate(12, 2), '12')\n    lu.assertEquals(candidate(97, 8), '79')\n    lu.assertEquals(candidate(12, 1), '21')\n    lu.assertEquals(candidate(11, 101), '11')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_66","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Codici ASCII. - Scrivi na funzioni ca pigghia na stringa comu input e torna sulu la summa di li caratteri supiriuri' - Tasca -- >>> digitSum('')\n-- 0\n-- >>> digitSum('abAB')\n-- 131\n-- >>> digitSum('abcCd')\n-- 67\n-- >>> digitSum('helloE')\n-- 69\n-- >>> digitSum('woArBld')\n-- 131\n-- >>> digitSum('aAaaaXa')\n-- 153\nlocal function digitSum(s)\n","canonical_solution":"local function digitSum(s)\n    local sum = 0\n    for i = 1, #s do\n        local char = s:sub(i, i)\n        if char:match(\"%u\") then\n            sum = sum + string.byte(char)\n        end\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = digitSum\n    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('abAB'), 131)\n    lu.assertEquals(candidate('abcCd'), 67)\n    lu.assertEquals(candidate('helloE'), 69)\n    lu.assertEquals(candidate('woArBld'), 131)\n    lu.assertEquals(candidate('aAaaaXa'), 153)\n    lu.assertEquals(candidate(' How are yOu?'), 151)\n    lu.assertEquals(candidate('You arE Very Smart'), 327)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_67","nl":"scn_Latn","pl":"lua","prompt":"- pi l'esamble: - in u cestimentu riturnà u numeru di frutti di mango in u cestimentu. - l'aranci e li meli e nu nùmmuru interi ca rapprisintanu lu nùmmuru tutali di li frutti - mele, aranci, e frutti di mango. datu la stringa ca rapprisenta lu nùmmiru tutali di - chì sò distribuiti in un cesti di frutti chì cuntene stu cesti - 'N stu compitu, vi sarà datu 'na stringa ca rapprisenta nu nùmmuru di meli e aranci.-- >>> fruit_distribution('5 apples and 6 oranges', 19)\n-- 8\n-- >>> fruit_distribution('0 apples and 1 oranges', 3)\n-- 2\n-- >>> fruit_distribution('2 apples and 3 oranges', 100)\n-- 95\n-- >>> fruit_distribution('100 apples and 1 oranges', 120)\n-- 19\nlocal function fruit_distribution(s, n)\n","canonical_solution":"local function fruit_distribution(s, n)\n    local apples, oranges = s:match(\"(%d+)%s*apples%s*and%s*(%d+)%s*oranges\")\n    apples = tonumber(apples)\n    oranges = tonumber(oranges)\n    local mangoes = n - (apples + oranges)\n    return mangoes\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fruit_distribution\n    lu.assertEquals(candidate('5 apples and 6 oranges', 19), 8)\n    lu.assertEquals(candidate('5 apples and 6 oranges', 21), 10)\n    lu.assertEquals(candidate('0 apples and 1 oranges', 3), 2)\n    lu.assertEquals(candidate('1 apples and 0 oranges', 3), 2)\n    lu.assertEquals(candidate('2 apples and 3 oranges', 100), 95)\n    lu.assertEquals(candidate('2 apples and 3 oranges', 5), 0)\n    lu.assertEquals(candidate('1 apples and 100 oranges', 120), 19)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_68","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu 1: - Si nun ci sunnu valuri pari o la tàvula data è vacanti, torna []. - U nodulu sbucciatu deve esse restituitu in una tavula, [small_value, u so indice ], - Si si trovanu tanti nodi cu lu stissu valuri pari cchiù nicu, riturnamu lu nodi ca havi l'indici cchiù nicu. - U noddu sbucciatu deve esse u noddu cù u valore pari u più chjucu. - u vostru compitu è di strappà unu di i nodi è di riturnà lu. - \"Datu na tàvula ca rapprisenta na ramu di n'arburu ca havi nodi nentieri nun nigativi -- >>> pluck({4, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 2:\n-- >>> pluck({1, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 3:\n-- >>> pluck({})\n-- {}\n-- Example 4:\n-- >>> pluck({5, 0, 3, 0, 4, 2})\n-- {0, 1}\n-- Explanation: 0 is the smallest value, but  there are two zeros,\n--              so we will choose the first zero, which has the smallest index.\n-- Constraints:\n--     * 1 <= nodes.length <= 10000\n--     * 0 <= node.value\nlocal function pluck(arr)\n","canonical_solution":"local function pluck(arr)\n    local smallest_even_value = nil\n    local smallest_index = nil\n\n    for index, value in ipairs(arr) do\n        if value % 2 == 0 then\n            if smallest_even_value == nil or value < smallest_even_value then\n                smallest_even_value = value\n                smallest_index = index\n            end\n        end\n    end\n\n    if smallest_even_value == nil then\n        return {}\n    else\n        return {smallest_even_value, smallest_index}\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = pluck\n    lu.assertEquals(candidate({4, 2, 3}), {2, 1})\n    lu.assertEquals(candidate({1, 2, 3}), {2, 1})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({5, 0, 3, 0, 4, 2}), {0, 1})\n    lu.assertEquals(candidate({1, 2, 3, 0, 5, 3}), {0, 3})\n    lu.assertEquals(candidate({5, 4, 8, 4, 8}), {4, 1})\n    lu.assertEquals(candidate({7, 6, 7, 1}), {6, 1})\n    lu.assertEquals(candidate({7, 9, 7, 1}), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_69","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Si nu tali valuri esisti, torna -1. - La friquenza di nu nùmmaru nteri è lu nùmmuru di voti ca appari nta la tàvula.- zeru, e havi na friquenza cchiù granni o uguali ô valuri dû nùmmuru nternu stissu. - Vi veni datu na tàvula di nùmmura nteri pusitivi.-- >>> search({4, 1, 2, 2, 3, 1})\n-- 2\n-- >>> search({1, 2, 2, 3, 3, 3, 4, 4, 4})\n-- 3\n-- >>> search({5, 5, 4, 4, 4})\n-- -1\nlocal function search(lst)\n","canonical_solution":"local function search(lst)\n    local frequency = {}\n    \n    -- Calculate the frequency of each number in the list\n    for _, num in ipairs(lst) do\n        frequency[num] = (frequency[num] or 0) + 1\n    end\n\n    local result = -1\n    \n    -- Determine the maximum valid integer with the criteria\n    for num, freq in pairs(frequency) do\n        if num > 0 and freq >= num and num > result then\n            result = num\n        end\n    end\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = search\n    lu.assertEquals(candidate({5, 5, 5, 5, 1}), 1)\n    lu.assertEquals(candidate({4, 1, 4, 1, 4, 4}), 4)\n    lu.assertEquals(candidate({3, 3}), -1)\n    lu.assertEquals(candidate({8, 8, 8, 8, 8, 8, 8, 8}), 8)\n    lu.assertEquals(candidate({2, 3, 3, 2, 2}), 2)\n    lu.assertEquals(candidate({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), 1)\n    lu.assertEquals(candidate({3, 2, 8, 2}), 2)\n    lu.assertEquals(candidate({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), 1)\n    lu.assertEquals(candidate({8, 8, 3, 6, 5, 6, 4}), -1)\n    lu.assertEquals(candidate({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), 1)\n    lu.assertEquals(candidate({1, 9, 10, 1, 3}), 1)\n    lu.assertEquals(candidate({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), 5)\n    lu.assertEquals(candidate({1}), 1)\n    lu.assertEquals(candidate({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), 4)\n    lu.assertEquals(candidate({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), 2)\n    lu.assertEquals(candidate({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), 1)\n    lu.assertEquals(candidate({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), 4)\n    lu.assertEquals(candidate({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), 4)\n    lu.assertEquals(candidate({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), 2)\n    lu.assertEquals(candidate({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), -1)\n    lu.assertEquals(candidate({10}), -1)\n    lu.assertEquals(candidate({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), 2)\n    lu.assertEquals(candidate({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), 1)\n    lu.assertEquals(candidate({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), 1)\n    lu.assertEquals(candidate({3, 10, 10, 9, 2}), -1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_70","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - poi u massimu di i numeri interi rimanenti, poi u minimu è cusì via. - Stranu, è quannu si cumincia cu lu valuri minimu, - Data la tàvula dî nùmmura interi, riturnà la tàvula 'n ordini straniu.-- >>> strange_sort_list({1, 2, 3, 4})\n-- {1, 4, 2, 3}\n-- >>> strange_sort_list({5, 5, 5, 5})\n-- {5, 5, 5, 5}\n-- >>> strange_sort_list({})\n-- {}\nlocal function strange_sort_list(lst)\n","canonical_solution":"local function strange_sort_list(lst)\n    table.sort(lst) -- Sort the list\n    local result = {}\n    local i, j = 1, #lst\n    \n    while i <= j do\n        table.insert(result, lst[i])\n        if i ~= j then\n            table.insert(result, lst[j])\n        end\n        i = i + 1\n        j = j - 1\n    end\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = strange_sort_list\n    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})\n    lu.assertEquals(candidate({5, 6, 7, 8, 9}), {5, 9, 6, 8, 7})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}), {1, 5, 2, 4, 3})\n    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5, 8, 6, 7})\n    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3, 6, 4, 5})\n    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5, -5, 5, 0, 2, 2, 2})\n    lu.assertEquals(candidate({111111}), {111111})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_71","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - ca lu terzu latu.- Tri lati fannu nu triàngulu validu quannu la summa di qualunqui dui lati è cchiù granni.- Altrimenti torna -1 - u triangulu arrotondatu à 2 punti decimali s'è i trè lati formanu un triangulu validu. - Datu li lunghi di li tri lati di nu triàngulu.-- >>> triangle_area(3, 4, 5)\n-- 6.0\n-- >>> triangle_area(1, 2, 10)\n-- -1\nlocal function triangle_area(a, b, c)\n","canonical_solution":"local function triangle_area(a, b, c)\n    -- Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a then\n        -- Calculate the semi-perimeter\n        local s = (a + b + c) \/ 2\n        -- Calculate the area using Heron's formula\n        local area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        -- Return the area rounded to 2 decimal points\n        return math.floor(area * 100 + 0.5) \/ 100\n    else\n        -- Return -1 if not a valid triangle\n        return -1\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = triangle_area\n    lu.assertEquals(candidate(3, 4, 5), 6.0)\n    lu.assertEquals(candidate(1, 2, 10), -1)\n    lu.assertEquals(candidate(4, 8, 5), 8.18)\n    lu.assertEquals(candidate(2, 2, 2), 1.73)\n    lu.assertEquals(candidate(1, 2, 3), -1)\n    lu.assertEquals(candidate(10, 5, 7), 16.25)\n    lu.assertEquals(candidate(2, 6, 3), -1)\n    lu.assertEquals(candidate(1, 1, 1), 0.43)\n    lu.assertEquals(candidate(2, 2, 10), -1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_72","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - L'uggettu q voli si è equilibratu (è una tavula palindromica) è a somma di i so elementi hè menu o uguale à u pesu massimu pussibule w. - Scrivite una funzione chì rende veru se l'ughjettu q voli, è falsu altrimenti. -- >>> will_it_fly({1, 2}, 5)\n-- false\n-- # 1+2 is less than the maximum possible weight, but it's unbalanced.\n-- >>> will_it_fly({3, 2, 3}, 1)\n-- false\n-- # it's balanced, but 3+2+3 is more than the maximum possible weight.\n-- >>> will_it_fly({3, 2, 3}, 9)\n-- true\n-- # 3+2+3 is less than the maximum possible weight, and it's balanced.\n-- >>> will_it_fly({3}, 5)\n-- true\n-- # 3 is less than the maximum possible weight, and it's balanced.\nlocal function will_it_fly(q, w)\n","canonical_solution":"local function will_it_fly(q, w)\n    local function is_palindrome(tbl)\n        local len = #tbl\n        for i = 1, math.floor(len \/ 2) do\n            if tbl[i] ~= tbl[len - i + 1] then\n                return false\n            end\n        end\n        return true\n    end\n\n    local function sum_elements(tbl)\n        local sum = 0\n        for _, value in ipairs(tbl) do\n            sum = sum + value\n        end\n        return sum\n    end\n\n    if not is_palindrome(q) then\n        return false\n    end\n\n    local total_weight = sum_elements(q)\n    return total_weight <= w\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = will_it_fly\n    lu.assertEquals(candidate({3, 2, 3}, 9), true)\n    lu.assertEquals(candidate({1, 2}, 5), false)\n    lu.assertEquals(candidate({3}, 5), true)\n    lu.assertEquals(candidate({3, 2, 3}, 1), false)\n    lu.assertEquals(candidate({1, 2, 3}, 6), false)\n    lu.assertEquals(candidate({5}, 5), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_73","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - si leggi lu stissu avanti e arreri. 'N na vota, si pò canciari un elementu pi n'àutru elementu.- ci vole à cambià per fà a tavula palindromica. Una tavula palindromica hè una tavula chì - Datu na tàvula arr di nùmmura interi, truvamu lu nùmmuru minimu di elementi ca -- >>> smallest_change({1, 2, 3, 5, 4, 7, 9, 6})\n-- 4\n-- >>> smallest_change({1, 2, 3, 4, 3, 2, 2})\n-- 1\n-- >>> smallest_change({1, 2, 3, 2, 1})\n-- 0\nlocal function smallest_change(arr)\n","canonical_solution":"local function smallest_change(arr)\n    local n = #arr\n    local changes = 0\n    \n    for i = 1, math.floor(n \/ 2) do\n        if arr[i] ~= arr[n - i + 1] then\n            changes = changes + 1\n        end\n    end\n    \n    return changes\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = smallest_change\n    lu.assertEquals(candidate({1, 2, 3, 5, 4, 7, 9, 6}), 4)\n    lu.assertEquals(candidate({1, 2, 3, 4, 3, 2, 2}), 1)\n    lu.assertEquals(candidate({1, 4, 2}), 1)\n    lu.assertEquals(candidate({1, 4, 4, 2}), 1)\n    lu.assertEquals(candidate({1, 2, 3, 2, 1}), 0)\n    lu.assertEquals(candidate({3, 1, 1, 3}), 0)\n    lu.assertEquals(candidate({1}), 0)\n    lu.assertEquals(candidate({0, 1}), 1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_74","nl":"scn_Latn","pl":"lua","prompt":"- Esempi - si li dui tàvuli hannu lu stissu nùmmiru di carri, riturnari la prima tàvula. - numaru tutali di carri nta tutti li fili dâ tàvula menu di l'àutra tàvula.- Scrivi na funzioni ca accetta dui tàvuli di stringhi e torna la tàvula ca havi -- >>> total_match({}, {})\n-- {}\n-- >>> total_match({'hi', 'admin'}, {'hI', 'Hi'})\n-- {'hI', 'Hi'}\n-- >>> total_match({'hi', 'admin'}, {'hi', 'hi', 'admin', 'project'})\n-- {'hi', 'admin'}\n-- >>> total_match({'hi', 'admin'}, {'hI', 'hi', 'hi'})\n-- {'hI', 'hi', 'hi'}\n-- >>> total_match({'4'}, {'1', '2', '3', '4', '5'})\n-- {'4'}\nlocal function total_match(lst1, lst2)\n","canonical_solution":"local function total_match(lst1, lst2)\n    local function total_chars(lst)\n        local count = 0\n        for _, str in ipairs(lst) do\n            count = count + #str\n        end\n        return count\n    end\n\n    local chars_lst1 = total_chars(lst1)\n    local chars_lst2 = total_chars(lst2)\n\n    if chars_lst1 < chars_lst2 then\n        return lst1\n    elseif chars_lst2 < chars_lst1 then\n        return lst2\n    else\n        return lst1\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = total_match\n    lu.assertEquals(candidate({}, {}), {})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hi', 'hi'}), {'hi', 'hi'})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hi', 'hi', 'admin', 'project'}), {'hi', 'admin'})\n    lu.assertEquals(candidate({'4'}, {'1', '2', '3', '4', '5'}), {'4'})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hI', 'Hi'}), {'hI', 'Hi'})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hI', 'hi', 'hi'}), {'hI', 'hi', 'hi'})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hI', 'hi', 'hii'}), {'hi', 'admin'})\n    lu.assertEquals(candidate({}, {'this'}), {})\n    lu.assertEquals(candidate({'this'}, {}), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_75","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - Sapennu ca (a) è cchiù picca di 100. - e altrimenti è falsu.- Scrivi na funzioni ca torna veru si lu nùmmuru datu è la multiplicationi di 3 nùmmura primi -- >>> is_multiply_prime(30)\n-- true\n-- 30 = 2 * 3 * 5\nlocal function is_multiply_prime(a)\n","canonical_solution":"local function is_prime(n)\n    if n <= 1 then return false end\n    if n <= 3 then return true end\n    if n % 2 == 0 or n % 3 == 0 then return false end\n    local i = 5\n    while (i * i) <= n do\n        if n % i == 0 or n % (i + 2) == 0 then\n            return false\n        end\n        i = i + 6\n    end\n    return true\nend\n\nlocal function generate_primes(limit)\n    local primes = {}\n    for i = 2, limit do\n        if is_prime(i) then\n            table.insert(primes, i)\n        end\n    end\n    return primes\nend\n\nlocal function is_multiply_prime(a)\n    local primes = generate_primes(100)\n    local count = #primes\n    for i = 1, count do\n        for j = i + 1, count do\n            for k = j + 1, count do\n                if primes[i] * primes[j] * primes[k] == a then\n                    return true\n                end\n            end\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_multiply_prime\n    lu.assertEquals(candidate(5), false)\n    lu.assertEquals(candidate(30), true)\n    lu.assertEquals(candidate(8), true)\n    lu.assertEquals(candidate(10), false)\n    lu.assertEquals(candidate(125), true)\n    lu.assertEquals(candidate(105), true)\n    lu.assertEquals(candidate(126), false)\n    lu.assertEquals(candidate(729), false)\n    lu.assertEquals(candidate(891), false)\n    lu.assertEquals(candidate(1001), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_76","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - x è na putenza semplici di n si n**int=x - putenza di n e falsu nta l'àutri casi. - U vostru compitu è di scriviri na funzioni ca torna veru si nu nùmmaru x è na semplici -- >>> is_simple_power(1, 4)\n-- true\n-- >>> is_simple_power(2, 2)\n-- true\n-- >>> is_simple_power(8, 2)\n-- true\n-- >>> is_simple_power(3, 2)\n-- false\n-- >>> is_simple_power(3, 1)\n-- false\n-- >>> is_simple_power(5, 3)\n-- false\nlocal function is_simple_power(x, n)\n","canonical_solution":"local function is_simple_power(x, n)\n    if x == 1 then\n        return true\n    end\n    if n <= 0 or x <= 0 then\n        return false\n    end\n    local current_power = 1\n    while current_power < x do\n        current_power = current_power * n\n    end\n    return current_power == x\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_simple_power\n    lu.assertEquals(candidate(16, 2), true)\n    lu.assertEquals(candidate(143214, 16), false)\n    lu.assertEquals(candidate(4, 2), true)\n    lu.assertEquals(candidate(9, 3), true)\n    lu.assertEquals(candidate(16, 4), true)\n    lu.assertEquals(candidate(24, 2), false)\n    lu.assertEquals(candidate(128, 4), false)\n    lu.assertEquals(candidate(12, 6), false)\n    lu.assertEquals(candidate(1, 1), true)\n    lu.assertEquals(candidate(1, 12), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_77","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Nota: si pò suppuniri ca lu input è sempri validu.- si stu ingeger è nu cubo di nu certu nùmmuru interi. - Scrivi na funzioni ca pigghia n'entieru a e torna veru -- >>> iscube(1)\n-- true\n-- >>> iscube(2)\n-- false\n-- >>> iscube(-1)\n-- true\n-- >>> iscube(64)\n-- true\n-- >>> iscube(0)\n-- true\n-- >>> iscube(180)\n-- false\nlocal function iscube(a)\n","canonical_solution":"local function iscube(a)\n    if a < 0 then\n        a = -a\n    end\n    local cbrt = math.floor(a ^ (1\/3) + 0.5)\n    return cbrt * cbrt * cbrt == a\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = iscube\n    lu.assertEquals(candidate(1), true)\n    lu.assertEquals(candidate(2), false)\n    lu.assertEquals(candidate(-1), true)\n    lu.assertEquals(candidate(64), true)\n    lu.assertEquals(candidate(180), false)\n    lu.assertEquals(candidate(1000), true)\n    lu.assertEquals(candidate(0), true)\n    lu.assertEquals(candidate(1729), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_78","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - e li sìmmuli A,B,C,D,E,F sunnu sempri maiusculi.- Nota: si pò supponi ca lu input hè sempre curretta o stringa vacanti, - B (= decimale 11), D (= decimale 13). - Allura haiu a truvari un nùmmiru dî seguienti cifri: 2, 3, 5, 7, - Li nùmmura primi sunnu 2, 3, 5, 7, 11, 13, 17...- Li cifri esadecimali sunnu 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. - cchiù granni di 1 ca nun è nu pruduttu di dui nùmmura naturali cchiù nichi).- cifri ca sunnu primi (nu nùmmuru primu, o un nùmmuru primu, è nu nùmmuru naturali - un nùmmuru esadecimali comu na stringa e cunta lu nùmmuru di esadecimali - Ti è statu dumandatu di scriviri na funzioni ca ricevi -- >>> hex_key('AB')\n-- 1\n-- >>> hex_key('1077E')\n-- 2\n-- >>> hex_key('ABED1A33')\n-- 4\n-- >>> hex_key('123456789ABCDEF0')\n-- 6\n-- >>> hex_key('2020')\n-- 2\nlocal function hex_key(num)\n","canonical_solution":"local function hex_key(num)\n    local prime_digits = {['2'] = true, ['3'] = true, ['5'] = true, ['7'] = true, ['B'] = true, ['D'] = true}\n    local count = 0\n    for digit in num:gmatch('.') do\n        if prime_digits[digit] then\n            count = count + 1\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = hex_key\n    lu.assertEquals(candidate('AB'), 1)\n    lu.assertEquals(candidate('1077E'), 2)\n    lu.assertEquals(candidate('ABED1A33'), 4)\n    lu.assertEquals(candidate('2020'), 2)\n    lu.assertEquals(candidate('123456789ABCDEF0'), 6)\n    lu.assertEquals(candidate('112233445566778899AABBCCDDEEFF00'), 12)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_79","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Li caratteri extra sunnu ccà pi aiutari cu lu furmatu.- Ci sarà un coppiu di caratteri extra 'db' à l'iniziu è à a fine di a stringa. Ogni caràttiri dâ stringa sarà \"0\" o \"1\".- furmatu binariu. La funzioni avissi a riturnari na stringa, cu ogni caràttiri ca rapprisenta un furmatu binariu - Vi sarà datu un numeru in forma decimale è u vostru compitu hè di cunvertisce lu in -- >>> decimal_to_binary(15)\n-- 'db1111db'\n-- >>> decimal_to_binary(32)\n-- 'db100000db'\nlocal function decimal_to_binary(decimal)\n","canonical_solution":"local function decimal_to_binary(decimal)\n    -- Convert the decimal number to binary and remove the '0b' prefix using string.sub\n    local binary = string.sub(string.format(\"%b\", decimal), 0)\n    -- Concatenate 'db' at the start and end of the binary string\n    return 'db' .. binary .. 'db'\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = decimal_to_binary\n    lu.assertEquals(candidate(0), 'db0db')\n    lu.assertEquals(candidate(32), 'db100000db')\n    lu.assertEquals(candidate(103), 'db1100111db')\n    lu.assertEquals(candidate(15), 'db1111db')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_80","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - Na stringa è haplua si la sò lunghizza è armenu 3 e ogni 3 littri cunzicutivi sunnu distinti - U vostru compitu è di verificà s'è u filu hè haplua o micca. - Ti dugnu na stringa di s. -- >>> is_happy('a')\n-- false\n-- >>> is_happy('aa')\n-- false\n-- >>> is_happy('abcd')\n-- true\n-- >>> is_happy('aabb')\n-- false\n-- >>> is_happy('adb')\n-- true\n-- >>> is_happy('xyy')\n-- false\nlocal function is_happy(s)\n","canonical_solution":"local function is_happy(s)\n    -- Check if the string length is less than 3\n    if #s < 3 then\n        return false\n    end\n\n    -- Iterate through the string and check every 3 consecutive characters\n    for i = 1, #s - 2 do\n        local a, b, c = s:sub(i, i), s:sub(i + 1, i + 1), s:sub(i + 2, i + 2)\n        if a == b or b == c or a == c then\n            return false\n        end\n    end\n\n    -- If no 3 consecutive characters are the same, return true\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_happy\n    lu.assertEquals(candidate('a'), false)\n    lu.assertEquals(candidate('aa'), false)\n    lu.assertEquals(candidate('abcd'), true)\n    lu.assertEquals(candidate('aabb'), false)\n    lu.assertEquals(candidate('adb'), true)\n    lu.assertEquals(candidate('xyy'), false)\n    lu.assertEquals(candidate('iopaxpoi'), true)\n    lu.assertEquals(candidate('iopaxioi'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_81","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - 0.0 E - > 0,0 D- - > 0,7 D - > 1,0 D+ - > 1.3 C- - > 1,7 C - > 2.0 C+ - > 2.3 B- - > 2,7 B - > 3.0 B+ - > 3.3 A- - > 3.7 A - 4.0 A+ - GPA. Gradu di lettura.- na funzioni ca pò fari na tavula di gradi di littri usannu la tavula siguenti: - Ti ha datu na tavula di media di certi studenti e tu devi scriviri .- L'unicu prubblema è, ca ha persu lu còdici ca usava pi la classifica.- a li studenti. lu maistru ha fattu lu so algoritmu pi li voti.- E ' l' ultima simana di semestru e lu maistru havi a dari li voti .-- >>> grade_equation({4.0, 3, 1.7, 2, 3.5})\n-- {'A+', 'B', 'C-', 'C', 'A-'}\nlocal function numerical_letter_grade(grades)\n","canonical_solution":"local function numerical_letter_grade(grades)\n    local letter_grades = {}\n    for _, gpa in ipairs(grades) do\n        local letter\n        if gpa == 4.0 then\n            letter = \"A+\"\n        elseif gpa > 3.7 then\n            letter = \"A\"\n        elseif gpa > 3.3 then\n            letter = \"A-\"\n        elseif gpa > 3.0 then\n            letter = \"B+\"\n        elseif gpa > 2.7 then\n            letter = \"B\"\n        elseif gpa > 2.3 then\n            letter = \"B-\"\n        elseif gpa > 2.0 then\n            letter = \"C+\"\n        elseif gpa > 1.7 then\n            letter = \"C\"\n        elseif gpa > 1.3 then\n            letter = \"C-\"\n        elseif gpa > 1.0 then\n            letter = \"D+\"\n        elseif gpa > 0.7 then\n            letter = \"D\"\n        elseif gpa > 0.0 then\n            letter = \"D-\"\n        else\n            letter = \"E\"\n        end\n        table.insert(letter_grades, letter)\n    end\n    return letter_grades\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = numerical_letter_grade\n    lu.assertEquals(candidate({4.0, 3, 1.7, 2, 3.5}), {'A+', 'B', 'C-', 'C', 'A-'})\n    lu.assertEquals(candidate({1.2}), {'D+'})\n    lu.assertEquals(candidate({0.5}), {'D-'})\n    lu.assertEquals(candidate({0.0}), {'E'})\n    lu.assertEquals(candidate({1.0, 0.3, 1.5, 2.8, 3.3}), {'D', 'D-', 'C-', 'B', 'B+'})\n    lu.assertEquals(candidate({0.0, 0.7}), {'E', 'D-'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_82","nl":"scn_Latn","pl":"lua","prompt":"- Esempi - lunghizza è nu nùmmuru primu o falsu altrimenti - Scrivi na funzioni ca pigghia na stringa e torna veru si la stringa -- >>> prime_length('Hello')\n-- true\n-- >>> prime_length('abcdcba')\n-- true\n-- >>> prime_length('kittens')\n-- true\n-- >>> prime_length('orange')\n-- false\nlocal function prime_length(string)\n","canonical_solution":"local function is_prime(n)\n    if n <= 1 then return false end\n    if n <= 3 then return true end\n    if n % 2 == 0 or n % 3 == 0 then return false end\n    local i = 5\n    while i * i <= n do\n        if n % i == 0 or n % (i + 2) == 0 then return false end\n        i = i + 6\n    end\n    return true\nend\n\nlocal function prime_length(str)\n    local length = #str\n    return is_prime(length)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = prime_length\n    lu.assertEquals(candidate('Hello'), true)\n    lu.assertEquals(candidate('abcdcba'), true)\n    lu.assertEquals(candidate('kittens'), true)\n    lu.assertEquals(candidate('orange'), false)\n    lu.assertEquals(candidate('wow'), true)\n    lu.assertEquals(candidate('world'), true)\n    lu.assertEquals(candidate('MadaM'), true)\n    lu.assertEquals(candidate('Wow'), true)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('HI'), true)\n    lu.assertEquals(candidate('go'), true)\n    lu.assertEquals(candidate('gogo'), false)\n    lu.assertEquals(candidate('aaaaaaaaaaaaaaa'), false)\n    lu.assertEquals(candidate('Madam'), true)\n    lu.assertEquals(candidate('M'), false)\n    lu.assertEquals(candidate('0'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_83","nl":"scn_Latn","pl":"lua","prompt":"- numari interi pusitivi ca accumincianu o finiscinu cu 1. - Datu nu nùmmaru n, riturnari lu cuntu dî nùmmura di n-cifri local function starts_one_ends(n)\n","canonical_solution":"local function starts_one_ends(n)\n    if n == 1 then\n        return 1 -- The single-digit numbers starting or ending with 1 is just 1 itself.\n    end\n    -- Calculate the count of n-digit numbers starting with 1 and ending with 1.\n    local count_start_with_1 = 10 ^ (n - 1) -- All numbers from 100... to 199...\n    local count_end_with_1 = 9 * (10 ^ (n - 1)) -- All numbers from 1, 11, 21,... excluding those starting with 1.\n    \n    -- A number starting and ending with 1 like 101 has been counted twice, correct for that.\n    return count_start_with_1 + count_end_with_1 - 10 ^ (n - 2)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = starts_one_ends\n    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(2), 18)\n    lu.assertEquals(candidate(3), 180)\n    lu.assertEquals(candidate(4), 1800)\n    lu.assertEquals(candidate(5), 18000)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_84","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu - Datu nu nùmmaru neru pusitivu, riturnari la summa tutali dî sò cifri n modu binariu. -- >>> solve(1000)\n-- '1'\n-- >>> solve(150)\n-- '110'\n-- >>> solve(147)\n-- '1100'\n-- Variables:\n--     @N integer\n--          Constraints: 0 ≤ N ≤ 10000.\n-- Output:\n--      a string of binary number\nlocal function solve(N)\n","canonical_solution":"local function solve(N)\n    local sum = 0\n    while N > 0 do\n        sum = sum + (N % 10)\n        N = math.floor(N \/ 10)\n    end\n    return string.format(\"%b\", sum)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = solve\n    lu.assertEquals(candidate(1000), '1')\n    lu.assertEquals(candidate(150), '110')\n    lu.assertEquals(candidate(147), '1100')\n    lu.assertEquals(candidate(333), '1001')\n    lu.assertEquals(candidate(963), '10010')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_85","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Datu na tavula di nùmmura nteri nun vacanti lst. agghiùnciri l'elementi pari ca sunnu a indici dispari.. -- >>> add({4, 2, 6, 7})\n-- 2\nlocal function add(lst)\n","canonical_solution":"local function add(lst)\n    local sum = 0\n    for i = 2, #lst, 2 do\n        if lst[i] % 2 == 0 then\n            sum = sum + lst[i]\n        end\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = add\n    lu.assertEquals(candidate({4, 88}), 88)\n    lu.assertEquals(candidate({4, 5, 6, 7, 2, 122}), 122)\n    lu.assertEquals(candidate({4, 0, 6, 7}), 0)\n    lu.assertEquals(candidate({4, 4, 6, 8}), 12)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_86","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - Nota: Vossia avissi a mantèniri l'òrdini dî palori e li spazzi vacanti ntâ frasi.- ordini ascendenti basati supra lu valuri ASCII. - sunnu rimpiazzati di na nova palora unni tutti li caratteri arriminati in - Versione urdinata di stringa, è na stringa unni tutti li palori (separati cu spaziu) - Scrivi na funzioni ca pigghia na stringa e la torna n'urdinata. -- >>> anti_shuffle('Hi')\n-- 'Hi'\n-- >>> anti_shuffle('hello')\n-- 'ehllo'\n-- >>> anti_shuffle('Hello World!!!')\n-- 'Hello !!!Wdlor'\nlocal function anti_shuffle(s)\n","canonical_solution":"local function anti_shuffle(s)\n    local function sort_word(word)\n        local chars = {}\n        for char in word:gmatch(\".\") do\n            table.insert(chars, char)\n        end\n        table.sort(chars)\n        return table.concat(chars)\n    end\n\n    return (s:gsub(\"%S+\", sort_word))\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = anti_shuffle\n    lu.assertEquals(candidate('Hi'), 'Hi')\n    lu.assertEquals(candidate('hello'), 'ehllo')\n    lu.assertEquals(candidate('number'), 'bemnru')\n    lu.assertEquals(candidate('abcd'), 'abcd')\n    lu.assertEquals(candidate('Hello World!!!'), 'Hello !!!Wdlor')\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_87","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Eppuru, ordinate e coordinate di a fila da e culonne in ordine discendente.- Sortì i coordinati inizialmente da fila in ordine ascendente.- ogni tavula è na cuurdinata - (rigghia, culonna), accuminciannu cu 0. - e torna tavula di tavula, [(x1, y1), (x2, y2) ...] tali ca - Datu lst, e nternu x, trova nternu x ntâ tavula, - ogni riga pò cuntene un numeru diversu di culonne. - ca è simili a matrici, però, a differenza di matrici, - Vi sunnu dati 2 dimensional, comu un tavula annidatu, -- >>> get_row({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}}, 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n","canonical_solution":"local function get_row(lst, x)\n    local coordinates = {}\n    for row_index, row in ipairs(lst) do\n        for col_index = #row, 1, -1 do\n            if row[col_index] == x then\n                table.insert(coordinates, {row_index - 1, col_index - 1})\n            end\n        end\n    end\n    table.sort(coordinates, function(a, b)\n        if a[1] == b[1] then\n            return a[2] > b[2]\n        else\n            return a[1] < b[1]\n        end\n    end)\n    return coordinates\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_88","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - * nun canciari la tàvula data. - Nota: - o ordinallu in ordine discendente se a somma ((primu valore di l'indice, ultimu valore di l'indice) hè pari. - ti sartificari la tavula datu in ordine crescente se la summa (u primu valore indice, u valore indice urtimi) hè dispari, - Datu na tàvula di nterni nun nigativi, riturnari na colua dâ tàvula data doppu l'ordinamentu,-- >>> sort_array({})\n-- {}\n-- >>> sort_array({5})\n-- {5}\n-- >>> sort_array({2, 4, 3, 0, 1, 5})\n-- {0, 1, 2, 3, 4, 5}\n-- >>> sort_array({2, 4, 3, 0, 1, 5, 6})\n-- {6, 5, 4, 3, 2, 1, 0}\nlocal function sort_array(array)\n","canonical_solution":"local function sort_array(array)\n    -- Create a copy of the given table\n    local sorted_array = {}\n    for i = 1, #array do\n        sorted_array[i] = array[i]\n    end\n\n    -- If the table is not empty\n    if #sorted_array > 0 then\n        local first = sorted_array[1]\n        local last = sorted_array[#sorted_array]\n        local sum = first + last\n        \n        -- Sort in ascending or descending order based on the sum\n        if sum % 2 == 0 then\n            table.sort(sorted_array, function(a, b) return a > b end)\n        else\n            table.sort(sorted_array, function(a, b) return a < b end)\n        end\n    end\n\n    return sorted_array\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_array\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({5}), {5})\n    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5}), {0, 1, 2, 3, 4, 5})\n    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5, 6}), {6, 5, 4, 3, 2, 1, 0})\n    lu.assertEquals(candidate({2, 1}), {1, 2})\n    lu.assertEquals(candidate({15, 42, 87, 32, 11, 0}), {0, 11, 15, 32, 42, 87})\n    lu.assertEquals(candidate({21, 14, 23, 11}), {23, 21, 14, 11})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_89","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - spustati 'n bassu pi dui multiplicati pi dui posti.- L'alfabetu deve esse giratu in una manera chì e lettere - torna na stringa criptata cu l'alfabetu ca veni giratu. - Crea na funzioni crittografica ca pigghia na stringa comu argumentu e -- >>> encrypt('hi')\n-- 'lm'\n-- >>> encrypt('asdfghjkl')\n-- 'ewhjklnop'\n-- >>> encrypt('gf')\n-- 'kj'\n-- >>> encrypt('et')\n-- 'ix'\nlocal function encrypt(s)\n","canonical_solution":"local function encrypt(s)\n    local result = {}\n    local shift = 2 * 2\n    for i = 1, #s do\n        local char = s:sub(i,i)\n        if char:match(\"%a\") then\n            local ascii_offset = char:match(\"%l\") and string.byte('a') or string.byte('A')\n            local new_char = string.char(((string.byte(char) - ascii_offset + shift) % 26) + ascii_offset)\n            table.insert(result, new_char)\n        else\n            table.insert(result, char)\n        end\n    end\n    return table.concat(result)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encrypt\n    lu.assertEquals(candidate('hi'), 'lm')\n    lu.assertEquals(candidate('asdfghjkl'), 'ewhjklnop')\n    lu.assertEquals(candidate('gf'), 'kj')\n    lu.assertEquals(candidate('et'), 'ix')\n    lu.assertEquals(candidate('faewfawefaewg'), 'jeiajeaijeiak')\n    lu.assertEquals(candidate('hellomyfriend'), 'lippsqcjvmirh')\n    lu.assertEquals(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')\n    lu.assertEquals(candidate('a'), 'e')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_90","nl":"scn_Latn","pl":"lua","prompt":"- Ritorna null si nun esisti nu tali elementu. - Scrivi na funzioni next_smallest (n) ca torna lu secunnu cchiù nicu elementu dâ tàvula. - Vi sunnu dati na tàvula di nùmmura interi.-- >>> next_smallest({1, 2, 3, 4, 5})\n-- 2\n-- >>> next_smallest({5, 1, 4, 3, 2})\n-- 2\n-- >>> next_smallest({})\n-- None\n-- >>> next_smallest({1, 1})\n-- None\nlocal function next_smallest(lst)\n","canonical_solution":"local function next_smallest(lst)\n    if #lst < 2 then\n        return nil\n    end\n\n    table.sort(lst)\n\n    local first = lst[1]\n    for i = 2, #lst do\n        if lst[i] > first then\n            return lst[i]\n        end\n    end\n\n    return nil\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = next_smallest\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)\n    lu.assertEquals(candidate({5, 1, 4, 3, 2}), 2)\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({1, 1}), None)\n    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)\n    lu.assertEquals(candidate({1, 1}), None)\n    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_91","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - I frasi sò delimitati da \"\"., \"?' o \"!\". - di l'annoiamenti. - L'annoiamenti è na frasi ca accuminci cu la parola \"io\".- Vi sarà datu un filu di parolle, è u vostru compitu hè di cuntà u numeru.-- >>> is_bored('Hello world')\n-- 0\n-- >>> is_bored('The sky is blue. The sun is shining. I love this weather')\n-- 1\nlocal function is_bored(S)\n","canonical_solution":"local function is_bored(S)\n    local count = 0\n    -- Split the string into sentences using patterns\n    for sentence in S:gmatch(\"[^%.!?]+\") do\n        -- Trim leading whitespace from the sentence\n        sentence = sentence:gsub(\"^%s+\", \"\")\n        -- Check if the sentence starts with \"I\"\n        if sentence:sub(1, 1) == \"I\" then\n            count = count + 1\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_bored\n    lu.assertEquals(candidate('Hello world'), 0)\n    lu.assertEquals(candidate('Is the sky blue?'), 0)\n    lu.assertEquals(candidate('I love It !'), 1)\n    lu.assertEquals(candidate('bIt'), 0)\n    lu.assertEquals(candidate('I feel good today. I will be productive. will kill It'), 2)\n    lu.assertEquals(candidate('You and I are going for a walk'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_92","nl":"scn_Latn","pl":"lua","prompt":"- Esempi - Ritorna falsu nta tutti l'àutri casi.- Rinnova veru si unu di li numari è uguali a summa di l'àutri dui, e tutti li numari sunnu interi. - Crea na funzioni ca pigghia 3 nummari. -- >>> any_int(5, 2, 7)\n-- true\n-- >>> any_int(3, 2, 2)\n-- false\n-- >>> any_int(3, -2, 1)\n-- true\n-- >>> any_int(3.6, -2.2, 2)\n-- false\nlocal function any_int(x, y, z)\n","canonical_solution":"local function any_int(x, y, z)\n    if math.floor(x) == x and math.floor(y) == y and math.floor(z) == z then\n        if x == y + z or y == x + z or z == x + y then\n            return true\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = any_int\n    lu.assertEquals(candidate(2, 3, 1), true)\n    lu.assertEquals(candidate(2.5, 2, 3), false)\n    lu.assertEquals(candidate(1.5, 5, 3.5), false)\n    lu.assertEquals(candidate(2, 6, 2), false)\n    lu.assertEquals(candidate(4, 2, 2), true)\n    lu.assertEquals(candidate(2.2, 2.2, 2.2), false)\n    lu.assertEquals(candidate(-4, 6, 2), true)\n    lu.assertEquals(candidate(2, 1, 1), true)\n    lu.assertEquals(candidate(3, 4, 7), true)\n    lu.assertEquals(candidate(3.0, 4, 7), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_93","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Assumi sulu littri.- vucali ntô alfabetu ngrisi.- lu missaggiu cu la littra ca appaia 2 posti avanti di chissu - comu si cancia la cassa di tutti li littri, si sustituisci tutti li vucali di - Scrivi na funzioni ca pigghia nu missaggiu, e lu codifica 'n tali forma.-- >>> encode('test')\n-- 'TGST'\n-- >>> encode('This is a message')\n-- 'tHKS KS C MGSSCGG'\nlocal function encode(message)\n","canonical_solution":"local function encode(message)\n    local vowels = { a = 'c', e = 'g', i = 'k', o = 'q', u = 'w', A = 'C', E = 'G', I = 'K', O = 'Q', U = 'W' }\n    local encodedMessage = {}\n    \n    for i = 1, #message do\n        local char = message:sub(i, i)\n        \n        -- Swap case\n        if char:match('%l') then\n            char = char:upper()\n        else\n            char = char:lower()\n        end\n        \n        -- Replace vowels\n        if vowels[char] then\n            char = vowels[char]\n        end\n        \n        table.insert(encodedMessage, char)\n    end\n    \n    return table.concat(encodedMessage)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encode\n    lu.assertEquals(candidate('TEST'), 'tgst')\n    lu.assertEquals(candidate('Mudasir'), 'mWDCSKR')\n    lu.assertEquals(candidate('YES'), 'ygs')\n    lu.assertEquals(candidate('This is a message'), 'tHKS KS C MGSSCGG')\n    lu.assertEquals(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_94","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Haiu a truvari lu cchiù granni valuri primu e turnari la summa di li sò cifri. - Vi sunnu dati na tàvula di nùmmura interi.-- >>> skjkasdkd({0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n-- 10\n-- >>> skjkasdkd({1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n-- 25\n-- >>> skjkasdkd({1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n-- 13\n-- >>> skjkasdkd({0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n-- 11\n-- >>> skjkasdkd({0, 81, 12, 3, 1, 21})\n-- 3\n-- >>> skjkasdkd({0, 8, 1, 2, 1, 7})\n-- 7\nlocal function skjkasdkd(lst)\n","canonical_solution":"local function is_prime(n)\n    if n <= 1 then return false end\n    if n <= 3 then return true end\n    if n % 2 == 0 or n % 3 == 0 then return false end\n    for i = 5, math.sqrt(n), 6 do\n        if n % i == 0 or n % (i + 2) == 0 then return false end\n    end\n    return true\nend\n\nlocal function sum_of_digits(n)\n    local sum = 0\n    while n > 0 do\n        sum = sum + n % 10\n        n = math.floor(n \/ 10)\n    end\n    return sum\nend\n\nlocal function skjkasdkd(lst)\n    local largest_prime = -1\n    for _, v in ipairs(lst) do\n        if is_prime(v) and v > largest_prime then\n            largest_prime = v\n        end\n    end\n    if largest_prime == -1 then return 0 end\n    return sum_of_digits(largest_prime)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = skjkasdkd\n    lu.assertEquals(candidate({0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}), 10)\n    lu.assertEquals(candidate({1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), 25)\n    lu.assertEquals(candidate({1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), 13)\n    lu.assertEquals(candidate({0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), 11)\n    lu.assertEquals(candidate({0, 81, 12, 3, 1, 21}), 3)\n    lu.assertEquals(candidate({0, 8, 1, 2, 1, 7}), 7)\n    lu.assertEquals(candidate({8191}), 19)\n    lu.assertEquals(candidate({8191, 123456, 127, 7}), 19)\n    lu.assertEquals(candidate({127, 97, 8192}), 10)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_95","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - La funzioni avissi a riturnari false è la tavula data è vacanti. - case o tutti i tasti sunnu stringhi in maiuscola, altrimenti torna false. - Datu na tàvula, torna veru si tutti li chiavi sunnu stringhi in minuri -- >>> check_dict_case({['a'] = 'apple', ['b'] = 'banana'})\n-- true\n-- >>> check_dict_case({['a'] = 'apple', ['A'] = 'banana', ['B'] = 'banana'})\n-- false\n-- >>> check_dict_case({['a'] = 'apple', [8] = 'banana', ['a'] = 'apple'})\n-- false\n-- >>> check_dict_case({['Name'] = 'John', ['Age'] = '36', ['City'] = 'Houston'})\n-- false\n-- >>> check_dict_case({['STATE'] = 'NC', ['ZIP'] = '12345'})\n-- true\nlocal function check_dict_case(dict)\n","canonical_solution":"local function is_lowercase(s)\n    return s:lower() == s\nend\n\nlocal function is_uppercase(s)\n    return s:upper() == s\nend\n\nlocal function check_dict_case(dict)\n    if next(dict) == nil then\n        return false\n    end\n\n    local lower_case = nil\n    for key, _ in pairs(dict) do\n        if type(key) ~= 'string' then\n            return false\n        end\n        \n        if lower_case == nil then\n            lower_case = is_lowercase(key)\n        elseif lower_case ~= is_lowercase(key) then\n            return false\n        end\n    end\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = check_dict_case\n    lu.assertEquals(candidate({['p'] = 'pineapple', ['b'] = 'banana'}), true)\n    lu.assertEquals(candidate({['p'] = 'pineapple', ['A'] = 'banana', ['B'] = 'banana'}), false)\n    lu.assertEquals(candidate({['p'] = 'pineapple', ['5'] = 'banana', ['a'] = 'apple'}), false)\n    lu.assertEquals(candidate({['Name'] = 'John', ['Age'] = '36', ['City'] = 'Houston'}), false)\n    lu.assertEquals(candidate({['STATE'] = 'NC', ['ZIP'] = '12345'}), true)\n    lu.assertEquals(candidate({['fruit'] = 'Orange', ['taste'] = 'Sweet'}), true)\n    lu.assertEquals(candidate({}), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_96","nl":"scn_Latn","pl":"lua","prompt":"- pi esempiu: - intiri ca sunnu numari primi e cchiù picca di n. - Implementà una funzione chì piglia un intiru non negativu è torna una tavula di u primu n -- >>> count_up_to(5)\n-- {2, 3}\n-- >>> count_up_to(11)\n-- {2, 3, 5, 7}\n-- >>> count_up_to(0)\n-- {}\n-- >>> count_up_to(20)\n-- {2, 3, 5, 7, 11, 13, 17, 19}\n-- >>> count_up_to(1)\n-- {}\n-- >>> count_up_to(18)\n-- {2, 3, 5, 7, 11, 13, 17}\nlocal function count_up_to(n)\n","canonical_solution":"local function is_prime(num)\n    if num <= 1 then return false end\n    if num <= 3 then return true end\n    if num % 2 == 0 or num % 3 == 0 then return false end\n    local i = 5\n    while i * i <= num do\n        if num % i == 0 or num % (i + 2) == 0 then return false end\n        i = i + 6\n    end\n    return true\nend\n\nlocal function count_up_to(n)\n    local primes = {}\n    for i = 2, n - 1 do\n        if is_prime(i) then\n            table.insert(primes, i)\n        end\n    end\n    return primes\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_up_to\n    lu.assertEquals(candidate(5), {2, 3})\n    lu.assertEquals(candidate(6), {2, 3, 5})\n    lu.assertEquals(candidate(7), {2, 3, 5})\n    lu.assertEquals(candidate(10), {2, 3, 5, 7})\n    lu.assertEquals(candidate(0), {})\n    lu.assertEquals(candidate(22), {2, 3, 5, 7, 11, 13, 17, 19})\n    lu.assertEquals(candidate(1), {})\n    lu.assertEquals(candidate(18), {2, 3, 5, 7, 11, 13, 17})\n    lu.assertEquals(candidate(47), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43})\n    lu.assertEquals(candidate(101), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_97","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Assumemu ca l'input è sempri validu.- u pruduttu di i so cifri unitarii. - Cumpiendi la funzioni ca pigghia dui nterni e torna -- >>> multiply(148, 412)\n-- 16\n-- >>> multiply(19, 28)\n-- 72\n-- >>> multiply(2020, 1851)\n-- 0\n-- >>> multiply(14, -15)\n-- 20\nlocal function multiply(a, b)\n","canonical_solution":"local function multiply(a, b)\n    local unitDigitA = math.abs(a) % 10\n    local unitDigitB = math.abs(b) % 10\n    return unitDigitA * unitDigitB\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = multiply\n    lu.assertEquals(candidate(148, 412), 16)\n    lu.assertEquals(candidate(19, 28), 72)\n    lu.assertEquals(candidate(2020, 1851), 0)\n    lu.assertEquals(candidate(14, -15), 20)\n    lu.assertEquals(candidate(76, 67), 42)\n    lu.assertEquals(candidate(17, 27), 49)\n    lu.assertEquals(candidate(0, 1), 0)\n    lu.assertEquals(candidate(0, 0), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_98","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - Datu na stringa s, cuntari lu nùmmiru di vucali maiusculi ntê indici pari. -- >>> count_upper('aBCdEf')\n-- 1\n-- >>> count_upper('abcdefg')\n-- 0\n-- >>> count_upper('dBBE')\n-- 0\nlocal function count_upper(s)\n","canonical_solution":"local function count_upper(s)\n    local count = 0\n    local vowels = { A = true, E = true, I = true, O = true, U = true }\n    for i = 1, #s, 2 do\n        local char = s:sub(i, i)\n        if vowels[char] then\n            count = count + 1\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_upper\n    lu.assertEquals(candidate('aBCdEf'), 1)\n    lu.assertEquals(candidate('abcdefg'), 0)\n    lu.assertEquals(candidate('dBBE'), 0)\n    lu.assertEquals(candidate('B'), 0)\n    lu.assertEquals(candidate('U'), 1)\n    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('EEEE'), 2)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_99","nl":"scn_Latn","pl":"lua","prompt":"- Esempi - di dui nùmmari nteri, arrotondàla luntanu di zeru. - e torna lu nùmmuru nternu cchiù vicinu a iddu.- Crea na funzioni ca pigghia nu valuri (string) ca rapprisenta nu nùmmaru -- >>> closest_integer('10')\n-- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n","canonical_solution":"local function closest_integer(value)\n    local number = tonumber(value)\n    if not number then\n        error(\"Invalid number\")\n    end\n    if number > 0 then\n        return math.floor(number + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_100","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - i rapprisenta lu nùmmiru di petri ntô liveddu (i+1). - Ritorna lu nùmmiru di petri in ogni livellu in una tavula, unni elementu à indice - - lu prossimu nùmmuru pari si n è pari. - - lu prossimu nùmmuru paru si n è paru. - Lu nùmmuru di petri ntô prossimu liveddu è: - Lu primu livellu havi n petri.- Datu nu nùmmuru n, haiu a fari na pila di n livelli di petri.-- >>> make_a_pile(3)\n-- {3, 5, 7}\nlocal function make_a_pile(n)\n","canonical_solution":"local function make_a_pile(n)\n    local pile = {}\n    local current_stones = n\n    for i = 1, n do\n        table.insert(pile, current_stones)\n        if n % 2 == 0 then\n            current_stones = current_stones + 2\n        else\n            current_stones = current_stones + 2\n        end\n    end\n    return pile\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_a_pile\n    lu.assertEquals(candidate(3), {3, 5, 7})\n    lu.assertEquals(candidate(4), {4, 6, 8, 10})\n    lu.assertEquals(candidate(5), {5, 7, 9, 11, 13})\n    lu.assertEquals(candidate(6), {6, 8, 10, 12, 14, 16})\n    lu.assertEquals(candidate(8), {8, 10, 12, 14, 16, 18, 20, 22})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_101","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - a spartiri la stringa 'n palori e a riturnari na tavula di palori. - Vi sarà datu un filu di parolle siparate da virgulette o spazii.-- >>> words_string('Hi, my name is John')\n-- {'Hi', 'my', 'name', 'is', 'John'}\n-- >>> words_string('One, two, three, four, five, six')\n-- {'One', 'two', 'three', 'four', 'five', 'six'}\nlocal function words_string(s)\n","canonical_solution":"local function words_string(s)\n    local words = {}\n    for word in s:gmatch(\"[^,%s]+\") do\n        table.insert(words, word)\n    end\n    return words\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = words_string\n    lu.assertEquals(candidate('Hi, my name is John'), {'Hi', 'my', 'name', 'is', 'John'})\n    lu.assertEquals(candidate('One, two, three, four, five, six'), {'One', 'two', 'three', 'four', 'five', 'six'})\n    lu.assertEquals(candidate('Hi, my name'), {'Hi', 'my', 'name'})\n    lu.assertEquals(candidate('One,, two, three, four, five, six,'), {'One', 'two', 'three', 'four', 'five', 'six'})\n    lu.assertEquals(candidate(''), {})\n    lu.assertEquals(candidate('ahmed     , gamal'), {'ahmed', 'gamal'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_102","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - nun c'è nu nùmmuru tali, allura la funzioni avissi a riturnari -1. - lu cchiù granni nùmmuru pari ca è ntô raggu [x, y] inclusu.- Sta funzioni pigghia dui numari pusitivi x e y e torna lu -- >>> choose_num(12, 15)\n-- 14\n-- >>> choose_num(13, 12)\n-- -1\nlocal function choose_num(x, y)\n","canonical_solution":"local function choose_num(x, y)\n    -- Ensure x is the smaller and y is the larger\n    if x > y then\n        x, y = y, x\n    end\n    \n    -- Start from y and work backwards\n    for i = y, x, -1 do\n        if i % 2 == 0 then\n            return i\n        end\n    end\n    \n    -- If no even number is found\n    return -1\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = choose_num\n    lu.assertEquals(candidate(12, 15), 14)\n    lu.assertEquals(candidate(13, 12), -1)\n    lu.assertEquals(candidate(33, 12354), 12354)\n    lu.assertEquals(candidate(5234, 5233), -1)\n    lu.assertEquals(candidate(6, 29), 28)\n    lu.assertEquals(candidate(27, 10), -1)\n    lu.assertEquals(candidate(7, 7), -1)\n    lu.assertEquals(candidate(546, 546), 546)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_103","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - Si n è cchiù granni di m, torna -1. - Arrunci la risposta ô nùmmuru interi cchiù vicinu e cunvertilu a binariu.- media dî nùmmura interi da n a m (compresi n e m).- Vi sunnu dati dui nteri pusitivi n e m, e lu vostru compitu è di calculari la -- >>> rounded_avg(1, 5)\n-- '0b11'\n-- >>> rounded_avg(7, 5)\n-- -1\n-- >>> rounded_avg(10, 20)\n-- '0b1111'\n-- >>> rounded_avg(20, 33)\n-- '0b11010'\nlocal function rounded_avg(n, m)\n","canonical_solution":"local function rounded_avg(n, m)\n    if n > m then\n        return -1\n    end\n    \n    local sum = 0\n    local count = 0\n\n    for i = n, m do\n        sum = sum + i\n        count = count + 1\n    end\n\n    local average = sum \/ count\n    local rounded_avg = math.floor(average + 0.5)\n\n    return string.format(\"0b%d\", tonumber(string.format(\"%o\", rounded_avg), 8))\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rounded_avg\n    lu.assertEquals(candidate(1, 5), '0b11')\n    lu.assertEquals(candidate(7, 13), '0b1010')\n    lu.assertEquals(candidate(964, 977), '0b1111001010')\n    lu.assertEquals(candidate(996, 997), '0b1111100100')\n    lu.assertEquals(candidate(560, 851), '0b1011000010')\n    lu.assertEquals(candidate(185, 546), '0b101101110')\n    lu.assertEquals(candidate(362, 496), '0b110101101')\n    lu.assertEquals(candidate(350, 902), '0b1001110010')\n    lu.assertEquals(candidate(197, 233), '0b11010111')\n    lu.assertEquals(candidate(7, 5), -1)\n    lu.assertEquals(candidate(5, 1), -1)\n    lu.assertEquals(candidate(5, 5), '0b101')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_104","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - Nota: La tàvula riturnata avissi a èssiri ordinata pi l'urdinamentu crescenti.- elementi ca nun hannu nuddu nummaru pari. - Datu na tàvula di nterni pusitivi x. riturnari na tàvula ordinata di tutti -- >>> unique_digits({15, 33, 1422, 1})\n-- {1, 15, 33}\n-- >>> unique_digits({152, 323, 1422, 10})\n-- {}\nlocal function unique_digits(x)\n","canonical_solution":"local function has_even_digit(num)\n    while num > 0 do\n        local digit = num % 10\n        if digit % 2 == 0 then\n            return true\n        end\n        num = math.floor(num \/ 10)\n    end\n    return false\nend\n\nlocal function unique_digits(x)\n    local result = {}\n    for _, num in ipairs(x) do\n        if not has_even_digit(num) then\n            table.insert(result, num)\n        end\n    end\n    table.sort(result)\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = unique_digits\n    lu.assertEquals(candidate({15, 33, 1422, 1}), {1, 15, 33})\n    lu.assertEquals(candidate({152, 323, 1422, 10}), {})\n    lu.assertEquals(candidate({12345, 2033, 111, 151}), {111, 151})\n    lu.assertEquals(candidate({135, 103, 31}), {31, 135})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_105","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - \"Unu\", \"Dui\", \"Tri\", \"Quattru\", \"Cincu\", \"Sei\", \"Sette\", \"Ottu\", \"Nove\".- inverte a tavula risultante, è poi rimpiazza ogni cifra cù u so nome currispundente da - Datu na tavula di nùmmura interi, ordinati li nùmmura interi ca sunnu tra 1 e 9 cumprisu, -- >>> by_length({2, 1, 1, 4, 5, 8, 2, 3})\n-- {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'}\n--   If the table is empty, return an empty table:\n-- >>> by_length({})\n-- {}\n--   If the table has any strange number ignore it:\n-- >>> by_length({1, -1, 55})\n-- {'One'}\nlocal function by_length(arr)\n","canonical_solution":"local function by_length(arr)\n    local digits_names = {\n        [1] = \"One\", [2] = \"Two\", [3] = \"Three\", [4] = \"Four\", [5] = \"Five\",\n        [6] = \"Six\", [7] = \"Seven\", [8] = \"Eight\", [9] = \"Nine\"\n    }\n\n    local filtered = {}\n    for _, num in ipairs(arr) do\n        if num >= 1 and num <= 9 then\n            table.insert(filtered, num)\n        end\n    end\n\n    table.sort(filtered, function(a, b) return a > b end)\n\n    for i, num in ipairs(filtered) do\n        filtered[i] = digits_names[num]\n    end\n\n    return filtered\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = by_length\n    lu.assertEquals(candidate({2, 1, 1, 4, 5, 8, 2, 3}), {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, -1, 55}), {'One'})\n    lu.assertEquals(candidate({1, -1, 3, 2}), {'Three', 'Two', 'One'})\n    lu.assertEquals(candidate({9, 4, 8}), {'Nine', 'Eight', 'Four'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_106","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - lu faturiariu di i è la multiplicazzioni dî nùmmura di 1 a i (1 * 2 * ... * i).- I accumincia da 1. - o la summa dî nùmmura di 1 a i altrimenti. - e torna na tavula di grannizza n, accussì ca lu valuri di l'elimentu a l'indici i è lu fatturialu di i si i è pari - Implementari la funzioni f ca pigghia n comu paramaturu, -- >>> f(5)\n-- {1, 2, 6, 24, 15}\nlocal function f(n)\n","canonical_solution":"local function factorial(x)\n    if x == 0 then\n        return 1\n    else\n        local result = 1\n        for i = 2, x do\n            result = result * i\n        end\n        return result\n    end\nend\n\nlocal function sum_to_i(x)\n    return (x * (x + 1)) \/\/ 2\nend\n\nlocal function f(n)\n    local result = {}\n    for i = 1, n do\n        if i % 2 == 0 then\n            result[i] = factorial(i)\n        else\n            result[i] = sum_to_i(i)\n        end\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = f\n    lu.assertEquals(candidate(5), {1, 2, 6, 24, 15})\n    lu.assertEquals(candidate(7), {1, 2, 6, 24, 15, 720, 28})\n    lu.assertEquals(candidate(1), {1})\n    lu.assertEquals(candidate(3), {1, 2, 6})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_107","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu 1: - palindromi di nùmmari nterni ca cadinu ntô raggu {1, n), inclusi. - Datu nu nùmmaru interu pusitivu n, riturnamu na tàvula ca havi lu nùmmaru di pari e dispari -- >>> even_odd_palindrome(3)\n-- {1, 2}\n--     Explanation:\n--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n-- Example 2:\n-- >>> even_odd_palindrome(12)\n-- {4, 6}\n--     Explanation:\n--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n-- Note:\n--     1. 1 <= n <= 10^3\n--     2. returned table has the number of even and odd integer palindromes respectively.\nlocal function even_odd_palindrome(n)\n","canonical_solution":"local function is_palindrome(num)\n    local str = tostring(num)\n    return str == string.reverse(str)\nend\n\nlocal function even_odd_palindrome(n)\n    local even_count = 0\n    local odd_count = 0\n\n    for i = 1, n do\n        if is_palindrome(i) then\n            if i % 2 == 0 then\n                even_count = even_count + 1\n            else\n                odd_count = odd_count + 1\n            end\n        end\n    end\n\n    return {even_count, odd_count}\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = even_odd_palindrome\n    lu.assertEquals(candidate(123), {8, 13})\n    lu.assertEquals(candidate(12), {4, 6})\n    lu.assertEquals(candidate(3), {1, 2})\n    lu.assertEquals(candidate(63), {6, 8})\n    lu.assertEquals(candidate(25), {5, 6})\n    lu.assertEquals(candidate(19), {4, 6})\n    lu.assertEquals(candidate(9), {4, 5})\n    lu.assertEquals(candidate(1), {0, 1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_108","nl":"scn_Latn","pl":"lua","prompt":"- p'esempiu -123 havi li cifri -1, 2 e 3. - Si nu nùmmaru è negativu, allura la sò prima cifra firmata sarà negativa: - u nùmmaru di elementi chì hà una summa di cifri > 0. - Scrivi na funzioni count_nums ca pigghia na tàvula di nùmmura interi e torna -- >>> count_nums({})\n-- 0\n-- >>> count_nums({-1, 11, -11})\n-- 1\n-- >>> count_nums({1, 1, 2})\n-- 3\nlocal function count_nums(arr)\n","canonical_solution":"local function count_nums(arr)\n    local function sum_of_digits(num)\n        local sum = 0\n        local is_negative = num < 0\n        num = math.abs(num)\n        while num > 0 do\n            sum = sum + (num % 10)\n            num = math.floor(num \/ 10)\n        end\n        if is_negative then\n            sum = sum - 2 * (math.floor(math.abs(arr[index]) \/ 10 ^ (math.floor(math.log10(math.abs(arr[index]))))))\n        end\n        return sum\n    end\n\n    local count = 0\n    for _, num in ipairs(arr) do\n        local digit_sum = sum_of_digits(num)\n        if digit_sum > 0 then\n            count = count + 1\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_nums\n    lu.assertEquals(candidate({}), 0)\n    lu.assertEquals(candidate({-1, -2, 0}), 0)\n    lu.assertEquals(candidate({1, 1, 2, -2, 3, 4, 5}), 6)\n    lu.assertEquals(candidate({1, 6, 9, -6, 0, 1, 5}), 5)\n    lu.assertEquals(candidate({1, 100, 98, -7, 1, -1}), 4)\n    lu.assertEquals(candidate({12, 23, 34, -45, -56, 0}), 5)\n    lu.assertEquals(candidate({0, 1}), 1)\n    lu.assertEquals(candidate({1}), 1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_109","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - Nota: La tàvula data è garantita di aviri elementi ùnici.- Se la tavula data è vacanti poi torna veru. - poi torna veru altrimenti torna falsu. - Se hè pussibule ottene a tavula ordinata realizendu l'operazione sopra citata - la pusizzioni di partenza ntâ tavula, ossia l'indici 0°.- pusizzioni ntâ direzzioni giusta. L'ùrtimu elementu dâ tàvula sarà spustatu â - Na operazzioni di spustamentu a destra significa spustà tutti l'elementi di a tavula di unu - Si pò fari l'operazzioni di spustamentu a destra ogni numaru di voti.- l'operazzioni siguenti nta la tàvula data: - è pussìbbili pigghiari na tàvula ordinata n ordini nun decrescenti facennu - numari ntâ tavula vennu urdinati a casu.- Avemu na tàvula 'arr' di N nùmmura interi arr[1], arr[2], ..., arr[N].-- >>> move_one_ball({3, 4, 5, 1, 2})\n-- true\n-- Explanation: By performin 2 right shift operations, non-decreasing order can\n--              be achieved for the given table.\n-- >>> move_one_ball({3, 5, 4, 1, 2})\n-- false\n-- Explanation:It is not possible to get non-decreasing order for the given\n--             table by performing any number of right shift operations.\nlocal function move_one_ball(arr)\n","canonical_solution":"local function move_one_ball(arr)\n    local n = #arr\n    if n == 0 then\n        return true\n    end\n\n    local count_descending_pairs = 0\n\n    for i = 1, n do\n        if arr[i] > arr[(i % n) + 1] then\n            count_descending_pairs = count_descending_pairs + 1\n        end\n        if count_descending_pairs > 1 then\n            return false\n        end\n    end\n\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = move_one_ball\n    lu.assertEquals(candidate({3, 4, 5, 1, 2}), true)\n    lu.assertEquals(candidate({3, 5, 10, 1, 2}), true)\n    lu.assertEquals(candidate({4, 3, 1, 2}), false)\n    lu.assertEquals(candidate({3, 5, 4, 1, 2}), false)\n    lu.assertEquals(candidate({}), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_110","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - Altrimenti, torna \"NO\".- tutti l'elementi di lst1 à esse pari, torna \"SI\". - Se hè pussibule scambià elementi trà lst1 è lst2 per fà - Ùn ci hè micca limitu à u numeru di elementi scambiati trà lst1 è lst2. - tra di l'altri pi fari l'lst1 na tàvula di sulu nummari pari. - e determina si è pussibili di fà un scambiu d'elementi - In stu prubblema, tu ti nniplimintari na funzioni ca pigghia dui tavuli di numari, -- >>> exchange({1, 2, 3, 4}, {1, 2, 3, 4})\n-- 'YES'\n-- >>> exchange({1, 2, 3, 4}, {1, 5, 3, 4})\n-- 'NO'\n-- It is assumed that the input tables will be non-empty.\nlocal function exchange(lst1, lst2)\n","canonical_solution":"local function exchange(lst1, lst2)\n    local is_all_even = true\n    local odd_count_lst1 = 0\n    local even_count_lst2 = 0\n\n    -- Check lst1 for odd numbers\n    for _, num in ipairs(lst1) do\n        if num % 2 ~= 0 then\n            odd_count_lst1 = odd_count_lst1 + 1\n        end\n    end\n\n    -- Check lst2 for even numbers\n    for _, num in ipairs(lst2) do\n        if num % 2 == 0 then\n            even_count_lst2 = even_count_lst2 + 1\n        end\n    end\n\n    -- It is possible to make lst1 all even if the number of odd elements\n    -- in lst1 can be swapped with the number of even elements in lst2\n    if odd_count_lst1 <= even_count_lst2 then\n        return \"YES\"\n    else\n        return \"NO\"\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = exchange\n    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 2, 3, 4}), 'YES')\n    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 5, 3, 4}), 'NO')\n    lu.assertEquals(candidate({1, 2, 3, 4}, {2, 1, 4, 3}), 'YES')\n    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 4}), 'YES')\n    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 3}), 'NO')\n    lu.assertEquals(candidate({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}), 'NO')\n    lu.assertEquals(candidate({100, 200}, {200, 200}), 'YES')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_111","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - Si diversi littri hannu la stissa prisenza, riturnari tutti.- di la littra cu la cchiù ripetizzioni e ca cunteni lu cunti currispunnenti. - Datu na stringa ca rapprisenta na littra minuri separata di spazziu, riturna na tàvula -- >>> histogram('a b c')\n-- {['a'] = 1, ['b'] = 1, ['c'] = 1}\n-- >>> histogram('a b b a')\n-- {['a'] = 2, ['b'] = 2}\n-- >>> histogram('a b c a b')\n-- {['a'] = 2, ['b'] = 2}\n-- >>> histogram('b b b b a')\n-- {['b'] = 4}\n-- >>> histogram('')\n-- {}\nlocal function histogram(test)\n","canonical_solution":"local function histogram(test)\n    if test == \"\" then return {} end\n    \n    local words = {}\n    for word in test:gmatch(\"%S\") do\n        words[word] = (words[word] or 0) + 1\n    end\n    \n    local max_count = 0\n    local result = {}\n    for letter, count in pairs(words) do\n        if count > max_count then\n            max_count = count\n            result = {[letter] = count}\n        elseif count == max_count then\n            result[letter] = count\n        end\n    end\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = histogram\n    lu.assertEquals(candidate('a b b a'), {['a'] = 2, ['b'] = 2})\n    lu.assertEquals(candidate('a b c a b'), {['a'] = 2, ['b'] = 2})\n    lu.assertEquals(candidate('a b c d g'), {['a'] = 1, ['b'] = 1, ['c'] = 1, ['d'] = 1, ['g'] = 1})\n    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})\n    lu.assertEquals(candidate('b b b b a'), {['b'] = 4})\n    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})\n    lu.assertEquals(candidate(''), {})\n    lu.assertEquals(candidate('a'), {['a'] = 1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_112","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu - Tu avissi a turnari na tavula chi cunteni la stringa di risurtati e veru\/falsu pi lu cuntrollu.- Na stringa è chiamata palindromu si leggi la stissa cosa avanti e arreri.- poi cuntrolla si la stringa di risurtatu è palindromu. - Ci sunnu dati dui stringhi s e c, tu hai a cancellari tutti li caratteri in s ca sunnu uguali a ogni caratteri in c - Tasca -- >>> reverse_delete('abcde', 'ae')\n-- {'bcd', false}\n-- >>> reverse_delete('abcdef', 'b')\n-- {'acdef', false}\n-- >>> reverse_delete('abcdedcba', 'ab')\n-- {'cdedc', true}\nlocal function reverse_delete(s, c)\n","canonical_solution":"local function reverse_delete(s, c)\n    -- Create a set for characters to delete\n    local delete_set = {}\n    for i = 1, #c do\n        delete_set[c:sub(i, i)] = true\n    end\n    \n    -- Create the result string by filtering out characters in delete_set\n    local result = {}\n    for i = 1, #s do\n        local char = s:sub(i, i)\n        if not delete_set[char] then\n            table.insert(result, char)\n        end\n    end\n    \n    -- Convert result table to string\n    local result_str = table.concat(result)\n    \n    -- Check if the result string is a palindrome\n    local is_palindrome = true\n    local len = #result_str\n    for i = 1, math.floor(len \/ 2) do\n        if result_str:sub(i, i) ~= result_str:sub(len - i + 1, len - i + 1) then\n            is_palindrome = false\n            break\n        end\n    end\n    \n    -- Return the result string and palindrome check as a table\n    return {result_str, is_palindrome}\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = reverse_delete\n    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})\n    lu.assertEquals(candidate('abcdef', 'b'), {'acdef', false})\n    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc', true})\n    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})\n    lu.assertEquals(candidate('a', 'a'), {'', true})\n    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba', true})\n    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})\n    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})\n    lu.assertEquals(candidate('mamma', 'mia'), {'', true})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_113","nl":"scn_Latn","pl":"lua","prompt":"- di cifre dispari in u i'th string di l 'input. - string i di l'input. \" unni tutti i's avissiru a èssiri rimpiazzati cu lu nùmmuru - Ogni elementu i di l'output deve esse u numeru di elementi dispari in u - Datu na tàvula di stringhi, unni ogni stringhi è cumpostu sulu di cifri, riturnari na tàvula. -- >>> odd_count({'1234567'})\n-- {'the number of odd elements 4n the str4ng 4 of the 4nput.'}\n-- >>> odd_count({'3', '11111111'})\n-- {'the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'}\nlocal function odd_count(lst)\n","canonical_solution":"local function odd_count(lst)\n    local result = {}\n    for _, str in ipairs(lst) do\n        local odd_count = 0\n        for i = 1, #str do\n            local digit = tonumber(str:sub(i, i))\n            if digit % 2 == 1 then\n                odd_count = odd_count + 1\n            end\n        end\n        local element = string.format(\"the number of odd elements %dn the str%1dng %d of the %d\", odd_count, odd_count, odd_count, odd_count)\n        result[#result + 1] = element\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = odd_count\n    lu.assertEquals(candidate({'1234567'}), {'the number of odd elements 4n the str4ng 4 of the 4nput.'})\n    lu.assertEquals(candidate({'3', '11111111'}), {'the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'})\n    lu.assertEquals(candidate({'271', '137', '314'}), {'the number of odd elements 2n the str2ng 2 of the 2nput.', 'the number of odd elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng 2 of the 2nput.'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_114","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu - di numari. - Datu na tàvula di nùmmura ntieri, trova la summa mìnima di ogni sutta-tàvula nun vacanti -- >>> minSubArraySum({2, 3, 4, 1, 2, 4})\n-- 1\n-- >>> minSubArraySum({-1, -2, -3})\n-- -6\nlocal function minSubArraySum(nums)\n","canonical_solution":"local function minSubArraySum(nums)\n    local min_sum = nums[1]\n    local current_sum = nums[1]\n\n    for i = 2, #nums do\n        current_sum = math.min(nums[i], current_sum + nums[i])\n        min_sum = math.min(min_sum, current_sum)\n    end\n\n    return min_sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = minSubArraySum\n    lu.assertEquals(candidate({2, 3, 4, 1, 2, 4}), 1)\n    lu.assertEquals(candidate({-1, -2, -3}), -6)\n    lu.assertEquals(candidate({-1, -2, -3, 2, -10}), -14)\n    lu.assertEquals(candidate({-9999999999999999}), -9999999999999999)\n    lu.assertEquals(candidate({0, 10, 20, 1000000}), 0)\n    lu.assertEquals(candidate({-1, -2, -3, 10, -5}), -6)\n    lu.assertEquals(candidate({100, -1, -2, -3, 10, -5}), -6)\n    lu.assertEquals(candidate({10, 11, 13, 8, 3, 4}), 3)\n    lu.assertEquals(candidate({100, -33, 32, -1, 0, -2}), -33)\n    lu.assertEquals(candidate({-10}), -10)\n    lu.assertEquals(candidate({7}), 7)\n    lu.assertEquals(candidate({1, -1}), -1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_115","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu 1: - Metti lu nùmmiru di voti ca ti servi pi abbasciari li vasuni.- U vostru compitu è di usari i secchi pi svuotari li pozzi.- e tutti li secchi hannu la stissa capacità.- Ogni pozzu havi nu cucchiaru currispunnenti ca si pò usari pi estrarri acqua,- e ogni 1 'n fila rapprisenta na sula unità d'acqua. - Vi veni datu na griglia rittangulari di pozzi.-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n-- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}}, 5)\n-- 0\n-- Constraints:\n--     * all wells have the same length\n--     * 1 <= grid.length <= 10^2\n--     * 1 <= grid[:,1].length <= 10^2\n--     * grid[i][j] -> 0 | 1\n--     * 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n","canonical_solution":"local function max_fill(grid, capacity)\n    local total_units = 0\n\n    -- Traverse each well in the grid\n    for i = 1, #grid do\n        for j = 1, #grid[i] do\n            total_units = total_units + grid[i][j]\n        end\n    end\n\n    -- Calculate the number of times the bucket needs to be lowered\n    local num_lowerings = math.ceil(total_units \/ capacity)\n\n    return num_lowerings\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_116","nl":"scn_Latn","pl":"lua","prompt":"- Lu deve esse attuatu cusì: - Pi nu nùmmiru simili di unu, ordinari a basi di valuri dicimali.- numaru di unu in a so rapprisintazioni binaria in ordine ascendente. - In stu Kata, tu hai a ordinari na tavula di nentieri nun nigativi secunnu -- >>> sort_array({1, 5, 2, 3, 4})\n-- {1, 2, 3, 4, 5}\n-- >>> sort_array({-2, -3, -4, -5, -6})\n-- {-6, -5, -4, -3, -2}\n-- >>> sort_array({1, 0, 2, 3, 4})\n-- {0, 1, 2, 3, 4}\nlocal function sort_array(arr)\n","canonical_solution":"local function count_ones(n)\n    local count = 0\n    while n > 0 do\n        count = count + (n % 2)\n        n = math.floor(n \/ 2)\n    end\n    return count\nend\n\nlocal function sort_array(arr)\n    table.sort(arr, function(a, b)\n        local ones_a = count_ones(math.abs(a))\n        local ones_b = count_ones(math.abs(b))\n        if ones_a == ones_b then\n            return a < b\n        else\n            return ones_a < ones_b\n        end\n    end)\n    return arr\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_array\n    lu.assertEquals(candidate({1, 5, 2, 3, 4}), {1, 2, 4, 3, 5})\n    lu.assertEquals(candidate({-2, -3, -4, -5, -6}), {-4, -2, -6, -5, -3})\n    lu.assertEquals(candidate({1, 0, 2, 3, 4}), {0, 1, 2, 4, 3})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77})\n    lu.assertEquals(candidate({3, 6, 44, 12, 32, 5}), {32, 3, 5, 6, 12, 44})\n    lu.assertEquals(candidate({2, 4, 8, 16, 32}), {2, 4, 8, 16, 32})\n    lu.assertEquals(candidate({2, 4, 8, 16, 32}), {2, 4, 8, 16, 32})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_117","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Nota: si pò suppuniri ca la stringa di input cunteni sulu littri e spazzi. - Si la stringa s è vacanti allura la funzioni avissi a riturnari na tavula vacanti. - n cunsunanti, pi fari cumpariri sti palori ntâ stringa s. - na funzioni ca riturna na tàvula di tutti li palori di stringa s ca cuntèninu esattamente - Datu na stringa s e nu nùmmuru naturali n, haiu statu incaricatu di implementari -- >>> select_words('Mary had a little lamb', 4)\n-- {'little'}\n-- >>> select_words('Mary had a little lamb', 3)\n-- {'Mary', 'lamb'}\n-- >>> select_words('simple white space', 2)\n-- {}\n-- >>> select_words('Hello world', 4)\n-- {'world'}\n-- >>> select_words('Uncle sam', 3)\n-- {'Uncle'}\nlocal function select_words(s, n)\n","canonical_solution":"local function select_words(s, n)\n    local vowels = { a = true, e = true, i = true, o = true, u = true,\n                     A = true, E = true, I = true, O = true, U = true }\n    local result = {}\n    \n    for word in s:gmatch(\"%S+\") do\n        local consonant_count = 0\n        for char in word:gmatch(\"%a\") do\n            if not vowels[char] then\n                consonant_count = consonant_count + 1\n            end\n        end\n        if consonant_count == n then\n            table.insert(result, word)\n        end\n    end\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = select_words\n    lu.assertEquals(candidate('Mary had a little lamb', 4), {'little'})\n    lu.assertEquals(candidate('Mary had a little lamb', 3), {'Mary', 'lamb'})\n    lu.assertEquals(candidate('simple white space', 2), {})\n    lu.assertEquals(candidate('Hello world', 4), {'world'})\n    lu.assertEquals(candidate('Uncle sam', 3), {'Uncle'})\n    lu.assertEquals(candidate('', 4), {})\n    lu.assertEquals(candidate('a b c d e f', 1), {'b', 'c', 'd', 'f'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_118","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - Si pò suppuniri ca la stringa datu cunteni littra inglese solu. - truvà qualchì vucale chì risponde à a cundizione sopra. - Vocali all'inizziu e a la fini nun cuntanu.- dui cunsunanti da u latu drittu di a parolla (sensibili à a cassa). - Vi veni datu na parola, u vostru compitu è truvari la vucali cchiù vicina ca sta 'ntra-- >>> get_closest_vowel('yogurt')\n-- 'u'\n-- >>> get_closest_vowel('FULL')\n-- 'U'\n-- >>> get_closest_vowel('quick')\n-- ''\n-- >>> get_closest_vowel('ab')\n-- ''\nlocal function get_closest_vowel(word)\n","canonical_solution":"local function get_closest_vowel(word)\n    local vowels = \"AEIOUaeiou\"\n    local found_vowel = false\n    local last_consonant = false\n\n    for i = #word - 1, 2, -1 do\n        local char = word:sub(i, i)\n        if vowels:find(char) then\n            if last_consonant then\n                return char\n            end\n            found_vowel = true\n        else\n            if found_vowel then\n                return ''\n            end\n            last_consonant = true\n        end\n    end\n\n    return ''\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_closest_vowel\n    lu.assertEquals(candidate('yogurt'), 'u')\n    lu.assertEquals(candidate('full'), 'u')\n    lu.assertEquals(candidate('easy'), '')\n    lu.assertEquals(candidate('eAsy'), '')\n    lu.assertEquals(candidate('ali'), '')\n    lu.assertEquals(candidate('bad'), 'a')\n    lu.assertEquals(candidate('most'), 'o')\n    lu.assertEquals(candidate('ab'), '')\n    lu.assertEquals(candidate('ba'), '')\n    lu.assertEquals(candidate('quick'), '')\n    lu.assertEquals(candidate('anime'), 'i')\n    lu.assertEquals(candidate('Asia'), '')\n    lu.assertEquals(candidate('Above'), 'o')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_119","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Ritorna 'Sì' si c'è na manera di fari na bona stringa, e ritorna 'No' altrimenti. - \"()) \" nun è.- sunnu abbalansati. p'asempiu: la stringa '(((() ' è bona, mentri la stringa - Na stringa S è cunzidirata bona si e sulu si tutti li parentizzi ntâ S - qualchi ordine, ca la stringa risurtante sarà bona.- Lu to travagghiu è di vidiri si è pussìbbili ccatinari li dui fili 'n- sulu li parentizzi \" ((\") o li parentizzi chiusi \") \".- Vi sunnu dati na tàvula di dui fili, tutti dui fili custituisci di aperta -- >>> match_parens({'()(', ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n","canonical_solution":"local function match_parens(lst)\n    local function is_balanced(s)\n        local balance = 0\n        for i = 1, #s do\n            if s:sub(i,i) == '(' then\n                balance = balance + 1\n            else\n                balance = balance - 1\n            end\n\n            if balance < 0 then\n                return false\n            end\n        end\n        return balance == 0\n    end\n\n    local s1, s2 = lst[1], lst[2]\n    return (is_balanced(s1 .. s2) or is_balanced(s2 .. s1)) and 'Yes' or 'No'\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_120","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu 1: - di lunghezza k cù u massimu di k numeri in arr. - Datu na tàvula arr di nùmmura interi e nu nùmmuru interi pusitivu k, riturna na tàvula ordinata -- >>> maximum({-3, -4, 5}, 3)\n-- {-4, -3, 5}\n-- Example 2:\n-- >>> maximum({4, -4, 4}, 2)\n-- {4, 4}\n-- Example 3:\n-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)\n-- {2}\n-- Note:\n--     1. The length of the table will be in the range of [1, 1000].\n--     2. The elements in the table will be in the range of [-1000, 1000].\n--     3. 0 <= k <= len(arr)\nlocal function maximum(arr, k)\n","canonical_solution":"local function maximum(arr, k)\n    table.sort(arr, function(a, b) return a > b end)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, arr[i])\n    end\n    table.sort(result)\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = maximum\n    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})\n    lu.assertEquals(candidate({4, -4, 4}, 2), {4, 4})\n    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1), {2})\n    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123})\n    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})\n    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15})\n    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})\n    lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})\n    lu.assertEquals(candidate({4, -4}, 2), {-4, 4})\n    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})\n    lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_121","nl":"scn_Latn","pl":"lua","prompt":"- Esempi - Datu na tavula di nùmmura nteri nun vacanti, riturnari la summa di tutti l'elementi paru ca sunnu in pusizzioni pari. -- >>> solution({5, 8, 7, 1})\n-- 12\n-- >>> solution({3, 3, 3, 3, 3})\n-- 9\n-- >>> solution({30, 13, 24, 321})\n-- 0\nlocal function solution(lst)\n","canonical_solution":"local function solution(lst)\n    local sum = 0\n    for i = 2, #lst, 2 do\n        if lst[i] % 2 == 1 then\n            sum = sum + lst[i]\n        end\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = solution\n    lu.assertEquals(candidate({5, 8, 7, 1}), 12)\n    lu.assertEquals(candidate({3, 3, 3, 3, 3}), 9)\n    lu.assertEquals(candidate({30, 13, 24, 321}), 0)\n    lu.assertEquals(candidate({5, 9}), 5)\n    lu.assertEquals(candidate({2, 4, 8}), 0)\n    lu.assertEquals(candidate({30, 13, 23, 32}), 23)\n    lu.assertEquals(candidate({3, 13, 2, 9}), 3)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_122","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - a summa di l'elementi cù almenu duie cifre da i primi k elementi di arr. - Datu na tàvula nun vacanti di nùmmura interi arr e n'entieru k, ritorna -- >>> add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n-- 24\n-- Constraints:\n--     1. 1 <= len(arr) <= 100\n--     2. 1 <= k <= len(arr)\nlocal function add_elements(arr, k)\n","canonical_solution":"local function add_elements(arr, k)\n    local sum = 0\n    for i = 1, k do\n        local element = arr[i]\n        if element >= -99 and element <= 99 then\n            sum = sum + element\n        end\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = add_elements\n    lu.assertEquals(candidate({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), -4)\n    lu.assertEquals(candidate({111, 121, 3, 4000, 5, 6}, 2), 0)\n    lu.assertEquals(candidate({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), 125)\n    lu.assertEquals(candidate({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), 24)\n    lu.assertEquals(candidate({1}, 1), 1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_123","nl":"scn_Latn","pl":"lua","prompt":"- get_odd_collatz(5) torna [1, 5] # La sequenza di collatz pi 5 è [5, 16, 8, 4, 2, 1], accussì li nummari dispari sunnu sulu 1, e 5. - Pi esempiu: - 2. tavula riturnata ordinata pi l'urdinamentu crescenti.- 1. Collatz(1) è [1]. - Nota: - tèrmini cchiù 1. La cunicitura è ca nun importa chi valuri di n, la siquenza arrivi sempri a 1. Se u termu precedente è dispari, u termu prossimu hè 3 volte u termu precedente.- tèrmini pricidenti comu siguenti: si lu tèrmini pricidenti è pari, lu prossimu tèrmini è la mità di - comu siguenti: accuminza cu ogni nùmmuru interu pusitivu n. Poi ogni tèrmini veni ottinutu dâ - La cunicitura di Collatz è na cunicitura di matimàtica ca riguarda na siquenza difinuta - Datu nu nùmmaru n, riturnari na tàvula ordinata ca havi li nùmmari dispari n sequenza collatz. -- >>> get_odd_collatz(5)\n-- {1, 5}\nlocal function get_odd_collatz(n)\n","canonical_solution":"local function get_odd_collatz(n)\n    local collatz_sequence = {}\n    while n ~= 1 do\n        if n % 2 == 1 then\n            table.insert(collatz_sequence, n)\n        end\n        if n % 2 == 0 then\n            n = n \/ 2\n        else\n            n = 3 * n + 1\n        end\n    end\n    table.insert(collatz_sequence, 1)  -- Always add 1 as the sequence ends with 1\n    \n    -- Remove duplicates and sort the table\n    local unique_odds = {}\n    for _, num in ipairs(collatz_sequence) do\n        unique_odds[num] = true\n    end\n\n    local sorted_odds = {}\n    for num, _ in pairs(unique_odds) do\n        table.insert(sorted_odds, num)\n    end\n    table.sort(sorted_odds)\n\n    return sorted_odds\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_odd_collatz\n    lu.assertEquals(candidate(14), {1, 5, 7, 11, 13, 17})\n    lu.assertEquals(candidate(5), {1, 5})\n    lu.assertEquals(candidate(12), {1, 3, 5})\n    lu.assertEquals(candidate(1), {1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_124","nl":"scn_Latn","pl":"lua","prompt":"- 4. A data deve esse in u furmatu: mm-dd-yyyy - 3. I mesi ùn devenu micca esse menu di 1 o più di 12.- 2. lu nùmmiru di jorna nun è cchiù picca di 1 o cchiù granni di 31 jorna pi li misi 1,3,5,7,8,10,12. e lu nùmmiru di jorna nun è cchiù picca di 1 o cchiù granni di 30 jorna pi li misi 4,6,9,11. e, lu nùmmiru di jorna nun è cchiù picca di 1 o cchiù granni di 29 jorna pi lu misi 2.- 1. La stringa di data nun è vacanti.- A data hè valida s'ellu sò soddisfatti tutti i règuli seguenti: - torna veru si la data è valida altrimenti falsa. - Tu hai a scriviri na funzioni ca validi na data data string e -- >>> valid_date('03-11-2000')\n-- true\n-- >>> valid_date('15-01-2012')\n-- false\n-- >>> valid_date('04-0-2040')\n-- false\n-- >>> valid_date('06-04-2020')\n-- true\n-- >>> valid_date('06\/04\/2020')\n-- false\nlocal function valid_date(date)\n","canonical_solution":"local function valid_date(date)\n    if date == \"\" then\n        return false\n    end\n    \n    local month, day, year = date:match(\"^(%d%d)%-(%d%d)%-(%d%d%d%d)$\")\n    \n    if not month or not day or not year then\n        return false\n    end\n    \n    month = tonumber(month)\n    day = tonumber(day)\n    year = tonumber(year)\n    \n    if month < 1 or month > 12 then\n        return false\n    end\n    \n    local days_in_month = {\n        [1] = 31,\n        [2] = 29, -- Leap year check not required for this problem\n        [3] = 31,\n        [4] = 30,\n        [5] = 31,\n        [6] = 30,\n        [7] = 31,\n        [8] = 31,\n        [9] = 30,\n        [10] = 31,\n        [11] = 30,\n        [12] = 31\n    }\n    \n    if day < 1 or day > days_in_month[month] then\n        return false\n    end\n    \n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = valid_date\n    lu.assertEquals(candidate('03-11-2000'), true)\n    lu.assertEquals(candidate('15-01-2012'), false)\n    lu.assertEquals(candidate('04-0-2040'), false)\n    lu.assertEquals(candidate('06-04-2020'), true)\n    lu.assertEquals(candidate('01-01-2007'), true)\n    lu.assertEquals(candidate('03-32-2011'), false)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('04-31-3000'), false)\n    lu.assertEquals(candidate('06-06-2005'), true)\n    lu.assertEquals(candidate('21-31-2000'), false)\n    lu.assertEquals(candidate('04-12-2003'), true)\n    lu.assertEquals(candidate('04122003'), false)\n    lu.assertEquals(candidate('20030412'), false)\n    lu.assertEquals(candidate('2003-04'), false)\n    lu.assertEquals(candidate('2003-04-12'), false)\n    lu.assertEquals(candidate('04-2003'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_125","nl":"scn_Latn","pl":"lua","prompt":"- Esempi - alfabetu, ordì a') = 0, ordì b') = 1, ... ordì z') = 25 - avissi a divìdiri supra virgule ',' si nun esisti virgule tu avissi a riturnari lu nùmmiru di littri minuri cu urdinamentu dispari ntô - Datu na stringa di palori, riturnari na tavula di palori spartuti supra spazzi bianchi, si nun esisti nuddu spazzi bianchi ntô testu chi si voli -- >>> split_words('Hello world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('Hello,world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('abcdef')\n-- 3\nlocal function split_words(txt)\n","canonical_solution":"local function split_words(txt)\n    -- Check if there is any whitespace to split on\n    if txt:find(\"%s\") then\n        local words = {}\n        for word in txt:gmatch(\"%S+\") do\n            table.insert(words, word)\n        end\n        return words\n    end\n\n    -- Check if there are commas to split on\n    if txt:find(\",\") then\n        local words = {}\n        for word in txt:gmatch(\"([^,]+)\") do\n            table.insert(words, word)\n        end\n        return words\n    end\n\n    -- Otherwise, count the number of lowercase letters with odd order\n    local count = 0\n    for i = 1, #txt do\n        local char = txt:sub(i, i)\n        local ord = char:byte() - string.byte('a')\n        if ord >= 0 and ord <= 25 and ord % 2 == 1 then\n            count = count + 1\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = split_words\n    lu.assertEquals(candidate('Hello world!'), {'Hello', 'world!'})\n    lu.assertEquals(candidate('Hello,world!'), {'Hello', 'world!'})\n    lu.assertEquals(candidate('Hello world,!'), {'Hello', 'world,!'})\n    lu.assertEquals(candidate('Hello,Hello,world !'), {'Hello,Hello,world', '!'})\n    lu.assertEquals(candidate('abcdef'), 3)\n    lu.assertEquals(candidate('aaabb'), 2)\n    lu.assertEquals(candidate('aaaBb'), 1)\n    lu.assertEquals(candidate(''), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_126","nl":"scn_Latn","pl":"lua","prompt":"- Esempi - numaru, torna falsu. Assumi ca nun ci sunnu numari negativi e sulu numari interi.- in ordine crescente. Se u tavulinu hà più di 1 duplicatu di u stessu - Datu na tabella di nummari, torna si sunnu ordinati o no.-- >>> is_sorted({5})\n-- true\n-- >>> is_sorted({1, 2, 3, 4, 5})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5})\n-- false\n-- >>> is_sorted({1, 2, 3, 4, 5, 6})\n-- true\n-- >>> is_sorted({1, 2, 3, 4, 5, 6, 7})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5, 6, 7})\n-- false\n-- >>> is_sorted({1, 2, 2, 3, 3, 4})\n-- true\n-- >>> is_sorted({1, 2, 2, 2, 3, 4})\n-- false\nlocal function is_sorted(lst)\n","canonical_solution":"local function is_sorted(lst)\n    local seen = {}\n    for i = 1, #lst - 1 do\n        if lst[i] > lst[i + 1] then\n            return false\n        end\n    end\n\n    for _, num in ipairs(lst) do\n        if seen[num] then\n            seen[num] = seen[num] + 1\n            if seen[num] > 2 then\n                return false\n            end\n        else\n            seen[num] = 1\n        end\n    end\n\n    return true\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_sorted\n    lu.assertEquals(candidate({5}), true)\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}), true)\n    lu.assertEquals(candidate({1, 3, 2, 4, 5}), false)\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6}), true)\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7}), true)\n    lu.assertEquals(candidate({1, 3, 2, 4, 5, 6, 7}), false)\n    lu.assertEquals(candidate({}), true)\n    lu.assertEquals(candidate({1}), true)\n    lu.assertEquals(candidate({3, 2, 1}), false)\n    lu.assertEquals(candidate({1, 2, 2, 2, 3, 4}), false)\n    lu.assertEquals(candidate({1, 2, 3, 3, 3, 4}), false)\n    lu.assertEquals(candidate({1, 2, 2, 3, 3, 4}), true)\n    lu.assertEquals(candidate({1, 2, 3, 4}), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_127","nl":"scn_Latn","pl":"lua","prompt":"- [input\/output] campioni: - Si li dui intervalli nun si incrucianu, torna \"NO\". - altrimenti, torna \"NO\". - Se a lunghezza di l'intersezzione hè un numeru primu, torna \"SI\", - ca la so lunghizza è 1, ca nun è nu nùmmuru primu.- Esempiu, l'intersezzione di l'intervalli (1, 3), (2, 4) hè (2, 3) - l'intervalli è nu nùmmuru primu.- U vostru compitu è di determinà s'è u lunghezza di intersection di sti dui - Pi ogni intervallu datu, si supponi ca lu so iniziu è menu o uguali a la so fini.- cumprendi sia lu principiu ca la fini. - L'intervalli dati sò chjusi chì significa chì l'intervallu (iniziu, fine)- unni ogni intervallu è nu paru di nùmmari interi.- Ti dugnu dui intervalli, -- >>> intersection({1, 2}, {2, 3})\n-- 'NO'\n-- >>> intersection({-1, 1}, {0, 4})\n-- 'NO'\n-- >>> intersection({-3, -1}, {-5, 5})\n-- 'YES'\nlocal function intersection(interval1, interval2)\n","canonical_solution":"local function is_prime(num)\n    if num <= 1 then\n        return false\n    end\n    if num <= 3 then\n        return true\n    end\n    if num % 2 == 0 or num % 3 == 0 then\n        return false\n    end\n    for i = 5, math.sqrt(num), 6 do\n        if num % i == 0 or num % (i + 2) == 0 then\n            return false\n        end\n    end\n    return true\nend\n\nlocal function intersection(interval1, interval2)\n    local start1, end1 = interval1[1], interval1[2]\n    local start2, end2 = interval2[1], interval2[2]\n    \n    local intersection_start = math.max(start1, start2)\n    local intersection_end = math.min(end1, end2)\n    \n    if intersection_start > intersection_end then\n        return 'NO'\n    end\n    \n    local intersection_length = intersection_end - intersection_start + 1\n    \n    if is_prime(intersection_length) then\n        return 'YES'\n    else\n        return 'NO'\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersection\n    lu.assertEquals(candidate({1, 2}, {2, 3}), 'NO')\n    lu.assertEquals(candidate({-1, 1}, {0, 4}), 'NO')\n    lu.assertEquals(candidate({-3, -1}, {-5, 5}), 'YES')\n    lu.assertEquals(candidate({-2, 2}, {-4, 0}), 'YES')\n    lu.assertEquals(candidate({-11, 2}, {-1, -1}), 'NO')\n    lu.assertEquals(candidate({1, 2}, {3, 5}), 'NO')\n    lu.assertEquals(candidate({1, 2}, {1, 2}), 'NO')\n    lu.assertEquals(candidate({-2, -2}, {-3, -2}), 'NO')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_128","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - Nota: ritorna nulu pi arr vacanti.- di ogni nùmmaru dâ tàvula, rapprisintatu cu 1, -1 o 0. - summa di magnitudini di nùmmura interi multiplicata pi u pruduttu di tutti li signi - Vi veni datu na tavula di nummari interi e vi tocca turnari -- >>> prod_signs({1, 2, 2, -4})\n-- 9\n-- >>> prod_signs({0, 1})\n-- 0\n-- >>> prod_signs({})\n-- None\nlocal function prod_signs(arr)\n","canonical_solution":"local function prod_signs(arr)\n    if #arr == 0 then\n        return nil\n    end\n\n    local sum_magnitudes = 0\n    local product_signs = 1\n\n    for _, num in ipairs(arr) do\n        sum_magnitudes = sum_magnitudes + math.abs(num)\n        if num > 0 then\n            product_signs = product_signs * 1\n        elseif num < 0 then\n            product_signs = product_signs * -1\n        else\n            product_signs = 0\n            break\n        end\n    end\n\n    return sum_magnitudes * product_signs\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = prod_signs\n    lu.assertEquals(candidate({1, 2, 2, -4}), -9)\n    lu.assertEquals(candidate({0, 1}), 0)\n    lu.assertEquals(candidate({1, 1, 1, 2, 3, -1, 1}), -10)\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({2, 4, 1, 2, -1, -1, 9}), 20)\n    lu.assertEquals(candidate({-1, 1, -1, 1}), 4)\n    lu.assertEquals(candidate({-1, 1, 1, 1}), -4)\n    lu.assertEquals(candidate({-1, 1, 1, 0}), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_129","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Ritorna na tàvula urdinata dî valuri dî celli ca lu caminu minimu passa.- Hè garantitu chì a risposta hè unica. - lst_A[j] = lst_B[j]. - tali ca lst_A[i] < lst_B[i] e pi ogni j (1 <= j < i) avemu - di lst_B, in altre parolle, ci hè un indice intregu i (1 <= i <= k) - attraversu (ch'elli si chjaminu lst_A è lst_B), lst_A hè lexicograficamente menu - doppu aviri fattu li tavuli urdinati dî valori supra li celli ca A e B vanu - Un percorsu A (di lunghezza k) hè cunsideratu più chjucu chè un percorsu B (di lunghezza k) se - Non si pò iri fora di la griglia.- necessariamente distinti).- Si prega di nutari ca nu percorsu di lunghizza k significa visità esattamente k cellule (nun - cellulare. - in altre parolle, si pò andà à cellule chì sparte un bordu cù voi currenti - da ogni cellula, e a ogni passu si pò spustari a ogni cellula vicinu, - Tu hai a truvari lu percorsu minimu di lunghizza k nta la griglia.- inclusivi appare esattamente una volta nantu à e cellule di a griglia. - ogni cellula di la griglia cunteni nu valuri.- Datu na griglia cu N riggi e N culonni (N >= 2) e nu nùmmuru interu pusitivu k, -- >>> minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3)\n-- {1, 2, 1}\n-- >>> minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1)\n-- {1}\nlocal function minPath(grid, k)\n","canonical_solution":"local function minPath(grid, k)\n    local N = #grid\n    local directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n\n    -- Check if a position is within the grid boundaries\n    local function inBounds(x, y)\n        return x >= 1 and x <= N and y >= 1 and y <= N\n    end\n\n    -- DFS to find the minimum path of length k\n    local function dfs(x, y, path, visited, result)\n        -- Append current cell's value to path\n        table.insert(path, grid[x][y])\n\n        if #path == k then\n            -- Check if we have a new minimum lexicographical path\n            if not result.min or table.concat(path) < table.concat(result.min) then\n                result.min = {table.unpack(path)}\n            end\n        else\n            for _, dir in ipairs(directions) do\n                local nx, ny = x + dir[1], y + dir[2]\n                if inBounds(nx, ny) then\n                    dfs(nx, ny, path, visited, result)\n                end\n            end\n        end\n\n        -- Backtrack\n        table.remove(path)\n    end\n\n    local result = {min = nil}\n\n    -- Start DFS from each cell\n    for i = 1, N do\n        for j = 1, N do\n            dfs(i, j, {}, {}, result)\n        end\n    end\n\n    return result.min\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = minPath\n    lu.assertEquals(candidate({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3), {1, 2, 1})\n    lu.assertEquals(candidate({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1), {1})\n    lu.assertEquals(candidate({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4), {1, 2, 1, 2})\n    lu.assertEquals(candidate({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7), {1, 10, 1, 10, 1, 10, 1})\n    lu.assertEquals(candidate({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5), {1, 7, 1, 7, 1})\n    lu.assertEquals(candidate({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9), {1, 6, 1, 6, 1, 6, 1, 6, 1})\n    lu.assertEquals(candidate({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12), {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6})\n    lu.assertEquals(candidate({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8), {1, 3, 1, 3, 1, 3, 1, 3})\n    lu.assertEquals(candidate({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8), {1, 5, 1, 5, 1, 5, 1, 5})\n    lu.assertEquals(candidate({{1, 2}, {3, 4}}, 10), {1, 2, 1, 2, 1, 2, 1, 2, 1, 2})\n    lu.assertEquals(candidate({{1, 3}, {3, 2}}, 10), {1, 3, 1, 3, 1, 3, 1, 3, 1, 3})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_130","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - primi n + 1 numari dâ siquenza di Tribonacci. - Vi è datu nu nùmmuru n, nun niggativu, vi tocca a ritornu na tàvula di - = 2 + 3 + 3 = 8 - tri(3) = tri(2) + tri(1) + tri(4) - tri{}4) = 3 {}- tri(2) = 1 + (2 \/ 2) = 2 - Pi esempiu: - tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n è dispari. - tri (n) = 1 + n \/ 2, si n è puru. - tri(1) = 3 - La sequenza di Tribonacci è difinuta dâ ricurrenza: Tuttavia, chiddu ca la genti nun canusci è la sequenza di Tribonacci.- Tutti canuscinu la siquenza di Fibonacci, fu studiata assai da li matimàtici di l'Italia.-- >>> tri(3)\n-- {1, 3, 2, 8}\nlocal function tri(n)\n","canonical_solution":"local function tri(n)\n    local sequence = {}\n    \n    -- Handle the first element separately\n    sequence[1] = 3\n\n    for i = 2, n + 1 do\n        if i % 2 == 0 then\n            sequence[i] = 1 + i \/ 2\n        else\n            sequence[i] = (i - 1 <= 0 and 0 or sequence[i - 1]) +\n                          (i - 2 <= 0 and 0 or sequence[i - 2]) +\n                          (i + 1 > n + 1 and 0 or sequence[i + 1])\n        end\n    end\n    \n    return sequence\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = tri\n    lu.assertEquals(candidate(3), {1, 3, 2, 8})\n    lu.assertEquals(candidate(4), {1, 3, 2, 8, 3})\n    lu.assertEquals(candidate(5), {1, 3, 2, 8, 3, 15})\n    lu.assertEquals(candidate(6), {1, 3, 2, 8, 3, 15, 4})\n    lu.assertEquals(candidate(7), {1, 3, 2, 8, 3, 15, 4, 24})\n    lu.assertEquals(candidate(8), {1, 3, 2, 8, 3, 15, 4, 24, 5})\n    lu.assertEquals(candidate(9), {1, 3, 2, 8, 3, 15, 4, 24, 5, 35})\n    lu.assertEquals(candidate(20), {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11})\n    lu.assertEquals(candidate(0), {1})\n    lu.assertEquals(candidate(1), {1, 3})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_131","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - Ritorna 0 si tutti li cifri sunnu pari. - Datu nu nùmmaru n, riturnamu lu pruduttu dî cifri pari. -- >>> digits(1)\n-- 1\n-- >>> digits(4)\n-- 0\n-- >>> digits(235)\n-- 15\nlocal function digits(n)\n","canonical_solution":"local function digits(n)\n    local product = 1\n    local hasOdd = false\n    \n    while n > 0 do\n        local digit = n % 10\n        if digit % 2 == 1 then\n            product = product * digit\n            hasOdd = true\n        end\n        n = math.floor(n \/ 10)\n    end\n    \n    return hasOdd and product or 0\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = digits\n    lu.assertEquals(candidate(5), 5)\n    lu.assertEquals(candidate(54), 5)\n    lu.assertEquals(candidate(120), 1)\n    lu.assertEquals(candidate(5014), 5)\n    lu.assertEquals(candidate(98765), 315)\n    lu.assertEquals(candidate(5576543), 2625)\n    lu.assertEquals(candidate(2468), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_132","nl":"scn_Latn","pl":"lua","prompt":"- unni armenu na catina ntâ suttasuccessioni è nistata. - La funzioni avissi a riturnari veru si e sulu si ci è na suttasuccinnenza valida di parentesi - Crea na funzioni ca pigghia comu input na stringa ca cunteni sulu parentesi quatrati. -- >>> is_nested('[[]]')\n-- true\n-- >>> is_nested('[]]]]]]][[[[[]')\n-- false\n-- >>> is_nested('[][]')\n-- false\n-- >>> is_nested('[]')\n-- false\n-- >>> is_nested('[[][]]')\n-- true\n-- >>> is_nested('[[]][[')\n-- true\nlocal function is_nested(string)\n","canonical_solution":"local function is_nested(brackets)\n    local stack = {}\n    for i = 1, #brackets do\n        local char = brackets:sub(i, i)\n        if char == '[' then\n            table.insert(stack, char)\n        elseif char == ']' then\n            if #stack > 0 and stack[#stack] == '[' then\n                table.remove(stack)\n                if #stack > 0 then\n                    -- Found at least one nested bracket\n                    return true\n                end\n            else\n                -- Mismatched bracket\n                return false\n            end\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_nested\n    lu.assertEquals(candidate('[[]]'), true)\n    lu.assertEquals(candidate('[]]]]]]][[[[[]'), false)\n    lu.assertEquals(candidate('[][]'), false)\n    lu.assertEquals(candidate('[]'), false)\n    lu.assertEquals(candidate('[[[[]]]]'), true)\n    lu.assertEquals(candidate('[]]]]]]]]]]'), false)\n    lu.assertEquals(candidate('[][][[]]'), true)\n    lu.assertEquals(candidate('[[]'), false)\n    lu.assertEquals(candidate('[]]'), false)\n    lu.assertEquals(candidate('[[]][['), true)\n    lu.assertEquals(candidate('[[][]]'), true)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('[[[[[[[['), false)\n    lu.assertEquals(candidate(']]]]]]]]'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_133","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - arrotondà ogni elementu in a tavula à u int supranu ((Taccu) prima.- Tu hai a riturnari la summa di li nummari squattati nta la tàvula data, - Vi sunnu dati na tabella di nummari.-- >>> lst({1.0, 2.0, 3.0})\n-- 14\n-- >>> lst({1.0, 4.0, 9.0})\n-- 98\n-- >>> lst({1.0, 3.0, 5.0, 7.0})\n-- 84\n-- >>> lst({1.4, 4.2, 0.0})\n-- 29\n-- >>> lst({-2.4, 1.0, 1.0})\n-- 6\nlocal function sum_squares(lst)\n","canonical_solution":"local function sum_squares(lst)\n    local sum = 0\n    for _, num in ipairs(lst) do\n        local ceil_num = math.ceil(num)\n        sum = sum + (ceil_num * ceil_num)\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_squares\n    lu.assertEquals(candidate({1.0, 2.0, 3.0}), 14)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0}), 14)\n    lu.assertEquals(candidate({1.0, 3.0, 5.0, 7.0}), 84)\n    lu.assertEquals(candidate({1.4, 4.2, 0.0}), 29)\n    lu.assertEquals(candidate({-2.4, 1.0, 1.0}), 6)\n    lu.assertEquals(candidate({100.0, 1.0, 15.0, 2.0}), 10230)\n    lu.assertEquals(candidate({10000.0, 10000.0}), 200000000)\n    lu.assertEquals(candidate({-1.4, 4.6, 6.3}), 75)\n    lu.assertEquals(candidate({-1.4, 17.9, 18.9, 19.9}), 1086)\n    lu.assertEquals(candidate({0.0}), 0)\n    lu.assertEquals(candidate({-1.0}), 1)\n    lu.assertEquals(candidate({-1.0, 1.0, 0.0}), 2)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_134","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Nota: \"parola\" è nu gruppu di caratteri siparati di spazziu.- na parti di na parola, e sbagghiata altrimenti.- di na data stringa è nu caràttiri alfabbèticu e nun è - Crea na funzioni ca torna veru si l'ùrtimu caràttiri è -- >>> check_if_last_char_is_a_letter('apple pie')\n-- false\n-- >>> check_if_last_char_is_a_letter('apple pi e')\n-- true\n-- >>> check_if_last_char_is_a_letter('apple pi e ')\n-- false\n-- >>> check_if_last_char_is_a_letter('')\n-- false\nlocal function check_if_last_char_is_a_letter(txt)\n","canonical_solution":"local function check_if_last_char_is_a_letter(txt)\n    -- Remove trailing spaces\n    txt = txt:match(\"^(.-)%s*$\")\n    -- Check if the string is empty after trimming spaces\n    if #txt == 0 then\n        return false\n    end\n    -- Get the last character of the string\n    local lastChar = txt:sub(-1)\n    -- Check if the last character is an alphabet and not part of a word\n    return lastChar:match(\"%a\") and not txt:match(\"%s%a*$\")\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = check_if_last_char_is_a_letter\n    lu.assertEquals(candidate('apple'), false)\n    lu.assertEquals(candidate('apple pi e'), true)\n    lu.assertEquals(candidate('eeeee'), false)\n    lu.assertEquals(candidate('A'), true)\n    lu.assertEquals(candidate('Pumpkin pie '), false)\n    lu.assertEquals(candidate('Pumpkin pie 1'), false)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('eeeee e '), false)\n    lu.assertEquals(candidate('apple pie'), false)\n    lu.assertEquals(candidate('apple pi e '), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_135","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - valori duplicati. - nun esisti nuddu tali elementu allura torna -1. La tàvula data nun cunteni - nun è cchiù granni o uguali all'elimentu ca lu precedi.- Crea na funzioni ca ritorna l'indici cchiù granni di n'elimentu ca -- >>> can_arrange({1, 2, 4, 3, 5})\n-- 3\n-- >>> can_arrange({1, 2, 3})\n-- -1\nlocal function can_arrange(arr)\n","canonical_solution":"local function can_arrange(arr)\n    for i = #arr, 2, -1 do\n        if arr[i] < arr[i - 1] then\n            return i\n        end\n    end\n    return -1\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = can_arrange\n    lu.assertEquals(candidate({1, 2, 4, 3, 5}), 3)\n    lu.assertEquals(candidate({1, 2, 4, 5}), -1)\n    lu.assertEquals(candidate({1, 4, 2, 5, 6, 7, 8, 9, 10}), 2)\n    lu.assertEquals(candidate({4, 8, 5, 7, 3}), 4)\n    lu.assertEquals(candidate({}), -1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_136","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Si nun ci sunnu nummari interi pusitivi o nigativi, li riturnamu comu null. - di nùmmari interi pusitivi nta na tàvula. - lu cchiù granni di li nteri nigativi, e \"b\" è lu cchiù nicu - Crea na funzioni ca ritorna na tàvula (a, b), unni 'a' è -- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})\n-- {None, 1}\n-- >>> largest_smallest_integers({})\n-- {None, None}\n-- >>> largest_smallest_integers({0})\n-- {None, None}\nlocal function largest_smallest_integers(lst)\n","canonical_solution":"local function largest_smallest_integers(lst)\n    local max_negative = nil\n    local min_positive = nil\n\n    for _, num in ipairs(lst) do\n        if num < 0 then\n            if max_negative == nil or num > max_negative then\n                max_negative = num\n            end\n        elseif num > 0 then\n            if min_positive == nil or num < min_positive then\n                min_positive = num\n            end\n        end\n    end\n\n    return {max_negative, min_positive}\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_smallest_integers\n    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})\n    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7, 0}), {None, 1})\n    lu.assertEquals(candidate({1, 3, 2, 4, 5, 6, -2}), {-2, 1})\n    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7, 2})\n    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})\n    lu.assertEquals(candidate({}), {None, None})\n    lu.assertEquals(candidate({0}), {None, None})\n    lu.assertEquals(candidate({-1, -3, -5, -6}), {-1, None})\n    lu.assertEquals(candidate({-1, -3, -5, -6, 0}), {-1, None})\n    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})\n    lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_137","nl":"scn_Latn","pl":"lua","prompt":"- Nota: Si nu nùmmaru riali è rapprisintatu comu na stringa, lu puntu flussienti pò èssiri . o , - Ritorna null si li valuri sunnu uguali. - numari riali, e torna la variabbili cchiù granni ntô sò tipu di variabbili. - Crea na funzioni ca pigghia nterari, floats, o stringhi rapprisintanti -- >>> compare_one(1, 2.5)\n-- 2.5\n-- >>> compare_one(1, '2,3')\n-- '2,3'\n-- >>> compare_one('5,1', '6')\n-- '6'\n-- >>> compare_one('1', 1)\n-- None\nlocal function compare_one(a, b)\n","canonical_solution":"local function to_real_number(val)\n    if type(val) == \"string\" then\n        val = val:gsub(\",\", \".\")\n        return tonumber(val)\n    end\n    return val\nend\n\nlocal function compare_one(a, b)\n    local a_type = type(a)\n    local b_type = type(b)\n    \n    if a_type == b_type then\n        if a == b then\n            return nil\n        end\n        return a > b and a or b\n    else\n        local a_real = to_real_number(a)\n        local b_real = to_real_number(b)\n        \n        if a_real == b_real then\n            return nil\n        end\n        return a_real > b_real and a or b\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = compare_one\n    lu.assertEquals(candidate(1, 2), 2)\n    lu.assertEquals(candidate(1, 2.5), 2.5)\n    lu.assertEquals(candidate(2, 3), 3)\n    lu.assertEquals(candidate(5, 6), 6)\n    lu.assertEquals(candidate(1, '2,3'), '2,3')\n    lu.assertEquals(candidate('5,1', '6'), '6')\n    lu.assertEquals(candidate('1', '2'), '2')\n    lu.assertEquals(candidate('1', 1), None)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_138","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu - Valute si lu nùmmuru datu n pò èssiri scrittu comu la summa di esattamente 4 nùmmura pari pusitivi -- >>> is_equal_to_sum_even(4)\n-- false\n-- >>> is_equal_to_sum_even(6)\n-- false\n-- >>> is_equal_to_sum_even(8)\n-- true\nlocal function is_equal_to_sum_even(n)\n","canonical_solution":"local function is_equal_to_sum_even(n)\n    -- Check if n can be expressed as the sum of 4 positive even numbers\n    -- which means n should at least be 8 (2 + 2 + 2 + 2) and n should be even.\n    if n >= 8 and n % 2 == 0 then\n        return true\n    else\n        return false\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_equal_to_sum_even\n    lu.assertEquals(candidate(4), false)\n    lu.assertEquals(candidate(6), false)\n    lu.assertEquals(candidate(8), true)\n    lu.assertEquals(candidate(10), true)\n    lu.assertEquals(candidate(11), false)\n    lu.assertEquals(candidate(12), true)\n    lu.assertEquals(candidate(13), false)\n    lu.assertEquals(candidate(16), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_139","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - unni n > 0 - brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! - Lu fatturialu brasilianu è difinutu comu: -- >>> special_factorial(4)\n-- 288\n-- The function will receive an integer as input and should return the special\n-- factorial of this integer.\nlocal function special_factorial(n)\n","canonical_solution":"local function factorial(m)\n    if m == 0 then\n        return 1\n    else\n        return m * factorial(m - 1)\n    end\nend\n\nlocal function special_factorial(n)\n    local result = 1\n    for i = 1, n do\n        result = result * factorial(i)\n    end\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = special_factorial\n    lu.assertEquals(candidate(4), 288)\n    lu.assertEquals(candidate(5), 34560)\n    lu.assertEquals(candidate(7), 125411328000)\n    lu.assertEquals(candidate(1), 1)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_140","nl":"scn_Latn","pl":"lua","prompt":"- poi sustituisci tutti li spazzi cunsicuenti cu - - e si na stringa havi cchiù di 2 spazzi cunsicuenti, - Datu na catina di testu, sustituisci tutti li spazzi cu li suttanavi, -- >>> fix_spaces(' Example')\n-- 'Example'\n-- >>> fix_spaces(' Example 1')\n-- 'Example_1'\n-- >>> fix_spaces(' Example 2')\n-- '_Example_2'\n-- >>> fix_spaces(' Example 3')\n-- '_Example-3'\nlocal function fix_spaces(text)\n","canonical_solution":"local function fix_spaces(text)\n    -- Trim leading and trailing spaces\n    text = text:match(\"^%s*(.-)%s*$\")\n    \n    -- Replace more than 2 consecutive spaces with '-'\n    text = text:gsub(\"%s%s%s+\", \"-\")\n    \n    -- Replace single spaces and double spaces with underscores\n    text = text:gsub(\"%s\", \"_\")\n    \n    return text\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fix_spaces\n    lu.assertEquals(candidate('Example'), 'Example')\n    lu.assertEquals(candidate('Mudasir Hanif '), 'Mudasir_Hanif_')\n    lu.assertEquals(candidate('Yellow Yellow  Dirty  Fellow'), 'Yellow_Yellow__Dirty__Fellow')\n    lu.assertEquals(candidate('Exa   mple'), 'Exa-mple')\n    lu.assertEquals(candidate('   Exa 1 2 2 mple'), '-Exa_1_2_2_mple')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_141","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - - La suttastinga doppu lu puntu avissi a èssiri unu di sti: ['txt', 'exe', 'dll'] - l'alfabetu latinu ('a'-'z' e 'A'-'Z'). - - La suttastinga prima dû puntu nun avissi a èssiri vacanti, e accumincia cu na littra di - - Lu nomu dû file cunteni esattamenti nu puntinu '.' - - U nomu di u schedariu ùn deve esse più di trè cifre ('0'-'9'). - sunnu accumpagnati: - Un nomu di schedariu hè cunsideratu validu s'è è solu s'è tutte e cundizioni seguenti sò soddisfatte - 'Sì' si lu nomu dû file è validu, e torna 'No' altrimenti. - Crea na funzioni ca pigghia na stringa ca rapprisenta lu nomu di nu file, e torna -- >>> file_name_check('example.txt')\n-- 'Yes'\n-- >>> file_name_check('1example.dll')\n-- 'No'\nlocal function file_name_check(file_name)\n","canonical_solution":"local function file_name_check(file_name)\n    -- Check exactly one dot in the file name\n    local dot_pos = file_name:find(\"%.\")\n    if not dot_pos or dot_pos ~= file_name:find(\"%.\", dot_pos + 1) then\n        return 'No'\n    end\n    \n    -- Split the name into prefix and suffix\n    local prefix = file_name:sub(1, dot_pos - 1)\n    local suffix = file_name:sub(dot_pos + 1)\n\n    -- Check if suffix is valid\n    local valid_suffixes = { txt = true, exe = true, dll = true }\n    if not valid_suffixes[suffix] then\n        return 'No'\n    end\n\n    -- Check prefix is not empty and starts with a letter\n    if #prefix == 0 or not prefix:match(\"^[a-zA-Z]\") then\n        return 'No'\n    end\n\n    -- Check that prefix has no more than 3 digits\n    local digit_count = 0\n    for i = 1, #prefix do\n        if prefix:sub(i, i):match(\"%d\") then\n            digit_count = digit_count + 1\n            if digit_count > 3 then\n                return 'No'\n            end\n        end\n    end\n\n    return 'Yes'\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = file_name_check\n    lu.assertEquals(candidate('example.txt'), 'Yes')\n    lu.assertEquals(candidate('1example.dll'), 'No')\n    lu.assertEquals(candidate('s1sdf3.asd'), 'No')\n    lu.assertEquals(candidate('K.dll'), 'Yes')\n    lu.assertEquals(candidate('MY16FILE3.exe'), 'Yes')\n    lu.assertEquals(candidate('His12FILE94.exe'), 'No')\n    lu.assertEquals(candidate('_Y.txt'), 'No')\n    lu.assertEquals(candidate('?aREYA.exe'), 'No')\n    lu.assertEquals(candidate('\/this_is_valid.dll'), 'No')\n    lu.assertEquals(candidate('this_is_valid.wow'), 'No')\n    lu.assertEquals(candidate('this_is_valid.txt'), 'Yes')\n    lu.assertEquals(candidate('this_is_valid.txtexe'), 'No')\n    lu.assertEquals(candidate('#this2_i4s_5valid.ten'), 'No')\n    lu.assertEquals(candidate('@this1_is6_valid.exe'), 'No')\n    lu.assertEquals(candidate('this_is_12valid.6exe4.txt'), 'No')\n    lu.assertEquals(candidate('all.exe.txt'), 'No')\n    lu.assertEquals(candidate('I563_No.exe'), 'Yes')\n    lu.assertEquals(candidate('Is3youfault.txt'), 'Yes')\n    lu.assertEquals(candidate('no_one#knows.dll'), 'Yes')\n    lu.assertEquals(candidate('1I563_Yes3.exe'), 'No')\n    lu.assertEquals(candidate('I563_Yes3.txtt'), 'No')\n    lu.assertEquals(candidate('final..txt'), 'No')\n    lu.assertEquals(candidate('final132'), 'No')\n    lu.assertEquals(candidate('_f4indsartal132.'), 'No')\n    lu.assertEquals(candidate('.txt'), 'No')\n    lu.assertEquals(candidate('s.'), 'No')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_142","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - canciari li voci dâ tàvula li cui indici nun sunnu nu multiplicu di 3 o 4. La funzioni poi torna la summa di tutti li voci.- multiplu di 3 e cubicherà l'entrata intjera si lu sò indici è nu multiplu di 4 e nun nu multiplu di 3. La funzioni nun - Sta funzioni pigghia na tàvula di nùmmura interi. pi tutti l'entrata ntâ tàvula, la funzioni s'havi a squariariari l'entrata n nùmmura interi si lu sò indici è a - \"  Lu-- >>> lst\n-- {1, 2, 3}\n-- >>> lst\n-- {}\n-- >>> lst\n-- {-1, -5, 2, -1, -5}\nlocal function sum_squares(lst)\n","canonical_solution":"local function sum_squares(lst)\n    local sum = 0\n    for i, v in ipairs(lst) do\n        if i % 3 == 0 then\n            sum = sum + v^2\n        elseif i % 4 == 0 then\n            sum = sum + v^3\n        else\n            sum = sum + v\n        end\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_squares\n    lu.assertEquals(candidate({1, 2, 3}), 6)\n    lu.assertEquals(candidate({1, 4, 9}), 14)\n    lu.assertEquals(candidate({}), 0)\n    lu.assertEquals(candidate({1, 1, 1, 1, 1, 1, 1, 1, 1}), 9)\n    lu.assertEquals(candidate({-1, -1, -1, -1, -1, -1, -1, -1, -1}), -3)\n    lu.assertEquals(candidate({0}), 0)\n    lu.assertEquals(candidate({-1, -5, 2, -1, -5}), -126)\n    lu.assertEquals(candidate({-56, -99, 1, 0, -2}), 3030)\n    lu.assertEquals(candidate({-1, 0, 0, 0, 0, 0, 0, 0, -1}), 0)\n    lu.assertEquals(candidate({-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}), -14196)\n    lu.assertEquals(candidate({-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}), -1448)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_143","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu 1: - l'ordine di e parolle in a nova stringa deve esse listessu chè quellu originale. - ca li lunghi sunnu numari primi, - e tu hai a riturnari na stringa ca cunteni li palori dâ frasi urigginaria, - la frasi cunteni arcuni palori siparati di nu spazziu, - Ti dugnu na stringa ca rapprisenta na frasi,-- >>> words_in_sentence('This is a test')\n-- 'is'\n-- Example 2:\n-- >>> words_in_sentence('lets go for swimming')\n-- 'go for'\n-- Constraints:\n--     * 1 <= len(sentence) <= 100\n--     * sentence contains only letters\nlocal function words_in_sentence(sentence)\n","canonical_solution":"local function is_prime(n)\n    if n <= 1 then return false end\n    if n <= 3 then return true end\n    if n % 2 == 0 or n % 3 == 0 then return false end\n    for i = 5, math.floor(math.sqrt(n)), 6 do\n        if n % i == 0 or n % (i + 2) == 0 then\n            return false\n        end\n    end\n    return true\nend\n\nlocal function words_in_sentence(sentence)\n    local words = {}\n    for word in sentence:gmatch(\"%S+\") do\n        table.insert(words, word)\n    end\n    \n    local result = {}\n    for _, word in ipairs(words) do\n        if is_prime(#word) then\n            table.insert(result, word)\n        end\n    end\n    \n    return table.concat(result, \" \")\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = words_in_sentence\n    lu.assertEquals(candidate('This is a test'), 'is')\n    lu.assertEquals(candidate('lets go for swimming'), 'go for')\n    lu.assertEquals(candidate('there is no place available here'), 'there is no place')\n    lu.assertEquals(candidate('Hi I am Hussein'), 'Hi am Hussein')\n    lu.assertEquals(candidate('go for it'), 'go for it')\n    lu.assertEquals(candidate('here'), '')\n    lu.assertEquals(candidate('here is'), 'is')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_144","nl":"scn_Latn","pl":"lua","prompt":"- Si pò supponiri ca x, e n sunnu frazzioni validi, e nun hannu zeru comu numinaturi. - <numeraturi>\/<denominatori> unni sia lu numeraturi ca lu denominatori sunnu nummari interi pusitivi. Sia x sia n sunnu rapprisintazzioni stringhi di na frazzioni, e hannu lu formatu siguenti, - x * n. La funzioni torna veru si x * n si valuta comu nu nùmmuru interu e falsu - U vostru compitu è di implementà una funzione chì simplificherà l'espressione -- >>> simplify('1\/5', '5\/1')\n-- true\n-- >>> simplify('1\/6', '2\/1')\n-- false\n-- >>> simplify('7\/10', '10\/2')\n-- false\nlocal function simplify(x, n)\n","canonical_solution":"local function simplify(x, n)\n    local function parseFraction(frac)\n        local num, denom = frac:match(\"(%d+)\/(%d+)\")\n        return tonumber(num), tonumber(denom)\n    end\n\n    local xn, xd = parseFraction(x)\n    local nn, nd = parseFraction(n)\n\n    local resultNumerator = xn * nn\n    local resultDenominator = xd * nd\n\n    return resultNumerator % resultDenominator == 0\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = simplify\n    lu.assertEquals(candidate('1\/5', '5\/1'), true)\n    lu.assertEquals(candidate('1\/6', '2\/1'), false)\n    lu.assertEquals(candidate('5\/1', '3\/1'), true)\n    lu.assertEquals(candidate('7\/10', '10\/2'), false)\n    lu.assertEquals(candidate('2\/10', '50\/10'), true)\n    lu.assertEquals(candidate('7\/2', '4\/2'), true)\n    lu.assertEquals(candidate('11\/6', '6\/1'), true)\n    lu.assertEquals(candidate('2\/3', '5\/2'), false)\n    lu.assertEquals(candidate('5\/2', '3\/5'), false)\n    lu.assertEquals(candidate('2\/4', '8\/4'), true)\n    lu.assertEquals(candidate('2\/4', '4\/2'), true)\n    lu.assertEquals(candidate('1\/5', '5\/1'), true)\n    lu.assertEquals(candidate('1\/5', '1\/5'), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_145","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - ordinalli a basi di lu so indici nta la tàvula urigginaria. - Nota: si ci sunnu diversi articuli cu summa simili di li sò cifri, - in ordine crescente secondu a somma di e so cifre. - Scrivi na funzioni ca sòrta la tàvula di nùmmura interi data -- >>> order_by_points({1, 11, -1, -11, -12})\n-- {-1, -11, 1, -12, 11}\n-- >>> order_by_points({})\n-- {}\nlocal function order_by_points(nums)\n","canonical_solution":"local function order_by_points(nums)\n    local function digit_sum(num)\n        local sum = 0\n        num = math.abs(num)\n        while num > 0 do\n            sum = sum + (num % 10)\n            num = math.floor(num \/ 10)\n        end\n        return sum\n    end\n\n    table.sort(nums, function(a, b)\n        local sum_a = digit_sum(a)\n        local sum_b = digit_sum(b)\n        if sum_a == sum_b then\n            -- Preserve original order if digit sums are equal\n            return false\n        else\n            return sum_a < sum_b\n        end\n    end)\n\n    return nums\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = order_by_points\n    lu.assertEquals(candidate({1, 11, -1, -11, -12}), {-1, -11, 1, -12, 11})\n    lu.assertEquals(candidate({1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, -11, -32, 43, 54, -98, 2, -3}), {-3, -32, -98, -11, 1, 2, 43, 54})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9})\n    lu.assertEquals(candidate({0, 6, 6, -76, -21, 23, 4}), {-76, -21, 0, 4, 23, 6, 6})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_146","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - la prima e l'ùrtima cifri di nu nùmmuru sunnu dispari (1, 3, 5, 7, 9).- u nùmmaru di elementi di a tavula chi sunnu cchiù granni di 10 e tutti dui - Scrivi na funzioni ca pigghia na tavula di nummari comu input e torna -- >>> specialFilter({15, -73, 14, -15})\n-- 1\n-- >>> specialFilter({33, -2, -3, 45, 21, 109})\n-- 2\nlocal function specialFilter(nums)\n","canonical_solution":"local function isOddDigit(num)\n    local digit = num % 10\n    return digit % 2 == 1\nend\n\nlocal function specialFilter(nums)\n    local count = 0\n    for _, num in ipairs(nums) do\n        local absNum = math.abs(num)\n        if absNum > 10 then\n            local firstDigit = tonumber(tostring(absNum):sub(1, 1))\n            local lastDigit = absNum % 10\n            if isOddDigit(firstDigit) and isOddDigit(lastDigit) then\n                count = count + 1\n            end\n        end\n    end\n    return count\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = specialFilter\n    lu.assertEquals(candidate({5, -2, 1, -5}), 0)\n    lu.assertEquals(candidate({15, -73, 14, -15}), 1)\n    lu.assertEquals(candidate({33, -2, -3, 45, 21, 109}), 2)\n    lu.assertEquals(candidate({43, -12, 93, 125, 121, 109}), 4)\n    lu.assertEquals(candidate({71, -2, -33, 75, 21, 19}), 3)\n    lu.assertEquals(candidate({1}), 0)\n    lu.assertEquals(candidate({}), 0)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_147","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu:- e a[i] + a[j] + a[k] è nu multiplu di 3. - Rinnova lu nùmmuru di trippi (a[i], a[j], a[k]) di a unni i < j < k, - pi ogni i (1 ≤ i ≤ n), lu valuri di a[i] = i * i - i + 1. - Vi è datu nu nùmmuru intiru pusitivu n. Vossia havi a criari na tàvula di nùmmura intiri a di lunghizza n.--     >>> get_max_triples(5)\n--     1\n-- Explanation: \n-- a = [1, 3, 7, 13, 21]\n-- The only valid triple is (1, 7, 13).\nlocal function get_max_triples(n)\n","canonical_solution":"local function get_max_triples(n)\n    local a = {}\n    for i = 1, n do\n        a[i] = i * i - i + 1\n    end\n\n    local count = 0\n    for i = 1, n - 2 do\n        for j = i + 1, n - 1 do\n            for k = j + 1, n do\n                if (a[i] + a[j] + a[k]) % 3 == 0 then\n                    count = count + 1\n                end\n            end\n        end\n    end\n\n    return count\nend\n\n-- Example Usage:\n-- print(get_max_triples(5)) -- Output: 1","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_max_triples\n    lu.assertEquals(candidate(5), 1)\n    lu.assertEquals(candidate(6), 4)\n    lu.assertEquals(candidate(10), 36)\n    lu.assertEquals(candidate(100), 53361)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_148","nl":"scn_Latn","pl":"lua","prompt":"- Esempi - nun sunnu nomi di pianeti curretti.- La funzioni avissi a riturnari na tàvula vacanti si planet1 o planet2 - la vicinanza ô suli.- situatu tra l'orbita di pianeta1 e l'orbita di pianeta2, ordinatu pi - La funzioni avissi a riturnari na tavula ca cunteni tutti li pianeti ca hannu l'urbita - Scrivi na funzioni ca pigghia dui nomi di pianeti comu strings planet1 e planet2. - Uranu, Nettunu.- è Mercuriu, u prossimu è Venere, poi Terra, Marte, Giove, Saturnu, - Ci sunnu ottu pianeti ntô nostru sistema sulari: li cchiù vicini ô suli.-- >>> bf('Jupiter', 'Neptune')\n-- {'Saturn', 'Uranus'}\n-- >>> bf('Earth', 'Mercury')\n-- 'Venus'\n-- >>> bf('Mercury', 'Uranus')\n-- {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'}\nlocal function bf(planet1, planet2)\n","canonical_solution":"local function bf(planet1, planet2)\n    local planets = {\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    }\n    \n    local planet_index = {}\n    for i, planet in ipairs(planets) do\n        planet_index[planet] = i\n    end\n    \n    local index1 = planet_index[planet1]\n    local index2 = planet_index[planet2]\n    \n    if not index1 or not index2 then\n        return {}\n    end\n    \n    local start_index = math.min(index1, index2) + 1\n    local end_index = math.max(index1, index2) - 1\n    \n    local result = {}\n    for i = start_index, end_index do\n        table.insert(result, planets[i])\n    end\n    \n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter', 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_149","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - Si pò suppuniri ca tutti li palori hannu la stissa lunghizza.- La funzioni avissi a riturnari na tàvula di stringhi ordinati. - Se dui palori hannu la stissa lunghizza, ordinati la tàvula a l'alfabetu. - deve restituisce a tavula ordinata da quella regula. - L'ordine di la tavula avissi a èssiri a scala di lunghizza di ogni palora, e tu...- e pò cuntèniri duplicati.- La tàvula è sempri na tàvula di fili e mai na tàvula di nùmmura,- e torna la tavula risurtata cu n'òrdini ordinatu, - cancella li fili ca hannu lunghizza dispari da lu, - Scrivi na funzioni ca accetta na tabella di stringhi comu paramatri, -- >>> list_sort({'aa', 'a', 'aaa'})\n-- {'aa'}\n-- >>> list_sort({'ab', 'a', 'aaa', 'cd'})\n-- {'ab', 'cd'}\nlocal function sorted_list_sum(lst)\n","canonical_solution":"local function list_sort(tbl)\n    local function is_even_length(s)\n        return #s % 2 == 0\n    end\n\n    local function compare_strings(a, b)\n        if #a == #b then\n            return a < b\n        else\n            return #a < #b\n        end\n    end\n\n    local result = {}\n    for _, v in ipairs(tbl) do\n        if is_even_length(v) then\n            table.insert(result, v)\n        end\n    end\n\n    table.sort(result, compare_strings)\n\n    return result\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_150","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - nu nùmmuru primu e avissi a riturnari lu valuri di y altrimenti. - Un prugramma simplice chì deve restituisce u valore di x se n hè -- >>> x_or_y(7, 34, 12)\n-- 34\n-- >>> x_or_y(15, 8, 5)\n-- 5\nlocal function x_or_y(n, x, y)\n","canonical_solution":"local function is_prime(num)\n    if num <= 1 then\n        return false\n    end\n    for i = 2, math.sqrt(num) do\n        if num % i == 0 then\n            return false\n        end\n    end\n    return true\nend\n\nlocal function x_or_y(n, x, y)\n    if is_prime(n) then\n        return x\n    else\n        return y\n    end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = x_or_y\n    lu.assertEquals(candidate(7, 34, 12), 34)\n    lu.assertEquals(candidate(15, 8, 5), 5)\n    lu.assertEquals(candidate(3, 33, 5212), 33)\n    lu.assertEquals(candidate(1259, 3, 52), 3)\n    lu.assertEquals(candidate(7919, -1, 12), -1)\n    lu.assertEquals(candidate(3609, 1245, 583), 583)\n    lu.assertEquals(candidate(91, 56, 129), 129)\n    lu.assertEquals(candidate(6, 34, 1234), 1234)\n    lu.assertEquals(candidate(1, 2, 0), 0)\n    lu.assertEquals(candidate(2, 2, 0), 2)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_151","nl":"scn_Latn","pl":"lua","prompt":"- ntâ tàvula chi sunnu dispari. Ignorari li nùmmura chi sunnu negativi o nun sunnu nteri.- Datu na tabella di nùmmura, riturnari la summa dî quadrati dî nùmmura -- >>> double_the_difference({1, 3, 2, 0})\n-- 10\n-- >>> double_the_difference({-1, -2, 0})\n-- 0\n-- >>> double_the_difference({9, -2})\n-- 81\n-- >>> double_the_difference({0})\n-- 0\n-- If the input table is empty, return 0.\nlocal function double_the_difference(lst)\n","canonical_solution":"local function double_the_difference(lst)\n    local sum = 0\n    for _, num in ipairs(lst) do\n        if type(num) == \"number\" and num >= 0 and num % 1 == 0 and num % 2 == 1 then\n            sum = sum + num * num\n        end\n    end\n    return sum\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = double_the_difference\n    lu.assertEquals(candidate({}), 0)\n    lu.assertEquals(candidate({5.0, 4.0}), 25)\n    lu.assertEquals(candidate({0.1, 0.2, 0.3}), 0)\n    lu.assertEquals(candidate({-10.0, -20.0, -30.0}), 0)\n    lu.assertEquals(candidate({-1.0, -2.0, 8.0}), 0)\n    lu.assertEquals(candidate({0.2, 3.0, 5.0}), 34)\n    lu.assertEquals(candidate({-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0}), 165)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_152","nl":"scn_Latn","pl":"lua","prompt":"- esempiu: - u valuri è 0, e si nun è, u valuri è la diffirenza assuluta tra la ghiuta e lu punteggiu. - Ritorna na tàvula di la stissa lunghizza ca indica quantu luntanu era ogni palisata.- Vi sunnu dati dui tavuli di punteggi e di ghici di lunghizza uguali, unni ogni indici mostra na partita. - U vostru compitu è di determinà si una persona hà indovinatu currettamente i risultati di un numeru di partite.- sicuramenti valuri di nota e di paraguni.- l'avvenimentu hè infine cunnisciutu.- Pensu ca tutti ci ricurdamu di 'sta sensazioni quannu 'u risultatu di quarchi tantu attesu ...-- >>> compare({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2})\n-- {0, 0, 0, 0, 3, 3}\n-- >>> compare({0, 5, 0, 0, 0, 4}, {4, 1, 1, 0, 0, -2})\n-- {4, 4, 1, 0, 0, 6}\nlocal function compare(game, guess)\n","canonical_solution":"local function compare(game, guess)\n    local differences = {}\n    for i = 1, #game do\n        if game[i] == guess[i] then\n            differences[i] = 0\n        else\n            differences[i] = math.abs(game[i] - guess[i])\n        end\n    end\n    return differences\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = compare\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2}), {0, 0, 0, 0, 3, 3})\n    lu.assertEquals(candidate({0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}), {0, 0, 0, 0, 0, 0})\n    lu.assertEquals(candidate({1, 2, 3}, {-1, -2, -3}), {2, 4, 6})\n    lu.assertEquals(candidate({1, 2, 3, 5}, {-1, 2, 3, 4}), {2, 0, 0, 1})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_153","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - (u so putenza è -1). - ritorna \"Slices.SERVINGSliCes\" postu chì \"SERVINGSliCes\" hè l'estensione più forte - estensioni: ['SErviNGSliCes', 'Cheese', 'StuFfed'] allura avissi a - Per esempiu, s'è vo site datu \"Slices\" comu la classi e na tàvula di u - sceglie quellu chì vene prima in a tavula. - Se ci sò dui o più estensioni cù a stessa forza, vi deve- furmatu: ClassName.StrongestExtensionName. - Tu avissi a truvari la cchiù forti estinzioni e turnari na stringa nta stu .- in u nome di l'estensione, u putere hè datu da a frazzione CAP - SM. - lettere in u nome di l'estensione, è SM sia u numeru di lettere minuscule - forza di l'estensione hè a seguente: Sia CAP u numeru di u maiusculu - L'estensioni hannu a èssiri usati pi caricari classi addiziunali â classi.- Vi sarà datu u nomu di una classa (una stringa) è una tavula di estensioni.-- >>> Strongest_Extension('my_class', {'AA', 'Be', 'CC'})\n-- 'my_class.AA'\nlocal function Strongest_Extension(class_name, extensions)\n","canonical_solution":"local function Strongest_Extension(class_name, extensions)\n    local strongest_extension = nil\n    local max_strength = nil\n\n    for _, extension in ipairs(extensions) do\n        local cap = 0\n        local sm = 0\n        for i = 1, #extension do\n            local char = extension:sub(i, i)\n            if char:match(\"%u\") then\n                cap = cap + 1\n            elseif char:match(\"%l\") then\n                sm = sm + 1\n            end\n        end\n        local strength = cap - sm\n        if max_strength == nil or strength > max_strength then\n            max_strength = strength\n            strongest_extension = extension\n        end\n    end\n\n    return class_name .. \".\" .. strongest_extension\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = Strongest_Extension\n    lu.assertEquals(candidate('Watashi', {'tEN', 'niNE', 'eIGHt8OKe'}), 'Watashi.eIGHt8OKe')\n    lu.assertEquals(candidate('Boku123', {'nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg'}), 'Boku123.YEs.WeCaNe')\n    lu.assertEquals(candidate('__YESIMHERE', {'t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321'}), '__YESIMHERE.NuLl__')\n    lu.assertEquals(candidate('K', {'Ta', 'TAR', 't234An', 'cosSo'}), 'K.TAR')\n    lu.assertEquals(candidate('__HAHA', {'Tab', '123', '781345', '-_-'}), '__HAHA.123')\n    lu.assertEquals(candidate('YameRore', {'HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-'}), 'YameRore.okIWILL123')\n    lu.assertEquals(candidate('finNNalLLly', {'Die', 'NowW', 'Wow', 'WoW'}), 'finNNalLLly.WoW')\n    lu.assertEquals(candidate('_', {'Bb', '91245'}), '_.Bb')\n    lu.assertEquals(candidate('Sp', {'671235', 'Bb'}), 'Sp.671235')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_154","nl":"scn_Latn","pl":"lua","prompt":"- Vi sunnu dati 2 palori. tu devi ritornu veru s'è la secunna palora o di ogni di i so rotazioni hè una substring in la prima parola -- >>> cycpattern_check('abcd', 'abd')\n-- false\n-- >>> cycpattern_check('hello', 'ell')\n-- true\n-- >>> cycpattern_check('whassup', 'psus')\n-- false\n-- >>> cycpattern_check('abab', 'baa')\n-- true\n-- >>> cycpattern_check('efef', 'eeff')\n-- false\n-- >>> cycpattern_check('himenss', 'simen')\n-- true\nlocal function cycpattern_check(a, b)\n","canonical_solution":"local function is_rotation(s1, s2)\n    return #s1 == #s2 and (s1 .. s1):find(s2) ~= nil\nend\n\nlocal function generate_rotations(s)\n    local rotations = {}\n    for i = 1, #s do\n        local rotation = s:sub(i) .. s:sub(1, i-1)\n        table.insert(rotations, rotation)\n    end\n    return rotations\nend\n\nlocal function cycpattern_check(a, b)\n    local rotations = generate_rotations(b)\n    for _, rotation in ipairs(rotations) do\n        if a:find(rotation) then\n            return true\n        end\n    end\n    return false\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = cycpattern_check\n    lu.assertEquals(candidate('xyzw', 'xyw'), false)\n    lu.assertEquals(candidate('yello', 'ell'), true)\n    lu.assertEquals(candidate('whattup', 'ptut'), false)\n    lu.assertEquals(candidate('efef', 'fee'), true)\n    lu.assertEquals(candidate('abab', 'aabb'), false)\n    lu.assertEquals(candidate('winemtt', 'tinem'), true)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_155","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - Datu nu nùmmaru nternu. riturnari na tàvula ca havi rispettivamenti lu nùmmaru di cifri pari e dispari. --     >>> even_odd_count(-12)\n--     {1, 1}\n--     >>> even_odd_count(123)\n--     {1, 2}\nlocal function even_odd_count(num)\n","canonical_solution":"local function even_odd_count(num)\n    local even_count, odd_count = 0, 0\n    num = math.abs(num)  -- remove the sign of the number\n    while num > 0 do\n        local digit = num % 10\n        if digit % 2 == 0 then\n            even_count = even_count + 1\n        else\n            odd_count = odd_count + 1\n        end\n        num = math.floor(num \/ 10)\n    end\n    return {even_count, odd_count}\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = even_odd_count\n    lu.assertEquals(candidate(7), {0, 1})\n    lu.assertEquals(candidate(-78), {1, 1})\n    lu.assertEquals(candidate(3452), {2, 2})\n    lu.assertEquals(candidate(346211), {3, 3})\n    lu.assertEquals(candidate(-345821), {3, 3})\n    lu.assertEquals(candidate(-2), {1, 0})\n    lu.assertEquals(candidate(-45347), {2, 3})\n    lu.assertEquals(candidate(0), {1, 0})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_156","nl":"scn_Latn","pl":"lua","prompt":"- Esempi: - Restrizioni: 1 <= num <= 1000 - e la rispunni cu li littri minuri.- Datu nu nùmmaru interu pusitivu, otteni lu sò equivalenti numirali rumani comu na stringa, -- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n-- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n","canonical_solution":"local function int_to_mini_roman(number)\n    local roman_numerals = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n    \n    local result = {}\n    for _, value_pair in ipairs(roman_numerals) do\n        local value, symbol = unpack(value_pair)\n        while number >= value do\n            number = number - value\n            table.insert(result, symbol)\n        end\n    end\n    \n    return table.concat(result)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_157","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - 90 gradi. - Un triàngulu rettangulu è un triàngulu unni un angulu è rettangulu o - i lati formanu un triangulu rettangulu, altrimenti è falsu. - Datu li lunghi di li tri lati di nu triàngulu.-- >>> right_angle_triangle(3, 4, 5)\n-- true\n-- >>> right_angle_triangle(1, 2, 3)\n-- false\nlocal function right_angle_triangle(a, b, c)\n","canonical_solution":"local function right_angle_triangle(a, b, c)\n    -- Sort the sides to make sure we always compare the largest with the sum of squares of the other two\n    local sides = {a, b, c}\n    table.sort(sides)\n\n    -- Check the Pythagorean theorem\n    return sides[1]^2 + sides[2]^2 == sides[3]^2\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = right_angle_triangle\n    lu.assertEquals(candidate(3, 4, 5), true)\n    lu.assertEquals(candidate(1, 2, 3), false)\n    lu.assertEquals(candidate(10, 6, 8), true)\n    lu.assertEquals(candidate(2, 2, 2), false)\n    lu.assertEquals(candidate(7, 24, 25), true)\n    lu.assertEquals(candidate(10, 5, 7), false)\n    lu.assertEquals(candidate(5, 12, 13), true)\n    lu.assertEquals(candidate(15, 8, 17), true)\n    lu.assertEquals(candidate(48, 55, 73), true)\n    lu.assertEquals(candidate(1, 1, 1), false)\n    lu.assertEquals(candidate(2, 2, 10), false)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_158","nl":"scn_Latn","pl":"lua","prompt":"- caratteri, torna quellu chì vene prima in ordine lessicograficu. - di caratteri ùnici. Se stringi multipli hannu u nùmmiru massimu di caratteri ùnici - La tàvula cunteni palori diversi.- Scrivi na funzioni ca accetta na tabella di stringhi. -- >>> find_max({'name', 'of', 'string'})\n-- 'string'\n-- >>> find_max({'name', 'enam', 'game'})\n-- 'enam'\n-- >>> find_max({'aaaaaaa', 'bb', 'cc'})\n-- 'aaaaaaa'\nlocal function find_max(words)\n","canonical_solution":"local function find_max(words)\n    local function unique_characters_count(word)\n        local char_set = {}\n        for char in word:gmatch('.') do\n            char_set[char] = true\n        end\n        local count = 0\n        for _ in pairs(char_set) do\n            count = count + 1\n        end\n        return count\n    end\n\n    local max_word = ''\n    local max_unique_count = 0\n\n    for _, word in ipairs(words) do\n        local unique_count = unique_characters_count(word)\n        if unique_count > max_unique_count or (unique_count == max_unique_count and word < max_word) then\n            max_word = word\n            max_unique_count = unique_count\n        end\n    end\n\n    return max_word\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_max\n    lu.assertEquals(candidate({'name', 'of', 'string'}), 'string')\n    lu.assertEquals(candidate({'name', 'enam', 'game'}), 'enam')\n    lu.assertEquals(candidate({'aaaaaaa', 'bb', 'cc'}), 'aaaaaaa')\n    lu.assertEquals(candidate({'abc', 'cba'}), 'abc')\n    lu.assertEquals(candidate({'play', 'this', 'game', 'of', 'footbott'}), 'footbott')\n    lu.assertEquals(candidate({'we', 'are', 'gonna', 'rock'}), 'gonna')\n    lu.assertEquals(candidate({'we', 'are', 'a', 'mad', 'nation'}), 'nation')\n    lu.assertEquals(candidate({'this', 'is', 'a', 'prrk'}), 'this')\n    lu.assertEquals(candidate({'b'}), 'b')\n    lu.assertEquals(candidate({'play', 'play', 'play'}), 'play')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_159","nl":"scn_Latn","pl":"lua","prompt":"- Esempiu: - si nun ci sunnu abbastanza carusi, ti mangi tutti li carusi, ma ancora ti senti la fami.- u nùmmaru di carote riminuti doppu i vostri pranzi ] - tu devi turnari na tavula di [numeru tutali di carote mangiate doppu i pasti, - ma ora hai bisognu di manciari cchiù carote pi cumminari i pasti di lu jornu.- Tu si' nu cunigghiu affamato, e già hai mangiatu nu certu nummaru di carote,-- >>> eat(5, 6, 10)\n-- {11, 4}\n-- >>> eat(4, 8, 9)\n-- {12, 1}\n-- >>> eat(1, 10, 10)\n-- {11, 0}\n-- >>> eat(2, 11, 5)\n-- {7, 0}\n-- Variables:\n-- @number : integer\n--     the number of carrots that you have eaten.\n-- @need : integer\n--     the number of carrots that you need to eat.\n-- @remaining : integer\n--     the number of remaining carrots thet exist in stock\n-- Constrain:\n-- * 0 <= number <= 1000\n-- * 0 <= need <= 1000\n-- * 0 <= remaining <= 1000\n-- Have fun :)\nlocal function eat(number, need, remaining)\n","canonical_solution":"local function eat(number, need, remaining)\n    local totalEaten\n    local leftOver\n    \n    if remaining >= need then\n        totalEaten = number + need\n        leftOver = remaining - need\n    else\n        totalEaten = number + remaining\n        leftOver = 0\n    end\n    \n    return {totalEaten, leftOver}\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = eat\n    lu.assertEquals(candidate(5, 6, 10), {11, 4})\n    lu.assertEquals(candidate(4, 8, 9), {12, 1})\n    lu.assertEquals(candidate(1, 10, 10), {11, 0})\n    lu.assertEquals(candidate(2, 11, 5), {7, 0})\n    lu.assertEquals(candidate(4, 5, 7), {9, 2})\n    lu.assertEquals(candidate(4, 5, 1), {5, 0})\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_160","nl":"scn_Latn","pl":"lua","prompt":"- Tabella di l'operatore hà almenu un operatore, è tabella di l'operand hà almenu dui operandi. - L'operandu è na tàvula di nterni nun nigativi.- A lunghizza di u operatore tavula hè uguali à a lunghizza di u operand tavula menu unu. - Nota: - => risultatu = 9 - risultatu = 2 + 3 * 4 - 5 - tavula = [2, 3, 4, 5] - operatore['+', '*', '-'] - Esempiu: - Espunenziamentu (**) - Divisioni pianu ( \/\/) - Multiplicazzioni (*) - Sottrazzioni ( - ) - Aggiunta (+) - L'upirazzioni basi d'algebra: - espressione e riturnari la valutazzioni di sta espressione. - la secunna tàvula è na tàvula di nùmmura interi.- Datu dui operaturi e operandi di tavula, la prima tavula havi funzioni di basi di l'algibbra, e local function do_algebra(operator, operand)\n","canonical_solution":"local function do_algebra(operator, operand)\n    local expression = tostring(operand[1])\n    \n    for i = 1, #operator do\n        expression = expression .. \" \" .. operator[i] .. \" \" .. operand[i+1]\n    end\n    \n    return load(\"return \" .. expression)()\nend\n\n-- Example usage:\n-- local operator = {'+', '*', '-'}\n-- local operand = {2, 3, 4, 5}\n-- local result = do_algebra(operator, operand)\n-- print(result) -- Output: 9","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = do_algebra\n    lu.assertEquals(candidate({'**', '*', '+'}, {2, 3, 4, 5}), 37)\n    lu.assertEquals(candidate({'+', '*', '-'}, {2, 3, 4, 5}), 9)\n    lu.assertEquals(candidate({'\/\/', '*'}, {7, 3, 4}), 8)\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_161","nl":"scn_Latn","pl":"lua","prompt":"- Esempi - La funzioni avissi a riturnari la stringa risurtata. - Si la stringa nun cunteni littri, inverti la stringa.- altrimenti lassa comu è.- si s[i] è na littra, inverta la sò cassa da lu bassu a lu supiriuri o viceversa, - Ti dugnu na stringa di s. -- >>> solve('1234')\n-- '4321'\n-- >>> solve('ab')\n-- 'AB'\n-- >>> solve('#a@C')\n-- '#A@c'\nlocal function solve(s)\n","canonical_solution":"local function solve(s)\n  local has_letters = false\n  local result = {}\n  \n  for i = 1, #s do\n    local char = s:sub(i, i)\n    if char:match(\"%a\") then\n      has_letters = true\n      if char:lower() == char then\n        table.insert(result, char:upper())\n      else\n        table.insert(result, char:lower())\n      end\n    else\n      table.insert(result, char)\n    end\n  end\n  \n  if has_letters then\n    return table.concat(result)\n  else\n    return s:reverse()\n  end\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = solve\n    lu.assertEquals(candidate('AsDf'), 'aSdF')\n    lu.assertEquals(candidate('1234'), '4321')\n    lu.assertEquals(candidate('ab'), 'AB')\n    lu.assertEquals(candidate('#a@C'), '#A@c')\n    lu.assertEquals(candidate('#AsdfW^45'), '#aSDFw^45')\n    lu.assertEquals(candidate('#6@2'), '2@6#')\n    lu.assertEquals(candidate('#$a^D'), '#$A^d')\n    lu.assertEquals(candidate('#ccc'), '#CCC')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_162","nl":"scn_Latn","pl":"lua","prompt":"- Si 'text' è na stringa vacanti, torna nil. - Datu na stringa 'text', riturnari la stringa di hash md5 equivalenti. -- >>> string_to_md5('Hello world')\n-- '3e25960a79dbc69b674cd4ec67a72c62'\nlocal function string_to_md5(text)\n","canonical_solution":"local md5 = require(\"md5\")\n\nlocal function string_to_md5(text)\n    if text == \"\" then\n        return nil\n    end\n    return md5.sumhexa(text)\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_to_md5\n    lu.assertEquals(candidate('Hello world'), '3e25960a79dbc69b674cd4ec67a72c62')\n    lu.assertEquals(candidate(''), None)\n    lu.assertEquals(candidate('A B C'), '0ef78513b0cb8cef12743f5aeb35f888')\n    lu.assertEquals(candidate('password'), '5f4dcc3b5aa765d61d8327deb882cf99')\nend\n\nos.exit(lu.LuaUnit.run())"},{"task_id":"HumanEval_163","nl":"scn_Latn","pl":"lua","prompt":"- Pi esempiu: - e b, in ordine crescente. - Dati dui nterni pusitivi a e b, riturnari li cifri pari tra a -- >>> generate_integers(2, 8)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(8, 2)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(10, 14)\n-- {}\nlocal function generate_integers(a, b)\n","canonical_solution":"local function generate_integers(a, b)\n    local evens = {}\n    local start, finish = math.min(a, b), math.max(a, b)\n    \n    for i = start, finish do\n        if i % 2 == 0 then\n            table.insert(evens, i)\n        end\n    end\n    \n    return evens\nend","tests":"lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = generate_integers\n    lu.assertEquals(candidate(2, 10), {2, 4, 6, 8})\n    lu.assertEquals(candidate(10, 2), {2, 4, 6, 8})\n    lu.assertEquals(candidate(132, 2), {2, 4, 6, 8})\n    lu.assertEquals(candidate(17, 89), {})\nend\n\nos.exit(lu.LuaUnit.run())"}]