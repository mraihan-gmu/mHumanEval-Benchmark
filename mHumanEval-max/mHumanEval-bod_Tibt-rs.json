[{"task_id":"HumanEval_0","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ བྱིན་ཚད་ཐིག་ཁྲམ་\/\/\/ ཚད་གཞི་ནང་ ཇི་འདྲ་ཨང་གྲངས་གཉིས་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་ ཇི་འདྲ་\/\/\/ >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)\n\/\/\/ false\n\/\/\/ >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n\/\/\/ true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n","canonical_solution":"fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n                return true;\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"},{"task_id":"HumanEval_1","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ནང་འཇུག་ཐིག་ནང་ཡོད་པའི་བར་སྟོང་ལ་དོ་སྣང་མ་བྱེད།\/\/\/ རིགས་དབྱེ་ཁག་ཅིག་རང་མཉམ་བཞག་ (ཁ་ཕྱེ་བའི་རྒྱབ་ལག་རེ་རེ་བཞིན་ལེགས་པར་རྒྱབ་) བྱས་ཡོད་པ་དང་ཕན་ཚུན་དབར་སྦྲེལ་མེད་པ།\/\/\/ ཚོ་ཚོ་ཚོ་སོ་སོར་དབྱེ་ནས་ ཚོ་ཚོ་ཚོ་གི་བེ་ཊར་ཕྱིར་ལོག་བྱེད་པ།\/\/\/ འདི་ལས་འགན་འདི་ནང་ནང་འཇུག་བྱེད་དེ་ སྦྲེལ་ཡོད་པའི་སྒམ་ཚིགས་ཀྱི་སྡེ་ཚན་མང་པོ་བསྡུས་པའི་ཐིག་ཡིག་ཡིན། ཁྱོད་ཀྱི་དམིགས་ཡུལ་ནི་ \/\/\/ >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n\/\/\/ vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n","canonical_solution":"fn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut groups = Vec::new();\n    let mut current_group = String::new();\n    let mut open_count = 0;\n\n    for char in paren_string.chars() {\n        if char == '(' {\n            open_count += 1;\n            current_group.push(char);\n        } else if char == ')' {\n            open_count -= 1;\n            current_group.push(char);\n        }\n\n        if open_count == 0 && !current_group.is_empty() {\n            groups.push(current_group.clone());\n            current_group.clear();\n        }\n    }\n\n    groups\n}","tests":"}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n"},{"task_id":"HumanEval_2","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ གྲངས་ཀའི་བཅུ་ཆ་ཕྱིར་ལོག་བྱེད།\/\/\/ (ལྷག་ལུས་ཆ་ཤས་ནི་ 1 ལས་ཆུང་བ་རེད།)\/\/\/ དང་ཧྲིལ་གྲངས་ཆ་ཤས་ (གྲངས་ཀ་འདི་ལས་ ཆེ་བའི་ཧྲིལ་གྲངས་ཆུང་བ་) དང་བཅུ་ཚིགས་ཀྱི་གྲངས་ཀ་ \/\/\/ མཆོང་ལྡོག་གི་ཆ་ཤས་གྲངས་ཤིག་ཡོད་ན། དེ་ནི་ ནང་དུ་ཆ་བགོས་བྱེད་ཐུབ།\/\/\/ >>> truncate_number(3.5)\n\/\/\/ 0.5\nfn truncate_number(number: f64) -> f64 {\n","canonical_solution":"fn truncate_number(number: f64) -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    println!(\"{}\", truncate_number(3.5)); \/\/ 0.5\n}","tests":"}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"},{"task_id":"HumanEval_3","nl":"bod_Tibt","pl":"rs","prompt":"\/\/ཚད་གཞི་དེ་ true ཕྱིར་ལོག་བྱེད་དགོས། དེ་མིན་ false ཕྱིར་ལོག་བྱེད་དགོས།\/\/ཤོག་ངོས་འདི་ཡི་བཟོ་བཅོས་མཐའ་མ་༢༩༩ ལ་རེད།\/\/ཤོག་ངོས་འདི་ནང་ \"དངུལ་ཁང་གི་རྩིས་ཁྲ་ནང་དངུལ་བསྐྱུར་དང་དངུལ་ཕྱིར་འདོན་གྱི་ལས་འགུལ་\" ཟེར་བའི་ཡི་གེ་འདུག\/\/\/ >>> below_zero(vec![1, 2, 3])\n\/\/\/ false\n\/\/\/ >>> below_zero(vec![1, 2, -4, 5])\n\/\/\/ true\nfn below_zero(operations: Vec<isize>) -> bool {\n","canonical_solution":"fn below_zero(operations: Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations {\n        balance += operation;\n        if balance < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", below_zero(vec![1, 2, 3])); \/\/ false\n    println!(\"{}\", below_zero(vec![1, 2, -4, 5])); \/\/ true\n    println!(\"{}\", below_zero(vec![1, -1, -1, 2])); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"},{"task_id":"HumanEval_4","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ MAD = average ཨིན། x - x_mean ཨིན།\/\/\/ ཚད་གཞི་དང་བར་གྱི་ཆ་ཤས་ (གནས་འདི་ནང་གི་བར་གྱི་ཆ་ཤས་) དང་།\/\/\/ Mean Absolute Deviation ནི་བར་གྱི་བར་གྱི་ཁྱད་པར་གཏན་ལ་ཕབ་པའོ།\/\/\/ ཚད་གཞི་འདི་ནང་གི་བར་མའི་མཐའ་འཁོར་དུ་ཡོད།\/\/\/ ནང་འཇུག་གྲངས་ཀྱི་བེ་ཊར་སྤྲོད་པའི་ཆེད་དུ་ Mean Absolute Deviation ཟེར་བ་རྩིས་དགོས།\/\/\/ >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])\n\/\/\/ 1.0\nfn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n","canonical_solution":"fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n    let n = numbers.len() as f64;\n    if n == 0.0 {\n        return 0.0;\n    }\n\n    let mean: f64 = numbers.iter().sum::<f64>() \/ n;\n    let mad: f64 = numbers.iter().map(|&x| (x - mean).abs()).sum::<f64>() \/ n;\n    \n    mad\n}\n\nfn main() {\n    let numbers = vec![1.0, 2.0, 3.0, 4.0];\n    println!(\"{}\", mean_absolute_deviation(numbers)); \/\/ Output: 1.0\n}","tests":"}\n\nfn main() {\n    let candidate = mean_absolute_deviation;\n    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);\n}\n"},{"task_id":"HumanEval_5","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ནང་འཇུག་གི་བེ་ཊར་ནང་འཇུག་གི་ཆ་ཤས་གཉིས་རེ་རེའི་བར་ལ་གྲངས་ \"delimeter\" ཞིག་བཙུགས་དགོས།\/\/\/ >>> intersperse(vec![], 4)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> intersperse(vec![1, 2, 3], 4)\n\/\/\/ vec![1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {\n","canonical_solution":"fn intersperse(numbers: Vec<isize>, delimiter: isize) -> Vec<isize> {\n    if numbers.is_empty() {\n        return Vec::new();\n    }\n    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);\n    for (i, &num) in numbers.iter().enumerate() {\n        result.push(num);\n        if i != numbers.len() - 1 {\n            result.push(delimiter);\n        }\n    }\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", intersperse(vec![], 4)); \/\/ Output: Vec::<isize>::new()\n    println!(\"{:?}\", intersperse(vec![1, 2, 3], 4)); \/\/ Output: vec![1, 4, 2, 4, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"},{"task_id":"HumanEval_6","nl":"bod_Tibt","pl":"rs","prompt":"\/\/དཔེར་ན། (() (()) ནི་ཚང་གི་ཚད་གཉིས་ལས་མང་བ་མེད་ལ། ((())) ནི་ཚང་གི་ཚད་གསུམ་ལས་མང་བ་མེད་ལ།\/\/\/ སྡེ་ཚན་རེ་རེའི་ཆེད་དུ་ཚིགས་སུ་བསྡུར་བའི་ཚད་མཐོའི་ཚད་གཞི་ཕྱིར་ཐོན་དགོས།\/\/\/ ལས་འགན་འདིའི་ནང་འཇུག་ནི་ སྐུད་པ་གང་ཞིག་ཡིན་པ་དེ་ནི་ སྦྲེལ་ཡོད་པའི་སྒམ་ཚིགས་ཀྱི་ཆེད་དུ་སྡེ་ཚན་མང་པོ་ཞིག་ཡིན་པའི་མཚོན་རྟགས་ཡིན།\/\/\/ >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n\/\/\/ vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n","canonical_solution":"fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n    paren_string.split_whitespace().map(|group| {\n        let mut max_depth = 0;\n        let mut current_depth = 0;\n        for char in group.chars() {\n            match char {\n                '(' => {\n                    current_depth += 1;\n                    if current_depth > max_depth {\n                        max_depth = current_depth;\n                    }\n                },\n                ')' => {\n                    current_depth -= 1;\n                },\n                _ => {}\n            }\n        }\n        max_depth\n    }).collect()\n}\n\nfn main() {\n    let result = parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"));\n    println!(\"{:?}\", result); \/\/ Output: [2, 3, 1, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n"},{"task_id":"HumanEval_7","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ནང་འཇུག་གི་ཐིག་ཡིག་ནང་ཐིག་འོག་གི་ཐིག་ཡིག་ཡོད་ན་རྐྱང་པའི་ཆེད་དུ་གཤེར་སྒྲོམ་འདེམས་དགོས།\/\/\/ >>> filter_by_substring(vec![], String::from(\"a\"))\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> filter_by_substring(vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n\/\/\/ vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"array\")]\nfn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n","canonical_solution":"fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n    strings.into_iter().filter(|s| s.contains(&substring)).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\")), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"},{"task_id":"HumanEval_8","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ སྟོང་པའི་བསྡོམས་ནི་ 0 དང་སྟོང་པའི་འབྲས་བུ་ནི་ 1 འདྲ་མཉམ་དགོས་པ་ཡིན།\/\/\/ འབྲས་བུ་གྲངས་ཚང་གི་བེ་ཊར་གང་ཞིག་ལ་བེ་ཊར་ནང་གི་གྲངས་ཚང་གི་བསྡོམས་དང་འབྲས་བུ་ལས་གྲུབ་པའི་བེ་ཊར་ཞིག་ཕྱིར་ལོག་བྱེད།\/\/\/ >>> sum_product(vec![])\n\/\/\/ (0, 1)\n\/\/\/ >>> sum_product(vec![1, 2, 3, 4])\n\/\/\/ (10, 24)\nfn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n","canonical_solution":"fn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n}\n\nfn main() {\n    println!(\"{:?}\", sum_product(vec![])); \/\/ (0, 1)\n    println!(\"{:?}\", sum_product(vec![1, 2, 3, 4])); \/\/ (10, 24)\n}","tests":"}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"},{"task_id":"HumanEval_9","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ནང་གི་རིམ་པ་ནང་།\/\/སྐར་ཆ་གང་ཞིག་ལ་གྲངས་ཆ་ཆ་ཚང་ཡོད་ཚད་ནས་ སྐར་ཆ་གང་ཞིག་ལ་དུས་ཆ་གང་ཞིག་ལ་ཐོབ་པའི་ སྐར་ཆ་མང་ཤོས་ཡོད་ཚད་ཀྱི་གྲངས་ཆ་གསར་པ་ཐོན་དགོས།\/\/\/ >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n\/\/\/ vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max = isize::MIN;\n    for &num in &numbers {\n        if num > current_max {\n            current_max = num;\n        }\n        result.push(current_max);\n    }\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"},{"task_id":"HumanEval_10","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ - ཚད་གཞི་གི་མཐའ་མར་ palindromic suffix གི་སྔོན་དུ་ཡོད་པའི་ཚད་གཞི་གི་སྔོན་འཇུག་འཇུག་འཇུག་པའི་རྒྱབ་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་འཇུག་\/\/\/ - ཇི་ཡོད་ཀྱི་ཡིག་འབྲུ་ནང་པ་ palindrome ཡོད་པའི་ postfix ཡི་རིང་ཤོས་འཚོལ་དགོས།\/\/\/ ཨལ་གོར་ཇི་མེའི་བསམ་ཚུལ་ནི་དྭངས་མ་ཡིན།: \/\/ཇི་ཙམ་ཐུང་བ་ཡོད་ཀྱང་ཚད་ལྡན་ཚད་ལྡན་ (palindrome) ཞིག་འཚོལ་དགོས།\/\/\/ >>> make_palindrome(String::from(\"\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> make_palindrome(String::from(\"cat\"))\n\/\/\/ String::from(\"catac\")\n\/\/\/ >>> make_palindrome(String::from(\"cata\"))\n\/\/\/ String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n","canonical_solution":"fn make_palindrome(string: String) -> String {\n    fn is_palindrome(s: &str) -> bool {\n        s.chars().eq(s.chars().rev())\n    }\n\n    if string.is_empty() || is_palindrome(&string) {\n        return string;\n    }\n\n    for i in (0..string.len()).rev() {\n        if is_palindrome(&string[i..]) {\n            let prefix = &string[..i];\n            let reversed_prefix: String = prefix.chars().rev().collect();\n            return string + &reversed_prefix;\n        }\n    }\n\n    string\n}\n\nfn main() {\n    println!(\"{:?}\", make_palindrome(String::from(\"\"))); \/\/ String::from(\"\")\n    println!(\"{:?}\", make_palindrome(String::from(\"cat\"))); \/\/ String::from(\"catac\")\n    println!(\"{:?}\", make_palindrome(String::from(\"cata\"))); \/\/ String::from(\"catac\")\n}","tests":"}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n}\n"},{"task_id":"HumanEval_11","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ Binary XOR འདི་ཚོ་ནང་འཇུག་བྱ་རྒྱུ་དང་འབྲས་བུ་ཡང་ string སྦེ་སླར་ལོག་བྱ་རྒྱུ་\/\/\/ Input ནི་ string a དང་ b གཉིས་ཡིན་ 1 དང་ 0 ཙམ་ལས་མི་འདུག\/\/\/ >>> string_xor(String::from(\"010\"), String::from(\"110\"))\n\/\/\/ String::from(\"100\")\nfn string_xor(a: String, b: String) -> String {\n","canonical_solution":"fn string_xor(a: String, b: String) -> String {\n    a.chars()\n     .zip(b.chars())\n     .map(|(char_a, char_b)| if char_a == char_b { '0' } else { '1' })\n     .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"},{"task_id":"HumanEval_12","nl":"bod_Tibt","pl":"rs","prompt":"\/\/ཚད་ལྡན་ཚད་ལྡན་གྱི་ཐིག་ཁྲམ་ནང་ཐིག་ཁྲམ་གཅིག་མཚུངས་ཡོད་ན་ None སླར་ལོག་བྱེད།\/\/ཕྲད་གྲངས་ཀྱི་ཐིག་ཁྲམ་ནས་ ཕྲད་གྲངས་རིང་ཤོས་ཕྱིར་ལོག་བྱེད། ཕྲད་གྲངས་མང་བ་ཡོད་ན་ ཕྲད་གྲངས་ཐོག་མ་ཕྱིར་ལོག་བྱེད།\/\/\/ >>> longest(vec![])\n\/\/\/ None\n\/\/\/ >>> longest(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n\/\/\/ Some(String::from(\"a\"))\n\/\/\/ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"ccc\")])\n\/\/\/ Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) -> Option<String> {\n","canonical_solution":"fn longest(strings: Vec<String>) -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len())\n}","tests":"}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"},{"task_id":"HumanEval_13","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ གྲངས་ཆ་ a དང་ b གཉིས་ཀྱི་ཆེ་མཐའི་སྤྱིར་བཏང་ཆ་བགོས་ཕྱིར་ལོག་བྱེད།\/\/\/ >>> greatest_common_divisor(3, 5)\n\/\/\/ 1\n\/\/\/ >>> greatest_common_divisor(25, 15)\n\/\/\/ 5\nfn greatest_common_divisor(a: isize, b: isize) -> isize {\n","canonical_solution":"fn greatest_common_divisor(mut a: isize, mut b: isize) -> isize {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}","tests":"}\n\nfn main() {\n    let candidate = greatest_common_divisor;\n    assert_eq!(candidate(3, 7), 1);\n    assert_eq!(candidate(10, 15), 5);\n    assert_eq!(candidate(49, 14), 7);\n    assert_eq!(candidate(144, 60), 12);\n}\n"},{"task_id":"HumanEval_14","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ སྔོན་འཇུག་གི་ཡིག་གཟུགས་ཚང་མ་ཕྱིར་ལོག་བྱེད་ཐིག་ ཡོད་པའི་ནང་འཇུག་ཡིག་གཟུགས་ཀྱི་ནང་འཇུག་ཡིག་གཟུགས་ཐུང་ཤོས་ནས་རིང་ཤོས་བར་\/\/\/ >>> all_prefixes(String::from(\"abc\"))\n\/\/\/ vec![String::from(\"a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String) -> Vec<String> {\n","canonical_solution":"fn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for i in 1..=string.len() {\n        prefixes.push(string[..i].to_string());\n    }\n    prefixes\n}\n\n\/\/ Example usage\nfn main() {\n    let prefixes = all_prefixes(String::from(\"abc\"));\n    println!(\"{:?}\", prefixes);\n}","tests":"}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\")]);\n}\n"},{"task_id":"HumanEval_15","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ནང་ཐིག་ནང་ 0 ནས་ n བར་གྱི་གྲངས་གྲངས་ཀྱི་གོ་རིམ་ངེས་ཅན་ཡོད་པའི་ string སླར་ལོག་བྱེད།\/\/\/ >>> string_sequence(0)\n\/\/\/ String::from(\"0\")\n\/\/\/ >>> string_sequence(5)\n\/\/\/ String::from(\"0 1 2 3 4 5\")\nfn string_sequence(n: isize) -> String {\n","canonical_solution":"fn string_sequence(n: isize) -> String {\n    (0..=n).map(|num| num.to_string()).collect::<Vec<String>>().join(\" \")\n}","tests":"}\n\nfn main() {\n    let candidate = string_sequence;\n    assert_eq!(candidate(0), String::from(\"0\"));\n    assert_eq!(candidate(3), String::from(\"0 1 2 3\"));\n    assert_eq!(candidate(10), String::from(\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"},{"task_id":"HumanEval_16","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ string ཞིག་ཡོད་ན། ཇི་ཙམ་ཁྱད་པར་ཅན་ཡོད་མེད་འཚོལ་དགོས།\/\/\/ >>> count_distinct_characters(String::from(\"xyzXYZ\"))\n\/\/\/ 3\n\/\/\/ >>> count_distinct_characters(String::from(\"Jerry\"))\n\/\/\/ 4\nfn count_distinct_characters(string: String) -> isize {\n","canonical_solution":"use std::collections::HashSet;\n\nfn count_distinct_characters(string: String) -> isize {\n    let lowercase_string = string.to_lowercase();\n    let distinct_chars: HashSet<char> = lowercase_string.chars().collect();\n    distinct_chars.len() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_distinct_characters;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"abcde\")), 5);\n    assert_eq!(candidate(String::from(\"abcdecadeCADE\")), 5);\n    assert_eq!(candidate(String::from(\"aaaaAAAAaaaa\")), 1);\n    assert_eq!(candidate(String::from(\"Jerry jERRY JeRRRY\")), 5);\n}\n"},{"task_id":"HumanEval_17","nl":"bod_Tibt","pl":"rs","prompt":"\/\/ཝར་ཊི་ལར་སྒྲ་བཞི་ཡོད་པ་ལ་སྒྲ་གཅིག་ལས་མེད།\/\/\"o\" ཟེར་བའི་སྒྲ་ནི་སྒྲ་ཕྱེད་ཙམ་ཞིག་ཡིན་པས་སྒྲ་གཉིས་ཙམ་འགོར་བ་རེད།\/\/ཤོག་གྲངས་ \"o\" - ཆ་ཚང་། ཚད་མ་བཞི་རིང་།\/\/\/ འདི་ནི་གཏམ་རྒྱུད་ཞིག་རེད།\/\/\/ མཇུག་མ་ཡིན།\/\/ཁྱོད་ཀྱི་ལས་འགན་ནི་ string འདི་ཁ་གསལ་བཟོ་དགོས་པ་དང་ སྐར་ཆ་རེ་རེར་ beat ཇི་ཙམ་ཡོད་ཚད་ཀྱི་གྲངས་ཐང་སླར་ལོག་བྱ་དགོས།\/\/\/ ལས་འགན་འདི་ནང་ཨང་ཡིག་འདི་ནི་ ASCII གྱི་རྣམ་པ་སོ་སོར་བཀོད་པའི་སྒྲ་དབྱངས་ཀྱི་སྒྲ་དབྱངས་ཀྱི་སྒྲོམ་ཞིག་ཡིན།\/\/\/ >>> parse_music(String::from(\"o o| .| o| o| .| .| .| .| o o\"))\n\/\/\/ vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string: String) -> Vec<isize> {\n","canonical_solution":"fn parse_music(music_string: String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let notes: Vec<&str> = music_string.split_whitespace().collect();\n\n    for note in notes {\n        match note {\n            \"o\" => result.push(4),\n            \"o|\" => result.push(2),\n            \".|\" => result.push(1),\n            _ => (),\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let music_string = String::from(\"o o| .| o| o| .| .| .| .| o o\");\n    let beats = parse_music(music_string);\n    println!(\"{:?}\", beats); \/\/ Outputs: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n}","tests":"}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"},{"task_id":"HumanEval_18","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ གཞི་ཐོག་གི་ཐིག་ཁྲམ་ནང་ ཚིག་ཡིག་འོག་གི་ཐིག་ཁྲམ་ཇི་ཙམ་རྙེད་ཐུབ་པ་འཚོལ་དགོས། གྱངས་ཁ་ལྡོག་པའི་ཐིག་ཁྲམ་རྩིས་ཤིག\/\/\/ >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n\/\/\/ 0\n\/\/\/ >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n\/\/\/ 3\n\/\/\/ >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n\/\/\/ 3\nfn how_many_times(string: String, substring: String) -> isize {\n","canonical_solution":"fn how_many_times(string: String, substring: String) -> isize {\n    if substring.is_empty() || string.is_empty() {\n        return 0;\n    }\n\n    let mut count = 0;\n    let mut position = 0;\n\n    while let Some(pos) = string[position..].find(&substring) {\n        count += 1;\n        position += pos + 1; \/\/ Move to the start of the next potential substring\n    }\n\n    count\n}\n\nfn main() {\n    println!(\"{}\", how_many_times(String::from(\"\"), String::from(\"a\"))); \/\/ 0\n    println!(\"{}\", how_many_times(String::from(\"aaa\"), String::from(\"a\"))); \/\/ 3\n    println!(\"{}\", how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))); \/\/ 3\n}","tests":"}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n"},{"task_id":"HumanEval_19","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཆུང་ཤོས་ནས་ཆེ་བར་རིམ་སྒྲིག་བྱས་པའི་གྲངས་ཀྱི་ཐིག་ཡིག་སླར་ལོག་བྱེད།\/\/ཚད་ལྡན་འདེམས་གཞི་ནི་ ' ༠', ' ༡', ' ༢', ' ༣', ' ༤', ' ༥', ' ༦', ' ༧', ' ༨' དང་ ' ༩' ཡིན།\/\/\/ ནང་འཇུག་ནི་ས་སྟོང་གི་ཚད་མཚམས་ཡོད་པའི་གྲངས་ཀྱི་ཐིག་ལེ་ཞིག་ཡིན་ཏེ། '0' ནས་ '9' བར་ཡིན།\/\/\/ >>> sort_numbers(String::from(\"three one five\"))\n\/\/\/ String::from(\"one three five\")\nfn sort_numbers(numbers: String) -> String {\n","canonical_solution":"fn sort_numbers(numbers: String) -> String {\n    let word_to_number = |word: &str| -> u32 {\n        match word {\n            \"zero\" => 0,\n            \"one\" => 1,\n            \"two\" => 2,\n            \"three\" => 3,\n            \"four\" => 4,\n            \"five\" => 5,\n            \"six\" => 6,\n            \"seven\" => 7,\n            \"eight\" => 8,\n            \"nine\" => 9,\n            _ => panic!(\"Invalid input\"),\n        }\n    };\n\n    let words: Vec<&str> = numbers.split_whitespace().collect();\n    let mut number_words: Vec<(&str, u32)> = words.iter().map(|&w| (w, word_to_number(w))).collect();\n\n    number_words.sort_by_key(|&(_, number)| number);\n\n    number_words.iter().map(|&(word, _)| word).collect::<Vec<&str>>().join(\" \")\n}","tests":"}\n\nfn main() {\n    let candidate = sort_numbers;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"three\")), String::from(\"three\"));\n    assert_eq!(candidate(String::from(\"three five nine\")), String::from(\"three five nine\"));\n    assert_eq!(candidate(String::from(\"five zero four seven nine eight\")), String::from(\"zero four five seven eight nine\"));\n    assert_eq!(candidate(String::from(\"six five four three two one zero\")), String::from(\"zero one two three four five six\"));\n}\n"},{"task_id":"HumanEval_20","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ གཞན་དང་དེ་དག་རིམ་བཞིན་ཕྱིར་སློག་བྱེད། (གྲངས་ཉུང་། གྲངས་མང་།)\/\/\/ ཚད་གཞི་གྲངས་ལས་ (ཉུང་མཐར་གཉིས་) ཤོག་གྲངས་གཉིས་འདེམས་ནས་ ཤོག་གྲངས་རེ་རེར་ཉེ་བར་ཡོད་ཚད་ཕྱིར་ལོག་བྱེད།\/\/\/ >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/\/ (2.0, 2.2)\n\/\/\/ >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/\/ (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n","canonical_solution":"fn find_closest_elements(mut numbers: Vec<f64>) -> (f64, f64) {\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut min_diff = f64::INFINITY;\n    let mut result = (0.0, 0.0);\n\n    for i in 0..(numbers.len() - 1) {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff {\n            min_diff = diff;\n            result = (numbers[i], numbers[i + 1]);\n        }\n    }\n    \n    result\n}\n\nfn main() {\n    \/\/ Example usage\n    let vec1 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2];\n    let res1 = find_closest_elements(vec1);\n    println!(\"{:?}\", res1); \/\/ (2.0, 2.2)\n\n    let vec2 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0];\n    let res2 = find_closest_elements(vec2);\n    println!(\"{:?}\", res2); \/\/ (2.0, 2.0)\n}","tests":"}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"},{"task_id":"HumanEval_21","nl":"bod_Tibt","pl":"rs","prompt":"\/\/ཆུང་ཤོས་ནི་ 0 དང་ཆེ་ཤོས་ནི་ 1 ཡིན་པའི་ངེས་པ་ཡོད།\/\/\/ གྲངས་འབོར་གྱི་བེ་ཊར་ (ཉུང་མཐར་ཆ་ཤས་གཉིས་ལས་) ཤིག་ཡོད་ན། བེ་ཊར་དེ་ལ་ཐིག་ལེ་སྒྱུར་བཅོས་བྱེད་པ།\/\/\/ >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/\/ vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n","canonical_solution":"fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let min_value = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max_value = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\n    numbers.into_iter().map(|x| (x - min_value) \/ (max_value - min_value)).collect()\n}\n\nfn main() {\n    let numbers = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let rescaled = rescale_to_unit(numbers);\n    println!(\"{:?}\", rescaled);\n}","tests":"}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"},{"task_id":"HumanEval_23","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཚད་གཞི་གཞི་གྲངས་ཀྱི་ཚད་གཞི་ཕྱིར་ལོག་བྱེད།\/\/\/ >>> strlen(String::from(\"\"))\n\/\/\/ 0\n\/\/\/ >>> strlen(String::from(\"abc\"))\n\/\/\/ 3\nfn strlen(string: String) -> isize {\n","canonical_solution":"fn strlen(string: String) -> isize {\n    string.chars().count() as isize\n}\n\nfn main() {\n    println!(\"{}\", strlen(String::from(\"\"))); \/\/ Output: 0\n    println!(\"{}\", strlen(String::from(\"abc\"))); \/\/ Output: 3\n}","tests":"}\n\nfn main() {\n    let candidate = strlen;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"x\")), 1);\n    assert_eq!(candidate(String::from(\"asdasnakj\")), 9);\n}\n"},{"task_id":"HumanEval_24","nl":"bod_Tibt","pl":"rs","prompt":"\/\/ཚད་ལྡན་གྲངས་ n ཆེད་ n ལས་ཆུང་བའི་གྲངས་ཆེན་ཤོས་ n ཀྱིས་ཆ་བགོས་བྱེད་དེ་འཚོལ་དགོས།\/\/\/ >>> largest_divisor(15)\n\/\/\/ 5\nfn largest_divisor(n: isize) -> isize {\n","canonical_solution":"fn largest_divisor(n: isize) -> isize {\n    for i in (1..n).rev() {\n        if n % i == 0 {\n            return i;\n        }\n    }\n    1 \/\/ If no other divisor is found, return 1\n}\n\nfn main() {\n    println!(\"{}\", largest_divisor(15)); \/\/ Output: 5\n}","tests":"}\n\nfn main() {\n    let candidate = largest_divisor;\n    assert_eq!(candidate(3), 1);\n    assert_eq!(candidate(7), 1);\n    assert_eq!(candidate(10), 5);\n    assert_eq!(candidate(100), 50);\n    assert_eq!(candidate(49), 7);\n}\n"},{"task_id":"HumanEval_25","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ནང་འཇུག་གྲངས་ནི་གཞི་གྲངས་ཚང་མའི་འབྲས་བུ་དང་མཚུངས་པར་ངེས་པ་དགོས།\/\/ཇི་འདྲ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་མང་བ་\/\/\/ བྱིན་ཡོད་པའི་གྲངས་ཆ་དང་པོ་གྲངས་ཆ་མང་གི་ལོག་པའི་འཁོར་ལམ་ནི་ ཆུང་ཤོས་ནས་ཆེ་ཤོས་བར་རིམ་བཞིན་ཡིན།\/\/\/ >>> factorize(8)\n\/\/\/ vec![2, 2, 2]\n\/\/\/ >>> factorize(25)\n\/\/\/ vec![5, 5]\n\/\/\/ >>> factorize(70)\n\/\/\/ vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n","canonical_solution":"fn factorize(mut n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut divisor = 2;\n    while n >= divisor * divisor {\n        while n % divisor == 0 {\n            factors.push(divisor);\n            n \/= divisor;\n        }\n        divisor += 1;\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", factorize(8));  \/\/ Should print: [2, 2, 2]\n    println!(\"{:?}\", factorize(25)); \/\/ Should print: [5, 5]\n    println!(\"{:?}\", factorize(70)); \/\/ Should print: [2, 5, 7]\n}","tests":"}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"},{"task_id":"HumanEval_26","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ནང་འཇུག་བྱ་བཞིན་གྱི་རིམ་པ་འདྲ་མཉམ་བཞག་དགོས།\/\/སྐར་ཆ་གང་ཞིག་མང་བ་ཡོད་ན་ སྐར་ཆ་གང་ཞིག་མང་བ་ཡོད་ན་ ཕྱིར་འབུད་བྱ་དགོས།\/\/\/ >>> remove_duplicates(vec![1, 2, 3, 2, 4])\n\/\/\/ vec![1, 3, 4]\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"use std::collections::HashMap;\n\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    let mut occurrences = HashMap::new();\n    \n    \/\/ Count occurrences of each number\n    for &number in &numbers {\n        *occurrences.entry(number).or_insert(0) += 1;\n    }\n\n    \/\/ Filter out numbers that occur more than once\n    numbers.into_iter()\n        .filter(|&number| occurrences[&number] == 1)\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = remove_duplicates;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);\n}\n"},{"task_id":"HumanEval_27","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཚད་གཞི་ནང་ཡིག་འབྲུ་ཆུང་བ་ཡིག་འབྲུ་སྦོམ་དང་ ཆུང་བ་ཡིག་འབྲུ་སྦོམ་སྦེ་ལུ་བསྒྱུར་དགོ།\/\/\/ >>> flip_case(String::from(\"Hello\"))\n\/\/\/ String::from(\"hELLO\")\nfn flip_case(string: String) -> String {\n","canonical_solution":"fn flip_case(string: String) -> String {\n    string.chars().map(|c| {\n        if c.is_lowercase() {\n            c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = flip_case;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hello!\")), String::from(\"hELLO!\"));\n    assert_eq!(candidate(String::from(\"These violent delights have violent ends\")), String::from(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"},{"task_id":"HumanEval_28","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ སྐུད་པ་མང་པོའི་ཐིག་ཁྲམ་གཅིག་ཏུ་བསྡོམས་པ།\/\/\/ >>> concatenate(vec![])\n\/\/\/ String::from(\"\")\n\/\/\/ >>> concatenate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n\/\/\/ String::from(\"abc\")\nfn concatenate(strings: Vec<String>) -> String {\n","canonical_solution":"fn concatenate(strings: Vec<String>) -> String {\n    strings.concat()\n}","tests":"}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n}\n"},{"task_id":"HumanEval_29","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ནང་འཇུག་གི་ཐིག་ཡིག་གི་ཐིག་ཡིག་འདི་ནང་ prefix ཞིག་ཡོད་ན་དེ་ནང་འཇུག་ཐིག་ཡིག་ལ་གནོན་དགོས།\/\/\/ >>> filter_by_prefix(vec![], String::from(\"a\"))\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> filter_by_prefix(vec![String::from(\"abc\"), String::from(\"bcd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n\/\/\/ vec![String::from(\"abc\"), String::from(\"array\")]\nfn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n","canonical_solution":"fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n    strings.into_iter()\n        .filter(|s| s.starts_with(&prefix))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = filter_by_prefix;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n}\n"},{"task_id":"HumanEval_30","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཝི་ཅཊར་ནང་གྲངས་ཆ་རྐྱང་པ་ཁ་སྐོང་ཕྱིར་ལོག་བྱེད།\/\/\/ >>> get_positive(vec![-1, 2, -4, 5, 6])\n\/\/\/ vec![2, 5, 6]\n\/\/\/ >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ vec![5, 3, 2, 3, 9, 123, 1]\nfn get_positive(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn get_positive(l: Vec<isize>) -> Vec<isize> {\n    l.into_iter().filter(|&x| x > 0).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = get_positive;\n    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);\n    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_31","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ གྲངས་ཀ་ངེས་ཅན་ཞིག་སྔོན་གྲངས་ཡིན་ན་ true སླར་ལོག་བྱེད། དེ་མིན་ false སླར་ལོག་བྱེད།\/\/\/ >>> is_prime(6)\n\/\/\/ false\n\/\/\/ >>> is_prime(101)\n\/\/\/ true\n\/\/\/ >>> is_prime(11)\n\/\/\/ true\n\/\/\/ >>> is_prime(13441)\n\/\/\/ true\n\/\/\/ >>> is_prime(61)\n\/\/\/ true\n\/\/\/ >>> is_prime(4)\n\/\/\/ false\n\/\/\/ >>> is_prime(1)\n\/\/\/ false\nfn is_prime(n: isize) -> bool {\n","canonical_solution":"fn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n}\n"},{"task_id":"HumanEval_33","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པའི་ཚད་གཞི་དང་མཚུངས་པ་\/\/\/l'ནི་གྲངས་སུ་མི་བཏུབ་པའི་གྲངས་སུ་ lདང་མཚུངས་ཤིང་། གྲངས་སུ་མི་བཏུབ་པའི་གྲངས་སུ་ l འདྲ་མཉམ་ཡིན།\/\/\/ ལས་འགན་འདི་ནི་ vector l དང་ ཕྱིར་ལོག་བྱེད་ vector l' འདི་ལྟ་བུ་ཡིན་\/\/\/ >>> sort_third(vec![1, 2, 3])\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n\/\/\/ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut divisible_by_three: Vec<(usize, isize)> = l.iter()\n        .enumerate()\n        .filter(|&(i, _)| i % 3 == 0)\n        .map(|(i, &value)| (i, value))\n        .collect();\n\n    \/\/ Sort the values that are at indices divisible by 3\n    divisible_by_three.sort_by_key(|&(_, value)| value);\n\n    let mut result = l.clone();\n    for (sorted_index, (original_index, _)) in divisible_by_three.iter().enumerate() {\n        result[*original_index] = divisible_by_three[sorted_index].1;\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"},{"task_id":"HumanEval_34","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཝེ་ཊར་ནང་དབྱེ་བ་ཕྱེ་བའི་ཆ་ཤས་རྐྱང་པ་ཕྱིར་ལོག་བྱེད།\/\/\/ >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ vec![0, 2, 3, 5, 9, 123]\nfn unique(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn unique(mut l: Vec<isize>) -> Vec<isize> {\n    l.sort_unstable();\n    l.dedup();\n    l\n}\n\nfn main() {\n    let result = unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]);\n    println!(\"{:?}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = unique;\n    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);\n}\n"},{"task_id":"HumanEval_35","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཝི་ཅཊར་ནང་ཤུགས་ཚད་མང་ཤོས་ཕྱིར་ལོག་བྱེད།\/\/\/ >>> max_element(vec![1, 2, 3])\n\/\/\/ 3\n\/\/\/ >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ 123\nfn max_element(l: Vec<isize>) -> isize {\n","canonical_solution":"fn max_element(l: Vec<isize>) -> isize {\n    l.into_iter().max().unwrap()\n}","tests":"}\n\nfn main() {\n    let candidate = max_element;\n    assert_eq!(candidate(vec![1, 2, 3]), 3);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);\n}\n"},{"task_id":"HumanEval_36","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ གྲངས་ 7 ནི་ 11 དང་ 13 ཀྱིས་ཆ་བགོས་ཐུབ་པའི་ n ལས་ཆུང་བའི་ཧྲིལ་གྲངས་ནང་ཐེངས་གྲངས་ཕྱིར་ལོག་བྱེད།\/\/\/ >>> fizz_buzz(50)\n\/\/\/ 0\n\/\/\/ >>> fizz_buzz(78)\n\/\/\/ 2\n\/\/\/ >>> fizz_buzz(79)\n\/\/\/ 3\nfn fizz_buzz(n: isize) -> isize {\n","canonical_solution":"fn fizz_buzz(n: isize) -> isize {\n    (0..n)\n        .filter(|&x| x % 11 == 0 || x % 13 == 0)\n        .flat_map(|x| x.to_string().chars())\n        .filter(|&c| c == '7')\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = fizz_buzz;\n    assert_eq!(candidate(50), 0);\n    assert_eq!(candidate(78), 2);\n    assert_eq!(candidate(79), 3);\n    assert_eq!(candidate(100), 3);\n    assert_eq!(candidate(200), 6);\n    assert_eq!(candidate(4000), 192);\n    assert_eq!(candidate(10000), 639);\n    assert_eq!(candidate(100000), 8026);\n}\n"},{"task_id":"HumanEval_37","nl":"bod_Tibt","pl":"rs","prompt":"\/\/ཚད་ལྡན་གྱི་ཚད་གཞི་དང་མཚུངས་པའི་གྲངས་ཐང་ཡིན་ཀྱང་། ཚད་གཞི་དང་མཚུངས་པའི་གྲངས་ཐང་ཡིན་པར་ངེས་སོ།\/\/ཚད་ལྡན་གྱི་ནང་ལ་ l དང་མཚུངས་པ་དང་། ཚད་ལྡན་གྱི་ནང་ལ་ l འདྲ་མཉམ་ཡིན།\/\/\/ ལས་འགན་འདི་ནི་ vector l དང་ ཕྱིར་ལོག་བྱེད་ vector l' འདི་ལྟ་བུ་ཡིན་\/\/\/ >>> sort_even(vec![1, 2, 3])\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> sort_even(vec![5, 6, 3, 4])\n\/\/\/ vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_even(l: Vec<isize>) -> Vec<isize> {\n    \/\/ Collect even indexed elements and sort them\n    let mut even_elements: Vec<isize> = l.iter().enumerate()\n        .filter(|&(i, _)| i % 2 == 0)\n        .map(|(_, &val)| val)\n        .collect();\n    even_elements.sort();\n\n    \/\/ Reconstruct the vector `l'`\n    let mut result = l.clone();\n    let mut even_index = 0;\n\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n            result[i] = even_elements[even_index];\n            even_index += 1;\n        }\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"},{"task_id":"HumanEval_39","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ prime_fib དེ་ནི་ཨང་གྲངས་ n-th དེ་ནི་ཕི་བྷོ་ན་ཅིའི་གྲངས་ཀ་ཞིག་ཡིན་པ་དང་དེ་ཡང་ཨང་གྲངས་དང་པོ་ཡིན།\/\/\/ >>> prime_fib(1)\n\/\/\/ 2\n\/\/\/ >>> prime_fib(2)\n\/\/\/ 3\n\/\/\/ >>> prime_fib(3)\n\/\/\/ 5\n\/\/\/ >>> prime_fib(4)\n\/\/\/ 13\n\/\/\/ >>> prime_fib(5)\n\/\/\/ 89\nfn prime_fib(n: isize) -> isize {\n","canonical_solution":"fn prime_fib(n: isize) -> isize {\n    fn is_prime(num: isize) -> bool {\n        if num <= 1 {\n            return false;\n        }\n        if num <= 3 {\n            return true;\n        }\n        if num % 2 == 0 || num % 3 == 0 {\n            return false;\n        }\n        let mut i = 5;\n        while i * i <= num {\n            if num % i == 0 || num % (i + 2) == 0 {\n                return false;\n            }\n            i += 6;\n        }\n        true\n    }\n\n    fn fibonacci() -> impl Iterator<Item = isize> {\n        let mut a: isize = 0;\n        let mut b: isize = 1;\n        std::iter::from_fn(move || {\n            let next = a + b;\n            a = b;\n            b = next;\n            Some(a)\n        })\n    }\n\n    let mut count = 0;\n    for fib_num in fibonacci() {\n        if is_prime(fib_num) {\n            count += 1;\n            if count == n {\n                return fib_num;\n            }\n        }\n    }\n    -1\n}","tests":"}\n\nfn main() {\n    let candidate = prime_fib;\n    assert_eq!(candidate(1), 2);\n    assert_eq!(candidate(2), 3);\n    assert_eq!(candidate(3), 5);\n    assert_eq!(candidate(4), 13);\n    assert_eq!(candidate(5), 89);\n    assert_eq!(candidate(6), 233);\n    assert_eq!(candidate(7), 1597);\n    assert_eq!(candidate(8), 28657);\n    assert_eq!(candidate(9), 514229);\n    assert_eq!(candidate(10), 433494437);\n}\n"},{"task_id":"HumanEval_40","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ sum to zero, and false otherwise. འབོར་ཆ་ནི་ ༠ དང་། གཞན་དོན་ནི་རྫུས་མ་ཡིན།\/\/\/ it returns true གལ་ཏེ་བེ་ཊར་ནང་ཁྱད་པར་ཅན་གྱི་ཆ་ཤས་གསུམ་ཡོད་ན་དེ་ \/\/\/ triples_sum_to_zero ནང་འཇུག་ལྟར་གྲངས་ཧྲིལ་གྱི་བེ་ཊར་ལེན་པ།\/\/\/ >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(vec![1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(vec![1])\n\/\/\/ false\nfn triples_sum_to_zero(l: Vec<isize>) -> bool {\n","canonical_solution":"fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    let n = l.len();\n    if n < 3 {\n        return false;\n    }\n\n    let mut sorted_l = l.clone();\n    sorted_l.sort();\n\n    for i in 0..n-2 {\n        let a = sorted_l[i];\n        let mut left = i + 1;\n        let mut right = n - 1;\n\n        while left < right {\n            let sum = a + sorted_l[left] + sorted_l[right];\n            if sum == 0 {\n                return true;\n            } else if sum < 0 {\n                left += 1;\n            } else {\n                right -= 1;\n            }\n        }\n    }\n\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n}\n"},{"task_id":"HumanEval_41","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ལས་འགན་འདི་གིས་ འདྲ་བའི་བརྡབ་སྐྱོན་གྱི་གྲངས་ཀ་ཕྱིར་འདོན་བྱེད།\/\/སྐར་མ་གཉིས་དང་སྐར་མ་གཉིས་བར་གྱི་རྒྱང་ཚད་ལ་མཚོན་ན། སྐར་མ་གཉིས་དང་སྐར་མ་གཉིས་བར་གྱི་རྒྱང་ཚད་ལ་མཚོན་ན། སྐར་མ་གཉིས་དང་སྐར་མ་གཉིས་བར་གྱི་རྒྱང་ཚད་ལ་མཚོན་ན།\/\/ཡིན་ན་ཡང་ཤིང་རྟ་ཚོ་ཧ་ཅང་བརྟན་པོ་དང་ཤུགས་ཆེན་པོ་ཡོད་སྟབས་དེ་དག་མུ་མཐུད་འགྲོ་གི་འདུག\/\/ཕྱོགས་གང་ནས་འགྲོ་བའི་ཤིང་རྟ་ཞིག་གིས་ཕྱོགས་གང་ནས་འགྲོ་བའི་ཤིང་རྟ་ཞིག་ལ་བརྡུང་ན།\/\/སྣུམ་འཁོར་ཚང་མ་དུས་མཚུངས་ཀྱི་མྱུར་ཚད་ལ་འགྲོ་གི་ཡོད། སྣུམ་འཁོར་གཉིས་བརྡབ་སྐྱོན་བྱུང་ཞེས་བརྗོད་ཀྱི་ཡོད།\/\/ཕྱོགས་གཡས་གཡོན་གཉིས་ནས་འགྲོ་གི་འདུག སྣུམ་འཁོར་གྱི་སྡེ་ཚན་གཉིས་ནི་ ཕྱོགས་གཡས་གཡོན་ནས་འགྲོ་གི་འདུག\/\/ཕྱོགས་གཅིག་ཏུ་འཁོར་ལོ་ n ཙམ་འཁོར་བ་ n ཙམ་ཡོད།\/\/ཚད་མེད་རིང་བའི་ཕྲེང་བ་དྲང་པོ་ཞིག་ཡིན་པ་བསམ་བློ་བཏང་ཞིགfn car_race_collision(n: isize) -> isize {\n","canonical_solution":"fn car_race_collision(n: isize) -> isize {\n    \/\/ Since every car moving left to right will collide exactly once\n    \/\/ with every car moving right to left, the number of collisions is n * n\n    n * n\n}\n\nfn main() {\n    let n = 5;\n    println!(\"Number of collisions: {}\", car_race_collision(n));\n}","tests":"}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"},{"task_id":"HumanEval_42","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཕྱིར་ལོག་གི་བེ་ཊར་ལ་ཆ་ཤས་ ༡ ཀྱིས་ཡར་སེང་བྱས་ཡོད།\/\/\/ >>> incr_list(vec![1, 2, 3])\n\/\/\/ vec![2, 3, 4]\n\/\/\/ >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ vec![6, 4, 6, 3, 4, 4, 10, 1, 124]\nfn incr_list(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn incr_list(l: Vec<isize>) -> Vec<isize> {\n    l.iter().map(|&x| x + 1).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = incr_list;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);\n    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);\n}\n"},{"task_id":"HumanEval_43","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ sum to zero, and false otherwise. འབོར་ཆ་ནི་ ༠ དང་། གཞན་དོན་ནི་རྫུས་མ་ཡིན།\/\/\/ it returns true གལ་ཏེ་བེ་ཊར་ནང་ཁྱད་པར་ཅན་གྱི་ཆ་ཤས་གཉིས་ཡོད་ན་དེ་འདྲ་ཡིན་ན།\/\/\/ pairs_sum_to_zero ནང་འཇུག་ལྟར་གྲངས་ཧྲིལ་གྱི་བེ་ཊར་ལེན་པ།\/\/\/ >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n\/\/\/ true\n\/\/\/ >>> pairs_sum_to_zero(vec![1])\n\/\/\/ false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n","canonical_solution":"fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    use std::collections::HashSet;\n    let mut seen = HashSet::new();\n    \n    for &num in &l {\n        if seen.contains(&-num) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 3, 5, 0])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 3, -2, 1])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 2, 3, 7])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])); \/\/ true\n    println!(\"{}\", pairs_sum_to_zero(vec![1])); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"},{"task_id":"HumanEval_44","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ གཞི་གྲངས་ནི་ ༡༠ ལས་ཆུང་བ་རེད།\/\/\/ ཕྱིར་ལོག string representation རྗེས་ཀྱི་བསྒྱུར་བཅོས་བྱེད་སྟངས།\/\/\/ ནང་འཇུག་གྲངས་ x གི་གྲངས་གཞི་གཞི་བསྒྱུར་བྱེད།\/\/\/ >>> change_base(8, 3)\n\/\/\/ String::from(\"22\")\n\/\/\/ >>> change_base(8, 2)\n\/\/\/ String::from(\"1000\")\n\/\/\/ >>> change_base(7, 2)\n\/\/\/ String::from(\"111\")\nfn change_base(x: isize, base: isize) -> String {\n","canonical_solution":"fn change_base(x: isize, base: isize) -> String {\n    if base < 2 || base > 9 {\n        panic!(\"Base must be between 2 and 9\");\n    }\n    \n    if x == 0 {\n        return String::from(\"0\");\n    }\n    \n    let mut result = String::new();\n    let mut number = x;\n    \n    while number > 0 {\n        let remainder = number % base;\n        result.push_str(&remainder.to_string());\n        number \/= base;\n    }\n    \n    result.chars().rev().collect()\n}","tests":"}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"},{"task_id":"HumanEval_45","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཟུར་གསུམ་གྱི་རིང་ཚད་དང་མཐོ་ཚད་ཀྱི་ལོག་ཕྱོགས་ཀྱི་ས་ཆ་རྩིས་ཡོད་ན།\/\/\/ >>> triangle_area(5, 3)\n\/\/\/ 7.5\nfn triangle_area(a: isize, h: isize) -> f64 {\n","canonical_solution":"fn triangle_area(a: isize, h: isize) -> f64 {\n    (a as f64 * h as f64) \/ 2.0\n}\n\nfn main() {\n    let area = triangle_area(5, 3);\n    println!(\"{}\", area);\n}","tests":"}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(5, 3), 7.5);\n    assert_eq!(candidate(2, 2), 2.0);\n    assert_eq!(candidate(10, 8), 40.0);\n}\n"},{"task_id":"HumanEval_46","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཕབ་ལེན་བྱེད་ན་ fib4 གྲངས་རིམ་གྱི་ n-th ཆ་ཤས་ངེས་གཏན་ཆེད་ལས་འགན་ཞིག་བྲིས་རོགས། སླར་ལོག་མི་འཇུག་ཅིག\/\/\/ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) ཟེར་བ་ལྟ་བུ།\/\/\/ fib4(3) -> 0 \/\/\/ fib4(2) -> 2 \/\/\/ fib4(1) -> 0 \/\/\/ fib4(0) -> 0 \/\/Fib4 ནི་ Fibbonacci གི་རིམ་པ་དང་འདྲ་བའི་རིམ་པ་ཞིག་ཡིན་ཏེ། དེའི་འགྲེལ་བཤད་ནི་གཤམ་གསལ་ལྟར་ཡིན།\/\/\/ >>> fib4(5)\n\/\/\/ 4\n\/\/\/ >>> fib4(6)\n\/\/\/ 8\n\/\/\/ >>> fib4(7)\n\/\/\/ 14\nfn fib4(n: isize) -> isize {\n","canonical_solution":"fn fib4(n: isize) -> isize {\n    if n < 0 {\n        return 0; \/\/ Define behavior for negative input\n    }\n\n    let mut sequence = vec![0, 0, 2, 0];\n\n    if n < 4 {\n        return sequence[n as usize];\n    }\n\n    for i in 4..=n {\n        let next_value = sequence[(i - 1) as usize] \n                       + sequence[(i - 2) as usize] \n                       + sequence[(i - 3) as usize] \n                       + sequence[(i - 4) as usize];\n        sequence.push(next_value);\n    }\n\n    sequence[n as usize]\n}\n\nfn main() {\n    println!(\"{}\", fib4(5)); \/\/ 4\n    println!(\"{}\", fib4(6)); \/\/ 8\n    println!(\"{}\", fib4(7)); \/\/ 14\n}","tests":"}\n\nfn main() {\n    let candidate = fib4;\n    assert_eq!(candidate(5), 4);\n    assert_eq!(candidate(8), 28);\n    assert_eq!(candidate(10), 104);\n    assert_eq!(candidate(12), 386);\n}\n"},{"task_id":"HumanEval_47","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཝེ་ཊར་ (l) ནང་གི་ཆ་ཤས་ཀྱི་བར་མཚམས་ཕྱིར་ལོག་བྱེད།\/\/\/ >>> median(vec![3, 1, 2, 4, 5])\n\/\/\/ 3.0\n\/\/\/ >>> median(vec![-10, 4, 6, 1000, 10, 20])\n\/\/\/ 15.0\nfn median(l: Vec<isize>) -> f64 {\n","canonical_solution":"fn median(l: Vec<isize>) -> f64 {\n    let mut l = l.clone();\n    l.sort();\n    let len = l.len();\n\n    if len % 2 == 0 {\n        let mid1 = len \/ 2;\n        let mid2 = mid1 - 1;\n        ((l[mid1] as f64) + (l[mid2] as f64)) \/ 2.0\n    } else {\n        l[len \/ 2] as f64\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6, 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n"},{"task_id":"HumanEval_48","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཚད་གཞི་འདི་ནི་ཁ་ཕྱོགས་ཡིན་མིན་བརྟག་དཔྱད་བྱེད།\/\/\/ >>> is_palindrome(String::from(\"\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"aba\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"aaaaa\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"zbcd\"))\n\/\/\/ false\nfn is_palindrome(text: String) -> bool {\n","canonical_solution":"fn is_palindrome(text: String) -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    let len = chars.len();\n    for i in 0..len \/ 2 {\n        if chars[i] != chars[len - 1 - i] {\n            return false;\n        }\n    }\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"},{"task_id":"HumanEval_49","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ Return 2^n modulo p (ཨང་གྲངས་ལ་དོ་སྣང་བྱེད་དགོས།)\/\/\/ >>> modp(3, 5)\n\/\/\/ 3\n\/\/\/ >>> modp(1101, 101)\n\/\/\/ 2\n\/\/\/ >>> modp(0, 101)\n\/\/\/ 1\n\/\/\/ >>> modp(3, 11)\n\/\/\/ 8\n\/\/\/ >>> modp(100, 101)\n\/\/\/ 1\nfn modp(n: isize, p: isize) -> isize {\n","canonical_solution":"fn modp(n: isize, p: isize) -> isize {\n    if p == 1 {\n        return 0;\n    }\n    let mut result = 1;\n    let mut base = 2 % p;\n    let mut exponent = n;\n    \n    while exponent > 0 {\n        if exponent % 2 == 1 {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        exponent \/= 2;\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"},{"task_id":"HumanEval_51","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ remove_vowels འདི་ལས་སྒྲ་དབྱངས་ཀྱི་ཡིག་འབྲུ་ལེན་ཏེ་སྒྲ་དབྱངས་མེད་པའི་ཡིག་འབྲུ་ཕྱིར་སློག་བྱ་བའི་ལས་འགན་ཞིག་ཡིན།\/\/\/ >>> remove_vowels(String::from(\"\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> remove_vowels(String::from(\"abcdef\"))\n\/\/\/ String::from(\"bcdf\")\n\/\/\/ >>> remove_vowels(String::from(\"aaaaa\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> remove_vowels(String::from(\"aaBAA\"))\n\/\/\/ String::from(\"B\")\n\/\/\/ >>> remove_vowels(String::from(\"zbcd\"))\n\/\/\/ String::from(\"zbcd\")\nfn remove_vowels(text: String) -> String {\n","canonical_solution":"fn remove_vowels(text: String) -> String {\n    text.chars()\n        .filter(|&c| !\"aeiouAEIOU\".contains(c))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = remove_vowels;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"abcdef\nghijklm\")), String::from(\"bcdf\nghjklm\"));\n    assert_eq!(candidate(String::from(\"fedcba\")), String::from(\"fdcb\"));\n    assert_eq!(candidate(String::from(\"eeeee\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"acBAA\")), String::from(\"cB\"));\n    assert_eq!(candidate(String::from(\"EcBOO\")), String::from(\"cB\"));\n    assert_eq!(candidate(String::from(\"ybcd\")), String::from(\"ybcd\"));\n}\n"},{"task_id":"HumanEval_52","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ སླར་ལོག་ true གལ་ཏེ་ vector l ནང་གི་གྲངས་ཆ་ཚང་མ་ threshold t ལས་དམའ་བ་ཡིན་ན།\/\/\/ >>> below_threshold(vec![1, 2, 4, 10], 100)\n\/\/\/ true\n\/\/\/ >>> below_threshold(vec![1, 20, 4, 10], 5)\n\/\/\/ false\nfn below_threshold(l: Vec<isize>, t: isize) -> bool {\n","canonical_solution":"fn below_threshold(l: Vec<isize>, t: isize) -> bool {\n    l.iter().all(|&x| x < t)\n}\n\nfn main() {\n    println!(\"{}\", below_threshold(vec![1, 2, 4, 10], 100)); \/\/ true\n    println!(\"{}\", below_threshold(vec![1, 20, 4, 10], 5));  \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = below_threshold;\n    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);\n    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);\n    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);\n}\n"},{"task_id":"HumanEval_53","nl":"bod_Tibt","pl":"rs","prompt":"\/\/གྲངས་ x དང་ y གཉིས་བསྡུར་དགོས།\/\/\/ >>> add(2, 3)\n\/\/\/ 5\n\/\/\/ >>> add(5, 7)\n\/\/\/ 12\nfn add(x: isize, y: isize) -> isize {\n","canonical_solution":"fn add(x: isize, y: isize) -> isize {\n    x + y\n}","tests":"}\n\nfn main() {\n    let candidate = add;\n    assert_eq!(candidate(0, 1), 1);\n    assert_eq!(candidate(1, 0), 1);\n    assert_eq!(candidate(2, 3), 5);\n    assert_eq!(candidate(5, 7), 12);\n    assert_eq!(candidate(7, 5), 12);\n}\n"},{"task_id":"HumanEval_54","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཚིག་གཉིས་ཡིག་འབྲུ་འདྲ་མཚུངས་ཡོད་མེད་བརྟག་དཔྱད་བྱེད།\/\/\/ >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))\n\/\/\/ false\n\/\/\/ >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))\n\/\/\/ false\n\/\/\/ >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))\n\/\/\/ false\nfn same_chars(s0: String, s1: String) -> bool {\n","canonical_solution":"use std::collections::HashSet;\n\nfn same_chars(s0: String, s1: String) -> bool {\n    let set0: HashSet<char> = s0.chars().collect();\n    let set1: HashSet<char> = s1.chars().collect();\n    set0 == set1\n}\n\nfn main() {\n    println!(\"{}\", same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))); \/\/ false\n    println!(\"{}\", same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))); \/\/ false\n    println!(\"{}\", same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"aabb\"), String::from(\"aaccc\")), false);\n}\n"},{"task_id":"HumanEval_55","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཕི་བོ་ན་ཅིའི་གྲངས་ n སླར་ལོག་བྱེད།\/\/\/ >>> fib(10)\n\/\/\/ 55\n\/\/\/ >>> fib(1)\n\/\/\/ 1\n\/\/\/ >>> fib(8)\n\/\/\/ 21\nfn fib(n: isize) -> isize {\n","canonical_solution":"fn fib(n: isize) -> isize {\n    match n {\n        0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }\n}\n\nfn main() {\n    println!(\"{}\", fib(10)); \/\/ 55\n    println!(\"{}\", fib(1));  \/\/ 1\n    println!(\"{}\", fib(8));  \/\/ 21\n}","tests":"}\n\nfn main() {\n    let candidate = fib;\n    assert_eq!(candidate(10), 55);\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(8), 21);\n    assert_eq!(candidate(11), 89);\n    assert_eq!(candidate(12), 144);\n}\n"},{"task_id":"HumanEval_56","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ གལ་ཏེ་ཁ་ཕྱེས་པའི་སྒྲོམ་རེ་རེར་མཐའ་མའི་སྒྲོམ་འདྲ་མཉམ་ཡོད་ན་ true སླར་ལོག་བྱེད།\/\/\/ brackets ནི་ \"<\" དང་ \">\" ཀྱི་ཡིག་འབྲུ་ཡིན།\/\/\/ >>> correct_bracketing(String::from(\"<\"))\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(String::from(\"<>\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"<<><>>\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"><<>\"))\n\/\/\/ false\nfn correct_bracketing(brackets: String) -> bool {\n","canonical_solution":"fn correct_bracketing(brackets: String) -> bool {\n    let mut balance = 0;\n    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n            balance += 1;\n        } else if bracket == '>' {\n            balance -= 1;\n            if balance < 0 {\n                return false;\n            }\n        }\n    }\n    \n    balance == 0\n}","tests":"}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n}\n"},{"task_id":"HumanEval_57","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ སླར་ལོག་ true འདི་ནི ཕྲེང་བ་ཅན་གྱི་ཆ་ཤས་རྣམས་གཅིག་མཚུངས་དུ་ཡར་འཕར་བའམ་མར་ཕབ་བྱེད་སྟངས།\/\/\/ >>> monotonic(vec![1, 2, 4, 20])\n\/\/\/ true\n\/\/\/ >>> monotonic(vec![1, 20, 4, 10])\n\/\/\/ false\n\/\/\/ >>> monotonic(vec![4, 1, 0, -10])\n\/\/\/ true\nfn monotonic(l: Vec<isize>) -> bool {\n","canonical_solution":"fn monotonic(l: Vec<isize>) -> bool {\n    if l.len() <= 1 {\n        return true;\n    }\n    \n    let mut increasing = true;\n    let mut decreasing = true;\n    \n    for i in 0..l.len() - 1 {\n        if l[i] < l[i + 1] {\n            decreasing = false;\n        }\n        if l[i] > l[i + 1] {\n            increasing = false;\n        }\n    }\n    \n    increasing || decreasing\n}\n\nfn main() {\n    println!(\"{}\", monotonic(vec![1, 2, 4, 20])); \/\/ true\n    println!(\"{}\", monotonic(vec![1, 20, 4, 10])); \/\/ false\n    println!(\"{}\", monotonic(vec![4, 1, 0, -10])); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = monotonic;\n    assert_eq!(candidate(vec![1, 2, 4, 10]), true);\n    assert_eq!(candidate(vec![1, 2, 4, 20]), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10]), false);\n    assert_eq!(candidate(vec![4, 1, 0, -10]), true);\n    assert_eq!(candidate(vec![4, 1, 1, 0]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);\n    assert_eq!(candidate(vec![9, 9, 9, 9]), true);\n}\n"},{"task_id":"HumanEval_58","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཝེ་ཊར་གཉིས་ཀྱི་ཆེད་དུ་དབྱེ་བ་བཏང་ཡོད་པའི་འདྲ་མིན་གྱི་ཆ་ཤས་ལོག་འཇུག་བྱེད།\/\/\/ >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n\/\/\/ vec![1, 5, 653]\n\/\/\/ >>> common(vec![5, 3, 2, 8], vec![3, 2])\n\/\/\/ vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"use std::collections::HashSet;\n\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    \/\/ Convert both vectors to hash sets to remove duplicates and allow set operations\n    let set1: HashSet<_> = l1.into_iter().collect();\n    let set2: HashSet<_> = l2.into_iter().collect();\n\n    \/\/ Find the intersection of both sets\n    let intersection: HashSet<_> = set1.intersection(&set2).cloned().collect();\n\n    \/\/ Convert the intersection set to a sorted vector\n    let mut result: Vec<_> = intersection.into_iter().collect();\n    result.sort();\n\n    result\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])); \/\/ Should print: [1, 5, 653]\n    println!(\"{:?}\", common(vec![5, 3, 2, 8], vec![3, 2])); \/\/ Should print: [2, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_59","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ n གི་གྲངས་ཀ་མང་ཤོས་ཀྱི་གྲངས་ཀ་མང་པོ་བསྒྱུར་བ། n > 1 དང་གྲངས་ཀ་མང་བ་མིན་པར་བརྟེན།\/\/\/ >>> largest_prime_factor(13195)\n\/\/\/ 29\n\/\/\/ >>> largest_prime_factor(2048)\n\/\/\/ 2\nfn largest_prime_factor(n: isize) -> isize {\n","canonical_solution":"fn largest_prime_factor(mut n: isize) -> isize {\n    let mut largest_factor = 1;\n\n    \/\/ Check for number of twos that divide n\n    while n % 2 == 0 {\n        largest_factor = 2;\n        n \/= 2;\n    }\n\n    \/\/ n must be odd at this point, so we can skip even numbers\n    let mut factor = 3;\n    while factor * factor <= n {\n        while n % factor == 0 {\n            largest_factor = factor;\n            n \/= factor;\n        }\n        factor += 2;\n    }\n\n    \/\/ If n becomes a prime number greater than 2\n    if n > 2 {\n        largest_factor = n;\n    }\n\n    largest_factor\n}\n\nfn main() {\n    println!(\"{}\", largest_prime_factor(13195));\n    println!(\"{}\", largest_prime_factor(2048));\n}","tests":"}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n"},{"task_id":"HumanEval_60","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ sum_to_n ནི་ 1 ནས་ n བར་གྱི་གྲངས་གྲངས་བསྡོམས་པའི་ལས་འགན་ཡིན།\/\/\/ >>> sum_to_n(30)\n\/\/\/ 465\n\/\/\/ >>> sum_to_n(100)\n\/\/\/ 5050\n\/\/\/ >>> sum_to_n(5)\n\/\/\/ 15\n\/\/\/ >>> sum_to_n(10)\n\/\/\/ 55\n\/\/\/ >>> sum_to_n(1)\n\/\/\/ 1\nfn sum_to_n(n: isize) -> isize {\n","canonical_solution":"fn sum_to_n(n: isize) -> isize {\n    n * (n + 1) \/ 2\n}","tests":"}\n\nfn main() {\n    let candidate = sum_to_n;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(6), 21);\n    assert_eq!(candidate(11), 66);\n    assert_eq!(candidate(30), 465);\n    assert_eq!(candidate(100), 5050);\n}\n"},{"task_id":"HumanEval_61","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ གལ་ཏེ་ཁ་ཕྱེས་པའི་སྒྲོམ་རེ་རེར་མཐའ་མའི་སྒྲོམ་འདྲ་མཉམ་ཡོད་ན་ true སླར་ལོག་བྱེད།\/\/\/ brackets ནི་ \"(\" དང་ \"\") ཀྱི་ཡིག་འབྲུ་ཡིན།\/\/\/ >>> correct_bracketing(String::from(\"(\"))\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(String::from(\"()\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"(()())\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\")(()\"))\n\/\/\/ false\nfn correct_bracketing(brackets: String) -> bool {\n","canonical_solution":"fn correct_bracketing(brackets: String) -> bool {\n    let mut balance = 0;\n    \n    for c in brackets.chars() {\n        if c == '(' {\n            balance += 1;\n        } else if c == ')' {\n            balance -= 1;\n        }\n\n        if balance < 0 {\n            return false;\n        }\n    }\n    \n    balance == 0\n}","tests":"}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n}\n"},{"task_id":"HumanEval_62","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ འདྲ་བའི་རྣམ་གྲངས་ཀྱི་ཟུར་གྲངས་ཕྱིར་ལོག་བྱེད།\/\/\/ xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/\/ xs ནི་མང་ཚུའི་མཚོན་རྟགས་ཡིན་\/\/\/ >>> derivative(vec![3, 1, 2, 4, 5])\n\/\/\/ vec![1, 4, 12, 20]\n\/\/\/ >>> derivative(vec![1, 2, 3])\n\/\/\/ vec![2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, &coeff) in xs.iter().enumerate().skip(1) {\n        result.push(coeff * i as isize);\n    }\n    result\n}\n\nfn main() {\n    let poly1 = vec![3, 1, 2, 4, 5];\n    let poly2 = vec![1, 2, 3];\n    println!(\"{:?}\", derivative(poly1)); \/\/ Output: [1, 4, 12, 20]\n    println!(\"{:?}\", derivative(poly2)); \/\/ Output: [2, 6]\n}","tests":"}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_63","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཕབ་ལེན་བྱེད་དེ་ཨང་གྲངས་རིམ་པའི་ n-th ནང་གི་ཆ་ཤས་ལེགས་པར་རྩིས་ཐུབ་པའི་ལས་འགན་ཞིག་བྲིས་རོགས།\/\/\/ fib fib (n) == fib fib (n-1) + fib fib (n-2) + fib (n-3)\/\/\/ fib fib (_ _) (2) == 1 \/\/\/ fib fib (_BAR_1) == 0 \/\/\/ fib fib (_ 0) == 0 \/\/FibFib ཨང་རིམ་ནི་ Fibbonacci sequence དང་འདྲ་བའི་རིམ་པ་ཞིག་ཡིན་ཏེ། དེའི་འགྲེལ་བཤད་ནི་གཤམ་གསལ་ལྟར་ཡིན།\/\/\/ >>> fibfib(1)\n\/\/\/ 0\n\/\/\/ >>> fibfib(5)\n\/\/\/ 4\n\/\/\/ >>> fibfib(8)\n\/\/\/ 24\nfn fibfib(n: isize) -> isize {\n","canonical_solution":"fn fibfib(n: isize) -> isize {\n    if n < 0 {\n        \/\/ Optionally handle negative indices as an error or specific value\n        return -1; \/\/ Example error indicator\n    }\n    match n {\n        0 => 0,\n        1 => 0,\n        2 => 1,\n        _ => {\n            let mut a = 0;\n            let mut b = 0;\n            let mut c = 1;\n            let mut result = 0;\n            for _ in 3..=n {\n                result = a + b + c;\n                a = b;\n                b = c;\n                c = result;\n            }\n            result\n        }\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = fibfib;\n    assert_eq!(candidate(2), 1);\n    assert_eq!(candidate(1), 0);\n    assert_eq!(candidate(5), 4);\n    assert_eq!(candidate(8), 24);\n    assert_eq!(candidate(10), 81);\n    assert_eq!(candidate(12), 274);\n    assert_eq!(candidate(14), 927);\n}\n"},{"task_id":"HumanEval_64","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/\/ vowel, ཡིན་ནའང་ཚིག་གི་མཇུག་ཏུ་ཡོད་ན་ཁོ་ན་ཡིན།\/\/འདིར་སྒྲ་དབྱངས་ཀྱི་རྣམ་པ་ནི་ \"a\", \"e\", \"i\", \"o\", \"u\" རྣམས་ཡིན། འདིར་ \"y\" ཀྱང་ a ཡིན་འདུག\/\/\/ ཚིག་ཡིག་ཅིག་ནང་འཇུག་བྱེད་དེ་ string ནང་གི་སྒྲ་སྒྲ་གྲངས་ལོག་འཇུག་བྱེད།\/\/\/ function vowels_count ཡིག་སྒྱུར་བྱེད་དེ། ཟེར་བའི་ཡིག་འབྲུ་ཞིག་ལེན་དགོས།\/\/\/ >>> vowels_count(String::from(\"abcde\"))\n\/\/\/ 2\n\/\/\/ >>> vowels_count(String::from(\"ACEDY\"))\n\/\/\/ 3\nfn vowels_count(s: String) -> isize {\n","canonical_solution":"fn vowels_count(s: String) -> isize {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let s = s.to_lowercase();\n    let mut count = 0;\n\n    for (i, c) in s.chars().enumerate() {\n        if vowels.contains(&c) || (c == 'y' && i == s.len() - 1) {\n            count += 1;\n        }\n    }\n    \n    count\n}\n\nfn main() {\n    println!(\"{}\", vowels_count(String::from(\"abcde\"))); \/\/ Output: 2\n    println!(\"{}\", vowels_count(String::from(\"ACEDY\"))); \/\/ Output: 3\n}","tests":"}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"},{"task_id":"HumanEval_65","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ shift > གྲངས་ཀ་ཁ་བསྒྱུར་ན། return གྲངས་ཀ་ཁ་བསྒྱུར་དགོས།\/\/འབྲས་བུ་ནི་ string སྦེ་སླར་ལོག་འབདཝ་ཨིན།\/\/ཕྱོགས་ཀྱི་གྲངས་ཐང་ x གི་གྲངས་ཐང་རྣམས་ཕྱོགས་ཀྱི་གྲངས་ཐང་ x གི་གྲངས་ཐང་རྣམས་ཕྱོགས་ཀྱི་གྲངས་ཐང་ ཀྱིས་ཕྱོགས་ཀྱི་གྲངས་ཐང་ ཀྱིས་ཕྱོགས་ཀྱི་གྲངས་ཐང་ ཀྱིས་ཕྱོགས་ཀྱི་གྲངས་ཐང་ ཀྱིས་ཕྱོགས་ཀྱི་གྲངས་ཐང་ ཀྱིས་ཕྱོགས་ཀྱི་གྲངས་ཐང་ ཀྱིས་ཕྱོགས་ཀྱི་གྲངས་ཐང་ ཀྱིས་ཕྱོགས་ཀྱི་གྲངས་ཐང་ ཀྱིས་ཕྱོགས་ཀྱི་གྲངས་ཐང་ ཀྱིས་ཕྱོགས་ཀྱི་གྲངས་ཐང་ ཀྱིས་\/\/\/ >>> circular_shift(12, 1)\n\/\/\/ String::from(\"21\")\n\/\/\/ >>> circular_shift(12, 2)\n\/\/\/ String::from(\"12\")\nfn circular_shift(x: isize, shift: isize) -> String {\n","canonical_solution":"fn circular_shift(x: isize, shift: isize) -> String {\n    let mut digits: Vec<char> = x.abs().to_string().chars().collect();\n    let len = digits.len() as isize;\n    \n    if shift > len {\n        digits.reverse();\n    } else {\n        digits.rotate_right(shift as usize % len as usize);\n    }\n    \n    digits.into_iter().collect()\n}","tests":"}\n\nfn main() {\n    let candidate = circular_shift;\n    assert_eq!(candidate(100, 2), String::from(\"001\"));\n    assert_eq!(candidate(12, 2), String::from(\"12\"));\n    assert_eq!(candidate(97, 8), String::from(\"79\"));\n    assert_eq!(candidate(12, 1), String::from(\"21\"));\n    assert_eq!(candidate(11, 101), String::from(\"11\"));\n}\n"},{"task_id":"HumanEval_66","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ASCIIཡིག་རྟགས་ཡིན།\/\/\/ ལས་འགན་ཅིག་འབྲི་དགོས། འདི་ནང་ string ཅིག་རྩིས་ཏེ་ input སྦེ་ལེན་ཏེ་ upper character གྱི་བསྡོམས་གྲངས་ཕྱིར་ལོག་བྱེད་ཐུབ།\/\/\/ ལས་འགན་ \/\/\/ >>> digitSum(String::from(\"\"))\n\/\/\/ 0\n\/\/\/ >>> digitSum(String::from(\"abAB\"))\n\/\/\/ 131\n\/\/\/ >>> digitSum(String::from(\"abcCd\"))\n\/\/\/ 67\n\/\/\/ >>> digitSum(String::from(\"helloE\"))\n\/\/\/ 69\n\/\/\/ >>> digitSum(String::from(\"woArBld\"))\n\/\/\/ 131\n\/\/\/ >>> digitSum(String::from(\"aAaaaXa\"))\n\/\/\/ 153\nfn digitSum(s: String) -> isize {\n","canonical_solution":"fn digitSum(s: String) -> isize {\n    s.chars()\n     .filter(|c| c.is_uppercase())\n     .map(|c| c as isize)\n     .sum()\n}","tests":"}\n\nfn main() {\n    let candidate = digitSum;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"abAB\")), 131);\n    assert_eq!(candidate(String::from(\"abcCd\")), 67);\n    assert_eq!(candidate(String::from(\"helloE\")), 69);\n    assert_eq!(candidate(String::from(\"woArBld\")), 131);\n    assert_eq!(candidate(String::from(\"aAaaaXa\")), 153);\n    assert_eq!(candidate(String::from(\" How are yOu?\")), 151);\n    assert_eq!(candidate(String::from(\"You arE Very Smart\")), 327);\n}\n"},{"task_id":"HumanEval_67","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ for examble: ཆེད་སྒྲིག\/\/ཙེལ་ནང་ཡོད་པའི་སྨན་འབྲས་ཀྱི་གྲངས་ཀ་སླར་ལོག་བྱ་དགོས།\/\/\/ ཨ་ཁུ་དང་ཀུ་ཤུ་དང་འབྲས་བུ་ཡོངས་བསྡོམས་གྲངས་ཐང་མཚོན་པའི་གྲངས་ཐང་།\/\/འབྲས་བུའི་གྲངས་ཆ་མཉམ་མཚོན་པའི་ཐིག་ཡིག་འདི་ལ།\/\/འབྲས་བུ་ཡོད་པའི་ཙེལ་པོ་ཞིག་ལ་བགོས་པའི་ཤིང་འབྲས་ཡིན།\/\/འདིར་ཁྱོད་ཚོར་ཁ་པར་དང་ཁམ་རྡོག་གི་གྲངས་ཐང་མཚོན་པའི་ སྐུད་པ་ཞིག་སྤྲོད་རྒྱུ་ཡིན།\/\/\/ >>> fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19)\n\/\/\/ 8\n\/\/\/ >>> fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3)\n\/\/\/ 2\n\/\/\/ >>> fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100)\n\/\/\/ 95\n\/\/\/ >>> fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120)\n\/\/\/ 19\nfn fruit_distribution(s: String, n: isize) -> isize {\n","canonical_solution":"fn fruit_distribution(s: String, n: isize) -> isize {\n    let mut parts = s.split_whitespace();\n    let apples: isize = parts.next().unwrap().parse().unwrap();\n    parts.next(); \/\/ skip \"apples\"\n    parts.next(); \/\/ skip \"and\"\n    let oranges: isize = parts.next().unwrap().parse().unwrap();\n    \n    n - (apples + oranges)\n}\n\nfn main() {\n    assert_eq!(fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19), 8);\n    assert_eq!(fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3), 2);\n    assert_eq!(fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100), 95);\n    assert_eq!(fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120), 19);\n    println!(\"All test cases passed!\");\n}","tests":"}\n\nfn main() {\n    let candidate = fruit_distribution;\n    assert_eq!(candidate(String::from(\"5 apples and 6 oranges\"), 19), 8);\n    assert_eq!(candidate(String::from(\"5 apples and 6 oranges\"), 21), 10);\n    assert_eq!(candidate(String::from(\"0 apples and 1 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"1 apples and 0 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"2 apples and 3 oranges\"), 100), 95);\n    assert_eq!(candidate(String::from(\"2 apples and 3 oranges\"), 5), 0);\n    assert_eq!(candidate(String::from(\"1 apples and 100 oranges\"), 120), 19);\n}\n"},{"task_id":"HumanEval_68","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་དང་པོ།: \/\/\/ གལ་ཏེ་ཆ་སྙོམས་གྲངས་མེད་པའམ་བེ་ཊར་སྟོང་པ་ཡོད་ན་སླར་ལོག་བྱ་དགོས།\/\/\/ ཕྱིར་བཏོན་པའི་ཨང་རྟགས་དེ་ ཝི་ཅཊ་ནང་ཕྱིར་ལོག་བྱེད་དེ་དགོས་། [smallest_value, its index], \/\/\/ གལ་ཏེ་ནང་འཇུག་རྟགས་ཆུང་ཤོས་དང་མཚུངས་པའི་ཨང་གྲངས་མང་པོ་བསྡུས་ན་ཨང་གྲངས་ཆུང་ཤོས་ཡོད་པའི་ཨང་གྲངས་ཕྱིར་ལོག་བྱེད།\/\/ཕྲ་བའི་ཨང་གྲངས་ནི་ཉུང་ཤོས་ཡིན་པའི་ཨང་གྲངས་ཡིན་དགོས།\/\/ཁྱོད་ཀྱི་ལས་འགན་ནི་ཨང་རྟགས་གཅིག་བཏོན་ནས་ཕྱིར་ལོག་བྱེད་རྒྱུ་དེ་ཡིན།\/\/\" འབྲས་བུ་མེད་པའི་ཧྲིལ་གྲངས་ཀྱི་སྒོ་གྲངས་ཡོད་པའི་ཤིང་སྡོང་གི་ཡལ་ག་མཚོན་པའི་ ཝི་ཅར་ཞིག་ཡོད་ན།\/\/\/ >>> pluck(vec![4, 2, 3])\n\/\/\/ vec![2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 2:\n\/\/\/ >>> pluck(vec![1, 2, 3])\n\/\/\/ vec![2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 3:\n\/\/\/ >>> pluck(vec![])\n\/\/\/ Vec::<isize>::new()\n\/\/\/ Example 4:\n\/\/\/ >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\/\/\/ vec![0, 1]\n\/\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/\/ so we will choose the first zero, which has the smallest index.\n\/\/\/ Constraints:\n\/\/\/ * 1 <= nodes.length <= 10000\n\/\/\/ * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even: Option<(isize, usize)> = None;\n\n    for (index, &value) in arr.iter().enumerate() {\n        if value % 2 == 0 {\n            match smallest_even {\n                None => smallest_even = Some((value, index)),\n                Some((smallest_value, _)) if value < smallest_value => smallest_even = Some((value, index)),\n                _ => {}\n            }\n        }\n    }\n\n    match smallest_even {\n        Some((value, index)) => vec![value, index as isize],\n        None => Vec::new(),\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_69","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ གལ་ཏེ་གོང་ཚད་དེ་མེད་ན་ -1 སླར་ལོག་བྱེད།\/\/སྐར་གྲངས་ཀྱི་འཕྲལ་ཆེན། སྐར་གྲངས་ཀྱི་འཕྲལ་ཆེན། སྐར་གྲངས་ཀྱི་འཕྲལ་ཆེན། སྐར་གྲངས་ཀྱི་འཕྲལ་ཆེན། སྐར་གྲངས་ཀྱི་འཕྲལ་ཆེན།\/\/\/ ༠ དང་དེའི་འཕྲལ་ཆེར་གྲངས་ཆ་རང་དང་མཚུངས་པའམ་དེ་ལས་ཆེ་བ་ཡིན།\/\/འདིར་ཁྱེད་ཚོར་ཆ་མཉམ་པའི་ཆ་མཉམ་པའི་གྲངས་ཆ་མེད་པའི་བེ་ཊར་ཞིག་སྤྲད་ཡོད། ཇི་ལྷག་མང་བ་ཡོད་ན་ཨང་གྲངས་ཆ་ཚང་ ཕྱིར་ལོག་བྱོས་དང་།\/\/\/ >>> search(vec![4, 1, 2, 2, 3, 1])\n\/\/\/ 2\n\/\/\/ >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/\/ 3\n\/\/\/ >>> search(vec![5, 5, 4, 4, 4])\n\/\/\/ -1\nfn search(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn search(lst: Vec<isize>) -> isize {\n    use std::collections::HashMap;\n    \n    let mut frequency_map = HashMap::new();\n    \n    \/\/ Count the frequency of each integer in the vector\n    for &num in &lst {\n        *frequency_map.entry(num).or_insert(0) += 1;\n    }\n    \n    let mut result = -1;\n    \n    \/\/ Iterate over the map to find the greatest integer with a frequency\n    \/\/ greater than or equal to its value\n    for (&num, &freq) in &frequency_map {\n        if freq >= num && num > result {\n            result = num;\n        }\n    }\n    \n    result\n}\n\n\/\/ Test cases\nfn main() {\n    assert_eq!(search(vec![4, 1, 2, 2, 3, 1]), 2);\n    assert_eq!(search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4]), 3);\n    assert_eq!(search(vec![5, 5, 4, 4, 4]), -1);\n}","tests":"}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);\n    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);\n    assert_eq!(candidate(vec![3, 3]), -1);\n    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);\n    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);\n    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);\n    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);\n    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);\n    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);\n    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);\n    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);\n    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);\n    assert_eq!(candidate(vec![1]), 1);\n    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);\n    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);\n    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);\n    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);\n    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);\n    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);\n    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);\n    assert_eq!(candidate(vec![10]), -1);\n    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);\n    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);\n    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);\n    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);\n}\n"},{"task_id":"HumanEval_70","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ དེའི་རྗེས་ལ་ལྷག་ལུས་ཧྲིལ་གྲངས་ཀྱི་ཆེ་མཐར། དེའི་རྗེས་ལ་ཉུང་མཐར། ཟེར་བ་ལྟ་བུ།\/\/ཇི་ཙམ་གལ་ཆེ་བས་གལ་ཆེ་བ་ཡིན་པའི་ཆ་ནས་འགོ་བརྩམས་པ།\/\/སྐར་ཆ་གྲངས་ཚང་གི་བེ་ཊར་ཡོད་ན། བེ་ཊར་ལོག་པའི་རིམ་པ་རྣམ་རྟོག་ཡིན།\/\/\/ >>> strange_sort_list(vec![1, 2, 3, 4])\n\/\/\/ vec![1, 4, 2, 3]\n\/\/\/ >>> strange_sort_list(vec![5, 5, 5, 5])\n\/\/\/ vec![5, 5, 5, 5]\n\/\/\/ >>> strange_sort_list(vec![])\n\/\/\/ Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn strange_sort_list(mut lst: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(lst.len());\n    lst.sort();\n\n    while !lst.is_empty() {\n        \/\/ Take the smallest element\n        if let Some(min) = lst.first().cloned() {\n            result.push(min);\n            lst.remove(0);\n        }\n        \/\/ Take the largest element\n        if let Some(max) = lst.last().cloned() {\n            result.push(max);\n            lst.pop();\n        }\n    }\n\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", strange_sort_list(vec![1, 2, 3, 4])); \/\/ Output: vec![1, 4, 2, 3]\n    println!(\"{:?}\", strange_sort_list(vec![5, 5, 5, 5])); \/\/ Output: vec![5, 5, 5, 5]\n    println!(\"{:?}\", strange_sort_list(vec![])); \/\/ Output: Vec::<isize>::new()\n}","tests":"}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n"},{"task_id":"HumanEval_71","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/\/ ཤོག་ངོས་གསུམ་པ་ལས་ཀྱང་ལེགས་པ་ཡོད།\/\/ཕྱོགས་གསུམ་གྱི་ཆ་སྙོམས་ནི་ཕྱོགས་གཉིས་ལས་མང་བ་ཡིན་ན་རྣམ་གསུམ་ལྡན་པ་བཟོའ ་ི\/\/\/ དེ་མིན་ཕྱིར་ལོག་བྱེད་ -1 \/\/\/ ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་ཟུར་གསུམ་\/\/ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་རིང་ཚད་ཡོད་ན། གྱི་ཁྱབ་ཚད་སླར་ལོག་བྱ་དགོས།\/\/\/ >>> triangle_area(3, 4, 5)\n\/\/\/ 6.0\n\/\/\/ >>> triangle_area(1, 2, 10)\n\/\/\/ -1.0\nfn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n","canonical_solution":"fn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 \/ 2.0;\n        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n        (area * 100.0).round() \/ 100.0\n    } else {\n        -1.0\n    }\n}\n\nfn main() {\n    println!(\"{}\", triangle_area(3, 4, 5)); \/\/ 6.0\n    println!(\"{}\", triangle_area(1, 2, 10)); \/\/ -1.0\n}","tests":"}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(3, 4, 5), 6.0);\n    assert_eq!(candidate(1, 2, 10), -1.0);\n    assert_eq!(candidate(4, 8, 5), 8.18);\n    assert_eq!(candidate(2, 2, 2), 1.73);\n    assert_eq!(candidate(1, 2, 3), -1.0);\n    assert_eq!(candidate(10, 5, 7), 16.25);\n    assert_eq!(candidate(2, 6, 3), -1.0);\n    assert_eq!(candidate(1, 1, 1), 0.43);\n    assert_eq!(candidate(2, 2, 10), -1.0);\n}\n"},{"task_id":"HumanEval_72","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/དངོས་པོ་ q དེ་ཚད་ལྡན་ཡིན་ན་འཕུར་བར་བྱེད། (དེ་ནི་བེ་ཊར་ palindromic ཡིན།) ཤུགས་ཚད་ཀྱི་ཆ་སྙོམས་ནི་ནུས་ཚད་མཐོར་ w ལས་ཆུང་བའམ་མཚུངས་པ་ཡིན།\/\/གལ་ཏེ་དངོས་པོ་ q གྱིས་འཕུར་བའི་སྐབས་ true སླར་ལོག་བྱེད་པ་དང་གཞན་ན་ false སླར་ལོག་བྱེད་པའི་ལས་འགན་ཞིག་བྲིས་དགོས།\/\/\/ >>> will_it_fly(vec![1, 2], 5)\n\/\/\/ false\n\/\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/\/ >>> will_it_fly(vec![3, 2, 3], 1)\n\/\/\/ false\n\/\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/\/ >>> will_it_fly(vec![3, 2, 3], 9)\n\/\/\/ true\n\/\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/\/ >>> will_it_fly(vec![3], 5)\n\/\/\/ true\n\/\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n","canonical_solution":"fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let is_palindromic = q.iter().eq(q.iter().rev());\n\n    is_palindromic && sum <= w\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{}\", will_it_fly(vec![1, 2], 5)); \/\/ false\n    println!(\"{}\", will_it_fly(vec![3, 2, 3], 1)); \/\/ false\n    println!(\"{}\", will_it_fly(vec![3, 2, 3], 9)); \/\/ true\n    println!(\"{}\", will_it_fly(vec![3], 5)); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"},{"task_id":"HumanEval_73","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/\/ འདི་རྒྱབ་མདུན་གཉིས་ཀར་འདྲ་མཚུངས་ཀློག་ཐུབ། འགྱུར་བ་གཅིག་གི་ནང་ཁྱོད་ཀྱིས་ཆ་ཤས་གཅིག་ལ་ཆ་ཤས་གཞན་སུ་བསྒྱུར་ཐུབ།\/\/ཕྱོགས་རིས་ཀྱི་འགྱུར་ཚད་ལ་བསྒྱུར་དགོས་པ་ཡིན། ཕྱོགས་རིས་ཀྱི་འགྱུར་ཚད་ནི་ ཕྱོགས་རིས་ཀྱི་འགྱུར་ཚད་ཡིན།\/\/སྐར་ཆ་མཐའ་དག་གི་མཐའ་གྲངས་ arr ཞིག་ཡོད་ན། སྐར་ཆ་ཉུང་ཤོས་ ཇི་ཡོད་འཚོལ་དགོས།\/\/\/ >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])\n\/\/\/ 4\n\/\/\/ >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])\n\/\/\/ 1\n\/\/\/ >>> smallest_change(vec![1, 2, 3, 2, 1])\n\/\/\/ 0\nfn smallest_change(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn smallest_change(arr: Vec<isize>) -> isize {\n    let mut changes = 0;\n    let n = arr.len();\n    \n    for i in 0..n\/2 {\n        if arr[i] != arr[n - i - 1] {\n            changes += 1;\n        }\n    }\n    \n    changes\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result = smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6]);\n\/\/     println!(\"{}\", result); \/\/ Outputs: 4\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"},{"task_id":"HumanEval_74","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/སྐར་ཆ་གཉིས་ནང་ཡིག་རྟགས་འདྲ་མཚུངས་ཡོད་ན། སྐར་ཆ་དང་པོ་ཕྱིར་ལོག་བྱེད།\/\/སྐར་ཆའི་ཐིག་ཁྲམ་ནང་ཡོད་པའི་ སྐར་ཆའི་གྲངས་ནི་ སྐར་ཆའི་གཞན་གྱི་གྲངས་ལས་ཉུང་བ་ཡིན།\/\/\/ ལས་འགན་ཞིག་བྲིས་ནས་ ཚད་གཞི་གཉིས་དང་ ཚད་གཞི་ ཡོད་པའི་ཚད་གཞི་ཕྱིར་ལོག་བྱེད་ཅིག\/\/\/ >>> total_match(vec![], vec![])\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")])\n\/\/\/ vec![String::from(\"hI\"), String::from(\"Hi\")]\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")])\n\/\/\/ vec![String::from(\"hi\"), String::from(\"admin\")]\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\/\/\/ vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n\/\/\/ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n\/\/\/ vec![String::from(\"4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n    let char_count = |lst: &Vec<String>| lst.iter().map(|s| s.len()).sum::<usize>();\n\n    if char_count(&lst1) <= char_count(&lst2) {\n        lst1\n    } else {\n        lst2\n    }\n}\n\n\/\/ Example usage\nfn main() {\n    let result1 = total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    println!(\"{:?}\", result1);\n\n    let result2 = total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")]);\n    println!(\"{:?}\", result2);\n}","tests":"}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\")]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(), vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"},{"task_id":"HumanEval_75","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/(a) ནི་ 100 ལས་ཆུང་བ་ཡིན་པར་ཤེས་པ་དགོས།\/\/\/ སྐྱོན་བརྗོད་གཞན་ཡང་རྫུན་མ་ཡིན།\/\/\/ གྲངས་ཀ་འདི་ནི་གྲངས་ཀ་གསུམ་གྱི་འབྲས་བུ་ཡིན་ན་ true སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་བྲིས་ཤིག\/\/\/ >>> is_multiply_prime(30)\n\/\/\/ true\n\/\/\/ 30 = 2 * 3 * 5\nfn is_multiply_prime(a: isize) -> bool {\n","canonical_solution":"fn is_multiply_prime(a: isize) -> bool {\n    fn is_prime(n: isize) -> bool {\n        if n <= 1 {\n            return false;\n        }\n        if n <= 3 {\n            return true;\n        }\n        if n % 2 == 0 || n % 3 == 0 {\n            return false;\n        }\n        let mut i = 5;\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 {\n                return false;\n            }\n            i += 6;\n        }\n        true\n    }\n\n    if a < 2 {\n        return false;\n    }\n\n    let mut primes = Vec::new();\n    for i in 2..a {\n        if is_prime(i) {\n            primes.push(i);\n        }\n    }\n\n    let p_len = primes.len();\n    for i in 0..p_len {\n        for j in i..p_len {\n            for k in j..p_len {\n                if primes[i] * primes[j] * primes[k] == a {\n                    return true;\n                }\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = is_multiply_prime;\n    assert_eq!(candidate(5), false);\n    assert_eq!(candidate(30), true);\n    assert_eq!(candidate(8), true);\n    assert_eq!(candidate(10), false);\n    assert_eq!(candidate(125), true);\n    assert_eq!(candidate(105), true);\n    assert_eq!(candidate(126), false);\n    assert_eq!(candidate(729), false);\n    assert_eq!(candidate(891), false);\n    assert_eq!(candidate(1001), true);\n}\n"},{"task_id":"HumanEval_76","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/\/ x ནི་ n གི་རྣམ་གྲངས་གཅིག་པུ་ཡིན་ན། n**int=x \/\/\/ ནུས་པ་ n དང་གཞན་ན་ false ཟེར་བ་ལྟ་བུ།\/\/ཁྱོད་ཀྱི་ལས་འགན་ནི་གྲངས་ x ནི་གྲངས་རྐྱང་པ་ཞིག་ཡིན་ན་ true སླར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་འབྲི་དགོས་པ་ཡིན།\/\/\/ >>> is_simple_power(1, 4)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(2, 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(8, 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(3, 2)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(3, 1)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(5, 3)\n\/\/\/ false\nfn is_simple_power(x: isize, n: isize) -> bool {\n","canonical_solution":"fn is_simple_power(x: isize, n: isize) -> bool {\n    if x <= 0 || n <= 0 {\n        return false;\n    } else if x == 1 {\n        return true;\n    } else if n == 1 {\n        return x == 1;\n    }\n\n    let mut power_n = n;\n    while power_n < x {\n        power_n *= n;\n    }\n    power_n == x\n}\n\nfn main() {\n    println!(\"{}\", is_simple_power(1, 4)); \/\/ true\n    println!(\"{}\", is_simple_power(2, 2)); \/\/ true\n    println!(\"{}\", is_simple_power(8, 2)); \/\/ true\n    println!(\"{}\", is_simple_power(3, 2)); \/\/ false\n    println!(\"{}\", is_simple_power(3, 1)); \/\/ false\n    println!(\"{}\", is_simple_power(5, 3)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"},{"task_id":"HumanEval_77","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ དྲན་གསོ། ཁྱོད་ཀྱིས་གཏན་ནས་གཏན་འབེབས་བྱས་ན་ལེགས་པ་ཡོད།\/\/གལ་ཏེ་འདི་ནི་ཨེན་ཇི་ཇི་ (ingeger) ནི་ཧྲིལ་གྲངས་ཀྱི་གྲུ་བཞི་ཡིན་ན།\/\/\/ function དེ་གྲངས་ཧྲིལ་པོ་ a དང་ true སླར་ལོག་བྱེད་པ་དེ་འབྲི་དགོས།\/\/\/ >>> iscube(1)\n\/\/\/ true\n\/\/\/ >>> iscube(2)\n\/\/\/ false\n\/\/\/ >>> iscube(-1)\n\/\/\/ true\n\/\/\/ >>> iscube(64)\n\/\/\/ true\n\/\/\/ >>> iscube(0)\n\/\/\/ true\n\/\/\/ >>> iscube(180)\n\/\/\/ false\nfn iscube(a: isize) -> bool {\n","canonical_solution":"fn iscube(a: isize) -> bool {\n    if a < 0 {\n        \/\/ For negative numbers, take the cube root of the absolute value.\n        let cube_root = (-a as f64).cbrt();\n        let rounded_cube = cube_root.round() as isize;\n        rounded_cube * rounded_cube * rounded_cube == a\n    } else {\n        let cube_root = (a as f64).cbrt();\n        let rounded_cube = cube_root.round() as isize;\n        rounded_cube * rounded_cube * rounded_cube == a\n    }\n}\n\nfn main() {\n    println!(\"{}\", iscube(1));   \/\/ true\n    println!(\"{}\", iscube(2));   \/\/ false\n    println!(\"{}\", iscube(-1));  \/\/ true\n    println!(\"{}\", iscube(64));  \/\/ true\n    println!(\"{}\", iscube(0));   \/\/ true\n    println!(\"{}\", iscube(180)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n"},{"task_id":"HumanEval_78","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/ཚོས་གཞི་ A,B,C,D,E,F འདི་ཚོ་རྒྱུན་དུ་ཡིག་ཆུང་ཡིན།\/\/\/ དྲན་གསོ། ཁྱོད་ཀྱིས་གཏན་ནས་ནང་འཇུག་དེ་བདེན་པའམ་སྟོང་པ་རེད་བསམ་ཐུབ།\/\/\/ B (= བཅུ་ཚིགས་ 11), D (= བཅུ་ཚིགས་ 13) \/\/འདིར་གཤམ་གསལ་ཨང་གྲངས་ཀྱི་གྲངས་ཀ་འདེམས་དགོས། ༢། ༣། ༥། ༧། \/\/ཕྲ་གྲངས་ནི་ ༢། ༣། ༥། ༧། ༡༡། ༡༣། ༡༧། ...\/\/༦གོང་མའི་ཨང་གྲངས་ནི་ ༠། ༡། ༢། ༣། ༤། ༥། ༦། ༧། ༨། ༩། A། B། C། D། E། F།\/\/\/ 1 ལས་མང་བ་འདི་ནི་གྲངས་ཆུང་བ་གཉིས་ལས་མང་བ་མ་ཡིན་)\/\/\/ དངོས་པོ་གྲངས་སུ་ prime ཟེར་བ་ཡོད།\/\/༦ ཕྲེང་བ་ལྟར་ཨང་གྲངས་ཧེ་ཀ་ཌེ་སི་མལ་གྲངས་སུ་རྩིས་པར་བྱེད།\/\/ཁྱོད་ཀྱིས་ཐོབ་པའི་ལས་འགན་ཞིག་འབྲི་དགོས་པ་ཡིན།\/\/\/ >>> hex_key(String::from(\"AB\"))\n\/\/\/ 1\n\/\/\/ >>> hex_key(String::from(\"1077E\"))\n\/\/\/ 2\n\/\/\/ >>> hex_key(String::from(\"ABED1A33\"))\n\/\/\/ 4\n\/\/\/ >>> hex_key(String::from(\"123456789ABCDEF0\"))\n\/\/\/ 6\n\/\/\/ >>> hex_key(String::from(\"2020\"))\n\/\/\/ 2\nfn hex_key(num: String) -> isize {\n","canonical_solution":"fn hex_key(num: String) -> isize {\n    let prime_hex_chars = vec!['2', '3', '5', '7', 'B', 'D'];\n    num.chars()\n        .filter(|c| prime_hex_chars.contains(c))\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"},{"task_id":"HumanEval_79","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ལྷག་པའི་ཡིག་འབྲུ་ནི་ཡིག་གཟུགས་ལ་ཕན་པའི་ཆེད་དུ་ཡིན།\/\/\/ string གི་འགོ་དང་མཇུག་ཏུ་ 'db' ཡིག་རྟགས་གཉིས་རེ་ལྷག་ཡོད།\/\/string ནང་གི་ཡིག་འབྲུ་རེ་རེར་ '0' ཡང་ན་ '1' ཟེར་བ་ཡོད།\/\/\/ binary format ལས་འགན་གྱིས་ string སླར་ལོག་བྱེད་དགོས། ཡིག་འབྲུ་རེ་རེས་ binary \/\/འདིར་གྲངས་ནི་བཅུ་གྲངས་ཀྱི་རྣམ་པ་ནས་གནང་ཡོད། ཁྱོད་ཀྱི་ལས་འགན་ནི་གྲངས་དེ་ ལ་བསྒྱུར་དགོས་པ་ཡིན།\/\/\/ >>> decimal_to_binary(15)\n\/\/\/ String::from(\"db1111db\")\n\/\/\/ >>> decimal_to_binary(32)\n\/\/\/ String::from(\"db100000db\")\nfn decimal_to_binary(decimal: isize) -> String {\n","canonical_solution":"fn decimal_to_binary(decimal: isize) -> String {\n    let binary_string = format!(\"{:b}\", decimal);\n    format!(\"db{}db\", binary_string)\n}\n\nfn main() {\n    \/\/ Example usage\n    let binary_15 = decimal_to_binary(15);\n    let binary_32 = decimal_to_binary(32);\n    println!(\"{}\", binary_15); \/\/ Outputs: db1111db\n    println!(\"{}\", binary_32); \/\/ Outputs: db100000db\n}","tests":"}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n}\n"},{"task_id":"HumanEval_80","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/string དེ་ haprs ཡིན། གལ་ཏེ་དེའི་རིང་ཚད་ནི་ཉུང་མཐར་ 3 ཡིན། ཡང་ 3 ཡི་གེ་རེ་རེ་ནི་སོ་སོར་དབྱེ་བ་ཡོད།\/\/ཤོག་གྲངས་འདི་ནི་ string ཞིག་ཡོད་མེད་ལ་བརྟག་དཔྱད་བྱ་དགོས་པ་ཡིན།\/\/ཤོག་ངོས་འདི་ཡི་བཟོ་བཅོས་མཐའ་མ་༢༩༩༩ ལ་རེད།\/\/\/ >>> is_happy(String::from(\"a\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"aa\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"abcd\"))\n\/\/\/ true\n\/\/\/ >>> is_happy(String::from(\"aabb\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"adb\"))\n\/\/\/ true\n\/\/\/ >>> is_happy(String::from(\"xyy\"))\n\/\/\/ false\nfn is_happy(s: String) -> bool {\n","canonical_solution":"fn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n\n    let chars: Vec<char> = s.chars().collect();\n    for i in 0..(chars.len() - 2) {\n        if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] || chars[i + 1] == chars[i + 2] {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    println!(\"{}\", is_happy(String::from(\"a\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"aa\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"abcd\"))); \/\/ true\n    println!(\"{}\", is_happy(String::from(\"aabb\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"adb\"))); \/\/ true\n    println!(\"{}\", is_happy(String::from(\"xyy\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"},{"task_id":"HumanEval_81","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/\/ 0.0 E \/\/\/ > 0.0 D- \/\/\/ > 0.7 D \/\/\/ > 1.0 D+ \/\/\/ > 1.3 C- \/\/\/ > 1.7 C \/\/\/ > 2.0 C+ \/\/\/ > 2.3 B- \/\/\/ > 2.7 B \/\/\/ > 3.0 B+ \/\/\/ > 3.3 A- \/\/\/ > 3.7 A \/\/\/ 4.0 A+ \/\/GPA སྐུགས་ཚད་ཨང་གྲངས་\/\/\/ འདི་ནི་གཤམ་གསལ་ཐིག་ཁྲམ་ནང་འཇུག་པའི་ཡིག་རྟགས་ཀྱི་ཚད་གཞི་ཐོན་འཇུག་བྱེད་ནུས་པའི་ལས་འགན་ཡིན།\/\/ཆུང་ཆུང་གིས་ཁྱོད་ལ་སློབ་ཕྲུག་འགའ་ཞིག་གི་ GPA གྱི་ཚད་གཞི་ཞིག་སྤྲད་ཡོད་ཅིང་། ཁྱོད་ཀྱིས་དེ་བྲིས་དགོས་པ་ཡིན།\/\/སྐྱོན་ནི་མོ་ལ་རྟགས་དཔྱད་བྱེད་སྐབས་བེད་སྤྱོད་བྱེད་པའི་ཡིག་ཆ་དེ་བརྗེད་སོང་བ་རེད།\/\/ཆེད་སློབ་ཕྲུག་ཚོར་སློབ་སྟོན་པ་ཚོས་རང་རང་གི་ཚད་གཞི་བཟོ་བཞིན་ཡོད།\/\/སློབ་དུས་ཀྱི་བདུན་ཕྲག་མཇུག་གི་ཉིན་མོ་ཡིན་པས་སློབ་དཔོན་གྱིས་སློབ་ཕྲུག་ཚོར་རྟགས་མཚན་སྤྲོད་དགོས་ཀྱི་འདུག\/\/\/ >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])\n\/\/\/ vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n","canonical_solution":"fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    grades.into_iter().map(|gpa| {\n        match gpa {\n            4.0 => String::from(\"A+\"),\n            v if v > 3.7 => String::from(\"A\"),\n            v if v > 3.3 => String::from(\"A-\"),\n            v if v > 3.0 => String::from(\"B+\"),\n            v if v > 2.7 => String::from(\"B\"),\n            v if v > 2.3 => String::from(\"B-\"),\n            v if v > 2.0 => String::from(\"C+\"),\n            v if v > 1.7 => String::from(\"C\"),\n            v if v > 1.3 => String::from(\"C-\"),\n            v if v > 1.0 => String::from(\"D+\"),\n            v if v > 0.7 => String::from(\"D\"),\n            v if v > 0.0 => String::from(\"D-\"),\n            _ => String::from(\"E\"),\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = numerical_letter_grade;\n    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]);\n    assert_eq!(candidate(vec![1.2]), vec![String::from(\"D+\")]);\n    assert_eq!(candidate(vec![0.5]), vec![String::from(\"D-\")]);\n    assert_eq!(candidate(vec![0.0]), vec![String::from(\"E\")]);\n    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from(\"D\"), String::from(\"D-\"), String::from(\"C-\"), String::from(\"B\"), String::from(\"B+\")]);\n    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from(\"E\"), String::from(\"D-\")]);\n}\n"},{"task_id":"HumanEval_82","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ length ནི་གྲངས་ཀ་མང་པོའམ་ false ཡིན་པ་ངེས་པ་མེད།\/\/\/ ལས་འགན་ཞིག་བྲིས་ནས་ string ཞིག་ལེན་ནས་ true སླར་ལོག་བྱེད་ན།\/\/\/ >>> prime_length(String::from(\"Hello\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"abcdcba\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"kittens\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"orange\"))\n\/\/\/ false\nfn prime_length(string: String) -> bool {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn prime_length(string: String) -> bool {\n    let length = string.len();\n    is_prime(length)\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", prime_length(String::from(\"Hello\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"abcdcba\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"kittens\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"orange\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n    assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")), false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"},{"task_id":"HumanEval_83","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ནི་ 1 དང་འགོ་དང་མཇུག་གི་ཨང་གྲངས་ཚུའི་ནང་ཡོད་པ།\/\/\/ འབྲས་བུ་ལྡན་གྲངས་ n ཞིག་ཡོད་ན། ཨང་གྲངས་ n- digit གི་གྲངས་རྩིས་ཕྱིར་ལོག་བྱོས།fn starts_one_ends(n: isize) -> isize {\n","canonical_solution":"fn starts_one_ends(n: isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    if n == 1 {\n        return 1; \/\/ only '1' satisfies the condition for a single-digit\n    }\n\n    \/\/ Consider numbers starting with '1' (1XXXX...)\n    let start_with_one = 9isize.pow((n-1) as u32);\n\n    \/\/ Consider numbers ending with '1' (...XXXX1)\n    let end_with_one = 9isize.pow((n-1) as u32);\n    \n    \/\/ Consider numbers both starting and ending with '1' and check overlaps (1XXX1)\n    let both_start_end_one = 9isize.pow((n-2) as u32);\n\n    \/\/ Total numbers starting or ending with '1'\n    start_with_one + end_with_one - both_start_end_one\n}\n\nfn main() {\n    \/\/ Example usage:\n    let n = 3;\n    println!(\"Count of n-digit numbers starting or ending with 1: {}\", starts_one_ends(n));\n}","tests":"}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"},{"task_id":"HumanEval_84","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ནུས་ལྡན་ཨང་གྲངས་ N ཞིག་ཡོད་ན། དེའི་ཨང་གྲངས་ཀྱི་བསྡོམས་གྲངས་ཉིས་ལྡན་དུ་ཕྱིར་ལོག་བྱོས། \/\/\/ >>> solve(1000)\n\/\/\/ String::from(\"1\")\n\/\/\/ >>> solve(150)\n\/\/\/ String::from(\"110\")\n\/\/\/ >>> solve(147)\n\/\/\/ String::from(\"1100\")\n\/\/\/ Variables:\n\/\/\/ @N integer\n\/\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/\/ Output:\n\/\/\/ a string of binary number\nfn solve(N: isize) -> String {\n","canonical_solution":"fn solve(N: isize) -> String {\n    let sum_of_digits: isize = N\n        .to_string()\n        .chars()\n        .map(|c| c.to_digit(10).unwrap() as isize)\n        .sum();\n    \n    format!(\"{:b}\", sum_of_digits)\n}","tests":"}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(1000), String::from(\"1\"));\n    assert_eq!(candidate(150), String::from(\"110\"));\n    assert_eq!(candidate(147), String::from(\"1100\"));\n    assert_eq!(candidate(333), String::from(\"1001\"));\n    assert_eq!(candidate(963), String::from(\"10010\"));\n}\n"},{"task_id":"HumanEval_85","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/སྐར་ཆ་གྲངས་མེད་ཀྱི་གྲངས་ཐང་ཡོད་ན། ཐོག་མར་གྲངས་ཆ་ཆ་སྙོམས་དང་གྲངས་ཆ་ཆ་རྐྱང་གི་གྲངས་ཐང་ཡོད་ཚད་བསྡོམས་དགོས།\/\/\/ >>> add(vec![4, 2, 6, 7])\n\/\/\/ 2\nfn add(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn add(lst: Vec<isize>) -> isize {\n    lst.iter()\n        .enumerate()\n        .filter(|(i, _)| i % 2 == 1) \/\/ select odd indices\n        .map(|(_, &x)| x) \/\/ get the values at odd indices\n        .filter(|&x| x % 2 == 0) \/\/ filter even values\n        .sum() \/\/ sum the values\n}","tests":"}\n\nfn main() {\n    let candidate = add;\n    assert_eq!(candidate(vec![4, 88]), 88);\n    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);\n    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);\n    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);\n}\n"},{"task_id":"HumanEval_86","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/\/ དྲན་གསོ། ཁྱོད་ཀྱིས་ཚིག་གི་རིམ་པ་དང་སྟོང་པ་གསལ་བའི་གོ་རིམ་སྲུང་དགོས་པ་ཡིན།\/\/\/ ཡར་འཕུར་གྱི་རིམ་པ་གཞི་རྟེན་ ascii གྱི་རིན་ཐང་ཡིན།\/\/\/ འདི་ལ་ཚིག་གསར་པ་ཞིག་གིས་ཚབ་ཏུ་འཇུག་སྟེ། ནང་ཡིག་རྟགས་ཚང་མ་སྒྲིག་ཡོད་ན།\/\/\/ ordered version of string འདི་ནང་ཚིག་ཆ་ཚང་མ་ (བར་སྟོང་གིས་སོ་སོར་དབྱེ་) ཡོད་པའི་ string ཞིག་ཡིན།\/\/\/ ལས་འགན་ཞིག་བྲིས་ནས་ string དང་དེའི་གོ་རིམ་སྒྲིག་པའི་རྣམ་པ་ཕྱིར་ལོག་བྱེད་པ།\/\/\/ >>> anti_shuffle(String::from(\"Hi\"))\n\/\/\/ String::from(\"Hi\")\n\/\/\/ >>> anti_shuffle(String::from(\"hello\"))\n\/\/\/ String::from(\"ehllo\")\n\/\/\/ >>> anti_shuffle(String::from(\"Hello World!!!\"))\n\/\/\/ String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String) -> String {\n","canonical_solution":"fn anti_shuffle(s: String) -> String {\n    let mut result = String::new();\n    let mut word = String::new();\n\n    for c in s.chars() {\n        if c.is_whitespace() {\n            if !word.is_empty() {\n                let mut chars: Vec<char> = word.chars().collect();\n                chars.sort_unstable();\n                result.push_str(&chars.into_iter().collect::<String>());\n                word.clear();\n            }\n            result.push(c);\n        } else {\n            word.push(c);\n        }\n    }\n\n    if !word.is_empty() {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort_unstable();\n        result.push_str(&chars.into_iter().collect::<String>());\n    }\n\n    result\n}\n\nfn main() {\n    \/\/ Example usages:\n    println!(\"{}\", anti_shuffle(String::from(\"Hi\")));              \/\/ \"Hi\"\n    println!(\"{}\", anti_shuffle(String::from(\"hello\")));           \/\/ \"ehllo\"\n    println!(\"{}\", anti_shuffle(String::from(\"Hello World!!!\")));  \/\/ \"Hello !!!Wdlor\"\n}","tests":"}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"},{"task_id":"HumanEval_87","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ དེ་མིན་གྲལ་རིམ་གྱི་གོ་རིམ་རིམ་རིམ་བཞིན་གྲལ་རིམ་གྱི་གོ་རིམ་རིམ་སྒྲིག་དགོས།\/\/\/ ཐོག་མར་གོ་རིམ་རིམ་བཞིན་གོ་རིམ་བཞིན་གོ་རིམ་སྒྲིག་དགོས།\/\/སྐར་ཁུང་ནང་ 0 ནས་འགོ་ཚུགས་པའི་ ཚད་གཞི་ནི་ སྐར་ཁུང་གི་ ཚད་གཞི་ཡིན།\/\/སྐར་ཆ་དང་སྐར་ཆ་ལོག་པའི་སྐར་ཆ་ནི་ [(x1, y1), (x2, y2) ...] འདི་ལྟ་བུ་ཡིན་ཏེ།\/\/སྐར་ཆ་ lst དང་ཧྲིལ་གྲངས་ x བྱིན་ནས་ སྐར་ཆ་ x གྱི་གྲངས་ཐང་འཚོལ་དགོས།\/\/\/ རེའུ་མིག་རེ་རེར་ཀ་བའི་གྲངས་མི་འདྲ་བ་ཡོད་སྲིད་དོ།\/\/ཇི་ནི་མ་ཊི་རེས་དང་འདྲ་བ་ཞིག་ཡིན། མ་ཊི་རེས་དང་མི་འདྲ་བ་ཞིག་ཡིན།\/\/ཇི་འདྲ་ཡིན་ན་དེ་གཉིས་གཉིས་གཉིས་ཡིན་པའི་རྩིས་གཞི་ཞིག་ཡིན་ཏེ། ཇི་འདྲ་ཡིན་ན་དེ་གཉིས་གཉིས་ཡིན་པའི་རྩིས་གཞི་ཞིག་ཡིན།\/\/\/ >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n\/\/\/ vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\/\/\/ >>> get_row(vec![], 1)\n\/\/\/ Vec::<(isize, isize)>::new()\n\/\/\/ >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n\/\/\/ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n","canonical_solution":"fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut result = Vec::new();\n\n    for (row_index, row) in lst.iter().enumerate() {\n        let mut found_indices: Vec<isize> = row.iter()\n            .enumerate()\n            .filter(|&(_, &value)| value == x)\n            .map(|(col_index, _)| col_index as isize)\n            .collect();\n\n        found_indices.sort_by(|a, b| b.cmp(a)); \/\/ Sort column indices in descending order\n\n        for col_index in found_indices {\n            result.push((row_index as isize, col_index));\n        }\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"},{"task_id":"HumanEval_88","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/* བྱིན་ཡོད་པའི་བེ་ཊར་བསྒྱུར་མི་དགོས།\/\/\/ དྲན་གསོ།: \/\/ཡང་ན་གོང་ནས་གོང་དུ་རིམ་བཞིན་དབྱེ་ན། འབྲས་བུ་ནི་ ((སྔོན་གྱི་ཚད་གཞི་གནས་གོང་དང་རྗེས་མའི་ཚད་གཞི་གནས་གོང་) འདྲ།\/\/\/ ཁྱོད་ཀྱིས་བྱིན་པའི་བེ་ཊར་ལ་ཡར་རྒྱས་ཀྱི་རིམ་པ་བཞིན་དབྱེ་ན། བསྡོམས་ ((ཐོག་མའི་གཞི་གྲངས་ཀྱི་རིན་ཐང་། མཇུག་གི་གཞི་གྲངས་ཀྱི་རིན་ཐང་།) ཇི་འདྲ་ཡིན་ན།\/\/འབྲས་བུ་མེད་པའི་གྲངས་ཚང་གི་བེ་ཊར་ཐོབ་ཡོད་ན། ཚད་འཛིན་བྱས་རྗེས་བེ་ཊར་གྱི་བེ་ཊར་ ཞིག་ཕྱིར་སློག་བྱ་དགོས།\/\/\/ >>> sort_array(vec![])\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> sort_array(vec![5])\n\/\/\/ vec![5]\n\/\/\/ >>> sort_array(vec![2, 4, 3, 0, 1, 5])\n\/\/\/ vec![0, 1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])\n\/\/\/ vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n        return Vec::<isize>::new();\n    }\n\n    let first = array.first().unwrap_or(&0);\n    let last = array.last().unwrap_or(&0);\n    let sum = first + last;\n\n    let mut sorted_array = array.clone();\n    if sum % 2 == 0 {\n        sorted_array.sort_by(|a, b| b.cmp(a)); \/\/ Descending order\n    } else {\n        sorted_array.sort(); \/\/ Ascending order\n    }\n\n    sorted_array\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", sort_array(vec![])); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", sort_array(vec![5])); \/\/ vec![5]\n    println!(\"{:?}\", sort_array(vec![2, 4, 3, 0, 1, 5])); \/\/ vec![0, 1, 2, 3, 4, 5]\n    println!(\"{:?}\", sort_array(vec![2, 4, 3, 0, 1, 5, 6])); \/\/ vec![6, 5, 4, 3, 2, 1, 0]\n}","tests":"}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"},{"task_id":"HumanEval_89","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/\/ འོག་ཏུ་ལྡོག་ 2 ཀྱིས་ 2 ཀྱི་གོ་རིམ་ལ་སྤར་དགོས།\/\/\/ ཨང་ཡིག་འདི་འདྲ་ཞིག་ཏུ་བསྒྱུར་དགོས་ན་ཡིག་འབྲུ་ \/\/\/ ཡིག་འབྲུ་ནང་ཨང་རྟགས་རྒྱབ་པའི་ནང་ཨང་རྟགས་སྒྱུར་བ་ཕྱིར་ལོག་བྱེད།\/\/\/ ལས་འགན་ཞིག་བཟོ་ནས་རྟགས་མཚན་ལྟར་ཐིག་ཡིག་ཅིག་ལེན་ནས་ \/\/\/ >>> encrypt(String::from(\"hi\"))\n\/\/\/ String::from(\"lm\")\n\/\/\/ >>> encrypt(String::from(\"asdfghjkl\"))\n\/\/\/ String::from(\"ewhjklnop\")\n\/\/\/ >>> encrypt(String::from(\"gf\"))\n\/\/\/ String::from(\"kj\")\n\/\/\/ >>> encrypt(String::from(\"et\"))\n\/\/\/ String::from(\"ix\")\nfn encrypt(s: String) -> String {\n","canonical_solution":"fn encrypt(s: String) -> String {\n    s.chars()\n        .map(|c| {\n            if c.is_ascii_lowercase() {\n                let offset = (c as u8 - b'a' + 4) % 26;\n                (b'a' + offset) as char\n            } else {\n                c\n            }\n        })\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"},{"task_id":"HumanEval_90","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ None དེ་འདྲ་མེད་ན་སླར་ལོག་བྱེད།\/\/\/ next_smallest () ལས་འགན་ཞིག་བྲིས་ནས་ ཝི་ཅཊར་གྱི་ཆ་ཤས་ཆུང་ཤོས་གཉིས་པ་ཕྱིར་ལོག་བྱེད་པ།\/\/འདིར་ཁྱེད་ཚོར་གྲངས་ཧྲིལ་གྱི་བེ་ཊར་ (vector) ཞིག་གནང་ཡོད།\/\/\/ >>> next_smallest(vec![1, 2, 3, 4, 5])\n\/\/\/ Some(2)\n\/\/\/ >>> next_smallest(vec![5, 1, 4, 3, 2])\n\/\/\/ Some(2)\n\/\/\/ >>> next_smallest(vec![])\n\/\/\/ None\n\/\/\/ >>> next_smallest(vec![1, 1])\n\/\/\/ None\nfn next_smallest(lst: Vec<isize>) -> Option<isize> {\n","canonical_solution":"fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    if lst.len() < 2 {\n        return None;\n    }\n    let mut unique_elements: Vec<isize> = lst.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect();\n    if unique_elements.len() < 2 {\n        return None;\n    }\n    unique_elements.sort();\n    Some(unique_elements[1])\n}\n\nfn main() {\n    println!(\"{:?}\", next_smallest(vec![1, 2, 3, 4, 5])); \/\/ Some(2)\n    println!(\"{:?}\", next_smallest(vec![5, 1, 4, 3, 2])); \/\/ Some(2)\n    println!(\"{:?}\", next_smallest(vec![])); \/\/ None\n    println!(\"{:?}\", next_smallest(vec![1, 1])); \/\/ None\n}","tests":"}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n}\n"},{"task_id":"HumanEval_91","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/\/ sentences are delimited by '.', '?' or '!'.  ཚིག་ཡིག་ལ་མཐའ་མཚམས་འཇོག་བྱེད་\/\/རྒྱུད་ཀྱི་ཚིག་ཡིག་ནི་ \"ང་\" ཟེར་ནས་འགོ་འཛུགས་པའི་ཚིག་ཡིག་ཡིན།\/\/ཁྱོད་ཚོར་ཚིག་གྲངས་ཤིག་སྤྲད་ནས་ཁྱོད་རྣམས་ཀྱི་ལས་འགན་ནི་གྲངས་རྩིས་རྒྱག་རྒྱུ་རེད།\/\/\/ >>> is_bored(String::from(\"Hello world\"))\n\/\/\/ 0\n\/\/\/ >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n\/\/\/ 1\nfn is_bored(S: String) -> isize {\n","canonical_solution":"fn is_bored(S: String) -> isize {\n    S.split(|c| c == '.' || c == '?' || c == '!')\n        .filter(|sentence| sentence.trim_start().starts_with(\"I\"))\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n"},{"task_id":"HumanEval_92","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ གཞན་གནས་སྟངས་གང་རུང་དུ་ false སླར་ལོག་བྱེད།\/\/\/ གྲངས་ཀ་གཅིག་ནི་གཞན་གཉིས་དང་མཚུངས་པ་ཡིན་ན་ true སླར་ལོག་བྱེད། གྲངས་ཀ་ཚང་མ་ནི་ཧྲིལ་པོ་ཡིན།\/\/\/ ལས་འགན་གྲངས་ ༣ ཡོད་པའི་ལས་འགན་ཞིག་བཟོས་ཤིག\/\/\/ >>> any_int(5, 2, 7)\n\/\/\/ true\n\/\/\/ >>> any_int(3, 2, 2)\n\/\/\/ false\n\/\/\/ >>> any_int(3, -2, 1)\n\/\/\/ true\n\/\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/\/ false\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n","canonical_solution":"fn any_int(x: f64, y: f64, z: f64) -> bool {\n    \/\/ Check if all the numbers are integers\n    if x.fract() == 0.0 && y.fract() == 0.0 && z.fract() == 0.0 {\n        \/\/ Convert f64 to i64 because they are integers\n        let xi = x as i64;\n        let yi = y as i64;\n        let zi = z as i64;\n\n        \/\/ Check if any one of the numbers is equal to the sum of the other two\n        xi == yi + zi || yi == xi + zi || zi == xi + yi\n    } else {\n        false\n    }\n}\n\nfn main() {\n    \/\/ Examples\n    println!(\"{}\", any_int(5.0, 2.0, 7.0)); \/\/ true\n    println!(\"{}\", any_int(3.0, 2.0, 2.0)); \/\/ false\n    println!(\"{}\", any_int(3.0, -2.0, 1.0)); \/\/ true\n    println!(\"{}\", any_int(3.6, -2.2, 2.0)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"},{"task_id":"HumanEval_93","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ཡིག་འབྲུ་གཅིག་པུ་ལ་འཇུག་པ།\/\/\/ དབྱིན་ཡིག་གི་སྒྲ་དབྱངས་ཀྱི་སྒྲ་དབྱངས་ཡིན།\/\/\/ འཕྲིན་ཡིག་དེའི་སྔོན་དུ་ཡིག་འབྲུ་གཉིས་ཡོད་པ་རེད།\/\/\/ འདི་ལ་ཡིག་རྟགས་ཐམས་ཅད་ཀྱི་ཡིག་གཟུགས་བརྗེ་སྒྱུར་བྱེད་ཅིང་། ནང་དུ་སྒྲ་དབྱངས་ཐམས་ཅད་ཀྱི་ཚབ་ཏུ་འཇོག་པ་ཡིན།\/\/འདྲ་བའི་འཕྲིན་ཡིག་ཞིག་ལེན་ནས་དེའི་ནང་ཡིག་རྟགས་བཀོད་པའི་ function ཞིག་འབྲི་དགོས།\/\/\/ >>> encode(String::from(\"test\"))\n\/\/\/ String::from(\"TGST\")\n\/\/\/ >>> encode(String::from(\"This is a message\"))\n\/\/\/ String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String) -> String {\n","canonical_solution":"fn encode(message: String) -> String {\n    message.chars().map(|c| {\n        match c {\n            'a' => 'C',\n            'e' => 'G',\n            'i' => 'K',\n            'o' => 'Q',\n            'u' => 'W',\n            'A' => 'c',\n            'E' => 'g',\n            'I' => 'k',\n            'O' => 'q',\n            'U' => 'w',\n            'a'..='z' => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"},{"task_id":"HumanEval_94","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/ཇི་ཙམ་མང་བ་ཡོད་ན་དེའི་ནང་གྲངས་ཀྱི་གྲངས་ཐང་དང་དེའི་གྲངས་ཐང་རྩིས་དགོས་པ་ཡིན།\/\/འདིར་ཁྱེད་ཚོར་གྲངས་ཧྲིལ་གྱི་བེ་ཊར་ (vector) ཞིག་གནང་ཡོད།\/\/\/ >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/\/ 10\n\/\/\/ >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/\/ 25\n\/\/\/ >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/\/ 13\n\/\/\/ >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/\/ 11\n\/\/\/ >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n\/\/\/ 3\n\/\/\/ >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n\/\/\/ 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn digit_sum(n: isize) -> isize {\n    n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum()\n}\n\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n    match lst.into_iter().filter(is_prime).max() {\n        Some(max_prime) => digit_sum(max_prime),\n        None => 0,\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n"},{"task_id":"HumanEval_95","nl":"bod_Tibt","pl":"rs","prompt":"use std::collections::HashMap;\n\n\/\/\/ དཔེ་གཟིགས། \/\/\/ ལས་འགན་འདི་ནི་ false སླར་ལོག་བྱེད་དགོས་པ་རེད་ན། HashMap འདི་སྟོང་པ་རེད་འདུག\/\/\/ case ཡང་ན་ལྡེ་མིག་ཚང་མ་ཆེ་ཆུང་ནང་ string ཡིན་པ་དགོས། དེ་མིན་ false སླར་ལོག་བྱེད།\/\/\/ HashMap ཞིག་ཡོད་ན། ཚད་གཞི་ཚང་མ་ lower ནང་དུ་ string ཡིན་ན་ true སླར་ལོག་བྱེད།\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n\/\/\/ true\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n\/\/\/ true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n","canonical_solution":"use std::collections::HashMap;\n\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return false;\n    }\n\n    let mut lowercase = true;\n    let mut uppercase = true;\n\n    for key in dict.keys() {\n        if !key.chars().all(|c| c.is_lowercase()) {\n            lowercase = false;\n        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            uppercase = false;\n        }\n    }\n\n    lowercase || uppercase\n}\n\nfn main() {\n    let dict1 = HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]);\n    assert_eq!(check_dict_case(dict1), true);\n\n    let dict2 = HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]);\n    assert_eq!(check_dict_case(dict2), false);\n\n    let dict3 = HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]);\n    assert_eq!(check_dict_case(dict3), true);\n\n    let dict4 = HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]);\n    assert_eq!(check_dict_case(dict4), false);\n}","tests":"}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"},{"task_id":"HumanEval_96","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེར་ན་: \/\/\/ གྲངས་ཆ་དང་པོ་ n ལས་ཆུང་བ་ཡིན།\/\/\/ ལས་འགན་ཞིག་ལག་ལེན་དུ་འཇུག་སྟེ། དེ་དང་མི་འགལ་བའི་གྲངས་ཆ་གང་རུང་ཞིག་ལེན་ནས་ཐོག་མའི་གྲངས་ཆ་ n  གྱི་ལྡེ་མིག་ཕྱིར་ལོག་བྱེད་པ།\/\/\/ >>> count_up_to(5)\n\/\/\/ vec![2, 3]\n\/\/\/ >>> count_up_to(11)\n\/\/\/ vec![2, 3, 5, 7]\n\/\/\/ >>> count_up_to(0)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> count_up_to(20)\n\/\/\/ vec![2, 3, 5, 7, 11, 13, 17, 19]\n\/\/\/ >>> count_up_to(1)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> count_up_to(18)\n\/\/\/ vec![2, 3, 5, 7, 11, 13, 17]\nfn count_up_to(n: isize) -> Vec<isize> {\n","canonical_solution":"fn count_up_to(n: isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n\n    for num in 2..n {\n        let mut is_prime = true;\n\n        for divisor in 2..=((num as f64).sqrt() as isize) {\n            if num % divisor == 0 {\n                is_prime = false;\n                break;\n            }\n        }\n\n        if is_prime {\n            primes.push(num);\n        }\n    }\n\n    primes\n}\n\nfn main() {\n    println!(\"{:?}\", count_up_to(5)); \/\/ vec![2, 3]\n    println!(\"{:?}\", count_up_to(11)); \/\/ vec![2, 3, 5, 7]\n    println!(\"{:?}\", count_up_to(0)); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", count_up_to(20)); \/\/ vec![2, 3, 5, 7, 11, 13, 17, 19]\n    println!(\"{:?}\", count_up_to(1)); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", count_up_to(18)); \/\/ vec![2, 3, 5, 7, 11, 13, 17]\n}","tests":"}\n\nfn main() {\n    let candidate = count_up_to;\n    assert_eq!(candidate(5), vec![2, 3]);\n    assert_eq!(candidate(6), vec![2, 3, 5]);\n    assert_eq!(candidate(7), vec![2, 3, 5]);\n    assert_eq!(candidate(10), vec![2, 3, 5, 7]);\n    assert_eq!(candidate(0), Vec::<isize>::new());\n    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);\n    assert_eq!(candidate(1), Vec::<isize>::new());\n    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);\n    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n}\n"},{"task_id":"HumanEval_97","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ནང་འཇུག་གཏན་ལ་ཕབ་པའི་ཆ་ནས་གཏན་ལ་ཕབ་པ་ཡིན།\/\/\/ འབྲས་བུ་ནི་དེའི་ཆ་ཤས་ཀྱི་ཨང་གྲངས་ཡིན།\/\/\/ function དེ་གྲངས་ཆ་ཆ་ཚང་གཉིས་ལེན་ནས་ཕྱིར་ལོག་བྱེད།\/\/\/ >>> multiply(148, 412)\n\/\/\/ 16\n\/\/\/ >>> multiply(19, 28)\n\/\/\/ 72\n\/\/\/ >>> multiply(2020, 1851)\n\/\/\/ 0\n\/\/\/ >>> multiply(14, -15)\n\/\/\/ 20\nfn multiply(a: isize, b: isize) -> isize {\n","canonical_solution":"fn multiply(a: isize, b: isize) -> isize {\n    let unit_digit_a = (a % 10).abs();\n    let unit_digit_b = (b % 10).abs();\n    unit_digit_a * unit_digit_b\n}","tests":"}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"},{"task_id":"HumanEval_98","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/\/ string s ཤིག་ཡོད་ན། ཤོག་གྲངས་ཉེར་མཁོ་ཅན་གྱི་ཡིག་གཟུགས་ནང་ capital vowels ཇི་ཙམ་ཡོད་གྲངས་རྩིས་དགོས།\/\/\/ >>> count_upper(String::from(\"aBCdEf\"))\n\/\/\/ 1\n\/\/\/ >>> count_upper(String::from(\"abcdefg\"))\n\/\/\/ 0\n\/\/\/ >>> count_upper(String::from(\"dBBE\"))\n\/\/\/ 0\nfn count_upper(s: String) -> isize {\n","canonical_solution":"fn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(i, c)| {\n        *i % 2 == 0 && matches!(c, 'A' | 'E' | 'I' | 'O' | 'U')\n    }).count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"},{"task_id":"HumanEval_99","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ནས་གྲངས་ཆ་ཆ་ཚང་གཉིས་དང་། 0 ནས་འཁོར་བོར་བགྲོད་པ།\/\/ཚད་ལྡན་གྱི་གྲངས་འདྲ་མཉམ་ཡིན་ན།\/\/\/ གྲངས་ཐང་ (string) ཡོད་པའི་ལས་འགན་ཞིག་བཟོ།\/\/\/ >>> closest_integer(String::from(\"10\"))\n\/\/\/ 10\n\/\/\/ >>> closest_integer(String::from(\"15.3\"))\n\/\/\/ 15\n\/\/\/ Note:\n\/\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/\/ from two integers, the one you should return is the one that is the\n\/\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n","canonical_solution":"fn closest_integer(value: String) -> isize {\n    let num: f64 = value.parse().expect(\"Invalid number format\");\n    if num.fract().abs() == 0.5 {\n        if num.is_sign_positive() {\n            num.ceil() as isize\n        } else {\n            num.floor() as isize\n        }\n    } else {\n        num.round() as isize\n    }\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", closest_integer(String::from(\"10\")));   \/\/ Output: 10\n    println!(\"{}\", closest_integer(String::from(\"15.3\"))); \/\/ Output: 15\n    println!(\"{}\", closest_integer(String::from(\"14.5\"))); \/\/ Output: 15\n    println!(\"{}\", closest_integer(String::from(\"-14.5\"))); \/\/ Output: -15\n}","tests":"}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"},{"task_id":"HumanEval_100","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/i ནི་ཚད་ (i+1) ནང་གི་རྡོ་གྲངས་མཚོན་པ་ཡིན།\/\/\/ ཚད་གཞི་རེ་རེའི་རྡོ་གྲངས་སླར་ལོག་བྱེད། ཚད་གཞི་ནང་ཡོད་ཆ་ \/\/\/ - རྗེས་མའི་གྲངས་ཆ་ཆ་ཡིན་ན། n ནི་ཆ་ཆ་ཡིན་ན།\/\/\/ - རྗེས་སུ་འོང་བའི་གྲངས་ཆ་མ་ཚད། n ནི་ཚད། \/\/\/ ཤུལ་མའི་གནས་ཚད་ནང་རྡོ་གྲངས་ནི་: \/\/ཐོག་མར་རྡོ་ n ཡོད།\/\/འབྲས་བུ་གྲངས་ཚང་ n ཡོད་པ་ཡིན་ན། རྡོ་རིང་ཚད་ n ཡི་རྡོ་བྲིས་དགོས།\/\/\/ >>> make_a_pile(3)\n\/\/\/ vec![3, 5, 7]\nfn make_a_pile(n: isize) -> Vec<isize> {\n","canonical_solution":"fn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n    let mut current = n;\n    \n    for _ in 0..n {\n        pile.push(current);\n        current = if n % 2 == 1 {\n            current + 2\n        } else {\n            current + 2\n        };\n    }\n    \n    pile\n}\n\nfn main() {\n    let level = make_a_pile(3);\n    println!(\"{:?}\", level);\n}","tests":"}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"},{"task_id":"HumanEval_101","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/སྐར་ཁུང་ནང་ཚིག་ཡིག་དབྱེ་བ། སྐར་ཁུང་ནང་ཚིག་ཡིག་དབྱེ་བ། སྐར་ཁུང་ནང་ཚིག་ཡིག་དབྱེ་བ།\/\/ཁྱོད་ཚོར་ཚིག་ཡིག་དག་གི་གྲས་སུ་དབྱེ་རྟོག་དང་བར་སྟོང་གཉིས་སྤྲོད་རྒྱུ་རེད། ཁྱོད་ཀྱི་ལས་འགན་ནི་\/\/\/ >>> words_string(String::from(\"Hi, my name is John\"))\n\/\/\/ vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]\n\/\/\/ >>> words_string(String::from(\"One, two, three, four, five, six\"))\n\/\/\/ vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]\nfn words_string(s: String) -> Vec<String> {\n","canonical_solution":"fn words_string(s: String) -> Vec<String> {\n    s.split(|c: char| c.is_whitespace() || c == ',')\n        .filter(|word| !word.is_empty())\n        .map(String::from)\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = words_string;\n    assert_eq!(candidate(String::from(\"Hi, my name is John\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]);\n    assert_eq!(candidate(String::from(\"One, two, three, four, five, six\")), vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"Hi, my name\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\")]);\n    assert_eq!(candidate(String::from(\"One,, two, three, four, five, six,\")), vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"ahmed     , gamal\")), vec![String::from(\"ahmed\"), String::from(\"gamal\")]);\n}\n"},{"task_id":"HumanEval_102","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/གྲངས་ཀ་འདི་མེད་ན་ function དེ་ -1 སླར་ལོག་བྱེད་དགོས།\/\/ཚད་ [x, y] ནང་གི་གྲངས་ཆ་ཚག་གྲངས་ཆེ་ཤོས་ཡིན་ན།\/\/\/ ལས་འགན་འདི་ནི་གྲངས་ཆ་ལྡོག་པ་གཉིས་ x དང་ y དང་སླར་ལོག་བྱེད།\/\/\/ >>> choose_num(12, 15)\n\/\/\/ 14\n\/\/\/ >>> choose_num(13, 12)\n\/\/\/ -1\nfn choose_num(x: isize, y: isize) -> isize {\n","canonical_solution":"fn choose_num(x: isize, y: isize) -> isize {\n    let (start, end) = if x < y { (x, y) } else { (y, x) };\n    for n in (start..=end).rev() {\n        if n % 2 == 0 {\n            return n;\n        }\n    }\n    -1\n}\n\nfn main() {\n    println!(\"{}\", choose_num(12, 15)); \/\/ 14\n    println!(\"{}\", choose_num(13, 12)); \/\/ -1\n}","tests":"}\n\nfn main() {\n    let candidate = choose_num;\n    assert_eq!(candidate(12, 15), 14);\n    assert_eq!(candidate(13, 12), -1);\n    assert_eq!(candidate(33, 12354), 12354);\n    assert_eq!(candidate(5234, 5233), -1);\n    assert_eq!(candidate(6, 29), 28);\n    assert_eq!(candidate(27, 10), -1);\n    assert_eq!(candidate(7, 7), -1);\n    assert_eq!(candidate(546, 546), 546);\n}\n"},{"task_id":"HumanEval_104","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/\/ དྲན་གསོ། ཕྱིར་ལོག་པའི་བེ་ཊར་དེ་ཡར་རྒྱས་ཀྱི་རིམ་པ་བཞིན་དབྱེ་དགོས།\/\/\/ དངོས་པོ་ལ་ཨང་གྲངས་ཆ་སྙོམས་མེད་པ།\/\/\/ འབྲས་བུ་གྲངས་ཚང་གི་བེ་ཊར་ x ཞིག་ཡོད་ན། ཚང་མ་ནས་བེ་ཊར་རིམ་སྒྲིག་བྱས་པ་ཞིག་ཕྱིར་ལོག་བྱེད་པ།\/\/\/ >>> unique_digits(vec![15, 33, 1422, 1])\n\/\/\/ vec![1, 15, 33]\n\/\/\/ >>> unique_digits(vec![152, 323, 1422, 10])\n\/\/\/ Vec::<isize>::new()\nfn unique_digits(x: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn unique_digits(x: Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = x.into_iter()\n        .filter(|&num| {\n            num.to_string().chars().all(|c| {\n                match c {\n                    '0' | '2' | '4' | '6' | '8' => false,\n                    _ => true,\n                }\n            })\n        })\n        .collect();\n    result.sort();\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = unique_digits;\n    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);\n    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());\n    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);\n    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);\n}\n"},{"task_id":"HumanEval_105","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/༡། ༢། ༣། ༤། ༥། ༦། ༧། ༨། ༩།\/\/\/ འབྲས་བུ་ཐོན་པའི་བེ་ཊར་ལ་རྒྱབ་སྒྱུར་བྱེད་ནས་ཨང་གྲངས་རེ་རེར་ ནང་ལས་དེའི་མིང་དང་མཚུངས་པའི་མིང་ཚབ་སྤྲོད་དགོས།\/\/སྐར་ཆ་གྲངས་ཚང་གི་བེ་ཊར་ཞིག་ཡོད་ན། 1 དང་ 9 བར་གྱི་གྲངས་ཚང་ལ་དབྱེ་དགོས།\/\/\/ >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])\n\/\/\/ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]\n\/\/\/ If the vector is empty, return an empty vector:\n\/\/\/ >>> by_length(vec![])\n\/\/\/ Vec::<String>::new()\n\/\/\/ If the vector has any strange number ignore it:\n\/\/\/ >>> by_length(vec![1, -1, 55])\n\/\/\/ vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n","canonical_solution":"fn by_length(arr: Vec<isize>) -> Vec<String> {\n    let digit_names = [\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \n        \"Six\", \"Seven\", \"Eight\", \"Nine\",\n    ];\n\n    let mut filtered: Vec<isize> = arr.into_iter()\n        .filter(|&x| x >= 1 && x <= 9)\n        .collect();\n\n    filtered.sort();\n    filtered.reverse();\n\n    filtered.into_iter()\n        .map(|x| String::from(digit_names[(x - 1) as usize]))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"},{"task_id":"HumanEval_106","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/\/ i གི་ཕྲེང་བ་ནི་ 1 ནས་ i བར་གྱི་གྲངས་ཀྱི་ལྡབ་གྲངས་ཡིན། (1 * 2 * ... * i)\/\/ཤོག་ངོས་དང་པོ་ནས་འགོ་བཙུགས།\/\/ཡང་ན་ 1 ནས་ i བར་གྱི་གྲངས་ཐང་གི་བསྡོམས་ཡིན་ན།\/\/ཚད་ n ཅན་གྱི་བེ་ཊར་ཕྱིར་ལོག་བྱེད་ཅིང་། ཚད་གཞི་ i ནང་ཡོད་པའི་ཆ་ཤས་ཀྱི་ཐང་ནི་ i གྱི་གྲངས་ཆ་ཡིན་ན།\/\/ཚད་གཞི་ n སྦེ་ལེན་པའི་ function f འདི་ལག་ལེན་བསྟར་དགོས།\/\/\/ >>> f(5)\n\/\/\/ vec![1, 2, 6, 24, 15]\nfn f(n: isize) -> Vec<isize> {\n","canonical_solution":"fn f(n: isize) -> Vec<isize> {\n    fn factorial(x: isize) -> isize {\n        (1..=x).product()\n    }\n\n    fn sum_up_to(x: isize) -> isize {\n        (1..=x).sum()\n    }\n\n    (1..=n)\n        .map(|i| if i % 2 == 0 { factorial(i) } else { sum_up_to(i) })\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = f;\n    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);\n    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);\n    assert_eq!(candidate(1), vec![1]);\n    assert_eq!(candidate(3), vec![1, 2, 6]);\n}\n"},{"task_id":"HumanEval_107","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་དང་པོ།: \/\/\/ སྐར་གྲངས་ཚང་བའི་སྒྲོམ་ (palindromes) རྣམས་ནང་ལ་ ((1, n) བཅས་ཚུད་ཡོད།\/\/འབྲས་བུ་ནི་ n ཡིན་པའི་ཆ་ཤས་ཚུའི་གྲངས་དང་ཆ་མེད་གྲངས་ཀྱི་གྲངས་ཡོད་པའི་ཆ་ཤས་ཚུའི་གྲངས་ཕྱིར་ལོག་བྱེད་པ།\/\/\/ >>> even_odd_palindrome(3)\n\/\/\/ (1, 2)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/\/ Example 2:\n\/\/\/ >>> even_odd_palindrome(12)\n\/\/\/ (4, 6)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/\/ Note:\n\/\/\/ 1. 1 <= n <= 10^3\n\/\/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n","canonical_solution":"fn is_palindrome(x: isize) -> bool {\n    let s = x.to_string();\n    s == s.chars().rev().collect::<String>()\n}\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n    \n    for i in 1..=n {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n    \n    (even_count, odd_count)\n}","tests":"}\n\nfn main() {\n    let candidate = even_odd_palindrome;\n    assert_eq!(candidate(123), (8, 13));\n    assert_eq!(candidate(12), (4, 6));\n    assert_eq!(candidate(3), (1, 2));\n    assert_eq!(candidate(63), (6, 8));\n    assert_eq!(candidate(25), (5, 6));\n    assert_eq!(candidate(19), (4, 6));\n    assert_eq!(candidate(9), (4, 5));\n    assert_eq!(candidate(1), (0, 1));\n}\n"},{"task_id":"HumanEval_108","nl":"bod_Tibt","pl":"rs","prompt":"\/\/དཔེར་ན། -123 ནང་གི་ཨང་རྟགས་ནི་ -1, 2, 3 ཡིན།\/\/\/ གྲངས་ཀ་ཞིག་ནི་ཟབ་མོ་ཡིན་ན། དེའི་སྔོན་གྱི་ཨང་རྟགས་ནི་ཟབ་མོ་ཡིན་ངེས་ཡིན།\/\/\/ ཕྲད་གྲངས་ཀྱི་གྲངས་ཐང་ནི་ 0 སྟེང་ཡོད།\/\/\/ count_nums ལས་འགན་ཞིག་བྲིས་ནས་གྲངས་ཚང་གི་བེ་ཊར་ལེན་ནས་ཕྱིར་ལོག་བྱེད་པ།\/\/\/ >>> count_nums(vec![])\n\/\/\/ 0\n\/\/\/ >>> count_nums(vec![-1, 11, -11])\n\/\/\/ 1\n\/\/\/ >>> count_nums(vec![1, 1, 2])\n\/\/\/ 3\nfn count_nums(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn count_nums(arr: Vec<isize>) -> isize {\n    arr.into_iter()\n        .filter(|&num| {\n            let mut n = num;\n            let mut sum = 0;\n            let mut is_first_digit = true;\n\n            while n != 0 {\n                let digit = if is_first_digit {\n                    is_first_digit = false;\n                    n % 10\n                } else {\n                    (n % 10).abs()\n                };\n                sum += digit;\n                n \/= 10;\n            }\n            sum > 0\n        })\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n"},{"task_id":"HumanEval_109","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་མཚོན།: \/\/\/ དྲན་གསོ། ཚད་གཞི་འདི་ལ་ཆ་རྐྱེན་གཅིག་པུ་ཡོད་ངེས་རེད།\/\/གལ་ཏེ་ vector འདིར་སྟོང་པ་ཡོད་ན་ true སླར་ལོག་བྱེད།\/\/ཕྱིར་ལོག་ true ཡང་ན་ false སླར་ལོག་བྱེད།\/\/\/ གལ་ཏེ་གོང་གི་བྱ་གཞག་འདི་བཞིན་བྱ་བའི་སྒོ་ནས་རིམ་སྒྲིག་ཅན་གྱི་བེ་ཊར་ཐོབ་ཐུབ་ན།\/\/སྐར་ཆའི་ནང་ཐིག་ཨང་ ༠ པའི་ཐོག་གི་གནས་བབ་ཡིན།\/\/ཕྱོགས་ཀྱི་མཐའ་མཇུག་གི་ཆ་ཤས་ ཕྱོགས་ཀྱི་མཐའ་མཇུག་གི་ཆ་ཤས་ ཕྱོགས་ཀྱི་མཐའ་མཇུག་གི་ཆ་ཤས་ ཕྱོགས་ཀྱི་མཐའ་མཇུག་གི་ཆ་ཤས་ ཕྱོགས་ཀྱི་མཐའ་མཇུག་གི་ཆ་ཤས་ ཕྱོགས་ཀྱི་མཐའ་མཇུག་གི་ཆ་ཤས་ ཕྱོགས་ཀྱི་མཐའ་མཇུག་གི་ཆ་ཤས་\/\/\/ གཡས་ཕྱོགས་བསྐྱོད་བྱ་རིམ་གཅིག་ནི་ ཕྲེང་བ་ནང་གི་ཆ་ཤས་ཚང་མ་ཕྱོགས་གཅིག་ཏུ་བསྐྱོད་པའོ།\/\/ཇི་ཙམ་ཐེངས་མང་བ་གཡས་ཕྱོགས་སུ་བསྒྱུར་ཐུབ་པ་ཡོད།\/\/\/ སྟོན་པའི་བེ་ཊར་ལ་འཇུག་པའི་རིམ་པ་འདི་ཡིན།\/\/ཚད་གཞི་འདི་ ཚད་གཞི་འོག་མ་ནང་རིམ་པ་སྒྲིག་བྱེད་ཆོག\/\/སྐར་ཆའི་ནང་གྲངས་གྲངས་ལ་གོ་རིམ་འདྲ་མིན་གྱིས་གོ་རིམ་སྒྲིག་དགོས། ཁྱོད་ཀྱི་ལས་འགན་ནི་ ཇི་ཡིན་ངེས་པ་དགོས།\/\/སྐར་ཆ་ N ཡི་ སྐར་ཆ་ 'arr' ཡིན། arr[1], arr[2], ..., arr[N] ཟེར་བ་ཡོད།\/\/\/ >>> move_one_ball(vec![3, 4, 5, 1, 2])\n\/\/\/ true\n\/\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/\/ be achieved for the given vector.\n\/\/\/ >>> move_one_ball(vec![3, 5, 4, 1, 2])\n\/\/\/ false\n\/\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/\/ vector by performing any number of right shift operations.\nfn move_one_ball(arr: Vec<isize>) -> bool {\n","canonical_solution":"fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.is_empty() {\n        return true; \/\/ An empty array is already considered sorted.\n    }\n    \n    let mut break_point = 0;\n    let mut break_found = false;\n    let len = arr.len();\n\n    for i in 0..len {\n        if arr[i] > arr[(i + 1) % len] {\n            if break_found {\n                return false;  \/\/ Found more than one break point, not possible.\n            }\n            break_point = i + 1;\n            break_found = true;\n        }\n    }\n    \n    \/\/ After finding a single break point, simulate the right shift by 'break_point'\n    for i in 0..len {\n        if arr[(break_point + i) % len] > arr[(break_point + i + 1) % len] {\n            return false; \/\/ Not sorted in non-decreasing order with this shift.\n        }\n    }\n    \n    true\n}\n\n\/\/ Example usages:\n\n\/\/ This will return true, as we can shift twice to sort it.\nassert_eq!(move_one_ball(vec![3, 4, 5, 1, 2]), true);\n\n\/\/ This will return false, as we can't sort this by any number of shifts.\nassert_eq!(move_one_ball(vec![3, 5, 4, 1, 2]), false);","tests":"}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"},{"task_id":"HumanEval_110","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/གལ་ཏེ་དེ་ལྟར་མ་ཡིན་ན་ \"NO\" ཕྱིར་སློག་བྱོས།\/\/ཚད་གཞི་ \"YES\" ཟེར་བ་ཕྱིར་ལོག་བྱེད།\/\/ཕྱོགས་མཚུངས་ཀྱི་ཆ་རྐྱེན་ཞིག་ཡིན་ན།\/\/སྐར་མ་ ༡ དང་སྐར་མ་ ༢ བར་གྱི་ཆ་ཤས་བརྗེ་ལེན་བྱེད་ཚད་ལ་ཚད་མ་འདུག\/\/ཇི་འདྲ་ཡིན་ན། ཇི་འདྲ་ཡིན་རུང་།\/\/\/ ཇི་འདྲ་ཞིག་བརྗེ་ལེན་བྱེད་ཆོག་མིན་ལ་དཔྱད་པ།\/\/འདིར་ཁྱེད་ཚོས་གྲངས་ཀྱི་བེ་ཊར་གཉིས་ལེན་པའི་ལས་འགན་ཞིག་ལག་ལེན་བྱེད་རྒྱུ་ཡིན།\/\/\/ >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])\n\/\/\/ String::from(\"YES\")\n\/\/\/ >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])\n\/\/\/ String::from(\"NO\")\n\/\/\/ It is assumed that the input vectors will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n","canonical_solution":"fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n    let mut even_in_lst2 = false;\n    for &num in &lst2 {\n        if num % 2 == 0 {\n            even_in_lst2 = true;\n            break;\n        }\n    }\n\n    if even_in_lst2 {\n        for &num in &lst1 {\n            if num % 2 != 0 {\n                return String::from(\"YES\");\n            }\n        }\n        return String::from(\"YES\");\n    }\n\n    String::from(\"NO\")\n}\n\nfn main() {\n    \/\/ Example cases\n    println!(\"{}\", exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])); \/\/ \"YES\"\n    println!(\"{}\", exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])); \/\/ \"NO\"\n}","tests":"}\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from(\"YES\"));\n}\n"},{"task_id":"HumanEval_111","nl":"bod_Tibt","pl":"rs","prompt":"use std::collections::HashMap;\n\n\/\/\/ དཔེ་གཟིགས།: \/\/གལ་ཏེ་ཡིག་རྟགས་མང་པོ་ཞིག་ནང་དོན་གཅིག་མཚུངས་ཡོད་ན་ ཚང་མ་ཕྱིར་སློག་བྱེད་དགོས།\/\/\/ འབྲི་ཤོག་གི་ཨང་གྲངས་དང་དེའི་ནང་ཨང་གྲངས་མང་ཤོས་ཡོད་པ།\/\/\/ ནང་ཐིག་ནང་ཡིག་ཆུང་ཆུང་ཆུང་གཉིས་ཡོད་པའི་ཡིག་འབྲུ་ཞིག་ཡོད་ན། HashMap ཞིག་ཕྱིར་སློག་བྱ་དགོས།\/\/\/ >>> histogram(String::from(\"a b c\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n\/\/\/ >>> histogram(String::from(\"a b b a\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\/\/\/ >>> histogram(String::from(\"a b c a b\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\/\/\/ >>> histogram(String::from(\"b b b b a\"))\n\/\/\/ HashMap::from([(String::from(\"b\"), 4)])\n\/\/\/ >>> histogram(String::from(\"\"))\n\/\/\/ HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize> {\n","canonical_solution":"use std::collections::HashMap;\n\nfn histogram(test: String) -> HashMap<String, isize> {\n    let mut counts: HashMap<String, isize> = HashMap::new();\n    let mut max_count = 0;\n\n    for letter in test.split_whitespace() {\n        let count = counts.entry(letter.to_string()).or_insert(0);\n        *count += 1;\n        if *count > max_count {\n            max_count = *count;\n        }\n    }\n\n    counts.retain(|_, &mut val| val == max_count);\n    counts\n}\n\nfn main() {\n    let result = histogram(String::from(\"a b c\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n\n    let result = histogram(String::from(\"a b b a\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\n    let result = histogram(String::from(\"a b c a b\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\n    let result = histogram(String::from(\"b b b b a\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"b\"), 4)])\n\n    let result = histogram(String::from(\"\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([])\n}","tests":"}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")), HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"a\"), 1)]));\n}\n"},{"task_id":"HumanEval_112","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/ཚོད་ལྟ་བྱེད་སྐབས་འབྲས་བུ་ string དང་ true\/false ཡོད་པའི་ tuple སླར་ལོག་བྱེད་དགོས།\/\/སྐུད་པ་ཞིག་ལ་ palindrome ཞེས་ཟེར་བ་ནི། སྐུད་པ་དེའི་རྒྱབ་མདུན་གཉིས་འདྲ་མཚུངས་ཡིན་ན།\/\/\/ དེ་ནས་འབྲས་བུ་ནི་ palindrome ཡིན་མིན་ལ་བརྟག་དཔྱད་བྱོས།\/\/འདིར་ s དང་ c གཉིས་ཀྱི་ཡིག་འབྲུ་གཉིས་ཡོད། ཁྱོད་ཀྱིས་ s ནང་གི་ཡིག་འབྲུ་གང་འདྲ་ཞིག་ c ནང་ཡོད་ན་དེ་དག་ཚང་མ་སེལ་དགོས།\/\/\/ ལས་འགན་ \/\/\/ >>> reverse_delete(String::from(\"abcde\"), String::from(\"ae\"))\n\/\/\/ (String::from(\"bcd\"), false)\n\/\/\/ >>> reverse_delete(String::from(\"abcdef\"), String::from(\"b\"))\n\/\/\/ (String::from(\"acdef\"), false)\n\/\/\/ >>> reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n\/\/\/ (String::from(\"cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n","canonical_solution":"fn reverse_delete(s: String, c: String) -> (String, bool) {\n    \/\/ Create a set of characters to delete for quick lookup\n    let delete_chars: std::collections::HashSet<char> = c.chars().collect();\n    \n    \/\/ Filter the string, keeping only characters not in the delete set\n    let filtered: String = s.chars().filter(|ch| !delete_chars.contains(ch)).collect();\n    \n    \/\/ Check if the filtered string is a palindrome\n    let is_palindrome = filtered == filtered.chars().rev().collect::<String>();\n    \n    \/\/ Return the filtered string and whether it's a palindrome\n    (filtered, is_palindrome)\n}","tests":"}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"},{"task_id":"HumanEval_113","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ནང་འཇུག་གི་ i'th string ནང་གི་ཨང་གྲངས་རྣམ་རྟོག་མེད་ཀྱི་གྲངས་ཀ་ཡིན།\/\/འདིར་ i ཚང་མ་གྲངས་ཀ་ ཀྱིས་ཚབ་ཏུ་སྤྲོད་དགོས།\/\/\/ འཐོན་ཚད་ཀྱི་ཆ་ཤས་ i འདི་ནི་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་ ཇི་ཡོད་ཆ་ཤས་གྲངས་\/\/སྐར་ཁུང་ནང་དྲ་ལམ་གྱི་གྲངས་ཀ་ཡོད་ན་ སྐར་ཁུང་ནང་དྲ་ལམ་གྱི་གྲངས་ཀ་ཡོད་ན་ སྐར་ཁུང་ནང་དྲ་ལམ་གྱི་གྲངས་ཀ་ཡོད་ན་ སྐར་ཁུང་ནང་དྲ་ལམ་ཡོད་ན་ སྐར་ཁུང་ནང་དྲ་ལམ་ཡོད་ན་ སྐར་ཁུང་ནང་དྲ་ལམ་ཡོད་ན་ སྐར་ཁུང་ནང་དྲ་ལམ་ཡོད་ན་ སྐར་ཁུང་ནང་དྲ་ལམ་ཡོད་ན་ སྐར་ཁུང་ནང་དྲ་ལམ་ཡོད་ན་ སྐར་ཁུང་ནང་དྲ་ལམ་ཡོད་ན་ སྐར་ཁུང་ནང་དྲ་ལམ་ཡོད་ན་ སྐར་ཁུང་ནང་དྲ་ལམ་ཡོད་ན་ སྐར་ཁུང་ནང་དྲ་ལམ་ཡོད་ན།\/\/\/ >>> odd_count(vec![String::from(\"1234567\")])\n\/\/\/ vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]\n\/\/\/ >>> odd_count(vec![String::from(\"3\"), String::from(\"11111111\")])\n\/\/\/ vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]\nfn odd_count(lst: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn odd_count(lst: Vec<String>) -> Vec<String> {\n    lst.iter()\n        .map(|s| {\n            let odd_count = s.chars().filter(|&c| {\n                match c {\n                    '1' | '3' | '5' | '7' | '9' => true,\n                    _ => false,\n                }\n            }).count();\n            format!(\"the number of odd elements {0}n the str{0}ng {0} of the {0}nput.\", odd_count)\n        })\n        .collect()\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result = odd_count(vec![String::from(\"1234567\")]);\n\/\/     println!(\"{:?}\", result);\n\/\/ \n\/\/     let result = odd_count(vec![String::from(\"3\"), String::from(\"11111111\")]);\n\/\/     println!(\"{:?}\", result);\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = odd_count;\n    assert_eq!(candidate(vec![String::from(\"1234567\")]), vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]);\n    assert_eq!(candidate(vec![String::from(\"3\"), String::from(\"11111111\")]), vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]);\n    assert_eq!(candidate(vec![String::from(\"271\"), String::from(\"137\"), String::from(\"314\")]), vec![String::from(\"the number of odd elements 2n the str2ng 2 of the 2nput.\"), String::from(\"the number of odd elements 3n the str3ng 3 of the 3nput.\"), String::from(\"the number of odd elements 2n the str2ng 2 of the 2nput.\")]);\n}\n"},{"task_id":"HumanEval_114","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ཤོག་གྲངས་ཀྱི་གྲངས་ཀ་ཡིན།\/\/སྐར་ཆ་ n གི་བེ་ཊར་ཐོབ་ཡོད་ན། སྟོང་པ་མིན་པའི་བེ་ཊར་ཆུང་ཤོས་ཀྱི་བསྡོམས་འཚོལ་དགོས།\/\/\/ >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])\n\/\/\/ 1\n\/\/\/ >>> minSubArraySum(vec![-1, -2, -3])\n\/\/\/ -6\nfn minSubArraySum(nums: Vec<isize>) -> isize {\n","canonical_solution":"fn minSubArraySum(nums: Vec<isize>) -> isize {\n    let mut min_sum = nums[0];\n    let mut current_sum = nums[0];\n\n    for &num in nums.iter().skip(1) {\n        current_sum = current_sum.min(current_sum + num);\n        min_sum = min_sum.min(current_sum);\n    }\n\n    min_sum\n}","tests":"}\n\nfn main() {\n    let candidate = minSubArraySum;\n    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);\n    assert_eq!(candidate(vec![-1, -2, -3]), -6);\n    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);\n    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);\n    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);\n    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);\n    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);\n    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);\n    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);\n    assert_eq!(candidate(vec![-10]), -10);\n    assert_eq!(candidate(vec![7]), 7);\n    assert_eq!(candidate(vec![1, -1]), -1);\n}\n"},{"task_id":"HumanEval_115","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་དང་པོ།: \/\/སྦྲག་ཕབ་དགོས་པའི་ཐེངས་གྲངས་འདེམས་དགོས།\/\/ཁྱོད་ཚོར་ལས་འགན་ནི་ཆུ་མཛོད་རྣམས་ཆུ་ཟམ་ནས་ཆུ་བསྐོལ་བའི་ཆེད་དུ་སླ་པོ་རྣམས་བེད་སྤྱོད་བྱེད་རྒྱུ་དེ་ཡིན།\/\/ཚད་གཞི་དང་ཚད་གཞི་འདྲ་མཉམ་ཡོད།\/\/ཆུ་རྐ་རེ་རེར་ཆུ་ལེན་པའི་ཆུ་རྫིང་ཞིག་ཡོད།\/\/ཤོག་ངོས་འདིའི་ནང་ 1 པོ་གང་རུང་ནི་ཆུ་ཕྲན་གང་རུང་ཞིག་ཡིན་པར་མཚོན་པ་ཡིན།\/\/འདིར་ཆུ་མིག་གི་དབྱིབས་གྲུ་བཞི་ཡོད་པའི་དྲ་རྒྱ་ཞིག་ཡོད། རེའུ་མིག་རེ་རེར་ཆུ་མིག་གཅིག་རང་ཡོད།\/\/\/ >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)\n\/\/\/ 6\n\/\/\/ Example 2:\n\/\/\/ >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n\/\/\/ 5\n\/\/\/ Example 3:\n\/\/\/ >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n\/\/\/ 0\n\/\/\/ Constraints:\n\/\/\/ * all wells have the same length\n\/\/\/ * 1 <= grid.length <= 10^2\n\/\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/\/ * grid[i][j] -> 0 | 1\n\/\/\/ * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n","canonical_solution":"fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut total_water_units = 0;\n\n    for row in grid.iter() {\n        for &unit in row.iter() {\n            total_water_units += unit;\n        }\n    }\n\n    \/\/ Calculate how many times we need to lower the bucket to extract all water units\n    (total_water_units + capacity - 1) \/ capacity\n}\n\nfn main() {\n    println!(\"{}\", max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)); \/\/ 6\n    println!(\"{}\", max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)); \/\/ 5\n    println!(\"{}\", max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)); \/\/ 0\n}","tests":"}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"},{"task_id":"HumanEval_116","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ འདི་ལྟར་ལག་ལེན་བྱ་དགོས།: \/\/འདྲ་མཉམ་གྲངས་སུ་གཅིག་ཡོད་ན། བཅུ་ཚིགས་ཀྱི་རིན་ཐང་ཐོག་ནས་དབྱེ་དགོས།\/\/\/ གྱངས་ཁ་ཡར་སེང་གི་རིམ་པ་བཞིན་གཉིས་ལྡན་གྱི་གྲངས་སུ་གྲངས་གྲངས་ཀྱི་གྲངས་ཐང་ཡིན།\/\/འདིར་ ཚད་མ་ནང་། ཚད་མ་ནང་། ཚད་མ་ནང་། ཚད་མ་ནང་། ཚད་མ་ནང་།\/\/\/ >>> sort_array(vec![1, 5, 2, 3, 4])\n\/\/\/ vec![1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(vec![-2, -3, -4, -5, -6])\n\/\/\/ vec![-6, -5, -4, -3, -2]\n\/\/\/ >>> sort_array(vec![1, 0, 2, 3, 4])\n\/\/\/ vec![0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr = arr;\n    arr.sort_by(|&a, &b| {\n        let ones_a = a.count_ones();\n        let ones_b = b.count_ones();\n        if ones_a == ones_b {\n            a.cmp(&b)\n        } else {\n            ones_a.cmp(&ones_b)\n        }\n    });\n    arr\n}\n\nfn main() {\n    println!(\"{:?}\", sort_array(vec![1, 5, 2, 3, 4])); \/\/ Output: [1, 2, 3, 4, 5]\n    println!(\"{:?}\", sort_array(vec![-2, -3, -4, -5, -6])); \/\/ Output: [-6, -5, -4, -3, -2]\n    println!(\"{:?}\", sort_array(vec![1, 0, 2, 3, 4])); \/\/ Output: [0, 1, 2, 3, 4]\n}","tests":"}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"},{"task_id":"HumanEval_117","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ དྲན་གསོ། ཁྱོད་ཀྱིས་ནང་འཇུག་ཡིག་འབྲུ་ནང་ཡིག་འབྲུ་དང་བར་སྟོང་མ་གཏོགས་གཞན་མེད་པར་ངེས་གཏན་བྱེད་དགོས།\/\/གལ་ཏེ་ string s ནི་སྟོང་པ་ཡིན་ན་ function ཀྱིས་སྟོང་པའི་ vector སླར་ལོག་བྱ་དགོས།\/\/\/n མཉམ་སྒྲ་རྣམས་རིམ་བཞིན་ཚིག་འདི་ཚོ་ string s ནང་གསལ་བྱེད།\/\/\/ འདི་ནི་ function འདི་ནས་ string s ནང་གི་ཚིག་ཡིག་ཚང་མའི་ vector སླར་ལོག་བྱེད་ཅིང་། འདི་ནང་ ཟེར་བ་ཡོད།\/\/སྐར་ཁུང་གི་དྲ་ངོས་ནས་ སྐར་ཁུང་གི་དྲ་ངོས་སུ་ སྐར་ཁུང་གི་དྲ་ངོས་སུ་ སྐར་ཁུང་གི་དྲ་ངོས་སུ་ སྐར་ཁུང་གི་དྲ་ངོས་སུ་ སྐར་ཁུང་གི་དྲ་ངོས་སུ་ སྐར་ཁུང་གི་དྲ་ངོས་སུ་ སྐར་ཁུང་གི་དྲ་ངོས་སུ་ སྐར་ཁུང་གི་དྲ་ངོས་སུ་ སྐར་ཁུང་གི་དྲ་ངོས་སུ་\/\/\/ >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\/\/\/ vec![String::from(\"little\")]\n\/\/\/ >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n\/\/\/ vec![String::from(\"Mary\"), String::from(\"lamb\")]\n\/\/\/ >>> select_words(String::from(\"simple white space\"), 2)\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> select_words(String::from(\"Hello world\"), 4)\n\/\/\/ vec![String::from(\"world\")]\n\/\/\/ >>> select_words(String::from(\"Uncle sam\"), 3)\n\/\/\/ vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n","canonical_solution":"fn select_words(s: String, n: isize) -> Vec<String> {\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let mut result = Vec::new();\n\n    for word in s.split_whitespace() {\n        let consonant_count = word.chars().filter(|c| consonants.contains(*c)).count();\n        if consonant_count == n as usize {\n            result.push(word.to_string());\n        }\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"},{"task_id":"HumanEval_118","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/ཇི་སྐད་ཡིག་ནང་དབྱིན་ཡིག་གི་ཡི་གེ་གཅིག་པུ་ཡོད་པར་ངེས་པ་དགོས།\/\/\/ སྟེང་གི་གནས་སྟངས་ལ་བསྟུན་པའི་སྒྲ་རིགས་རྙེད་པ།\/\/ཤོག་ངོས་དང་པོའི་ནང་ཡོད་པའི་སྒྲ་དབྱངས་ལ་རྩིས་མི་བྱེད། གལ་ཏེ་མེད་ན་ string སྟོང་པ་ཕྱིར་ལོག་བྱོས།\/\/\/ ཕྲེང་གཉིས་ནི་ཚིག་གི་གཡས་ཕྱོགས་ནས་ (case sensitive) ཟེར་བ་ལྟ་བུ།\/\/ཁྱེད་ལ་ཚིག་ཅིག་སྤྲོད་ཡོད། ཁྱེད་ཚོའི་ལས་འགན་ནི་ ཇི་ཙམ་ཉེ་བར་ཡོད་ན་དེའི་བར་གྱི་སྒྲ་དབྱངས་དེ་འཚོལ་དགོས་པ་ཡིན།\/\/\/ >>> get_closest_vowel(String::from(\"yogurt\"))\n\/\/\/ String::from(\"u\")\n\/\/\/ >>> get_closest_vowel(String::from(\"FULL\"))\n\/\/\/ String::from(\"U\")\n\/\/\/ >>> get_closest_vowel(String::from(\"quick\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> get_closest_vowel(String::from(\"ab\"))\n\/\/\/ String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n","canonical_solution":"fn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let chars: Vec<char> = word.chars().collect();\n    if chars.len() < 3 {\n        return String::from(\"\");\n    }\n\n    for i in (1..chars.len() - 1).rev() {\n        if vowels.contains(chars[i]) && !vowels.contains(chars[i-1]) && !vowels.contains(chars[i+1]) {\n            return chars[i].to_string();\n        }\n    }\n    String::from(\"\")\n}","tests":"}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"},{"task_id":"HumanEval_119","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/ཚད་ལྡན་ཡིག་འབྲུ་བཟོ་ཐབས་ཡོད་ན་ \"Yes\" སླར་ལོག་བྱེད་དང་གཞན་ན་ \"No\" སླར་ལོག་བྱེད་\/\/\/ \" ((()) \"མི་འདུག\/\/ཚད་ལྡན་ཡིན་པའི་དཔེར་ན། string '(()))) ཟེར་བ་དེ་ལེགས་པ་ཡིན་པའི་དོན། string ཟེར་བ་དེ་ལེགས་པ་རེད།\/\/\/ string S འདི་ S ནང་གི་ parentheses ཚང་མ་ཡོད་ན་དང་གཅིག་པུར་ལེགས་པར་བརྩི་ཐུབ།\/\/ཚད་གཞི་འདི་ནི་ ཚད་གཞི་དང་མཚུངས་པ་ཞིག་རེད།\/\/ཤོག་གྲངས་གཉིས་ནང་ཐིག་ལེ་གཉིས་མཐུད་ཐུབ་མིན་བརྟག་དཔྱད་བྱེད་དགོས།\/\/\/ ནང་འཇུག་བྱེད་ཚིག་ཡིག་ནང་ \" ((\" ཡང་ན་ནང་འཇུག་བྱེད་ཚིག་ཡིག་ནང་ \") \" ཙམ་ཡོད།\/\/ཝེ་ཁེ་ཊར་ (vector) གཉིས་ཀྱི་ནང་ཐིག་གཉིས་ཀ་ཁ་ཕྱེས་ཡོད།\/\/\/ >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n\/\/\/ String::from(\"Yes\")\n\/\/\/ >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n\/\/\/ String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n","canonical_solution":"fn match_parens(lst: Vec<String>) -> String {\n    fn is_balanced(s: &str) -> bool {\n        let mut balance = 0;\n        for ch in s.chars() {\n            if ch == '(' {\n                balance += 1;\n            } else {\n                balance -= 1;\n            }\n            if balance < 0 {\n                return false;\n            }\n        }\n        balance == 0\n    }\n\n    if lst.len() != 2 {\n        return \"No\".to_string();\n    }\n\n    let s1 = &lst[0];\n    let s2 = &lst[1];\n\n    let combined1 = format!(\"{}{}\", s1, s2);\n    let combined2 = format!(\"{}{}\", s2, s1);\n\n    if is_balanced(&combined1) || is_balanced(&combined2) {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"},{"task_id":"HumanEval_120","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་དང་པོ།: \/\/\/ རིང་ཚད་ k དང་གྲངས་ k ཡི་རིང་ཚད་ arr དང་།\/\/\/ སྐར་ཆ་ arr དང་ k ཅན་གྲངས་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་ཆ་ཚུའི་གྲངས་\/\/\/ >>> maximum(vec![-3, -4, 5], 3)\n\/\/\/ vec![-4, -3, 5]\n\/\/\/ Example 2:\n\/\/\/ >>> maximum(vec![4, -4, 4], 2)\n\/\/\/ vec![4, 4]\n\/\/\/ Example 3:\n\/\/\/ >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)\n\/\/\/ vec![2]\n\/\/\/ Note:\n\/\/\/ 1. The length of the vector will be in the range of [1, 1000].\n\/\/\/ 2. The elements in the vector will be in the range of [-1000, 1000].\n\/\/\/ 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n","canonical_solution":"fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let mut arr = arr;\n    arr.sort_unstable_by(|a, b| b.cmp(a));\n    let k = k as usize;\n    let mut result: Vec<isize> = arr.into_iter().take(k).collect();\n    result.sort_unstable();\n    result\n}\n\nfn main() {\n    assert_eq!(maximum(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(maximum(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n}","tests":"}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_121","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/སྟོང་པ་མིན་པའི་གྲངས་ཆ་མཉམ་གྱི་ཐིག་ཁྲམ་ཐོབ་ན། གྱངས་ཁ་ཆ་སྙོམ་ཡོད་པའི་ཆ་ཤས་ཚང་མའི་བསྡོམས་གྲངས་ཕྱིར་ལོག་བྱེད་པ།\/\/\/ >>> solution(vec![5, 8, 7, 1])\n\/\/\/ 12\n\/\/\/ >>> solution(vec![3, 3, 3, 3, 3])\n\/\/\/ 9\n\/\/\/ >>> solution(vec![30, 13, 24, 321])\n\/\/\/ 0\nfn solution(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn solution(lst: Vec<isize>) -> isize {\n    lst.iter()\n        .enumerate()\n        .filter(|(i, &x)| i % 2 == 0 && x % 2 != 0)\n        .map(|(_, &x)| x)\n        .sum()\n}","tests":"}\n\nfn main() {\n    let candidate = solution;\n    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);\n    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);\n    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);\n    assert_eq!(candidate(vec![5, 9]), 5);\n    assert_eq!(candidate(vec![2, 4, 8]), 0);\n    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);\n    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);\n}\n"},{"task_id":"HumanEval_122","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/\/ arr ནང་གི་ཆ་ཤས་ k ཐོག་མའི་ཆ་ཤས་ནས་ཨང་གྲངས་གཉིས་ལས་མང་བ་མེད་པའི་ཆ་ཤས་ཀྱི་བསྡོམས་ཡིན།\/\/\/ འདིར་ཨང་གྲངས་ཧྲིལ་པོ་ arr དང་ཨང་གྲངས་ཧྲིལ་པོ་ k ཡོད་པའི་སྟོང་པ་མིན་པའི་བེ་ཊར་ཡོད་ན། return \/\/\/ >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n\/\/\/ 24\n\/\/\/ Constraints:\n\/\/\/ 1. 1 <= len(arr) <= 100\n\/\/\/ 2. 1 <= k <= len(arr)\nfn add_elements(arr: Vec<isize>, k: isize) -> isize {\n","canonical_solution":"fn add_elements(arr: Vec<isize>, k: isize) -> isize {\n    arr.iter()\n        .take(k as usize)\n        .filter(|&&x| x > -100 && x < 100)\n        .sum()\n}\n\nfn main() {\n    let result = add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4);\n    println!(\"{}\", result);  \/\/ Output: 24\n}","tests":"}\n\nfn main() {\n    let candidate = add_elements;\n    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);\n    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);\n    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);\n    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);\n    assert_eq!(candidate(vec![1], 1), 1);\n}\n"},{"task_id":"HumanEval_123","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ get_odd_collatz(5) སླར་ལོག་བྱས་ [1, 5] # 5 གི་ collatz ཐིག་ཁྲམ་ནི་ [5, 16, 8, 4, 2, 1] ཡིན་པས་གྲངས་ཆ་རྐྱང་ནི་ 1 དང་ 5 ཙམ་ཡིན།\/\/\/ དཔེ་གཞི་: \/\/\/ ༢། སླར་ལོག་པའི་བེ་ཊར་རིམ་བཞིན་རིམ་སྒྲིག་བྱས་ཡོད།\/\/Collatz ((1) ནི་ [1]ཡིན།\/\/\/ དྲན་གསོ།: \/\/\/term+1 ཟེར་བའི་དཔེར་བརྗོད་དེ་ n ཇི་འདྲ་ཡིན་རུང་རིམ་པ་ 1 ཏུ་ངེས་གཏན་ཡིན།\/\/གལ་ཏེ་སྔོན་གྱི་གྲངས་ནི་རྣམ་གྲངས་ཡིན་ན། རྗེས་མའི་གྲངས་ནི་སྔོན་གྱི་གྲངས་ལས་ 3 ཙམ་ཡིན།\/\/\/ སྔོན་མའི་གྲངས་ཀ་འདི་འདྲ་ཡིན་ན། རྗེས་མའི་གྲངས་ཀ་ནི་ གྱི་ཕྱེད་ཀ་ཡིན།\/\/ཇི་འདྲ་ཡིན་རུང་ཨང་གྲངས་ n ལས་འགོ་འཛུགས་དགོས། དེ་ནས་ཨང་གྲངས་རེ་རེར་ ཟེར་བའི་གྲངས་ནས་ཐོབ་ཡོད།\/\/\/ Collatz conjecture ནི་རྩིས་རིག་གི་རྣམ་གྲངས་ཞིག་ཡིན་ཏེ། དེའི་ནང་གསལ་རིམ་པ་གཅིག་ལ་འཇུག་པའི་རྣམ་གྲངས་ཞིག་ཡིན།\/\/འབྲས་བུ་ནི་ n ཡིན་པའི་རྩིས་རྒྱག་བྱས་རྗེས་ ཚད་ལྡན་གྲངས་གྲངས་ཀྱི་གོ་རིམ་ནང་གྲངས་གྲངས་རྣམ་པ་ཡོད་པའི་ ཚད་ལྡན་གྲངས་གྲངས་ཤིག་ཕྱིར་སློག་བྱ་དགོས།\/\/\/ >>> get_odd_collatz(5)\n\/\/\/ vec![1, 5]\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n","canonical_solution":"fn get_odd_collatz(n: isize) -> Vec<isize> {\n    let mut sequence = Vec::new();\n    let mut current = n;\n\n    while current != 1 {\n        if current % 2 != 0 {\n            sequence.push(current);\n        }\n\n        if current % 2 == 0 {\n            current \/= 2;\n        } else {\n            current = 3 * current + 1;\n        }\n    }\n    \n    \/\/ Add the final odd number 1 if n is 1\n    sequence.push(1);\n\n    sequence.sort();\n    sequence\n}\n\nfn main() {\n    let result = get_odd_collatz(5);\n    println!(\"{:?}\", result); \/\/ Outputs: [1, 5]\n}","tests":"}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"},{"task_id":"HumanEval_124","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ 4 ཚེས་གྲངས་ནི་ཨང་རིམ་: mm-dd-yyyy ནང་དུ་བཀོད་དགོས།\/\/ཟླ་བ་ ༡ ལས་ཉུང་བ་ཡང་ན་ ༡༢ ལས་མང་བ་མི་རུང་།\/\/ཟླ་བ་ ༡། ༣། ༥། ༧། ༨། ༡༠། ༡༢ ནང་ཉིན་གྲངས་ ༡ ལས་ཉུང་བ་ཡང་ན་ ༣༡ ལས་མང་བ་མིན་པ་དང་། ཟླ་བ་ ༤། ༦། ༩། ༡༡ ནང་ཉིན་གྲངས་ ༡ ལས་ཉུང་བ་ཡང་ན་ ༣༠ ལས་མང་བ་མིན་པ་དང་། ཟླ་བ་ ༢ ནང་ཉིན་གྲངས་ ༡ ལས་ཉུང་བ་ཡང་ན་ ༢༩ ལས་མང་བ་མིན་པ་དགོས།\/\/\/ 1 ཚེས་གྲངས་ཀྱི་ཐིག་ཡིག་ནི་སྟོང་པ་མིན་ནོ།།\/\/\/ འོག་གི་ཁྲིམས་ལུགས་ཚང་མ་སྲུང་ཡོད་ན་ཚེས་གྲངས་དེ་བདེན་པ་ཡིན།\/\/\/ སླར་ལོག་ true དེ་དུས་གཏན་འཁེལ་ཡིན་ན་ true དེ་མིན་ false ཟེར་བ་ཡིན།\/\/\/ ཁྱོད་ཀྱིས་དུས་ཚེས་གྲངས་ཀྱི་ཐིག་ཡིག་ལ་ངེས་གཏན་བྱ་རྒྱུའི་ལས་འགན་ཞིག་འབྲི་དགོས་ཤིང་། \/\/\/ >>> valid_date(String::from(\"03-11-2000\"))\n\/\/\/ true\n\/\/\/ >>> valid_date(String::from(\"15-01-2012\"))\n\/\/\/ false\n\/\/\/ >>> valid_date(String::from(\"04-0-2040\"))\n\/\/\/ false\n\/\/\/ >>> valid_date(String::from(\"06-04-2020\"))\n\/\/\/ true\n\/\/\/ >>> valid_date(String::from(\"06\/04\/2020\"))\n\/\/\/ false\nfn valid_date(date: String) -> bool {\n","canonical_solution":"fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return false;\n    }\n\n    let parts: Vec<&str> = date.split('-').collect();\n    if parts.len() != 3 {\n        return false;\n    }\n\n    let maybe_month = parts[0].parse::<u32>();\n    let maybe_day = parts[1].parse::<u32>();\n    let maybe_year = parts[2].parse::<u32>();\n\n    if maybe_month.is_err() || maybe_day.is_err() || maybe_year.is_err() {\n        return false;\n    }\n\n    let month = maybe_month.unwrap();\n    let day = maybe_day.unwrap();\n\n    if month < 1 || month > 12 {\n        return false;\n    }\n\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day < 1 || day > 31 {\n                return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if day < 1 || day > 30 {\n                return false;\n            }\n        }\n        2 => {\n            if day < 1 || day > 29 {\n                return false;\n            }\n        }\n        _ => return false, \/\/ This case should never be reached\n    }\n\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"},{"task_id":"HumanEval_126","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ number, return false. ནུས་མེད་གྲངས་དང་ཧྲིལ་གྲངས་ཁོ་ན་རེད་བསམ་དགོས།\/\/ཕྱོགས་མཚུངས་ཀྱི་འདྲ་དཔེ་གཅིག་ལས་མང་བ་ཡོད་ན།\/\/\/ གྲངས་ཀྱི་བེ་ཊར་ཞིག་ཡོད་ན། ཚོས་གཞི་སྒྲིག་ཡོད་མིན་ལོག་འཇུག་དགོས།\/\/\/ >>> is_sorted(vec![5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 3, 2, 4, 5])\n\/\/\/ false\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5, 6])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n\/\/\/ false\n\/\/\/ >>> is_sorted(vec![1, 2, 2, 3, 3, 4])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n\/\/\/ false\nfn is_sorted(lst: Vec<isize>) -> bool {\n","canonical_solution":"fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.is_empty() || lst.len() == 1 {\n        return true;\n    }\n    \n    let mut previous = lst[0];\n    let mut repeat_count = 0;\n\n    for &current in &lst[1..] {\n        if current < previous {\n            return false;\n        }\n        if current == previous {\n            repeat_count += 1;\n            if repeat_count >= 2 {\n                return false;\n            }\n        } else {\n            repeat_count = 0;\n        }\n        previous = current;\n    }\n\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n}\n"},{"task_id":"HumanEval_127","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ [input\/output] དཔེ་གཟུགས།\/\/གལ་ཏེ་བར་མཚམས་གཉིས་མ་བགོས་ན་ \"NO\" སླར་ལོག་བྱེད།\/\/\/ དེ་མིན་ \"NO\" ཕྱིར་སློག་བྱོས།\/\/\/ གལ་ཏེ་ཕྲེང་བའི་རིང་ཚད་ནི་སྔོན་གྲངས་ཡིན་ན། \"YES\" ཕྱིར་སློག་བྱོས།\/\/ཚད་ནི་ 1 ཡིན་ལ། ཚད་ནི་སྔོན་གྲངས་མིན་པ་ཡིན།\/\/དཔེ་གཞི་འདི་ནི་བར་མཚམས་ (1, 3), (2, 4) གྱི་ཕྲེང་བ་ནི་ (2, 3) ཡིན།\/\/\/ བར་མཚམས་ནི་གྲངས་དང་པོ་ཡིན།\/\/འདིར་ཁྱེད་རང་ཚོའི་ལས་འགན་ནི་ ཚད་གཞི་འདི་གཉིས་ཀྱི་བར་མཚམས་ཀྱི་ཚད་གཞི་ཡིན་མིན་གཏན་འབེབས་བྱེད་རྒྱུ་དེ་ཡིན།\/\/\/ ཇི་རེ་ཡིན་ན་དེའི་འགོ་ནི་མཐའ་དང་ཆུང་བའམ་མཚུངས་པ་ཞིག་རེད་བསམ་གྱི་ཡོད།\/\/\/ ཐོག་མ་དང་མཐའ་གཉིས་ཀ་མཉམ་ཡོད།\/\/\/ བྱིན་ཡོད་པའི་བར་མཚམས་ནི་བསྡམས་པ་རེད་ཟེར། དེའི་དོན་ནི་བར་མཚམས་ (འགོ་འཛུགས་དང་མཇུག་བསྡུ་) ཟེར་བ་རེད།\/\/ཚོད་གྲངས་ཆ་ཤས་རེ་རེ་ནི་གྲངས་ཆ་ཆ་ཚང་གཉིས་ཡིན། དཔེར་ན། ཚོད་གྲངས་ = (འགོ་འཛིན། མཇུག་) = (1, 2) ཟེར་བ་ལྟ་བུ།\/\/\/ ཁྱོད་ཚོར་དུས་ཡུན་གཉིས་ཐོབ་ཡོད།\/\/\/ >>> intersection((1, 2), (2, 3))\n\/\/\/ String::from(\"NO\")\n\/\/\/ >>> intersection((-1, 1), (0, 4))\n\/\/\/ String::from(\"NO\")\n\/\/\/ >>> intersection((-3, -1), (-5, 5))\n\/\/\/ String::from(\"YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    let start_intersection = std::cmp::max(start1, start2);\n    let end_intersection = std::cmp::min(end1, end2);\n\n    if start_intersection <= end_intersection {\n        let length = (end_intersection - start_intersection + 1) as usize;\n        if is_prime(length) {\n            return String::from(\"YES\");\n        }\n    }\n    String::from(\"NO\")\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", intersection((1, 2), (2, 3))); \/\/ \"NO\"\n    println!(\"{}\", intersection((-1, 1), (0, 4))); \/\/ \"NO\"\n    println!(\"{}\", intersection((-3, -1), (-5, 5))); \/\/ \"YES\"\n}","tests":"}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"},{"task_id":"HumanEval_128","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/\/ དྲན་གསོ། སྟོང་པའི་ཨར་ལ་ None སླར་ལོག་བྱེད།\/\/སྐར་ཆ་རེ་རེའི་ནང་གྲངས་ཆ་གང་ཡོད་ཀྱི་གྲངས་ཆ་ 1 དང་ 0 ཡང་ན་ 0 ཟེར་བ་ཡོད།\/\/\/ འབྲས་བུ་ནི་ཨང་གྲངས་ཧྲིལ་པོ་གི་ཆེ་ཆུང་དང་རྟགས་ཐམས་ཅད་ཀྱི་འབྲས་བུ་ཡིན།\/\/འདིར་ཁྱེད་ཚོར་གྲངས་ཧྲིལ་གྲངས་ཀྱི་ ཝི་ཅར་ཨར་ (arr) ཞིག་གནང་ཡོད་པ་དང་ཁྱེད་ཚོས་ཕྱིར་ལོག་དགོས་ཀྱི་འདུག\/\/\/ >>> prod_signs(vec![1, 2, 2, -4])\n\/\/\/ Some(9)\n\/\/\/ >>> prod_signs(vec![0, 1])\n\/\/\/ Some(0)\n\/\/\/ >>> prod_signs(vec![])\n\/\/\/ None\nfn prod_signs(arr: Vec<isize>) -> Option<isize> {\n","canonical_solution":"fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n    let mut sum_of_magnitudes = 0;\n    let mut product_of_signs = 1;\n\n    for &num in &arr {\n        sum_of_magnitudes += num.abs();\n        if num == 0 {\n            product_of_signs = 0;\n            break;\n        } else if num > 0 {\n            product_of_signs *= 1;\n        } else {\n            product_of_signs *= -1;\n        }\n    }\n\n    Some(sum_of_magnitudes * product_of_signs)\n}","tests":"}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n}\n"},{"task_id":"HumanEval_129","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ཕྲེང་བ་ཆུང་ཤོས་ཀྱི་ལམ་བརྒྱུད་པའི་ཕྲེང་བའི་ཚད་གཞི་རིམ་བཞིན་སླར་ལོག་བྱེད།\/\/ཇི་སྲིད་ལན་འདེབས་དེ་འདྲ་མེད་ན་དེ་ངེས་རེད།\/\/\/ lst_A[j] = lst_B[j] ཟེར་བ་ལྟ་བུ།\/\/ཇི་འདྲ་ཡིན་ན་ lst_A[i] < lst_B[i] དང་ j (1 <= j < i) ཇི་འདྲ་ཡིན་ན་\/\/ཕྲ་རིང་གི་ཚད་ནི་ 1 པ་དང་མཉམ་པ་ཡིན།\/\/རྒྱུད་ནས་ (ང་ཚོས་དེ་དག་ལ་ lst_A དང་ lst_B ཞེས་འབོད།) lst_A ནི་ཚིག་མཛོད་རིག་པའི་ཐོག་ནས་ཉུང་བ་རེད།\/\/སྐར་ཁུང་ A དང་ B ནང་གི་ཐང་གི་རིམ་སྒྲིག་ཅན་གྱི་སྐར་ཁུང་བཟོས་རྗེས་འགྲོ་བཞིན་ཡོད།\/\/\/ ལམ་རིམ་ A (རིང་ཚད་ k) ནི་ལམ་རིམ་ B (རིང་ཚད་ k) ལས་ཆུང་བ་རེད་བསམ་ན་\/\/\/ ཁྱོད་ཀྱིས་དྲ་ལམ་ནས་ཕྱིར་འགྲོ་མི་ཐུབ།\/\/\/ ངེས་པར་དུ་ཁྱད་པར་ཅན་རེད།)\/\/\/ ཐབས་ལམ་རིང་ཚད་ k ཟེར་བ་འདི་ནི་ k ཁང་མིག་ལ་ཐད་ཀར་འགྲོ་དགོས་པ་ (མི་ འདྲ་བ་) ཡིན་པར་གཟིགས།\/\/\/ ཁང་མིག་། \/\/འདི་ཡང་ཁྱེད་རང་དང་ ཕྱོགས་གཅིག་ཏུ་ཡོད་པའི་ ཕྲ་ཁུང་ནང་འགྲོ་ཐུབ།\/\/སྐར་ཁུང་ནས་དྲ་ལམ་གང་རུང་ནས་དྲ་ལམ་གང་རུང་དུ་འགྲོ་ཐུབ། སྐར་ཁུང་གི་དྲ་ལམ་གང་རུང་ནས་དྲ་ལམ་གང་རུང་དུ་འགྲོ་ཐུབ།\/\/ཁྱོད་ཀྱིས་དྲ་ལམ་ནང་གི་ཚད་ k ཡི་ཆུང་ཤོས་ཀྱི་ལམ་འཚོལ་དགོས། ཁྱོད་ཀྱིས་འགོ་ཚུགས་ཐུབ།\/\/\/ inclusive ཟེར་བ་འདི་ནི་ཐིག་ཁྲམ་ནང་གི་ཚགས་པར་ནང་ཐེངས་གཅིག་རང་མངོན་པར་བྱེད།\/\/\/ ཕྲེང་བ་རེ་རེའི་ནང་གྲངས་ཐང་ཞིག་ཡོད། [1, N * N] ནང་གི་གྲངས་ཐང་ཆ་ཚང་རེ་རེ\/\/\/ གྲལ་ཐིག་ N དང་ཀ་བ་ N (N >=2) དང་གྲངས་ཆ་ k ཡོད་པའི་དྲ་རྒྱ་ཞིག་ཡོད་ན། \/\/\/ >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)\n\/\/\/ vec![1, 2, 1]\n\/\/\/ >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)\n\/\/\/ vec![1]\nfn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n","canonical_solution":"fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n    let n = grid.len();\n    let mut best_path = vec![];\n    let mut best_values = vec![isize::MAX; k as usize];\n    \n    fn dfs(\n        grid: &Vec<Vec<isize>>, \n        row: usize, \n        col: usize, \n        path: &mut Vec<(usize, usize)>, \n        values: &mut Vec<isize>, \n        k: isize, \n        best_values: &mut Vec<isize>\n    ) {\n        if path.len() == k as usize {\n            if values < best_values {\n                best_values.clone_from(values);\n            }\n            return;\n        }\n        \n        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];\n        for &(dr, dc) in directions.iter() {\n            let new_row = row as isize + dr;\n            let new_col = col as isize + dc;\n            if new_row >= 0 && new_row < grid.len() as isize && new_col >= 0 && new_col < grid.len() as isize {\n                path.push((new_row as usize, new_col as usize));\n                values.push(grid[new_row as usize][new_col as usize]);\n                dfs(grid, new_row as usize, new_col as usize, path, values, k, best_values);\n                values.pop();\n                path.pop();\n            }\n        }\n    }\n\n    for r in 0..n {\n        for c in 0..n {\n            let mut path = vec![(r, c)];\n            let mut values = vec![grid[r][c]];\n            dfs(&grid, r, c, &mut path, &mut values, k, &mut best_values);\n        }\n    }\n\n    best_values\n}","tests":"}\n\nfn main() {\n    let candidate = minPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);\n    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);\n    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);\n    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);\n    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);\n    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);\n    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n"},{"task_id":"HumanEval_130","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ དང་པོ་ n+1 ནི་ Tribonacci གི་རིམ་པ་ཡིན།\/\/འདིར་མི་ནག་པའི་གྲངས་ཀ་ n ཞིག་ཡོད་ལ། འདིར་ གྱི་བེ་ཊར་ a སླར་ལོག་བྱ་དགོས།\/\/\/ = 2 + 3 + 3 = 8\/\/\/ tri(3) = tri(2) + tri(1) + tri(4) \/\/\/ tri ((4) = 3\/\/\/ tri(2) = 1 + (2 \/ 2) = 2 \/\/\/ དཔེ་གཞི་: \/\/\/ tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1) ཡིན་ན། n ནི་གྲངས་ཆ་མ་ཡིན།\/\/\/tri (n) =1+n\/2, གལ་ཏེ་ n ནི་ཆ་སྙོམས་ཡིན་ན།\/\/\/ tri(1) = 3 \/\/\/ Tribonacci sequence འདི་ཡང་བསྐྱར་དུ་བྱུང་བའི་སྒོ་ནས་གསལ་བཤད་བྱས་པ་ཡིན།\/\/ཡིན་ན་ཡང་མི་ཚོས་མི་ཤེས་པ་ནི་ཏྲི་བོན་ཅེ་ (Tribonacci) གི་རིམ་པ་ཡིན།\/\/མི་ཚང་མས་ཕི་བྷོ་ན་ཅིའི་རིམ་པ་ཤེས་ཀྱི་ཡོད། ཕི་བྷོ་ན་ཅིའི་རིམ་པ་ནི་ ༡༩༥༠ ལོར་རིག་རྩལ་མཁས་པ་རྣམས་ཀྱིས་ཞིབ་ཏུ་ཞིབ་འཇུག་བྱས་པ་ཡིན།\/\/\/ >>> tri(3)\n\/\/\/ vec![1, 3, 2, 8]\nfn tri(n: isize) -> Vec<isize> {\n","canonical_solution":"fn tri(n: isize) -> Vec<isize> {\n    fn tribonacci(n: isize, memo: &mut Vec<isize>) -> isize {\n        if n < memo.len() as isize {\n            return memo[n as usize];\n        }\n\n        let result = if n == 1 {\n            3\n        } else if n % 2 == 0 {\n            1 + n \/ 2\n        } else {\n            tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n + 1, memo)\n        };\n\n        if n as usize >= memo.len() {\n            memo.resize(n as usize + 1, 0);\n        }\n        memo[n as usize] = result;\n        result\n    }\n\n    let mut sequence = Vec::new();\n    let mut memo = Vec::new();\n\n    for i in 0..=n {\n        sequence.push(tribonacci(i, &mut memo));\n    }\n\n    sequence\n}","tests":"}\n\nfn main() {\n    let candidate = tri;\n    assert_eq!(candidate(3), vec![1, 3, 2, 8]);\n    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);\n    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);\n    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);\n    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);\n    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);\n    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);\n    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);\n    assert_eq!(candidate(0), vec![1]);\n    assert_eq!(candidate(1), vec![1, 3]);\n}\n"},{"task_id":"HumanEval_131","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/\/ གྲངས་ཀ་ཆ་མཉམ་ཉ་ན་ 0 སླར་ལོག་བྱེད།\/\/\/ ནུས་ལྡན་ཨང་གྲངས་ n བྱིན་ཚད། གྱངས་ཁ་མ་ཚང་བའི་ཨང་གྲངས་ཀྱི་འབྲས་བུ་ཕྱིར་སློག་བྱོས།\/\/\/ >>> digits(1)\n\/\/\/ 1\n\/\/\/ >>> digits(4)\n\/\/\/ 0\n\/\/\/ >>> digits(235)\n\/\/\/ 15\nfn digits(n: isize) -> isize {\n","canonical_solution":"fn digits(n: isize) -> isize {\n    let mut product = 1;\n    let mut has_odd = false;\n    let mut num = n;\n\n    while num > 0 {\n        let digit = num % 10;\n        if digit % 2 != 0 {\n            product *= digit;\n            has_odd = true;\n        }\n        num \/= 10;\n    }\n\n    if has_odd {\n        product\n    } else {\n        0\n    }\n}\n\nfn main() {\n    println!(\"{}\", digits(1));  \/\/ 1\n    println!(\"{}\", digits(4));  \/\/ 0\n    println!(\"{}\", digits(235)); \/\/ 15\n}","tests":"}\n\nfn main() {\n    let candidate = digits;\n    assert_eq!(candidate(5), 5);\n    assert_eq!(candidate(54), 5);\n    assert_eq!(candidate(120), 1);\n    assert_eq!(candidate(5014), 5);\n    assert_eq!(candidate(98765), 315);\n    assert_eq!(candidate(5576543), 2625);\n    assert_eq!(candidate(2468), 0);\n}\n"},{"task_id":"HumanEval_132","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ འདི་ནང་འོག་གི་རིམ་པ་གཅིག་ཡང་མ་ཉུང་ན་སྦྲེལ་ཡོད།\/\/\/ ལས་འགན་འདི་ནི་བདེན་པ་ཡིན་པ་ཕྱིར་ལོག་བྱེད་དགོས། གལ་ཏེ་ brackets ཀྱི་རིམ་པ་ངེས་ཅན་ཞིག་ཡོད་ན་ཁོ་ན་ true སླར་ལོག་བྱེད་དགོས།\/\/\/ ལས་འགན་ཞིག་བཟོ་དགོས། ཇི་འདྲ་ཞིག་ནང་འཇུག་བྱེད་པ་དེ་ནི་ ཀྲུང་གོ་ནང་ཡོད་པའི་ཡིག་འབྲུ་ཞིག་ཡིན།\/\/\/ >>> is_nested(String::from(\"[[]]\"))\n\/\/\/ true\n\/\/\/ >>> is_nested(String::from(\"[]]]]]]][[[[[]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[][]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[[][]]\"))\n\/\/\/ true\n\/\/\/ >>> is_nested(String::from(\"[[]][[\"))\n\/\/\/ true\nfn is_nested(string: String) -> bool {\n","canonical_solution":"fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let mut nested = false;\n\n    for bracket in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n        } else if bracket == ']' {\n            if let Some(_) = stack.pop() {\n                if !stack.is_empty() {\n                    nested = true;\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n\n    nested\n}\n\nfn main() {\n    println!(\"{}\", is_nested(String::from(\"[[]]\"))); \/\/ true\n    println!(\"{}\", is_nested(String::from(\"[]]]]]]][[[[[]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[][]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[[][]]\"))); \/\/ true\n    println!(\"{}\", is_nested(String::from(\"[[]][[\"))); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"},{"task_id":"HumanEval_133","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ཕྱོགས་རིས་ནང་ཡོད་པའི་ཆ་ཤས་རེ་རེར་ཐོག་མར་སྟེང་གི་ int (སྟེང་གི་ཐིག་) སྟེང་གི་ཐིག་ (སྟེང་གི་ཐིག་) སྟེང་གི་ཐིག་ (སྟེང་གི་ཐིག་) སྟེང་གི་ཐིག་ (སྟེང་གི་ཐིག་) སྟེང་གི་ཐིག་ (སྟེང་གི་ཐིག་) སྟེང་གི་ཐིག་ (སྟེང་གི་ཐིག་) སྟེང་གི་ཐིག་ (སྟེང་གི་ཐིག་) སྟེང་གི་ཐིག་ (སྟེང་གི་ཐིག་) སྟེང་གི་ཐིག་ (སྟེང་གི་ཐིག་) སྟེང་གི་ཐིག་ (སྟེང་གི་ཐིག་)\/\/ཁྱོད་ཀྱིས་གྲངས་ཀྱི་ཟུར་གཉིས་གྱི་བསྡོམས་གྲངས་ཕྱིར་ལོག་བྱེད་དགོས་པ་ཡིན།\/\/སྐར་མ་གྲངས་ཀྱི་གྲངས་ཐིག་ཞིག་གནང་ཡོད།\/\/\/ >>> lst(vec![1.0, 2.0, 3.0])\n\/\/\/ 14\n\/\/\/ >>> lst(vec![1.0, 4.0, 9.0])\n\/\/\/ 98\n\/\/\/ >>> lst(vec![1.0, 3.0, 5.0, 7.0])\n\/\/\/ 84\n\/\/\/ >>> lst(vec![1.4, 4.2, 0.0])\n\/\/\/ 29\n\/\/\/ >>> lst(vec![-2.4, 1.0, 1.0])\n\/\/\/ 6\nfn sum_squares(lst: Vec<f64>) -> isize {\n","canonical_solution":"fn sum_squares(lst: Vec<f64>) -> isize {\n    lst.iter()\n        .map(|&x| x.ceil() as isize)  \/\/ Round each element to the nearest upper integer\n        .map(|x| x * x)               \/\/ Square each element\n        .sum()                        \/\/ Sum all the squared elements\n}\n\nfn main() {\n    println!(\"{}\", sum_squares(vec![1.0, 2.0, 3.0])); \/\/ 14\n    println!(\"{}\", sum_squares(vec![1.0, 4.0, 9.0])); \/\/ 98\n    println!(\"{}\", sum_squares(vec![1.0, 3.0, 5.0, 7.0])); \/\/ 84\n    println!(\"{}\", sum_squares(vec![1.4, 4.2, 0.0])); \/\/ 29\n    println!(\"{}\", sum_squares(vec![-2.4, 1.0, 1.0])); \/\/ 6\n}","tests":"}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);\n    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);\n    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);\n    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);\n    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);\n    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);\n    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);\n    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);\n    assert_eq!(candidate(vec![0.0]), 0);\n    assert_eq!(candidate(vec![-1.0]), 1);\n    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);\n}\n"},{"task_id":"HumanEval_134","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ དྲན་གསོ། \"word\" ནི་ཡིག་འབྲུ་ཁག་གི་སྡེ་ཚན་ཞིག་ཡིན་པས་དེའི་བར་སྟོང་བཞག་ཡོད།\/\/ཕྱོགས་གཅིག་ནས་ཚིག་ཅིག་དང་། གཞན་ནས་ཚིག་རྫུན་མ་ཞིག\/\/ཚད་ལྡན་ཡིག་འབྲུ་འདི་ནི་ཡིག་འབྲུ་ཡིག་གཟུགས་ཀྱི་ཡིག་རྟགས་ཤིག་ཡིན་དང་དེ་མིན་ \/\/གལ་ཏེ་མཐའ་མའི་ཡིག་འབྲུ་འདི་ true ཡིན་ན་ function དེ་སླར་ལོག་བྱ་དགོས།\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pie\"))\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pi e\"))\n\/\/\/ true\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pi e \"))\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"\"))\n\/\/\/ false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n","canonical_solution":"fn check_if_last_char_is_a_letter(txt: String) -> bool {\n    if let Some(c) = txt.trim().chars().rev().next() {\n        if c.is_alphabetic() {\n            if let Some(prev_char) = txt.chars().rev().skip_while(|&ch| ch.is_whitespace()).nth(1) {\n                return !prev_char.is_alphabetic();\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pie\")));  \/\/ false\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pi e\"))); \/\/ true\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pi e \"))); \/\/ false\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"\")));           \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n}\n"},{"task_id":"HumanEval_135","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ དངོས་པོ་གཉིས་མཚུངས་ཡོད་ན།\/\/\/ འདི་ལྟ་བུའི་ཆ་ཤས་མེད་ན་ return - 1 སླར་ལོག་བྱེད། བྱིན་ཡོད་པའི་བེ་ཊར་ནང་ ཡོད་པ་མི་འདུག\/\/ཇི་འདྲ་ཡིན་ན་དེ་སྔོན་གྱི་ཆ་ཤས་དང་ འདྲ་བའམ་དེ་ལས་ཆེ་བ་མི་འདུག\/\/\/ ལས་འགན་ཅིག་བཟོ། ཇི་བཞིན་ཆ་ཤས་ཤིག་གི་ index ཆེ་ཤོས་ཕྱིར་ལོག་བྱེད།\/\/\/ >>> can_arrange(vec![1, 2, 4, 3, 5])\n\/\/\/ 3\n\/\/\/ >>> can_arrange(vec![1, 2, 3])\n\/\/\/ -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn can_arrange(arr: Vec<isize>) -> isize {\n    for i in (1..arr.len()).rev() {\n        if arr[i] < arr[i - 1] {\n            return i as isize;\n        }\n    }\n    -1\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     println!(\"{}\", can_arrange(vec![1, 2, 4, 3, 5])); \/\/ Outputs: 3\n\/\/     println!(\"{}\", can_arrange(vec![1, 2, 3])); \/\/ Outputs: -1\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"},{"task_id":"HumanEval_136","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ནུས་མེད་དང་ཆ་མེད་གྲངས་ཆ་མེད་ཡིན་ན། None སྦེ་ཕྱིར་ལོག་བྱེད།\/\/\/ པོ་ཊི་རི་ཀཊར་ནང་ཨང་གྲངས་ཧྲིལ་པོ་ཚུའི་གྲངས་ཐང་།\/\/ཆུང་ཤོས་ནི་ b ཡིན་\/\/\/ ལས་འགན་ཅིག་བཟོ། འདི་ནང་ 'a' ནི་ ཡིན་པའི་ནང་།\/\/\/ >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n\/\/\/ (None, Some(1))\n\/\/\/ >>> largest_smallest_integers(vec![])\n\/\/\/ (None, None)\n\/\/\/ >>> largest_smallest_integers(vec![0])\n\/\/\/ (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n","canonical_solution":"fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative: Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\n    for &num in &lst {\n        if num < 0 {\n            largest_negative = match largest_negative {\n                Some(largest) => Some(largest.max(num)),\n                None => Some(num),\n            };\n        } else if num > 0 {\n            smallest_positive = match smallest_positive {\n                Some(smallest) => Some(smallest.min(num)),\n                None => Some(num),\n            };\n        }\n    }\n\n    (largest_negative, smallest_positive)\n}\n\nfn main() {\n    println!(\"{:?}\", largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])); \/\/ (None, Some(1))\n    println!(\"{:?}\", largest_smallest_integers(vec![])); \/\/ (None, None)\n    println!(\"{:?}\", largest_smallest_integers(vec![0])); \/\/ (None, None)\n    println!(\"{:?}\", largest_smallest_integers(vec![-5, -1, -3, 0, 2, 3])); \/\/ (Some(-1), Some(2))\n}","tests":"}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));\n}\n"},{"task_id":"HumanEval_138","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/ཇི་ཡོད་གྲངས་ n ནི་གྲངས་ཆ་ལྡོག་པའི་གྲངས་ཆ་ 4 ཀྱི་བསྡོམས་ཡིན་མིན་ལ་དཔྱད་པ།\/\/\/ >>> is_equal_to_sum_even(4)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(6)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(8)\n\/\/\/ true\nfn is_equal_to_sum_even(n: isize) -> bool {\n","canonical_solution":"fn is_equal_to_sum_even(n: isize) -> bool {\n    \/\/ A number n can be expressed as the sum of 4 positive even numbers if and only if\n    \/\/ it is greater than or equal to 8 and even\n    n >= 8 && n % 2 == 0\n}\n\n\/\/ Test cases\nfn main() {\n    println!(\"{}\", is_equal_to_sum_even(4));  \/\/ false\n    println!(\"{}\", is_equal_to_sum_even(6));  \/\/ false\n    println!(\"{}\", is_equal_to_sum_even(8));  \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = is_equal_to_sum_even;\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(8), true);\n    assert_eq!(candidate(10), true);\n    assert_eq!(candidate(11), false);\n    assert_eq!(candidate(12), true);\n    assert_eq!(candidate(13), false);\n    assert_eq!(candidate(16), true);\n}\n"},{"task_id":"HumanEval_139","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/\/ དེར་ n > 0 \/\/\/ brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! \/\/\/ བརཱ་ཛིལ་གྱི་གནས་ལུགས་ནི་གཤམ་གསལ་ལྟར་ངེས་གཏན་བྱས་ཡོད།\/\/\/ >>> special_factorial(4)\n\/\/\/ 288\n\/\/\/ The function will receive an integer as input and should return the special\n\/\/\/ factorial of this integer.\nfn special_factorial(n: isize) -> isize {\n","canonical_solution":"fn factorial(n: isize) -> isize {\n    (1..=n).product()\n}\n\nfn special_factorial(n: isize) -> isize {\n    (1..=n).map(factorial).product()\n}\n\nfn main() {\n    let result = special_factorial(4);\n    println!(\"{}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"},{"task_id":"HumanEval_140","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དེ་ནས་ཤུལ་མའི་བར་སྟོང་ཚང་མ་ -   ཀྱིས་འདེམས་དགོས།\/\/\/ དང་ string ནང་ space གཉིས་ལས་ལྷག་ཡོད་ན།\/\/\/ ཡིག་འབྲུ་ཐིག་ཡིག་ཅིག་ཡོད་ན་ ནང་གི་བར་སྟོང་ཚང་མ་འོག་ཡིག་དང་ཚབ་ཏུ་འཇོག་དགོས།\/\/\/ >>> fix_spaces(String::from(\" Example\"))\n\/\/\/ String::from(\"Example\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 1\"))\n\/\/\/ String::from(\"Example_1\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 2\"))\n\/\/\/ String::from(\"_Example_2\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 3\"))\n\/\/\/ String::from(\"_Example-3\")\nfn fix_spaces(text: String) -> String {\n","canonical_solution":"fn fix_spaces(text: String) -> String {\n    let mut result = String::new();\n    let mut space_count = 0;\n\n    for c in text.chars() {\n        if c == ' ' {\n            space_count += 1;\n        } else {\n            if space_count > 2 {\n                result.push('-');\n            } else if space_count > 0 {\n                result.push_str(&\"_\".repeat(space_count));\n            }\n            result.push(c);\n            space_count = 0;\n        }\n    }\n\n    if space_count > 2 {\n        result.push('-');\n    } else if space_count > 0 {\n        result.push_str(&\"_\".repeat(space_count));\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = fix_spaces;\n    assert_eq!(candidate(String::from(\"Example\")), String::from(\"Example\"));\n    assert_eq!(candidate(String::from(\"Mudasir Hanif \")), String::from(\"Mudasir_Hanif_\"));\n    assert_eq!(candidate(String::from(\"Yellow Yellow  Dirty  Fellow\")), String::from(\"Yellow_Yellow__Dirty__Fellow\"));\n    assert_eq!(candidate(String::from(\"Exa   mple\")), String::from(\"Exa-mple\"));\n    assert_eq!(candidate(String::from(\"   Exa 1 2 2 mple\")), String::from(\"-Exa_1_2_2_mple\"));\n}\n"},{"task_id":"HumanEval_141","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ - ཕྲེང་བ་རྗེས་ཀྱི་ཡིག་འབྲུ་འདི་ཚོ་གཅིག་རེད། ['txt', 'exe', 'dll']\/\/\/ ལ་ཏིན་ཡིག་གཟུགས་ (a-z དང་ A-Z) དང་།\/\/\/ - ཕྲེང་བ་སྔོན་གྱི་ནང་ཡིག་རྟགས་ནི་སྟོང་པ་མི་དགོས་པར་ ཟེར་བའི་ཡི་གེ་ལས་འགོ་འཛུགས་དགོས།\/\/\/ - ཡིག་སྣོད་མིང་གི་ནང་དོན་གཅིག་རང་ཡོད།\/\/\/ - ཡིག་སྣོད་མིང་དུ་ཨང་གྲངས་གསུམ་ལས་ལྷག་མི་ཆོག ('0'-'9')\/\/\/ ཇི་ལྟ་བ་ལ་ཐུག་ཡོད།\/\/\/ ཡིག་སྣོད་མིང་རྟགས་འདི་ཁ་སྐོང་གནས་སྟངས་ཚང་མ་ནང་ཡོད་ན་དང་དེ་མ་གཏོགས་གནས་སྟངས་ཆ་མཉམ་ནང་ཡོད་མེད་ཆ་འཛིན་བྱ་ཐུབ།\/\/\/ གལ་ཏེ་ཡིག་སྣོད་མིང་གི་མིང་དེ་བདེན་པ་ཡིན་ན་ \"Yes\" དེ་ཡིན་ན་ \"No\" དེ་ཡིན་ན་ \"No\" ཟེར་བ་ཕྱིར་ལོག་བྱེད།\/\/\/ ལས་འགན་ཅིག་བཟོ། ཇི་གིས་ཡིག་སྣོད་མིང་གི་མིང་རྟགས་ཀྱི་ཐིག་ཡིག་ལེན་ནས་སླར་ལོག་བྱེད།\/\/\/ >>> file_name_check(String::from(\"example.txt\"))\n\/\/\/ String::from(\"Yes\")\n\/\/\/ >>> file_name_check(String::from(\"1example.dll\"))\n\/\/\/ String::from(\"No\")\nfn file_name_check(file_name: String) -> String {\n","canonical_solution":"fn file_name_check(file_name: String) -> String {\n    let parts: Vec<&str> = file_name.split('.').collect();\n\n    if parts.len() != 2 {\n        return String::from(\"No\");\n    }\n\n    let before_dot = parts[0];\n    let after_dot = parts[1];\n\n    if before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic() {\n        return String::from(\"No\");\n    }\n\n    let digit_count = before_dot.chars().filter(|c| c.is_digit(10)).count();\n    if digit_count > 3 {\n        return String::from(\"No\");\n    }\n\n    match after_dot {\n        \"txt\" | \"exe\" | \"dll\" => String::from(\"Yes\"),\n        _ => String::from(\"No\"),\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\/this_is_valid.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"No\"));\n}\n"},{"task_id":"HumanEval_142","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ཝི་ཅཊར་ནང་ནང་དོན་བརྗེ་བསྒྱུར་བྱེད་སྐབས་དེའི་ནང་དོན་ནི་ 3 དང་ 4 ཀྱི་གྱངས་ཁ་དང་མི་འདྲ་བ་ཡིན། དེ་ནས་ལས་འགན་གྱིས་ནང་དོན་ཐམས་ཅད་ཀྱི་བསྡོམས་གྲངས་ཕྱིར་ལོག་བྱེད་དགོས།\/\/སྐར་ཁུང་གི་དྲ་རྒྱ་ནས་དྲ་རྒྱ་ཁ་པར་གྱི་ནང་དོན་འདྲ་མིན་དང་འབྲེལ་བའི་དྲ་རྒྱ་ཁ་པར་གྱི་ནང་དོན་འདྲ་མིན་ལ་དཔྱད་པ།\/\/\/ ལས་འགན་འདི་ནི་ཨང་གྲངས་ཧྲིལ་པོ་གི་བེ་ཊར་ཞིག་ལེན་ངེས་ཡིན། ཝི་ཊར་ནང་ཡོད་པའི་ཡིག་ཆ་ཚང་མ་ལ། ལས་འགན་དེའི་ཨང་གྲངས་ཧྲིལ་པོ་ནི་ a ཡིན་ན་དེའི་ནང་དོན་ནི་གྲུ་བཞི་ཏུ་བཀོད་དགོས་པ་ཡིན།\/\/\/ \" ཟེར་བ་རེད།\/\/\/ >>> lst\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> lst\n\/\/\/ vec![]\n\/\/\/ >>> lst\n\/\/\/ vec![-1, -5, 2, -1, -5]\nfn sum_squares(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn sum_squares(lst: Vec<isize>) -> isize {\n    lst.into_iter()\n        .enumerate()\n        .map(|(i, value)| {\n            if i % 3 == 0 {\n                value * value\n            } else if i % 4 == 0 {\n                value * value * value\n            } else {\n                value\n            }\n        })\n        .sum()\n}\n\nfn main() {\n    let lst = vec![1, 2, 3];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 14\n\n    let lst = vec![];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 0\n\n    let lst = vec![-1, -5, 2, -1, -5];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 112\n}","tests":"}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1, 2, 3]), 6);\n    assert_eq!(candidate(vec![1, 4, 9]), 14);\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);\n    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);\n    assert_eq!(candidate(vec![0]), 0);\n    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);\n    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);\n    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);\n    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);\n    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);\n}\n"},{"task_id":"HumanEval_143","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་དང་པོ།: \/\/\/ ཚིག་རིམ་གསར་པའི་ནང་ཡོད་པའི་ཚིག་ཡིག་གི་རིམ་པ་སྔོན་གྱི་རིམ་པ་འདྲ་མཚུངས་ཡིན་དགོས།\/\/\/ དེའི་རིང་ཚད་ནི་སྔོན་གྲངས་ཡིན།\/\/ཤོག་ངོས་འདི་ཡི་བཟོ་བཅོས་མཐའ་མ་༢༩༩ ལས་འགོ་བཙུགས་ཏེ་ ཤོག་ངོས་འདི་ལ་མཐའ་མའི་མིང་བཏགས་འདུག\/\/\/ ནང་ཚིག་ལ་བར་སྟོང་བཞག་པའི་ཚིག་འགའ་ཤས་ཡོད།\/\/མཆན་འགྲེལ་ཚིག་ཕྲེང་བ་ཞིག་གནང་ཡོད།\/\/\/ >>> words_in_sentence(String::from(\"This is a test\"))\n\/\/\/ String::from(\"is\")\n\/\/\/ Example 2:\n\/\/\/ >>> words_in_sentence(String::from(\"lets go for swimming\"))\n\/\/\/ String::from(\"go for\")\n\/\/\/ Constraints:\n\/\/\/ * 1 <= len(sentence) <= 100\n\/\/\/ * sentence contains only letters\nfn words_in_sentence(sentence: String) -> String {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn words_in_sentence(sentence: String) -> String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n    let prime_length_words: Vec<&str> = words\n        .iter()\n        .filter(|&&word| is_prime(word.len()))\n        .cloned()\n        .collect();\n    prime_length_words.join(\" \")\n}\n\nfn main() {\n    assert_eq!(\n        words_in_sentence(String::from(\"This is a test\")),\n        String::from(\"is\")\n    );\n    assert_eq!(\n        words_in_sentence(String::from(\"lets go for swimming\")),\n        String::from(\"go for\")\n    );\n}","tests":"}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"));\n}\n"},{"task_id":"HumanEval_144","nl":"bod_Tibt","pl":"rs","prompt":"\/\/ཁྱོད་ཀྱིས་ x དང་ n ནི་ཆ་ཤས་དངོས་ཡིན་པར་ངོས་འཛིན་བྱེད་ཆོག ཕྲེང་བ་ནི་ 0 ཡིན་པ་མི་འདུག\/\/\/ <གྲངས་ཀ་>\/<གྲངས་ཀ་> ནང་གྲངས་ཀ་དང་གྲངས་ཀ་གཉིས་ཆ་ར་ནི་གྲངས་ཀ་ཧྲིལ་པོ་ཡིན་ན།\/\/x དང་ n གཉིས་ནི་ཕྲད་གྲངས་ཀྱི་རིམ་པའི་མཚོན་རྟགས་ཡིན་ཏེ། ཟེར་བའི་རྣམ་པ་གཤམ་གསལ་ལྟར་ཡོད།\/\/\/ x * n གྲངས་ཀ་ཧྲིལ་པོ་ x * n དང་ false ཡིན་ན་ལས་འགན་ true སླར་ལོག་བྱེད།\/\/\/ ཁྱོད་ཀྱི་ལས་འགན་ནི་ཚིག་མཛོད་དྭངས་གསལ་བཟོ་རྒྱུའི་ལས་འགན་ཞིག་ལག་ལེན་དུ་འཇུག་པ་ཡིན།\/\/\/ >>> simplify(String::from(\"1\/5\"), String::from(\"5\/1\"))\n\/\/\/ true\n\/\/\/ >>> simplify(String::from(\"1\/6\"), String::from(\"2\/1\"))\n\/\/\/ false\n\/\/\/ >>> simplify(String::from(\"7\/10\"), String::from(\"10\/2\"))\n\/\/\/ false\nfn simplify(x: String, n: String) -> bool {\n","canonical_solution":"fn gcd(a: u32, b: u32) -> u32 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nfn simplify(x: String, n: String) -> bool {\n    let x_parts: Vec<&str> = x.split('\/').collect();\n    let n_parts: Vec<&str> = n.split('\/').collect();\n    \n    let x_num: u32 = x_parts[0].parse().unwrap();\n    let x_den: u32 = x_parts[1].parse().unwrap();\n    let n_num: u32 = n_parts[0].parse().unwrap();\n    let n_den: u32 = n_parts[1].parse().unwrap();\n    \n    let result_num = x_num * n_num;\n    let result_den = x_den * n_den;\n    \n    let gcd_value = gcd(result_num, result_den);\n    \n    result_den \/ gcd_value == 1\n}","tests":"}\n\nfn main() {\n    let candidate = simplify;\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"5\/1\")), true);\n    assert_eq!(candidate(String::from(\"1\/6\"), String::from(\"2\/1\")), false);\n    assert_eq!(candidate(String::from(\"5\/1\"), String::from(\"3\/1\")), true);\n    assert_eq!(candidate(String::from(\"7\/10\"), String::from(\"10\/2\")), false);\n    assert_eq!(candidate(String::from(\"2\/10\"), String::from(\"50\/10\")), true);\n    assert_eq!(candidate(String::from(\"7\/2\"), String::from(\"4\/2\")), true);\n    assert_eq!(candidate(String::from(\"11\/6\"), String::from(\"6\/1\")), true);\n    assert_eq!(candidate(String::from(\"2\/3\"), String::from(\"5\/2\")), false);\n    assert_eq!(candidate(String::from(\"5\/2\"), String::from(\"3\/5\")), false);\n    assert_eq!(candidate(String::from(\"2\/4\"), String::from(\"8\/4\")), true);\n    assert_eq!(candidate(String::from(\"2\/4\"), String::from(\"4\/2\")), true);\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"5\/1\")), true);\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"1\/5\")), false);\n}\n"},{"task_id":"HumanEval_145","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/\/ ཚོས་གཞི་གཞི་ཐོག་ནས་རིམ་སྒྲིག་བྱེད་པ།\/\/\/ དྲན་གསོ། གལ་ཏེ་ནང་དོན་ཁ་ཤས་ཀྱི་ཨང་གྲངས་བསྡོམས་མཚུངས་ཡོད་ན།\/\/\/ ཤོག་གྲངས་ཀྱི་གྲངས་བསྡོམས་དང་བསྟུན་པའི་རིམ་པ་ཡར་འཕེལ།\/\/\/ ཕན་ནུས་ཤིག་བྲིས་ནས་གྲངས་ཚང་གི་བེ་ཊར་ལ་རིམ་སྒྲིག་བྱེད་ཅིག\/\/\/ >>> order_by_points(vec![1, 11, -1, -11, -12])\n\/\/\/ vec![-1, -11, 1, -12, 11]\n\/\/\/ >>> order_by_points(vec![])\n\/\/\/ Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut nums_with_indices: Vec<(isize, usize)> = nums.iter().cloned().enumerate().collect();\n\n    nums_with_indices.sort_by_key(|&(num, index)| {\n        let sum_of_digits = num.abs().to_string().chars().map(|c| c.to_digit(10).unwrap_or(0) as isize).sum::<isize>();\n        (sum_of_digits, index)\n    });\n\n    nums_with_indices.iter().map(|&(num, _)| num).collect()\n}\n\nfn main() {\n    \/\/ Example usage\n    let sorted = order_by_points(vec![1, 11, -1, -11, -12]);\n    println!(\"{:?}\", sorted); \/\/ Output: [-1, -11, 1, -12, 11]\n}","tests":"}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"},{"task_id":"HumanEval_146","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/\/ གྲངས་ཀྱི་ཨང་གྲངས་དང་པོ་དང་མཐའ་མ་ནི་རྣམ་གྲངས་ཡིན། (1, 3, 5, 7, 9)\/\/\/ ཕྲེང་བ་ནང་ཡོད་ཆ་གྲངས་ནི་ 10 ལས་མང་བ་ཡིན་པ་དང་གཉིས་ཀ་ཡིན་པ།\/\/\/ གྲངས་ཀྱི་བེ་ཊར་ཞིག་རྩིས་ཏེ་ནང་འཇུག་དང་ཕྱིར་ལོག་བྱ་བའི་ལས་འགན་ཞིག་བྲིས་ཤིག\/\/\/ >>> specialFilter(vec![15, -73, 14, -15])\n\/\/\/ 1\n\/\/\/ >>> specialFilter(vec![33, -2, -3, 45, 21, 109])\n\/\/\/ 2\nfn specialFilter(nums: Vec<isize>) -> isize {\n","canonical_solution":"fn specialFilter(nums: Vec<isize>) -> isize {\n    nums.into_iter().filter(|&num| {\n        let abs_num = num.abs();\n        abs_num > 10 && {\n            let digits: Vec<u8> = abs_num.to_string().bytes().map(|b| b - b'0').collect();\n            let first_digit = digits.first().unwrap();\n            let last_digit = digits.last().unwrap();\n            first_digit % 2 == 1 && last_digit % 2 == 1\n        }\n    }).count() as isize\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result1 = specialFilter(vec![15, -73, 14, -15]);\n\/\/     println!(\"{}\", result1); \/\/ Output: 1\n\n\/\/     let result2 = specialFilter(vec![33, -2, -3, 45, 21, 109]);\n\/\/     println!(\"{}\", result2); \/\/ Output: 2\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = specialFilter;\n    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);\n    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);\n    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);\n    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);\n    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n}\n"},{"task_id":"HumanEval_147","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/a[i] + a[j] + a[k] ནི་ 3 ཀྱི་ལྡབ་གྲངས་ཡིན།\/\/\/ a ནང་གི་གསུམ་ལྡོག་གྲངས་ (a[i], a[j], a[k]) ཕྱིར་ལོག་བྱེད་ཅིང་། དེར་ i < j < k, \/\/= i (i+1) ཟེར་བའི་གྲངས་ཐང་ i (i+1) = i (i+1) ཟེར་བའི་གྲངས་ཐང་ཡིན་པའི་ངེས་དོན་ཡོད།\/\/ཁྱོད་ཀྱིས་གྲངས་ཆ་ཚིམས་ n ཞིག་ཐོབ་ཡོད། ཁྱོད་ཀྱིས་གྲངས་ཆ་ཚིམས་ vector a ཡི་རིང་ཚད་ n བཟོ་དགོས།\/\/\/ >>> get_max_triples(5)\n\/\/\/ 1\n\/\/\/ Explanation: \n\/\/\/ a = [1, 3, 7, 13, 21]\n\/\/\/ The only valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n","canonical_solution":"fn get_max_triples(n: isize) -> isize {\n    let mut a = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    \n    let mut count = 0;\n    for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n                    count += 1;\n                }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    println!(\"{}\", get_max_triples(5)); \/\/ Output: 1\n}","tests":"}\n\nfn main() {\n    let candidate = get_max_triples;\n    assert_eq!(candidate(5), 1);\n    assert_eq!(candidate(6), 4);\n    assert_eq!(candidate(10), 36);\n    assert_eq!(candidate(100), 53361);\n}\n"},{"task_id":"HumanEval_149","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/ཚད་གཞི་འདི་ནི་ཚིག་ཡིག་ཚང་མ་འདྲ་མཉམ་ཡིན་པར་ངེས་པ་རེད་འདུག\/\/\/ ལས་འགན་འདི་ནི་རིམ་བཞིན་རིམ་བཞིན་གྱི་ string ཀྱི་བེ་ཊར་ཕྱིར་ལོག་བྱེད་དགོས།\/\/\/ གལ་ཏེ་ཚིག་གཉིས་རིང་ཚད་འདྲ་མཚུངས་ཡིན་ན། ཝི་ཅཊ་རིར་ཨལ་ཕེབ་ཊི་རིམ་སྒྲིག་དགོས།\/\/\/ འདི་ལ་གཞི་གྲངས་དེ་ནས་རིམ་སྒྲིག་བྱས་པའི་ ཝི་ཅཊ་ལོག་འཇུག་དགོས།\/\/ཚད་གཞི་རིམ་པའི་རིམ་པ་ནི་ཚིག་རེ་རེ་བཞིན་ཡར་འཕོ་འགྱུར་བཞིན་ཡོད་ལ།\/\/\/ འདི་ནང་འདྲ་བཤུས་ཡང་ཡོད་སྲིད་རེད།\/\/ཕྲེང་བ་ནི་གཏན་ནས་ཕྲེང་བ་ཞིག་ཡིན་ཏེ། གྲངས་ཀྱི་ཕྲེང་བ་ཞིག་ནམ་ཡང་མ་ཡིན།\/\/འབྲས་བུ་ནི་རིམ་པ་བཞིན་ཡོད་པ།\/\/\/ འདི་ནས་རིང་ཚད་རྣམ་རྟོག་མེད་པའི་ཡིག་འབྲུ་དག་སེལ་བ། \/\/\/ ལས་འགན་ཞིག་བྲིས་ནས་ ཚད་གཞིའི་རིམ་པ་ལྟར་ string གྱི་བེ་ཊར་ངོས་ལེན་བྱེད་པ།\/\/\/ >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")])\n\/\/\/ vec![String::from(\"aa\")]\n\/\/\/ >>> list_sort(vec![String::from(\"ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n\/\/\/ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    let mut even_length_strings: Vec<String> = lst\n        .into_iter()\n        .filter(|s| s.len() % 2 == 0)\n        .collect();\n    \n    even_length_strings.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));\n    \n    even_length_strings\n}\n\nfn main() {\n    let result = sorted_list_sum(vec![\n        String::from(\"aa\"),\n        String::from(\"a\"),\n        String::from(\"aaa\"),\n    ]);\n    println!(\"{:?}\", result); \/\/ Should print: [\"aa\"]\n\n    let result = sorted_list_sum(vec![\n        String::from(\"ab\"),\n        String::from(\"a\"),\n        String::from(\"aaa\"),\n        String::from(\"cd\"),\n    ]);\n    println!(\"{:?}\", result); \/\/ Should print: [\"ab\", \"cd\"]\n}","tests":"}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]), vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"bbbb\")]);\n}\n"},{"task_id":"HumanEval_150","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ དེ་སྔོན་གྲངས་དང་ y གི་ཐང་ཕྱིར་ལོག་བྱེད་དགོས། དེ་མིན་\/\/སྟབས་བདེ་བའི་ལས་རིམ་ཤིག་སྟེ། གལ་ཏེ་ n ནི་ ཡིན་ན་ x གི་ཐང་ཕྱིར་ལོག་བྱེད་པ།\/\/\/ >>> x_or_y(7, 34, 12)\n\/\/\/ 34\n\/\/\/ >>> x_or_y(15, 8, 5)\n\/\/\/ 5\nfn x_or_y(n: isize, x: isize, y: isize) -> isize {\n","canonical_solution":"fn x_or_y(n: isize, x: isize, y: isize) -> isize {\n    fn is_prime(num: isize) -> bool {\n        if num <= 1 {\n            return false;\n        }\n        for i in 2..=((num as f64).sqrt() as isize) {\n            if num % i == 0 {\n                return false;\n            }\n        }\n        true\n    }\n    \n    if is_prime(n) {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    println!(\"{}\", x_or_y(7, 34, 12)); \/\/ Output: 34\n    println!(\"{}\", x_or_y(15, 8, 5)); \/\/ Output: 5\n}","tests":"}\n\nfn main() {\n    let candidate = x_or_y;\n    assert_eq!(candidate(7, 34, 12), 34);\n    assert_eq!(candidate(15, 8, 5), 5);\n    assert_eq!(candidate(3, 33, 5212), 33);\n    assert_eq!(candidate(1259, 3, 52), 3);\n    assert_eq!(candidate(7919, -1, 12), -1);\n    assert_eq!(candidate(3609, 1245, 583), 583);\n    assert_eq!(candidate(91, 56, 129), 129);\n    assert_eq!(candidate(6, 34, 1234), 1234);\n    assert_eq!(candidate(1, 2, 0), 0);\n    assert_eq!(candidate(2, 2, 0), 2);\n}\n"},{"task_id":"HumanEval_151","nl":"bod_Tibt","pl":"rs","prompt":"\/\/སྐར་ཆའི་ནང་གྲངས་ཆ་མེད་ཡིན་ན། སྐར་ཆའི་ནང་གྲངས་ཆ་མེད་ཡིན་ན་གྲངས་ཆ་མེད་ཡིན་པར་བརྩི་མེད་བྱ་དགོས།\/\/\/ གྲངས་ཀྱི་བེ་ཊར་ཞིག་ཡོད་ན། གྲངས་ཀྱི་གྲུ་བཞི་གི་བསྡོམས་གྲངས་ཕྱིར་ལོག་བྱེད་པ།\/\/\/ >>> double_the_difference(vec![1, 3, 2, 0])\n\/\/\/ 10\n\/\/\/ >>> double_the_difference(vec![-1, -2, 0])\n\/\/\/ 0\n\/\/\/ >>> double_the_difference(vec![9, -2])\n\/\/\/ 81\n\/\/\/ >>> double_the_difference(vec![0])\n\/\/\/ 0\n\/\/\/ If the input vector is empty, return 0.\nfn double_the_difference(lst: Vec<f64>) -> isize {\n","canonical_solution":"fn double_the_difference(lst: Vec<f64>) -> isize {\n    lst.iter()\n        .filter(|&&x| x.fract() == 0.0 && x > 0.0 && x as isize % 2 != 0)\n        .map(|&x| (x as isize).pow(2))\n        .sum()\n}\n\nfn main() {\n    println!(\"{}\", double_the_difference(vec![1.0, 3.0, 2.0, 0.0])); \/\/ 10\n    println!(\"{}\", double_the_difference(vec![-1.0, -2.0, 0.0])); \/\/ 0\n    println!(\"{}\", double_the_difference(vec![9.0, -2.0])); \/\/ 81\n    println!(\"{}\", double_the_difference(vec![0.0])); \/\/ 0\n    println!(\"{}\", double_the_difference(vec![])); \/\/ 0\n}","tests":"}\n\nfn main() {\n    let candidate = double_the_difference;\n    assert_eq!(candidate(Vec::<f64>::new()), 0);\n    assert_eq!(candidate(vec![5.0, 4.0]), 25);\n    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);\n    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);\n    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);\n    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);\n    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);\n}\n"},{"task_id":"HumanEval_152","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་ཆ།: \/\/ཚད་ནི་ 0 ཡིན་པ་དང་། གལ་ཏེ་དེ་ 0 ཡིན་ན་ཚད་ནི་དཔེར་བརྗོད་དང་ཐིག་ཁྲམ་གཉིས་ཀྱི་བར་གྱི་ཁྱད་པར་གཏན་ལ་ཕབ་པ་ཡིན།\/\/ཚད་གཞི་འདྲ་མཉམ་གྱི་བེ་ཊར་ཕྱིར་ལོག་བྱེད་དེ། ཚོད་དཔག་གང་ཙམ་ཐག་རིང་པོ་ཡིན་པར་མཚོན་པ་ཡིན། གལ་ཏེ་ཁོ་ཚོས་ཚོད་དཔག་དྲང་པོ་བྱས་ཡོད་ན། \/\/ཚད་གཞི་དང་ཚོད་དཔག་ཚད་འདྲ་མཉམ་གྱི་ ཚད་གཞི་གཉིས་གནང་ཡོད། ཚད་གཞི་རེ་རེར་ཆ་མཐུན་ཡོད།\/\/ཤོག་གྲངས་དང་མཚུངས་པའི་ ཚོད་རྩིས་ཀྱི་གྲུབ་འབྲས་དེ་བདེན་མིན་ལ་བརྟག་དཔྱད་བྱེད་དགོས།\/\/\/ འདྲ་བཤུས་དང་བསྡུར་བྱེད་འོས་པ་ཞིག་རེད།\/\/བྱུང་རིམ་དེ་མཇུག་ཏུ་ཤེས་རྟོགས་བྱུང་ཡོད། དེ་དུས་ཁྱེད་རང་ཚོར་བའི་ཚོར་སྣང་དང་བསམ་བློ་ནི་\/\/རྒྱུན་ཆད་མེད་པར་རེ་བ་ཆེན་པོ་ཡོད་པས་དུས་ཀྱི་འབྲས་བུར་ཐུག་སྐབས་ཀྱི་ཚོར་བ་དེ་ང་ཚོ་ཚང་མས་དྲན་གྱི་རེད།\/\/\/ >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])\n\/\/\/ vec![0, 0, 0, 0, 3, 3]\n\/\/\/ >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])\n\/\/\/ vec![4, 4, 1, 0, 0, 6]\nfn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n    game.iter()\n        .zip(guess.iter())\n        .map(|(g, gss)| (g - gss).abs())\n        .collect()\n}\n\nfn main() {\n    let result1 = compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]);\n    let result2 = compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2]);\n    println!(\"{:?}\", result1); \/\/ Output: [0, 0, 0, 0, 3, 3]\n    println!(\"{:?}\", result2); \/\/ Output: [4, 4, 1, 0, 0, 6]\n}","tests":"}\n\nfn main() {\n    let candidate = compare;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);\n    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);\n    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);\n    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);\n}\n"},{"task_id":"HumanEval_153","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/\/ (དེའི་ཤུགས་ནི་ -༡) ཡིན།\/\/\/ return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension  'Slices.SErviNGSliCes' is the strongest extension  'Slices.SErviNGSliCes' is the strongest extension  'Slices.SErviNGSliCes' is the strongest extension  'Slices.SErviNGSliCes' is the strongest extension  'Slices.SErviNGSliCes' is the strongest extension  'Slices.SErviNGSliCes' is the strongest extension  'Slices.SErviNGSliCes' is the strongest extension \/\/\/ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] བྱས་ན་ཁྱེད་ཀྱིས་ \/\/དཔེར་ན་ \"Slices\" ཟེར་བ་འདི་ class དང་ vector ཟེར་བའི་གྲངས་སུ་ཡོད་ན།\/\/སྐར་ཁུང་གི་དྲ་ངོས་ནས་ སྐར་ཁུང་གི་དྲ་ངོས་སུ་ཐོག་མར་ཐོན་པ་འདེམས་དགོས།\/\/གལ་ཏེ་ནུས་པ་འདྲ་མཚུངས་ཡོད་པའི་ extension གཉིས་སམ་དེ་ལས་མང་བ་ཡོད་ན། ཁྱོད་ཀྱིས་\/\/\/ format: ClassName.StrongestExtensionName.  ཚད་ལྡན་མིང་གི་གོ་རིམ་\/\/ཁྱོད་ཀྱིས་ཤུགས་ཆེ་ཤོས་ཀྱི་ extension འཚོལ་ནས་ string ནང་འཇུག་བྱ་དགོས།\/\/\/ སྦྱོར་བའི་མིང་གི་ནང་། ཤུགས་ཚད་ CAP-SM ཟེར་བ་ལས་གྲུབ་པ་ཡིན།\/\/\/ ཡིག་འབྲུ་ extension མིང་གི་ནང་ SM ནི་ཡིག་ཆུང་གི་གྲངས་ཀ་ཡིན་པར་བྱའོ།\/\/\/ རྒྱས་འགྲེལ་གྱི་ནུས་པ་འདི་འདྲ་ཡིན། CAP ནི་ཡིག་འབྲུ་ཆེན་པོའི་གྲངས་ཀ་ཡིན་པར་བྱའོ།\/\/\/ རྒྱས་འགྲེལ། ཚད་འཛིན་གྱི་ལག་ལེན་ནི་སློབ་ཚན་ནང་ལྷག་པའི་སློབ་ཚན་བཀོལ་སྤྱོད་བྱེད་རྒྱུ་ཡིན།\/\/ཚད་གཞི་ (string) དང་ (extension) གྱི་བེ་ཊར་ (vector) ཞིག་ཐོབ་ཐུབ།\/\/\/ >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n\/\/\/ String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n","canonical_solution":"fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let mut strongest_extension = String::new();\n    let mut max_strength = i32::MIN;\n\n    for extension in extensions {\n        let cap_count = extension.chars().filter(|c| c.is_uppercase()).count() as i32;\n        let sm_count = extension.chars().filter(|c| c.is_lowercase()).count() as i32;\n        let strength = cap_count - sm_count;\n\n        if strength > max_strength {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    format!(\"{}.{}\", class_name, strongest_extension)\n}","tests":"}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"},{"task_id":"HumanEval_154","nl":"bod_Tibt","pl":"rs","prompt":"\/\/ཁྱོད་ཀྱིས་ཚིག་གཉིས་ཐོབ་ཡོད། གལ་ཏེ་ཚིག་གཉིས་པ་ཡང་ན་དེའི་འཁོར་བ་གང་ཞིག་ནི་ཚིག་དང་པོའི་ནང་གི་འོག་རིམ་ཡིན་ན་ true སླར་ལོག་བྱེད་དགོས་པ་ཡིན།\/\/\/ >>> cycpattern_check(String::from(\"abcd\"), String::from(\"abd\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"hello\"), String::from(\"ell\"))\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(String::from(\"whassup\"), String::from(\"psus\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"abab\"), String::from(\"baa\"))\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(String::from(\"efef\"), String::from(\"eeff\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"himenss\"), String::from(\"simen\"))\n\/\/\/ true\nfn cycpattern_check(a: String, b: String) -> bool {\n","canonical_solution":"fn cycpattern_check(a: String, b: String) -> bool {\n    let len_b = b.len();\n    if len_b == 0 {\n        return true;\n    }\n    let doubled_b = b.clone() + &b;\n    for i in 0..len_b {\n        if let Some(sub) = doubled_b.get(i..i + len_b) {\n            if a.contains(sub) {\n                return true;\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = cycpattern_check;\n    assert_eq!(candidate(String::from(\"xyzw\"), String::from(\"xyw\")), false);\n    assert_eq!(candidate(String::from(\"yello\"), String::from(\"ell\")), true);\n    assert_eq!(candidate(String::from(\"whattup\"), String::from(\"ptut\")), false);\n    assert_eq!(candidate(String::from(\"efef\"), String::from(\"fee\")), true);\n    assert_eq!(candidate(String::from(\"abab\"), String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"winemtt\"), String::from(\"tinem\")), true);\n}\n"},{"task_id":"HumanEval_155","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/\/ ཨང་གྲངས་ཧྲིལ་པོ་ཡོད་ན། ཕྲེང་བ་གཉིས་དང་ཕྲེང་བ་གཉིས་ཡོད་པའི་ཨང་གྲངས་སླར་ལོག་བྱེད།\/\/\/ >>> even_odd_count(-12)\n\/\/\/ (1, 1)\n\/\/\/ >>> even_odd_count(123)\n\/\/\/ (1, 2)\nfn even_odd_count(num: isize) -> (isize, isize) {\n","canonical_solution":"fn even_odd_count(num: isize) -> (isize, isize) {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n    let num_str = num.abs().to_string();\n    \n    for ch in num_str.chars() {\n        if let Some(digit) = ch.to_digit(10) {\n            if digit % 2 == 0 {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n    \n    (even_count, odd_count)\n}","tests":"}\n\nfn main() {\n    let candidate = even_odd_count;\n    assert_eq!(candidate(7), (0, 1));\n    assert_eq!(candidate(-78), (1, 1));\n    assert_eq!(candidate(3452), (2, 2));\n    assert_eq!(candidate(346211), (3, 3));\n    assert_eq!(candidate(-345821), (3, 3));\n    assert_eq!(candidate(-2), (1, 0));\n    assert_eq!(candidate(-45347), (2, 3));\n    assert_eq!(candidate(0), (1, 0));\n}\n"},{"task_id":"HumanEval_156","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ཚད་འཛིན་: 1 <= num <= 1000\/\/\/ ཆེ་ཆུང་ཡིག་གཟུགས་ནང་ཕྱིར་ལོག་བྱེད་པ།\/\/\/ འབྲས་བུ་ལྡན་གྲངས་ཤིག་ཡོད་ན། རོམ་གྲངས་ཀྱི་འདྲ་མཚུངས་དེ་ཐིག་ཡིག་ལྟར་ལེན་དགོས། \/\/\/ >>> int_to_mini_roman(19)\n\/\/\/ String::from(\"xix\")\n\/\/\/ >>> int_to_mini_roman(152)\n\/\/\/ String::from(\"clii\")\n\/\/\/ >>> int_to_mini_roman(426)\n\/\/\/ String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n","canonical_solution":"fn int_to_mini_roman(mut number: isize) -> String {\n    let roman_numerals = [\n        (1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n        (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n        (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"),\n        (1, \"i\"),\n    ];\n    \n    let mut result = String::new();\n    \n    for &(value, symbol) in roman_numerals.iter() {\n        while number >= value {\n            number -= value;\n            result.push_str(symbol);\n        }\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"},{"task_id":"HumanEval_157","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/ཚད་མ་ ༩༠ ཙམ་ཡོད།\/\/ཟུར་གསུམ་ཟུར་དྲང་པོ་ནི་ཟུར་གསུམ་གྱི་ཟུར་གཅིག་ཟུར་དྲང་པོ་ཡིན་པའམ། ཡང་ན་\/\/\/ ཕྱོགས་རྣམས་ཟུར་དྲང་གསུམ་གྱི་དབྱིབས་ཡིན་ན། འདྲ་མིན་ལ་རྫུན་ཡིན།\/\/ཚད་གསུམ་གྱི་ཟུར་གསུམ་གྱི་རིང་ཚད་ཡོད་ན། true སླར་ལོག་བྱེད།\/\/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/\/ true\n\/\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/\/ false\nfn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n","canonical_solution":"fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n    let mut sides = [a, b, c];\n    sides.sort_unstable();\n\n    let [x, y, z] = sides;\n    x * x + y * y == z * z\n}","tests":"}\n\nfn main() {\n    let candidate = right_angle_triangle;\n    assert_eq!(candidate(3, 4, 5), true);\n    assert_eq!(candidate(1, 2, 3), false);\n    assert_eq!(candidate(10, 6, 8), true);\n    assert_eq!(candidate(2, 2, 2), false);\n    assert_eq!(candidate(7, 24, 25), true);\n    assert_eq!(candidate(10, 5, 7), false);\n    assert_eq!(candidate(5, 12, 13), true);\n    assert_eq!(candidate(15, 8, 17), true);\n    assert_eq!(candidate(48, 55, 73), true);\n    assert_eq!(candidate(1, 1, 1), false);\n    assert_eq!(candidate(2, 2, 10), false);\n}\n"},{"task_id":"HumanEval_158","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ ཡིག་འབྲུ་ནང་། ཚིག་མཛོད་དང་པོ་ནས་ཨང་རིམ་དང་པོ་ལ་འཇུག་པ།\/\/གལ་ཏེ་ string མང་པོ་ཡོད་ན་ unique  ཀྱི་གྲངས་མང་ཤོས་ཡོད་ན་\/\/སྐར་ཁུང་ནང་ཚིག་ཡིག་སྣ་ཚོགས་ཡོད། ཆེ་མཐོའི་གྲངས་ཀ་ཡོད་པའི་ཚིག་ཡིག་ཕྱིར་ལོག་བྱོས།\/\/\/ ཡིག་རྟགས་ཀྱི་ཕྲེང་བ་ལེན་པའི་ལས་འགན་ཞིག་བྲིས་ཤིག\/\/\/ >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n\/\/\/ String::from(\"string\")\n\/\/\/ >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n\/\/\/ String::from(\"enam\")\n\/\/\/ >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n\/\/\/ String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n","canonical_solution":"fn find_max(words: Vec<String>) -> String {\n    fn unique_char_count(s: &str) -> usize {\n        let mut chars: std::collections::HashSet<char> = std::collections::HashSet::new();\n        for c in s.chars() {\n            chars.insert(c);\n        }\n        chars.len()\n    }\n\n    words\n        .into_iter()\n        .max_by(|a, b| {\n            let count_a = unique_char_count(a);\n            let count_b = unique_char_count(b);\n            count_a.cmp(&count_b).then_with(|| a.cmp(b))\n        })\n        .unwrap()\n}","tests":"}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n"},{"task_id":"HumanEval_159","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས།: \/\/གལ་ཏེ་མར་ག་ལྷག་མ་ཡོད་ན་ ཟས་མ་ཚར་བར་མུ་གེ་ལུས་ཀྱང་ཟ་ཆོག\/\/ཟ་ཚར་རྗེས་ལུས་པའི་ཤིང་འབྲས་ཀྱི་གྲངས་ཀ་ལ།\/\/\/ ཟས་རྗེས། བག་ལེབ་ཟ་བའི་གྲངས་འབོར་གྱི་རྩིས་གཞི་ [ ཟས་རྗེས། བག་ལེབ་ཟ་བའི་གྲངས་འབོར་གྱི་རྩིས་གཞི་] ཕྱིར་ལོག་བྱེད་དགོས།\/\/ད་ལྟའི་ཟས་རེའི་ནང་ག་ག་མང་ཟ་དགོས་ཀྱི་འདུག\/\/ཁྱོད་ནི་ལྟོ་བ་ཡོད་པའི་བེའུ་ཞིག་རེད། ཁྱོད་ཀྱིས་ག་རེར་ག་རེར་ཟ་ཚར་ཡོད།\/\/\/ >>> eat(5, 6, 10)\n\/\/\/ vec![11, 4]\n\/\/\/ >>> eat(4, 8, 9)\n\/\/\/ vec![12, 1]\n\/\/\/ >>> eat(1, 10, 10)\n\/\/\/ vec![11, 0]\n\/\/\/ >>> eat(2, 11, 5)\n\/\/\/ vec![7, 0]\n\/\/\/ Variables:\n\/\/\/ @number : integer\n\/\/\/ the number of carrots that you have eaten.\n\/\/\/ @need : integer\n\/\/\/ the number of carrots that you need to eat.\n\/\/\/ @remaining : integer\n\/\/\/ the number of remaining carrots thet exist in stock\n\/\/\/ Constrain:\n\/\/\/ * 0 <= number <= 1000\n\/\/\/ * 0 <= need <= 1000\n\/\/\/ * 0 <= remaining <= 1000\n\/\/\/ Have fun :)\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n","canonical_solution":"fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let to_eat = if need <= remaining { need } else { remaining };\n    vec![number + to_eat, remaining - to_eat]\n}","tests":"}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"},{"task_id":"HumanEval_160","nl":"bod_Tibt","pl":"rs","prompt":"\/\/འབྲེལ་བའི་ལག་ལེན་པའི་ལག་ལེན་པ་ཞིག་ལ་ཉུང་མཐར་ལག་ལེན་པ་གཅིག་ཡོད་པ་དང་ འབྲེལ་བའི་ལག་ལེན་པའི་ལག་ལེན་པའི་ལག་ལེན་པ་གཉིས་ཡོད་པ།\/\/སྦྱར་བའི་གྲངས་ནི་ འབྲས་བུ་མེད་པའི་གྲངས་ཀྱི་ ཕྲེང་བ་ཡིན།\/\/སྐར་ཆའི་རིང་ཚད་ནི་སྐར་ཆའི་རིང་ཚད་དང་མཚུངས་པ་ཡིན།\/\/\/ དྲན་གསོ།: \/\/= = = གྲུབ་འབྲས་ = 9\/\/\/ གྲུབ་འབྲས་ = 2 + 3 * 4 - 5 \/\/\/ vector = [2, 3, 4, 5] \/\/\/ ལས་འཛིན་པ་['+', '*', '-'] \/\/\/ དཔེ་གཟིགས།: \/\/\/ གྱངས་ཁ་རྩིས་རྒྱག་ (**) བྱེད་པ།\/\/\/ ཐོག་གི་ས་ཁུལ་ ( \/\/ ) \/\/\/ གྱངས་ཁ་ (*) དང་།\/\/\/ ཕྱིར་འདོན་ ( - ) བྱེད་པ།\/\/\/ སྦྱོར་བ། (+) \/\/\/ གཞི་རིམ་ཨལ་ཇི་བིར་གྱི་བྱ་གཞག: \/\/ཚད་གཞི་དང་ཚད་གཞི་སླར་ལོག་བྱེད།\/\/སྐར་ཆ་གཉིས་པ་ནི་གྲངས་ཆ་ཧྲིལ་པོ་གི་སྐར་ཆ་ཡིན། སྐར་ཆ་གཉིས་པ་བེད་སྤྱོད་བྱས་ནས་ཨང་གྲངས་རྩིས་རྒྱག་དགོས།\/\/སྐར་ཆ་གཉིས་ལ་སྤྱོད་འཇུག་པ་དང་སྤྱོད་འཇུག་པ་གཉིས་ཡོད། སྐར་ཆ་དང་པོ་ལ་གཞི་རྟེན་ཨལ་ཇི་བིར་གྱི་སྤྱོད་འཇུག་ཡོད་ལ། སྐར་ཆ་དང་པོ་ལ་གཞི་རྟེན་ཨལ་ཇི་བིར་གྱི་སྤྱོད་འཇུག་ཡོད་ལ།fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n","canonical_solution":"fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n    let mut result = operand[0];\n    \n    for i in 0..operator.len() {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i+1],\n            \"-\" => result -= operand[i+1],\n            \"*\" => result *= operand[i+1],\n            \"\/\/\" => result \/= operand[i+1],\n            \"**\" => result = result.pow(operand[i+1] as u32),\n            _ => panic!(\"Unexpected operator\"),\n        }\n    }\n    \n    result\n}\n\nfn main() {\n    let operators = vec![\"+\",\"*\",\"-\"].iter().map(|s| s.to_string()).collect();\n    let operands = vec![2, 3, 4, 5];\n    let result = do_algebra(operators, operands);\n    println!(\"Result: {}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = do_algebra;\n    assert_eq!(candidate(vec![String::from(\"**\"), String::from(\"*\"), String::from(\"+\")], vec![2, 3, 4, 5]), 37);\n    assert_eq!(candidate(vec![String::from(\"+\"), String::from(\"*\"), String::from(\"-\")], vec![2, 3, 4, 5]), 9);\n    assert_eq!(candidate(vec![String::from(\"\/\/\"), String::from(\"*\")], vec![7, 3, 4]), 8);\n}\n"},{"task_id":"HumanEval_161","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཟིགས། \/\/\/ ལས་འགན་འདི་ནས་ཐིག་ལེ་ཐོན་པའི་འབྲས་བུ་ཕྱིར་ལོག་བྱ་དགོས།\/\/གལ་ཏེ་ string ནང་ཡི་གེ་མེད་ན་ string ལ་རྒྱབ་སྒྱུར་བྱོས།\/\/\/ དེ་མིན་དེ་འདྲ་བཞག་ན་ཡག་པོ་རེད།\/\/\/ s[i] ནི་ཡི་གེ་ཡིན་ན། དེའི་ཡིག་གཟུགས་འོག་ནས་གོང་དུ་སྒྱུར་བ། ཡང་ན་རྒྱབ་ཕྱོགས་ལ་བསྒྱུར་བ།\/\/ཤོག་ངོས་འདི་ཡི་བཟོ་བཅོས་མཐའ་མ་༢༩༩༩ ལ་རེད།\/\/\/ >>> solve(String::from(\"1234\"))\n\/\/\/ String::from(\"4321\")\n\/\/\/ >>> solve(String::from(\"ab\"))\n\/\/\/ String::from(\"AB\")\n\/\/\/ >>> solve(String::from(\"#a@C\"))\n\/\/\/ String::from(\"#A@c\")\nfn solve(s: String) -> String {\n","canonical_solution":"fn solve(s: String) -> String {\n    if s.chars().all(|c| !c.is_alphabetic()) {\n        s.chars().rev().collect()\n    } else {\n        s.chars()\n            .map(|c| {\n                if c.is_lowercase() {\n                    c.to_ascii_uppercase()\n                } else if c.is_uppercase() {\n                    c.to_ascii_lowercase()\n                } else {\n                    c\n                }\n            })\n            .collect()\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n"},{"task_id":"HumanEval_162","nl":"bod_Tibt","pl":"rs","prompt":"\/\/གལ་ཏེ་ 'text' ནི་སྟོང་པ་ན་ None སླར་ལོག་བྱེད།\/\/\/ string 'text' ཤིག་ཡོད་ན། md5 ཧེཤི་འདྲ་མཉམ་གྱི་ string དེ་ཕྱིར་སློག་བྱེད་དགོས།\/\/\/ >>> string_to_md5(String::from(\"Hello world\"))\n\/\/\/ Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\"))\nfn string_to_md5(text: String) -> Option<String> {\n","canonical_solution":"use md5;\n\nfn string_to_md5(text: String) -> Option<String> {\n    if text.is_empty() {\n        return None;\n    }\n    let digest = md5::compute(text);\n    Some(format!(\"{:x}\", digest))\n}","tests":"}\n\nfn main() {\n    let candidate = string_to_md5;\n    assert_eq!(candidate(String::from(\"Hello world\")), Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\")));\n    assert_eq!(candidate(String::from(\"\")), None);\n    assert_eq!(candidate(String::from(\"A B C\")), Some(String::from(\"0ef78513b0cb8cef12743f5aeb35f888\")));\n    assert_eq!(candidate(String::from(\"password\")), Some(String::from(\"5f4dcc3b5aa765d61d8327deb882cf99\")));\n}\n"},{"task_id":"HumanEval_163","nl":"bod_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་གཞི་: \/\/\/དང་ b སྟེང་ནས་ཡར་འགྲོ་བཞིན་ཡོད།\/\/འབྲས་བུ་ཆ་མཉམ་ a དང་ b གཉིས་ཡོད་ན། a དང་ b བར་གྱི་གྲངས་ཆ་ཆ་མཚུངས་ཕྱིར་ལོག་བྱོས།\/\/\/ >>> generate_integers(2, 8)\n\/\/\/ vec![2, 4, 6, 8]\n\/\/\/ >>> generate_integers(8, 2)\n\/\/\/ vec![2, 4, 6, 8]\n\/\/\/ >>> generate_integers(10, 14)\n\/\/\/ Vec::<isize>::new()\nfn generate_integers(a: isize, b: isize) -> Vec<isize> {\n","canonical_solution":"fn generate_integers(a: isize, b: isize) -> Vec<isize> {\n    let (start, end) = if a < b { (a, b) } else { (b, a) };\n    (start..=end).filter(|&x| x % 2 == 0).collect()\n}\n\nfn main() {\n    let result1 = generate_integers(2, 8);\n    println!(\"{:?}\", result1); \/\/ Output: vec![2, 4, 6, 8]\n\n    let result2 = generate_integers(8, 2);\n    println!(\"{:?}\", result2); \/\/ Output: vec![2, 4, 6, 8]\n\n    let result3 = generate_integers(10, 14);\n    println!(\"{:?}\", result3); \/\/ Output: vec![10, 12, 14]\n}","tests":"}\n\nfn main() {\n    let candidate = generate_integers;\n    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(17, 89), Vec::<isize>::new());\n}\n"}]