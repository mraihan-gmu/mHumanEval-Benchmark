prompt,canonical_solution,test
"
def eat(number, need, remaining):
    """"""
    ⵏⴻⵛⵛⴰⵍ ⵏⴻⵜ ⴰⵛⵛⴻⵛⴰⵍ, ⴷⴻⵗ ⴰⵛⵛⴻⵛⴰⵍ ⵏⴻⵜ ⴰⵋⴻⵏ ⵏ ⵉⵛⴰⵔⴻⵜⴰⵏ, ⵎⴰⵛⴰⵏ ⴷⴰⵔⵂⴰ ⴰⴷ ⴰⵛⴻⵛ ⴰⵋⴻⵏ ⵏ ⵉⵛⴰⵔⴻⵜⴰⵏ ⵉ ⴰⴷ ⴰⴾⴻⵜⴻⵏ ⴰⵍⵛⵉⵎⴰⵜⴻⵏ ⵏ ⴰⵛⴰⵍ. ⴰⴷ ⵉⴾⴼⴻⵜ ⴰⵔⵉ ⵏ [ ⴰⵋⴻⵏ ⵏ ⵉⵛⴰⵔⴻⵜⴰⵏ ⵓⵉ ⴰⵛⵛⴻⵛⴰⵍⵏⴻⵏ ⴷⴰⵔⴰⵜ ⴰⵍⵛⵉⵎⴰⵜⴻⵏ ⵏⴻⵜ, ⴰⵋⴻⵏ ⵏ ⵉⵛⴰⵔⴻⵜⴰⵏ ⵓⵉ ⴰⵣⵣⴰⵔⴰⵏ ⴷⴰⵔⴰⵜ ⴰⵍⵛⵉⵎⴰⵜⴻⵏ ⵏⴻⵜ ] ⴰ ⴼⴰⵍ ⵓⴰⵔ ⵉⵍⵍⴻⵏ ⵉⵛⴰⵔⴻⵜⴰⵏ ⵓⵉ ⵉⵛⴰⵔⴻⵏ, ⴰⴷ ⴰⵛⴻⵛ ⴰⵋⴻⵏ ⵏ ⵉⵛⴰⵔⴻⵜⴰⵏ ⵓⵉ ⵉⵛⴰⵔⴻⵏ, ⵎⴰⵛⴰⵏ ⴰⴷ ⴰⵛⴻ
    """"""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

"
"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

"
"
def by_length(arr):
    """"""
    ⴳ ⵓⵙⵔⵔⵓⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴷⵙ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳⵔ 1 ⴷ 9 ⴳ ⵜⴰⵎⵎⵏⵜ, ⵙⵙⵓⴷⵙ ⴰⵙⵔⵔⵓⵙ ⵏ ⵓⵙⵔⵔⵓⵙ, ⴷ ⴷⴼⴼⵉⵔ ⴰⴷ ⵙⵙⵎⴷⵍ ⴽⵓ ⵓⵟⵟⵓⵏ ⵙ ⵢⵉⵙⵎ ⵏⵏⵙ ⵙⴳ ""ⵢⴰⵏ"", "" ⵙⵉⵏ"", "" ⴽⵕⴰⴹ"", "" ⴽⴽⵓⵥ"", "" ⵙⵎⵎⵓⵙ"", "" ⵚⴹⵉⵚ"", "" ⵙⴰ"", "" ⵙⵎⵎⵓⵙ"", "" ⵙⵎⵎⵓⵙ"", ""ⵜⴰⵎⵔⴰⵡ"". ⵙ ⵓⵎⴷⵢⴰ: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> ⵙⵙⵓⴷⵙ arr -> [1, 1, 2, 3, 4, 5, 8] -> ⵙⵙⵓⴷⵙ arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [""Eight"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One
    """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

"
"
def words_string(s):
    """"""
    ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵜⵜⵓⵢⴼⴼⵖⵏ ⵙ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵖⴷ ⵜⵉⴼⵔⴽⵉⵏ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴱⴹⵓ ⵜⵉⴽⵛⵓⵎⵏ ⵙ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⴳⵔⵔⴰⵢⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵙ ⵓⵎⴷⵢⴰ: words_string ((""ⵙⵍⵉⵎ, ⵉⵙⵎ ⵉⵏⵓ ⵢⵓⵏ"") == [""ⵙⵍⵉⵎ"", ""ⵙⵍⵉⵎ"", ""ⵉⵙⵎ"", ""ⵉⵙ"", ""ⵊⵓⵏ""] words_string ((""ⵢⴰⵏ, ⵙⵉⵏ, ⴽⵕⴰⴹ, ⴽⴽⵓⵥ, ⵙⵎⵎⵓⵙ, ⵚⴹⵉⵚ"") == [""ⵢⴰⵏ"", ""ⵙⵉⵏ"", "" ⴽⵕⴰⴹ"", ""ⴽⵓⵥ"", ""ⵎⵎⵓⵙ"", ""ⵚⴹⵉⵚ""]
    """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

"
"

def fizz_buzz(n: int):
    """"""ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵓⵎⴹⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵜⵜⴼⴼⵖ ⵓⵟⵟⵓⵏ 7 ⴳ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵥⵥⵉⵏ ⵏⵏⴰ ⵓⵔ ⵢⴰⴽⵙⵓⵍⵏ ⵙ 11 ⵏⵖⴷ 13.
    >>> fizz_buzz(50)
    0
    >>> fizz_buzz(78)
    2
    >>> fizz_buzz(79)
    3
    """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

"
"
def check_dict_case(dict):
    """"""
    ⵉⴳ ⴷⴰⵔⴽ ⵉⵙⵎⴽⵉⵍ, ⴷⴷⵔⵖ ⵜⵉⴷⵜ ⵎⴽ ⴳⴰⵏ ⴽⵓⵍⵍⵓ ⵉⵙⵍⴽⵉⵏ ⵜⵉⵙⵉⴹⴼⴰⵏ ⴳ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉ
    """"""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

"
"
def minPath(grid, k):
    """"""
    ⵉⵖ ⵏⴰⴽⴽⴰ ⵜⴰⵡⵔⵉⵔⵜ ⵙ N ⵜⵉⴼⵔⴽⵉⵏ ⴷ N ⵜⵉⵔⵙⴰⵍ (N >= 2) ⴷ ⴽⵓ ⵜⴰⵖⵔⴰⵙⵜ ⵏ ⵜⴱⵔⵉⴷⵜ ⴷⴰⵔⵙ ⵢⴰⵏ ⵡⴰⵜⵉⴳ. ⴽⵓ ⵜⴰⵖⵔⴰⵙⵜ ⴳ ⵓⵎⵏⵉⴷ [1, N * N] ⵉⵍⵍⴰ ⴽⵓ ⵢⴰⵏ ⴳ ⵡⴰⵜⵉⴳⵏ ⴳ ⵜⴱⵔⵉⴷⵜ. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵏⴰⴼ ⴰⴱⵔⵉⴷ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵜⵉⵖⵣⵉ k ⴳ ⵜⴱⵔⵉⴷⵜ. ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⴱⴷⵓ ⵙⴳ ⴽⵓ ⵜⴰⵖⵔⴰⵙⵜ, ⴷ ⴳ ⴽⵓ ⵜⵉⴽⵍⵉⵜ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵣⵣⵉⴳⵉⵣⴷ ⵖⵔ ⴽⵓ ⵜⴰⵖⵔⴰⵙⵉⵏ ⵜⵉⵎⴰⴷⴷⵓⴽⴰⵍⵉⵏ, ⵙ ⵜⴳⵓⵔⵉ ⵢⴰⴹⵏ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵣⵣⵉⴳⵉⵣⴷ ⵖⵔ ⵜⴰⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⴷⴰⵔⵙ ⴰⴳⴰⴼ
    """"""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

"
"

def derivative(xs: list):
    """""" xs ⴷⴰ ⵉⵙⵎⴷⵢⴰ ⵉⵎⴳⴳⵉⵜⵏ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵡⵜⵜⴰ. xs[0] + xs[1] * x + xs[2] * x^2 +.... ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵜⴰⵢⴰⴼⵓⵜ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵡⵜⵜⴰ ⵙ ⵢⴰⵜ ⵜⴰⵍⵖⴰ.
    >>> derivative([3, 1, 2, 4, 5])
    [1, 4, 12, 20]
    >>> derivative([1, 2, 3])
    [2, 6]
    """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

"
"

def car_race_collision(n: int):
    """"""
    ⴰⴷⴰⵍⵉⵎⴰⵍ ⵉⵉⴰⴾⴰ ⵓⴰ ⵢⵈⴰⵍ ⴰⴱⴰⵔⴰ ⵓⴰ ⵓⴶⵓⴷ ⵓⴰⵔⴰⵏ ⵓⴶⵓⴷ. ⵏⴰⴾⴰⵍ ⴰⴾⴰⵉⴰⵏ ⵙⵓⵍⵓ ⵙⴰⵔⴰⵜ ⵙⴰⵎⴰⵍ ⵙ ⵙⴰⵎⴰⵍ; ⴷⴰⵗ ⴰⵍⵓⴰⵈ ⵉⵉⴰⵏ, ⵜⴰⵈⵈⵉⵎⵜ ⴰⵏ ⵏⴰⴾⴰⵍ ⴰⴾⴰⵉⴰⵏ ⵙⴰⵔⴰⵜ ⵙⴰⵎⴰⵍ ⵙ ⵙⴰⵎⴰⵍ. ⵙⴰⵏⴰⵜⴰⵜⴰⵜ ⵜⴰⵈⵈⵉⵎⵢⵏ ⴰⵏ ⵏⴰⴾⴰⵍ ⴰⵈⴰⵍⴰⵏ ⴰⵜⵉⵓⴰⵣⴰⵉⴰⵏ ⴷⴰⵗ ⴰⵋⴰⵎⴰ ⴰⵏ ⵜⴰⵔⵜⵉⵜ. ⴾⵓⵍ ⵏⴰⴾⴰⵍ ⴰⴾⴰⵉⴰⵏ ⵙⴰⵎⴰⵍ ⵙ ⵙⴰⵎⴰⵍ. ⵜⴰⵈⴰⵍ ⴰⴾⴰⵉⴰⵏ ⴰⵙ ⴰⴾⴰⵉⴰⵏ ⴰⵙ ⵜⴰⴾⴰⵉⴰⵜ ⵜⴰⴾⴰⵉⴰⵜ ⵜⴰ ⵜⴰⴾⴰⵉⴰⵜ ⵙⴰⵎⴰⵍ ⵙ ⵙⴰⵎⴰⵍ ⵜⴰⴾⴰⵉⴰⵜ ⵜⴰⴾⴰⵉⴰⵜ ⵙⴰⵎⴰⵍ. ⵎⴰⵛⴰⵏ, ⴰⴾⴰⵉ
    """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

"
"
def next_smallest(lst):
    """"""
    ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ next_smallest (() ⵏⵏⴰ ⵉⵙⴽⵔⵏ ⴰⵙⴽⴽⵉⵍ ⵡⵉⵙⵙ ⵙⵉⵏ ⴳ ⵜⵍⴳⴰⵎⵜ. ⴷⴰ ⵉⵜⵜⵔⴰⵔ None ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵓⵙⴽⴽⵉⵍ ⴰⴷ. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None
    """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" ⴳ ⵜⵍⴳⴰⵎⵜ ⵏ ⵡⵓⵟⵟⵓⵏ (ⵙ ⵡⴰⵜⵜⴰⵢⵏ ⵏ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ), ⵙⵙⵎⵔⵙⵏ ⵜⴰⵙⵏⴼⵍⵜ ⵜⴰⵣⵔⵉⵔⵜ ⴳ ⵜⵍⴳⴰⵎⵜ, ⴰⵢⵏⵏⴰ ⵉⴳⴰⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵥⵥⵢⴰⵏ ⴰⴷ ⵉⴳ 0 ⴷ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵇⵔⴰⵏ ⴰⴷ ⵉⴳ 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
"
"
def intersection(interval1, interval2):
    """"""ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵏⴱⵔⴰⵍⵏ, ⴳ ⴽⵓ ⵉⵏⴱⵔⴰⵍ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙ ⵓⵎⴷⵢⴰ, ⵉⵏⴱⵔⴰⵍ = (ⵜⴱⴷⴰⴷⵜ, ⵜⴳⵉⵔⴰ) = (1, 2). ⵉⵏⴱⵔⴰⵍⵏ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ ⴳⴰⵏ ⵉⵇⵇⵏⵏ, ⵎⴰⵢⴰⴷ ⵉⴳⴰⵏ ⵉⵙ ⴷⴰ ⵢⴰⵎⵓ ⵉⵏⴱⵔⴰⵍ (ⵜⴱⴷⴰⴷⵜ, ⵜⴳⵉⵔⴰ) ⴳ ⵜⵉⵣⵡⵉⵔⵉ ⴷ ⵜⴳⵉⵔⴰ. ⴳ ⴽⵓ ⵉⵏⴱⵔⴰⵍ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ, ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔ ⵎⴰⵙ ⵉⴳⴰ ⵓⵣⵡⵉⵔⵉ ⵏⵏⵙ ⵉⵎⵥⵥⵉⵢⵏ ⵏⵖⴷ ⵉⵎⵣⴷⴰⵢⵏ ⴷ ⵜⴳⵉⵔⴰ ⵏⵏⵙ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵏⵙⵙⵖⵓⴷⵓ ⵎⴰⵙⴷ ⵜⵉⵖⵣⵉ ⵏ ⵓⵙⵎⴽⵍ ⵏ ⵉⵏⴱⵔⴰⵍⵏ ⴰⴷ ⵙⵉⵏ ⵜⴳⴰ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ. ⴰⵎⴷⵢⴰ, ⴰⵙ
    """"""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

"
"

def monotonic(l: list):
    """"""Return True ⵉⴳⴰⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵜⵍⴳⴰⵎⵜ ⴷⴰ ⵙⵙⵓⴷⵓⵏ ⵙ ⵓⵖⵍⵉ ⵏⵖⴷ ⵙ ⵓⴷⵔⴰⵔ.
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

"
"
def digitSum(s):
    """"""ⵜⴰⵡⵓⵔⵉ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵢⴰⵜ ⵜⵎⵔⵙⵜ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵖⵕⴹⵉ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴰⴳⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴼⵍⵍⴰ ⴷⴰⵢ' ⵉⵙⴽⵉⴷⵏ ⵏ ASCII. ⵉⵎⴷⵢⴰⵜⵏ: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153
    """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

"
"
def right_angle_triangle(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return True if the three
    sides form a right-angled triangle, False otherwise.
    A right-angled triangle is a triangle in which one angle is right angle or 
    90 degree.
    Example:
    right_angle_triangle(3, 4, 5) == True
    right_angle_triangle(1, 2, 3) == False
    '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

"
"

def pairs_sum_to_zero(l):
    """"""
    ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ True ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ ⵉⵜⵜⴳⴳⴰⵏ ⴰⵎⵢⴰ, ⴷ False ⵎⴽ ⵓⵔ ⵉⴳⵉ.
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    False
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    False
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    False
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    True
    >>> pairs_sum_to_zero([1])
    False
    """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

"
"
def will_it_fly(q,w):
    '''
    Write a function that returns True if the object q will fly, and False otherwise.
    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.

    Example:
    will_it_fly([1, 2], 5) â -> False 
    # 1+2 is less than the maximum possible weight, but it's unbalanced.

    will_it_fly([3, 2, 3], 1) â -> False
    # it's balanced, but 3+2+3 is more than the maximum possible weight.

    will_it_fly([3, 2, 3], 9) â -> True
    # 3+2+3 is less than the maximum possible weight, and it's balanced.

    will_it_fly([3], 5) â -> True
    # 3 is less than the maximum possible weight, and it's balanced.
    '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

"
"

def incr_list(l: list):
    """"""ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵓⵙⵙⴰⵖⵓⵍ ⵙ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵙⵏⴼⵍⵏ ⵙ 1.
    >>> incr_list([1, 2, 3])
    [2, 3, 4]
    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [6, 4, 6, 3, 4, 4, 10, 1, 124]
    """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

"
"
def pluck(arr):
    """"""
    ""ⵙⴳ ⵓⵎⵙⴰⵙⴰ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏ ⵜⴰⴳⵓⵜ ⵏ ⵜⵙⴽⵍⴰ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⵓⵏⵖⵉⵍⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵃⵍⵉⵏ, ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵜⵔ ⵢⴰⵜ ⵜⵓⵏⵖⵉⵍⵜ ⴷ ⴰⴷ ⵜⵙⵙⴽⵜⵔ. ⵜⵓⵏⵖⵉⵍⵜ ⵏⵏⴰ ⵉⵜⵜⵓⵙⴽⵜⵔ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⴳ ⵜⵓⵏⵖⵉⵍⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⴰⵎⵎ ⵡⴰⴹ. ⵎⴽ ⵜⵜⵢⴰⴼⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵓⵏⵖⵉⵍⵉⵏ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⴰⵎⵎ ⵡⴰⴹ, ⵙⴽⵜⵔ ⵜⵓⵏⵖⵉⵍⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⴰⵎⵎ ⵡⴰⵜⵉⴳ. ⵜⵓⵏⵖⵉⵍⵜ ⵏⵏⴰ ⵉⵜⵜⵓⵙⴽⵜⵔ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⴽⵜⵔ ⴳ ⵜⵍⴳⴰ, [smallest_val
    """"""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

"
"
def histogram(test):
    """"""ⴰ ⴼⴰⵍ ⵉⵋⵋⴰ ⵙⵜⵔⵉⵏⴶ ⵢⵈⵈⴰⵍ ⵏ ⴰⵍⴾⵉⵜⵜⴰⴱⴰⵏ ⵓⵉ ⵎⴰⴷⵔⵓⵉⵏⵢⵏ ⵉⵋⵋⴰⵏⵢⵏ ⵜⵉⵣⵍⴰⵉⴰⵏ ⵙ ⵙⴱⵢⵛⵢⵔ, ⴰⴷ ⵢⵔⵢⵎ ⵢⴼⵢⵙ ⵏ ⴰⵍⴾⵉⵜⵜⴰⴱ ⵙ ⵉⵋⵋⵉⵜ ⵏ ⴰⵙⵉⵓⵉⵍ ⵜⵓⵍⴰⵙ ⵉⵍⴰ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⴰⵙⵉⵓⵉⵍ ⵓⴰ ⵉⵋⵋⴰⵏ ⴼⴰⵍ ⴰⵓⵢⵏ. ⴰ ⴼⴰⵍ ⵉⵍⴰⵏ ⴰⵍⴾⵉⵜⵜⴰⴱⴰⵏ ⴰⵋⵋⵓⵜⵏⵢⵏ ⵉⵍⴰⵏⵢⵏ ⵉⵋⵋⵉⵜ ⵓⵍⴰⵂⴰⵏ, ⴰⴷ ⵢⵔⵢⵎ ⴼⵓⴾ ⵏⴰⵙⴰⵏ ⴰⵍⵎⵉⵜⴰⵍ: ⵂⵉⵙⵜⵓⴶⵔⴰⵎ ((ⴰ ⴱ ⵛ) == {'ⴰ': 1, 'ⴱ': 1, 'ⵛ': 1} ⵂⵉⵙⵜⵓⴶⵔⴰⵎ ((ⴰ ⴱ ⴱ ⴱ ⴰ') == {'ⴰ': 2, 'ⴱ': 2} ⵂⵉⵙⵜⵓⴶⵔⴰⵎ ((ⴰ ⴱ ⵛ ⴰ ⴱ')

    """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

"
"

def fib4(n: int):
    """"""ⵜⴰⵍⵖⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ Fib4 ⵜⴳⴰ ⵜⴰⵍⵖⴰ ⵢⴰⴽⵙⵓⵍⵏ ⵉ ⵜⴰⵍⵖⴰ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ ⵓⵎⴽ ⴰⴷ: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). ⵔⵏⵉ ⵜⴰⵡⵓⵔⵉ ⵉ ⵓⵙⵉⵙⵙⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ fib4 ⵙ ⵢⴰⵜ ⵜⵖⴰⵔⴰⵙⵜ ⵉⴼⵓⵍⴽⵉⵏ. ⵓⵔ ⵜⵙⵙⵎⵔⵙ ⵜⵉⴽⵍⵉⵜ.
    >>> fib4(5)
    4
    >>> fib4(6)
    8
    >>> fib4(7)
    14
    """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

"
"
def is_simple_power(x, n):
    """"""ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴰⵔⵔⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴷⵜ ⵉⵖ ⵉⴳⴰ ⵓⵟⵟⵓⵏ x ⵜⴰⵣⴷⵓⵖⵜ ⵜⴰⵎⵢⵉⵡⴰⵏⵜ ⵏ n ⴷ ⵜⵉⴱⵔⵙⴳⴳⵡⴰⴷⵜ ⴳ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏ. x ⵜⴳⴰ ⵜⴰⵣⴷⵓⵖⵜ ⵜⴰⵎⵢⵉⵡⴰⵏⵜ ⵏ n ⵉⵖ ⵉⴳⴰ n**int=x ⵙ ⵓⵎⴷⵢⴰ: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false
    """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def odd_count(lst):
    """"""""ⴰⵛⴽⵓ ⵏⵜⵜⴰⴼ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⵉⴼⵔⵉⵙⵉⵏ, ⴳ ⴽⵓ ⵜⵉⴼⵔⵉⵙⵜ ⵓⵔ ⵉⵍⵍⵉ ⵎⴰⵢⴷ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏⵏ, ⵏⵙⵙⴽⵔ ⵜⴰⵍⴳⴰⵎⵜ. ⴽⵓ ⵉⴼⵔⴷⵉⵙ i ⵏ ⵜⵢⴰⴼⵓⵜ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ""ⵉⴹ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵜⵉⴼⵔⵉⵙⵜ i ⵏ ⵓⵙⴽⵛⵎ"". ⴳ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⵏⴼⴰⵍⵜ ⵜⵉⴼⵔⵉⵙⵉⵏ ⴰⴽⴽⵡ ⵙ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵜⵉⴼⵔⵉⵙⵜ ⵜⵉⵙⵙ i ⵏ ⵓⵙⴽⵛⵎ.

    >>> odd_count(['1234567'])
    [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
    >>> odd_count(['3',""11111111""])
    [""the number of odd elements 1n the str1ng 1 of the 1nput."",
     ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
    """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def rounded_avg(n, m):
    """"""ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵉⴷⵏ n ⴷ m, ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵉⵟⵏ ⴰⵎⵎⴰⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙⴳ n ⴰⵔ m (ⵙⴳ ⴳⴰⵏ n ⴷ m). ⵙⵙⵓⴷⵓⵏ ⵜⴰⵔⴰⵔⵓⵜ ⵖⵔ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⴽⴽⵡ ⵢⵓⵙⵉⵏ ⴷ ⵜⵙⵏⴼⵍ ⵖⵔ ⴱⵉⵏⴰⵔⵉ. ⵎⴽ ⵉⴳⴰ n ⴰⵅⴰⵜⴰⵔ ⵙⴳ m, ⵙⵙⵓⴷⵓⵏ -1. ⴰⵎⴷⵢⴰ: rounded_avg(1, 5) => ""0b11"" rounded_avg(7, 5) => -1 rounded_avg(10, 20) => ""0b11"" rounded_avg(20, 33) => ""0b11010""
    """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

"
"
def minSubArraySum(nums):
    """"""
    ⴳ ⵓⵙⴰⵜⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵜⵓⵜⵜⵉ ⵏ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⴽⵔⴰ ⵏ ⵓⵙⴰⵜⵉ ⴰⵎⵥⵥⵢⴰⵏ ⵓⵔ ⵉⴳⵉⵏ ⵓⵎⵥⵥⵢⴰⵏ. ⴰⵎⴷⵢⴰ minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6
    """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
"
"
def by_length(arr):
    """"""
    د بشپړ شمیرونو یو صف ورکړل شوی ، د 1 او 9 په شمول د بشپړ شمیرونو ترتیب کړئ ، پایله لرونکی صف بیرته واړوئ ، او بیا هر عدد د دې د ورته نوم سره ځای په ځای کړئ له ""یو"" ، ""دوه"" ، ""درې"" ، ""څلور"" ، ""پنځه"" ، ""شپږ"" ، "" اوه"" ، ""اویا"" ، ""نه"". د مثال په توګه: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> ترتیب arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> بیرته arr -> [8, 5, 4, 3, 2, 2, 1, 1] بیرته راستون کړئ ["" اته"" ، ""پنج"" ، ""درې"" ، ""دوه"" ، ""دوه"" ، ""یو"" ، ""یو""] که چیرې صف خالي وي ، بیرته راستون کړئ: arr = [] array []
    """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

"
"
def valid_date(date):
    """"""تاسو باید یو داسې فنکشن ولیکئ چې د نیټې د تار اعتبار تاییدوي او ریښتیا بیرته راستونوي که نیټه د اعتبار وړ وي که نه نو غلط. نیټه د اعتبار وړ ده که لاندې ټول قواعد پوره شي: 1. د نیټې تار خالي نه وي. 2. د ورځو شمیر د میاشتو لپاره 1 یا 31 ورځو څخه کم نه وي. او د ورځو شمیر د میاشتو لپاره 1 یا 30 ورځو څخه کم نه وي. او د میاشتو شمیر د میاشتې لپاره 1 یا 29 څخه کم نه وي. 3. میاشتې باید له 1 څخه کم نه وي یا له 12 څخه ډیر نه وي. 4. نیټه باید په فارمیټ کې وي: mm-dd-yyyy د مثال په توګه: valid_date ((('03-11-2000') => valid_date ((('15-01-2012') => false valid_date ((('04-02040') => false_
    """"""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
"
"
def solve(s):
    """"""تاسو ته يو تار s درکول شوی دی. که s[i] يو حرف وي، د هغه قضیې له ښکته څخه پورته ته او يا برعکس ته واړوي، که نه نو هغه په خپل حال کې وساتئ. که چېرې تار کې کوم حرفونه نه وي، نو تار بېرته واړوي. د فنکشن بايد د پايلې تار بېرته راولي. مثالونه حل (((""1234"") = ""4321"" حل (((""ab"") = ""AB"" حل (((""#a@C"") = ""#A@c""
    """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
"
"
def hex_key(num):
    """"""تاسو ته دنده درکول شوې چې د یو فنکشن لیکل چې د یو هکسادسیمال شمیر په توګه د تار په توګه ترلاسه کوي او د هکسادسیمال ډیجیټونو شمیر شمیرل کیږي چې لومړني دي (لومړی شمیر ، یا لومړنی ، یو طبیعي شمیر دی چې له 1 څخه لوی دی چې د دوه کوچني طبیعي شمیرو محصول نه دی). هکسادسیمال ډیجیټونه 0 ، 1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9 ، A ، B ، C ، D ، E ، F دي. لومړني شمیرې 2 ، 3 ، 5 ، 7 ، 11 ، 13 ، 17 ،... دي نو تاسو باید د لاندې ډیجیټونو شمیر وټاکئ: 2 ، 3 ، 5 ، 7 ، 7 ، B (= لسیزه 11) ، D (= لسیزه 13). یادونه: تاسو کولی شئ فرض
    """"""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

"
"

def is_palindrome(text: str):
    """"""
    دا چک کوي چې ورکړل شوی تار یو پالینډروم دی که نه
    >>> is_palindrome('')
    True
    >>> is_palindrome('aba')
    True
    >>> is_palindrome('aaaaa')
    True
    >>> is_palindrome('zbcd')
    False
    """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

"
"

def median(l: list):
    """"""د لیست l کې د عناصرو منځنۍ برخه بیرته راګرځئ.
    >>> median([3, 1, 2, 4, 5])
    3
    >>> median([-10, 4, 6, 1000, 10, 20])
    15.0
    """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

"
"import math


def poly(xs: list, x: float):
    """"""
    په x نقطه کې د کوفيفېسنټ xs سره پولینوم ارزوي. xs[0] + xs[1] * x + xs[1] * x ^ 2 +.... xs[n] * x ^ n بیرته راګرځئ
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

"
"

def fib(n: int):
    """"""د فبوناچي د n شمېرې بېرته ورکول.
    >>> fib(10)
    55
    >>> fib(1)
    1
    >>> fib(8)
    21
    """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

"
"
def will_it_fly(q,w):
    '''
    Write a function that returns True if the object q will fly, and False otherwise.
    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.

    Example:
    will_it_fly([1, 2], 5) â -> False 
    # 1+2 is less than the maximum possible weight, but it's unbalanced.

    will_it_fly([3, 2, 3], 1) â -> False
    # it's balanced, but 3+2+3 is more than the maximum possible weight.

    will_it_fly([3, 2, 3], 9) â -> True
    # 3+2+3 is less than the maximum possible weight, and it's balanced.

    will_it_fly([3], 5) â -> True
    # 3 is less than the maximum possible weight, and it's balanced.
    '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

"
"

def truncate_number(number: float) -> float:
    """""" د مثبت تعویضي ټکي شمیره ورکړل شوې ، دا په بشپړ برخه (لوی عدد د ورکړل شوي شمیر څخه کوچنی) او لسیزو (پاته برخه تل له 1 څخه کوچنۍ وي) کې تحلیل کیدی شي. د شمیر لسیزه برخه بیرته راګرځئ. مثال:
    >>> truncate_number(3.5)
    0.5
    """"""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
"
"
def even_odd_palindrome(n):
    """"""
    د مثبت عدد n په پام کې نیولو سره، یو ټپل بیرته راګرځوئ چې د حتی او عجیب عدد پالینډرومونو شمیر لري چې په حد کې راځي ((1، n) ، په شمول. مثال1: ان پټ: 3 محصول: (1, 2) توضیح: بشپړ پالینډرومونه دي 1، 2، 3. یو یې حتی دی، او دوه یې عجیب دي. مثال2: ان پټ: 12 محصول: (4, 6) توضیح: بشپړ پالینډرومونه دي 1، 2، 3، 4، 5، 6، 7، 8، 9، 11. څلور یې حتی دي، او 6 یې عجیب دي. یادونه: 1. 1 <= n <= 10 ^ 3 2. ټپل په ترتیب سره د حتی او عجیب عدد پالینډرومونو شمیر بیرته راستون کړی.
    """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

"
"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" د بشپړ شمیرونو د ورکړل شوي لیست لپاره، یو ټپل بیرته راګرځوئ چې د ټولې لیست کې د ټولو بشپړ شمیرونو مجموعه او محصول لري. خالي مجموعه باید 0 سره مساوي وي او خالي محصول باید 1 سره مساوي وي.
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
"
"

def count_distinct_characters(string: str) -> int:
    """""" د يو تار په پام کې نيولو سره، معلومه کړئ چې دا څومره بېلابېل حروف لري (د قضیې په پام کې نیولو پرته)
    >>> count_distinct_characters('xyzXYZ')
    3
    >>> count_distinct_characters('Jerry')
    4
    """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
"
"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" د هرې پیتون ارزښتونو ورکړل شوی لیست یوازې د بشپړونو لپاره فلټر کړئ
    >>> filter_integers(['a', 3.14, 5])
    [5]
    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    [1, 2, 3]
    """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
"
"
def fruit_distribution(s,n):
    """"""
    په دې کار کې، تاسو ته به يو تار چې د مڼو او نارنجونو چې د ميوو په يوه ټوکرۍ کې ویشل شوي دي د شمېر استازیتوب ورکړل شي دا ټوکرۍ مڼې، نارنج، او د مانګو ميوو لري. ورکړل د تار چې د نارنجونو او مڼو د ټول شمېر او د يو عدد چې په ټوکرۍ کې د ميوو د ټول شمېر استازیتوب کوي په ټوکرۍ کې د مانګو ميوو د شمېر بېرته. د مثال په توګه: fruit_distribution""5(مڼې او 6 نارنجونه""، 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 مڼې او 1 نارنجونه،""3) -> 3 - 0 - 1 = 2 fruit_distribution""2 مڼې او 3 نارنجونه،"" 100) -> 100 - 2 - 3 = 95
    """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
"
"
def numerical_letter_grade(grades):
    """"""دا د سمستر وروستۍ اونۍ ده او ښوونکي باید زده کوونکو ته درجې ورکړي. ښوونکي د درجې ورکولو لپاره خپل الګوریتم جوړ کړی دی. یوازینۍ ستونزه دا ده چې هغه د درجې ورکولو لپاره کارول شوی کوډ له لاسه ورکړی دی. هغې تاسو ته د ځینې زده کونکو لپاره د GPAs لیست درکړی او تاسو باید یو فنکشن ولیکئ چې کولی شي د لاندې جدول په کارولو سره د لیک درجې لیست تولید کړي: GPA. د لیک درجې 4.0 A + > 3.7 A > 3.3 A- > 3.0 B + > 2.7 B- > 2.3 B- > 2.0 B + > 1.7 C > 1.3 C- > 1.0 D + > 0.7 D > 0.0 D- 0.0 E مثال: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-
    """"""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def simplify(x, n):
    """"""ستاسو دنده دا ده چې د x * n افادې ساده کړئ. د دې فنکشن راستنیدنه ریښتیا ده که x * n بشپړ شمیر ته ارزښت ورکړي او که نه نو غلط. دواړه x او n ، د کسر تار استازیتوب دی ، او لاندې ب formatه لري ، <شمیرونکی> / <نومینټر> چیرې چې دواړه شمیرونکی او نومونکی مثبت بشپړ شمیرونه دي. تاسو کولی شئ فرض کړئ چې x ، او n معتبر کسرونه دي ، او د نومونکی په توګه صفر نلري. ساده کول (((""1/5"" ، ""5/1"") = ریښتیا ساده کول (((""1/6"" ، ""2/1"") = غلط ساده کول (((""7/10"" ، ""10/2"") = غلط
    """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

"
"

def get_positive(l: list):
    """"""په لیست کې یوازې مثبت شمیرې بیرته راګرځوئ.
    >>> get_positive([-1, 2, -4, 5, 6])
    [2, 5, 6]
    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    [5, 3, 2, 3, 9, 123, 1]
    """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

"
"
def sorted_list_sum(lst):
    """"""د يو فنکشن ليکل چې د تارونو يو لړلست د پارامتر په توګه ومني، هغه تارونه چې بې ځايه اوږدوالى لري له هغې څخه حذف کړي، او د يو ترتيب شوي ترتيب سره پايله لرونکی لړلست بيرته راولي، لړلست تل د تارونو يو لړلست دی او هيڅکله د شمیرو يو صف نه دی، او کېدای شي چې دوه ځلې ولري. د لړلست ترتيب بايد د هرې کلمې د اوږدوالي له مخې پورته شي، او تاسو بايد د دې قاعدې له مخې ترتيب شوی لړلست بيرته راولي. که دوه کلمې يو شان اوږدوالى ولري، نو لړلست په الفبايي ډول ترتیب کړئ. د فنکشن بايد د تارونو يو لړلست په ترتيب شوي ترتيب کې بيرته راولي. تاسو کولاى شئ
    """"""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

"
"
def choose_num(x, y):
    """"""دا فنکشن دوه مثبت شمیرې x او y اخلي او تر ټولو لوی عدد چې په [x، y] کې دی بیرته راولي. که داسې شمیره شتون ونلري، نو فنکشن باید -1 بیرته راولي. د مثال په توګه: choose_num (((12، 15) = 14 choose_num (((13, 12) = -1
    """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

"
"

def correct_bracketing(brackets: str):
    """""" brackets د ""<"" او "">"" یو تار دی. ریښتیني بیرته راستون کړئ که چیرې هر پرانیستل شوی براکټ د ورته تړلو براکټ ولري.

    >>> correct_bracketing(""<"")
    False
    >>> correct_bracketing(""<>"")
    True
    >>> correct_bracketing(""<<><>>"")
    True
    >>> correct_bracketing(""><<>"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

"
"
def next_smallest(lst):
    """"""
    تاسو ته د بشپړ شمیرونو لیست درکول شوی. یو فنکشن ولیکئ next_smallest ((() چې د لیست دوهم کوچنی عنصر بیرته راولي. هیڅ نه بیرته راګرځئ که چیرې داسې عنصر شتون ونلري. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == هیڅ نه next_smallest (([1, 1]) == هیڅ نه
    """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def solution(lst):
    """"""د بشپړ شمیرونو غیر خالي لیست ورکړل شوی ، د ټولو عجیب عناصرو مجموعه بیرته راګرځئ چې په حتی موقعیتونو کې دي. د مثال حل (([5, 8, 7, 1]) ==> 12 حل (([3, 3, 3, 3, 3]) ==> 9 حل (([30, 13, 24, 321]) ==> 0
    """"""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

"
"

def max_element(l: list):
    """"""په لست کې اعظمي عنصر بیرته راګرځوي.
    >>> max_element([1, 2, 3])
    3
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    123
    """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
"
"

def common(l1: list, l2: list):
    """"""د دوو لیستونو لپاره بېل شوي ځانګړي عام عناصر بیرته راګرځوي.
    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
    [1, 5, 653]
    >>> common([5, 3, 2, 8], [3, 2])
    [2, 3]

    """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

"
"
def bf(planet1, planet2):
    '''
    There are eight planets in our solar system: the closerst to the Sun 
    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, 
    Uranus, Neptune.
    Write a function that takes two planet names as strings planet1 and planet2. 
    The function should return a tuple containing all planets whose orbits are 
    located between the orbit of planet1 and the orbit of planet2, sorted by 
    the proximity to the sun. 
    The function should return an empty tuple if planet1 or planet2
    are not correct planet names. 
    Examples
    bf(""Jupiter"", ""Neptune"") ==> (""Saturn"", ""Uranus"")
    bf(""Earth"", ""Mercury"") ==> (""Venus"")
    bf(""Mercury"", ""Uranus"") ==> (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"")
    '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

"
"
def numerical_letter_grade(grades):
    """"""Kay semestropi qhipa semana, profesorqa yachachinmanmi yachakuqkunaman, profesorqa kikin algoritmopi ruwashan, chaytaq huk ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch
    """"""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def histogram(test):
    """"""Kaypi rikch'akun kay simikuna: {{{1}}}, {{{2}}}, {{{3}}}, {{{4}}}, {{{5}}}, {{{6}}}, {{{6}}}, {{{7}}}, {{{7}}}, {{{7}}}, {{{8}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}

    """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

"
"

def largest_divisor(n: int) -> int:
    """""" Qhawarisun, n yupayta, n-ta aswan pisi, aswan hatun, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi
    >>> largest_divisor(15)
    5
    """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
"
"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" Filtrar una lista de entrada de cadenas de caracteres solamente para las que empiezan con un prefijo dado. Kay listataqa filtrar, chaymantaqa, kay listataqa filtrar, chaymantaqa kay listataqa filtrar.
    >>> filter_by_prefix([], 'a')
    []
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    ['abc', 'array']
    """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
"
"

def skjkasdkd(lst):
    """"""Qamqa tarinki entero yupaykuna listata. Qamqa maskanki aswan hatun prim valorta, hinaspataq kutichinki chay yupaykuna sumaqta. Ejemplos: Para lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3], chaymanta 10 Para lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1], chaymanta 25 Para lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3], chaymanta 13 Para lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6], chaymanta 11 Para lst = [0,81,12,31,21], chaymanta 3 Para lst = [0,8,1,
    """"""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
"
"

def strlen(string: str) -> int:
    """""" Qusqu qhichwa simipi
    >>> strlen('')
    0
    >>> strlen('abc')
    3
    """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
"
"
def by_length(arr):
    """"""
    Qhapaqpi enteros nisqa q'uñi q'uñi, q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'uñi q'u
    """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

"
"

def prime_fib(n: int):
    """"""
    prime_fib n-ñay kaq Fibonacci yupayta kutichin, chaytaq prim primus.
    >>> prime_fib(1)
    2
    >>> prime_fib(2)
    3
    >>> prime_fib(3)
    5
    >>> prime_fib(4)
    13
    >>> prime_fib(5)
    89
    """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

"
"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """""" Kay llamk'ayqa, huk k'itiwan rikuchin, maypichus may chhika qutuchakunapi qutuchakunapi qutuchakunapaq t'aqakun, maypichus may chhika t'aqakunapaq t'aqakunapaq t'aqakun.

    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    [2, 3, 1, 3]
    """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
"
"

def triples_sum_to_zero(l: list):
    """"""
    triples_sum_to_zero nisqaqa entero yupaykunaq listanta jap'in. Kay listapi kimsa kaq kaq kaqkuna kaqtinqa, True nisqata kutichin, mana chayqa False nisqata kutichin.

    >>> triples_sum_to_zero([1, 3, 5, 0])
    False
    >>> triples_sum_to_zero([1, 3, -2, 1])
    True
    >>> triples_sum_to_zero([1, 2, 3, 7])
    False
    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
    True
    >>> triples_sum_to_zero([1])
    False
    """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

"
"
def valid_date(date):
    """"""Kay p'anqata qillqaspa, allin p'anqata kutichinki chayqa, allin p'anqata kutichinki chayqa, k'arita. Kay p'anqataqa allin p'anqataqa, kay kamachikuykunaman hunt'asqa kaptinmi: 1. Kay p'anqataqa mana ch'usaqchu. 2. Kay p'anqataqa mana pisichu icha aswan 31 p'unchaykuna, 1,3,5,7,8,10,12 killakunapi. Kay p'anqataqa mana pisichu icha aswan 30 p'unchawkuna, 4,6,9,11 killakunapi. Kay p'anqataqa mana pisichu icha aswan 29 p'unchawkuna, 2 killakunapi. Kay p'anqataqa mana pisichu icha aswan 12. Kay p'anqataqa kay hinam: mm-dd-yyyy, kay hinam: valid_date ({{'03-11-2000'}}
    """"""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
"
"

def count_distinct_characters(string: str) -> int:
    """""" Qhaway, may chhika k'iti k'iti k'iti qillqakunamanta (mana ima k'iti k'iti qillqakunamanta)
    >>> count_distinct_characters('xyzXYZ')
    3
    >>> count_distinct_characters('Jerry')
    4
    """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
"
"
FIX = """"""
Astawan yachanapaq.
""""""

def vowels_count(s):
    """"""Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
    vowel, but only when it is at the end of the given word.

    Example:
    >>> vowels_count(""abcde"")
    2
    >>> vowels_count(""ACEDY"")
    3
    """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def even_odd_count(num):
    """"""Rikuchispa, uj entero. kutichinqa uj tuplata, maypichus uj ch'ichi, uj ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'
    """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def add(lst):
    """"""Mana ch'usaq yupaykuna lst. listata rikuspa, ch'usaq yupaykunawan yapay. Ejemplos: sumachiy ([4, 2, 6, 7]) ==> 2 
    """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
"
"

def flip_case(string: str) -> str:
    """""" Kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi.
    >>> flip_case('Hello')
    'hELLO'
    """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
"
"

def remove_vowels(text):
    """"""
    remove_vowels nisqaqa huk llamk'aymi, chaytaq string nisqata jap'in, hinaspataq vowels mana kaqtinqa string nisqata kutichin.
    >>> remove_vowels('')
    ''
    >>> remove_vowels(""abcdef\nghijklm"")
    'bcdf\nghjklm'
    >>> remove_vowels('abcdef')
    'bcdf'
    >>> remove_vowels('aaaaa')
    ''
    >>> remove_vowels('aaBAA')
    'B'
    >>> remove_vowels('zbcd')
    'zbcd'
    """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

"
"

def is_palindrome(text: str):
    """"""
    Qhapaq simikunaqa palindromo-nchu
    >>> is_palindrome('')
    True
    >>> is_palindrome('aba')
    True
    >>> is_palindrome('aaaaa')
    True
    >>> is_palindrome('zbcd')
    False
    """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

"
"

def below_threshold(l: list, t: int):
    """"""Rikuchiy True nisqata, sichus l listapi l yupaykuna t nisqata mana junt'anchu chayqa.
    >>> below_threshold([1, 2, 4, 10], 100)
    True
    >>> below_threshold([1, 20, 4, 10], 5)
    False
    """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

"
"
def split_words(txt):
    '''
    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you
    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
    Examples
    split_words(""Hello world!"") â -> [""Hello"", ""world!""]
    split_words(""Hello,world!"") â -> [""Hello"", ""world!""]
    split_words(""abcdef"") == 3 
    '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
"
"

def fib4(n: int):
    """"""Fib4 yupaykunaq qhatunqa Fibbonacci yupaykunaq qhatun hinam: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
    >>> fib4(5)
    4
    >>> fib4(6)
    8
    >>> fib4(7)
    14
    """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

"
"
def unique_digits(x):
    """"""Qhapaqpi tukuy k'iti yupaykuna, qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi
    >>> unique_digits([15, 33, 1422, 1])
    [1, 15, 33]
    >>> unique_digits([152, 323, 1422, 10])
    []
    """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"

def car_race_collision(n: int):
    """"""
    Imachus chayllapi, chay iskay q'ala carreterakunaqa, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika
    """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

"
"

def unique(l: list):
    """"""Quriqllapi kaqlla kaqkunata kutichiy
    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [0, 2, 3, 5, 9, 123]
    """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

"
"

def common(l1: list, l2: list):
    """"""ཐོ་བཀོད་གཉིས་ཆ་རའི་དོན་ལུ་ དབྱེ་བ་ཕྱེ་ཡོད་པའི་ཁྱད་ཆོས་ཅན་གྱི་ཆ་ཤས་འདི་སླར་ལོག་འབདཝ་ཨིན།
    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
    [1, 5, 653]
    >>> common([5, 3, 2, 8], [3, 2])
    [2, 3]

    """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

"
"
def string_to_md5(text):
    """"""
    string 'text' བྱིན་པ་ཅིན་ md5 ཧེཤི་ འདྲ་མཉམ་གྱི་ཐིག་ཁྲམ་སླར་ལོག་འབད། གལ་སྲིད་ 'text' འདི་ སྟོངམ་ཐིག་ཁྲམ་ཨིན་པ་ཅིན་ None སླར་ལོག་འབད།

    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def get_row(lst, x):
    """"""
    ཁྱོད་ཀྱིས་ཚད་གཉིས་ཅན་གྱི་ཡིག་སྣོད་ཅིག་ཐོབ་སྟེ་ འདི་ཡང་ matrix དང་འདྲ་བ་ཨིན། ཨིན་རུང་ matrix དང་མ་འདྲ་བར་ ཐིག་ཁྲམ་རེ་ནང་ ཀེར་ཐིག་གི་གྱངས་ཁ་མ་འདྲཝ་ཡོདཔ་ཨིན། lst དང་ཨང་གྲངས་ཧྲིལ་ x བྱིན་པ་ཅིན་ ཐིག་ཁྲམ་ནང་ལུ་ ཨང་གྲངས་ཧྲིལ་ x འཚོལ་ཞིནམ་ལས་ ཀེར་ཐིག་གི་ཐོ་ཡིག་སླར་ལོག་འབད་ [(x1, y1), (x2, y2)...] འདི་བཟུམ་སྦེ་ ཀེར་ཐིག་རེ་རེ་འདི་ ཀོར་ཌི་ནེཊི་ - (གྲལ་ཐིག་ ཀེར་ཐིག་) སྦེ་ འགོ་བཙུགས་ཏེ་ ༠ ཨིན། ཀོར་ཌི་ནེཊི་ཚུ་རིམ་པ་ཡར་སེང་གི་ཐོག་ལས་ འགོ་ཐོག་ལུ་དབྱེ་ཞིབ་འབད་ དེ་ལས་ ཀེར་ཐིག་གི་ ཀེར་ཐིག་ཚུ་རིམ་པ་མར་འབབ་གི་ཐོག་ལས་དབྱེ་ཞིབ་འབད་ དཔེར་ན་: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1],
    """"""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def maximum(arr, k):
    """"""
    ཨེ་རེ་ arr འདི་ ཨང་གྲངས་ཧྲིལ་བུམ་དང་ ནུས་པ་ཅན་ཨང་གྲངས་ k ཨིནམ་སྦེ་བྱིན་པ་ཅིན་ ཨེ་རེ་ནང་གི་ཨང་གྲངས་ k ཚུ་དང་གཅིག་ཁར་ ཚེ་རིང་སྒྲིག་ཡོད་པའི་ཐོ་ཡིག་ཅིག་ལོག་གཏང་། དཔེ་གཞི་༡: ཨེ་རེ་ནང་བཙུགས་: arr = [-3, -4, 5], k = 3 ཐོན་སྐྱེད་: [-4, -3, 5] དཔེ་གཞི་༢: ཨེ་རེ་ནང་བཙུགས་: arr = [4, -4, 4], k = 2 ཐོན་སྐྱེད་: [4, 4] དཔེ་གཞི་༣: ཨེ་རེ་ནང་བཙུགས་: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 ཐོན་སྐྱེད་: [2] དྲན་གསོ། ༡: ཨེ་རེ་གི་རིང་ཚད་དེ་ [1, 1000] གི་བར་ན་ལུ་འོང་ནི་ཨིན། ༢: ཨེ་རེ་ནང་ཡོད་པའི་ཆ་ཤས་ཚུ་ [-1000, 1000] གི་བར་ན་ལུ་འོང་ནི་ཨིན། ༣: ༠ <= k <= len ((arr)
    """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

"
"
def cycpattern_check(a , b):
    """"""ཁྱོད་ཀྱིས་ཚིག་གཉིས་ཐོབ་ཡོདཔ་ཨིན། ཁྱོད་ཀྱིས་ཚིག་གཉིས་པ་ཡང་ན་ འདི་གི་འཁོར་ལོའི་གྲལ་རིམ་ཚུ་ ཚིག་དང་པ་ནང་ལུ་ ནང་ཐིག་སྦེ་ཡོད་པ་ཅིན་ ཁྱོད་ཀྱིས་བདེན་པ་ལོག་གཏང་དགོཔ་ཨིན། cycpattern_check(""abcd"",""abd"") => false cycpattern_check(""hello"",""ell"") => true cycpattern_check (((""whassup"",""psus"") => false cycpattern_check""abab"",""baa"") => true cycpattern_check (((""efef"",""eeff"") => false cycpattern_check"" ((hims"",""simen"") => true

    """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

"
"
def strange_sort_list(lst):
    '''
    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.

    Examples:
    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    strange_sort_list([]) == []
    '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"

def is_prime(n):
    """"""ཨང་གྲངས་འདི་ཨང་གྲངས་ངོ་མ་ཨིན་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།
    >>> is_prime(6)
    False
    >>> is_prime(101)
    True
    >>> is_prime(11)
    True
    >>> is_prime(13441)
    True
    >>> is_prime(61)
    True
    >>> is_prime(4)
    False
    >>> is_prime(1)
    False
    """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

"
"
def move_one_ball(arr):
    """"""ང་བཅས་ནང་ལུ་ ཨེ་རེ་ 'arr' འདི་ ཨང་གྲངས་ N ཡོངས་བསྡོམས་ arr[1], arr[2],..., arr[N] ཚུ་ཡོད་ ཨེ་རེ་ནང་གི་ཨང་གྲངས་ཚུ་ སྟབས་བདེ་ཏོག་ཏོ་སྦེ་རིམ་སྒྲིག་འབད་འོང་། ཁྱོད་ཀྱི་ལཱ་འདི་ ཨེ་རེ་འདི་ མར་འབབ་འགྱོ་ནི་མེད་པའི་རིམ་སྒྲིག་ནང་ ཐོབ་ཚུགས་ག་འདི་ངེས་འཛིན་འབད་དགོ འདི་གི་དོན་ལུ་ ཁྱོད་ཀྱིས་ ཨེ་རེ་འདི་ནང་ལུ་ ཚར་གྲངས་ཚུ་ ཕྲང་སྒྲིག་འབད་བཏུབ། ཨེ་རེ་གི་ཆ་ཤས་ཆ་མཉམ་ ཕྲང་སྒྲིག་འབད་བཏངམ་ད་ ཕྲང་སྒྲིག་འབད་བཏངམ་ད་ ཕྲང་སྒྲིག་འབད་བཏངམ་ད་ ཕྲང་སྒྲིག་འབད་བཏངམ་ད་ ཨེ་རེ་གི་ཆ་ཤས་ཆ་མཉམ་ ཕྲང་སྒྲིག་འབད་བཏངམ་ད་ ཕྲང་སྒྲིག་འབད་བཏངམ་ད་ ཨེ་རེ་གི་ཆ་ཤས་མཇུག་དེ་ ཨེ་རེ་ནང་ འགོ་བཙུགས་པའི་ས་སྒོ་ལུ་ སྤོ་བཤུད་འབད་བཏངམ་ཨིན། ཨེ་རེ་དེ་གི་ཆ་ཤས་མཇུག་འདི་ ཨེ་རེ་གི་ཨང་གྲངས་ ༠ པ་ཨིན། ག་དེམ་ཅིག་
                
    """"""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
"
"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" ནང་བསྐྱོད་ཐོ་ཡིག་ནང་ལུ་ string འདི་ཚུ་ prefix ཅིག་ལས་འགོ་བཙུགས་ཏེ་ཡོད་མི་ཚུ་རྐྱངམ་ཅིག་ ཌའི་ལོག་འབདཝ་ཨིན།
    >>> filter_by_prefix([], 'a')
    []
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    ['abc', 'array']
    """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
"
"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

"
"
def is_multiply_prime(a):
    """"""ཨང་གྲངས་འདི་ ཨང་གྲངས་ངོ་མ་༣ གྱི་གྱངས་ཁ་དང་ ཨང་གྲངས་གཞན་ཚུ་ཤོམ་པ་ཅིན་ ཨིན་ཟེར་ལོག་གཏང་མི་ལས་འགན་ཅིག་འབྲི་དགོ། དཔེར་ན་: is_multiply_prime (༣༠) == ཨིན་པུཊི་ ༣༠ = ༢*༣*༥
    """"""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

"
"
def odd_count(lst):
    """"""string གི་ཐོ་ཡིག་ཅིག་བྱིནམ་ད་ string རེ་རེ་ནང་ཨང་གྲངས་རྐྱངམ་ཅིག་ཡོདཔ་ལས་ ཚིག་ཡིག་ཅིག་ལོག་གཏང་། ཨང་གྲངས་ཐོན་པའི་ཆ་ཤས་རེ་རེ་ i འདི་ ""input གི་ string i ནང་གི་རྣམ་གྲངས་མེད་པའི་ཆ་ཤས་ཚུ་གི་གྱངས་ཁ་"" ཨིནམ་ད་ i ཚུ་ཆ་ཤས་ i པའི་ནང་རྣམ་གྲངས་མེད་པའི་ཨང་གྲངས་ཚུ་དང་ཚབ་རྐྱབ་དགོ།

    >>> odd_count(['1234567'])
    [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
    >>> odd_count(['3',""11111111""])
    [""the number of odd elements 1n the str1ng 1 of the 1nput."",
     ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
    """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def fibfib(n: int):
    """"""FibFib ཨང་རིམ་འདི་ Fibbonacci ཨང་རིམ་དང་འདྲཝ་སྦེ་ར་ཨིནམ་ད་ འདི་ཚུ་ནང་དོན་འདི་བཀོད་དེ་འདུག: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) ཨིན་པ་ཅིན་ ཨང་རིམ་གྱི་ཆ་ཤས་ཨང་ n པ་འདི་ ཕྲ་རིང་སྦེ་རྩིས་སྟོན་འབད་ནིའི་དོན་ལུ་ ལས་འགན་ཅིག་འབྲི་གནང་
    >>> fibfib(1)
    0
    >>> fibfib(5)
    4
    >>> fibfib(8)
    24
    """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

"
"from typing import List


def sort_numbers(numbers: str) -> str:
    """""" ནང་བསྐྱོད་འདི་ ས་སྒོ་ནང་ཐིག་ཡིག་ཡོད་པའི་ string འདི་'༠' ལས་'༩' ཚུན་ཨིན། གདམ་ཁ་ཚུ་'༠'༡'༢'༣'༤'༥'༦'༧'༨'༩'ཚུ་ཨིན། string འདི་ཆུང་ཤོས་ལས་སྦོམ་ཤོས་ཚུན་རིམ་སྒྲིག་འབད་ཡོད་པའི་ཨང་གྲངས་ཚུ་སླར་ལོག་འབདཝ་ཨིན།
    >>> sort_numbers('three one five')
    'one three five'
    """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
"
"

def triples_sum_to_zero(l: list):
    """"""
    triples_sum_to_zero གིས་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ཐོ་ཡིག་ཅིག་ཨེབ་གཏང་འབད་སྦེ་ལེན་ཡོདཔ་ཨིན། གལ་སྲིད་ཐོ་ཡིག་ནང་ལུ་ ཨང་གྲངས་ཧྲིལ་བུམ་ལུ་ ༠་དང་གཞན་མི་ཅིག་ལུ་རྫུས་མ་སྦེ་བསྡོམས་མི་ཁྱད་པར་ཅན་གསུམ་ཡོད་པ་ཅིན་ True སླར་ལོག་འབདཝ་ཨིན།

    >>> triples_sum_to_zero([1, 3, 5, 0])
    False
    >>> triples_sum_to_zero([1, 3, -2, 1])
    True
    >>> triples_sum_to_zero([1, 2, 3, 7])
    False
    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
    True
    >>> triples_sum_to_zero([1])
    False
    """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

"
"
def double_the_difference(lst):
    '''
    Given a list of numbers, return the sum of squares of the numbers
    in the list that are odd. Ignore numbers that are negative or not integers.
    
    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10
    double_the_difference([-1, -2, 0]) == 0
    double_the_difference([9, -2]) == 81
    double_the_difference([0]) == 0  
   
    If the input list is empty, return 0.
    '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

"
"
def is_equal_to_sum_even(n):
    """"""དཔེ་གཞི་འདི་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_ཆ་མཉམ་_
    """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
"
"
def compare_one(a, b):
    """"""
    ལས་འགན་ཅིག་བཟོ་ཞིནམ་ལས་ ཨང་གྲངས་ཧྲིལ་བུམ་དང་ floats ཡང་ན་ string གིས་ཨང་གྲངས་ངོ་མ་འདི་ངོ་ཚབ་འབད་ཞིནམ་ལས་ སྦོམ་ཤོས་དེ་སླར་ལོག་འབདཝ་ཨིན། གནས་གོང་ཚུ་འདྲན་འདྲ་ཡོད་པ་ཅིན་ None སླར་ལོག་འབདཝ་ཨིན། དྲན་པ་བཟོ་ནི། ཨང་གྲངས་ངོ་མ་ཅིག་ string སྦེ་ངོ་ཚབ་འབད་བ་ཅིན་ འཁྱིལ་འགྱོ་བའི་གནས་གོང་འདི་. ཡང་ན་, compare_one (༡,༢.༥) â -> ༢.༥ compare_one (༡,༢.༣) â -> ""༢,༣ compare_one (༡,༥,༡"", ""༦"") â -> ""༦"" compare_one (༡,༡) â -> None
    """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """""" འ་ནི་ལས་འགན་ནང་ཨེབ་གཏང་འབད་མི་འདི་ ནང་ཐིག་ནང་ཡོད་པའི་ ཀེར་ཐིག་སྡེ་ཚན་ལེ་ཤ་ཡོད་པའི་ ཀེར་ཐིག་ཨིན། ཁྱོད་ཀྱི་དམིགས་ཡུལ་འདི་ སྡེ་ཚན་དེ་སོ་སོར་སྦེ་ ཕྲ་རིང་ནང་དབྱེ་བ་ཕྱེ་ནི་དང་ འདི་ཚུ་གི་ཐོ་དེ་སླར་ལོག་འབདཝ་ཨིན། སྡེ་ཚན་སོ་སོར་ཚུ་ ཚད་ལྡན་བཟོ་སྟེ་ (སྒོ་སྒྲིག་རེ་རེའི་ ཀེར་ཐིག་འདི་ ལེགས་ཤོམ་སྦེ་བསྡམ་ཡོདཔ་) དང་ གཅིག་གིས་གཅིག་ལུ་ ནང་ཐིག་ནང་མ་ཚུད་དེ་ཡོད། ཨེབ་གཏང་ཐིག་ནང་ བར་སྟོང་ཚུ་སྣང་མེད་བཟོ་དགོ། དཔེ་:
    >>> separate_paren_groups('( ) (( )) (( )( ))')
    ['()', '(())', '(()())']
    """"""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
"
"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """""" ཨང་གྲངས་ཀྱི་ཐོ་ཡིག་ཅིག་ལས་ (ཉུང་ཤོས་ཨང་གྲངས་གཉིས་) གཅིག་དང་གཅིག་དང་ཉེ་བའི་ཨང་གྲངས་གཉིས་གདམ་ཁ་རྐྱབ་སྟེ་ལོག་གཏང་ནི་དང་ ཨང་གྲངས་ཚུ་རིམ་པ་བཞིན་དུ་ལོག་གཏང་ (ཨང་གྲངས་ཆུང་ཤོས་དང་ ཨང་གྲངས་སྦོམ་ཤོས་) །
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
    (2.0, 2.2)
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
    (2.0, 2.0)
    """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

"
"
def total_match(lst1, lst2):
    '''
    Write a function that accepts two lists of strings and returns the list that has 
    total number of chars in the all strings of the list less than the other list.

    if the two lists have the same number of chars, return the first list.

    Examples
    total_match([], []) â -> []
    total_match(['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi']
    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin']
    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi', 'hi']
    total_match(['4'], ['1', '2', '3', '4', '5']) â -> ['4']
    '''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

"
"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """""" ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ཐོ་ཡིག་ནང་ལས་ ཚར་གཅིག་ལས་ལྷག་པའི་ནང་ཡོད་པའི་ཆ་ཤས་ཚུ་བཏོན་གཏང་། ནང་བསྐྱོད་ནང་བཟུམ་སྦེ་ཆ་ཤས་ཚུ་རིམ་པ་གཅིག་སྦེ་བཞག་དགོ།
    >>> remove_duplicates([1, 2, 3, 2, 4])
    [1, 3, 4]
    """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
"
"import math


def poly(xs: list, x: float):
    """"""
    ཚད་ལྡན་ xs ཚུ་ཡོད་པའི་སྒོ་འདི་ xs ལུ་རྩིས་སྟོནམ་ཨིན། སླར་ལོག་ xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

"
"
def add_elements(arr, k):
    """"""
    ཨང་གྲངས་མཐའ་དག་ arr དང་ ཨང་གྲངས་མཐའ་དག་ k ཚུ་ཡོད་པའི་ ཨེ་རེ་མེད་ཅིག་བྱིན་པ་ཅིན་ ཨེ་རེ་གི་ཨང་གྲངས་མཐའ་དག་ k གི་ཨང་གྲངས་ལས་ཨང་གྲངས་གཉིས་ལས་ལྷག་སྟེ་མེད་མི་ཚུ་སླར་ལོག་འབདཝ་ཨིན། དཔེ་གཞི་: ཨེན་པུཊི་: arr = [111,21,3,4000,5,6,7,8,9], k = 4 ཨེན་པུཊི་: 24 # sum of 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)
    """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def closest_integer(value):
    '''
    Create a function that takes a value (string) representing a number
    and returns the closest integer to it. If the number is equidistant
    from two integers, round it away from zero.

    Examples
    >>> closest_integer(""10"")
    10
    >>> closest_integer(""15.3"")
    15

    Note:
    Rounding away from zero means that if the given number is equidistant
    from two integers, the one you should return is the one that is the
    farthest from zero. For Exampleclosest_integer(""14.5"") should
    return 15 and closest_integer(""-14.5"") should return -15.
    '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

"
"

def get_positive(l: list):
    """"""Miverena amin'ny isa tsara ao amin'ny lisitra ihany.
    >>> get_positive([-1, 2, -4, 5, 6])
    [2, 5, 6]
    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    [5, 3, 2, 3, 9, 123, 1]
    """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

"
"

def strlen(string: str) -> int:
    """""" Halavany miverina amin'ny tady nomena
    >>> strlen('')
    0
    >>> strlen('abc')
    3
    """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
"
"
def circular_shift(x, shift):
    """"""Mivezivezy manodidina ny tarehimarika amin'ny integer x, mivezivezy miankavanana ny tarehimarika ary avereno ny valiny ho toy ny tadiny. Raha miova > isa ny tarehimarika, avereno ny tarehimarika mivadika.
    >>> circular_shift(12, 1)
    ""21""
    >>> circular_shift(12, 2)
    ""12""
    """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

"
"from typing import List


def sort_numbers(numbers: str) -> str:
    """""" Ny fidirana dia singa iray voafetra amin'ny habaka misy isa manomboka amin'ny 'zero' ka hatramin'ny'sivy'. Safidy mety dia 'zero', 'iray', 'roa', 'telo', 'efatra', 'dimy', 'enina', 'fito', 'valo' ary'sivy'. Avereno ny tady misy isa voalahatra avy amin'ny kely indrindra ka hatramin'ny lehibe indrindra
    >>> sort_numbers('three one five')
    'one three five'
    """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
"
"

def truncate_number(number: float) -> float:
    """""" Raha nomena isa isa mihetsiketsika tsara, dia azo zaraina ho ampahany iray manontolo (isa lehibe indrindra kely kokoa noho ny isa nomena) sy ny decimals (ny ampahany sisa tavela dia kely kokoa noho ny 1).
    >>> truncate_number(3.5)
    0.5
    """"""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
"
"
def make_a_pile(n):
    """"""
    Raha nomena isa iray n, dia tsy maintsy manao antontam-bato misy vato n ianao. Ny ambaratonga voalohany dia misy vato n. Ny isan'ny vato ao amin'ny ambaratonga manaraka dia: - ny isa hafahafa manaraka raha n dia hafahafa. - ny isa manaraka raha n dia mitovy. Avereno ny isan'ny vato isaky ny ambaratonga ao anaty lisitra, izay maneho ny isan'ny vato ao amin'ny ambaratonga (i + 1) ny singa ao amin'ny index i.
    >>> make_a_pile(3)
    [3, 5, 7]
    """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def iscube(a):
    '''
    Write a function that takes an integer a and returns True 
    if this ingeger is a cube of some integer number.
    Note: you may assume the input is always valid.
    Examples:
    iscube(1) ==> True
    iscube(2) ==> False
    iscube(-1) ==> True
    iscube(64) ==> True
    iscube(0) ==> True
    iscube(180) ==> False
    '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

"
"
def rounded_avg(n, m):
    """"""Ohatra: boribory_avg ((1, 5) => ""0b11"" boribory_avg ((7, 5) => -1 boribory_avg ((10, 20) => ""0b11"" boribory_avg ((20, 33) => ""0b11010""
    """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

"
"

def largest_prime_factor(n: int):
    """"""Avereno ny mpanisa voalohany lehibe indrindra amin'ny n. Mihevitra n > 1 ary tsy prime.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

"
"
def get_row(lst, x):
    """"""
    Ohatra: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 1, 4], 0 (1, 4), 0 (2, 5), 0 (2), get_(1), 1) [_] == [[laharana 1, 2, 3, 2]], == 2]], [_]] == laharan 1, 2, 3, 2, 3]] == laharan 1, 2, 3 == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == ==
    """"""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def bf(planet1, planet2):
    '''
    There are eight planets in our solar system: the closerst to the Sun 
    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, 
    Uranus, Neptune.
    Write a function that takes two planet names as strings planet1 and planet2. 
    The function should return a tuple containing all planets whose orbits are 
    located between the orbit of planet1 and the orbit of planet2, sorted by 
    the proximity to the sun. 
    The function should return an empty tuple if planet1 or planet2
    are not correct planet names. 
    Examples
    bf(""Jupiter"", ""Neptune"") ==> (""Saturn"", ""Uranus"")
    bf(""Earth"", ""Mercury"") ==> (""Venus"")
    bf(""Mercury"", ""Uranus"") ==> (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"")
    '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

"
"
def max_fill(grid, capacity):
    import math
    """"""
    Ohatra 1: Fidirana: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Famoahana: 62: Fidirana: [[0,0,1,1], [0,0,0,0], [1,1,1,1]] bucket_capacity: 2 Famoahana: 53: [[:0,0,0], [0,0,0]] bucket_capacity: 5 Famoahana: 5 * 0 * 0 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 11 * 11 * 11 * 11 * 11 * 12 * 12 * 13 * 13 * 14 * 15 * 15 * 15 * 15 * 15
    """"""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

"
"
def f(n):
    """""" Ampiharo ny fiasa f izay mandray ny n ho toy ny masontsivana, ary mamerina lisitra iray amin'ny habeny n, toy ny hoe ny sandan'ny singa ao amin'ny index i dia ny factorial an'ny i raha toa ka i dia mitovy na ny totalin'ny isa avy amin'ny 1 ka hatramin'ny i raha tsy izany. i manomboka amin'ny 1. ny factorial an'ny i dia ny fampitomboana ny isa avy amin'ny 1 ka hatramin'ny i (1 * 2 *... * i). Ohatra: f(5) == [1, 2, 6, 24, 15]
    """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
"
"
def string_to_md5(text):
    """"""
    Raha misy ny 'text' dia avereno ny md5 hash equivalent string. Raha 'text' dia tsy misy string dia avereno ny None.

    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" Ho an'ny lisitra iray nomena ny integers, miverina ny tuple ahitana ny sombiny sy ny vokatra ny integers rehetra ao amin'ny lisitra. foana dia tokony ho mitovy amin'ny 0 sy ny vokatra foana dia tokony ho mitovy amin'ny 1.
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
"
"
def words_string(s):
    """"""
    Ohatra: words_string (tantara) => ""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""] words_string (tantara) => ""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

"
"

def derivative(xs: list):
    """""" xs dia maneho ny coefficients amin'ny polynôme. xs[0] + xs[1] * x + xs[2] * x^2 +.... Avereno amin'ny endriny mitovy ny derivate amin'ity polynôme ity.
    >>> derivative([3, 1, 2, 4, 5])
    [1, 4, 12, 20]
    >>> derivative([1, 2, 3])
    [2, 6]
    """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

"
"
FIX = """"""
Ampio tranga fanandramana bebe kokoa.
""""""

def vowels_count(s):
    """"""Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
    vowel, but only when it is at the end of the given word.

    Example:
    >>> vowels_count(""abcde"")
    2
    >>> vowels_count(""ACEDY"")
    3
    """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def monotonic(l: list):
    """"""Miverina marina raha toa ka mitombo na mihena tsy miova ny singa ao anaty lisitra.
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

"
"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" Raha nomena lisitry ny isa (amin'ny singa roa farafahakeliny), ampiharo ny fanovana tsipika amin'io lisitra io, ka ny isa kely indrindra dia ho lasa 0 ary ny lehibe indrindra dia ho lasa 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
"
"

def correct_bracketing(brackets: str):
    """""" brackets dia andian-dahatsoratra misy ""<"" sy "">"". miverina ho marina raha toa ka misy bracket fanokafana mifanandrify amin'ny bracket famaranana.

    >>> correct_bracketing(""<"")
    False
    >>> correct_bracketing(""<>"")
    True
    >>> correct_bracketing(""<<><>>"")
    True
    >>> correct_bracketing(""><<>"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

"
"
def numerical_letter_grade(grades):
    """"""Ny olana dia very ny kaody nampiasainy tamin'ny fanasokajiana. Nomeny anao ny lisitry ny salan'isan'ny mpianatra sasany ary tsy maintsy manoratra fiasa izay afaka mamoaka ny lisitry ny mari-pahaizana amin'ny alàlan'ny tabilao manaraka ianao: GPA  GPA  Lasibatra taratasy 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation ([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']
    """"""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"from typing import List


def factorize(n: int) -> List[int]:
    """""" Miverena lisitry ny laharam-pahamehana amin'ny laharam-pahamehana amin'ny laharam-pahamehana amin'ny laharam-pahamehana. Ny isa tsirairay dia tokony ho voatanisa amin'ny isa mitovy amin'ny isan'ny fotoana miseho amin'ny factorization. Ny isa fidirana dia tokony hitovy amin'ny vokatra rehetra
    >>> factorize(8)
    [2, 2, 2]
    >>> factorize(25)
    [5, 5]
    >>> factorize(70)
    [2, 5, 7]
    """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
"
"
def pluck(arr):
    """"""
    Raha misy laharana iray maneho sampana iray amin'ny hazo izay manana node integer tsy ratsy ny asanao dia ny manaisotra ny iray amin'ireo node ary mamerina azy. Ny node noforonina dia tokony ho ny node miaraka amin'ny sanda kely indrindra. Raha misy node maromaro miaraka amin'ny sanda kely indrindra dia mamerina ny node izay manana index kely indrindra. Ny node noforonina dia tokony haverina ao anaty lisitra, [small_value, ny index-ny ], Raha tsy misy sanda na ny array nomena dia foana, miverina []. Ohatra 1: Input: [4,2,3] Output: [2, 1] Fanazavana: 2 no manana sanda kely indrindra, ary 2 no manana index kely indrindra. Ohatra 2: Input: [1,2,3] Output: [2, 1] Fanazavana: 2 no manana sanda kely indrindra, ary 2 no manana index kely indrindra. Ohatra 3: Input: []
    """"""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

"
"
def closest_integer(value):
    '''
    Create a function that takes a value (string) representing a number
    and returns the closest integer to it. If the number is equidistant
    from two integers, round it away from zero.

    Examples
    >>> closest_integer(""10"")
    10
    >>> closest_integer(""15.3"")
    15

    Note:
    Rounding away from zero means that if the given number is equidistant
    from two integers, the one you should return is the one that is the
    farthest from zero. For Exampleclosest_integer(""14.5"") should
    return 15 and closest_integer(""-14.5"") should return -15.
    '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

"
"

def correct_bracketing(brackets: str):
    """""" brackets string of ""("" and "")"". return True eger her bracket vekirina heye a bracket girtina hevbeş.

    >>> correct_bracketing(""("")
    False
    >>> correct_bracketing(""()"")
    True
    >>> correct_bracketing(""(()())"")
    True
    >>> correct_bracketing("")(()"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

"
"

def change_base(x: int, base: int):
    """"""Guherandina base hejmarî ya hejmara input x ji bo base. nûnertiya string vegerandin piştî veguhastina. hejmarên base kêmtir ji 10 in.
    >>> change_base(8, 3)
    '22'
    >>> change_base(8, 2)
    '1000'
    >>> change_base(7, 2)
    '111'
    """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

"
"

def skjkasdkd(lst):
    """"""Ji bo lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] encam divê 10 ji bo lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] encam divê 25 ji bo lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] encam divê 13 ji bo lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] encam divê 11 ji bo lst = [0,81,12,3,21,1] encam divê 3 ji bo lst = [0,1,8,1,2,1,7] encam divê 7 ji bo lst = [0,8,1,2,7] encam divê 10 ji bo lst = [0,1,1,2,2,2,2,1] encam divê 10 ji bo
    """"""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
"
"
def iscube(a):
    '''
    Write a function that takes an integer a and returns True 
    if this ingeger is a cube of some integer number.
    Note: you may assume the input is always valid.
    Examples:
    iscube(1) ==> True
    iscube(2) ==> False
    iscube(-1) ==> True
    iscube(64) ==> True
    iscube(0) ==> True
    iscube(180) ==> False
    '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

"
"
def f(n):
    """""" Fonksiyona f ku n wek parameter digire, pêk bîne û lîsteya mezinbûna n vedigere, wekî ku nirxa hêmana li endeksê i faktoriyê i ye eger i jî an jî jimara hejmarên ji 1 heta i be. i ji 1. factoriyê i ji 1 heta i (1 * 2 *... * i) pirkirine. Mînak: f ((5) == [1, 2, 6, 24, 15]
    """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
"
"

def derivative(xs: list):
    """""" xs koefîsanên polinomê nîşan dide. xs[0] + xs[1] * x + xs[2] * x^2 +.... Derivata vê polinomê di heman formê de vegerîne.
    >>> derivative([3, 1, 2, 4, 5])
    [1, 4, 12, 20]
    >>> derivative([1, 2, 3])
    [2, 6]
    """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

"
"
def digits(n):
    """"""Ji bo hejmarek pozîtîf n, hilberê hêjmara hêjmaran vegerîne. 0 vegerîne eger hemû hêjmaran jî hevbeş bin. Mînak: hêjmaran ((1) == 1 hêjmaran ((4) == 0 hêjmaran ((235) == 15
    """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

"
"
def prime_length(string):
    """"""Fonksiyonek binivîse ku stringekê digire û rast vedigere eger dirêjahiya string hejmarek sereke be an jî derew be.
    """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

"
"
def sort_array(arr):
    """"""
    Di vê Kata de, divê hûn rêza hejmarên ne-negatîf li gor hejmara yekên di nûnertiya wan a binerî de bi rêza bilindbûnê rêz bikin. Ji bo hejmara wekhev ya yekan, rêzê li gorî nirxa dehanîn. Divê wiha were pêkanîn:
    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]
    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]
    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]
    """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def next_smallest(lst):
    """"""
    Hûn lîsteya hejmarên tam tê dayîn. Fonksiyonek next_smallest binivîse ku hêmana duyemîn a lîsteyê vedigere. Eger hêmanek wiha tune be, None vedigere. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None
    """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"

def fibfib(n: int):
    """"""The FibFib hejmar rêzika a rêzika wekhev ji bo Fibbonacci sequnece ku wek jêr hatiye diyarkirin e: fibfib ((0) == 0 fibfib ((1) == 0 fibfib ((2) == 1 fibfib ((n) == fib ((n-1) + fibfib ((n-2) + fibfib ((n-3). Ji kerema xwe re function a ji bo bi bandor hesabkirina element n-emîn ji rêzika hejmar fibfib binivîse.
    >>> fibfib(1)
    0
    >>> fibfib(5)
    4
    >>> fibfib(8)
    24
    """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

"
"
def fruit_distribution(s,n):
    """"""
    Di vê wezîfeyê de, hûn dê ji bo string ku nîşan dide hejmareke apples û orange ku di basket fêkî belavkirin ev basket dihewîne apples, orange, û fêkî mango. Given string ku nîşan dide hejmara giştî ya orange û apples û integer ku hejmara giştî ya fêkî di basket vegerînin hejmara fêkî mango di basket. ji bo examble: fruit_distribution""5(apples û 6 orange"", 19) ->19 - 5 - 6 = 8 fruit_distribution""0 apples û 1 orange"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 apples û 3 orange"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 apples û 120) "",1 -> 120 - 100 - 1 = 19
    """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
"
"
def specialFilter(nums):
    """"""Nivîseke function ku array of hejmarên wek input û hejmara hêmanên di array ku mezintir ji 10 û hem yekem û dawî digits ji hejmareke ne wekhev in, vegerîne.
    """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

"
"
def sort_array(array):
    """"""
    Di nav array a hejmarên ne-negatîf de, kopiyek ji arrayê dayîn vegerîne piştî rêzkirinê, hûn ê arrayê dayîn bi rêza bilindbûnê rêzkirin, eger jimara (( nirxa endeksê ya yekem, nirxa endeksê ya dawî) neyek e, an jî rêzkirinê bi rêza dakêşandinê rêzkirin, eger jimara (( nirxa endeksê ya yekem, nirxa endeksê ya dawî) jî e. Têbînî: * arrayê dayîn neguhere. Mînak: * sort_array[(]) => [] * sort_array[]] => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5]
    """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

"
"
def check_dict_case(dict):
    """"""
    Ji ber ku ferhengek, eger hemû kilîtan di nav tîpên biçûk de bin an hemû kilîtan di nav tîpên mezin de bin, eger ne wisa be, vegerîne False. Fonksiyon divê vegerîne False eger ferhengê dayî vala be. Mînak: check_dict_case{""a"":""apple"", ""b"":""banana""}) divê vegerîne True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) divê vegerîne False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) divê vegerîne False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}
    """"""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

"
"
def string_to_md5(text):
    """"""
    Ji ber ku string 'text', string hevbeş ya hash md5 xwe vegerîne. Eger 'text' stringek vala be, None vegerîne.

    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"

def pairs_sum_to_zero(l):
    """"""
    pairs_sum_to_zero lîsteya hejmarên temam wek input digire. ew rast vedigere eger du hêmanên cuda di lîsteyê de hebin ku jimara xwe ji sifir re, û bi awayekî din derew.
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    False
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    False
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    False
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    True
    >>> pairs_sum_to_zero([1])
    False
    """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

"
"

def modp(n: int, p: int):
    """"""2 ^ n modulo p vegerîne (ji hejmarên hişyar be).
    >>> modp(3, 5)
    3
    >>> modp(1101, 101)
    2
    >>> modp(0, 101)
    1
    >>> modp(3, 11)
    8
    >>> modp(100, 101)
    1
    """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

"
"
def prod_signs(arr):
    """"""
    Tu bi array arr ji integer dan û hûn divê ji bo vegera sum of mezintirî yên integer bi berhemên hemû nîşaneyên her hejmarê di array, bi 1, -1 an 0 temsîl kirin.
    >>> prod_signs([1, 2, 2, -4]) == -9
    >>> prod_signs([0, 1]) == 0
    >>> prod_signs([]) == None
    """"""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def string_sequence(n: int) -> str:
    """""" Stranek ku hejmarên space-sînorkirî ji 0 heta n dest pê dikin vedigere.
    >>> string_sequence(0)
    '0'
    >>> string_sequence(5)
    '0 1 2 3 4 5'
    """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
"
"
def find_max(words):
    """"""Fonksiyonek binivîse ku lîsteya stringan qebûl bike. Lîste peyvên cuda dihewîne. Peyv bi hejmara herî zêde ya karakterên yekane vegerîne. Eger çend string hejmara herî zêde ya karakterên yekane hebin, peyvê ku di rêza leksîkoografîk de yekemîn tê vegerîne. find_max (([""name"", ""of"", ""string""]) == ""string"" find_max (([""name"", ""enam"", ""game""]) == ""enam"" find_max (([""aaaaaaa"", ""bb"", ""cc""]) == """"aaaaaaa""
    """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

"
"
def Strongest_Extension(class_name, extensions):
    """"""Tu dê navê class (a string) û lîsteya ji extensionên dayîn. The extensionên ji bo barkirina dersên din ji bo class bikaranîn. Hêza ji extension e wek li jêr: Bila CAP hejmara tîpên uppercase di navê extension ya be, û bila SM hejmara tîpên biçûk di navê extension ya be, hêza bi fraction CAP - SM dayîn. Tu divê ji bo dîtina extension herî xurt û vegera string di vê formatê de: ClassName.StrongestExtensionName. Eger du an zêdetir ji extensionên bi heman hêza hene, divê hûn ji yek ku yekemîn di lîsteyê de tê hilbijêre. Bo nimûne, eger tu bi ""Slices"" wek class û lîsteya ji extensionên dayîn: ['SEviRNGSliCes', 'Cheese', 'StuFfed'] hing
    """"""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
"
"

def monotonic(l: list):
    """"""Return True e ku hêmanên lîsteyê bi awayekî monotonî zêde dibin an kêm dibin.
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

"
"
def can_arrange(arr):
    """"""Create a function ku herî mezin index ji element ku ne mezintir e ji an jî wekhev bi element rasterast berî wê ye. Eger elementeke wiha tune ye, paşê vegere -1. array dayîn dê nirxên dubare ne. nimûne: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1
    """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

"
"
def minPath(grid, k):
    """"""
    Ji ber ku grid bi rêzên N û kolanên N (N > = 2) û k a integer pozîtîf, her hucreya gridê nirxek dihewîne. Her integer di rêza [1, N * N] de yekser yekser li hucreyên gridê xuya dibe. Hûn divê rêya herî kêm a dirêjahiya k di gridê de bibînin. Hûn dikarin ji her hucreyekê dest pê bikin, û di her gavê de hûn dikarin ji bo hucreyên cîran vegerin, bi gotineke din, hûn dikarin ji hucreyên ku bi hucreya niha re li ser xêzeke hev re parve bikin. Ji kerema xwe ve têbînî bikin ku rêya dirêjahiya k tê wateya serdana k hucreyan (ne hewce ne ku cuda be). Hûn nikarin ji gridê derkevin. A rêya A (ji dirê
    """"""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

"
"
def strange_sort_list(lst):
    '''
    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.

    Examples:
    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    strange_sort_list([]) == []
    '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

"
"
def make_a_pile(n):
    """"""
    एगो धनात्मक पूर्णांक n के मान के आधार पर, रउआ के n स्तर के पत्थर के ढेर बनावे के होई. पहिला स्तर में n पत्थर बा. अगिला स्तर में पत्थर के संख्या ई बा: - अगर n विषम बा त अगला विषम संख्या. - अगर n सम बा त अगला सम संख्या. एगो सूची में प्रत्येक स्तर में पत्थर के संख्या लौटाईं, जहाँ इंडेक्स i में तत्व स्तर (i+1) में पत्थर के संख्या के प्रतिनिधित्व करेला. उदाहरण:
    >>> make_a_pile(3)
    [3, 5, 7]
    """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def words_in_sentence(sentence):
    """"""
    एगो वाक्य के प्रतिनिधित्व करे वाला एगो स्ट्रिंग दिहल गइल बा, एह में कुछ शब्द बाड़ी स जेकरा के एगो स्पेस से अलग कइल गइल बा, आ आप के एगो अइसन स्ट्रिंग लौटावे के बा जेह में मूल वाक्य के शब्द बाड़ी स, जेकर लंबाई अभाज्य संख्या बा, नया स्ट्रिंग में शब्द के क्रम मूल के क्रम के समान होखे के चाहीं. उदाहरण 1: इनपुटः वाक्य = ""ई एगो परीक्षण ह"" आउटपुटः ""हो बा"" उदाहरण 2: इनपुटः वाक्य = ""चलो स्विमिंग खातिर चलल जाव"" आउटपुटः ""जावे खातिर"" बाधाः * 1 <= len(sentence) <= 100 * वाक्य में खाली अक्षर बा
    """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

"
"

def flip_case(string: str) -> str:
    """""" एगो दिहल गइल स्ट्रिंग खातिर, छोट अक्षर के बड़ अक्षर में आ बड़ अक्षर के छोट अक्षर में बदल दीं.
    >>> flip_case('Hello')
    'hELLO'
    """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
"
"

def truncate_number(number: float) -> float:
    """""" एगो धनात्मक फ्लोटिंग पॉइंट संख्या के देख के, एकरा के पूर्णांक भाग (सबसे बड़ पूर्णांक दिहल गइल संख्या से छोट) आउर दशमलव (बाकी भाग हमेशा 1 से छोट) में विभाजित कइल जा सकेला. संख्या के दशमलव भाग लौटाईं. उदाहरण:
    >>> truncate_number(3.5)
    0.5
    """"""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
"
"
def anti_shuffle(s):
    """"""
    एगो फलन लिखें जे एगो स्ट्रिंग ले ले आ ओकर एगो क्रमबद्ध संस्करण लौटावेला. स्ट्रिंग के क्रमबद्ध संस्करण, एगो अइसन स्ट्रिंग होला जहाँ सब शब्द (स्पेस से अलग) के एगो नया शब्द से बदल दिहल जाला जहाँ सब अक्षर के क्रम क्रम में क्रमबद्ध कइल जाला. नोटः आपके वाक्य में शब्द आ खाली जगह के क्रम रखे के चाहीं. उदाहरण खातिरः anti_shuffle ((('Hi') 'Hi' anti_shuffle (('hello') लौटावेला 'ehllo' anti_shuffle (('Hello World!!!') लौटावेला 'Hello!!!Wdlor'
    """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

"
"

def correct_bracketing(brackets: str):
    """""" brackets ""<"" आ "">"" के स्ट्रिंग हवे. अगर हर खोले वाला ब्रैकेट में एक ठो बंद करे वाला ब्रैकेट होखे तब ई सही लउके ला.

    >>> correct_bracketing(""<"")
    False
    >>> correct_bracketing(""<>"")
    True
    >>> correct_bracketing(""<<><>>"")
    True
    >>> correct_bracketing(""><<>"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

"
"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" स्ट्रिंग के एगो इनपुट सूची के खाली उ सब खातिर फ़िल्टर करीं जेमे दिहल गइल सबस्ट्रिंग बा
    >>> filter_by_substring([], 'a')
    []
    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    ['abc', 'bacd', 'array']
    """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
"
"
def specialFilter(nums):
    """"""एगो फलन लिखीं जे संख्या के एगो सरणी के इनपुट के रूप में ले ले आ ऊ तत्व के संख्या लौटावे जे 10 से बड़ होखे आ संख्या के पहिला आ आखिरी अंक दुनों विषम (1, 3, 5, 7, 9) होखे उदाहरण खातिरः specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2
    """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

"
"

def incr_list(l: list):
    """"""1 से बढ़ावल गइल तत्व के साथे रिटर्न सूची
    >>> incr_list([1, 2, 3])
    [2, 3, 4]
    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [6, 4, 6, 3, 4, 4, 10, 1, 124]
    """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

"
"

def encode_shift(s: str):
    """"""
    वर्णमाला में हर वर्ण के 5 से स्थानांतरित करके एन्कोडेड स्ट्रिंग लौटावेला.
    """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""
    takes as input string encoded with encode_shift function. Returns decoded string.
    """"""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

"
"
def is_equal_to_sum_even(n):
    """"""ई आंकलन करीं कि का दिहल गइल संख्या n के ठीक 4 धनात्मक सम संख्या के योग के रूप में लिखल जा सकेला उदाहरण is_equal_to_sum_even ({4) == False is_equal_to_sum_even ({6) == False is_equal_to_sum_even ({8) == True
    """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
"
"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """""" स्ट्रिंग्स के सूची में से, सबसे लंबा लौटाई. एकही लंबाई के कई स्ट्रिंग्स के स्थिति में पहिला लौटाई. इनपुट सूची खाली होखे पर ना लौटाई.
    >>> longest([])

    >>> longest(['a', 'b', 'c'])
    'a'
    >>> longest(['a', 'bb', 'ccc'])
    'ccc'
    """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
"
"

def sort_third(l: list):
    """"""ई फलन एगो सूची l लेला आउर एगो सूची l' लौटावेला, अइसन कि l' उ सूचकांक में l के समान हो जे तीन से विभाज्य ना हो, जबकि तीन से विभाज्य सूचकांक में एकर मान l के संबंधित सूचकांक के मान के बराबर होला, लेकिन सॉर्ट कइल जाला.
    >>> sort_third([1, 2, 3])
    [1, 2, 3]
    >>> sort_third([5, 6, 3, 4, 8, 9, 2])
    [2, 6, 3, 4, 8, 9, 5]
    """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

"
"
def add_elements(arr, k):
    """"""
    पूर्णांक arr आउर पूर्णांक k के एगो गैर-खाली सरणी के दिहल गइल बा, तब एआर के पहिला के तत्वन से अधिकतम दू अंक वाला तत्वन के योग लौटाई. उदाहरणः इनपुटः एआर = [111,21,3,4000,5,6,7,8,9], के = 4 आउटपुटः 24 # 21 + 3 के योग बाधाः 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)
    """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def file_name_check(file_name):
    """"""एगो फलन बनावे जे एगो फ़ाइल के नाँव के प्रतिनिधित्व करे वाली स्ट्रिंग ले, आ अगर फाइल के नाँव मान्य बा त 'हाँ' लौटावे, आ अगर मान्य न बा त 'ना' लौटावे. एगो फाइल के नाँव वैध मानल जाला अगर अउरी खाली अगर नीचे दिहल शर्त पूरा होखेंः - फाइल के नाँव में तीन से बेसी अंक ('0'-'9') ना होखे के चाहीं. - फाइल के नाँव में ठीक एक ठो बिंदु '.' होखे के चाहीं. - बिंदु से पहिले के सबस्ट्रिंग खाली ना होखे के चाहीं, आ ई लातीनी अल्फाबेट ('a'-'z' आ 'A'Z'-) से शुरू होखे के चाहीं. - बिंदु के बाद के सबस्ट्रिंग में से एगो होखे के चाहींः ['txt', 'exe', 'lld'] उदाहरणः file_name_check""{example.txt.} # => 'हाँ' file_name_check""{ex
    """"""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

"
"
def double_the_difference(lst):
    '''
    Given a list of numbers, return the sum of squares of the numbers
    in the list that are odd. Ignore numbers that are negative or not integers.
    
    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10
    double_the_difference([-1, -2, 0]) == 0
    double_the_difference([9, -2]) == 81
    double_the_difference([0]) == 0  
   
    If the input list is empty, return 0.
    '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

"
"

def modp(n: int, p: int):
    """"""2^n मॉडुलो p लौटाई (संख्या के बारे में जागरूक रहें).
    >>> modp(3, 5)
    3
    >>> modp(1101, 101)
    2
    >>> modp(0, 101)
    1
    >>> modp(3, 11)
    8
    >>> modp(100, 101)
    1
    """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

"
"
def split_words(txt):
    '''
    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you
    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
    Examples
    split_words(""Hello world!"") â -> [""Hello"", ""world!""]
    split_words(""Hello,world!"") â -> [""Hello"", ""world!""]
    split_words(""abcdef"") == 3 
    '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
"
"

def sum_to_n(n: int):
    """"""sum_to_n एगो फलन बा जे 1 से n तक के संख्या के योग बनावेला.
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
    """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

"
"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" संख्या के एगो सूची (कम से कम दू तत्व के) दिहल गइल बा, उ सूची में एगो रैखिक परिवर्तन लागू कइल जा, जेवना से सबसे छोट संख्या 0 हो जाई आउर सबसे बड़ संख्या 1 हो जाई.
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
"
"
def encrypt(s):
    """"""एगो फलन एन्क्रिप्ट बनाईं जे एगो स्ट्रिंग के तर्क के रूप में ले ले आ वर्णमाला के घुमा के एगो एन्क्रिप्ट कइल स्ट्रिंग लौटावे. वर्णमाला के अइसन तरीका से घुमावल जाए के चाहीं कि अक्षर दू स्थान पर दू से गुणा करके नीचे आ जाव. उदाहरण खातिरः एन्क्रिप्ट (hi) लौटावे 'lm' एन्क्रिप्ट (asdfghjkl) लौटावे 'ewhjklnop' एन्क्रिप्ट (gf) लौटावे 'kj' एन्क्रिप्ट (et) लौटावे 'ix'
    """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def count_nums(arr):
    """"""
    एगो फलन count_nums लिखीं जे पूर्णांक के एगो सरणी लेला आउर अइसन तत्व के संख्या लौटावेला जेकर अंक के योग > 0 बा. अगर कौनो संख्या ऋणात्मक बा, त ओकर पहिला हस्ताक्षरित अंक ऋणात्मक होईः उदाहरण खातिर -123 में अंक -1, 2, आउर 3 के हस्ताक्षरित बा.
    >>> count_nums([]) == 0
    >>> count_nums([-1, 11, -11]) == 1
    >>> count_nums([1, 1, 2]) == 3
    """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """""" पूर्णांक के सूची से, उ सब तत्व के हटा दीं जे एक से अधिक बार आवेला. इनपुट में जइसन क्रम बाचल बा, ओइसन ही क्रम में तत्व के रखीं.
    >>> remove_duplicates([1, 2, 3, 2, 4])
    [1, 3, 4]
    """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
"
"

def get_positive(l: list):
    """"""Endurgevur bert jalig tøl í listanum.
    >>> get_positive([-1, 2, -4, 5, 6])
    [2, 5, 6]
    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    [5, 3, 2, 3, 9, 123, 1]
    """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

"
"

def largest_prime_factor(n: int):
    """"""Gev størsta primtøl av n. Um n > 1 er ikki primt.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

"
"

def common(l1: list, l2: list):
    """"""Gevur upp ordiliga felags elementir fyri tveir listar.
    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
    [1, 5, 653]
    >>> common([5, 3, 2, 8], [3, 2])
    [2, 3]

    """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

"
"

def correct_bracketing(brackets: str):
    """""" brackets er ein streng av ""<"" og "">"". return True um hvørt opnandi parket hevur eitt samsvarandi lokandi parket.

    >>> correct_bracketing(""<"")
    False
    >>> correct_bracketing(""<>"")
    True
    >>> correct_bracketing(""<<><>>"")
    True
    >>> correct_bracketing(""><<>"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

"
"
def solve(N):
    """"""Um N = 1000, verður talið av talvum 1 og útgangsstøðið skal vera ""1"". Um N = 150, verður talið av talvum 6 og útgangsstøðið skal vera ""110"". Um N = 147, verður talið av talvum 12 og útgangsstøðið skal vera ""1100"".
    """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

"
"

def below_threshold(l: list, t: int):
    """"""Gevur sannleika, um øll tøl í listanum l eru undir markinum t.
    >>> below_threshold([1, 2, 4, 10], 100)
    True
    >>> below_threshold([1, 20, 4, 10], 5)
    False
    """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

"
"

def max_element(l: list):
    """"""Vísir størsta element í listanum.
    >>> max_element([1, 2, 3])
    3
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    123
    """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
"
"
def add_elements(arr, k):
    """"""
    Gevst ein ikki tóm røð av heilum tølum arr og eitt heil tøl k, so skal summarið av elementunum við í mesta lagi tveimum tølum frá fyrstu k elementunum í arr, verða latin aftur. Dømi: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # summarið av 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)
    """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def skjkasdkd(lst):
    """"""Tú fært ein lista við heilum tølum. Tú skalt finna størsta prim-virðið og lata summar av tí nummarinum. Dømi: Fyri lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] skal útgávuna vera 10 Fyri lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] skal útgávuna vera 25 Fyri lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] skal útgávuna vera 13 Fyri lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] skal útgávuna vera 11 Fyri lst = [0,81,12,31,21] skal útgávuna vera 3
    """"""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
"
"
def sort_array(arr):
    """"""
    Í hesum Kata, skalt tú raðfesta eina røð av ikki-negativum heilum talum eftir tali av einum í teirra binara representatión í uppgongdari raðfylgju.
    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]
    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]
    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]
    """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def hex_key(num):
    """"""Tú hevur fingið til uppgávu at skriva eina funktión, sum tekur ímóti einum hexadecimaltal sum einari strengi og telur talið av hexadecimaltaltølum, sum eru primtøl (prímtøl, ella eitt primtøl, er eitt natúrligt tal størri enn 1, sum ikki er eitt produkt av tveimum smærri natúrligum tølum). Hexadecimaltølini eru 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Prímtølini eru 2, 3, 5, 7, 11, 13, 17,... So tú mást finna eitt tal av hesum tølum: 2, 3, 5, 7, B (=decimal 11), D (=decimal 13). Viðmerking: Tú kanst rokna við, at inngangurin altíð er rættur ella tómur strengi, og symbolini A,B,C,D,E,F eru altíð stórskri
    """"""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

"
"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" Til ein givnan lista við heilum tølum, skal ein tuple verða latin sum er eitt heild og eitt produkt av øllum heilum tølum í einum lista.
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
"
"
def is_simple_power(x, n):
    """"""Tín uppgáva er at skriva eina funktión, sum gevur sannleika, um eitt tal x er ein einføld potens av n, og falskt í øðrum førum. x er ein einføld potens av n, um n**int=x T.d.: er_einføld_potentia (a) (i) (i) (ii) => sannur er_einføld_potentia (i) (ii) => sannur er_einføld_potentia (i) (iii) => sannur er_einføld_potentia (i) (iii) => falskur er_einføld_potentia (i) (iii) => falskur er_einføld_potentia (i) (iii) => falskur
    """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def will_it_fly(q,w):
    '''
    Write a function that returns True if the object q will fly, and False otherwise.
    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.

    Example:
    will_it_fly([1, 2], 5) â -> False 
    # 1+2 is less than the maximum possible weight, but it's unbalanced.

    will_it_fly([3, 2, 3], 1) â -> False
    # it's balanced, but 3+2+3 is more than the maximum possible weight.

    will_it_fly([3, 2, 3], 9) â -> True
    # 3+2+3 is less than the maximum possible weight, and it's balanced.

    will_it_fly([3], 5) â -> True
    # 3 is less than the maximum possible weight, and it's balanced.
    '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

"
"
def choose_num(x, y):
    """"""Henda funktión tekur tvey positivar tøl x og y og gevur størsta javna heilt tal, sum er í rásini [x, y] inklusivt. Um tað ikki er nakað slíkt tal, so skal funktiónin geva -1.
    """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

"
"
def intersection(interval1, interval2):
    """"""Tú hevur tvey intervall, har hvørt intervall er eitt pari av heilum tølum. T.d. intervall = (start, end) = (1, 2). Tær givnu intervallini eru stongd, sum merkir, at intervall (start, end) inniheldur bæði start og end. Fyri hvørt givið intervall verður roknað við, at starturin er minni enn ella líka við endin. Tín uppgáva er at finna út av, um longdin á skerjingini av hesum báðum intervallum er eitt primtal. Dømi: Skeringin av intervallunum (1, 3), (2, 4) er (2, 3) sum hevur longdina 1, sum ikki er eitt primtal. Um longdin á skerjingini er eitt primtal, sendur tú ""JA"", annars sendur tú ""NEI"". Um teir báðir intervallini ikki skerjast, sendir tú ""NEI"". [input
    """"""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

"
"

def strlen(string: str) -> int:
    """""" Vís longd á givnu strengi
    >>> strlen('')
    0
    >>> strlen('abc')
    3
    """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
"
"
def max_fill(grid, capacity):
    import math
    """"""
    Tú hevur eitt rektangulært rásverk av brunnum. Hvør røð umboðar eina brunn, og hvør 1 í røðini umboðar eina vatnstykki. Hvør brunnur hevur eina samsvarandi spann, sum kann brúkast til at taka vatn úr, og allir spannir hava sama kapasitet. Tín uppgáva er at brúka spannirnar til at tøma brunnirnar. Útgangin er, hvussu ofta tú skalt lækka brunnirnar.
    """"""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

"
"
def sort_array(array):
    """"""
    Gev einari røð av ikki-negativum heilum tølum, send eitt avrit av tí givnu røðini eftir at hava sorterað, so skal tú sortera ta givnu røðina í uppgongdarsvari, um summan ((fyrsta indekstvirði, seinasta indekstvirði) er ólíkt, ella sortera hana í fallandi rað, um summan ((fyrsta indekstvirði, seinasta indekstvirði) er javnt.
    """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

"
"from typing import List


def concatenate(strings: List[str]) -> str:
    """""" At fáa strenge listan í eina strenge
    >>> concatenate([])
    ''
    >>> concatenate(['a', 'b', 'c'])
    'abc'
    """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
"
"

def how_many_times(string: str, substring: str) -> int:
    """""" Finn hvussu ofta ein givin undirstring kann finnast í upprunaliga stringini. Tel yvirskipað dømi.
    >>> how_many_times('', 'a')
    0
    >>> how_many_times('aaa', 'a')
    3
    >>> how_many_times('aaaa', 'aa')
    3
    """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
"
"
def match_parens(lst):
    '''
    You are given a list of two strings, both strings consist of open
    parentheses '(' or close parentheses ')' only.
    Your job is to check if it is possible to concatenate the two strings in
    some order, that the resulting string will be good.
    A string S is considered to be good if and only if all parentheses in S
    are balanced. For example: the string '(())()' is good, while the string
    '())' is not.
    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.

    Examples:
    match_parens(['()(', ')']) == 'Yes'
    match_parens([')', ')']) == 'No'
    '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

"
"
def specialFilter(nums):
    """"""Skriva eina funktión, sum tekur eina talvu sum inngang og gevur talið av elementum í talvu, sum eru størri enn 10, og bæði fyrsta og seinasta talvtalv er óliviligt (1, 3, 5, 7, 9). T.d. specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2
    """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

"
"

def remove_vowels(text):
    """"""
    remove_vowels er ein funktión, sum tekur strengi og gevur strengi uttan vokal.
    >>> remove_vowels('')
    ''
    >>> remove_vowels(""abcdef\nghijklm"")
    'bcdf\nghjklm'
    >>> remove_vowels('abcdef')
    'bcdf'
    >>> remove_vowels('aaaaa')
    ''
    >>> remove_vowels('aaBAA')
    'B'
    >>> remove_vowels('zbcd')
    'zbcd'
    """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

"
"
def even_odd_palindrome(n):
    """"""
    Given a positive integer n, returns a tuple that has the number of even and odd integer palindromes that fall within the range ((1, n), inclusive. Example1: Input: 3 Output: (1, 2) Explanation: Integer palindrome are 1, 2, 3. ein teirra er javnur, og tveir teirra eru ójavnir. Example2: Input: 12 Output: (4, 6) Explanation: Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. fýra teirra eru javnir, og 6 teirra eru ójavnir.
    """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def remove_vowels(text):
    """"""
    remove_vowels adalah fungsi nyang geucok string ngon geuwoe string hana vokal.
    >>> remove_vowels('')
    ''
    >>> remove_vowels(""abcdef\nghijklm"")
    'bcdf\nghjklm'
    >>> remove_vowels('abcdef')
    'bcdf'
    >>> remove_vowels('aaaaa')
    ''
    >>> remove_vowels('aaBAA')
    'B'
    >>> remove_vowels('zbcd')
    'zbcd'
    """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

"
"
def is_nested(string):
    '''
    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.

    is_nested('[[]]') â -> True
    is_nested('[]]]]]]][[[[[]') â -> False
    is_nested('[][]') â -> False
    is_nested('[]') â -> False
    is_nested('[[][]]') â -> True
    is_nested('[[]][[') â -> True
    '''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

"
"
def solve(N):
    """"""Diberi bilangan bulat positif N, kembalikan jumlah total digit-digitnya dalam biner. Contoh Untuk N = 1000, jumlah digit akan menjadi 1 output harus ""1"". Untuk N = 150, jumlah digit akan menjadi 6 output harus ""110"". Untuk N = 147, jumlah digit akan menjadi 12 output harus ""1100"". Variabel: @N bilangan bulat Keterbatasan: 0 â‰¤ N â‰¤ 10000. Output: string bilangan biner
    """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

"
"
def digits(n):
    """"""Meunurot bilangan bulat positif n, meubalekkan hasil peuneubah dari angka ganjil. Meubalekkan 0 meunyo mandum angka na pasangan. Miseu jih: angka
    """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

"
"
def minPath(grid, k):
    """"""
    Meunurot grid deungen N bareh dan N kolom (N >= 2) dan bilangan bulat positif k, tiep sel dari grid nyan na nilai. tiep bilangan bulat dalam rentang [1, N * N] termasok deuh seucara eksak sekali bak sel-sel grid. Droeneuh harus meurumpok jalan minimal panyang k bak grid. Droeneuh jeut neujak dari sel, dan bak tiep langkah droeneuh jeut neujak bak sel-sel tetangga, ngon kata laen, droeneuh jeut neujak bak sel-sel yang na sagoe sama deungen droeneuh bak sel saat nyo. Neuteupue bahwa jalan panyang k berarti neujak bak sel-sel yang tepat (hana perle hana berbeda). Droeneuh hanjeut neujak bak grid. Jalan A (panjang k) dianggap kureng dari jalan B (panjang k) jika lheuh peuget daftar tersusun nilai-nilai bak sel-sel yang
    """"""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

"
"

def car_race_collision(n: int):
    """"""
    Bayangkan sebuah jalan yang lurus sempurna garis panjang yang tak terhingga. n mobil mengemudi dari kiri ke kanan; secara bersamaan, satu set berbeda dari n mobil mengemudi dari kanan ke kiri. dua set mobil mulai dari jarak yang sangat jauh satu sama lain. semua mobil bergerak dengan kecepatan yang sama. dua mobil dikatakan bertabrakan ketika mobil yang bergerak dari kiri ke kanan menabrak mobil yang bergerak dari kanan ke kiri. namun, mobil-mobil tersebut sangat kokoh dan kuat; akibatnya, mereka terus bergerak dalam lintasan mereka seolah-olah mereka tidak bertabrakan. fungsi ini menghasilkan jumlah tabrakan seperti itu.
    """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

"
"from typing import List


def parse_music(music_string: str) -> List[int]:
    """""" Input untuk fungsi ini adalah string yang mewakili nota musik dalam format ASCII khusus. Tugas anda adalah untuk menganalisa string ini dan mengembalikan daftar bilangan bulat yang sesuai dengan berapa banyak ketukan yang masing-masing tidak bertahan. Berikut adalah legenda: 'o' - catatan keseluruhan, bertahan empat ketukan 'o"" - setengah catatan, bertahan dua ketukan '. "" "" - catatan quater, bertahan satu ketukan

    >>> parse_music('o o| .| o| o| .| .| .| .| o o')
    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
    """"""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
"
"

def pairs_sum_to_zero(l):
    """"""
    pairs_sum_to_zero meuanggap daftar bilangan bulat seubagoe input. jih meupeugisa True meunyo na dua elemen yang berbeda dalam daftar yang jumlah jih sama deungen nol, dan False meunyo hana.
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    False
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    False
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    False
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    True
    >>> pairs_sum_to_zero([1])
    False
    """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

"
"

def string_sequence(n: int) -> str:
    """""" Meugisa string nyang meuaso angka nyang ji wateh le spasi mulai dari 0 sampoe n termasok.
    >>> string_sequence(0)
    '0'
    >>> string_sequence(5)
    '0 1 2 3 4 5'
    """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
"
"
def next_smallest(lst):
    """"""
    Neubri saboh daftar bilangan bulat. Neutuleh fungsi next_smallest (() nyang geuwoe elemen keu-2 paleng ubit lam daftar. Neupeugisa none meunyoe hana elemen lagee nyan. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None
    """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def maximum(arr, k):
    """"""
    Diberi sebuah array arr bilangan bulat dan bilangan bulat positif k, kembalikan daftar tersusun panjangnya k dengan jumlah maksimum k bilangan di arr. Contoh1: Input: arr = [-3, -4, 5], k = 3 Output: [-4, -3, 5] Contoh2: Input: arr = [4, -4, 4], k = 2 Output: [4, 4] Contoh3: Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Output: [2] Catatan: 1. panjang array akan berada di kisaran [1, 1000]. 2. elemen dalam array akan berada di kisaran [-1000, 1000]. 3. 0 <= k <= len (arr)
    """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

"
"
def largest_smallest_integers(lst):
    '''
    Create a function that returns a tuple (a, b), where 'a' is
    the largest of negative integers, and 'b' is the smallest
    of positive integers in a list.
    If there is no negative or positive integers, return them as None.

    Examples:
    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)
    largest_smallest_integers([]) == (None, None)
    largest_smallest_integers([0]) == (None, None)
    '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
"
"

def common(l1: list, l2: list):
    """"""Kembalikan elemen umum unik yang disortir untuk dua daftar.
    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
    [1, 5, 653]
    >>> common([5, 3, 2, 8], [3, 2])
    [2, 3]

    """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

"
"
def digitSum(s):
    """"""Tugas Tuleh fungsi nyang geucok string seubagoe input ngon geuwoe jumlah dari karakter ateuh mantong' kode ASCII. Contoh: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153
    """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

"
"import math


def poly(xs: list, x: float):
    """"""
    Meuseukat polinomial deungen koefisien xs bak titek x. puwoe xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

"
"
def find_max(words):
    """"""Tulis fungsi yang menerima daftar string. Daftar berisi kata yang berbeda. Kembalikan kata dengan jumlah karakter unik maksimal. Jika beberapa string memiliki jumlah karakter unik maksimal, kembalikan yang pertama dalam urutan leksikografis.
    """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

"
"
def compare_one(a, b):
    """"""
    Peuget fungsi yang meucok bilangan bulat, float, atau string yang mewakili bilangan nyata, dan meupeutron variabel yang leubeh rayek dalam tipe variabel yang diberikan. Meulipat hana jika nilai-nilai sama. Catatan: Jika bilangan nyata diwakili sebagai string, titik terapung mungkin. atau, bandingkan_satu, 2,5) â -> 2,5 bandingkan_satu, ""2,3"") â -> ""2,3"" bandingkan_satu, ""5,1"", ""6"") â -> ""6"" bandingkan_satu, ""1"", 1) â -> Hana
    """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
FIX = """"""
Tamah lom kasus uji coba.
""""""

def vowels_count(s):
    """"""Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
    vowel, but only when it is at the end of the given word.

    Example:
    >>> vowels_count(""abcde"")
    2
    >>> vowels_count(""ACEDY"")
    3
    """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def eat(number, need, remaining):
    """"""
    Contoh: * makan(5, 6, 10) -> [11, 4] * makan(4, 8, 9) -> [12, 1] * makan(1, 10, 10) -> [11, 0] * makan(2, 11, 5) -> [7, 0] Variabel: @number: bilangan bulat bilangan wortel yang telah anda makan. @need: bilangan bulat bilangan wortel yang perlu anda makan. @remaining: bilangan bulat bilangan wortel yang tersisa di stok Constrain: * 0= <= 0 * 1000 = <= 0 * 0 = <= 1000 = <= 1000 Sekalian bersenang-senanglah:)
    """"""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

"
"
def valid_date(date):
    """"""Peuteubiet fungsi nyang geupeutentei string tanggai nyang teubri dan geuwoe True meunyoe tanggai nyan sah. Laen jih False. Tanggai nyan sah meunyoe mandum aturan nyoe geupeutentei: 1. string tanggai hana kosong. 2. jumlah uroe hana kureung leubeh dari 1 atawa leubeh dari 31 uroe keu buleun 1,3,5,7,8,10,12. dan jumlah uroe hana kureung leubeh dari 1 atawa leubeh dari 30 uroe keu buleun 4,6,9,11. dan, jumlah uroe hana kureung leubeh dari 1 atawa leubeh dari 29 keu buleun 2. 3. buleun han jeut kureung leubeh dari 1 atawa leubeh dari 12.4. tanggai nyan harus lam format: mm-dd-yyyy misaljih: valid_date (('03-11-2000') => true_date (('15-01-2012') => false_date (('04-040-20') => false_date (('06-04-2020') => true_date (('06/04/2020
    """"""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
"
"
def hex_key(num):
    """"""Peurlehan peuniléh peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt peuneugöt
    """"""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

"
"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

"
"

def skjkasdkd(lst):
    """"""Contoh: Untuk lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] outputnya harus 10 Untuk lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] outputnya harus 25 Untuk lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] outputnya harus 13 Untuk lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] outputnya harus 11 Untuk lst = [0,81,12,3,21,1] outputnya harus 3 Untuk lst = [0,1,8,2,1,7] outputnya harus 7
    """"""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
"
"

def unique(l: list):
    """"""Meupeugisa elemen unik nyang ka ji urot lam daftar
    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [0, 2, 3, 5, 9, 123]
    """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

"
"
def tri(n):
    """"""Seurutan Fibonacci dituri le mandum ureng, nyan ka geu peuruno le para matematikawan lam padum-padum abad nyang ka u likot. Namun, yang hana dituri le ureng adalah urutan Tribonacci. Urutan Tribonacci didefinisikan le pengulangan: tri(1) = 3 tri(n) = 1 + n / 2, jika n adalah genap. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), jika n adalah ganjil. Misal: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Droeneuh geubri bilangan bulat non-negatif n, droeneuh harus neuba daftar bilangan n + 1 phon dari urutan Tribonacci. Contoh: tri(3) = [1, 3, 2, 8]
    """"""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
"
"

def median(l: list):
    """"""Emu nsɛm a ɛwɔ list l no mu no mu dodow a wɔsan de ba.
    >>> median([3, 1, 2, 4, 5])
    3
    >>> median([-10, 4, 6, 1000, 10, 20])
    15.0
    """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

"
"
def do_algebra(operator, operand):
    """"""
    Sɛ wode operand ne operator ka ho a, nea edi kan no yɛ algebra mu adwuma, na nea ɛtɔ so no yɛ integers. Fa list abien no yɛ algebra mu adwuma na fa kyerɛ sɛ nea ɛkyerɛ no yɛ no. Basic algebra operation: Addition ( +) Subtraction ( - ) Multiplication ( *) Floor division ( //) Exponentiation ( ** Example): operator['+', '*', '-'] array = [2, 3, 4, 5] result = 2 + 3 * 4 - 5 => result = 9 Hyɛ no nsow: Operand no tenten yɛ pɛ sɛ list a wɔde operand ka ho no tenten a wɔtwe baako. Operand no yɛ integers a ɛnyɛ negative no nyinaa. Operator no wɔ operator baako, na list no nso wɔ operand mmienu.

    """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def max_element(l: list):
    """"""San kɔfa nneɛma a ɛboro so wɔ din no mu.
    >>> max_element([1, 2, 3])
    3
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    123
    """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
"
"

def how_many_times(string: str, substring: str) -> int:
    """""" Hwehwɛ mpɛn dodow a substring bi wɔ mfitiase no mu. Hwehwɛ nsɛm a ɛboro so.
    >>> how_many_times('', 'a')
    0
    >>> how_many_times('aaa', 'a')
    3
    >>> how_many_times('aaaa', 'aa')
    3
    """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
"
"
def find_max(words):
    """"""Kyerɛw adwuma a ɛgye ntweaa a ɛwɔ din din mu. Nkyerεkyerεmu no kura nsɛmfua ahorow. Fa asɛmfua no a ne nkyerɛwde dodow no ara yɛ soronko no san. Sɛ ntweaa bebree wɔ nkyerɛwde dodow a ɛsen biara a, fa nea edi kan wɔ nkyerɛwde mu no san.
    """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

"
"

def is_palindrome(string: str) -> bool:
    """""" Sɛntire a wɔde ama no yɛ palindrome """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """""" Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    >>> make_palindrome('')
    ''
    >>> make_palindrome('cat')
    'catac'
    >>> make_palindrome('cata')
    'catac'
    """"""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
"
"
def file_name_check(file_name):
    """"""Yɛ adwuma bi a fa ɔtweaseɛ a egyina hɔ ma file din, na sɛ ɔtweaseɛ no din yɛ papa a, ɛde 'Yiw' ma, na sɛ ɛnte saa a ɛde 'Dabi' ma. Sɛ nea edidi so yi nyinaa ba a, ɛno nkutoo na wobegye file din sɛ ɛyɛ papa: - Ɛnsɛ sɛ ɛboro ntwerɛfua mmiɛnsa ('0'-'9') wɔ file no din mu. - File no din no mu no, ɛkura dot baako pɛ '.' - Substring a ɛwɔ dot no anim no, ɛnsɛ sɛ ɛyɛ hunu, na ɛsɛ sɛ efi ase wɔ Latin nkyerɛwde alphapet ('a'-'z' ne 'A'-Z'). - Substring a ɛwɔ dot no akyi no, ɛsɛ sɛ ɛyɛ nea edidi so yi mu baako: ['txt', 'exe', 'lld'] Mfatoho: file_name_check""{example.txt.
    """"""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

"
"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" Hwɛ sɛ wɔ din a wɔde ato hɔ no mu no, sɛ wɔfa din foforo bi a, ɛbɛn ne ho sen nea wɔaka ho asɛm no.
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    False
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    True
    """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

"
"
def starts_one_ends(n):
    """"""
    Sɛ wɔde positive integer n ma a, ma no nkyerɛ n-digit positive integer a efi ase anaa ewie wɔ 1 no dodow.
    """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def fib4(n: int):
    """"""Fib4 a w'aka no yɛ biribi a ɛte sɛ Fibbonacci a w'aka no sɛ: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Yɛsrɛ wo kyerɛw biribi a wode bɛte n-fa a ɛwɔ fib4 a w'aka no mu.
    >>> fib4(5)
    4
    >>> fib4(6)
    8
    >>> fib4(7)
    14
    """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

"
"

def encode_cyclic(s: str):
    """"""
    de ahyɛnsode a wɔde kyerɛ no ase kɔma no wɔ nkyerɛwde ahorow a ɛwɔ afã ahorow a emu biara yɛ ahyɛnsode ahorow abiɛsa.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

"
"

def get_positive(l: list):
    """"""San kɔfa nnum a ɛwɔ din no mu no nkutoo.
    >>> get_positive([-1, 2, -4, 5, 6])
    [2, 5, 6]
    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    [5, 3, 2, 3, 9, 123, 1]
    """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

"
"
def string_to_md5(text):
    """"""
    Sɛ wɔde 'text' ahoma ama a, fa n'ahoma md5 hash no ma no. Sɛ 'text' yɛ ahoma hunu a, fa None ma no.

    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def get_max_triples(n):
    """"""
    Wama wo akontaahyɛde a ɛyɛ papa n. Ɛsɛ sɛ woyɛ akontaahyɛde a ɛware n. A[y[ biara (1 ‰¤ i ‰¤ n), a[y[ a[y[ = i * i - i + 1. Fa a[y[ a[y[, a[j], a[k]) a a[y[ a[y[ a[y[ a[y[ a[y[ a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y
    """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
"
"
def choose_num(x, y):
    """"""Saa adwuma yi fa akontabuo a ɛyɛ papa x ne y na ɛde akontabuo a ɛkorɔn paa a ɛgyina hɔ ma [x, y] a ne nyinaa ka ho no ma. Sɛ akontabuo a ɛte saa nni hɔ a, ɛnde ɛsɛ sɛ adwuma no de -1. Sɛ nhwɛso: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1
    """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

"
"
def int_to_mini_roman(number):
    """"""
    Sɛ wode ɔkra a ɛgyina hɔ ma no ma a, fa Roman numerals a ɛne no yɛ pɛ sɛ string, na fa no to hɔ ma no. Nhyɛso: 1 <= num <= 1000 Nhwɛso:
    >>> int_to_mini_roman(19) == 'xix'
    >>> int_to_mini_roman(152) == 'clii'
    >>> int_to_mini_roman(426) == 'cdxxvi'
    """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"from typing import List


def sort_numbers(numbers: str) -> str:
    """""" Deɛ wɔde aba no yɛ nsɛso a wɔde atwerɛ a ɛsi nsɛsoɔ a ɛsi nsɛsoɔ kɔsi nsɛsoɔ. Nkyerεkyerεmu a ɛfata ne nsɛsoɔ, baako, mmienu, mmiɛnsa, anan, anum, nsia, nson, nwɔtwe ne nkron. De nsɛsoɔ a ɛsi nsɛsoɔ kɔsi akɛseɛ no na ɛsan ba.
    >>> sort_numbers('three one five')
    'one three five'
    """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
"
"
def is_bored(S):
    """"""
    Wobɛma wo nsɛmfua a ɛwɔ hɔ, na w'adwuma ne sɛ wobɛkan nsɛmfua a ɛhaw wo no. Sɛ asɛmfua a ɛhaw wo yɛ asɛmfua a efi ase ""me"". Nsɛmfua no mu no, wɔde '.', '?' anaa '!' na ɛtwa ho. Sɛ nhwɛso:
    >>> is_bored(""Hello world"")
    0
    >>> is_bored(""The sky is blue. The sun is shining. I love this weather"")
    1
    """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """""" Saa adwuma yi mu no, nea ɛwɔ mu ne sɛ, ɔfã biara a ɛwɔ mu no, ɔfã biara a ɛwɔ mu no, wɔayi no afi mu. Wo botae ne sɛ wobɛpae saa akuw no mu ayɛ no ɔfã biara na woayi wɔn mu no nyinaa.
    >>> separate_paren_groups('( ) (( )) (( )( ))')
    ['()', '(())', '(()())']
    """"""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
"
"
def Strongest_Extension(class_name, extensions):
    """"""Wobɛhu class (a string) din ne extensions. Sɛ wɔde extensions no bɛhyɛ class no mu a, wobɛhu sɛ: ma CAP nyɛ nkyerɛwde akɛseɛ a ɛwɔ extension no din mu, na ma SM nyɛ nkyerɛwde nketewa a ɛwɔ extension no din mu, na ɛno na ɛkyerɛ sɛnea asɛmfua CAP - SM yɛ den. Ɛsɛ sɛ wuhu className.StrongestExtensionName. Sɛ wowɔ extensions mmienu anaa nea ɛboro saa a, ɛsɛ sɛ wofa nea edi kan wɔ list no mu. Sɛ nhwɛso, sɛ wɔde ""Slices"" ama wo sɛ class ne extensions no din: ['SEviviRNGSliCes', 'Cheese', 'StuFfed'] a, ɛsɛ sɛ wo san 'Slices.SEviRNGSliCes' na 'SviRNGSliCes' na ɛkyerɛ sɛnea ɛyɛ den, efisɛ extension no yɛ strong
    """"""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
"
"from typing import List


def below_zero(operations: List[int]) -> bool:
    """""" Woama wo sika a wode bɛtwe ne nea wode bɛtwe wɔ bank account a ebedu no na ne nyinaa fi ase no. Wo adwuma ne sɛ wobɛhu sɛ bere bi mu no account no balance no so atew a, na saa bere no ɛsɛ sɛ function no san true. Sɛ ɛnte saa a ɛsɛ sɛ san false.
    >>> below_zero([1, 2, 3])
    False
    >>> below_zero([1, 2, -4, 5])
    True
    """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
"
"
def strange_sort_list(lst):
    '''
    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.

    Examples:
    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    strange_sort_list([]) == []
    '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def pluck(arr):
    """"""
    ""Sɛ wode ɔfã bi a ɛkyerɛ dua bi a ɛwɔ ntini a ɛnnyɛ negative wɔ hɔ a, wo adwuma ne sɛ wobɛyi ntini no baako na woayi no. Sɛ wohu ntini a ɛboro so a ɛkura akatua ketewaa bi a, fa nea ɛkura akatua ketewaa bi no ma no. Sɛ wohu ntini a ɛkura akatua ketewaa bi a, fa nea ɛkura akatua ketewaa bi no ma no. Sɛ akatua ketewaa bi nni hɔ anaa nea wɔde ama no yɛ hwee a, fa nea ɛwɔ akatua ketewaa bi mu no ma no. Mfatoho 1: Akwankyerɛ: [4,2,3] Akwankyerɛ: [2, 1] Nkyerɛkyerɛmu: 2 yɛ akatua ketewaa bi, na 2 yɛ akatua ketewaa bi. Mfatoho 2: Akwankyerɛ: [1,2,3] Akwankyerɛ: [2, 1] Nkyerɛkyerɛmu: 2 yɛ akatua ketewaa
    """"""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

"
"
def will_it_fly(q,w):
    '''
    Write a function that returns True if the object q will fly, and False otherwise.
    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.

    Example:
    will_it_fly([1, 2], 5) â -> False 
    # 1+2 is less than the maximum possible weight, but it's unbalanced.

    will_it_fly([3, 2, 3], 1) â -> False
    # it's balanced, but 3+2+3 is more than the maximum possible weight.

    will_it_fly([3, 2, 3], 9) â -> True
    # 3+2+3 is less than the maximum possible weight, and it's balanced.

    will_it_fly([3], 5) â -> True
    # 3 is less than the maximum possible weight, and it's balanced.
    '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

"
"
def count_upper(s):
    """"""
    Sɛ wɔde string s ma a, ka ɛnne akɛseɛ a ɛwɔ ntwerɛeɛ a emu yɛ pɛ mu. Sɛ nhwɛso: count_upper (('aBCdEf') de 1 count_upper (('abcdefg') de 0 count_upper (('dBBE') de 0
    """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def right_angle_triangle(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return True if the three
    sides form a right-angled triangle, False otherwise.
    A right-angled triangle is a triangle in which one angle is right angle or 
    90 degree.
    Example:
    right_angle_triangle(3, 4, 5) == True
    right_angle_triangle(1, 2, 3) == False
    '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

"
"
def count_up_to(n):
    """"""تطبيق دالة كتأخذ رقم صحيح غير سلبي وترجع صف من أول n أرقام صحيحة هي أرقام أولية وأقل من n. على سبيل المثال: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]
    """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

"
"

def prime_fib(n: int):
    """"""
    prime_fib يعيد الرقم n-th وهو رقم فيبوناتشي وهو أيضاً عدد أولي.
    >>> prime_fib(1)
    2
    >>> prime_fib(2)
    3
    >>> prime_fib(3)
    5
    >>> prime_fib(4)
    13
    >>> prime_fib(5)
    89
    """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

"
"

def sum_to_n(n: int):
    """"""sum_to_n هي دالة تجمع الأرقام من 1 إلى n.
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
    """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

"
"

def largest_divisor(n: int) -> int:
    """""" بالنسبة لعدد معين n، اعثر على أكبر عدد يقسم n بالتساوي، أصغر من n
    >>> largest_divisor(15)
    5
    """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
"
"
def is_sorted(lst):
    '''
    Given a list of numbers, return whether or not they are sorted
    in ascending order. If list has more than 1 duplicate of the same
    number, return False. Assume no negative numbers and only integers.

    Examples
    is_sorted([5]) â -> True
    is_sorted([1, 2, 3, 4, 5]) â -> True
    is_sorted([1, 3, 2, 4, 5]) â -> False
    is_sorted([1, 2, 3, 4, 5, 6]) â -> True
    is_sorted([1, 2, 3, 4, 5, 6, 7]) â -> True
    is_sorted([1, 3, 2, 4, 5, 6, 7]) â -> False
    is_sorted([1, 2, 2, 3, 3, 4]) â -> True
    is_sorted([1, 2, 2, 2, 3, 4]) â -> False
    '''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

"
"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" تصفية قائمة السلاسل اللي فيها واحد السلاسل الفرعية
    >>> filter_by_substring([], 'a')
    []
    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    ['abc', 'bacd', 'array']
    """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
"
"
def by_length(arr):
    """"""
    وبالحاجة للي كايعطي ليك شي صف من الأعداد الصحيحة، خاصك تفرز الأعداد الصحيحة اللي بين 1 و 9، و تغير المصف الناتج، و من بعد تبدل كل رقم باسمها المقابل من ""واحد""، ""اثنين""، ""ثلاثة""، ""أربعة""، ""خمسة""، ""ستة""، ""سبعة""، ""ثمانية""، ""تسعة"". على سبيل المثال: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> ترتيب arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> الرد arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [""تمانية""، ""خمسة""، ""ثلاثة""، ""اثنين""، ""تنين""، ""واحد""، ""واحد""] إذا كان المصف فارغ، يرجع صف فارغ: arr = [] return [] إذا
    """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

"
"
def prod_signs(arr):
    """"""
    تلقيت صف صفوف من الأعداد الصحيحة و خاصك تخلص مجموع الأعداد الصحيحة مضروبة في ناتج كل علامات لكل رقم في المصفوفة، ممثلة ب 1، -1 أو 0. ملاحظة: لا تقدر تخلص أي صفوف لصفوف فارغة.
    >>> prod_signs([1, 2, 2, -4]) == -9
    >>> prod_signs([0, 1]) == 0
    >>> prod_signs([]) == None
    """"""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def minPath(grid, k):
    """"""
    يمكن ليك تبدأ من أي خلية، و في كل خطوة يمكن ليك تتحرك لشي خلايا جيران، و بمعنى آخر، يمكن ليك تتحرك لشي خلايا كايكون ليها حافة. لا يمكن ليك تتحرك خارج من الخلية. يمكن لشي خلايا A (من طول k) تتمثل في أقل من خلايا B (من طول k) إذا بعد ما تصنع القوائم المرتبة للقيم على الخلايا A و B (لنجم نسميها l_stA و l_stB) ، فهي أقل من الخلايا l_stA من الناحية اللكسيغرافية، و بمعنى آخر، فهي أقل من الخلايا l_stB، و بلمعنى آخر، فهي خلايا كايكون ليها حافة مع خلاياك الحالية. [
    """"""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

"
"

def unique(l: list):
    """"""عاود بالعناصر المفردة المفرقة في القائمة
    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [0, 2, 3, 5, 9, 123]
    """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

"
"
def words_string(s):
    """"""
    غي تتاولك سلسلة من الكلمات مفصولة بالفواصل أو الفراغات. واجبك هو تقسيم السلسلة على كلمات وإرجاع مجموعة من الكلمات. على سبيل المثال: words_string (((""سلا، اسمي جون"") == [""سلا""، ""سما""، ""اسمي""، ""هو""، ""جون""] words_string (((""واحد، جوج، تلاتة، ربعة، خمسة، ستة"") == [""واحد""، ""جوج""، ""تلاتة""، ""ربعة""، ""خمسة""، ""ستة""]
    """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

"
"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

"
"
def search(lst):
    '''
    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    Examples:
        search([4, 1, 2, 2, 3, 1]) == 2
        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
        search([5, 5, 4, 4, 4]) == -1
    '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

"
"

def flip_case(string: str) -> str:
    """""" بالنسبة لسلسلة معينة، حول الحروف الصغيرة للكبيرة والكبيرة للكبيرة.
    >>> flip_case('Hello')
    'hELLO'
    """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
"
"
def is_multiply_prime(a):
    """"""كتب دالة ترجع الصادق إذا كان الرقم المعطى ضرب ل 3 أرقام أولية و كاذبة إلا. مع العلم بلي (أ) أقل من 100.
    """"""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

"
"import math


def poly(xs: list, x: float):
    """"""
    تقييم متعدد الحدود مع معامل xs في النقطة x. العودة xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

"
"

def sum_squares(lst):
    """"""تلقيت قائمة من الأرقام. خاصك تخلص من مجموع الأرقام المربعة في القائمة، وترقيم كل عنصر في القائمة على العدد الفوقي. مثال: ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل
    

    """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def solve(N):
    """"""عند إعطاء عدد صحيح إيجابي N، ارجع مجموع الأرقام في النموذج الثنائي. مثال على N = 1000، مجموع الأرقام سيكون 1، المخرج يجب أن يكون ""1"". على N = 150، مجموع الأرقام سيكون 6، المخرج يجب أن يكون ""110"". على N = 147, مجموع الأرقام سيكون 12، المخرج يجب أن يكون ""1100"". متغيرات: @N عدد صحيح قيود: 0 â‰¤ N â‰¤ 10000. المخرج: سلسلة من الأرقام الثنائية
    """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

"
"

def common(l1: list, l2: list):
    """"""يعيد العناصر المشتركة الفريدة المرتبة لليستين.
    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
    [1, 5, 653]
    >>> common([5, 3, 2, 8], [3, 2])
    [2, 3]

    """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

"
"

def max_element(l: list):
    """"""يعيد الحد الأقصى لليلي يمكن لليلي موجود في القائمة.
    >>> max_element([1, 2, 3])
    3
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    123
    """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
"
"
def compare(game,guess):
    """"""كايبان ليك شي شي شيروق ديال النتائج و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و الاختبارات و
    """"""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def split_words(txt):
    '''
    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you
    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
    Examples
    split_words(""Hello world!"") â -> [""Hello"", ""world!""]
    split_words(""Hello,world!"") â -> [""Hello"", ""world!""]
    split_words(""abcdef"") == 3 
    '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
"
"

def fib(n: int):
    """"""ارجع رقم فيبوناتشي التاسع.
    >>> fib(10)
    55
    >>> fib(1)
    1
    >>> fib(8)
    21
    """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

"
"

def largest_prime_factor(n: int):
    """"""ارجع أكبر عامل أولي لـ n. افترض أن n > 1 وليس أولي.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

"
"
def eat(number, need, remaining):
    """"""
    你係一個餓,已經食咗一定數嘅胡卜,但你需要多啲胡卜去完成一日嘅食物.你應該返一個數列 [ 吃完完完食後嘅胡卜總數,食完食後剩返嘅胡卜數 ] 如果剩返嘅胡卜唔夠,你就會食曬剩餘嘅胡卜,但你依然會餓. 例: * eat(5, 6, 10) -> [11, 4] * eat(4, 8, 9) -> [12, 1] * eat(1, 10, 10) -> [11, 0] * eat(2, 11, 5) -> [7, 0] 變量: @number: 整數: 你已經食咗嘅胡卜數. @need:: 整數: 你需要食嘅胡卜數. @remaining:: 整數: 剩餘嘅胡卜數. Constrain: * 0
    """"""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

"
"

def string_sequence(n: int) -> str:
    """""" 返回包含由0到n包含的空间划分的数列.
    >>> string_sequence(0)
    '0'
    >>> string_sequence(5)
    '0 1 2 3 4 5'
    """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
"
"
def x_or_y(n, x, y):
    """"""一个简单的程序,如果n是个素数,它应该返回x的值,否则则应该返回y的值.例如:对于x_or_y{7, 34, 12) == 34对于x_or_y{15, 8, 5) == 5
    
    """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

"
"
def sort_array(array):
    """"""
    给定一组非负数整数,排序后返回给定的数组的副本,如果和 (第一索引值,最后索引值) 是奇数,你会以上升顺序排序给定的数组,或者如果和 (第一索引值,最后索引值) 是偶数,则以下降顺序排序. 注意: *不要改变给定的数组. 例: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0]
    """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

"
"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" 对于给定的输入数列表,计算这个数据集的平均值周围的平均绝对偏差.平均绝对偏差是每个元素与中心点 (在这种情况下的平均值) 之间的平均绝对差异:MAD =平均值.x - x_mean. 例:
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    1.0
    """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

"
"
def fruit_distribution(s,n):
    """"""
    在这个任务中,你会得到一个字符串,表示一个数量的果和子,这些果分布在一个水果篮子里.这个篮子里有果,子和果果.给出代表果和果的总数的字符串和代表篮子里水果总数的整数,返回篮子里果的数量.例如: fruit_distribution""5(果和6个子"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0果和1个子"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2果和3个子"",100) -> 100 - 2 - 3 = 95 fruit_distribution""100果和120) "",1 -> 120 - 100 - 1 = 19
    """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
"
"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """""" 在每两个连续的输入列表元素之间插入一个""分界符""
    >>> intersperse([], 4)
    []
    >>> intersperse([1, 2, 3], 4)
    [1, 4, 2, 4, 3]
    """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
"
"from typing import List


def string_xor(a: str, b: str) -> str:
    """""" 入力係兩個字符串 a 同 b 只包含 1 同 0.喺呢啲輸入嘅字符串上執行二進制 XOR,並將結果返回字符串.
    >>> string_xor('010', '110')
    '100'
    """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
"
"
def smallest_change(arr):
    """"""
    给定一组整数,求出需要更改的元素的最小数量,使得该数组成为平行列.平行列是向后和向前读取相同的数组.在一次更改中,你可以将一个元素更改为任何其他元素.例如: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1,2,3,4,3,2,2]) == 1 smallest_change (([1,2,3,2,1,2,2,1]) == 0
    """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

"
"
def sort_array(arr):
    """"""
    喺呢個 Kata 中,你必須根據二進制表示嘅 1 數排序一個數列嘅非負整數.類似嘅 1 數,要根據十進制數值排序.佢必須係咁執行:
    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]
    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]
    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]
    """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"from typing import List


def sort_numbers(numbers: str) -> str:
    """""" 入力是由""零""到""九""的數字字串. 有效選擇是""零"""",一"""",二"""",三"""",四"""",五"""",六"""",七"""",八""和""九"". 返回從最小到最大排序數字串
    >>> sort_numbers('three one five')
    'one three five'
    """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
"
"
def circular_shift(x, shift):
    """"""轉換整數 x 轉換成一個圓,轉換成右轉換成一個字符串.如果轉換 > 數字數,返回數字數字反轉.
    >>> circular_shift(12, 1)
    ""21""
    >>> circular_shift(12, 2)
    ""12""
    """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def rounded_avg(n, m):
    """"""你有兩個正整數 n 和 m,你的任務是計算從 n 到 m (包括 n 和 m) 的整數的平均數.將答案圓到最近的整數,然後將其轉換為二進制.如果 n 大於 m,返回 -1. 例: rounded_avg ((1, 5) => ""0b11"" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => ""0b1111"" rounded_avg ((20, 33) => ""0b11010""
    """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

"
"

def encode_cyclic(s: str):
    """"""
    返回一個由三個字符組成嘅編碼字符串.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

"
"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" 檢查一下係咪有兩個數字係比數值更近嘅
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    False
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    True
    """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

"
"
def words_in_sentence(sentence):
    """"""
    你得到一個代表句子嘅字串,句子包含幾個用空格隔開嘅單詞,你必須返回一個包含原句子嘅單詞嘅字串,其長度係素數,新字串嘅單詞排序應該係同原句子一樣嘅. Example1: Input: sentence = ""This is a test"" Output: ""is"" Example2: Input: sentence = ""let go for swimming"" Output: ""go for"" 限制: * 1 <= len(sentence) <= 100 *句子只包含字母
    """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

"
"
def compare(game,guess):
    """"""我諗大家都記得當你終於知道某個長期等待嘅事件嘅結果時嘅感覺. 你嗰一刻嘅感覺同想法絕對值得記錄同埋比較. 你嘅任務係決定一個人係咪正確地猜出一系列比賽嘅結果. 你俾咗兩個等長度嘅分數同埋猜測嘅數列,每個索引都顯示一個比賽. 返回一組同樣長度嘅數列,表示每一個猜測嘅差距. 如果佢哋猜得啱,個數值係0,如果唔係,個數值就係猜測同分數之間嘅絕對差異. 例如: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare ((([0,5,0,4,0,1,0,4]]) -> [4,4,0,1,0,6]
    """"""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

"
"

def sort_third(l: list):
    """"""呢個函數會取一個列表 l,並返回一個列表 l',使得在不能被三除的指標中,l' 同 l相同,而在可以被三除的指標中,l 的值等於對應的 l 指數的值,但已被排序.
    >>> sort_third([1, 2, 3])
    [1, 2, 3]
    >>> sort_third([5, 6, 3, 4, 8, 9, 2])
    [2, 6, 3, 4, 8, 9, 5]
    """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

"
"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" 除任何python值的给定列表,只对整数
    >>> filter_integers(['a', 3.14, 5])
    [5]
    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    [1, 2, 3]
    """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
"
"
def is_nested(string):
    '''
    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.

    is_nested('[[]]') â -> True
    is_nested('[]]]]]]][[[[[]') â -> False
    is_nested('[][]') â -> False
    is_nested('[]') â -> False
    is_nested('[[][]]') â -> True
    is_nested('[[]][[') â -> True
    '''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

"
"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" 單純以一個先頭開始嘅字符串來過濾輸入串嘅列表.
    >>> filter_by_prefix([], 'a')
    []
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    ['abc', 'array']
    """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
"
"

def strlen(string: str) -> int:
    """""" 返回给定的字符串的长度
    >>> strlen('')
    0
    >>> strlen('abc')
    3
    """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
"
"
def find_max(words):
    """"""寫一個函數,接受一個字符串列表. 列表包含不同單詞.返回最多獨一無二字符數字的單詞. 如果多個字符串有最多獨一無二字符數字,返回第一個單詞順序. find_max (([""name"""",of"""",string""]) == ""string"" find_max (([""name"""",enam"""",game""]) == ""enam"" find_max (([""aaaaaaa"""",bb"""",cc""]) == """"aaaaaaa""
    """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

"
"

def monotonic(l: list):
    """"""Return True 返回 list 元素是單調地增加或減少.
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

"
"
def string_to_md5(text):
    """"""
    သင်ဝႃႈ လႆႈပၼ် string 'text' ၼႆၸိုင် ၶိုၼ်းဢဝ် md5 hash equivalent string မၼ်းၼၼ်ႉသေ ၶိုၼ်းဢဝ် None

    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def get_max_triples(n):
    """"""
    တူဝ်ၼပ်ႉဢၼ်ပၼ်ဝႆႉၼၼ်ႉ ပဵၼ်တူဝ်ၼပ်ႉတဵမ် ဢၼ်တဵမ်ထူၼ်ႈ n ယဝ်ႉ။ တေလႆႈႁဵတ်း တူဝ်ၼပ်ႉတဵမ်ထူၼ်ႈ ဢၼ်တဵမ်ထူၼ်ႈ a ဢၼ်မီးတၢင်းယၢဝ်း n ၼၼ်ႉယူႇယဝ်ႉ။ တွၼ်ႈတႃႇ i (1 ‰¤ i ‰¤ n) ၵူႈဢၼ်ၼၼ်ႉ ၵႃႈၶၼ် a[i] = i * i - i + 1 ၼၼ်ႉ ၶိုၼ်းပၼ် တူဝ်ၼပ်ႉဢၼ်ပဵၼ် သၢမ်ဢၼ် (a[i], a[j], a[k]) ၶွင် a တီႈဢၼ် i < j < k လႄႈ a[i] + a[j] + a[k] ၼႆႉပဵၼ် တူဝ်ၼမ်ၶွင် 3 ၼၼ်ႉယူႇယဝ်ႉ။ တူဝ်ယၢင်ႇ: Input: n = 5 Output: 1 ၶေႃႈသပ်းလႅင်း: a = [1, 3, 7, 13, 21] ဢၼ်တဵမ်ထူၼ်ႈဢၼ်လဵဝ်ၼႆႉ ပဵၼ် (1, 7, 13) ၼၼ်ႉယဝ်ႉ။
    """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
"
"

def fibfib(n: int):
    """"""တူဝ်ၼပ်ႉ FibFib ၼႆႉ မၼ်းမိူၼ်ၵၼ်တင်း တူဝ်ၼပ်ႉ Fibbonacci ဢၼ်မၵ်းမၼ်ႈဝႆႉၼင်ႇၼႆ: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3 ၶႅၼ်းတေႃႈ တႅမ်ႈပၼ် တူဝ်ဢိင် တႃႇတေၼပ်ႉသွၼ်ႇ တူဝ်ၼပ်ႉ n-th ၶွင် တူဝ်ၼပ်ႉ fibfib ၼၼ်ႉၶႃႈလႄႈ။
    >>> fibfib(1)
    0
    >>> fibfib(5)
    4
    >>> fibfib(8)
    24
    """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

"
"

def largest_divisor(n: int) -> int:
    """""" တွၼ်ႈတႃႇ တူဝ်ၼပ်ႉ n ၼၼ်ႉႁႃ တူဝ်ၼပ်ႉဢၼ်ယႂ်ႇသုတ်း ဢၼ်ၸႅၵ်ႇ n ႁ်ႂႈပဵၼ်ဢၼ်လဵၵ်ႉလိူဝ် n
    >>> largest_divisor(15)
    5
    """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
"
"
def add(lst):
    """"""ပေႃးဝႃႈႁဝ်းပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် ဢၼ်ဢမ်ႇၸႂ်ႈ တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇသုမ်းၼၼ်ႉၼႆ ထႅမ်သႂ်ႇ တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ် ၸိူဝ်းဢၼ်မီးတီႈ တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼၼ်ႉ။ တူဝ်ယၢင်ႇမၼ်းတႄႉ ထႅမ်သႂ်ႇ ([4, 2, 6, 7]) ==> 2 
    """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
"
"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" ၸၼ်ဢဝ် သဵၼ်ႈမၢႆ ဢၼ်ပႃး သဵၼ်ႈမၢႆ ဢၼ်ပၼ်ဝႆႉၼၼ်ႉၵူၺ်း
    >>> filter_by_substring([], 'a')
    []
    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    ['abc', 'bacd', 'array']
    """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
"
"
def words_in_sentence(sentence):
    """"""
    တူဝ်ယၢင်ႇ1: Input: sentence = ""this is a test"" Output: ""is"" Example2: Input: sentence = ""let go for swimming"" Output: ""go for"" Constraints: * 1 <= len(sentence) <= 100 * sentence contains only letters
    """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

"
"import math


def poly(xs: list, x: float):
    """"""
    ထတ်းသၢင်ႈ တူဝ်ၼပ်ႉၶိုၵ်ႉတွၼ်း ဢၼ်မီး တူဝ်ၵုၼ်း xs တီႈ တီႈ x ၼၼ်ႉသေ ၶိုၼ်းဢဝ် xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

"
"

def monotonic(l: list):
    """"""Return True is သဵၼ်ႈမၢႆ ဢၼ်တူဝ်ၼပ်ႉမၼ်း တိူဝ်းၶိုၼ်ႈ ဢမ်ႇၼၼ် လူတ်းယွမ်းမႃး လူၺ်ႈဢမ်ႇမီးလွင်ႈမၵ်းမၼ်း။
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

"
"
def largest_smallest_integers(lst):
    '''
    Create a function that returns a tuple (a, b), where 'a' is
    the largest of negative integers, and 'b' is the smallest
    of positive integers in a list.
    If there is no negative or positive integers, return them as None.

    Examples:
    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)
    largest_smallest_integers([]) == (None, None)
    largest_smallest_integers([0]) == (None, None)
    '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
"
"

def max_element(l: list):
    """"""ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ယႂ်ႇသုတ်း ၼႂ်းသဵၼ်ႈမၢႆၼၼ်ႉ။
    >>> max_element([1, 2, 3])
    3
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    123
    """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
"
"
def count_upper(s):
    """"""
    ပေႃးဝႃႈႁဝ်းပၼ် string s ၼႆၸိုင် ၵဵပ်းဢဝ် တူဝ်လိၵ်ႈတူဝ်မႄႈလိၵ်ႈတူဝ်ယႂ်ႇ ဢၼ်ပႃး တူဝ်ၼပ်ႉၸႅၼ်ႇတူဝ်ၼပ်ႉသွၼ်ႇ တူဝ်ယၢင်ႇမၼ်း: count_upper (('aBCdEf') ၶိုၼ်းပၼ် 1 count_upper (('abcdefg') ၶိုၼ်းပၼ် 0 count_upper (('dBBE') ၶိုၼ်းပၼ် 0
    """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"

def incr_list(l: list):
    """"""သဵၼ်ႈမၢႆ ဢၼ်လႆႈၶိုၼ်းမႃးၼၼ်ႉ မီးဝႆႉ တူဝ်ၼပ်ႉဢၼ်တိူဝ်းလိူဝ်မႃးထႅင်ႈ 1.
    >>> incr_list([1, 2, 3])
    [2, 3, 4]
    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [6, 4, 6, 3, 4, 4, 10, 1, 124]
    """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

"
"
def valid_date(date):
    """"""တေလႆႈတႅမ်ႈပၼ် တူဝ်ဢိင်ဢၼ်တေမၵ်းမၼ်ႈပၼ် ဝၼ်းထီႉ လႄႈ ၶိုၼ်းမိူဝ်း True သင်ဝႃႈ ဝၼ်းထီႉၼၼ်ႉ မၢၼ်ႇမႅၼ်ႈ ပေႃးဢမ်ႇၼၼ် False ဝၼ်းထီႉၼၼ်ႉ မၢၼ်ႇမႅၼ်ႈ သင်ဝႃႈ ပၵ်းပိူင်ဢၼ်ၸွမ်းမႃးၼႆႉ ၵုမ်ႇထူၼ်ႈဝႆႉ: 1. ဝၼ်းထီႉၼၼ်ႉ ဢမ်ႇလႆႈပဵၼ်ဢၼ်ဢမ်ႇမီးတီႈပွင်ႇ 2. ဝၼ်းထီႉၼႆႉ ဢမ်ႇယွမ်း 1 ဢမ်ႇၼၼ် ၼမ်လိူဝ် 31 ဝၼ်း တွၼ်ႈတႃႇ လိူၼ် 1,3,5,7,8,10,12 လႄႈ ဝၼ်းထီႉၼႆႉ ဢမ်ႇယွမ်း 1 ဢမ်ႇၼၼ် ၼမ်လိူဝ် 30 ဝၼ်း တွၼ်ႈတႃႇ လိူၼ် 4,6,9,11 လႄႈ ဝၼ်းထီႉၼႆႉ ဢမ်ႇယွမ်း 1 ဢမ်ႇၼၼ် ၼမ်လိူဝ် 29 တွၼ်ႈတႃႇ လိူၼ် 2. လိူၼ်ထီႉၼႆႉ ဢမ်ႇထုၵ်ႇလီပဵၼ် 1 ဢမ်ႇၼၼ် ၼမ်လိူဝ် 12. ဝၼ်းထီႉၼႆႉ ထုၵ်ႇလီမီးဝႆႉၼႂ်း ပိူင်ၾၢင်: mm-dd-yyyy မိူၼ်ၼင်ႇ: valid_date (('03-11-2000') => true_date (('15-01-2012') => false
    """"""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
"
"
def even_odd_count(num):
    """"""တူဝ်ယၢင်ႇ: even_odd_count (-1) ==> (1, 1) even_odd_count (-12) ==> (1, 2)
    """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

"
"from typing import List


def sort_numbers(numbers: str) -> str:
    """""" ၶေႃႈထၢမ်ဢၼ်လႆႈသႂ်ႇဝႆႉၼႆႉ ပဵၼ်တူဝ်ၼပ်ႉဢၼ်ၸႅၵ်ႇဝႆႉတီႈႁွင်ႈမၼ်းသေ ပဵၼ်တူဝ်ၼပ်ႉဢၼ်တႄႇဢဝ် 'သုၼ်' တေႃႇထိုင် 'သိပ်း' ၼၼ်ႉယဝ်ႉ။ ဢၼ်တေလႆႈလိူၵ်ႈၼၼ်ႉပဵၼ် 'သုၼ်'၊ 'ၼိုင်ႈ'၊ 'သွင်'၊ 'သၢမ်'၊ 'သီႇ'၊ 'ႁႃႈ'၊ 'ႁူၵ်း'၊ 'ၸဵတ်း'၊ 'ဢဵတ်း' လႄႈ 'သိပ်း' ၸိူဝ်းၼႆႉယဝ်ႉ။ ၶိုၼ်းဢဝ်တူဝ်ၼပ်ႉဢၼ်ၸႅၵ်ႇဝႆႉတီႈလဵၵ်ႉသုတ်း တေႃႇထိုင် ဢၼ်ယႂ်ႇသုတ်းသေ ၶိုၼ်းဢဝ်တူဝ်ၼပ်ႉဢၼ်မီးတီႈၼႂ်းတူဝ်ၼပ်ႉၼၼ်ႉ လၢႆႈပၼ်ၶိုၼ်းယဝ်ႉ။
    >>> sort_numbers('three one five')
    'one three five'
    """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
"
"

def add(x: int, y: int):
    """"""ထႅမ်သႂ်ႇတူဝ်ၼပ်ႉ x လႄႈ y သွင်တူဝ်
    >>> add(2, 3)
    5
    >>> add(5, 7)
    12
    """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

"
"
def histogram(test):
    """"""ပေႃးဝႃႈ လႆႈပၼ် string ဢၼ်တႅၼ်းတၢင် တူဝ်လိၵ်ႈ ဢၼ်ၸႅၵ်ႇဝႆႉ တီႈၵႄႈ ၶွင်ႈၵႄႈ ၶွင်ႈၼၼ်ႉၼႆ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ် ၼမ်သေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈ ဢၼ်လႆႈႁၼ်

    """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

"
"
def do_algebra(operator, operand):
    """"""
    လွင်ႈႁဵတ်းသၢင်ႈ algebra ဢၼ်လမ်ႇလွင်ႈမၼ်းတႄႉ ပဵၼ် လွင်ႈထႅမ်သႂ်ႇ (+) လွင်ႈထွၼ် (-)) လွင်ႈၵုၼ်း (*) လွင်ႈၸႅၵ်ႇၽႄ (/) လွင်ႈတႅၵ်ႈ တူဝ်တႅၼ်း (**) တူဝ်ယၢင်ႇ: လွင်ႈႁဵတ်းသၢင်ႈ operator['+', '*', '-'] array = [2, 3, 4, 5] result = 2 + 3 * 4 - 5 => result = 9 ၶေႃႈတွင်း: တၢင်းယၢဝ်း list of operator ၼႆႉ မိူၼ်တၢင်းယၢဝ်း list of operand minus one ဢၼ်လမ်ႇလွင်ႈမၼ်းတႄႉ ပဵၼ် တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမီး တူဝ်ထွၼ်ၼၼ်ႉ Operator ၼၼ်ႉ မီး operator ဢၼ်လမ်ႇလွင်ႈမၼ်း 1 ဢၼ် လႄႈ list of operand ၼၼ်ႉ မီး operands ဢၼ်လမ်ႇလွင်ႈမၼ်း 2 ဢၼ် Operand ၼၼ်ႉမီး 2 ဢၼ် Operand ၼၼ်ႉမီး 1 ဢၼ် Operand ၼၼ်ႉမီး 1 ဢၼ် Operand ၼၼ်ႉမီး 2 ဢၼ် Operand ၼၼ်ႉမီး 1 ဢၼ် Operator ၼၼ်ႉမီး 1 ဢၼ် Operand ၼၼ်ႉမီး 2 ဢၼ် Operand ၼၼ်ႉမီး 2 ဢၼ် Oper

    """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def Strongest_Extension(class_name, extensions):
    """"""ပေႃးဝႃႈႁဝ်းလႆႈပၼ်ၸိုဝ်ႈ class (string) လႄႈ သဵၼ်ႈမၢႆ extension မၼ်းၼႆၸိုင် တေလႆႈၸႂ်ႉ extension မၼ်းသေ တၢင်ႇပၼ် class တၢင်ႇဢၼ်။ ႁႅင်း extension မၼ်းၼႆႉ တေလႆႈမိူၼ်ၼင်ႇ CAP ပဵၼ်တူဝ်လိၵ်ႈ တူဝ်ယႂ်ႇ ၼႂ်းၸိုဝ်ႈ extension မၼ်းလႄႈ SM ပဵၼ်တူဝ်လိၵ်ႈ တူဝ်လဵၵ်ႉ ၼႂ်းၸိုဝ်ႈ extension မၼ်းၼႆ တေလႆႈၸႂ်ႉ တူဝ်ၸႅၵ်ႇ CAP - SM သေ တၢင်ႇပၼ်။ တေလႆႈႁႃ တူဝ်ၸႅၵ်ႇဢၼ်ႁႅင်းသေပိူၼ်ႈသေ ၶိုၼ်းဢဝ် string ဢၼ်မိူၼ်ၼင်ႇ ClassName.StrongestExtensionName ၼႆႉသေ တၢင်ႇပၼ်။ ပေႃးဝႃႈ မီးတူဝ်ၸႅၵ်ႇဢၼ်ႁႅင်းမိူၼ်ၵၼ် သွင်ဢၼ်ၼႆ တေလႆႈလိူၵ်ႈ တူဝ်ၸႅၵ်ႇဢၼ်ဢွၵ်ႇမႃး ဢွၼ်တၢင်းသုတ်း ၼႂ်းသဵၼ်ႈမၢႆၼၼ်ႉ။ တူဝ်ယၢင်ႇမၼ်း သင်ဝႃႈႁဝ်းလႆႈပၼ် ""Slices"" မိူၼ်ၼင်ႇ class လႄႈ သဵၼ်ႈမၢႆ extension: ['SEviviRNGSliCes', 'Cheese', 'StuFfed'] ၼႆ တေလႆႈၶိုၼ်းဢဝ် 'Slices.SEviRNGSliCes'
    """"""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
"
"
def get_closest_vowel(word):
    """"""သင်ဝႃႈႁဝ်းလႆႈၶေႃႈၵႂၢမ်းၼႆ ၼႃႈၵၢၼ်ႁဝ်းၼႆႉ တေလႆႈႁႃ တူဝ်လိၵ်ႈတူဝ်ၸဝ်ႉ ဢၼ်ၸမ်သုတ်း ဢၼ်ယူႇၼႂ်းၵႄႈ တူဝ်သွၼ်ႉ သွင်တူဝ် ၽၢႆႇၶႂႃ ၶေႃႈၵႂၢမ်း (တူဝ်ဢၼ်ၸမ်သုတ်း) တူဝ်လိၵ်ႈတူဝ်ၸဝ်ႉ တီႈတႄႇလႄႈ တူဝ်ဢၼ်ၸမ်သုတ်း ဢမ်ႇလႆႈၼပ်ႉသွၼ်ႇ သင်ဝႃႈႁဝ်းဢမ်ႇလႆႈ တူဝ်လိၵ်ႈတူဝ်ၸဝ်ႉ ဢၼ်လႆႈမၵ်းမၼ်ႈဝႆႉၽၢႆႇၼိူဝ်ၼႆ တေလႆႈၶိုၼ်း တူဝ်လိၵ်ႈဢၼ်ဢမ်ႇမီးတူဝ်ၼၼ်ႉၼႆ တူဝ်ယၢင်ႇ: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" (((ab"") ==> """"
    """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"

def fib4(n: int):
    """"""တူဝ်ၼပ်ႉ Fib4 ၼႆႉ မၼ်းမိူၼ်ၵၼ်တင်း တူဝ်ၼပ်ႉ Fibbonacci ဢၼ်မၵ်းမၼ်ႈဝႆႉၼင်ႇၼႆ fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). ၶႅၼ်းတေႃႈ တႅမ်ႈပၼ် တူဝ်ဢိင်ဢၼ်တေၼပ်ႉသွၼ်ႇလႆႈ တူဝ်ၼပ်ႉ n-th ၶွင် တူဝ်ၼပ်ႉ fib4 ၼၼ်ႉၶႃႈလႄႈ။ ယႃႇပေၸႂ်ႉတိုဝ်း လွင်ႈၶိုၼ်းတႄႇ။
    >>> fib4(5)
    4
    >>> fib4(6)
    8
    >>> fib4(7)
    14
    """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

"
"

def correct_bracketing(brackets: str):
    """""" brackets ၼႆႉပဵၼ် string ဢၼ်ပႃးဝႆႉ ""<"" လႄႈ "">"" ၼႆသေ သင်ဝႃႈ bracket ဢၼ်ပိုတ်ႇဝႆႉၼၼ်ႉ မီး bracket ဢၼ်ဢိုတ်းဝႆႉၼၼ်ႉၼႆ return True။

    >>> correct_bracketing(""<"")
    False
    >>> correct_bracketing(""<>"")
    True
    >>> correct_bracketing(""<<><>>"")
    True
    >>> correct_bracketing(""><<>"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

"
"

def skjkasdkd(lst):
    """"""တူဝ်ယၢင်ႇမၼ်းတႄႉ ပေႃးတူဝ်ၼပ်ႉ lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] ၼႆၸိုင် တေလႆႈဢွၵ်ႇ 10 တူဝ် ပေႃးတူဝ်ၼပ်ႉ lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] ၼႆၸိုင် တေလႆႈဢွၵ်ႇ 25 တူဝ် ပေႃးတူဝ်ၼပ်ႉ lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] ၼႆၸိုင် တေလႆႈဢွၵ်ႇ 13 တူဝ် ပေႃးတူဝ်ၼပ်ႉ lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] ၼႆၸိုင် တေလႆႈဢွၵ်ႇ 11 တူဝ် ပေႃးတူဝ်ၼပ်ႉ lst = [0,81,12,3,21,21] ၼႆၸိုင် တေလႆႈဢွၵ်ႇ 3 တူဝ် ပေႃးတူဝ်ၼပ်ႉ lst = [1,8,1,2,1,7] ၼႆၸိုင် တေလႆႈဢွၵ်ႇ 7 တူဝ် ပေႃးတူဝ်ၼပ်ႉ l
    """"""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
"
"

def sum_squares(lst):
    """"""တူဝ်ယၢင်ႇမၼ်း: တွၼ်ႈတႃႇ lst = [1,2,3] ဢၼ်ဢွၵ်ႇမၼ်းတေလႆႈပဵၼ် 14 တွၼ်ႈတႃႇ lst = [1,4,9] ဢၼ်ဢွၵ်ႇမၼ်းတေလႆႈပဵၼ် 98 တွၼ်ႈတႃႇ lst = [1,3,5,7] ဢၼ်ဢွၵ်ႇမၼ်းတေလႆႈပဵၼ် 84 တွၼ်ႈတႃႇ lst = [1.4,4.2,0] ဢၼ်ဢွၵ်ႇမၼ်းတေလႆႈပဵၼ် 29 တွၼ်ႈတႃႇ lst = [-2.4,1,1] ဢၼ်ဢွၵ်ႇမၼ်းတေလႆႈပဵၼ် 6
    

    """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

"
"from typing import List


def parse_music(music_string: str) -> List[int]:
    """""" මෙම ශ් රිතයට ආදානය වන්නේ සංගීත නෝට්ටු නිරූපණය කරන නූලක් විශේෂ ASCII ආකෘතියකින්. ඔබේ කාර්යය වන්නේ මෙම නූල විග් රහ කර එක් එක් නොපවතින ස්පන්දන ගණනට අනුරූප පූර්ණ සංඛ් යා ලැයිස්තුවක් ලබා දීමයි. මෙන්න පුරාවෘත්තයක්: 'o' - සම්පූර්ණ නෝට්ටුව, ස්පන්දන හතරක් පවතී 'o"" - අර්ධ නෝට්ටුව, ස්පන්දන දෙකක් පවතී '. "" "" - හතරේ නෝට්ටුව, එක් ස්පන්දනයක් පවතී

    >>> parse_music('o o| .| o| o| .| .| .| .| o o')
    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
    """"""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
"
"
def smallest_change(arr):
    """"""
    පූර්ණ සංඛ් යා අරා ලබා දී ඇති විට, අරා පැලින්ඩ් රෝම බවට පත් කිරීම සඳහා වෙනස් කළ යුතු අවම මූලද් රව් ය ගණන සොයා ගන්න. පැලින්ඩ් රෝම අරා යනු එකම ආකාරයකින් පිටුපසට සහ ඉදිරියට කියවන අරා වේ. එක් වෙනස් කිරීමකින් ඔබට එක් මූලද් රව් යයක් වෙනත් ඕනෑම මූලද් රව් යයක් බවට වෙනස් කළ හැකිය. උදාහරණයක් ලෙස: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0
    """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

"
"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """""" ලැයිස්තුවේ දිගම නූල නැවත ලබා දෙන්න. එකම දිගට නූල් කිහිපයක් තිබේ නම් පළමුවැන්න නැවත ලබා දෙන්න. ආදාන ලැයිස්තුව හිස් නම් කිසිවක් නැවත ලබා දෙන්න එපා.
    >>> longest([])

    >>> longest(['a', 'b', 'c'])
    'a'
    >>> longest(['a', 'bb', 'ccc'])
    'ccc'
    """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
"
"
def strange_sort_list(lst):
    '''
    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.

    Examples:
    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    strange_sort_list([]) == []
    '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def total_match(lst1, lst2):
    '''
    Write a function that accepts two lists of strings and returns the list that has 
    total number of chars in the all strings of the list less than the other list.

    if the two lists have the same number of chars, return the first list.

    Examples
    total_match([], []) â -> []
    total_match(['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi']
    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin']
    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi', 'hi']
    total_match(['4'], ['1', '2', '3', '4', '5']) â -> ['4']
    '''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

"
"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """""" ලබා දී ඇති සම්පූර්ණ සංඛ් යා ලැයිස්තුවකින්, අනුක් රමයේ දී ඇති මොහොත දක්වා සොයාගත් උපරිම අංග ලැයිස්තුවක් ජනනය කරන්න.
    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
    [1, 2, 3, 3, 3, 4, 4]
    """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
"
"
def will_it_fly(q,w):
    '''
    Write a function that returns True if the object q will fly, and False otherwise.
    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.

    Example:
    will_it_fly([1, 2], 5) â -> False 
    # 1+2 is less than the maximum possible weight, but it's unbalanced.

    will_it_fly([3, 2, 3], 1) â -> False
    # it's balanced, but 3+2+3 is more than the maximum possible weight.

    will_it_fly([3, 2, 3], 9) â -> True
    # 3+2+3 is less than the maximum possible weight, and it's balanced.

    will_it_fly([3], 5) â -> True
    # 3 is less than the maximum possible weight, and it's balanced.
    '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

"
"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """""" ආදාන ලැයිස්තුවේ සෑම අඛණ්ඩ අංග දෙකක් අතරම ""සීමා මායිම"" අංකයක් ඇතුලත් කරන්න `numbers'
    >>> intersperse([], 4)
    []
    >>> intersperse([1, 2, 3], 4)
    [1, 4, 2, 4, 3]
    """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
"
"
def get_row(lst, x):
    """"""
    ඔබට 2 මාන දත්ත ලබා දී ඇත, නයිට් ලැයිස්තු ලෙස, එය න් යාසයට සමාන ය, කෙසේ වෙතත්, න් යාස මෙන් නොව, සෑම පේළියකටම වෙනස් තීරු ගණනක් අඩංගු විය හැකිය. lst, සහ පූර්ණ සංඛ් යාව x ලබා දී ඇති විට, ලැයිස්තුවේ x පූර්ණ සංඛ් යාව සොයා ගන්න, සහ ත් රිත්ව ලැයිස්තුව ආපසු ලබා දෙන්න, [(x1, y1), (x2, y2)...] සෑම ටුපල් එකක්ම ඛණ්ඩාංකයකි - (පේළිය, තීරු), 0 සිට ආරම්භ වේ. ආරම්භයේ දී අනුකූලතා ඉහළ යන පිළිවෙලට පේළි අනුව වර්ග කරන්න. එසේම, තීරු වල අනුකූලතා පහළ යන පිළිවෙලට පේළි අනුව වර්ග කරන්න. උදාහරණ: get_row [1,
    """"""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def generate_integers(a, b):
    """"""
    ධනාත්මක පූර්ණ සංඛ් යා දෙකක් ලබා දී ඇති විට, a සහ b අතර ඇති සම අංක ඉහළ යන පිළිවෙලට ලබා දෙන්න. උදාහරණයක් ලෙස: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => []
    """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"


def sum_squares(lst):
    """"""මෙම ශ් රිතය පූර්ණ සංඛ් යා ලැයිස්තුවක් ගනී. ලැයිස්තුවේ සියලුම ප් රවේශයන් සඳහා, ශ් රිතය එහි දර්ශකය 3 ක ගුණයක් නම් පූර්ණ සංඛ් යා ප් රවේශය වර්ග කළ යුතු අතර එහි දර්ශකය 4 ක ගුණයක් නම් පූර්ණ සංඛ් යා ප් රවේශය ඝන කරයි. ශ් රිතය ලැයිස්තුවේ ප් රවේශයන් වෙනස් නොකරනු ඇත. එහි දර්ශක 3 හෝ 4 ක ගුණයක් නොවේ. එවිට ශ් රිතය සියලුම ප් රවේශයන්ගේ එකතුව නැවත ලබා දෙයි. උදාහරණ: lst = [1,2,3] සඳහා ප් රතිදානය 6 විය යුතුය lst = [] සඳහා ප් රතිදානය 0 විය යුතුය lst = [-1,-5,2,-1,-5] සඳහා ප් රතිදානය -126 විය යුතුය
    """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
"
"
def minSubArraySum(nums):
    """"""
    පූර්ණ සංඛ් යා අරා එකක් ලබා දී ඇති විට, හිස් නොවන ඕනෑම උප අරාකයක අවම එකතුව සොයා ගන්න. උදාහරණය minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6
    """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
"
"
def decimal_to_binary(decimal):
    """"""ඔබට දශම සංඛ් යා ආකෘතියේ අංකයක් ලබා දෙනු ඇත. ඔබේ කාර්යය එය ද්විමය ආකෘතියට පරිවර්තනය කිරීමයි. ශ් රිතය ද්විමය සංඛ් යාවක් නියෝජනය කරන සෑම අක්ෂරයක්ම සහිත නූලක් ආපසු ලබා දිය යුතුය. නූලෙහි සෑම අක්ෂරයක්ම '0' හෝ '1' වනු ඇත. නූල ආරම්භයේ සහ අවසානයේ 'db' අක්ෂර කිහිපයක් අමතර වනු ඇත. ආකෘතියට උදව් කිරීම සඳහා අමතර අක්ෂර තිබේ. උදාහරණ: decimal_to_binary(15) # ""db1111db"" දශම_to_binary32) # ""db100000db"" ලබා දෙයි
    """"""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def histogram(test):
    """"""අවකාශය වෙන් කරන ලද කුඩා අකුරු නියෝජනය කරන නූලක් ලබා දී ඇති විට, වඩාත්ම පුනරාවර්තනය වන අකුරෙහි ශබ්දකෝෂයක් ආපසු ලබා දෙන්න. අකුරු කිහිපයක් එකම සිදුවීමක් තිබේ නම්, ඒවා සියල්ලම ආපසු ලබා දෙන්න. උදාහරණය: හිස්ටෝග් රෑම් ((('a b c') == {'a': 1, 'b': 1, 'c': 1} හිස්ටෝග් රෑම් ((('a b b a') == {'a': 2, 'b': 2} හිස්ටෝග් රෑම් ((('a b c a b') == {'a': 2, 'b': 2} හිස්ටෝග් රෑම් ((('b b a') == {'b 4}': හිස්ටෝග් රෑම් ((')) == {}

    """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

"
"

def encode_cyclic(s: str):
    """"""
    අක්ෂර 3 කින් යුත් චක් ර කණ්ඩායම් වලින් කේතනය කරන ලද නූල් නැවත ලබා දෙයි.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

"
"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" ලබා දී ඇති ආදාන සංඛ් යා ලැයිස්තුවක් සඳහා, මෙම දත්ත කට්ටලයේ මධ් යම අගය වටා මධ් යම නිරපේක්ෂ අපගමනය ගණනය කරන්න. මධ් යම නිරපේක්ෂ අපගමනය යනු එක් එක් මූලද් රව් යය සහ මධ් යස්ථානයක් අතර සාමාන් ය නිරපේක්ෂ වෙනසයි (මෙම අවස්ථාවේ දී මධ් ය): MAD = සාමාන් ය  x - x_mean  උදාහරණය:
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    1.0
    """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

"
"

def is_palindrome(text: str):
    """"""
    ලබා දී ඇති නූල පාලින්ඩ් රෝම් එකක්දැයි පරීක්ෂා කරයි
    >>> is_palindrome('')
    True
    >>> is_palindrome('aba')
    True
    >>> is_palindrome('aaaaa')
    True
    >>> is_palindrome('zbcd')
    False
    """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

"
"
def digits(n):
    """"""ධනාත්මක පූර්ණ සංඛ් යාවක් n ලබා දී ඇති විට, අමු ඉලක්කම් වල ගුණය ලබා දෙන්න. සියලු ඉලක්කම් සම නම් 0 ලබා දෙන්න. උදාහරණයක් ලෙස: ඉලක්කම් ((1) == 1 ඉලක්කම් ((4) == 0 ඉලක්කම් ((235) == 15
    """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

"
"
def even_odd_palindrome(n):
    """"""
    ධනාත්මක පූර්ණ සංඛ් යාවක් n ලබා දී ඇති විට, සීමාව තුළට වැටෙන සම සහ අමු පූර්ණ සංඛ් යා පාලින්ඩ් රෝම් ගණනක් ඇති ටියුපලයක් ආපසු ලබා දෙන්න. උදාහරණය1: ආදානය: 3 ප් රතිදානය: (1, 2) පැහැදිලි කිරීම: සම පූර්ණ සංඛ් යා පාලින්ඩ් රෝම් 1, 2, 3. ඒවායින් එකක් සම සහ දෙකක් අමු ය. උදාහරණය 2: ආදානය: 12 ප් රතිදානය: (4, 6) පැහැදිලි කිරීම: සම පූර්ණ සංඛ් යා පාලින්ඩ් රෝම් 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. ඒවායින් හතරක් සම සහ 6 අමු ය. සටහන: 1. 1 <= n <= 10^3 2. ටියුපලය පිළිවෙලින් සම සහ අමු පූර්ණ සංඛ් යා පාලින්ඩ් රෝම් ගණන ලබා දී ඇත.
    """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def sort_array(array):
    """"""
    ණ නොවන පූර්ණ සංඛ් යා සමූහයක් ලබා දී ඇති විට, එම සමූහයේ පිටපතක් නැවත ලබා දෙන්න, ඔබ එම සමූහය වර්ධනාත්මකව වර්ග කරයි, එම සමූහය අමුතු නම්, හෝ එය පහළට වර්ග කරයි. සටහන: * ලබා දී ඇති සමූහය වෙනස් නොකරන්න. උදාහරණ: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0]
    """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

"
"
def intersection(interval1, interval2):
    """"""ඔබට කාල පරිච්ඡේද දෙකක් ලබා දී ඇත, එහිදී සෑම කාල පරිච්ඡේදයක්ම පූර්ණ සංඛ් යා යුගලයකි. උදාහරණයක් ලෙස, කාල පරිච්ඡේදය = (ආරම්භය, අවසානය) = (1, 2). ලබා දී ඇති කාල පරිච්ඡේදයන් වසා ඇත, එයින් අදහස් වන්නේ කාල පරිච්ඡේදය (ආරම්භය, අවසානය) ආරම්භය සහ අවසානය යන දෙකම ඇතුළත් බවයි. සෑම ලබා දී ඇති කාල පරිච්ඡේදයක් සඳහාම, එහි ආරම්භය එහි අවසානයට වඩා අඩු හෝ සමාන යැයි උපකල්පනය කෙරේ. ඔබේ කාර්යය වන්නේ මෙම කාල පරිච්ඡේද දෙකේ ඡේදයේ දිග ප් රාථමික සංඛ් යාවක් දැයි තීරණය කිරීමයි. උදාහරණයක් ලෙස, කාල පරිච්ඡේදයන් (1, 3), (2, 4) හි ඡේදයේ දිග (2, 3) වන අතර එහි දිග ප් රාථමික සංඛ් යාවක් නොවේ. ඡේදයේ
    """"""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

"
"
def prime_length(string):
    """"""string එකක් අරගෙන True එකක් ලබා දෙන function එකක් ලියන්න. string එක ප් රයිම් නම් True හෝ False නම් False. උදාහරණ prime_length (අකුරු) == True prime_length (අකුරු) == True prime_length (අකුරු) == True prime_length (අකුරු) == True prime_length (අකුරු) == True prime_length (අකුරු) == True prime_length (අකුරු) == False
    """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

"
"

def add(x: int, y: int):
    """"""x සහ y අංක දෙක එකතු කරන්න
    >>> add(2, 3)
    5
    >>> add(5, 7)
    12
    """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

"
"
def match_parens(lst):
    '''
    You are given a list of two strings, both strings consist of open
    parentheses '(' or close parentheses ')' only.
    Your job is to check if it is possible to concatenate the two strings in
    some order, that the resulting string will be good.
    A string S is considered to be good if and only if all parentheses in S
    are balanced. For example: the string '(())()' is good, while the string
    '())' is not.
    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.

    Examples:
    match_parens(['()(', ')']) == 'Yes'
    match_parens([')', ')']) == 'No'
    '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

"
"
def check_if_last_char_is_a_letter(txt):
    '''
    Create a function that returns True if the last character
    of a given string is an alphabetical character and is not
    a part of a word, and False otherwise.
    Note: ""word"" is a group of characters separated by space.

    Examples:
    check_if_last_char_is_a_letter(""apple pie"") â -> False
    check_if_last_char_is_a_letter(""apple pi e"") â -> True
    check_if_last_char_is_a_letter(""apple pi e "") â -> False
    check_if_last_char_is_a_letter("""") â -> False 
    '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" دبري لنتاي ارق (دري دوا ايليمن) ، مڠاجر ڤمباڠونن لينيار كاو لنتاي ڽواي، جادي ارق يڠ كوريڠ جاوت كاو ٠ ڠن يڠ ڤاليڠ راييك جاوت كاو ١
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
"
"
def search(lst):
    '''
    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    Examples:
        search([4, 1, 2, 2, 3, 1]) == 2
        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
        search([5, 5, 4, 4, 4]) == -1
    '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

"
"
def minSubArraySum(nums):
    """"""
    دبري سابوه ارري انتيڬره نوم، جاوت سوم مينيموم سابوه ارري نوم يڠ هان بيلا. چونتوه minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6
    """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
"
"
def sort_array(arr):
    """"""
    دالم كات اين، كامو ڤرلو منچاري ارري ڤد انتيڬري يڠ هان نڬاتيف برداسركن كاءدأن اونتوق دڤرتيمبڠكن دالم اوردين باينري دالم اوردين مڠورڠ. اونتوق كاءدأن يڠ سام، منچاري برداسركن قدر ديسيمل. كامي ڤرلو ممڤركنلكن لاڬي:
    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]
    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]
    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]
    """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def count_nums(arr):
    """"""
    منوليس فانسي count_nums يڠ مڠڬوناكن ارري انتيڬره دان مروڤاكن ڤڠڬونأن ايليمن يڠ نا سومبڠن ديڬيت > 0. جك اد نومبور نڬاتيف، لالو ديڬيت ڤرتام يڠ دتوقيڽ اكن دتوقي نڬاتيف: چونتوهڽ -123 نا ديڬيت -1, 2، دان 3.
    >>> count_nums([]) == 0
    >>> count_nums([-1, 11, -11]) == 1
    >>> count_nums([1, 1, 2]) == 3
    """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def get_odd_collatz(n):
    """"""
    دڤاودڠ ڤوسيتيف اينتڬري n، مروڤاكن سبواه ليمت يڠ دڤرتوا يڠ دڤرتوا دالم سيکويينس كولاتز. كونچيتر كولاتز اداله كونچيتر دالم ماتماتيك يڠ برتنتڠن دڠن سيکويينس يڠ دڤرتوا دڠن چارا يڠ دڤرتوا: مولا دڠن سموا اينتڬري ڤوسيتيف n. لالو ستياڤ اصطلاح دڤيليه دري سيکويينس يڠ سبلومڽ سڤرتي يڠ دڤرتوا: اڤابيلا سيکويينس سبلومڽ اداله ڤور، سيکويينس يڠ سبلومڽ اداله ڤولس سيکويينس يڠ سبلومڽ اداله 3 كالي سيکويينس ڤور دڤرت
    """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

"
"from typing import List


def concatenate(strings: List[str]) -> str:
    """""" كونكاتينات ليهت ستراين دالم ساتو ستراين
    >>> concatenate([])
    ''
    >>> concatenate(['a', 'b', 'c'])
    'abc'
    """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
"
"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """""" ڤڠاره ڤڠاره اين اداله سورت يڠ مروڤاكن ببراڤ ڬروڤ اونتوق ڤڠاره يڠ دڤرتوان اڬوڠ يڠ دڤرباڬايكن اوليه ڤڠاره. اونتوق ستياڤ ڬروڤ، ڤڠاره ڤڠاره ڤڠاره ڤڠاره يڠ ڤاليڠ دالم. چونتوهڽ (() (()) ممڤوڽاءي ماکسيما دوا ڤڠاره ڤڠاره درڤد ((())) ممڤوڽاءي تيڬ.

    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    [2, 3, 1, 3]
    """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
"
"

def is_prime(n):
    """"""مروڤاكن ڤرنه جاوه جك ڤڽوكوڠ دبريكن، دان ڤڠككوتن لاڬي.
    >>> is_prime(6)
    False
    >>> is_prime(101)
    True
    >>> is_prime(11)
    True
    >>> is_prime(13441)
    True
    >>> is_prime(61)
    True
    >>> is_prime(4)
    False
    >>> is_prime(1)
    False
    """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

"
"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

"
"
def will_it_fly(q,w):
    '''
    Write a function that returns True if the object q will fly, and False otherwise.
    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.

    Example:
    will_it_fly([1, 2], 5) â -> False 
    # 1+2 is less than the maximum possible weight, but it's unbalanced.

    will_it_fly([3, 2, 3], 1) â -> False
    # it's balanced, but 3+2+3 is more than the maximum possible weight.

    will_it_fly([3, 2, 3], 9) â -> True
    # 3+2+3 is less than the maximum possible weight, and it's balanced.

    will_it_fly([3], 5) â -> True
    # 3 is less than the maximum possible weight, and it's balanced.
    '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

"
"
def even_odd_count(num):
    """"""دڤاوڬيت سابوه اينتڬري. مروڤاكن سابوه توڤل يڠ نا ليڠكوڠن ديڬيت ڤون دان ڤون. چونتوه: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2)
    """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

"
"

def count_distinct_characters(string: str) -> int:
    """""" دبري ستراين، جاديكن لي كاراكتر يڠ بربيدا (لاڤركنله كيس) جيه ترماسوق دري
    >>> count_distinct_characters('xyzXYZ')
    3
    >>> count_distinct_characters('Jerry')
    4
    """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
"
"
def digits(n):
    """"""دڤاوڬيت ڤوسيتيف اينتڬر n، مروڤاكن ڤرودوك ديڬيت ڤرڬي. مروڤاكن 0 جك سموا ديڬيت اداله ڤرڬي. چونتوهڽ: ديڬيتس ((1) == 1 ديڬيتس ((4) == 0 ديڬيتس ((235) == 15
    """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

"
"
def any_int(x, y, z):
    '''
    Create a function that takes 3 numbers.
    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
    Returns false in any other cases.
    
    Examples
    any_int(5, 2, 7) â -> True
    
    any_int(3, 2, 2) â -> False

    any_int(3, -2, 1) â -> True
    
    any_int(3.6, -2.2, 2) â -> False
  

    
    '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

"
"
def next_smallest(lst):
    """"""
    اكو دبريكن ليست ڤڠڬمڤوڠن. منوليس فڠسي next_smallest (() يڠ مروڤاكن ايليمن كدوا ڤڠڬمڤوڠن دالم ليست. مروڤاكن نيه جك ايليمن ايت تيدق اد. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == هيڠڬ اد next_smallest (([1, 1]) == هيڠڬ اد
    """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def special_factorial(n):
    """"""فكتوريل برازيلي ددفينيسيكن سيوباڬواي: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! د مان n > 0
    >>> special_factorial(4)
    288

    The function will receive an integer as input and should return the special
    factorial of this integer.
    """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

"
"
def rounded_avg(n, m):
    """"""جك كيت دبري دوا عدد اينتيجر ڤوسيتيف n دان m، دان ڤركارا كيت اداله اونتوق مڠحساب ڤرتڠهن عدد اينتيجر دري n سمڤاي m (تنتوكن n دان m). مڠورونكن جواڤن كڤد عدد اينتيجر يڠ ڤاليڠ كوكوڠ دان مڠورونكن كڤد عدد باينري. جك n لبيه بسر دري m، مڠورونكن -1. چونتوه: rounded_avg ((1، 5) => ""0b11"" rounded_avg ((7، 5) => -1 rounded_avg ((10، 20) => ""0b11"" rounded_avg ((20، 33) => ""0b11010""
    """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

"
"

def derivative(xs: list):
    """""" xs منداكن كوايفيسين ڤولينوم. xs[0] + xs[1] * x + xs[2] * x^2 +.... مروڤاكن دريۏيتات ڤولينوم ڽن دالم بنتوق يڠ سام.
    >>> derivative([3, 1, 2, 4, 5])
    [1, 4, 12, 20]
    >>> derivative([1, 2, 3])
    [2, 6]
    """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

"
"

def same_chars(s0: str, s1: str):
    """"""
    ڤاوچيت جك دوا كات نا حروف يڠ سام.
    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
    True
    >>> same_chars('abcd', 'dddddddabc')
    True
    >>> same_chars('dddddddabc', 'abcd')
    True
    >>> same_chars('eabcd', 'dddddddabc')
    False
    >>> same_chars('abcd', 'dddddddabce')
    False
    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
    False
    """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

"
"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """""" مڠمبيل نومبور ""ديليميتير"" انتارا ستياڤ دوا ايليمن يڠ برتراڠكت دري ليست ڤڠمبيلن ∀نومبور""
    >>> intersperse([], 4)
    []
    >>> intersperse([1, 2, 3], 4)
    [1, 4, 2, 4, 3]
    """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
"
"
def sorted_list_sum(lst):
    """"""منوليس فانسي يڠ منوليس لنتاي سورت سباڬاي ڤاراميتر، مڠحذف سورت يڠ لڠسوڠڽ تيدق بربيذا دريڽ، دان مڽروسيکن سورت يڠ دڤرتوان اݢوڠ دڠن ڤرتنديڠن يڠ دڤرتوان اݢوڠ، سورت ايت سداڠله سباݢاي سورت سورت دان تيدق سباݢاي ارر يڠ دڤرتوان اݢوڠ، دان اي موڠکين ممڤوڽاءي دوڤليکيت. سورت سورت ايت ڤرلو دڤرتوان اݢوڠ دڠن ڤرتنديڠن سورت دڠن ڤرتنديڠن سورت. اڤابيلا دوا ڤرتنديڠن بربيذا، سورت سورت ايت ڤرلو دڤرتنديڠن دڠن
    """"""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

"
"
def is_multiply_prime(a):
    """"""منوليس فانسي يڠ مروڤاكن ڤركمباڠن دري 3 ڤرميت دان فول سهيڠڬ تيدق. چونتوه: is_multiply_prime ((30) == True 30 = 2 * 3 * 5
    """"""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

"
"
def is_nested(string):
    '''
    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.

    is_nested('[[]]') â -> True
    is_nested('[]]]]]]][[[[[]') â -> False
    is_nested('[][]') â -> False
    is_nested('[]') â -> False
    is_nested('[[][]]') â -> True
    is_nested('[[]][[') â -> True
    '''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

"
"

def correct_bracketing(brackets: str):
    """""" brackets اداله ستريڠ ""("" دان "")"". return True اڤابيلا ستياڤ bracket ڤمبوكاين اداله بركاءيتن دڠن bracket ڤمبوكاين.

    >>> correct_bracketing(""("")
    False
    >>> correct_bracketing(""()"")
    True
    >>> correct_bracketing(""(()())"")
    True
    >>> correct_bracketing("")(()"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

"
"
def total_match(lst1, lst2):
    '''
    Write a function that accepts two lists of strings and returns the list that has 
    total number of chars in the all strings of the list less than the other list.

    if the two lists have the same number of chars, return the first list.

    Examples
    total_match([], []) â -> []
    total_match(['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi']
    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin']
    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi', 'hi']
    total_match(['4'], ['1', '2', '3', '4', '5']) â -> ['4']
    '''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

"
"
def prod_signs(arr):
    """"""
    Sa soli vei iko e dua na array ni integers ka o gadreva mo lesu tale na levu ni levu ni integers vakaikuritaki ena ivoli ni ivakatakilakila kece ni naba yadua ena array, ka matataka na 1, -1 se 0.
    >>> prod_signs([1, 2, 2, -4]) == -9
    >>> prod_signs([0, 1]) == 0
    >>> prod_signs([]) == None
    """"""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def is_palindrome(text: str):
    """"""
    Vakasaqara ke sa palindrome na laini ni laini e soli
    >>> is_palindrome('')
    True
    >>> is_palindrome('aba')
    True
    >>> is_palindrome('aaaaa')
    True
    >>> is_palindrome('zbcd')
    False
    """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

"
"
def choose_num(x, y):
    """"""Na cakacaka oqo e taura e rua na naba ni vinaka x kei na y ka sa lesu tale na levu duadua na iwiliwili taucoko ni dinau ka tiko ena na range [x, y] wili kina. Kevaka e sega ni dua na naba vakaoqo, sa na qai lesu tale na cakacaka -1.
    """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

"
"
def select_words(s, n):
    """"""Ni sa soli vei iko e dua na laini s kei na dua na naba ni veika bula n, o sa vakacuruma e dua na cakacaka ka lesu mai e dua na lisi ni vosa mai na laini s ka tiko kina na vakau ni vosa n, me rawa ni ra na basika na vosa oqo ena laini s. Kevaka e lala na laini s na kena ibalebale ni dodonu me lesu mai e dua na lisi lala. Nanuma: o na rawa ni nanuma na laini ni curu e tiko ga na matanivola kei na veitawasei.
    """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

"
"

def same_chars(s0: str, s1: str):
    """"""
    Dikeva mada ke tautauvata na matanivola ena rua na vosa.
    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
    True
    >>> same_chars('abcd', 'dddddddabc')
    True
    >>> same_chars('dddddddabc', 'abcd')
    True
    >>> same_chars('eabcd', 'dddddddabc')
    False
    >>> same_chars('abcd', 'dddddddabce')
    False
    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
    False
    """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

"
"

def sum_squares(lst):
    """"""Sa soli vei iko e dua na lisi ni nabavuni. E gadrevi mo lesu mai na iwiliwili ni nabavuni ena lisi e soli, vakavolivolita na veika yadua ena lisi ki na int e cake ((Ceiling) taumada.
    

    """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def get_odd_collatz(n):
    """"""
    Na vakasama ni Collatz e dua na vakasama ena fika ka baleta e dua na ituvatuva e vakamacalataki vakaoqo: tekivu ena dua na integer ni vinaka n. Sa qai yadua na vosa e rawati mai na vosa e liu me vaka oqo: kevaka e dua na vosa e liu e tautauvata, na vosa ka tarava e dua na veimama ni vosa e liu. Kevaka e dua na vosa e liu e sega ni tautauvata, na vosa ka tarava e 3 na gauna na vosa e liu ka vakuri 1.
    """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def cycpattern_check(a , b):
    """"""Sa soli vei iko e 2 na vosa. E gadrevi mo lesu tale ki na Dina kevaka na ikarua ni vosa se dua vei ira na kena veimau e dua na substring ena imatai ni vosa cycpattern_check (((""abcd"",""abd"") => Lasu cycpattern_check (((""kalou"",""ell"") => Dina cycpattern_check (((""whassup"",""psus"") => Lasu cycpattern_check (((""abab"",""baa"") => Dina cycpattern_check (((""efef"",""eeff"") => Lasu cycpattern_check (((hims"",""simen"") => Dina

    """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

"
"
def iscube(a):
    '''
    Write a function that takes an integer a and returns True 
    if this ingeger is a cube of some integer number.
    Note: you may assume the input is always valid.
    Examples:
    iscube(1) ==> True
    iscube(2) ==> False
    iscube(-1) ==> True
    iscube(64) ==> True
    iscube(0) ==> True
    iscube(180) ==> False
    '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

"
"
def search(lst):
    '''
    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    Examples:
        search([4, 1, 2, 2, 3, 1]) == 2
        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
        search([5, 5, 4, 4, 4]) == -1
    '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

"
"

def pairs_sum_to_zero(l):
    """"""
    pairs_sum_to_zero e taura e dua na lisi ni integers me vaka e dua na curu. e lesu mai na dina kevaka e tiko e rua na iyaya duidui ena lisi ka na levu ni ki na zero, kei na lasu ke sega.
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    False
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    False
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    False
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    True
    >>> pairs_sum_to_zero([1])
    False
    """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

"
"
def file_name_check(file_name):
    """"""Me caka e dua na cakacaka ka taura e dua na laini ka matataka na yaca ni dua na faile, ka lesu mai 'Io' kevaka na yaca ni faile e donu, ka lesu mai 'Sega' kevaka e sega. E dua na yaca ni faile e okati me donu kevaka ka walega kevaka e taucoko na veika oqo: - E sega ni dodonu me sivia na tolu na digidigi ('0'-'9') ena yaca ni faile. - Na yaca ni faile e tiko kina e dua na tikini '.' - Na substring ni bera na tikini e dodonu me sega ni lala, ka tekivu ena dua na ivola mai na na na latin alphapet ('a'-'z' kei na 'A''-Z'). - Na substring ni oti na tikini e dodonu me dua vei ira oqo: ['txt', 'exe', 'lld'] ivakaraitaki: file_name_check""{example
    """"""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

"
"

def triples_sum_to_zero(l: list):
    """"""
    triples_sum_to_zero e taura e dua na lisi ni integers me vaka e dua na curu. e lesu tale na dina kevaka e tiko e tolu na iyaya duidui ena lisi ni iwiliwili ki na zero, kei na lasu ke sega.

    >>> triples_sum_to_zero([1, 3, 5, 0])
    False
    >>> triples_sum_to_zero([1, 3, -2, 1])
    True
    >>> triples_sum_to_zero([1, 2, 3, 7])
    False
    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
    True
    >>> triples_sum_to_zero([1])
    False
    """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

"
"

def remove_vowels(text):
    """"""
    remove_vowels e dua na cakacaka ka taura na wa ka lesu na wa ka sega ni vowels.
    >>> remove_vowels('')
    ''
    >>> remove_vowels(""abcdef\nghijklm"")
    'bcdf\nghjklm'
    >>> remove_vowels('abcdef')
    'bcdf'
    >>> remove_vowels('aaaaa')
    ''
    >>> remove_vowels('aaBAA')
    'B'
    >>> remove_vowels('zbcd')
    'zbcd'
    """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

"
"
def encrypt(s):
    """"""Me caka e dua na cakacaka encrypt ka taura e dua na laini me vaka e dua na kena ivakamacala ka lesu mai e dua na laini encrypted vata kei na matanivola sa veisoliyaki. Na matanivola me na veisoliyaki ena dua na sala me vaka na matanivola sa toso sobu ena rua vakaikuritaki ki na rua na vanua. Kena ivakaraitaki: encrypt (('hi') lesu mai 'lm' encrypt (('asdfghjkl') lesu mai 'ewhjklnop' encrypt (('gf') lesu mai 'kj' encrypt (('et') lesu mai 'ix'
    """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def pluck(arr):
    """"""
    ""Na mataveilawa e dua na tabana ni dua na kau ka tiko kina na sega ni ca na nodes ni integer na nomu itavi me ra digitaka e dua na nodes ka lesu mai. Na nodes ni digitaka e dodonu me na nodes vata kei na lailai sara mada ga na isau. Kevaka e vuqa na nodes vata kei na lailai sara mada ga na isau e kunei lesu mai na nodes ka tiko na lailai sara na ivakatakilakila. Na nodes ni digitaka e dodonu me lesu mai ena dua na lisi, [smallest_value, kena ivakatakilakila ], Kevaka e sega ni dua na isau se na mataveilawa e soli tu, lesu mai []. Kena ivakaraitaki: 1: curu: [4,2,3] Ivakaraitaki: [2, 1] Vakamacala: 2 e tiko na lailai sara mada ga na isau, kei na 2 e tiko na lailai sara na ivakatakilakila. Kena ivakaraitaki
    """"""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

"
"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" Me baleta e dua na lisi ni integers, lesu mai e dua na tuple ka tiko e dua na iwiliwili kei na dua na ivoli ni integers kece ena dua na lisi. e dodonu me tautauvata kei na 0 na iwiliwili lala ka dodonu me tautauvata kei na 1 na iwiliwili lala.
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
"
"

def string_sequence(n: int) -> str:
    """""" Vakalesuya mai e dua na laini e tiko kina na space-delimited na naba tekivu mai na 0 ki na n okati kina.
    >>> string_sequence(0)
    '0'
    >>> string_sequence(5)
    '0 1 2 3 4 5'
    """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
"
"
def special_factorial(n):
    """"""Na Brazil na factoral e vakamacalataki me vaka: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! na vanua e n > 0 Me kena ivakaraitaki:
    >>> special_factorial(4)
    288

    The function will receive an integer as input and should return the special
    factorial of this integer.
    """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

"
"
def closest_integer(value):
    '''
    Create a function that takes a value (string) representing a number
    and returns the closest integer to it. If the number is equidistant
    from two integers, round it away from zero.

    Examples
    >>> closest_integer(""10"")
    10
    >>> closest_integer(""15.3"")
    15

    Note:
    Rounding away from zero means that if the given number is equidistant
    from two integers, the one you should return is the one that is the
    farthest from zero. For Exampleclosest_integer(""14.5"") should
    return 15 and closest_integer(""-14.5"") should return -15.
    '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

"
"
def generate_integers(a, b):
    """"""
    Me soli e rua na integers vinaka a kei na b, lesu tale na digits ni se bera ni yaco ena maliwa ni a kei na b, ena kena ivakarau cake. Kena ivakaraitaki: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => []
    """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"import math


def poly(xs: list, x: float):
    """"""
    E vakadikeva na polynomial vata kei na coefficients xs ena tikina x. lesu xs[0] + xs[1] * x + xs[1] * x ^ 2 +.... xs[n] * x ^ n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

"
"
def maximum(arr, k):
    """"""
    E dua na array ni integer kei na dua na integer vinaka k, lesu mai e dua na lisi ni kena balavu k vata kei na levu duadua na iwiliwili k ena arr. ivakaraitaki1: curu: arr = [-3, -4, 5], k = 3 na isau: [-4, -3, 5] ivakaraitaki2: curu: arr = [4, -4, 4], k = 2 na isau: [4, 4] ivakaraitaki3: curu: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 na isau: [2] Nanuma: 1. na balavu ni na ituvatuva ena tiko ena maliwa ni [1, 1000]. 2. na veika ena na ituvatuva ena tiko ena maliwa ni [-1000, 1000].
    """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

"
"
def count_upper(s):
    """"""
    E dua na laini s, wilika na iwiliwili ni vowels ni uppercase ena na idusidusi ni veibuku. Kena ivakaraitaki: count_upper (('aBCdEf') lesu 1 count_upper (('abcdefg') lesu 0 count_upper (('dBBE') lesu 0
    """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" Oku soneha ulala wovina viosi, ci fetika lika lolondaka vi kuete etendelo ale etendelo lionduko.
    >>> filter_by_prefix([], 'a')
    []
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    ['abc', 'array']
    """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
"
"
def sorted_list_sum(lst):
    """"""Soneha ocimalẽho cimue ci tava okuti ci kuata olondondimbukiso violohaku vialua, pole ka ci kuata olondimbukiso violohaku vialua, kuenda ci pondola oku tiuka londimbukiso ya kapiwa. Ocina caco ci lomboloka okuti, olonjanja viosi o sukila oku soneha olondimbukiso violohaku vialua, pole, lalimue eteke o sukila oku soneha olondimbukiso violohaku vialua. Ondimbukiso yaco yi lekisa okuti, olondaka viosi via kapiwamo vi kuete etendelo limuamue. Nda olondimbukiso viaco vi kuete etendelo limuamue, ci lekisa okuti, olondimbukiso viaco via kapiwa lonjila yimue ya litepa. O pondola oku sima okuti, olondimbukiso viosi vi kuete etendelo limuamue.
    """"""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

"
"
def total_match(lst1, lst2):
    '''
    Write a function that accepts two lists of strings and returns the list that has 
    total number of chars in the all strings of the list less than the other list.

    if the two lists have the same number of chars, return the first list.

    Examples
    total_match([], []) â -> []
    total_match(['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi']
    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin']
    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi', 'hi']
    total_match(['4'], ['1', '2', '3', '4', '5']) â -> ['4']
    '''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

"
"

def triples_sum_to_zero(l: list):
    """"""
    triples_sum_to_zero yi tambula ulala wolonduko viosi. yi tiuka lika nda kuli olonduko vitatu via litepa vi kuete ulala wolonduko viosi, kuenje yi tiuka lika nda kuli olonduko vitatu via litepa vi kuete ulala wolonduko viosi.

    >>> triples_sum_to_zero([1, 3, 5, 0])
    False
    >>> triples_sum_to_zero([1, 3, -2, 1])
    True
    >>> triples_sum_to_zero([1, 2, 3, 7])
    False
    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
    True
    >>> triples_sum_to_zero([1])
    False
    """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

"
"
def right_angle_triangle(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return True if the three
    sides form a right-angled triangle, False otherwise.
    A right-angled triangle is a triangle in which one angle is right angle or 
    90 degree.
    Example:
    right_angle_triangle(3, 4, 5) == True
    right_angle_triangle(1, 2, 3) == False
    '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

"
"
def find_max(words):
    """"""Soneha ocindekaise cimue ci tava oku sanga ulala wolonduko via litepa. Ocisonehua ci kuete olondaka via litepa. Tioka londaka yi kuete etendelo liololetala via litepa. Nda ovinimbu vialua vi kuete etendelo liololetala via litepa, tioka londuko ya tete yi sangiwa vocisonehua.
    """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

"
"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

"
"from typing import List


def factorize(n: int) -> List[int]:
    """""" Ocicapa ci lekisa etendelo liolohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violo
    >>> factorize(8)
    [2, 2, 2]
    >>> factorize(25)
    [5, 5]
    >>> factorize(70)
    [2, 5, 7]
    """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
"
"
def odd_count(lst):
    """"""Nda tua sanga ulala wolondimbukiso okuti, vovikanda viaco mu sangiwa lika olonduko, tu sukila oku soneha onduko yaco, kuenda etendelo lionduko yaco.

    >>> odd_count(['1234567'])
    [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
    >>> odd_count(['3',""11111111""])
    [""the number of odd elements 1n the str1ng 1 of the 1nput."",
     ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
    """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def words_string(s):
    """"""
    O pondola oku sanga olondaka via litepa vovinimbu vimue, kuenje o sukila oku vi pitulula. O pondola oku sanga olondaka via litepa vovinimbu vialua, oku vi pitulula, kuenda oku vi soneha oco vi ku kuatise.
    """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

"
"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" Oku pitamo kuetendelo limue lia tukuiwa, ci lekisa oku litepa ku kasi pokati ketendelo liaco kuenda etendelo liosimbu.
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    1.0
    """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

"
"
def strange_sort_list(lst):
    '''
    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.

    Examples:
    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    strange_sort_list([]) == []
    '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def prime_length(string):
    """"""Soneha ocindekaise cimue ci lekisa etendelo liololetala kuenda o tiuka londuko ya True nda etendelo liaco li kuete etendelo liokaliye ale False nda etendelo liaco ka li kuete etendelo liokaliye.
    """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

"
"

def same_chars(s0: str, s1: str):
    """"""
    Kũlĩhĩsa nda olondaka viaco vivali vi kuete elomboloko limuamue.
    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
    True
    >>> same_chars('abcd', 'dddddddabc')
    True
    >>> same_chars('dddddddabc', 'abcd')
    True
    >>> same_chars('eabcd', 'dddddddabc')
    False
    >>> same_chars('abcd', 'dddddddabce')
    False
    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
    False
    """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

"
"
def get_max_triples(n):
    """"""
    O pondola oku sanga ocimalẽho cimue ci lekisa etendelo liolohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa
    """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
"
"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" Sanda oku kũlĩhĩsa nda volonduko violo atendelo mua kongela atendelo avali a velapo okuti etendelo liaco ka li sokisiwa.
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    False
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    True
    """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

"
"
def x_or_y(n, x, y):
    """"""O programa yimue ya leluka yi sukila oku tiula ondando y y nda n yi kuete etendelo liokaliye kuenda yi sukila oku tiula ondando y y nda ka ci tẽliwa.
    
    """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

"
"
def sort_array(array):
    """"""
    Nda wa sanga etendelo limue liosimbu, o sukila oku li soneha velimi lio Helasi. * Nda wa sanga etendelo liokaliye, o sukila oku li soneha velimi lio Helasi.
    """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

"
"
def compare_one(a, b):
    """"""
    Seteka oku linga ondimbukiso yimue yi lekisa etendelo liololetala, ale olondimbukiso vikuavo vi lekisa etendelo liociña cimue, kuenje o tioka kondimbukiso ya velapo.
    """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def count_upper(s):
    """"""
    Nda ocimalẽho cimue ci kuete ocimalẽho cimuamue, tenda etendelo liololetala vinene vi kuete olonduko via litepa.
    """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def hex_key(num):
    """"""Olio li tukula etendelo li soka 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Olombinga viatete vi lomboloka 2, 3, 5, 7, 11, 13, 17,... Omo liaco, o sukila oku nõla etendelo liolombinga vikuãimo: 2, 3, 5, 7, B (= ocimalẽho 11), D (= ocimalẽho 13). Ivaluka okuti: O pondola oku sima okuti ocimalẽho ci kasi ciwa ale ka ci kasi ciwa, kuenda olondimbukiso A,B,C,D,E,F, vi kasi ño londaka yitito.
    """"""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

"
"
def cycpattern_check(a , b):
    """"""O sukila oku tiuka ku True nda ondaka yavali ale oku ñualapo kuayo ku kuete ocimalẽho cimue ci kasi vocinimbu catete. cycpattern_check{""abcd"",""abd"") => False cycpattern_check{""hello"",""ell"") => True cycpattern_check{""whassup"",""psus"") => False cycpattern_check{""abab"",""baa"") => True cycpattern_check{""efef"",""eeff"") => False cycpattern_check{""hims"",""simen"") => True

    """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

"
"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """""" Ocimunga ci kuete atosi a litepa a kapiwa vocinimbu cimue ale vovinimbu vimue, kuenje o ci kapa vocinimbu cimue ale vovinimbu vimue.

    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    [2, 3, 1, 3]
    """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
"
"
def add_elements(arr, k):
    """"""
    Nda tua sanga etendelo limue ka li kuete atendelo osi, tu sukila oku pitulula etendelo liolo atendelo osi a sangiwa ketendelo liatete.
    """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def search(lst):
    '''
    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    Examples:
        search([4, 1, 2, 2, 3, 1]) == 2
        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
        search([5, 5, 4, 4, 4]) == -1
    '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

"
"
def words_string(s):
    """"""
    ""Təmaɗ ənes eqal asikin ən magrad ənes dǎɣ magrad əd asikin ənes dǎɣ magrad əd asikin ənes dǎɣ magrad. "" """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

"
"

def is_prime(n):
    """"""Awen eqqal tiditt a fal iddikud eqqal a ezzaran tolas war eqqel tiditt a fal wadden
    >>> is_prime(6)
    False
    >>> is_prime(101)
    True
    >>> is_prime(11)
    True
    >>> is_prime(13441)
    True
    >>> is_prime(61)
    True
    >>> is_prime(4)
    False
    >>> is_prime(1)
    False
    """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

"
"

def remove_vowels(text):
    """"""
    remove_vowels eqqal alxidmăt ta taj string tolas t asilmad string wala vowels
    >>> remove_vowels('')
    ''
    >>> remove_vowels(""abcdef\nghijklm"")
    'bcdf\nghjklm'
    >>> remove_vowels('abcdef')
    'bcdf'
    >>> remove_vowels('aaaaa')
    ''
    >>> remove_vowels('aaBAA')
    'B'
    >>> remove_vowels('zbcd')
    'zbcd'
    """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

"
"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

"
"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" Ye assəkən atiwəjan ən maɗinan ən ijji, assəkən ən assəməsədu iknan ɣor amək ən amək ən assərtay ən ilavitan. Assəməsədu iknan eqal aməgrad iknan jar haratən kul ad edag ən amək (adəkən dǎɣ edag wen): MAD = amək. x - x_mean. Almital:
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    1.0
    """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

"
"
def numerical_letter_grade(grades):
    """"""Eqal aynayan əsim ən semestre əd emagare ilzam ye ihuk ən edanatan. Emagare iga algorithme ənes fal igi ən edan. Ašahat iyan eqal as taqal ayfan əmik wa eqalan amitkalan fal igi ən edanatan. Iha aliɣi ən GPAs fal iyad emagaran əd ilzam adiqil ayktaban əšiɣil wa adobat adiqil aliɣi ən edanatan ən əliɣitan dǎɣ amitkal ən tabarat taqalat: GPA. Əliɣitan ən əliɣitan 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: alɣisab ən edanatan (..) [4.0, 3, 1.7, 2, 3.5]) ==> ['
    """"""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def special_factorial(n):
    """"""Brazilian factorial eqqal: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! ɣur n > 0 almital:
    >>> special_factorial(4)
    288

    The function will receive an integer as input and should return the special
    factorial of this integer.
    """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

"
"
def decimal_to_binary(decimal):
    """"""""Aqalan atiwafan imaɗinan dǎɣ əmik ən déəimal əd əšiɣil iness eqal asimililiy ənes dǎɣ əmik ən əsin. Ašiɣil adiqil ayfan asisuhu ən əmik, dǎɣ hak əmik eqalan əmik ən əsin. Hak əmik dǎɣ əmik eqalan '0' meɣ '1'. Addobat adiqil ayfan əsin əmik ən 'db' dǎɣ santo əd dǎɣ samando ən əmik. Əmik ən əmik eqalan ayfan fal təmuqunt. Almital: déəimal_to_binary (_15) # asisuhu """"db1111db"""" déəimal_to_binary32) # asisuhu """"db100000db""""
    """"""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" Dǎɣ asikin ən tartit ən haratan ən Python atiwafanen fal entiertan ɣas
    >>> filter_integers(['a', 3.14, 5])
    [5]
    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    [1, 2, 3]
    """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
"
"
def count_up_to(n):
    """"""Awen eqqal alxidmăt ta tajjach nen iddikud n imaɗinan wi azzarnen n eɣaf d wi madroynen n almital: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]
    """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

"
"
def move_one_ball(arr):
    """"""Dǎɣ asikin ən asikin ən haratan kul ən haratan dǎɣ edag iyan dǎɣ almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən almaɣna ən al
                
    """"""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
"
"

def encode_cyclic(s: str):
    """"""
    Isasaɣra əmik ən amsədu ən amsədu ən amsədu ən amsədu ən amsədu ən amsədu ən amsədu ən amsədu ən amsədu ən amsədu.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

"
"
def specialFilter(nums):
    """"""Əlkəttab ən əšiɣil itajən tabəde ən maɗinan sund ijji ən edaj ad assəmədu ən maɗinan ən tabəde ogarnen 10 ad haratan azarnen ad samdo ən maɗinan aqalan amsədu (1, 3, 5, 7, 9). sund specialFilter ([15, -73, 14, -15]) => 1 specialFilter ([33, -2, -3, 45, 21, 109]) => 2
    """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

"
"from typing import List


def all_prefixes(string: str) -> List[str]:
    """""" Isuj win isuj n ismawan win tizarat s tizarat s tizarat n string n asuj
    >>> all_prefixes('abc')
    ['a', 'ab', 'abc']
    """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
"
"
def tri(n):
    """"""Fibonacci eqqal a fal ijja majrad n matematik daɣ iwityan win ušray mucham awa war n issen addinat eqqal Tribonacci Sequence. Tribonacci Sequence eqqal a fal ijja majrad n tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri
    """"""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
"
"

def fizz_buzz(n: int):
    """"""Awen eqqal iddikud n alwaq wa id iddikud n 7 eqqal iddikud n iddikud n addikud andarran n n a tan osaɣnen s 11 meɣ 13
    >>> fizz_buzz(50)
    0
    >>> fizz_buzz(78)
    2
    >>> fizz_buzz(79)
    3
    """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

"
"
def is_nested(string):
    '''
    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.

    is_nested('[[]]') â -> True
    is_nested('[]]]]]]][[[[[]') â -> False
    is_nested('[][]') â -> False
    is_nested('[]') â -> False
    is_nested('[[][]]') â -> True
    is_nested('[[]][[') â -> True
    '''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

"
"

def count_distinct_characters(string: str) -> int:
    """""" Dǎɣ asikin ən esɗan, afənazat maɗinan ən edanən azlaynen (dǎɣ iba ən əmik) ən esɗan
    >>> count_distinct_characters('xyzXYZ')
    3
    >>> count_distinct_characters('Jerry')
    4
    """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
"
"
def valid_date(date):
    """"""Ilzam ad ikteb alxidmat ta tikna amšǝkki n data tolas ad t id isammuti tiditt a fal amšǝkki wen eqqal amšǝkki n data fal war eqqel amšǝkki n data eqqalan amšǝkki n data a fal fal ilzam achareɣa tan win fuk: 1. amšǝkki wan data war eqqel ebas 2. iddikud n awtay war ifnaz fal 1 meɣ ojjar 31 n awtay i awtay wan 1,3,5,7,8,10,12 d iddikud n awtay war ifnaz fal 1 meɣ ojjar 30 n awtay i awtay wan 4,6,9,11 d iddikud n awtay war ifnaz fal 1 meɣ ojjar 29 i awtay wan 2 3. awtay war addobat ad ifnaz fal 1 meɣ ojjar 12 4. amšǝkki wan data ilzam ad eqqil daɣ dumu: mm-dd-
    """"""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
"
"
def compare_one(a, b):
    """"""
    Eqal əšiɣil wa itagan imaɗinan əmdanen, əmik ən təzunawen meɣ əmik ən təzunawen ən haditan əknanen, əd wa isaknen awa ogaran təmɣire dǎɣ əmik ən təzunawen ənes. Winan ila harat afal hadi aqalan ogdahan.
    """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def reverse_delete(s,c):
    """"""""Aqalan atiwafanen əsin əšəɣir s əd c, ilzam ad ekfu əšəɣir kul ən əšəɣir s eqalan ogdahan əd əšəɣir c, izar anhiy as əšəɣir wa eqalan əšəɣir eqal palindrome. əšəɣir eqal asitawan palindrome afal eqalan olahan dǎɣ aśahat əd dǎɣ aśahat. Aśahat adiqil adiqil aykan tuple ahanen əšəɣir wa eqalan əšəɣir əd tidit/tabarat fal asikin. Almital fal s = """"abcde"""", c = """"ae"""", agaraw adiqil (""bcd"""",Tidət) fal s = """"abcdef"""", c = """"b"""" agaraw adiqil (""acdef"""",Tidət) fal s = """"
    """"""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
"
"
def histogram(test):
    """"""A fal eqqal string eha tijililwăyen ti madroynen azzărnen s amădal, isălan ti almaɣna n tijililwăyen ti illanen amătikwi d idăgăn n idăgăn win almaɣna wen. A fal ti illan ti tijililwăyen ajjotnen, isălan ti fuk nasan. almităl: histogram ((a b c) == {'a': 1, 'b': 1, 'c': 1} histogram ((a b b a') == {'a': 2, 'b': 2} histogram ((a b c a b') == {'a': 2, 'b': 2} histogram ((b b a') == {'b 4}: histogram (('a') == {}

    """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

"
"
def find_max(words):
    """"""Əlkəttab ən əšiɣil itajən assərtay ən təzunt ən təzunt.Təzunt təla ismawan abdanen.Əlkəttab ən təzunt ən təzunt ən təzunt ən təzunt ən təzunt ən təzunt ən təzunt ən təzunt ən təzunt ən təzunt.
    """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

"
"
FIX = """"""
Awen eqqal a ehan edag n asidu n isalan
""""""

def vowels_count(s):
    """"""Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
    vowel, but only when it is at the end of the given word.

    Example:
    >>> vowels_count(""abcde"")
    2
    >>> vowels_count(""ACEDY"")
    3
    """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def choose_num(x, y):
    """"""Dǎɣ əšiɣil wen, əmik eqalan əsin maɗinan wi əknanen x əd y əd isaknin ogaran təmɣire amaɗin əmdan dǎɣ tartit [x, y] dǎɣ tartit. Afal wala iyan maɗinan, əšiɣil adiqil aygan -1. sund: aliɣi_imaɗinan 12, 15 = 14 aliɣi_imaɗinan 13, 12 = -1
    """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

"
"
def digits(n):
    """"""أعطيت رقم صحيح موجب n، ارجع ضرب الأرقام الفردية. ارجع 0 إذا كانت جميع الأرقام زوجية. على سبيل المثال: الأرقام ((1) == 1 الأرقام ((4) == 0 الأرقام ((235) == 15
    """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

"
"

def remove_vowels(text):
    """"""
    remove_vowels هو دالة تأخذ السلسلة وتعيد السلسلة بدون حروف علة.
    >>> remove_vowels('')
    ''
    >>> remove_vowels(""abcdef\nghijklm"")
    'bcdf\nghjklm'
    >>> remove_vowels('abcdef')
    'bcdf'
    >>> remove_vowels('aaaaa')
    ''
    >>> remove_vowels('aaBAA')
    'B'
    >>> remove_vowels('zbcd')
    'zbcd'
    """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

"
"
def sort_array(array):
    """"""
    مع مجموعة من الأعداد الصحيحة غير السالبة، ارجع نسخة من المجموعة المحددة بعد الترتيب، ستقوم بترتيب المجموعة المحددة بالترتيب الصاعد إذا كانت المجموعة ((قيمة المؤشر الأولى، القيمة المؤشر الأخيرة) فريدة، أو ترتيبها بالترتيب الهابط إذا كانت المجموعة ((قيمة المؤشر الأولى، القيمة المؤشر الأخيرة) زوجية. ملاحظة: * لا تغير المجموعة المحددة. أمثلة: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5]
    """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

"
"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" لو اعطيت قائمة من الارقام (من عنصرين على الاقل) ، اطلب تحويل خطي على تلك القائمة، بحيث يصبح أصغر رقم 0 والأكبر يصبح 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
"
"
def is_bored(S):
    """"""
    ستعطيك سلسلة كلمات، ومهمتك هي حساب عدد المملات. المملة هي جملة تبدأ بالكلمة ""I"".
    >>> is_bored(""Hello world"")
    0
    >>> is_bored(""The sky is blue. The sun is shining. I love this weather"")
    1
    """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def strlen(string: str) -> int:
    """""" طول العودة للسلسلة المعطاة
    >>> strlen('')
    0
    >>> strlen('abc')
    3
    """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
"
"
def digitSum(s):
    """"""اكتب دالة تأخذ سلسلة كمدخل وتعيد مجموع الحروف العليا فقط' رموز ASCII. أمثلة: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153
    """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

"
"
def encrypt(s):
    """"""اكتب وظيفة تشفير تأخذ سلسلة كحرف وتعيد سلسلة مشفرة مع تدوير الأبجدية. يجب تدوير الأبجدية بطريقة تتحول الحروف إلى أسفل بمضاعفة اثنين إلى مكانين. على سبيل المثال: تشفير ((('hi') يعيد 'lm' تشفير ((('asdfghjkl') يعيد 'ewhjklnop' تشفير ((('gf') يعيد 'kj' تشفير ((('et') يعيد 'ix'
    """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def even_odd_palindrome(n):
    """"""
    مع عدد صحيح موجب n، ارجع توبل يحتوي على عدد من palindromes الصحيحة والغريبة التي تقع في النطاق ((1، n) ، بما في ذلك. مثال1: المدخل: 3 الناتج: (1, 2) التفسير: عدد صحيح هو 1، 2، 3. واحد منهم زوج، واثنين منهم غريب. مثال2: مدخل: 12 الناتج: (4, 6) التفسير: عدد صحيح هو 1، 2، 3، 4، 5، 6، 7، 8، 9، 11. أربعة منهم زوجين، و 6 منهم غريبين. ملاحظة: 1 <= n <= 10^3 2. توبل قد عاد عدد عدد صحيح وفارق بالترتيب.
    """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def is_palindrome(string: str) -> bool:
    """""" اختبار اذا السلسلة المعطاة بالندروم """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """""" Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    >>> make_palindrome('')
    ''
    >>> make_palindrome('cat')
    'catac'
    >>> make_palindrome('cata')
    'catac'
    """"""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
"
"

def car_race_collision(n: int):
    """"""
    تخيل طريق مستقيم جداً. n سيارات تسير من اليسار الى اليمين، وفي نفس الوقت مجموعة مختلفة من n سيارات تسير من اليمين الى اليسار. مجموعتين من السيارات تبدا بعيدة جداً عن بعضها البعض. كل السيارات تتحرك بنفس السرعة. يقال ان سيارتين تتصادم عندما تصطدم سيارة تتحرك من اليسار الى اليمين بسيارة تتحرك من اليمين الى اليسار. ومع ذلك، السيارات قوية الى ما لا نهاية؛ ونتيجة لذلك، فهي تستمر في التحرك في مسارها كما لو لم تتصادم. هذه الدالة تصدر عدد مثل هذه التصادمات.
    """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

"
"
def add(lst):
    """"""مع وجود قائمة غير فارغة من الأعداد الصحيحة، اضف العناصر الزوجية التي في المؤشرات الفردية. 
    """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
"
"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" فلتر القائمة المقدمة من أي قيمة بايثون للأعداد الصحيحة فقط
    >>> filter_integers(['a', 3.14, 5])
    [5]
    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    [1, 2, 3]
    """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
"
"
def by_length(arr):
    """"""
    معطوف على صف من الأعداد الصحيحة، رتب الأعداد الصحيحة التي تتراوح بين 1 و 9، و عكس المصف الناتج، ثم استبدل كل رقم باسمه المقابلة من ""واحد""، ""اثنين""، ""ثلاثة""، ""أربعة""، ""خمسة""، ""ستة""، ""سبعة""، ""ثمانية""، ""تسعة"". على سبيل المثال: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> رتب arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> arr عكس -> [8, 5, 4, 3, 2, 2, 1, 1] return [""ثمانية""، ""أربعة""، ""ثلاثة""، ""اثنين""، ""اثنين""، ""اثنين""، ""واحد""، ""واحد""] إذا كان المصف فارغًا، ارجع صف فارغ: arr = [] return [] إذا كان المصف لديه أي
    """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

"
"
def will_it_fly(q,w):
    '''
    Write a function that returns True if the object q will fly, and False otherwise.
    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.

    Example:
    will_it_fly([1, 2], 5) â -> False 
    # 1+2 is less than the maximum possible weight, but it's unbalanced.

    will_it_fly([3, 2, 3], 1) â -> False
    # it's balanced, but 3+2+3 is more than the maximum possible weight.

    will_it_fly([3, 2, 3], 9) â -> True
    # 3+2+3 is less than the maximum possible weight, and it's balanced.

    will_it_fly([3], 5) â -> True
    # 3 is less than the maximum possible weight, and it's balanced.
    '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

"
"

def sum_to_n(n: int):
    """"""sum_to_n هو دالة تضيف الأرقام من 1 إلى n.
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
    """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

"
"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" لليست المعطى من الأعداد الصحيحة، ارجع توبل يتكون من مجموع ومضاعف لكل الأعداد الصحيحة في القائمة. المجموع الفارغ يجب أن يكون يساوي 0 والمضاعف الفارغ يجب أن يكون يساوي 1.
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
"
"
def find_max(words):
    """"""اكتب دالة تقبل قائمة من السلاسل. القائمة تحتوي على كلمات مختلفة. ارجع الكلمة مع الحد الأقصى لعدد الأحرف الفريدة. إذا كان هناك عدد من السلاسل مع الحد الأقصى لعدد الأحرف الفريدة، ارجع أول حرف في الترتيب المفرد.
    """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

"
"
def get_odd_collatz(n):
    """"""
    مع عدد صحيح مثبت n، ارجع قائمة مرتبة فيها الأرقام الغير عادلة في تسلسل كولاتز. تخمين كولاتز هو تخمين في الرياضيات يتعلق بتسلسل محدد على النحو التالي: ابدأ بأي عدد صحيح مثبت n. ثم كل مصطلح يتم الحصول عليه من المصطلح السابق على النحو التالي: إذا كان المصطلح السابق زوج، المصطلح التالي هو نصف المصطلح السابق. إذا كان المصطلح السابق فريد، المصطلح التالي هو 3 مرات المصطلح السابق زائد 1. التخمين هو أنه بغض النظر عن قيمة n، سيتم الوصول إلى 1. ملاحظة: 1. كولاتز (((1) هو [1]. 2. القائمة المرجعة مرتبة بترتيب متزايد. على سبيل المثال: get_odd_collatz (((5) يعيد [1, 5] # تسلسل كولات
    """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def sort_even(l: list):
    """"""هذه الوظيفة تأخذ قائمة l وتعيد قائمة l' بحيث تكون l' متطابقة مع l في المؤشرات الفردية، بينما قيمها في المؤشرات الزوجية تساوي قيم المؤشرات الزوجية لـ l، ولكن مرتبة.
    >>> sort_even([1, 2, 3])
    [1, 2, 3]
    >>> sort_even([5, 6, 3, 4])
    [3, 6, 5, 4]
    """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

"
"
def anti_shuffle(s):
    """"""
    اكتب دالة تأخذ سلسلة وترجع نسخة مرتبة منها. نسخة مرتبة من سلسلة، هي سلسلة حيث يتم استبدال كل الكلمات (مفصولة عن طريق الفراغ) بكلمة جديدة حيث يتم ترتيب جميع الحروف بترتيب تصاعدي بناء على قيمة ascii. ملاحظة: يجب عليك الاحتفاظ بترتيب الكلمات والفراغات الفارغة في الجملة. على سبيل المثال: anti_shuffle ((('Hi') يرجع 'Hi' anti_shuffle ((('hello') يرجع 'ehllo' anti_shuffle (('Hello World!!!') يرجع 'Hello!!!Wdlor'
    """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

"
"from typing import List


def string_xor(a: str, b: str) -> str:
    """""" المدخلات هي سلسلتين a و b تتكون من 1 و 0 فقط. قم بتنفيذ XOR ثنائي على هذه المدخلات و ارجع النتيجة كسلسلة.
    >>> string_xor('010', '110')
    '100'
    """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
"
"

def correct_bracketing(brackets: str):
    """""" قوسين هو سلسلة من ""<"" و "">"". return True اذا كل قوس افتتاحية لها قوس اغلاق متطابق.

    >>> correct_bracketing(""<"")
    False
    >>> correct_bracketing(""<>"")
    True
    >>> correct_bracketing(""<<><>>"")
    True
    >>> correct_bracketing(""><<>"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

"
"
def add_elements(arr, k):
    """"""
    مع وجود صف غير فارغ من الأعداد الصحيحة arr و k، ارجع مجموع العناصر مع رقمين كحد أقصى من العناصر k الأولى من arr. مثال: المدخلات: arr = [111,21,3,4000,5,6,7,8,9], k = 4 الناتج: 24 # مجموع 21 + 3 القيود: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)
    """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def right_angle_triangle(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return True if the three
    sides form a right-angled triangle, False otherwise.
    A right-angled triangle is a triangle in which one angle is right angle or 
    90 degree.
    Example:
    right_angle_triangle(3, 4, 5) == True
    right_angle_triangle(1, 2, 3) == False
    '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

"
"
def Strongest_Extension(class_name, extensions):
    """"""ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵢⵉⵙⵎ ⵏ ⵜⵔⵎⵜ (ⵜⴰⵏⴳⴳⴰ) ⴷ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵙⵖⵣⵏ. ⵉⵙⵖⵣⵏⵏ ⴰⴷ ⵜⵜⵓⵙⵎⵔⴰⵙⵏ ⵉ ⵓⵙⵙⴽⵛⵎ ⵏ ⵜⵔⵎⵉⵏ ⵢⴰⴹⵏⵉⵏ ⵙ ⵜⵔⵎⵜ. ⵜⴰⴷⵓⵙⵉ ⵏ ⵓⵙⵖⵣⵏ ⵜⴳⴰ ⵣⵓⵏⴷ ⴰⵢⴰ: ⴰⴷ ⵜⴳ CAP ⵓⵟⵟⵓⵏ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵜⴰⵎⵇⵕⴰⵏⵜ ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵏ, ⴷ ⴰⴷ ⵜⴳ SM ⵓⵟⵟⵓⵏ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵜⴰⵎⵥⵥⵢⴰⵏⵜ ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵏ, ⵜⴰⴷⵓⵙⵉ ⵜⵜⵓⴼⴽⴰ ⵙ ⵜⴽⵔⵔⴰ CAP - SM. ⵔⴰⴷ ⵜⵙⵙⵓⴼⵖ ⵜⴰⴷⵓⵙⵉ ⵜⴰⵅⴰⵜⴰⵔⵜ ⴷ ⵜⵔⵎⵜ ⴳ ⵓⵙⵖⵣⵏ ⴰⴷ: ClassName.StrongestExtensionName. ⵉⵖ ⴳⴰⵏ ⵙⵉⵏ ⵉⵙⵖ
    """"""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
"
"
def even_odd_count(num):
    """"""ⵉⴳ ⴷⴰⵔⵙ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ, ⴰⵔ ⵉⵙⵙⴽⵛⵎ ⵜⴰⴱⵍⵓⵜ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ ⴷ ⵡⵉⵏ ⵡⵉⵏ ⵡⵉⵏ ⵡⴰⵔ ⴰⵎⴷⵢⴰ: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2)
    """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

"
"

def unique(l: list):
    """"""ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⵉⵡⵏⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⴳ ⵜⵍⴳⴰⵎⵜ
    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [0, 2, 3, 5, 9, 123]
    """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

"
"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """""" ⴰⵙⴽⵛⵎ ⵙ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵛⵛⵎ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵏ ⵜⴱⵕⴰⵏⴽⵉⵙⵉⵏ ⵉⵜⵜⵓⵙⵎⴳⴰⵍⵏ. ⴰⵡⵜⵜⴰⵙ ⵏⵏⴽ ⵉⴳⴰ ⴰⴷ ⵜⴱⴹⵉⴷ ⵜⵔⵓⴱⴱⴰ ⴰⴷ ⴳ ⵜⵉⴱⵕⴰⵏⴽⵉⵙⵉⵏ ⵉⵜⵜⵓⵙⵎⴳⴰⵍⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⴱⵕⴰⵏⴽⵉⵙⵉⵏ ⴰⴷ. ⵜⵉⴱⵕⴰⵏⴽⵉⵙⵉⵏ ⵉⵜⵜⵓⵙⵎⴳⴰⵍⵏ (ⵢⴰⵜⵜⵓⵢ ⵉⵊⵊ ⵏ ⵓⴽⵛⵛⵎ ⵉⵜⵜⵓⵙⵎⴳⴰⵍⵏ) ⴷ ⵓⵔ ⵜⵜⵓⵙⵎⴳⴰⵍⵏ ⴳ ⵓⴳⵏⵙⵓ ⵏ ⴽⵔⴰ ⵢⴳⴰⵜⵜ ⵢⴰⵏ. ⵓⵔ ⵜⵙⵙⵏ ⴽⵔⴰ ⵏ ⵡⴰⵏⵙⴰ ⴳ ⵓⴽⵛⵛⵎ ⵏ ⵜⴱⵕⴰⵏⴽⵉⵙⵜ. ⴰⵎⴷⵢⴰ:
    >>> separate_paren_groups('( ) (( )) (( )( ))')
    ['()', '(())', '(()())']
    """"""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
"
"
def count_up_to(n):
    """"""ⵙⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⵔⵉⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴷ ⵉⵎⵥⵥⵉⵏⵏ ⵏⵉⴳ ⵏ n. ⵙ ⵓⵎⴷⵢⴰ: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]
    """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

"
"
def is_sorted(lst):
    '''
    Given a list of numbers, return whether or not they are sorted
    in ascending order. If list has more than 1 duplicate of the same
    number, return False. Assume no negative numbers and only integers.

    Examples
    is_sorted([5]) â -> True
    is_sorted([1, 2, 3, 4, 5]) â -> True
    is_sorted([1, 3, 2, 4, 5]) â -> False
    is_sorted([1, 2, 3, 4, 5, 6]) â -> True
    is_sorted([1, 2, 3, 4, 5, 6, 7]) â -> True
    is_sorted([1, 3, 2, 4, 5, 6, 7]) â -> False
    is_sorted([1, 2, 2, 3, 3, 4]) â -> True
    is_sorted([1, 2, 2, 2, 3, 4]) â -> False
    '''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

"
"
def int_to_mini_roman(number):
    """"""
    ⵉⴳ ⴷⴰⵔⴽ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ, ⵙⵙⵓⵜⵔ ⴰⵎⵢⴰⵡⴰⵙ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵕⵓⵎⴰⵏ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵓⴽⵜⵓⵎ, ⴷ ⵙⵙⵓⴼⵖ ⵙ ⵉⵎⴷⵢⴰⵡⵏ ⵉⵎⵥⵥⵉⵏ. ⵜⵉⵎⵥⴰ: 1 <= num <= 1000 ⵉⵎⴷⵢⴰⵜⵏ:
    >>> int_to_mini_roman(19) == 'xix'
    >>> int_to_mini_roman(152) == 'clii'
    >>> int_to_mini_roman(426) == 'cdxxvi'
    """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"

def largest_prime_factor(n: int):
    """"""ⴰⴷ ⵏⵔⴰⵔ ⴰⵎⴳⴳⴰⵔⵓ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ ⵏ n. ⵏⵙⵙⵏ ⵉⵙ n > 1 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵎⵣⵡⴰⵔⵓ.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

"
"
def x_or_y(n, x, y):
    """"""ⴰⵖⴰⵡⴰⵙ ⴰⵎⵢⵉⵡⵏ ⵏⵏⴰ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⴰ ⴰⵜⵉⴳ ⵏ x ⵎⴽ ⵉⴳⴰ n ⴰⵎⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⴰ ⴰⵜⵉⴳ ⵏ y ⵎⴽ ⵓⵔ ⵉⴳⵉ. ⵉⵎⴷⵢⴰⵜⵏ: ⵉ x_or_y{7, 34, 12) == 34 ⵉ x_or_y{15, 8, 5) == 5
    
    """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

"
"

def pairs_sum_to_zero(l):
    """"""
    pairs_sum_to_zero ⴷⴰ ⵉⵜⵜⴰⵎⵥ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ. ⴷⴰ ⵢⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ ⵉⵜⵜⵎⵓⵏⵏ ⵙ ⵓⵎⵢⴰ, ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ.
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    False
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    False
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    False
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    True
    >>> pairs_sum_to_zero([1])
    False
    """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

"
"
def solve(s):
    """"""ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵔⴰ ⵏ ⵓⵡⵉⴽⵉⵍ s. ⵎⴽ ⵜⴳⴰ s[i] ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⵙⵙⵓⵜⵍ ⵜⴰⵡⵉⴽⵉⵍⵜ ⵏⵏⵙ ⵙⴳ ⴷⴷⴰⵡ ⵙ ⴰⴼⵍⵍⴰ ⵏⵖⴷ ⵙ ⵓⴱⵔⴰⵔⴳ, ⵎⴽ ⵓⵔ ⵜⵍⵍⴰ. ⵎⴽ ⵓⵔ ⵜⵍⵍⴰ ⴳ ⵓⵡⵉⴽⵉⵍ ⴽⵔⴰ ⵏ ⵜⴱⵔⴰⵜⵉⵏ, ⵙⵙⵓⵜⵍ ⵜⴰⵡⵉⴽⵉⵍⵜ. ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⵜⵔⴰ ⴰⴷ ⵜⵙⴽⵔ ⵜⴰⵡⵉⴽⵉⵍⵜ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ. ⵉⵎⴷⵢⴰⵜⵏ solve{""1234"") = ""4321""{""ab"") = ""AB""{""#a@C"") = ""#A@c""
    """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
"
"

def derivative(xs: list):
    """""" xs ⴷⴰ ⵉⵙⵎⴷⵢⴰ ⵉⵎⵙⴽⴰⵔⵏ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ. xs[0] + xs[1] * x + xs[2] * x^2 +.... ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵜⴰⵙⵏⴼⵍⵓⵍⵜ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵙ ⵢⴰⵜ ⵜⴰⵍⵖⴰ.
    >>> derivative([3, 1, 2, 4, 5])
    [1, 4, 12, 20]
    >>> derivative([1, 2, 3])
    [2, 6]
    """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

"
"from typing import List


def sort_numbers(numbers: str) -> str:
    """""" ⴰⵙⴽⵛⵎ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ ""ⵙⵢⴰ"" ⴰⵔ ""ⵜⵥⴰ"". ⵉⵙⵜⴰⵢⵏ ⵉⵣⵔⴼⴰⵏ ⴳⴰⵏ ""ⵙⵢⴰ"", ""ⵢⵉⵡⵏ"", "" ⵙⵉⵏ"", "" ⴽⵕⴰⴹ"", ""ⴽⴽⵓⵥ"", ""ⵎⵎⵓⵙ"", ""ⵚⴹⵉⵚ"", ""ⴰⵙⵙⴰ"", ""ⴰⵙⴰ"" ⴷ ""ⵜⵥⴰ"". ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵓⴽⵛⵛⵓⵎ ⵙ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙⴳ ⵉⵎⵥⵥⵢⴰⵏⵏ ⴰⵔ ⵉⵎⵇⵇⵔⴰⵏⵏ.
    >>> sort_numbers('three one five')
    'one three five'
    """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
"
"

def correct_bracketing(brackets: str):
    """""" brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏ ""("" ⴷ """". return True ⵎⴽ ⴷⴰ ⵜⵍⵍⴰ ⴽⵓ ⵜⴰⵡⵉⴽⵉⵜ ⵏ ⵓⵕⵥⵥⵓⵎ ⴷ ⵜⵥⵕⵉⴳⵜ ⵏ ⵓⵇⵇⵏ.

    >>> correct_bracketing(""("")
    False
    >>> correct_bracketing(""()"")
    True
    >>> correct_bracketing(""(()())"")
    True
    >>> correct_bracketing("")(()"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

"
"
def get_max_triples(n):
    """"""
    ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵓ ⵢⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ n. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⴽⵔⴷ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⵏ ⵜⵉⵖⵣⵉ n. ⵉ ⴽⵓ i (1 â‰¤ i â‰¤ n), ⴰⵜⵉⴳ ⵏ a[i] = i * i - i + 1. ⴰⵔⵏ ⵉⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵎⵔⵏ (a[i], a[j], a[k]) ⵏ a ⴳ i < j < k, ⴷ a[i] + a[j] + a[k] ⵉⴳⴰ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3. ⴰⵎⴷⵢⴰ: Input: n = 5 Output: 1 ⴰⵙⴼⵔⵓ: a = [1, 3, 7, 13, 21] ⴰⵎⴳⴳⴰⵔⵓ ⴰⵎⵢⵉⵡⵏ ⵉⴳⴰⵏ (1, 7, 13).
    """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
"
"
def get_odd_collatz(n):
    """"""
    ⵉⴳ ⴷⴰⵔⴽ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ n, ⵙⵙⵓⴼⵖ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵓⵔ ⵉⵎⵙⴰⵙⴰⵏ ⴳ ⵓⵙⵏⵙⵍ ⵏ ⴽⵓⵍⴰⵜⵣ. ⵜⴰⵡⵏⴳⵉⵎⵜ ⵏ ⴽⵓⵍⴰⵜⵣ ⵜⴳⴰ ⵢⴰⵜ ⵜⴰⵡⵏⴳⵉⵎⵜ ⴳ ⵜⵓⵙⵏⴰⴽⵜ ⵏⵏⴰ ⵉⵥⵍⵉⵏ ⵙ ⵓⵙⵏⵙⵍ ⵉⵜⵜⵓⵣⵔⴰⵢⵏ ⵙ ⵓⵎⴽ ⴰⴷ: ⵙⵙⵏⵜ ⵙ ⴽⵓ ⵓⵟⵟⵓⵏ ⴰⵎⵏⵉⴳ n. ⴷⴼⴼⵉⵔ ⵏ ⵖⵉⴽⴰⵏⵏ, ⴽⵓ ⵜⴰⴳⵓⵔⵉ ⴷⴰ ⵜⵜⵢⴰⵡⴼⴰ ⵙⴳ ⵜⴰⴳⵓⵔⵉ ⵉⵣⵔⵉⵏ ⵙ ⵓⵎⴽ ⴰⴷ: ⵉⴳ ⵜⴰⴳⵓⵔⵉ ⵉⵣⵔⵉⵏ ⵜⴳⴰ ⵜⵣⴷⵉⴳⵜ, ⵜⴰⴳⵓⵔⵉ ⵜⴰⴹⴼⴰⵕⵜ ⵜⴳⴰ ⵢⴰⵏ ⵓⵣⴳⵏ ⵏ ⵜⴳⵓⵔⵉ ⵉⵣⵔⵉⵏ. ⵉⴳ ⵜⴰⴳⵓⵔⵉ ⵜⴰⵣⴷⵉⴳⵜ ⵜⴳⴰ ⵜⵣⴷⵉⴳⵜ, ⵜⴰⴳⵓⵔⵉ ⵜⴰⴹⴼⴰⵕⵜ ⵜⴳⴰ 3
    """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def greatest_common_divisor(a: int, b: int) -> int:
    """""" ⴰⴷ ⵏⵔⴰⵔ ⴰⵎⵟⵟⵓ ⴰⵎⵛⵛⴰⵔⵏ ⴰⵅⴰⵜⴰⵔ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⴷ b
    >>> greatest_common_divisor(3, 5)
    1
    >>> greatest_common_divisor(25, 15)
    5
    """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
"
"


def sum_squares(lst):
    """""""" ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⴽⴽⴰ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵉ ⴽⵓⵍⵍⵓ ⵉⵎⴹⴰⵏⵏ ⴳ ⵜⵍⴳⴰⵎⵜ, ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⴽⴽⵙ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴳ ⵉⴳⵔ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3 ⴷ ⵔⴰⴷ ⵜⴽⴽⵙ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴳ ⵉⴳⵔ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 4 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3. ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⵓⵔ ⵜⵙⵏⴼⵍ ⵉⵎⴹⴰⵏⵏ ⴳ ⵜⵍⴳⴰⵎⵜ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵉⵎⴳⴳⴰⵔⵏ ⵏ 3 ⵏⵖ 4. ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⵔⴰⵔ ⵜⴰⴳⵓⵜ ⵏ ⵉⵎⴹⴰⵏⵏ ⴳ ⵜⵍⴳⴰⵎⵜ. ⵉⵎⴷⵢⴰⵜⵏ: ⵉ lst = [1,2,3] ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⴳ ⵜⵢⴰⴼⵓⵜ 6 ⵉⵇⵇⴰⵏ ⴰⴷ
    """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
"
"

def below_threshold(l: list, t: int):
    """"""ⴰⵔ ⵉⵜⵜⵔ True ⵎⴽ ⴳⴰⵏ ⵉⵎⴹⴰⵏⵏ ⴳ ⵜⵍⴳⴰⵎⵜ l ⴷⴷⴰⵡ ⵏ ⵓⴽⵡⵜⵜⴰⵢ t.
    >>> below_threshold([1, 2, 4, 10], 100)
    True
    >>> below_threshold([1, 20, 4, 10], 5)
    False
    """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

"
"

def sum_to_n(n: int):
    """"""sum_to_n ⵜⴳⴰ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵉⵜⵜⵎⵓⵏⵏ ⵉⵎⴹⴰⵏⵏ ⵙⴳ 1 ⴰⵔ n.
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
    """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

"
"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """""" ⵙⴳ ⵜⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⴰⴽⴽⵡ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵉⵜⵜⵊⵕⴰⵏ ⵓⴳⴳⴰⵔ ⵏ ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ. ⵃⴹⵓ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵇⵇⵉⵎⵏ ⴰⵎⵎ ⵡⵉⵏⵏⴰ ⴳ ⵜⴽⵛⵛⵓⵎⵜ.
    >>> remove_duplicates([1, 2, 3, 2, 4])
    [1, 3, 4]
    """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
"
"
def anti_shuffle(s):
    """"""
    ⵙⵔⵙⵏ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵏⴰⴹ ⴷ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵜ ⵜⵓⵏⵖⵉⵍⵜ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ. ⵜⴰⵡⵉⴽⵉ ⴰⵏⵎⵏⴰⴹ ⵏ ⵓⵡⵉⴽⵉ, ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴳ ⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴽⵓⵍⵍⵓ ⵜⴳⵓⵔⵉⵡⵉⵏ (ⵜⵓⵙⴱⴹⴰⵏⵜ ⵙ ⵓⵙⴰⵢⵔⴰⵔ) ⵙ ⵢⴰⵜ ⵜⴳⵓⵔⵉ ⵜⴰⵎⴰⵢⵏⵓⵜ ⴳ ⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵇⵔⴰⵏ ⵅⴼ ⵡⴰⵜⵉⴳ ⵏ ascii. ⵜⴰⵖⴹⴼⵜ: ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵃⴹⵓ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⵉⵙⴰⵢⵔⴰⵔⵏ ⴳ ⵜⴳⵓⵔⵉ. ⵙ ⵓⵎⴷⵢⴰ: anti_shuffle ((('Hi') ⴰⵔ ⵉⵜⵜⵔⴰⵔ 'Hi' anti_shuffle ((('hello') ⴰⵔ ⵉⵜⵜⵔⴰⵔ 'ehllo' anti_shuffle ((
    """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def right_angle_triangle(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return True if the three
    sides form a right-angled triangle, False otherwise.
    A right-angled triangle is a triangle in which one angle is right angle or 
    90 degree.
    Example:
    right_angle_triangle(3, 4, 5) == True
    right_angle_triangle(1, 2, 3) == False
    '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

"
"
def sort_array(array):
    """"""
    ⴳ ⵓⵎⵙⴷⵓⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⴳⵓⵜⵏ, ⵙⵙⵓⴼⵖ ⵜⴰⴽⵓⴱⵉⵢⵜ ⵏ ⵓⵎⵙⴷⵓⵙ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵎⵙⴰⵙⴰ, ⵔⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⴰⵎⵙⴷⵓⵙ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵇⵔⴰⵏ ⵎⴽ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⵖⵎⵉⵙ ⴰⵎⵣⵡⴰⵔⵓ, ⵡⴰⵜⵉⴳ ⵏ ⵓⵖⵎⵉⵙ ⴰⵎⴳⴳⴰⵔⵓ, ⵓⵔ ⵉⵎⵢⴰⵏⴰⵡⵏ, ⵏⵖⴷ ⵙ ⵓⵙⵙⵓⴷⵙ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⴳⴳⴰⵔⵓ ⵎⴽ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⵖⵎⵉⵙ ⴰⵎⵣⵡⴰⵔⵓ, ⵡⴰⵜⵉⴳ ⵏ ⵓⵖⵎⵉⵙ ⴰⵎⴳⴳⴰⵔⵓ, ⵉⵎⵢⴰⵏⴰⵡⵏ. ⵜⴰⵖⴹⴼⵜ: * ⵓⵔ ⵜⵙⵙⵓⴷⵙⴷ ⴰⵎⵙⴷⵓⵙ. ⴰⵎⴷⵢⴰ: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[
    """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

"
"

def fib4(n: int):
    """"""ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ Fib4 ⵜⴳⴰ ⵢⴰⵜ ⵜⴰⵍⴳⴰⵎⵜ ⵣⵓⵏⴷ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). ⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵉⵟⵏ ⵙ ⵜⵣⵎⵔⵜ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ fib4. ⵓⵔ ⵜⵙⵙⵎⵔⵙ ⵜⵉⵔⵔⴰ.
    >>> fib4(5)
    4
    >>> fib4(6)
    8
    >>> fib4(7)
    14
    """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

"
