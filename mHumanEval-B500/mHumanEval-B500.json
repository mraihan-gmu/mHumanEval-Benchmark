[
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    \u2d4f\u2d3b\u2d5b\u2d5b\u2d30\u2d4d \u2d4f\u2d3b\u2d5c \u2d30\u2d5b\u2d5b\u2d3b\u2d5b\u2d30\u2d4d, \u2d37\u2d3b\u2d57 \u2d30\u2d5b\u2d5b\u2d3b\u2d5b\u2d30\u2d4d \u2d4f\u2d3b\u2d5c \u2d30\u2d4b\u2d3b\u2d4f \u2d4f \u2d49\u2d5b\u2d30\u2d54\u2d3b\u2d5c\u2d30\u2d4f, \u2d4e\u2d30\u2d5b\u2d30\u2d4f \u2d37\u2d30\u2d54\u2d42\u2d30 \u2d30\u2d37 \u2d30\u2d5b\u2d3b\u2d5b \u2d30\u2d4b\u2d3b\u2d4f \u2d4f \u2d49\u2d5b\u2d30\u2d54\u2d3b\u2d5c\u2d30\u2d4f \u2d49 \u2d30\u2d37 \u2d30\u2d3e\u2d3b\u2d5c\u2d3b\u2d4f \u2d30\u2d4d\u2d5b\u2d49\u2d4e\u2d30\u2d5c\u2d3b\u2d4f \u2d4f \u2d30\u2d5b\u2d30\u2d4d. \u2d30\u2d37 \u2d49\u2d3e\u2d3c\u2d3b\u2d5c \u2d30\u2d54\u2d49 \u2d4f [ \u2d30\u2d4b\u2d3b\u2d4f \u2d4f \u2d49\u2d5b\u2d30\u2d54\u2d3b\u2d5c\u2d30\u2d4f \u2d53\u2d49 \u2d30\u2d5b\u2d5b\u2d3b\u2d5b\u2d30\u2d4d\u2d4f\u2d3b\u2d4f \u2d37\u2d30\u2d54\u2d30\u2d5c \u2d30\u2d4d\u2d5b\u2d49\u2d4e\u2d30\u2d5c\u2d3b\u2d4f \u2d4f\u2d3b\u2d5c, \u2d30\u2d4b\u2d3b\u2d4f \u2d4f \u2d49\u2d5b\u2d30\u2d54\u2d3b\u2d5c\u2d30\u2d4f \u2d53\u2d49 \u2d30\u2d63\u2d63\u2d30\u2d54\u2d30\u2d4f \u2d37\u2d30\u2d54\u2d30\u2d5c \u2d30\u2d4d\u2d5b\u2d49\u2d4e\u2d30\u2d5c\u2d3b\u2d4f \u2d4f\u2d3b\u2d5c ] \u2d30 \u2d3c\u2d30\u2d4d \u2d53\u2d30\u2d54 \u2d49\u2d4d\u2d4d\u2d3b\u2d4f \u2d49\u2d5b\u2d30\u2d54\u2d3b\u2d5c\u2d30\u2d4f \u2d53\u2d49 \u2d49\u2d5b\u2d30\u2d54\u2d3b\u2d4f, \u2d30\u2d37 \u2d30\u2d5b\u2d3b\u2d5b \u2d30\u2d4b\u2d3b\u2d4f \u2d4f \u2d49\u2d5b\u2d30\u2d54\u2d3b\u2d5c\u2d30\u2d4f \u2d53\u2d49 \u2d49\u2d5b\u2d30\u2d54\u2d3b\u2d4f, \u2d4e\u2d30\u2d5b\u2d30\u2d4f \u2d30\u2d37 \u2d30\u2d5b\u2d3b\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    \u2d33 \u2d53\u2d59\u2d54\u2d54\u2d53\u2d59 \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f, \u2d59\u2d59\u2d53\u2d37\u2d59 \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d33\u2d54 1 \u2d37 9 \u2d33 \u2d5c\u2d30\u2d4e\u2d4e\u2d4f\u2d5c, \u2d59\u2d59\u2d53\u2d37\u2d59 \u2d30\u2d59\u2d54\u2d54\u2d53\u2d59 \u2d4f \u2d53\u2d59\u2d54\u2d54\u2d53\u2d59, \u2d37 \u2d37\u2d3c\u2d3c\u2d49\u2d54 \u2d30\u2d37 \u2d59\u2d59\u2d4e\u2d37\u2d4d \u2d3d\u2d53 \u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d59 \u2d62\u2d49\u2d59\u2d4e \u2d4f\u2d4f\u2d59 \u2d59\u2d33 \"\u2d62\u2d30\u2d4f\", \" \u2d59\u2d49\u2d4f\", \" \u2d3d\u2d55\u2d30\u2d39\", \" \u2d3d\u2d3d\u2d53\u2d65\", \" \u2d59\u2d4e\u2d4e\u2d53\u2d59\", \" \u2d5a\u2d39\u2d49\u2d5a\", \" \u2d59\u2d30\", \" \u2d59\u2d4e\u2d4e\u2d53\u2d59\", \" \u2d59\u2d4e\u2d4e\u2d53\u2d59\", \"\u2d5c\u2d30\u2d4e\u2d54\u2d30\u2d61\". \u2d59 \u2d53\u2d4e\u2d37\u2d62\u2d30: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> \u2d59\u2d59\u2d53\u2d37\u2d59 arr -> [1, 1, 2, 3, 4, 5, 8] -> \u2d59\u2d59\u2d53\u2d37\u2d59 arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"Eight\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    \u2d54\u2d30\u2d37 \u2d5c\u2d5c\u2d53\u2d3c\u2d3d\u2d30 \u2d49\u2d3d\u2d5b\u2d5b\u2d53\u2d4e\u2d4f \u2d4f \u2d5c\u2d33\u2d53\u2d54\u2d49\u2d61\u2d49\u2d4f \u2d49\u2d5c\u2d5c\u2d53\u2d62\u2d3c\u2d3c\u2d56\u2d4f \u2d59 \u2d5c\u2d49\u2d3c\u2d49\u2d4f\u2d30\u2d56 \u2d4f\u2d56\u2d37 \u2d5c\u2d49\u2d3c\u2d54\u2d3d\u2d49\u2d4f. \u2d5c\u2d30\u2d61\u2d53\u2d54\u2d49 \u2d4f\u2d4f\u2d3d \u2d5c\u2d33\u2d30 \u2d30\u2d37 \u2d5c\u2d31\u2d39\u2d53 \u2d5c\u2d49\u2d3d\u2d5b\u2d53\u2d4e\u2d4f \u2d59 \u2d5c\u2d33\u2d53\u2d54\u2d49\u2d61\u2d49\u2d4f \u2d37 \u2d30\u2d37 \u2d5c\u2d54\u2d30\u2d54 \u2d5c\u2d30\u2d33\u2d54\u2d54\u2d30\u2d62\u2d5c \u2d4f \u2d5c\u2d33\u2d53\u2d54\u2d49\u2d61\u2d49\u2d4f. \u2d59 \u2d53\u2d4e\u2d37\u2d62\u2d30: words_string ((\"\u2d59\u2d4d\u2d49\u2d4e, \u2d49\u2d59\u2d4e \u2d49\u2d4f\u2d53 \u2d62\u2d53\u2d4f\") == [\"\u2d59\u2d4d\u2d49\u2d4e\", \"\u2d59\u2d4d\u2d49\u2d4e\", \"\u2d49\u2d59\u2d4e\", \"\u2d49\u2d59\", \"\u2d4a\u2d53\u2d4f\"] words_string ((\"\u2d62\u2d30\u2d4f, \u2d59\u2d49\u2d4f, \u2d3d\u2d55\u2d30\u2d39, \u2d3d\u2d3d\u2d53\u2d65, \u2d59\u2d4e\u2d4e\u2d53\u2d59, \u2d5a\u2d39\u2d49\u2d5a\") == [\"\u2d62\u2d30\u2d4f\", \"\u2d59\u2d49\u2d4f\", \" \u2d3d\u2d55\u2d30\u2d39\", \"\u2d3d\u2d53\u2d65\", \"\u2d4e\u2d4e\u2d53\u2d59\", \"\u2d5a\u2d39\u2d49\u2d5a\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"\u2d37\u2d30 \u2d49\u2d5c\u2d5c\u2d54\u2d30\u2d54 \u2d53\u2d4e\u2d39\u2d30\u2d4f \u2d4f \u2d5c\u2d49\u2d3d\u2d3d\u2d30\u2d4d \u2d4f\u2d4f\u2d30 \u2d33 \u2d49\u2d5c\u2d5c\u2d3c\u2d3c\u2d56 \u2d53\u2d5f\u2d5f\u2d53\u2d4f 7 \u2d33 \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d49\u2d4e\u2d65\u2d65\u2d49\u2d4f \u2d4f\u2d4f\u2d30 \u2d53\u2d54 \u2d62\u2d30\u2d3d\u2d59\u2d53\u2d4d\u2d4f \u2d59 11 \u2d4f\u2d56\u2d37 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    \u2d49\u2d33 \u2d37\u2d30\u2d54\u2d3d \u2d49\u2d59\u2d4e\u2d3d\u2d49\u2d4d, \u2d37\u2d37\u2d54\u2d56 \u2d5c\u2d49\u2d37\u2d5c \u2d4e\u2d3d \u2d33\u2d30\u2d4f \u2d3d\u2d53\u2d4d\u2d4d\u2d53 \u2d49\u2d59\u2d4d\u2d3d\u2d49\u2d4f \u2d5c\u2d49\u2d59\u2d49\u2d39\u2d3c\u2d30\u2d4f \u2d33 \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    \u2d49\u2d56 \u2d4f\u2d30\u2d3d\u2d3d\u2d30 \u2d5c\u2d30\u2d61\u2d54\u2d49\u2d54\u2d5c \u2d59 N \u2d5c\u2d49\u2d3c\u2d54\u2d3d\u2d49\u2d4f \u2d37 N \u2d5c\u2d49\u2d54\u2d59\u2d30\u2d4d (N >= 2) \u2d37 \u2d3d\u2d53 \u2d5c\u2d30\u2d56\u2d54\u2d30\u2d59\u2d5c \u2d4f \u2d5c\u2d31\u2d54\u2d49\u2d37\u2d5c \u2d37\u2d30\u2d54\u2d59 \u2d62\u2d30\u2d4f \u2d61\u2d30\u2d5c\u2d49\u2d33. \u2d3d\u2d53 \u2d5c\u2d30\u2d56\u2d54\u2d30\u2d59\u2d5c \u2d33 \u2d53\u2d4e\u2d4f\u2d49\u2d37 [1, N * N] \u2d49\u2d4d\u2d4d\u2d30 \u2d3d\u2d53 \u2d62\u2d30\u2d4f \u2d33 \u2d61\u2d30\u2d5c\u2d49\u2d33\u2d4f \u2d33 \u2d5c\u2d31\u2d54\u2d49\u2d37\u2d5c. \u2d49\u2d47\u2d47\u2d30\u2d4f \u2d37 \u2d30\u2d37 \u2d4f\u2d30\u2d3c \u2d30\u2d31\u2d54\u2d49\u2d37 \u2d30\u2d4e\u2d65\u2d65\u2d62\u2d30\u2d4f \u2d4f \u2d5c\u2d49\u2d56\u2d63\u2d49 k \u2d33 \u2d5c\u2d31\u2d54\u2d49\u2d37\u2d5c. \u2d5c\u2d63\u2d4e\u2d54\u2d37 \u2d30\u2d37 \u2d5c\u2d31\u2d37\u2d53 \u2d59\u2d33 \u2d3d\u2d53 \u2d5c\u2d30\u2d56\u2d54\u2d30\u2d59\u2d5c, \u2d37 \u2d33 \u2d3d\u2d53 \u2d5c\u2d49\u2d3d\u2d4d\u2d49\u2d5c \u2d5c\u2d63\u2d4e\u2d54\u2d37 \u2d30\u2d37 \u2d5c\u2d63\u2d63\u2d49\u2d33\u2d49\u2d63\u2d37 \u2d56\u2d54 \u2d3d\u2d53 \u2d5c\u2d30\u2d56\u2d54\u2d30\u2d59\u2d49\u2d4f \u2d5c\u2d49\u2d4e\u2d30\u2d37\u2d37\u2d53\u2d3d\u2d30\u2d4d\u2d49\u2d4f, \u2d59 \u2d5c\u2d33\u2d53\u2d54\u2d49 \u2d62\u2d30\u2d39\u2d4f, \u2d5c\u2d63\u2d4e\u2d54\u2d37 \u2d30\u2d37 \u2d5c\u2d63\u2d63\u2d49\u2d33\u2d49\u2d63\u2d37 \u2d56\u2d54 \u2d5c\u2d30\u2d56\u2d54\u2d30\u2d59\u2d49\u2d4f \u2d4f\u2d4f\u2d30 \u2d37\u2d30\u2d54\u2d59 \u2d30\u2d33\u2d30\u2d3c\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs \u2d37\u2d30 \u2d49\u2d59\u2d4e\u2d37\u2d62\u2d30 \u2d49\u2d4e\u2d33\u2d33\u2d49\u2d5c\u2d4f \u2d4f \u2d3d\u2d49\u2d33\u2d30\u2d4f \u2d4f \u2d49\u2d61\u2d5c\u2d5c\u2d30. xs[0] + xs[1] * x + xs[2] * x^2 +.... \u2d37\u2d30 \u2d49\u2d5c\u2d5c\u2d54\u2d30\u2d54 \u2d5c\u2d30\u2d62\u2d30\u2d3c\u2d53\u2d5c \u2d4f \u2d3d\u2d49\u2d33\u2d30\u2d4f \u2d4f \u2d49\u2d61\u2d5c\u2d5c\u2d30 \u2d59 \u2d62\u2d30\u2d5c \u2d5c\u2d30\u2d4d\u2d56\u2d30.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    \u2d30\u2d37\u2d30\u2d4d\u2d49\u2d4e\u2d30\u2d4d \u2d49\u2d49\u2d30\u2d3e\u2d30 \u2d53\u2d30 \u2d62\u2d48\u2d30\u2d4d \u2d30\u2d31\u2d30\u2d54\u2d30 \u2d53\u2d30 \u2d53\u2d36\u2d53\u2d37 \u2d53\u2d30\u2d54\u2d30\u2d4f \u2d53\u2d36\u2d53\u2d37. \u2d4f\u2d30\u2d3e\u2d30\u2d4d \u2d30\u2d3e\u2d30\u2d49\u2d30\u2d4f \u2d59\u2d53\u2d4d\u2d53 \u2d59\u2d30\u2d54\u2d30\u2d5c \u2d59\u2d30\u2d4e\u2d30\u2d4d \u2d59 \u2d59\u2d30\u2d4e\u2d30\u2d4d; \u2d37\u2d30\u2d57 \u2d30\u2d4d\u2d53\u2d30\u2d48 \u2d49\u2d49\u2d30\u2d4f, \u2d5c\u2d30\u2d48\u2d48\u2d49\u2d4e\u2d5c \u2d30\u2d4f \u2d4f\u2d30\u2d3e\u2d30\u2d4d \u2d30\u2d3e\u2d30\u2d49\u2d30\u2d4f \u2d59\u2d30\u2d54\u2d30\u2d5c \u2d59\u2d30\u2d4e\u2d30\u2d4d \u2d59 \u2d59\u2d30\u2d4e\u2d30\u2d4d. \u2d59\u2d30\u2d4f\u2d30\u2d5c\u2d30\u2d5c\u2d30\u2d5c \u2d5c\u2d30\u2d48\u2d48\u2d49\u2d4e\u2d62\u2d4f \u2d30\u2d4f \u2d4f\u2d30\u2d3e\u2d30\u2d4d \u2d30\u2d48\u2d30\u2d4d\u2d30\u2d4f \u2d30\u2d5c\u2d49\u2d53\u2d30\u2d63\u2d30\u2d49\u2d30\u2d4f \u2d37\u2d30\u2d57 \u2d30\u2d4b\u2d30\u2d4e\u2d30 \u2d30\u2d4f \u2d5c\u2d30\u2d54\u2d5c\u2d49\u2d5c. \u2d3e\u2d53\u2d4d \u2d4f\u2d30\u2d3e\u2d30\u2d4d \u2d30\u2d3e\u2d30\u2d49\u2d30\u2d4f \u2d59\u2d30\u2d4e\u2d30\u2d4d \u2d59 \u2d59\u2d30\u2d4e\u2d30\u2d4d. \u2d5c\u2d30\u2d48\u2d30\u2d4d \u2d30\u2d3e\u2d30\u2d49\u2d30\u2d4f \u2d30\u2d59 \u2d30\u2d3e\u2d30\u2d49\u2d30\u2d4f \u2d30\u2d59 \u2d5c\u2d30\u2d3e\u2d30\u2d49\u2d30\u2d5c \u2d5c\u2d30\u2d3e\u2d30\u2d49\u2d30\u2d5c \u2d5c\u2d30 \u2d5c\u2d30\u2d3e\u2d30\u2d49\u2d30\u2d5c \u2d59\u2d30\u2d4e\u2d30\u2d4d \u2d59 \u2d59\u2d30\u2d4e\u2d30\u2d4d \u2d5c\u2d30\u2d3e\u2d30\u2d49\u2d30\u2d5c \u2d5c\u2d30\u2d3e\u2d30\u2d49\u2d30\u2d5c \u2d59\u2d30\u2d4e\u2d30\u2d4d. \u2d4e\u2d30\u2d5b\u2d30\u2d4f, \u2d30\u2d3e\u2d30\u2d49\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    \u2d37\u2d30 \u2d5c\u2d5c\u2d53\u2d3c\u2d3d\u2d30 \u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f. \u2d59\u2d3d\u2d54 \u2d5c\u2d30\u2d61\u2d53\u2d54\u2d49 next_smallest (() \u2d4f\u2d4f\u2d30 \u2d49\u2d59\u2d3d\u2d54\u2d4f \u2d30\u2d59\u2d3d\u2d3d\u2d49\u2d4d \u2d61\u2d49\u2d59\u2d59 \u2d59\u2d49\u2d4f \u2d33 \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c. \u2d37\u2d30 \u2d49\u2d5c\u2d5c\u2d54\u2d30\u2d54 None \u2d4e\u2d3d \u2d53\u2d54 \u2d49\u2d4d\u2d4d\u2d49 \u2d53\u2d59\u2d3d\u2d3d\u2d49\u2d4d \u2d30\u2d37. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" \u2d33 \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f (\u2d59 \u2d61\u2d30\u2d5c\u2d5c\u2d30\u2d62\u2d4f \u2d4f \u2d59\u2d49\u2d4f \u2d49\u2d3c\u2d54\u2d37\u2d49\u2d59\u2d4f), \u2d59\u2d59\u2d4e\u2d54\u2d59\u2d4f \u2d5c\u2d30\u2d59\u2d4f\u2d3c\u2d4d\u2d5c \u2d5c\u2d30\u2d63\u2d54\u2d49\u2d54\u2d5c \u2d33 \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c, \u2d30\u2d62\u2d4f\u2d4f\u2d30 \u2d49\u2d33\u2d30\u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d30\u2d4e\u2d65\u2d65\u2d62\u2d30\u2d4f \u2d30\u2d37 \u2d49\u2d33 0 \u2d37 \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d30\u2d4e\u2d47\u2d54\u2d30\u2d4f \u2d30\u2d37 \u2d49\u2d33 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"\u2d37\u2d30 \u2d5c\u2d5c\u2d53\u2d3c\u2d3d\u2d30 \u2d59\u2d49\u2d4f \u2d49\u2d4f\u2d31\u2d54\u2d30\u2d4d\u2d4f, \u2d33 \u2d3d\u2d53 \u2d49\u2d4f\u2d31\u2d54\u2d30\u2d4d \u2d49\u2d33\u2d30 \u2d62\u2d30\u2d4f \u2d53\u2d3d\u2d4f \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f. \u2d59 \u2d53\u2d4e\u2d37\u2d62\u2d30, \u2d49\u2d4f\u2d31\u2d54\u2d30\u2d4d = (\u2d5c\u2d31\u2d37\u2d30\u2d37\u2d5c, \u2d5c\u2d33\u2d49\u2d54\u2d30) = (1, 2). \u2d49\u2d4f\u2d31\u2d54\u2d30\u2d4d\u2d4f \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d3d\u2d30\u2d54\u2d4f \u2d33\u2d30\u2d4f \u2d49\u2d47\u2d47\u2d4f\u2d4f, \u2d4e\u2d30\u2d62\u2d30\u2d37 \u2d49\u2d33\u2d30\u2d4f \u2d49\u2d59 \u2d37\u2d30 \u2d62\u2d30\u2d4e\u2d53 \u2d49\u2d4f\u2d31\u2d54\u2d30\u2d4d (\u2d5c\u2d31\u2d37\u2d30\u2d37\u2d5c, \u2d5c\u2d33\u2d49\u2d54\u2d30) \u2d33 \u2d5c\u2d49\u2d63\u2d61\u2d49\u2d54\u2d49 \u2d37 \u2d5c\u2d33\u2d49\u2d54\u2d30. \u2d33 \u2d3d\u2d53 \u2d49\u2d4f\u2d31\u2d54\u2d30\u2d4d \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d3d\u2d30\u2d54\u2d4f, \u2d37\u2d30 \u2d5c\u2d5c\u2d53\u2d59\u2d3d\u2d30\u2d54 \u2d4e\u2d30\u2d59 \u2d49\u2d33\u2d30 \u2d53\u2d63\u2d61\u2d49\u2d54\u2d49 \u2d4f\u2d4f\u2d59 \u2d49\u2d4e\u2d65\u2d65\u2d49\u2d62\u2d4f \u2d4f\u2d56\u2d37 \u2d49\u2d4e\u2d63\u2d37\u2d30\u2d62\u2d4f \u2d37 \u2d5c\u2d33\u2d49\u2d54\u2d30 \u2d4f\u2d4f\u2d59. \u2d5c\u2d30\u2d61\u2d53\u2d54\u2d49 \u2d4f\u2d4f\u2d3d \u2d5c\u2d33\u2d30 \u2d30\u2d37 \u2d4f\u2d59\u2d59\u2d56\u2d53\u2d37\u2d53 \u2d4e\u2d30\u2d59\u2d37 \u2d5c\u2d49\u2d56\u2d63\u2d49 \u2d4f \u2d53\u2d59\u2d4e\u2d3d\u2d4d \u2d4f \u2d49\u2d4f\u2d31\u2d54\u2d30\u2d4d\u2d4f \u2d30\u2d37 \u2d59\u2d49\u2d4f \u2d5c\u2d33\u2d30 \u2d62\u2d30\u2d4f \u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d30\u2d4e\u2d63\u2d61\u2d30\u2d54\u2d53. \u2d30\u2d4e\u2d37\u2d62\u2d30, \u2d30\u2d59\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Return True \u2d49\u2d33\u2d30\u2d4f \u2d49\u2d3c\u2d54\u2d37\u2d49\u2d59\u2d4f \u2d4f \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d37\u2d30 \u2d59\u2d59\u2d53\u2d37\u2d53\u2d4f \u2d59 \u2d53\u2d56\u2d4d\u2d49 \u2d4f\u2d56\u2d37 \u2d59 \u2d53\u2d37\u2d54\u2d30\u2d54.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"\u2d5c\u2d30\u2d61\u2d53\u2d54\u2d49 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d62\u2d30\u2d5c \u2d5c\u2d4e\u2d54\u2d59\u2d5c \u2d4f\u2d4f\u2d30 \u2d49\u2d5c\u2d5c\u2d53\u2d4e\u2d65\u2d4f \u2d62\u2d30\u2d4f \u2d53\u2d56\u2d55\u2d39\u2d49 \u2d30\u2d4e\u2d4e \u2d53\u2d3d\u2d5b\u2d5b\u2d53\u2d4e \u2d30\u2d54 \u2d49\u2d5c\u2d5c\u2d30\u2d3d\u2d3d\u2d30 \u2d5c\u2d30\u2d33\u2d53\u2d5c \u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f \u2d53\u2d3c\u2d4d\u2d4d\u2d30 \u2d37\u2d30\u2d62' \u2d49\u2d59\u2d3d\u2d49\u2d37\u2d4f \u2d4f ASCII. \u2d49\u2d4e\u2d37\u2d62\u2d30\u2d5c\u2d4f: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    \u2d37\u2d30 \u2d49\u2d5c\u2d5c\u2d30\u2d3d\u2d3d\u2d30 True \u2d4e\u2d3d \u2d4d\u2d4d\u2d30\u2d4f \u2d59\u2d49\u2d4f \u2d49\u2d3c\u2d54\u2d37\u2d49\u2d59\u2d4f \u2d49\u2d4e\u2d63\u2d30\u2d54\u2d30\u2d62\u2d4f \u2d33 \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f\u2d4f\u2d30 \u2d49\u2d5c\u2d5c\u2d33\u2d33\u2d30\u2d4f \u2d30\u2d4e\u2d62\u2d30, \u2d37 False \u2d4e\u2d3d \u2d53\u2d54 \u2d49\u2d33\u2d49.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"\u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d53\u2d59\u2d59\u2d30\u2d56\u2d53\u2d4d \u2d59 \u2d49\u2d3c\u2d54\u2d37\u2d49\u2d59\u2d4f \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d4f\u2d3c\u2d4d\u2d4f \u2d59 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"\u2d59\u2d33 \u2d53\u2d4e\u2d59\u2d30\u2d59\u2d30 \u2d4f\u2d4f\u2d30 \u2d49\u2d59\u2d4e\u2d37\u2d62\u2d30\u2d4f \u2d5c\u2d30\u2d33\u2d53\u2d5c \u2d4f \u2d5c\u2d59\u2d3d\u2d4d\u2d30 \u2d4f\u2d4f\u2d30 \u2d33 \u2d4d\u2d4d\u2d30\u2d4f\u2d5c \u2d5c\u2d53\u2d4f\u2d56\u2d49\u2d4d\u2d49\u2d4f \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d53\u2d54 \u2d49\u2d43\u2d4d\u2d49\u2d4f, \u2d5c\u2d30\u2d61\u2d53\u2d54\u2d49 \u2d4f\u2d4f\u2d3d \u2d5c\u2d33\u2d30 \u2d30\u2d37 \u2d5c\u2d59\u2d59\u2d3d\u2d5c\u2d54 \u2d62\u2d30\u2d5c \u2d5c\u2d53\u2d4f\u2d56\u2d49\u2d4d\u2d5c \u2d37 \u2d30\u2d37 \u2d5c\u2d59\u2d59\u2d3d\u2d5c\u2d54. \u2d5c\u2d53\u2d4f\u2d56\u2d49\u2d4d\u2d5c \u2d4f\u2d4f\u2d30 \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d3d\u2d5c\u2d54 \u2d49\u2d47\u2d47\u2d30\u2d4f \u2d30\u2d37 \u2d5c\u2d33 \u2d5c\u2d53\u2d4f\u2d56\u2d49\u2d4d\u2d5c \u2d4f\u2d4f\u2d30 \u2d56\u2d53\u2d54 \u2d49\u2d4d\u2d4d\u2d30 \u2d61\u2d30\u2d5c\u2d49\u2d33 \u2d30\u2d4e\u2d65\u2d65\u2d62\u2d30\u2d4f \u2d30\u2d4e\u2d4e \u2d61\u2d30\u2d39. \u2d4e\u2d3d \u2d5c\u2d5c\u2d62\u2d30\u2d3c\u2d30\u2d4f \u2d3d\u2d49\u2d33\u2d30\u2d4f \u2d4f \u2d5c\u2d53\u2d4f\u2d56\u2d49\u2d4d\u2d49\u2d4f \u2d56\u2d53\u2d54 \u2d49\u2d4d\u2d4d\u2d30 \u2d61\u2d30\u2d5c\u2d49\u2d33 \u2d30\u2d4e\u2d65\u2d65\u2d62\u2d30\u2d4f \u2d30\u2d4e\u2d4e \u2d61\u2d30\u2d39, \u2d59\u2d3d\u2d5c\u2d54 \u2d5c\u2d53\u2d4f\u2d56\u2d49\u2d4d\u2d5c \u2d4f\u2d4f\u2d30 \u2d56\u2d53\u2d54 \u2d49\u2d4d\u2d4d\u2d30 \u2d61\u2d30\u2d5c\u2d49\u2d33 \u2d30\u2d4e\u2d65\u2d65\u2d62\u2d30\u2d4f \u2d30\u2d4e\u2d4e \u2d61\u2d30\u2d5c\u2d49\u2d33. \u2d5c\u2d53\u2d4f\u2d56\u2d49\u2d4d\u2d5c \u2d4f\u2d4f\u2d30 \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d3d\u2d5c\u2d54 \u2d49\u2d47\u2d47\u2d30\u2d4f \u2d30\u2d37 \u2d5c\u2d5c\u2d53\u2d59\u2d3d\u2d5c\u2d54 \u2d33 \u2d5c\u2d4d\u2d33\u2d30, [smallest_val\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"\u2d30 \u2d3c\u2d30\u2d4d \u2d49\u2d4b\u2d4b\u2d30 \u2d59\u2d5c\u2d54\u2d49\u2d4f\u2d36 \u2d62\u2d48\u2d48\u2d30\u2d4d \u2d4f \u2d30\u2d4d\u2d3e\u2d49\u2d5c\u2d5c\u2d30\u2d31\u2d30\u2d4f \u2d53\u2d49 \u2d4e\u2d30\u2d37\u2d54\u2d53\u2d49\u2d4f\u2d62\u2d4f \u2d49\u2d4b\u2d4b\u2d30\u2d4f\u2d62\u2d4f \u2d5c\u2d49\u2d63\u2d4d\u2d30\u2d49\u2d30\u2d4f \u2d59 \u2d59\u2d31\u2d62\u2d5b\u2d62\u2d54, \u2d30\u2d37 \u2d62\u2d54\u2d62\u2d4e \u2d62\u2d3c\u2d62\u2d59 \u2d4f \u2d30\u2d4d\u2d3e\u2d49\u2d5c\u2d5c\u2d30\u2d31 \u2d59 \u2d49\u2d4b\u2d4b\u2d49\u2d5c \u2d4f \u2d30\u2d59\u2d49\u2d53\u2d49\u2d4d \u2d5c\u2d53\u2d4d\u2d30\u2d59 \u2d49\u2d4d\u2d30 \u2d49\u2d37\u2d37\u2d49\u2d3e\u2d53\u2d37 \u2d4f \u2d30\u2d59\u2d49\u2d53\u2d49\u2d4d \u2d53\u2d30 \u2d49\u2d4b\u2d4b\u2d30\u2d4f \u2d3c\u2d30\u2d4d \u2d30\u2d53\u2d62\u2d4f. \u2d30 \u2d3c\u2d30\u2d4d \u2d49\u2d4d\u2d30\u2d4f \u2d30\u2d4d\u2d3e\u2d49\u2d5c\u2d5c\u2d30\u2d31\u2d30\u2d4f \u2d30\u2d4b\u2d4b\u2d53\u2d5c\u2d4f\u2d62\u2d4f \u2d49\u2d4d\u2d30\u2d4f\u2d62\u2d4f \u2d49\u2d4b\u2d4b\u2d49\u2d5c \u2d53\u2d4d\u2d30\u2d42\u2d30\u2d4f, \u2d30\u2d37 \u2d62\u2d54\u2d62\u2d4e \u2d3c\u2d53\u2d3e \u2d4f\u2d30\u2d59\u2d30\u2d4f \u2d30\u2d4d\u2d4e\u2d49\u2d5c\u2d30\u2d4d: \u2d42\u2d49\u2d59\u2d5c\u2d53\u2d36\u2d54\u2d30\u2d4e ((\u2d30 \u2d31 \u2d5b) == {'\u2d30': 1, '\u2d31': 1, '\u2d5b': 1} \u2d42\u2d49\u2d59\u2d5c\u2d53\u2d36\u2d54\u2d30\u2d4e ((\u2d30 \u2d31 \u2d31 \u2d31 \u2d30') == {'\u2d30': 2, '\u2d31': 2} \u2d42\u2d49\u2d59\u2d5c\u2d53\u2d36\u2d54\u2d30\u2d4e ((\u2d30 \u2d31 \u2d5b \u2d30 \u2d31')\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"\u2d5c\u2d30\u2d4d\u2d56\u2d30 \u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f Fib4 \u2d5c\u2d33\u2d30 \u2d5c\u2d30\u2d4d\u2d56\u2d30 \u2d62\u2d30\u2d3d\u2d59\u2d53\u2d4d\u2d4f \u2d49 \u2d5c\u2d30\u2d4d\u2d56\u2d30 \u2d4f \u2d3c\u2d49\u2d31\u2d53\u2d4f\u2d30\u2d5b\u2d49 \u2d4f\u2d4f\u2d30 \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d4f\u2d4e\u2d4d\u2d4f \u2d59 \u2d53\u2d4e\u2d3d \u2d30\u2d37: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). \u2d54\u2d4f\u2d49 \u2d5c\u2d30\u2d61\u2d53\u2d54\u2d49 \u2d49 \u2d53\u2d59\u2d49\u2d59\u2d59\u2d4f \u2d4f \u2d49\u2d3c\u2d54\u2d37\u2d49\u2d59\u2d4f \u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f fib4 \u2d59 \u2d62\u2d30\u2d5c \u2d5c\u2d56\u2d30\u2d54\u2d30\u2d59\u2d5c \u2d49\u2d3c\u2d53\u2d4d\u2d3d\u2d49\u2d4f. \u2d53\u2d54 \u2d5c\u2d59\u2d59\u2d4e\u2d54\u2d59 \u2d5c\u2d49\u2d3d\u2d4d\u2d49\u2d5c.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"\u2d5c\u2d30\u2d61\u2d53\u2d54\u2d49 \u2d4f\u2d4f\u2d3d \u2d5c\u2d33\u2d30 \u2d30\u2d37 \u2d5c\u2d30\u2d54\u2d54\u2d30 \u2d5c\u2d30\u2d61\u2d53\u2d54\u2d49 \u2d4f\u2d4f\u2d30 \u2d49\u2d5c\u2d5c\u2d30\u2d3d\u2d3d\u2d30\u2d4f \u2d5c\u2d49\u2d37\u2d5c \u2d49\u2d56 \u2d49\u2d33\u2d30 \u2d53\u2d5f\u2d5f\u2d53\u2d4f x \u2d5c\u2d30\u2d63\u2d37\u2d53\u2d56\u2d5c \u2d5c\u2d30\u2d4e\u2d62\u2d49\u2d61\u2d30\u2d4f\u2d5c \u2d4f n \u2d37 \u2d5c\u2d49\u2d31\u2d54\u2d59\u2d33\u2d33\u2d61\u2d30\u2d37\u2d5c \u2d33 \u2d61\u2d30\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d62\u2d30\u2d39\u2d4f. x \u2d5c\u2d33\u2d30 \u2d5c\u2d30\u2d63\u2d37\u2d53\u2d56\u2d5c \u2d5c\u2d30\u2d4e\u2d62\u2d49\u2d61\u2d30\u2d4f\u2d5c \u2d4f n \u2d49\u2d56 \u2d49\u2d33\u2d30 n**int=x \u2d59 \u2d53\u2d4e\u2d37\u2d62\u2d30: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"\"\u2d30\u2d5b\u2d3d\u2d53 \u2d4f\u2d5c\u2d5c\u2d30\u2d3c \u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d5c\u2d49\u2d3c\u2d54\u2d49\u2d59\u2d49\u2d4f, \u2d33 \u2d3d\u2d53 \u2d5c\u2d49\u2d3c\u2d54\u2d49\u2d59\u2d5c \u2d53\u2d54 \u2d49\u2d4d\u2d4d\u2d49 \u2d4e\u2d30\u2d62\u2d37 \u2d49\u2d33\u2d30\u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f\u2d4f, \u2d4f\u2d59\u2d59\u2d3d\u2d54 \u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c. \u2d3d\u2d53 \u2d49\u2d3c\u2d54\u2d37\u2d49\u2d59 i \u2d4f \u2d5c\u2d62\u2d30\u2d3c\u2d53\u2d5c \u2d49\u2d47\u2d47\u2d30\u2d4f\u2d37 \u2d30\u2d37 \u2d49\u2d33 \"\u2d49\u2d39 \u2d4f \u2d49\u2d3c\u2d54\u2d37\u2d49\u2d59\u2d4f \u2d49\u2d4e\u2d63\u2d30\u2d54\u2d30\u2d62\u2d4f \u2d33 \u2d5c\u2d49\u2d3c\u2d54\u2d49\u2d59\u2d5c i \u2d4f \u2d53\u2d59\u2d3d\u2d5b\u2d4e\". \u2d33 \u2d49\u2d47\u2d47\u2d30\u2d4f\u2d37 \u2d30\u2d37 \u2d5c\u2d5c\u2d53\u2d59\u2d4f\u2d3c\u2d30\u2d4d\u2d5c \u2d5c\u2d49\u2d3c\u2d54\u2d49\u2d59\u2d49\u2d4f \u2d30\u2d3d\u2d3d\u2d61 \u2d59 \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f\u2d4f \u2d49\u2d4e\u2d63\u2d30\u2d54\u2d30\u2d62\u2d4f \u2d33 \u2d5c\u2d49\u2d3c\u2d54\u2d49\u2d59\u2d5c \u2d5c\u2d49\u2d59\u2d59 i \u2d4f \u2d53\u2d59\u2d3d\u2d5b\u2d4e.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"\u2d37\u2d30 \u2d5c\u2d5c\u2d53\u2d3c\u2d3d\u2d30 \u2d59\u2d49\u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d49\u2d4e\u2d4f\u2d49\u2d37\u2d4f n \u2d37 m, \u2d37 \u2d5c\u2d30\u2d61\u2d53\u2d54\u2d49 \u2d4f\u2d4f\u2d3d \u2d5c\u2d33\u2d30 \u2d30\u2d37 \u2d5c\u2d59\u2d59\u2d49\u2d5f\u2d4f \u2d30\u2d4e\u2d4e\u2d30\u2d59 \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d59\u2d33 n \u2d30\u2d54 m (\u2d59\u2d33 \u2d33\u2d30\u2d4f n \u2d37 m). \u2d59\u2d59\u2d53\u2d37\u2d53\u2d4f \u2d5c\u2d30\u2d54\u2d30\u2d54\u2d53\u2d5c \u2d56\u2d54 \u2d53\u2d4e\u2d39\u2d30\u2d4f \u2d30\u2d4e\u2d37\u2d37\u2d30\u2d37 \u2d30\u2d3d\u2d3d\u2d61 \u2d62\u2d53\u2d59\u2d49\u2d4f \u2d37 \u2d5c\u2d59\u2d4f\u2d3c\u2d4d \u2d56\u2d54 \u2d31\u2d49\u2d4f\u2d30\u2d54\u2d49. \u2d4e\u2d3d \u2d49\u2d33\u2d30 n \u2d30\u2d45\u2d30\u2d5c\u2d30\u2d54 \u2d59\u2d33 m, \u2d59\u2d59\u2d53\u2d37\u2d53\u2d4f -1. \u2d30\u2d4e\u2d37\u2d62\u2d30: rounded_avg(1, 5) => \"0b11\" rounded_avg(7, 5) => -1 rounded_avg(10, 20) => \"0b11\" rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    \u2d33 \u2d53\u2d59\u2d30\u2d5c\u2d49 \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f, \u2d59\u2d5c\u2d53\u2d5c\u2d5c\u2d49 \u2d4f \u2d61\u2d30\u2d5c\u2d49\u2d33 \u2d30\u2d4e\u2d65\u2d65\u2d62\u2d30\u2d4f \u2d4f \u2d3d\u2d54\u2d30 \u2d4f \u2d53\u2d59\u2d30\u2d5c\u2d49 \u2d30\u2d4e\u2d65\u2d65\u2d62\u2d30\u2d4f \u2d53\u2d54 \u2d49\u2d33\u2d49\u2d4f \u2d53\u2d4e\u2d65\u2d65\u2d62\u2d30\u2d4f. \u2d30\u2d4e\u2d37\u2d62\u2d30 minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    \u062f \u0628\u0634\u067e\u0693 \u0634\u0645\u06cc\u0631\u0648\u0646\u0648 \u06cc\u0648 \u0635\u0641 \u0648\u0631\u06a9\u0693\u0644 \u0634\u0648\u06cc \u060c \u062f 1 \u0627\u0648 9 \u067e\u0647 \u0634\u0645\u0648\u0644 \u062f \u0628\u0634\u067e\u0693 \u0634\u0645\u06cc\u0631\u0648\u0646\u0648 \u062a\u0631\u062a\u06cc\u0628 \u06a9\u0693\u0626 \u060c \u067e\u0627\u06cc\u0644\u0647 \u0644\u0631\u0648\u0646\u06a9\u06cc \u0635\u0641 \u0628\u06cc\u0631\u062a\u0647 \u0648\u0627\u0693\u0648\u0626 \u060c \u0627\u0648 \u0628\u06cc\u0627 \u0647\u0631 \u0639\u062f\u062f \u062f \u062f\u06d0 \u062f \u0648\u0631\u062a\u0647 \u0646\u0648\u0645 \u0633\u0631\u0647 \u0681\u0627\u06cc \u067e\u0647 \u0681\u0627\u06cc \u06a9\u0693\u0626 \u0644\u0647 \"\u06cc\u0648\" \u060c \"\u062f\u0648\u0647\" \u060c \"\u062f\u0631\u06d0\" \u060c \"\u0685\u0644\u0648\u0631\" \u060c \"\u067e\u0646\u0681\u0647\" \u060c \"\u0634\u067e\u0696\" \u060c \" \u0627\u0648\u0647\" \u060c \"\u0627\u0648\u06cc\u0627\" \u060c \"\u0646\u0647\". \u062f \u0645\u062b\u0627\u0644 \u067e\u0647 \u062a\u0648\u06ab\u0647: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> \u062a\u0631\u062a\u06cc\u0628 arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> \u0628\u06cc\u0631\u062a\u0647 arr -> [8, 5, 4, 3, 2, 2, 1, 1] \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u0633\u062a\u0648\u0646 \u06a9\u0693\u0626 [\" \u0627\u062a\u0647\" \u060c \"\u067e\u0646\u062c\" \u060c \"\u062f\u0631\u06d0\" \u060c \"\u062f\u0648\u0647\" \u060c \"\u062f\u0648\u0647\" \u060c \"\u06cc\u0648\" \u060c \"\u06cc\u0648\"] \u06a9\u0647 \u0686\u06cc\u0631\u06d0 \u0635\u0641 \u062e\u0627\u0644\u064a \u0648\u064a \u060c \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u0633\u062a\u0648\u0646 \u06a9\u0693\u0626: arr = [] array []\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"\u062a\u0627\u0633\u0648 \u0628\u0627\u06cc\u062f \u06cc\u0648 \u062f\u0627\u0633\u06d0 \u0641\u0646\u06a9\u0634\u0646 \u0648\u0644\u06cc\u06a9\u0626 \u0686\u06d0 \u062f \u0646\u06cc\u067c\u06d0 \u062f \u062a\u0627\u0631 \u0627\u0639\u062a\u0628\u0627\u0631 \u062a\u0627\u06cc\u06cc\u062f\u0648\u064a \u0627\u0648 \u0631\u06cc\u069a\u062a\u06cc\u0627 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u0633\u062a\u0648\u0646\u0648\u064a \u06a9\u0647 \u0646\u06cc\u067c\u0647 \u062f \u0627\u0639\u062a\u0628\u0627\u0631 \u0648\u0693 \u0648\u064a \u06a9\u0647 \u0646\u0647 \u0646\u0648 \u063a\u0644\u0637. \u0646\u06cc\u067c\u0647 \u062f \u0627\u0639\u062a\u0628\u0627\u0631 \u0648\u0693 \u062f\u0647 \u06a9\u0647 \u0644\u0627\u0646\u062f\u06d0 \u067c\u0648\u0644 \u0642\u0648\u0627\u0639\u062f \u067e\u0648\u0631\u0647 \u0634\u064a: 1. \u062f \u0646\u06cc\u067c\u06d0 \u062a\u0627\u0631 \u062e\u0627\u0644\u064a \u0646\u0647 \u0648\u064a. 2. \u062f \u0648\u0631\u0681\u0648 \u0634\u0645\u06cc\u0631 \u062f \u0645\u06cc\u0627\u0634\u062a\u0648 \u0644\u067e\u0627\u0631\u0647 1 \u06cc\u0627 31 \u0648\u0631\u0681\u0648 \u0685\u062e\u0647 \u06a9\u0645 \u0646\u0647 \u0648\u064a. \u0627\u0648 \u062f \u0648\u0631\u0681\u0648 \u0634\u0645\u06cc\u0631 \u062f \u0645\u06cc\u0627\u0634\u062a\u0648 \u0644\u067e\u0627\u0631\u0647 1 \u06cc\u0627 30 \u0648\u0631\u0681\u0648 \u0685\u062e\u0647 \u06a9\u0645 \u0646\u0647 \u0648\u064a. \u0627\u0648 \u062f \u0645\u06cc\u0627\u0634\u062a\u0648 \u0634\u0645\u06cc\u0631 \u062f \u0645\u06cc\u0627\u0634\u062a\u06d0 \u0644\u067e\u0627\u0631\u0647 1 \u06cc\u0627 29 \u0685\u062e\u0647 \u06a9\u0645 \u0646\u0647 \u0648\u064a. 3. \u0645\u06cc\u0627\u0634\u062a\u06d0 \u0628\u0627\u06cc\u062f \u0644\u0647 1 \u0685\u062e\u0647 \u06a9\u0645 \u0646\u0647 \u0648\u064a \u06cc\u0627 \u0644\u0647 12 \u0685\u062e\u0647 \u0689\u06cc\u0631 \u0646\u0647 \u0648\u064a. 4. \u0646\u06cc\u067c\u0647 \u0628\u0627\u06cc\u062f \u067e\u0647 \u0641\u0627\u0631\u0645\u06cc\u067c \u06a9\u06d0 \u0648\u064a: mm-dd-yyyy \u062f \u0645\u062b\u0627\u0644 \u067e\u0647 \u062a\u0648\u06ab\u0647: valid_date ((('03-11-2000') => valid_date ((('15-01-2012') => false valid_date ((('04-02040') => false_\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"\u062a\u0627\u0633\u0648 \u062a\u0647 \u064a\u0648 \u062a\u0627\u0631 s \u062f\u0631\u06a9\u0648\u0644 \u0634\u0648\u06cc \u062f\u06cc. \u06a9\u0647 s[i] \u064a\u0648 \u062d\u0631\u0641 \u0648\u064a\u060c \u062f \u0647\u063a\u0647 \u0642\u0636\u06cc\u06d0 \u0644\u0647 \u069a\u06a9\u062a\u0647 \u0685\u062e\u0647 \u067e\u0648\u0631\u062a\u0647 \u062a\u0647 \u0627\u0648 \u064a\u0627 \u0628\u0631\u0639\u06a9\u0633 \u062a\u0647 \u0648\u0627\u0693\u0648\u064a\u060c \u06a9\u0647 \u0646\u0647 \u0646\u0648 \u0647\u063a\u0647 \u067e\u0647 \u062e\u067e\u0644 \u062d\u0627\u0644 \u06a9\u06d0 \u0648\u0633\u0627\u062a\u0626. \u06a9\u0647 \u0686\u06d0\u0631\u06d0 \u062a\u0627\u0631 \u06a9\u06d0 \u06a9\u0648\u0645 \u062d\u0631\u0641\u0648\u0646\u0647 \u0646\u0647 \u0648\u064a\u060c \u0646\u0648 \u062a\u0627\u0631 \u0628\u06d0\u0631\u062a\u0647 \u0648\u0627\u0693\u0648\u064a. \u062f \u0641\u0646\u06a9\u0634\u0646 \u0628\u0627\u064a\u062f \u062f \u067e\u0627\u064a\u0644\u06d0 \u062a\u0627\u0631 \u0628\u06d0\u0631\u062a\u0647 \u0631\u0627\u0648\u0644\u064a. \u0645\u062b\u0627\u0644\u0648\u0646\u0647 \u062d\u0644 (((\"1234\") = \"4321\" \u062d\u0644 (((\"ab\") = \"AB\" \u062d\u0644 (((\"#a@C\") = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"\u062a\u0627\u0633\u0648 \u062a\u0647 \u062f\u0646\u062f\u0647 \u062f\u0631\u06a9\u0648\u0644 \u0634\u0648\u06d0 \u0686\u06d0 \u062f \u06cc\u0648 \u0641\u0646\u06a9\u0634\u0646 \u0644\u06cc\u06a9\u0644 \u0686\u06d0 \u062f \u06cc\u0648 \u0647\u06a9\u0633\u0627\u062f\u0633\u06cc\u0645\u0627\u0644 \u0634\u0645\u06cc\u0631 \u067e\u0647 \u062a\u0648\u06ab\u0647 \u062f \u062a\u0627\u0631 \u067e\u0647 \u062a\u0648\u06ab\u0647 \u062a\u0631\u0644\u0627\u0633\u0647 \u06a9\u0648\u064a \u0627\u0648 \u062f \u0647\u06a9\u0633\u0627\u062f\u0633\u06cc\u0645\u0627\u0644 \u0689\u06cc\u062c\u06cc\u067c\u0648\u0646\u0648 \u0634\u0645\u06cc\u0631 \u0634\u0645\u06cc\u0631\u0644 \u06a9\u06cc\u0696\u064a \u0686\u06d0 \u0644\u0648\u0645\u0693\u0646\u064a \u062f\u064a (\u0644\u0648\u0645\u0693\u06cc \u0634\u0645\u06cc\u0631 \u060c \u06cc\u0627 \u0644\u0648\u0645\u0693\u0646\u06cc \u060c \u06cc\u0648 \u0637\u0628\u06cc\u0639\u064a \u0634\u0645\u06cc\u0631 \u062f\u06cc \u0686\u06d0 \u0644\u0647 1 \u0685\u062e\u0647 \u0644\u0648\u06cc \u062f\u06cc \u0686\u06d0 \u062f \u062f\u0648\u0647 \u06a9\u0648\u0686\u0646\u064a \u0637\u0628\u06cc\u0639\u064a \u0634\u0645\u06cc\u0631\u0648 \u0645\u062d\u0635\u0648\u0644 \u0646\u0647 \u062f\u06cc). \u0647\u06a9\u0633\u0627\u062f\u0633\u06cc\u0645\u0627\u0644 \u0689\u06cc\u062c\u06cc\u067c\u0648\u0646\u0647 0 \u060c 1 \u060c 2 \u060c 3 \u060c 4 \u060c 5 \u060c 6 \u060c 7 \u060c 8 \u060c 9 \u060c A \u060c B \u060c C \u060c D \u060c E \u060c F \u062f\u064a. \u0644\u0648\u0645\u0693\u0646\u064a \u0634\u0645\u06cc\u0631\u06d0 2 \u060c 3 \u060c 5 \u060c 7 \u060c 11 \u060c 13 \u060c 17 \u060c... \u062f\u064a \u0646\u0648 \u062a\u0627\u0633\u0648 \u0628\u0627\u06cc\u062f \u062f \u0644\u0627\u0646\u062f\u06d0 \u0689\u06cc\u062c\u06cc\u067c\u0648\u0646\u0648 \u0634\u0645\u06cc\u0631 \u0648\u067c\u0627\u06a9\u0626: 2 \u060c 3 \u060c 5 \u060c 7 \u060c 7 \u060c B (= \u0644\u0633\u06cc\u0632\u0647 11) \u060c D (= \u0644\u0633\u06cc\u0632\u0647 13). \u06cc\u0627\u062f\u0648\u0646\u0647: \u062a\u0627\u0633\u0648 \u06a9\u0648\u0644\u06cc \u0634\u0626 \u0641\u0631\u0636\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    \u062f\u0627 \u0686\u06a9 \u06a9\u0648\u064a \u0686\u06d0 \u0648\u0631\u06a9\u0693\u0644 \u0634\u0648\u06cc \u062a\u0627\u0631 \u06cc\u0648 \u067e\u0627\u0644\u06cc\u0646\u0689\u0631\u0648\u0645 \u062f\u06cc \u06a9\u0647 \u0646\u0647\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"\u062f \u0644\u06cc\u0633\u062a l \u06a9\u06d0 \u062f \u0639\u0646\u0627\u0635\u0631\u0648 \u0645\u0646\u0681\u0646\u06cd \u0628\u0631\u062e\u0647 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u06ab\u0631\u0681\u0626.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    \u067e\u0647 x \u0646\u0642\u0637\u0647 \u06a9\u06d0 \u062f \u06a9\u0648\u0641\u064a\u0641\u06d0\u0633\u0646\u067c xs \u0633\u0631\u0647 \u067e\u0648\u0644\u06cc\u0646\u0648\u0645 \u0627\u0631\u0632\u0648\u064a. xs[0] + xs[1] * x + xs[1] * x ^ 2 +.... xs[n] * x ^ n \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u06ab\u0631\u0681\u0626\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"\u062f \u0641\u0628\u0648\u0646\u0627\u0686\u064a \u062f n \u0634\u0645\u06d0\u0631\u06d0 \u0628\u06d0\u0631\u062a\u0647 \u0648\u0631\u06a9\u0648\u0644.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" \u062f \u0645\u062b\u0628\u062a \u062a\u0639\u0648\u06cc\u0636\u064a \u067c\u06a9\u064a \u0634\u0645\u06cc\u0631\u0647 \u0648\u0631\u06a9\u0693\u0644 \u0634\u0648\u06d0 \u060c \u062f\u0627 \u067e\u0647 \u0628\u0634\u067e\u0693 \u0628\u0631\u062e\u0647 (\u0644\u0648\u06cc \u0639\u062f\u062f \u062f \u0648\u0631\u06a9\u0693\u0644 \u0634\u0648\u064a \u0634\u0645\u06cc\u0631 \u0685\u062e\u0647 \u06a9\u0648\u0686\u0646\u06cc) \u0627\u0648 \u0644\u0633\u06cc\u0632\u0648 (\u067e\u0627\u062a\u0647 \u0628\u0631\u062e\u0647 \u062a\u0644 \u0644\u0647 1 \u0685\u062e\u0647 \u06a9\u0648\u0686\u0646\u06cd \u0648\u064a) \u06a9\u06d0 \u062a\u062d\u0644\u06cc\u0644 \u06a9\u06cc\u062f\u06cc \u0634\u064a. \u062f \u0634\u0645\u06cc\u0631 \u0644\u0633\u06cc\u0632\u0647 \u0628\u0631\u062e\u0647 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u06ab\u0631\u0681\u0626. \u0645\u062b\u0627\u0644:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    \u062f \u0645\u062b\u0628\u062a \u0639\u062f\u062f n \u067e\u0647 \u067e\u0627\u0645 \u06a9\u06d0 \u0646\u06cc\u0648\u0644\u0648 \u0633\u0631\u0647\u060c \u06cc\u0648 \u067c\u067e\u0644 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u06ab\u0631\u0681\u0648\u0626 \u0686\u06d0 \u062f \u062d\u062a\u06cc \u0627\u0648 \u0639\u062c\u06cc\u0628 \u0639\u062f\u062f \u067e\u0627\u0644\u06cc\u0646\u0689\u0631\u0648\u0645\u0648\u0646\u0648 \u0634\u0645\u06cc\u0631 \u0644\u0631\u064a \u0686\u06d0 \u067e\u0647 \u062d\u062f \u06a9\u06d0 \u0631\u0627\u0681\u064a ((1\u060c n) \u060c \u067e\u0647 \u0634\u0645\u0648\u0644. \u0645\u062b\u0627\u06441: \u0627\u0646 \u067e\u067c: 3 \u0645\u062d\u0635\u0648\u0644: (1, 2) \u062a\u0648\u0636\u06cc\u062d: \u0628\u0634\u067e\u0693 \u067e\u0627\u0644\u06cc\u0646\u0689\u0631\u0648\u0645\u0648\u0646\u0647 \u062f\u064a 1\u060c 2\u060c 3. \u06cc\u0648 \u06cc\u06d0 \u062d\u062a\u06cc \u062f\u06cc\u060c \u0627\u0648 \u062f\u0648\u0647 \u06cc\u06d0 \u0639\u062c\u06cc\u0628 \u062f\u064a. \u0645\u062b\u0627\u06442: \u0627\u0646 \u067e\u067c: 12 \u0645\u062d\u0635\u0648\u0644: (4, 6) \u062a\u0648\u0636\u06cc\u062d: \u0628\u0634\u067e\u0693 \u067e\u0627\u0644\u06cc\u0646\u0689\u0631\u0648\u0645\u0648\u0646\u0647 \u062f\u064a 1\u060c 2\u060c 3\u060c 4\u060c 5\u060c 6\u060c 7\u060c 8\u060c 9\u060c 11. \u0685\u0644\u0648\u0631 \u06cc\u06d0 \u062d\u062a\u06cc \u062f\u064a\u060c \u0627\u0648 6 \u06cc\u06d0 \u0639\u062c\u06cc\u0628 \u062f\u064a. \u06cc\u0627\u062f\u0648\u0646\u0647: 1. 1 <= n <= 10 ^ 3 2. \u067c\u067e\u0644 \u067e\u0647 \u062a\u0631\u062a\u06cc\u0628 \u0633\u0631\u0647 \u062f \u062d\u062a\u06cc \u0627\u0648 \u0639\u062c\u06cc\u0628 \u0639\u062f\u062f \u067e\u0627\u0644\u06cc\u0646\u0689\u0631\u0648\u0645\u0648\u0646\u0648 \u0634\u0645\u06cc\u0631 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u0633\u062a\u0648\u0646 \u06a9\u0693\u06cc.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" \u062f \u0628\u0634\u067e\u0693 \u0634\u0645\u06cc\u0631\u0648\u0646\u0648 \u062f \u0648\u0631\u06a9\u0693\u0644 \u0634\u0648\u064a \u0644\u06cc\u0633\u062a \u0644\u067e\u0627\u0631\u0647\u060c \u06cc\u0648 \u067c\u067e\u0644 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u06ab\u0631\u0681\u0648\u0626 \u0686\u06d0 \u062f \u067c\u0648\u0644\u06d0 \u0644\u06cc\u0633\u062a \u06a9\u06d0 \u062f \u067c\u0648\u0644\u0648 \u0628\u0634\u067e\u0693 \u0634\u0645\u06cc\u0631\u0648\u0646\u0648 \u0645\u062c\u0645\u0648\u0639\u0647 \u0627\u0648 \u0645\u062d\u0635\u0648\u0644 \u0644\u0631\u064a. \u062e\u0627\u0644\u064a \u0645\u062c\u0645\u0648\u0639\u0647 \u0628\u0627\u06cc\u062f 0 \u0633\u0631\u0647 \u0645\u0633\u0627\u0648\u064a \u0648\u064a \u0627\u0648 \u062e\u0627\u0644\u064a \u0645\u062d\u0635\u0648\u0644 \u0628\u0627\u06cc\u062f 1 \u0633\u0631\u0647 \u0645\u0633\u0627\u0648\u064a \u0648\u064a.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" \u062f \u064a\u0648 \u062a\u0627\u0631 \u067e\u0647 \u067e\u0627\u0645 \u06a9\u06d0 \u0646\u064a\u0648\u0644\u0648 \u0633\u0631\u0647\u060c \u0645\u0639\u0644\u0648\u0645\u0647 \u06a9\u0693\u0626 \u0686\u06d0 \u062f\u0627 \u0685\u0648\u0645\u0631\u0647 \u0628\u06d0\u0644\u0627\u0628\u06d0\u0644 \u062d\u0631\u0648\u0641 \u0644\u0631\u064a (\u062f \u0642\u0636\u06cc\u06d0 \u067e\u0647 \u067e\u0627\u0645 \u06a9\u06d0 \u0646\u06cc\u0648\u0644\u0648 \u067e\u0631\u062a\u0647)\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" \u062f \u0647\u0631\u06d0 \u067e\u06cc\u062a\u0648\u0646 \u0627\u0631\u0632\u069a\u062a\u0648\u0646\u0648 \u0648\u0631\u06a9\u0693\u0644 \u0634\u0648\u06cc \u0644\u06cc\u0633\u062a \u06cc\u0648\u0627\u0632\u06d0 \u062f \u0628\u0634\u067e\u0693\u0648\u0646\u0648 \u0644\u067e\u0627\u0631\u0647 \u0641\u0644\u067c\u0631 \u06a9\u0693\u0626\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    \u067e\u0647 \u062f\u06d0 \u06a9\u0627\u0631 \u06a9\u06d0\u060c \u062a\u0627\u0633\u0648 \u062a\u0647 \u0628\u0647 \u064a\u0648 \u062a\u0627\u0631 \u0686\u06d0 \u062f \u0645\u06bc\u0648 \u0627\u0648 \u0646\u0627\u0631\u0646\u062c\u0648\u0646\u0648 \u0686\u06d0 \u062f \u0645\u064a\u0648\u0648 \u067e\u0647 \u064a\u0648\u0647 \u067c\u0648\u06a9\u0631\u06cd \u06a9\u06d0 \u0648\u06cc\u0634\u0644 \u0634\u0648\u064a \u062f\u064a \u062f \u0634\u0645\u06d0\u0631 \u0627\u0633\u062a\u0627\u0632\u06cc\u062a\u0648\u0628 \u0648\u0631\u06a9\u0693\u0644 \u0634\u064a \u062f\u0627 \u067c\u0648\u06a9\u0631\u06cd \u0645\u06bc\u06d0\u060c \u0646\u0627\u0631\u0646\u062c\u060c \u0627\u0648 \u062f \u0645\u0627\u0646\u06ab\u0648 \u0645\u064a\u0648\u0648 \u0644\u0631\u064a. \u0648\u0631\u06a9\u0693\u0644 \u062f \u062a\u0627\u0631 \u0686\u06d0 \u062f \u0646\u0627\u0631\u0646\u062c\u0648\u0646\u0648 \u0627\u0648 \u0645\u06bc\u0648 \u062f \u067c\u0648\u0644 \u0634\u0645\u06d0\u0631 \u0627\u0648 \u062f \u064a\u0648 \u0639\u062f\u062f \u0686\u06d0 \u067e\u0647 \u067c\u0648\u06a9\u0631\u06cd \u06a9\u06d0 \u062f \u0645\u064a\u0648\u0648 \u062f \u067c\u0648\u0644 \u0634\u0645\u06d0\u0631 \u0627\u0633\u062a\u0627\u0632\u06cc\u062a\u0648\u0628 \u06a9\u0648\u064a \u067e\u0647 \u067c\u0648\u06a9\u0631\u06cd \u06a9\u06d0 \u062f \u0645\u0627\u0646\u06ab\u0648 \u0645\u064a\u0648\u0648 \u062f \u0634\u0645\u06d0\u0631 \u0628\u06d0\u0631\u062a\u0647. \u062f \u0645\u062b\u0627\u0644 \u067e\u0647 \u062a\u0648\u06ab\u0647: fruit_distribution\"5(\u0645\u06bc\u06d0 \u0627\u0648 6 \u0646\u0627\u0631\u0646\u062c\u0648\u0646\u0647\"\u060c 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 \u0645\u06bc\u06d0 \u0627\u0648 1 \u0646\u0627\u0631\u0646\u062c\u0648\u0646\u0647\u060c\"3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 \u0645\u06bc\u06d0 \u0627\u0648 3 \u0646\u0627\u0631\u0646\u062c\u0648\u0646\u0647\u060c\" 100) -> 100 - 2 - 3 = 95\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"\u062f\u0627 \u062f \u0633\u0645\u0633\u062a\u0631 \u0648\u0631\u0648\u0633\u062a\u06cd \u0627\u0648\u0646\u06cd \u062f\u0647 \u0627\u0648 \u069a\u0648\u0648\u0646\u06a9\u064a \u0628\u0627\u06cc\u062f \u0632\u062f\u0647 \u06a9\u0648\u0648\u0646\u06a9\u0648 \u062a\u0647 \u062f\u0631\u062c\u06d0 \u0648\u0631\u06a9\u0693\u064a. \u069a\u0648\u0648\u0646\u06a9\u064a \u062f \u062f\u0631\u062c\u06d0 \u0648\u0631\u06a9\u0648\u0644\u0648 \u0644\u067e\u0627\u0631\u0647 \u062e\u067e\u0644 \u0627\u0644\u06ab\u0648\u0631\u06cc\u062a\u0645 \u062c\u0648\u0693 \u06a9\u0693\u06cc \u062f\u06cc. \u06cc\u0648\u0627\u0632\u06cc\u0646\u06cd \u0633\u062a\u0648\u0646\u0632\u0647 \u062f\u0627 \u062f\u0647 \u0686\u06d0 \u0647\u063a\u0647 \u062f \u062f\u0631\u062c\u06d0 \u0648\u0631\u06a9\u0648\u0644\u0648 \u0644\u067e\u0627\u0631\u0647 \u06a9\u0627\u0631\u0648\u0644 \u0634\u0648\u06cc \u06a9\u0648\u0689 \u0644\u0647 \u0644\u0627\u0633\u0647 \u0648\u0631\u06a9\u0693\u06cc \u062f\u06cc. \u0647\u063a\u06d0 \u062a\u0627\u0633\u0648 \u062a\u0647 \u062f \u0681\u06cc\u0646\u06d0 \u0632\u062f\u0647 \u06a9\u0648\u0646\u06a9\u0648 \u0644\u067e\u0627\u0631\u0647 \u062f GPAs \u0644\u06cc\u0633\u062a \u062f\u0631\u06a9\u0693\u06cc \u0627\u0648 \u062a\u0627\u0633\u0648 \u0628\u0627\u06cc\u062f \u06cc\u0648 \u0641\u0646\u06a9\u0634\u0646 \u0648\u0644\u06cc\u06a9\u0626 \u0686\u06d0 \u06a9\u0648\u0644\u06cc \u0634\u064a \u062f \u0644\u0627\u0646\u062f\u06d0 \u062c\u062f\u0648\u0644 \u067e\u0647 \u06a9\u0627\u0631\u0648\u0644\u0648 \u0633\u0631\u0647 \u062f \u0644\u06cc\u06a9 \u062f\u0631\u062c\u06d0 \u0644\u06cc\u0633\u062a \u062a\u0648\u0644\u06cc\u062f \u06a9\u0693\u064a: GPA. \u062f \u0644\u06cc\u06a9 \u062f\u0631\u062c\u06d0 4.0 A + > 3.7 A > 3.3 A- > 3.0 B + > 2.7 B- > 2.3 B- > 2.0 B + > 1.7 C > 1.3 C- > 1.0 D + > 0.7 D > 0.0 D- 0.0 E \u0645\u062b\u0627\u0644: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"\u0633\u062a\u0627\u0633\u0648 \u062f\u0646\u062f\u0647 \u062f\u0627 \u062f\u0647 \u0686\u06d0 \u062f x * n \u0627\u0641\u0627\u062f\u06d0 \u0633\u0627\u062f\u0647 \u06a9\u0693\u0626. \u062f \u062f\u06d0 \u0641\u0646\u06a9\u0634\u0646 \u0631\u0627\u0633\u062a\u0646\u06cc\u062f\u0646\u0647 \u0631\u06cc\u069a\u062a\u06cc\u0627 \u062f\u0647 \u06a9\u0647 x * n \u0628\u0634\u067e\u0693 \u0634\u0645\u06cc\u0631 \u062a\u0647 \u0627\u0631\u0632\u069a\u062a \u0648\u0631\u06a9\u0693\u064a \u0627\u0648 \u06a9\u0647 \u0646\u0647 \u0646\u0648 \u063a\u0644\u0637. \u062f\u0648\u0627\u0693\u0647 x \u0627\u0648 n \u060c \u062f \u06a9\u0633\u0631 \u062a\u0627\u0631 \u0627\u0633\u062a\u0627\u0632\u06cc\u062a\u0648\u0628 \u062f\u06cc \u060c \u0627\u0648 \u0644\u0627\u0646\u062f\u06d0 \u0628 format\u0647 \u0644\u0631\u064a \u060c <\u0634\u0645\u06cc\u0631\u0648\u0646\u06a9\u06cc> \/ <\u0646\u0648\u0645\u06cc\u0646\u067c\u0631> \u0686\u06cc\u0631\u06d0 \u0686\u06d0 \u062f\u0648\u0627\u0693\u0647 \u0634\u0645\u06cc\u0631\u0648\u0646\u06a9\u06cc \u0627\u0648 \u0646\u0648\u0645\u0648\u0646\u06a9\u06cc \u0645\u062b\u0628\u062a \u0628\u0634\u067e\u0693 \u0634\u0645\u06cc\u0631\u0648\u0646\u0647 \u062f\u064a. \u062a\u0627\u0633\u0648 \u06a9\u0648\u0644\u06cc \u0634\u0626 \u0641\u0631\u0636 \u06a9\u0693\u0626 \u0686\u06d0 x \u060c \u0627\u0648 n \u0645\u0639\u062a\u0628\u0631 \u06a9\u0633\u0631\u0648\u0646\u0647 \u062f\u064a \u060c \u0627\u0648 \u062f \u0646\u0648\u0645\u0648\u0646\u06a9\u06cc \u067e\u0647 \u062a\u0648\u06ab\u0647 \u0635\u0641\u0631 \u0646\u0644\u0631\u064a. \u0633\u0627\u062f\u0647 \u06a9\u0648\u0644 (((\"1\/5\" \u060c \"5\/1\") = \u0631\u06cc\u069a\u062a\u06cc\u0627 \u0633\u0627\u062f\u0647 \u06a9\u0648\u0644 (((\"1\/6\" \u060c \"2\/1\") = \u063a\u0644\u0637 \u0633\u0627\u062f\u0647 \u06a9\u0648\u0644 (((\"7\/10\" \u060c \"10\/2\") = \u063a\u0644\u0637\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"\u067e\u0647 \u0644\u06cc\u0633\u062a \u06a9\u06d0 \u06cc\u0648\u0627\u0632\u06d0 \u0645\u062b\u0628\u062a \u0634\u0645\u06cc\u0631\u06d0 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u06ab\u0631\u0681\u0648\u0626.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"\u062f \u064a\u0648 \u0641\u0646\u06a9\u0634\u0646 \u0644\u064a\u06a9\u0644 \u0686\u06d0 \u062f \u062a\u0627\u0631\u0648\u0646\u0648 \u064a\u0648 \u0644\u0693\u0644\u0633\u062a \u062f \u067e\u0627\u0631\u0627\u0645\u062a\u0631 \u067e\u0647 \u062a\u0648\u06ab\u0647 \u0648\u0645\u0646\u064a\u060c \u0647\u063a\u0647 \u062a\u0627\u0631\u0648\u0646\u0647 \u0686\u06d0 \u0628\u06d0 \u0681\u0627\u064a\u0647 \u0627\u0648\u0696\u062f\u0648\u0627\u0644\u0649 \u0644\u0631\u064a \u0644\u0647 \u0647\u063a\u06d0 \u0685\u062e\u0647 \u062d\u0630\u0641 \u06a9\u0693\u064a\u060c \u0627\u0648 \u062f \u064a\u0648 \u062a\u0631\u062a\u064a\u0628 \u0634\u0648\u064a \u062a\u0631\u062a\u064a\u0628 \u0633\u0631\u0647 \u067e\u0627\u064a\u0644\u0647 \u0644\u0631\u0648\u0646\u06a9\u06cc \u0644\u0693\u0644\u0633\u062a \u0628\u064a\u0631\u062a\u0647 \u0631\u0627\u0648\u0644\u064a\u060c \u0644\u0693\u0644\u0633\u062a \u062a\u0644 \u062f \u062a\u0627\u0631\u0648\u0646\u0648 \u064a\u0648 \u0644\u0693\u0644\u0633\u062a \u062f\u06cc \u0627\u0648 \u0647\u064a\u0685\u06a9\u0644\u0647 \u062f \u0634\u0645\u06cc\u0631\u0648 \u064a\u0648 \u0635\u0641 \u0646\u0647 \u062f\u06cc\u060c \u0627\u0648 \u06a9\u06d0\u062f\u0627\u06cc \u0634\u064a \u0686\u06d0 \u062f\u0648\u0647 \u0681\u0644\u06d0 \u0648\u0644\u0631\u064a. \u062f \u0644\u0693\u0644\u0633\u062a \u062a\u0631\u062a\u064a\u0628 \u0628\u0627\u064a\u062f \u062f \u0647\u0631\u06d0 \u06a9\u0644\u0645\u06d0 \u062f \u0627\u0648\u0696\u062f\u0648\u0627\u0644\u064a \u0644\u0647 \u0645\u062e\u06d0 \u067e\u0648\u0631\u062a\u0647 \u0634\u064a\u060c \u0627\u0648 \u062a\u0627\u0633\u0648 \u0628\u0627\u064a\u062f \u062f \u062f\u06d0 \u0642\u0627\u0639\u062f\u06d0 \u0644\u0647 \u0645\u062e\u06d0 \u062a\u0631\u062a\u064a\u0628 \u0634\u0648\u06cc \u0644\u0693\u0644\u0633\u062a \u0628\u064a\u0631\u062a\u0647 \u0631\u0627\u0648\u0644\u064a. \u06a9\u0647 \u062f\u0648\u0647 \u06a9\u0644\u0645\u06d0 \u064a\u0648 \u0634\u0627\u0646 \u0627\u0648\u0696\u062f\u0648\u0627\u0644\u0649 \u0648\u0644\u0631\u064a\u060c \u0646\u0648 \u0644\u0693\u0644\u0633\u062a \u067e\u0647 \u0627\u0644\u0641\u0628\u0627\u064a\u064a \u0689\u0648\u0644 \u062a\u0631\u062a\u06cc\u0628 \u06a9\u0693\u0626. \u062f \u0641\u0646\u06a9\u0634\u0646 \u0628\u0627\u064a\u062f \u062f \u062a\u0627\u0631\u0648\u0646\u0648 \u064a\u0648 \u0644\u0693\u0644\u0633\u062a \u067e\u0647 \u062a\u0631\u062a\u064a\u0628 \u0634\u0648\u064a \u062a\u0631\u062a\u064a\u0628 \u06a9\u06d0 \u0628\u064a\u0631\u062a\u0647 \u0631\u0627\u0648\u0644\u064a. \u062a\u0627\u0633\u0648 \u06a9\u0648\u0644\u0627\u0649 \u0634\u0626\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"\u062f\u0627 \u0641\u0646\u06a9\u0634\u0646 \u062f\u0648\u0647 \u0645\u062b\u0628\u062a \u0634\u0645\u06cc\u0631\u06d0 x \u0627\u0648 y \u0627\u062e\u0644\u064a \u0627\u0648 \u062a\u0631 \u067c\u0648\u0644\u0648 \u0644\u0648\u06cc \u0639\u062f\u062f \u0686\u06d0 \u067e\u0647 [x\u060c y] \u06a9\u06d0 \u062f\u06cc \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u0648\u0644\u064a. \u06a9\u0647 \u062f\u0627\u0633\u06d0 \u0634\u0645\u06cc\u0631\u0647 \u0634\u062a\u0648\u0646 \u0648\u0646\u0644\u0631\u064a\u060c \u0646\u0648 \u0641\u0646\u06a9\u0634\u0646 \u0628\u0627\u06cc\u062f -1 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u0648\u0644\u064a. \u062f \u0645\u062b\u0627\u0644 \u067e\u0647 \u062a\u0648\u06ab\u0647: choose_num (((12\u060c 15) = 14 choose_num (((13, 12) = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets \u062f \"<\" \u0627\u0648 \">\" \u06cc\u0648 \u062a\u0627\u0631 \u062f\u06cc. \u0631\u06cc\u069a\u062a\u06cc\u0646\u064a \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u0633\u062a\u0648\u0646 \u06a9\u0693\u0626 \u06a9\u0647 \u0686\u06cc\u0631\u06d0 \u0647\u0631 \u067e\u0631\u0627\u0646\u06cc\u0633\u062a\u0644 \u0634\u0648\u06cc \u0628\u0631\u0627\u06a9\u067c \u062f \u0648\u0631\u062a\u0647 \u062a\u0693\u0644\u0648 \u0628\u0631\u0627\u06a9\u067c \u0648\u0644\u0631\u064a.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    \u062a\u0627\u0633\u0648 \u062a\u0647 \u062f \u0628\u0634\u067e\u0693 \u0634\u0645\u06cc\u0631\u0648\u0646\u0648 \u0644\u06cc\u0633\u062a \u062f\u0631\u06a9\u0648\u0644 \u0634\u0648\u06cc. \u06cc\u0648 \u0641\u0646\u06a9\u0634\u0646 \u0648\u0644\u06cc\u06a9\u0626 next_smallest ((() \u0686\u06d0 \u062f \u0644\u06cc\u0633\u062a \u062f\u0648\u0647\u0645 \u06a9\u0648\u0686\u0646\u06cc \u0639\u0646\u0635\u0631 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u0648\u0644\u064a. \u0647\u06cc\u0685 \u0646\u0647 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u06ab\u0631\u0681\u0626 \u06a9\u0647 \u0686\u06cc\u0631\u06d0 \u062f\u0627\u0633\u06d0 \u0639\u0646\u0635\u0631 \u0634\u062a\u0648\u0646 \u0648\u0646\u0644\u0631\u064a. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == \u0647\u06cc\u0685 \u0646\u0647 next_smallest (([1, 1]) == \u0647\u06cc\u0685 \u0646\u0647\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"\u062f \u0628\u0634\u067e\u0693 \u0634\u0645\u06cc\u0631\u0648\u0646\u0648 \u063a\u06cc\u0631 \u062e\u0627\u0644\u064a \u0644\u06cc\u0633\u062a \u0648\u0631\u06a9\u0693\u0644 \u0634\u0648\u06cc \u060c \u062f \u067c\u0648\u0644\u0648 \u0639\u062c\u06cc\u0628 \u0639\u0646\u0627\u0635\u0631\u0648 \u0645\u062c\u0645\u0648\u0639\u0647 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u06ab\u0631\u0681\u0626 \u0686\u06d0 \u067e\u0647 \u062d\u062a\u06cc \u0645\u0648\u0642\u0639\u06cc\u062a\u0648\u0646\u0648 \u06a9\u06d0 \u062f\u064a. \u062f \u0645\u062b\u0627\u0644 \u062d\u0644 (([5, 8, 7, 1]) ==> 12 \u062d\u0644 (([3, 3, 3, 3, 3]) ==> 9 \u062d\u0644 (([30, 13, 24, 321]) ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"\u067e\u0647 \u0644\u0633\u062a \u06a9\u06d0 \u0627\u0639\u0638\u0645\u064a \u0639\u0646\u0635\u0631 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u06ab\u0631\u0681\u0648\u064a.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"\u062f \u062f\u0648\u0648 \u0644\u06cc\u0633\u062a\u0648\u0646\u0648 \u0644\u067e\u0627\u0631\u0647 \u0628\u06d0\u0644 \u0634\u0648\u064a \u0681\u0627\u0646\u06ab\u0693\u064a \u0639\u0627\u0645 \u0639\u0646\u0627\u0635\u0631 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u06ab\u0631\u0681\u0648\u064a.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"Kay semestropi qhipa semana, profesorqa yachachinmanmi yachakuqkunaman, profesorqa kikin algoritmopi ruwashan, chaytaq huk ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch'usaq ch\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Kaypi rikch'akun kay simikuna: {{{1}}}, {{{2}}}, {{{3}}}, {{{4}}}, {{{5}}}, {{{6}}}, {{{6}}}, {{{7}}}, {{{7}}}, {{{7}}}, {{{8}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}, {{{9}}}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Qhawarisun, n yupayta, n-ta aswan pisi, aswan hatun, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi, n-ta aswan pisi\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filtrar una lista de entrada de cadenas de caracteres solamente para las que empiezan con un prefijo dado. Kay listataqa filtrar, chaymantaqa, kay listataqa filtrar, chaymantaqa kay listataqa filtrar.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Qamqa tarinki entero yupaykuna listata. Qamqa maskanki aswan hatun prim valorta, hinaspataq kutichinki chay yupaykuna sumaqta. Ejemplos: Para lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3], chaymanta 10 Para lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1], chaymanta 25 Para lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3], chaymanta 13 Para lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6], chaymanta 11 Para lst = [0,81,12,31,21], chaymanta 3 Para lst = [0,8,1,\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Qusqu qhichwa simipi\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Qhapaqpi enteros nisqa q'u\u00f1i q'u\u00f1i, q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\u00f1i q'u\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib n-\u00f1ay kaq Fibonacci yupayta kutichin, chaytaq prim primus.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Kay llamk'ayqa, huk k'itiwan rikuchin, maypichus may chhika qutuchakunapi qutuchakunapi qutuchakunapaq t'aqakun, maypichus may chhika t'aqakunapaq t'aqakunapaq t'aqakun.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero nisqaqa entero yupaykunaq listanta jap'in. Kay listapi kimsa kaq kaq kaqkuna kaqtinqa, True nisqata kutichin, mana chayqa False nisqata kutichin.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Kay p'anqata qillqaspa, allin p'anqata kutichinki chayqa, allin p'anqata kutichinki chayqa, k'arita. Kay p'anqataqa allin p'anqataqa, kay kamachikuykunaman hunt'asqa kaptinmi: 1. Kay p'anqataqa mana ch'usaqchu. 2. Kay p'anqataqa mana pisichu icha aswan 31 p'unchaykuna, 1,3,5,7,8,10,12 killakunapi. Kay p'anqataqa mana pisichu icha aswan 30 p'unchawkuna, 4,6,9,11 killakunapi. Kay p'anqataqa mana pisichu icha aswan 29 p'unchawkuna, 2 killakunapi. Kay p'anqataqa mana pisichu icha aswan 12. Kay p'anqataqa kay hinam: mm-dd-yyyy, kay hinam: valid_date ({{'03-11-2000'}}\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Qhaway, may chhika k'iti k'iti k'iti qillqakunamanta (mana ima k'iti k'iti qillqakunamanta)\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nAstawan yachanapaq.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Rikuchispa, uj entero. kutichinqa uj tuplata, maypichus uj ch'ichi, uj ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'ichi, ch'\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Mana ch'usaq yupaykuna lst. listata rikuspa, ch'usaq yupaykunawan yapay. Ejemplos: sumachiy ([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi, kaypi.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels nisqaqa huk llamk'aymi, chaytaq string nisqata jap'in, hinaspataq vowels mana kaqtinqa string nisqata kutichin.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Qhapaq simikunaqa palindromo-nchu\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Rikuchiy True nisqata, sichus l listapi l yupaykuna t nisqata mana junt'anchu chayqa.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Fib4 yupaykunaq qhatunqa Fibbonacci yupaykunaq qhatun hinam: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Qhapaqpi tukuy k'iti yupaykuna, qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi qhichwa simipi\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Imachus chayllapi, chay iskay q'ala carreterakunaqa, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika karupi, may chhika\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Quriqllapi kaqlla kaqkunata kutichiy\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"\u0f50\u0f7c\u0f0b\u0f56\u0f40\u0f7c\u0f51\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f46\u0f0b\u0f62\u0f60\u0f72\u0f0b\u0f51\u0f7c\u0f53\u0f0b\u0f63\u0f74\u0f0b \u0f51\u0f56\u0fb1\u0f7a\u0f0b\u0f56\u0f0b\u0f55\u0fb1\u0f7a\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f41\u0fb1\u0f51\u0f0b\u0f46\u0f7c\u0f66\u0f0b\u0f45\u0f53\u0f0b\u0f42\u0fb1\u0f72\u0f0b\u0f46\u0f0b\u0f64\u0f66\u0f0b\u0f60\u0f51\u0f72\u0f0b\u0f66\u0fb3\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f5d\u0f0b\u0f68\u0f72\u0f53\u0f0d\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    string 'text' \u0f56\u0fb1\u0f72\u0f53\u0f0b\u0f54\u0f0b\u0f45\u0f72\u0f53\u0f0b md5 \u0f67\u0f7a\u0f64\u0f72\u0f0b \u0f60\u0f51\u0fb2\u0f0b\u0f58\u0f49\u0f58\u0f0b\u0f42\u0fb1\u0f72\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f41\u0fb2\u0f58\u0f0b\u0f66\u0fb3\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f0d \u0f42\u0f63\u0f0b\u0f66\u0fb2\u0f72\u0f51\u0f0b 'text' \u0f60\u0f51\u0f72\u0f0b \u0f66\u0f9f\u0f7c\u0f44\u0f58\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f41\u0fb2\u0f58\u0f0b\u0f68\u0f72\u0f53\u0f0b\u0f54\u0f0b\u0f45\u0f72\u0f53\u0f0b None \u0f66\u0fb3\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f0d\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    \u0f41\u0fb1\u0f7c\u0f51\u0f0b\u0f40\u0fb1\u0f72\u0f66\u0f0b\u0f5a\u0f51\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f45\u0f53\u0f0b\u0f42\u0fb1\u0f72\u0f0b\u0f61\u0f72\u0f42\u0f0b\u0f66\u0fa3\u0f7c\u0f51\u0f0b\u0f45\u0f72\u0f42\u0f0b\u0f50\u0f7c\u0f56\u0f0b\u0f66\u0f9f\u0f7a\u0f0b \u0f60\u0f51\u0f72\u0f0b\u0f61\u0f44\u0f0b matrix \u0f51\u0f44\u0f0b\u0f60\u0f51\u0fb2\u0f0b\u0f56\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f68\u0f72\u0f53\u0f0b\u0f62\u0f74\u0f44\u0f0b matrix \u0f51\u0f44\u0f0b\u0f58\u0f0b\u0f60\u0f51\u0fb2\u0f0b\u0f56\u0f62\u0f0b \u0f50\u0f72\u0f42\u0f0b\u0f41\u0fb2\u0f58\u0f0b\u0f62\u0f7a\u0f0b\u0f53\u0f44\u0f0b \u0f40\u0f7a\u0f62\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f42\u0f72\u0f0b\u0f42\u0fb1\u0f44\u0f66\u0f0b\u0f41\u0f0b\u0f58\u0f0b\u0f60\u0f51\u0fb2\u0f5d\u0f0b\u0f61\u0f7c\u0f51\u0f54\u0f0b\u0f68\u0f72\u0f53\u0f0d lst \u0f51\u0f44\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f67\u0fb2\u0f72\u0f63\u0f0b x \u0f56\u0fb1\u0f72\u0f53\u0f0b\u0f54\u0f0b\u0f45\u0f72\u0f53\u0f0b \u0f50\u0f72\u0f42\u0f0b\u0f41\u0fb2\u0f58\u0f0b\u0f53\u0f44\u0f0b\u0f63\u0f74\u0f0b \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f67\u0fb2\u0f72\u0f63\u0f0b x \u0f60\u0f5a\u0f7c\u0f63\u0f0b\u0f5e\u0f72\u0f53\u0f58\u0f0b\u0f63\u0f66\u0f0b \u0f40\u0f7a\u0f62\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f42\u0f72\u0f0b\u0f50\u0f7c\u0f0b\u0f61\u0f72\u0f42\u0f0b\u0f66\u0fb3\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f0b [(x1, y1), (x2, y2)...] \u0f60\u0f51\u0f72\u0f0b\u0f56\u0f5f\u0f74\u0f58\u0f0b\u0f66\u0fa6\u0f7a\u0f0b \u0f40\u0f7a\u0f62\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f62\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f60\u0f51\u0f72\u0f0b \u0f40\u0f7c\u0f62\u0f0b\u0f4c\u0f72\u0f0b\u0f53\u0f7a\u0f4a\u0f72\u0f0b - (\u0f42\u0fb2\u0f63\u0f0b\u0f50\u0f72\u0f42\u0f0b \u0f40\u0f7a\u0f62\u0f0b\u0f50\u0f72\u0f42\u0f0b) \u0f66\u0fa6\u0f7a\u0f0b \u0f60\u0f42\u0f7c\u0f0b\u0f56\u0f59\u0f74\u0f42\u0f66\u0f0b\u0f4f\u0f7a\u0f0b \u0f20 \u0f68\u0f72\u0f53\u0f0d \u0f40\u0f7c\u0f62\u0f0b\u0f4c\u0f72\u0f0b\u0f53\u0f7a\u0f4a\u0f72\u0f0b\u0f5a\u0f74\u0f0b\u0f62\u0f72\u0f58\u0f0b\u0f54\u0f0b\u0f61\u0f62\u0f0b\u0f66\u0f7a\u0f44\u0f0b\u0f42\u0f72\u0f0b\u0f50\u0f7c\u0f42\u0f0b\u0f63\u0f66\u0f0b \u0f60\u0f42\u0f7c\u0f0b\u0f50\u0f7c\u0f42\u0f0b\u0f63\u0f74\u0f0b\u0f51\u0f56\u0fb1\u0f7a\u0f0b\u0f5e\u0f72\u0f56\u0f0b\u0f60\u0f56\u0f51\u0f0b \u0f51\u0f7a\u0f0b\u0f63\u0f66\u0f0b \u0f40\u0f7a\u0f62\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f42\u0f72\u0f0b \u0f40\u0f7a\u0f62\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f5a\u0f74\u0f0b\u0f62\u0f72\u0f58\u0f0b\u0f54\u0f0b\u0f58\u0f62\u0f0b\u0f60\u0f56\u0f56\u0f0b\u0f42\u0f72\u0f0b\u0f50\u0f7c\u0f42\u0f0b\u0f63\u0f66\u0f0b\u0f51\u0f56\u0fb1\u0f7a\u0f0b\u0f5e\u0f72\u0f56\u0f0b\u0f60\u0f56\u0f51\u0f0b \u0f51\u0f54\u0f7a\u0f62\u0f0b\u0f53\u0f0b: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1],\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b arr \u0f60\u0f51\u0f72\u0f0b \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f67\u0fb2\u0f72\u0f63\u0f0b\u0f56\u0f74\u0f58\u0f0b\u0f51\u0f44\u0f0b \u0f53\u0f74\u0f66\u0f0b\u0f54\u0f0b\u0f45\u0f53\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b k \u0f68\u0f72\u0f53\u0f58\u0f0b\u0f66\u0fa6\u0f7a\u0f0b\u0f56\u0fb1\u0f72\u0f53\u0f0b\u0f54\u0f0b\u0f45\u0f72\u0f53\u0f0b \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f53\u0f44\u0f0b\u0f42\u0f72\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b k \u0f5a\u0f74\u0f0b\u0f51\u0f44\u0f0b\u0f42\u0f45\u0f72\u0f42\u0f0b\u0f41\u0f62\u0f0b \u0f5a\u0f7a\u0f0b\u0f62\u0f72\u0f44\u0f0b\u0f66\u0f92\u0fb2\u0f72\u0f42\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f50\u0f7c\u0f0b\u0f61\u0f72\u0f42\u0f0b\u0f45\u0f72\u0f42\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f42\u0f4f\u0f44\u0f0b\u0f0d \u0f51\u0f54\u0f7a\u0f0b\u0f42\u0f5e\u0f72\u0f0b\u0f21: \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f53\u0f44\u0f0b\u0f56\u0f59\u0f74\u0f42\u0f66\u0f0b: arr = [-3, -4, 5], k = 3 \u0f50\u0f7c\u0f53\u0f0b\u0f66\u0f90\u0fb1\u0f7a\u0f51\u0f0b: [-4, -3, 5] \u0f51\u0f54\u0f7a\u0f0b\u0f42\u0f5e\u0f72\u0f0b\u0f22: \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f53\u0f44\u0f0b\u0f56\u0f59\u0f74\u0f42\u0f66\u0f0b: arr = [4, -4, 4], k = 2 \u0f50\u0f7c\u0f53\u0f0b\u0f66\u0f90\u0fb1\u0f7a\u0f51\u0f0b: [4, 4] \u0f51\u0f54\u0f7a\u0f0b\u0f42\u0f5e\u0f72\u0f0b\u0f23: \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f53\u0f44\u0f0b\u0f56\u0f59\u0f74\u0f42\u0f66\u0f0b: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 \u0f50\u0f7c\u0f53\u0f0b\u0f66\u0f90\u0fb1\u0f7a\u0f51\u0f0b: [2] \u0f51\u0fb2\u0f53\u0f0b\u0f42\u0f66\u0f7c\u0f0d \u0f21: \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f42\u0f72\u0f0b\u0f62\u0f72\u0f44\u0f0b\u0f5a\u0f51\u0f0b\u0f51\u0f7a\u0f0b [1, 1000] \u0f42\u0f72\u0f0b\u0f56\u0f62\u0f0b\u0f53\u0f0b\u0f63\u0f74\u0f0b\u0f60\u0f7c\u0f44\u0f0b\u0f53\u0f72\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f22: \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f53\u0f44\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f46\u0f0b\u0f64\u0f66\u0f0b\u0f5a\u0f74\u0f0b [-1000, 1000] \u0f42\u0f72\u0f0b\u0f56\u0f62\u0f0b\u0f53\u0f0b\u0f63\u0f74\u0f0b\u0f60\u0f7c\u0f44\u0f0b\u0f53\u0f72\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f23: \u0f20 <= k <= len ((arr)\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"\u0f41\u0fb1\u0f7c\u0f51\u0f0b\u0f40\u0fb1\u0f72\u0f66\u0f0b\u0f5a\u0f72\u0f42\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f50\u0f7c\u0f56\u0f0b\u0f61\u0f7c\u0f51\u0f54\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f41\u0fb1\u0f7c\u0f51\u0f0b\u0f40\u0fb1\u0f72\u0f66\u0f0b\u0f5a\u0f72\u0f42\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f54\u0f0b\u0f61\u0f44\u0f0b\u0f53\u0f0b \u0f60\u0f51\u0f72\u0f0b\u0f42\u0f72\u0f0b\u0f60\u0f41\u0f7c\u0f62\u0f0b\u0f63\u0f7c\u0f60\u0f72\u0f0b\u0f42\u0fb2\u0f63\u0f0b\u0f62\u0f72\u0f58\u0f0b\u0f5a\u0f74\u0f0b \u0f5a\u0f72\u0f42\u0f0b\u0f51\u0f44\u0f0b\u0f54\u0f0b\u0f53\u0f44\u0f0b\u0f63\u0f74\u0f0b \u0f53\u0f44\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f66\u0fa6\u0f7a\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f0b\u0f45\u0f72\u0f53\u0f0b \u0f41\u0fb1\u0f7c\u0f51\u0f0b\u0f40\u0fb1\u0f72\u0f66\u0f0b\u0f56\u0f51\u0f7a\u0f53\u0f0b\u0f54\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f42\u0f4f\u0f44\u0f0b\u0f51\u0f42\u0f7c\u0f54\u0f0b\u0f68\u0f72\u0f53\u0f0d cycpattern_check(\"abcd\",\"abd\") => false cycpattern_check(\"hello\",\"ell\") => true cycpattern_check (((\"whassup\",\"psus\") => false cycpattern_check\"abab\",\"baa\") => true cycpattern_check (((\"efef\",\"eeff\") => false cycpattern_check\" ((hims\",\"simen\") => true\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f60\u0f51\u0f72\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f44\u0f7c\u0f0b\u0f58\u0f0b\u0f68\u0f72\u0f53\u0f0b\u0f54\u0f0b\u0f45\u0f72\u0f53\u0f0b true \u0f66\u0fb3\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f5d\u0f0b\u0f68\u0f72\u0f53\u0f0d\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"\u0f44\u0f0b\u0f56\u0f45\u0f66\u0f0b\u0f53\u0f44\u0f0b\u0f63\u0f74\u0f0b \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b 'arr' \u0f60\u0f51\u0f72\u0f0b \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b N \u0f61\u0f7c\u0f44\u0f66\u0f0b\u0f56\u0f66\u0fa1\u0f7c\u0f58\u0f66\u0f0b arr[1], arr[2],..., arr[N] \u0f5a\u0f74\u0f0b\u0f61\u0f7c\u0f51\u0f0b \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f53\u0f44\u0f0b\u0f42\u0f72\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f5a\u0f74\u0f0b \u0f66\u0f9f\u0f56\u0f66\u0f0b\u0f56\u0f51\u0f7a\u0f0b\u0f4f\u0f7c\u0f42\u0f0b\u0f4f\u0f7c\u0f0b\u0f66\u0fa6\u0f7a\u0f0b\u0f62\u0f72\u0f58\u0f0b\u0f66\u0f92\u0fb2\u0f72\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f60\u0f7c\u0f44\u0f0b\u0f0d \u0f41\u0fb1\u0f7c\u0f51\u0f0b\u0f40\u0fb1\u0f72\u0f0b\u0f63\u0f71\u0f0b\u0f60\u0f51\u0f72\u0f0b \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f60\u0f51\u0f72\u0f0b \u0f58\u0f62\u0f0b\u0f60\u0f56\u0f56\u0f0b\u0f60\u0f42\u0fb1\u0f7c\u0f0b\u0f53\u0f72\u0f0b\u0f58\u0f7a\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f62\u0f72\u0f58\u0f0b\u0f66\u0f92\u0fb2\u0f72\u0f42\u0f0b\u0f53\u0f44\u0f0b \u0f50\u0f7c\u0f56\u0f0b\u0f5a\u0f74\u0f42\u0f66\u0f0b\u0f42\u0f0b\u0f60\u0f51\u0f72\u0f0b\u0f44\u0f7a\u0f66\u0f0b\u0f60\u0f5b\u0f72\u0f53\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f51\u0f42\u0f7c \u0f60\u0f51\u0f72\u0f0b\u0f42\u0f72\u0f0b\u0f51\u0f7c\u0f53\u0f0b\u0f63\u0f74\u0f0b \u0f41\u0fb1\u0f7c\u0f51\u0f0b\u0f40\u0fb1\u0f72\u0f66\u0f0b \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f60\u0f51\u0f72\u0f0b\u0f53\u0f44\u0f0b\u0f63\u0f74\u0f0b \u0f5a\u0f62\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f5a\u0f74\u0f0b \u0f55\u0fb2\u0f44\u0f0b\u0f66\u0f92\u0fb2\u0f72\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f56\u0f4f\u0f74\u0f56\u0f0d \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f42\u0f72\u0f0b\u0f46\u0f0b\u0f64\u0f66\u0f0b\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b \u0f55\u0fb2\u0f44\u0f0b\u0f66\u0f92\u0fb2\u0f72\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f56\u0f4f\u0f44\u0f58\u0f0b\u0f51\u0f0b \u0f55\u0fb2\u0f44\u0f0b\u0f66\u0f92\u0fb2\u0f72\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f56\u0f4f\u0f44\u0f58\u0f0b\u0f51\u0f0b \u0f55\u0fb2\u0f44\u0f0b\u0f66\u0f92\u0fb2\u0f72\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f56\u0f4f\u0f44\u0f58\u0f0b\u0f51\u0f0b \u0f55\u0fb2\u0f44\u0f0b\u0f66\u0f92\u0fb2\u0f72\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f56\u0f4f\u0f44\u0f58\u0f0b\u0f51\u0f0b \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f42\u0f72\u0f0b\u0f46\u0f0b\u0f64\u0f66\u0f0b\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b \u0f55\u0fb2\u0f44\u0f0b\u0f66\u0f92\u0fb2\u0f72\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f56\u0f4f\u0f44\u0f58\u0f0b\u0f51\u0f0b \u0f55\u0fb2\u0f44\u0f0b\u0f66\u0f92\u0fb2\u0f72\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f56\u0f4f\u0f44\u0f58\u0f0b\u0f51\u0f0b \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f42\u0f72\u0f0b\u0f46\u0f0b\u0f64\u0f66\u0f0b\u0f58\u0f47\u0f74\u0f42\u0f0b\u0f51\u0f7a\u0f0b \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f53\u0f44\u0f0b \u0f60\u0f42\u0f7c\u0f0b\u0f56\u0f59\u0f74\u0f42\u0f66\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f66\u0f0b\u0f66\u0f92\u0f7c\u0f0b\u0f63\u0f74\u0f0b \u0f66\u0fa4\u0f7c\u0f0b\u0f56\u0f64\u0f74\u0f51\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f56\u0f4f\u0f44\u0f58\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f51\u0f7a\u0f0b\u0f42\u0f72\u0f0b\u0f46\u0f0b\u0f64\u0f66\u0f0b\u0f58\u0f47\u0f74\u0f42\u0f0b\u0f60\u0f51\u0f72\u0f0b \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f42\u0f72\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b \u0f20 \u0f54\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f42\u0f0b\u0f51\u0f7a\u0f58\u0f0b\u0f45\u0f72\u0f42\u0f0b\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" \u0f53\u0f44\u0f0b\u0f56\u0f66\u0f90\u0fb1\u0f7c\u0f51\u0f0b\u0f50\u0f7c\u0f0b\u0f61\u0f72\u0f42\u0f0b\u0f53\u0f44\u0f0b\u0f63\u0f74\u0f0b string \u0f60\u0f51\u0f72\u0f0b\u0f5a\u0f74\u0f0b prefix \u0f45\u0f72\u0f42\u0f0b\u0f63\u0f66\u0f0b\u0f60\u0f42\u0f7c\u0f0b\u0f56\u0f59\u0f74\u0f42\u0f66\u0f0b\u0f4f\u0f7a\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f58\u0f72\u0f0b\u0f5a\u0f74\u0f0b\u0f62\u0f90\u0fb1\u0f44\u0f58\u0f0b\u0f45\u0f72\u0f42\u0f0b \u0f4c\u0f60\u0f72\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f5d\u0f0b\u0f68\u0f72\u0f53\u0f0d\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f60\u0f51\u0f72\u0f0b \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f44\u0f7c\u0f0b\u0f58\u0f0b\u0f23 \u0f42\u0fb1\u0f72\u0f0b\u0f42\u0fb1\u0f44\u0f66\u0f0b\u0f41\u0f0b\u0f51\u0f44\u0f0b \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f42\u0f5e\u0f53\u0f0b\u0f5a\u0f74\u0f0b\u0f64\u0f7c\u0f58\u0f0b\u0f54\u0f0b\u0f45\u0f72\u0f53\u0f0b \u0f68\u0f72\u0f53\u0f0b\u0f5f\u0f7a\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f42\u0f4f\u0f44\u0f0b\u0f58\u0f72\u0f0b\u0f63\u0f66\u0f0b\u0f60\u0f42\u0f53\u0f0b\u0f45\u0f72\u0f42\u0f0b\u0f60\u0f56\u0fb2\u0f72\u0f0b\u0f51\u0f42\u0f7c\u0f0d \u0f51\u0f54\u0f7a\u0f62\u0f0b\u0f53\u0f0b: is_multiply_prime (\u0f23\u0f20) == \u0f68\u0f72\u0f53\u0f0b\u0f54\u0f74\u0f4a\u0f72\u0f0b \u0f23\u0f20 = \u0f22*\u0f23*\u0f25\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"string \u0f42\u0f72\u0f0b\u0f50\u0f7c\u0f0b\u0f61\u0f72\u0f42\u0f0b\u0f45\u0f72\u0f42\u0f0b\u0f56\u0fb1\u0f72\u0f53\u0f58\u0f0b\u0f51\u0f0b string \u0f62\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f53\u0f44\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f62\u0f90\u0fb1\u0f44\u0f58\u0f0b\u0f45\u0f72\u0f42\u0f0b\u0f61\u0f7c\u0f51\u0f54\u0f0b\u0f63\u0f66\u0f0b \u0f5a\u0f72\u0f42\u0f0b\u0f61\u0f72\u0f42\u0f0b\u0f45\u0f72\u0f42\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f42\u0f4f\u0f44\u0f0b\u0f0d \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f50\u0f7c\u0f53\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f46\u0f0b\u0f64\u0f66\u0f0b\u0f62\u0f7a\u0f0b\u0f62\u0f7a\u0f0b i \u0f60\u0f51\u0f72\u0f0b \"input \u0f42\u0f72\u0f0b string i \u0f53\u0f44\u0f0b\u0f42\u0f72\u0f0b\u0f62\u0fa3\u0f58\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f58\u0f7a\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f46\u0f0b\u0f64\u0f66\u0f0b\u0f5a\u0f74\u0f0b\u0f42\u0f72\u0f0b\u0f42\u0fb1\u0f44\u0f66\u0f0b\u0f41\u0f0b\" \u0f68\u0f72\u0f53\u0f58\u0f0b\u0f51\u0f0b i \u0f5a\u0f74\u0f0b\u0f46\u0f0b\u0f64\u0f66\u0f0b i \u0f54\u0f60\u0f72\u0f0b\u0f53\u0f44\u0f0b\u0f62\u0fa3\u0f58\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f58\u0f7a\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f5a\u0f74\u0f0b\u0f51\u0f44\u0f0b\u0f5a\u0f56\u0f0b\u0f62\u0f90\u0fb1\u0f56\u0f0b\u0f51\u0f42\u0f7c\u0f0d\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"FibFib \u0f68\u0f44\u0f0b\u0f62\u0f72\u0f58\u0f0b\u0f60\u0f51\u0f72\u0f0b Fibbonacci \u0f68\u0f44\u0f0b\u0f62\u0f72\u0f58\u0f0b\u0f51\u0f44\u0f0b\u0f60\u0f51\u0fb2\u0f5d\u0f0b\u0f66\u0fa6\u0f7a\u0f0b\u0f62\u0f0b\u0f68\u0f72\u0f53\u0f58\u0f0b\u0f51\u0f0b \u0f60\u0f51\u0f72\u0f0b\u0f5a\u0f74\u0f0b\u0f53\u0f44\u0f0b\u0f51\u0f7c\u0f53\u0f0b\u0f60\u0f51\u0f72\u0f0b\u0f56\u0f40\u0f7c\u0f51\u0f0b\u0f51\u0f7a\u0f0b\u0f60\u0f51\u0f74\u0f42: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) \u0f68\u0f72\u0f53\u0f0b\u0f54\u0f0b\u0f45\u0f72\u0f53\u0f0b \u0f68\u0f44\u0f0b\u0f62\u0f72\u0f58\u0f0b\u0f42\u0fb1\u0f72\u0f0b\u0f46\u0f0b\u0f64\u0f66\u0f0b\u0f68\u0f44\u0f0b n \u0f54\u0f0b\u0f60\u0f51\u0f72\u0f0b \u0f55\u0fb2\u0f0b\u0f62\u0f72\u0f44\u0f0b\u0f66\u0fa6\u0f7a\u0f0b\u0f62\u0fa9\u0f72\u0f66\u0f0b\u0f66\u0f9f\u0f7c\u0f53\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f53\u0f72\u0f60\u0f72\u0f0b\u0f51\u0f7c\u0f53\u0f0b\u0f63\u0f74\u0f0b \u0f63\u0f66\u0f0b\u0f60\u0f42\u0f53\u0f0b\u0f45\u0f72\u0f42\u0f0b\u0f60\u0f56\u0fb2\u0f72\u0f0b\u0f42\u0f53\u0f44\u0f0b\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" \u0f53\u0f44\u0f0b\u0f56\u0f66\u0f90\u0fb1\u0f7c\u0f51\u0f0b\u0f60\u0f51\u0f72\u0f0b \u0f66\u0f0b\u0f66\u0f92\u0f7c\u0f0b\u0f53\u0f44\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f61\u0f72\u0f42\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b string \u0f60\u0f51\u0f72\u0f0b'\u0f20' \u0f63\u0f66\u0f0b'\u0f29' \u0f5a\u0f74\u0f53\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f42\u0f51\u0f58\u0f0b\u0f41\u0f0b\u0f5a\u0f74\u0f0b'\u0f20'\u0f21'\u0f22'\u0f23'\u0f24'\u0f25'\u0f26'\u0f27'\u0f28'\u0f29'\u0f5a\u0f74\u0f0b\u0f68\u0f72\u0f53\u0f0d string \u0f60\u0f51\u0f72\u0f0b\u0f46\u0f74\u0f44\u0f0b\u0f64\u0f7c\u0f66\u0f0b\u0f63\u0f66\u0f0b\u0f66\u0fa6\u0f7c\u0f58\u0f0b\u0f64\u0f7c\u0f66\u0f0b\u0f5a\u0f74\u0f53\u0f0b\u0f62\u0f72\u0f58\u0f0b\u0f66\u0f92\u0fb2\u0f72\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f5a\u0f74\u0f0b\u0f66\u0fb3\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f5d\u0f0b\u0f68\u0f72\u0f53\u0f0d\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero \u0f42\u0f72\u0f66\u0f0b \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f67\u0fb2\u0f72\u0f63\u0f0b\u0f56\u0f74\u0f58\u0f0b\u0f42\u0fb1\u0f72\u0f0b\u0f50\u0f7c\u0f0b\u0f61\u0f72\u0f42\u0f0b\u0f45\u0f72\u0f42\u0f0b\u0f68\u0f7a\u0f56\u0f0b\u0f42\u0f4f\u0f44\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f66\u0fa6\u0f7a\u0f0b\u0f63\u0f7a\u0f53\u0f0b\u0f61\u0f7c\u0f51\u0f54\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f42\u0f63\u0f0b\u0f66\u0fb2\u0f72\u0f51\u0f0b\u0f50\u0f7c\u0f0b\u0f61\u0f72\u0f42\u0f0b\u0f53\u0f44\u0f0b\u0f63\u0f74\u0f0b \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f67\u0fb2\u0f72\u0f63\u0f0b\u0f56\u0f74\u0f58\u0f0b\u0f63\u0f74\u0f0b \u0f20\u0f0b\u0f51\u0f44\u0f0b\u0f42\u0f5e\u0f53\u0f0b\u0f58\u0f72\u0f0b\u0f45\u0f72\u0f42\u0f0b\u0f63\u0f74\u0f0b\u0f62\u0fab\u0f74\u0f66\u0f0b\u0f58\u0f0b\u0f66\u0fa6\u0f7a\u0f0b\u0f56\u0f66\u0fa1\u0f7c\u0f58\u0f66\u0f0b\u0f58\u0f72\u0f0b\u0f41\u0fb1\u0f51\u0f0b\u0f54\u0f62\u0f0b\u0f45\u0f53\u0f0b\u0f42\u0f66\u0f74\u0f58\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f0b\u0f45\u0f72\u0f53\u0f0b True \u0f66\u0fb3\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f5d\u0f0b\u0f68\u0f72\u0f53\u0f0d\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"\u0f51\u0f54\u0f7a\u0f0b\u0f42\u0f5e\u0f72\u0f0b\u0f60\u0f51\u0f72\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\u0f46\u0f0b\u0f58\u0f49\u0f58\u0f0b_\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    \u0f63\u0f66\u0f0b\u0f60\u0f42\u0f53\u0f0b\u0f45\u0f72\u0f42\u0f0b\u0f56\u0f5f\u0f7c\u0f0b\u0f5e\u0f72\u0f53\u0f58\u0f0b\u0f63\u0f66\u0f0b \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f67\u0fb2\u0f72\u0f63\u0f0b\u0f56\u0f74\u0f58\u0f0b\u0f51\u0f44\u0f0b floats \u0f61\u0f44\u0f0b\u0f53\u0f0b string \u0f42\u0f72\u0f66\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f44\u0f7c\u0f0b\u0f58\u0f0b\u0f60\u0f51\u0f72\u0f0b\u0f44\u0f7c\u0f0b\u0f5a\u0f56\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f5e\u0f72\u0f53\u0f58\u0f0b\u0f63\u0f66\u0f0b \u0f66\u0fa6\u0f7c\u0f58\u0f0b\u0f64\u0f7c\u0f66\u0f0b\u0f51\u0f7a\u0f0b\u0f66\u0fb3\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f5d\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f42\u0f53\u0f66\u0f0b\u0f42\u0f7c\u0f44\u0f0b\u0f5a\u0f74\u0f0b\u0f60\u0f51\u0fb2\u0f53\u0f0b\u0f60\u0f51\u0fb2\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f0b\u0f45\u0f72\u0f53\u0f0b None \u0f66\u0fb3\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f5d\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f51\u0fb2\u0f53\u0f0b\u0f54\u0f0b\u0f56\u0f5f\u0f7c\u0f0b\u0f53\u0f72\u0f0d \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f44\u0f7c\u0f0b\u0f58\u0f0b\u0f45\u0f72\u0f42\u0f0b string \u0f66\u0fa6\u0f7a\u0f0b\u0f44\u0f7c\u0f0b\u0f5a\u0f56\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f56\u0f0b\u0f45\u0f72\u0f53\u0f0b \u0f60\u0f41\u0fb1\u0f72\u0f63\u0f0b\u0f60\u0f42\u0fb1\u0f7c\u0f0b\u0f56\u0f60\u0f72\u0f0b\u0f42\u0f53\u0f66\u0f0b\u0f42\u0f7c\u0f44\u0f0b\u0f60\u0f51\u0f72\u0f0b. \u0f61\u0f44\u0f0b\u0f53\u0f0b, compare_one (\u0f21,\u0f22.\u0f25) \u00e2 -> \u0f22.\u0f25 compare_one (\u0f21,\u0f22.\u0f23) \u00e2 -> \"\u0f22,\u0f23 compare_one (\u0f21,\u0f25,\u0f21\", \"\u0f26\") \u00e2 -> \"\u0f26\" compare_one (\u0f21,\u0f21) \u00e2 -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" \u0f60\u0f0b\u0f53\u0f72\u0f0b\u0f63\u0f66\u0f0b\u0f60\u0f42\u0f53\u0f0b\u0f53\u0f44\u0f0b\u0f68\u0f7a\u0f56\u0f0b\u0f42\u0f4f\u0f44\u0f0b\u0f60\u0f56\u0f51\u0f0b\u0f58\u0f72\u0f0b\u0f60\u0f51\u0f72\u0f0b \u0f53\u0f44\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f53\u0f44\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b \u0f40\u0f7a\u0f62\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f66\u0fa1\u0f7a\u0f0b\u0f5a\u0f53\u0f0b\u0f63\u0f7a\u0f0b\u0f64\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b \u0f40\u0f7a\u0f62\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f41\u0fb1\u0f7c\u0f51\u0f0b\u0f40\u0fb1\u0f72\u0f0b\u0f51\u0f58\u0f72\u0f42\u0f66\u0f0b\u0f61\u0f74\u0f63\u0f0b\u0f60\u0f51\u0f72\u0f0b \u0f66\u0fa1\u0f7a\u0f0b\u0f5a\u0f53\u0f0b\u0f51\u0f7a\u0f0b\u0f66\u0f7c\u0f0b\u0f66\u0f7c\u0f62\u0f0b\u0f66\u0fa6\u0f7a\u0f0b \u0f55\u0fb2\u0f0b\u0f62\u0f72\u0f44\u0f0b\u0f53\u0f44\u0f0b\u0f51\u0f56\u0fb1\u0f7a\u0f0b\u0f56\u0f0b\u0f55\u0fb1\u0f7a\u0f0b\u0f53\u0f72\u0f0b\u0f51\u0f44\u0f0b \u0f60\u0f51\u0f72\u0f0b\u0f5a\u0f74\u0f0b\u0f42\u0f72\u0f0b\u0f50\u0f7c\u0f0b\u0f51\u0f7a\u0f0b\u0f66\u0fb3\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f5d\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f66\u0fa1\u0f7a\u0f0b\u0f5a\u0f53\u0f0b\u0f66\u0f7c\u0f0b\u0f66\u0f7c\u0f62\u0f0b\u0f5a\u0f74\u0f0b \u0f5a\u0f51\u0f0b\u0f63\u0fa1\u0f53\u0f0b\u0f56\u0f5f\u0f7c\u0f0b\u0f66\u0f9f\u0f7a\u0f0b (\u0f66\u0f92\u0f7c\u0f0b\u0f66\u0f92\u0fb2\u0f72\u0f42\u0f0b\u0f62\u0f7a\u0f0b\u0f62\u0f7a\u0f60\u0f72\u0f0b \u0f40\u0f7a\u0f62\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f60\u0f51\u0f72\u0f0b \u0f63\u0f7a\u0f42\u0f66\u0f0b\u0f64\u0f7c\u0f58\u0f0b\u0f66\u0fa6\u0f7a\u0f0b\u0f56\u0f66\u0fa1\u0f58\u0f0b\u0f61\u0f7c\u0f51\u0f54\u0f0b) \u0f51\u0f44\u0f0b \u0f42\u0f45\u0f72\u0f42\u0f0b\u0f42\u0f72\u0f66\u0f0b\u0f42\u0f45\u0f72\u0f42\u0f0b\u0f63\u0f74\u0f0b \u0f53\u0f44\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f53\u0f44\u0f0b\u0f58\u0f0b\u0f5a\u0f74\u0f51\u0f0b\u0f51\u0f7a\u0f0b\u0f61\u0f7c\u0f51\u0f0d \u0f68\u0f7a\u0f56\u0f0b\u0f42\u0f4f\u0f44\u0f0b\u0f50\u0f72\u0f42\u0f0b\u0f53\u0f44\u0f0b \u0f56\u0f62\u0f0b\u0f66\u0f9f\u0f7c\u0f44\u0f0b\u0f5a\u0f74\u0f0b\u0f66\u0fa3\u0f44\u0f0b\u0f58\u0f7a\u0f51\u0f0b\u0f56\u0f5f\u0f7c\u0f0b\u0f51\u0f42\u0f7c\u0f0d \u0f51\u0f54\u0f7a\u0f0b:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f40\u0fb1\u0f72\u0f0b\u0f50\u0f7c\u0f0b\u0f61\u0f72\u0f42\u0f0b\u0f45\u0f72\u0f42\u0f0b\u0f63\u0f66\u0f0b (\u0f49\u0f74\u0f44\u0f0b\u0f64\u0f7c\u0f66\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b) \u0f42\u0f45\u0f72\u0f42\u0f0b\u0f51\u0f44\u0f0b\u0f42\u0f45\u0f72\u0f42\u0f0b\u0f51\u0f44\u0f0b\u0f49\u0f7a\u0f0b\u0f56\u0f60\u0f72\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f42\u0f51\u0f58\u0f0b\u0f41\u0f0b\u0f62\u0f90\u0fb1\u0f56\u0f0b\u0f66\u0f9f\u0f7a\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f42\u0f4f\u0f44\u0f0b\u0f53\u0f72\u0f0b\u0f51\u0f44\u0f0b \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f5a\u0f74\u0f0b\u0f62\u0f72\u0f58\u0f0b\u0f54\u0f0b\u0f56\u0f5e\u0f72\u0f53\u0f0b\u0f51\u0f74\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f42\u0f4f\u0f44\u0f0b (\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f46\u0f74\u0f44\u0f0b\u0f64\u0f7c\u0f66\u0f0b\u0f51\u0f44\u0f0b \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f66\u0fa6\u0f7c\u0f58\u0f0b\u0f64\u0f7c\u0f66\u0f0b) \u0f0d\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f67\u0fb2\u0f72\u0f63\u0f0b\u0f56\u0f74\u0f58\u0f0b\u0f42\u0fb1\u0f72\u0f0b\u0f50\u0f7c\u0f0b\u0f61\u0f72\u0f42\u0f0b\u0f53\u0f44\u0f0b\u0f63\u0f66\u0f0b \u0f5a\u0f62\u0f0b\u0f42\u0f45\u0f72\u0f42\u0f0b\u0f63\u0f66\u0f0b\u0f63\u0fb7\u0f42\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f53\u0f44\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f46\u0f0b\u0f64\u0f66\u0f0b\u0f5a\u0f74\u0f0b\u0f56\u0f4f\u0f7c\u0f53\u0f0b\u0f42\u0f4f\u0f44\u0f0b\u0f0d \u0f53\u0f44\u0f0b\u0f56\u0f66\u0f90\u0fb1\u0f7c\u0f51\u0f0b\u0f53\u0f44\u0f0b\u0f56\u0f5f\u0f74\u0f58\u0f0b\u0f66\u0fa6\u0f7a\u0f0b\u0f46\u0f0b\u0f64\u0f66\u0f0b\u0f5a\u0f74\u0f0b\u0f62\u0f72\u0f58\u0f0b\u0f54\u0f0b\u0f42\u0f45\u0f72\u0f42\u0f0b\u0f66\u0fa6\u0f7a\u0f0b\u0f56\u0f5e\u0f42\u0f0b\u0f51\u0f42\u0f7c\u0f0d\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    \u0f5a\u0f51\u0f0b\u0f63\u0fa1\u0f53\u0f0b xs \u0f5a\u0f74\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f66\u0f92\u0f7c\u0f0b\u0f60\u0f51\u0f72\u0f0b xs \u0f63\u0f74\u0f0b\u0f62\u0fa9\u0f72\u0f66\u0f0b\u0f66\u0f9f\u0f7c\u0f53\u0f58\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f66\u0fb3\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f58\u0f50\u0f60\u0f0b\u0f51\u0f42\u0f0b arr \u0f51\u0f44\u0f0b \u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f58\u0f50\u0f60\u0f0b\u0f51\u0f42\u0f0b k \u0f5a\u0f74\u0f0b\u0f61\u0f7c\u0f51\u0f0b\u0f54\u0f60\u0f72\u0f0b \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f58\u0f7a\u0f51\u0f0b\u0f45\u0f72\u0f42\u0f0b\u0f56\u0fb1\u0f72\u0f53\u0f0b\u0f54\u0f0b\u0f45\u0f72\u0f53\u0f0b \u0f68\u0f7a\u0f0b\u0f62\u0f7a\u0f0b\u0f42\u0f72\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f58\u0f50\u0f60\u0f0b\u0f51\u0f42\u0f0b k \u0f42\u0f72\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f63\u0f66\u0f0b\u0f68\u0f44\u0f0b\u0f42\u0fb2\u0f44\u0f66\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f63\u0f66\u0f0b\u0f63\u0fb7\u0f42\u0f0b\u0f66\u0f9f\u0f7a\u0f0b\u0f58\u0f7a\u0f51\u0f0b\u0f58\u0f72\u0f0b\u0f5a\u0f74\u0f0b\u0f66\u0fb3\u0f62\u0f0b\u0f63\u0f7c\u0f42\u0f0b\u0f60\u0f56\u0f51\u0f5d\u0f0b\u0f68\u0f72\u0f53\u0f0d \u0f51\u0f54\u0f7a\u0f0b\u0f42\u0f5e\u0f72\u0f0b: \u0f68\u0f7a\u0f53\u0f0b\u0f54\u0f74\u0f4a\u0f72\u0f0b: arr = [111,21,3,4000,5,6,7,8,9], k = 4 \u0f68\u0f7a\u0f53\u0f0b\u0f54\u0f74\u0f4a\u0f72\u0f0b: 24 # sum of 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Miverena amin'ny isa tsara ao amin'ny lisitra ihany.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Halavany miverina amin'ny tady nomena\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Mivezivezy manodidina ny tarehimarika amin'ny integer x, mivezivezy miankavanana ny tarehimarika ary avereno ny valiny ho toy ny tadiny. Raha miova > isa ny tarehimarika, avereno ny tarehimarika mivadika.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Ny fidirana dia singa iray voafetra amin'ny habaka misy isa manomboka amin'ny 'zero' ka hatramin'ny'sivy'. Safidy mety dia 'zero', 'iray', 'roa', 'telo', 'efatra', 'dimy', 'enina', 'fito', 'valo' ary'sivy'. Avereno ny tady misy isa voalahatra avy amin'ny kely indrindra ka hatramin'ny lehibe indrindra\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Raha nomena isa isa mihetsiketsika tsara, dia azo zaraina ho ampahany iray manontolo (isa lehibe indrindra kely kokoa noho ny isa nomena) sy ny decimals (ny ampahany sisa tavela dia kely kokoa noho ny 1).\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Raha nomena isa iray n, dia tsy maintsy manao antontam-bato misy vato n ianao. Ny ambaratonga voalohany dia misy vato n. Ny isan'ny vato ao amin'ny ambaratonga manaraka dia: - ny isa hafahafa manaraka raha n dia hafahafa. - ny isa manaraka raha n dia mitovy. Avereno ny isan'ny vato isaky ny ambaratonga ao anaty lisitra, izay maneho ny isan'ny vato ao amin'ny ambaratonga (i + 1) ny singa ao amin'ny index i.\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"Ohatra: boribory_avg ((1, 5) => \"0b11\" boribory_avg ((7, 5) => -1 boribory_avg ((10, 20) => \"0b11\" boribory_avg ((20, 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Avereno ny mpanisa voalohany lehibe indrindra amin'ny n. Mihevitra n > 1 ary tsy prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Ohatra: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 1, 4], 0 (1, 4), 0 (2, 5), 0 (2), get_(1), 1) [_] == [[laharana 1, 2, 3, 2]], == 2]], [_]] == laharan 1, 2, 3, 2, 3]] == laharan 1, 2, 3 == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == ==\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Ohatra 1: Fidirana: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Famoahana: 62: Fidirana: [[0,0,1,1], [0,0,0,0], [1,1,1,1]] bucket_capacity: 2 Famoahana: 53: [[:0,0,0], [0,0,0]] bucket_capacity: 5 Famoahana: 5 * 0 * 0 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 11 * 11 * 11 * 11 * 11 * 12 * 12 * 13 * 13 * 14 * 15 * 15 * 15 * 15 * 15\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Ampiharo ny fiasa f izay mandray ny n ho toy ny masontsivana, ary mamerina lisitra iray amin'ny habeny n, toy ny hoe ny sandan'ny singa ao amin'ny index i dia ny factorial an'ny i raha toa ka i dia mitovy na ny totalin'ny isa avy amin'ny 1 ka hatramin'ny i raha tsy izany. i manomboka amin'ny 1. ny factorial an'ny i dia ny fampitomboana ny isa avy amin'ny 1 ka hatramin'ny i (1 * 2 *... * i). Ohatra: f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Raha misy ny 'text' dia avereno ny md5 hash equivalent string. Raha 'text' dia tsy misy string dia avereno ny None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Ho an'ny lisitra iray nomena ny integers, miverina ny tuple ahitana ny sombiny sy ny vokatra ny integers rehetra ao amin'ny lisitra. foana dia tokony ho mitovy amin'ny 0 sy ny vokatra foana dia tokony ho mitovy amin'ny 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Ohatra: words_string (tantara) => \"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"] words_string (tantara) => \"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs dia maneho ny coefficients amin'ny polyn\u00f4me. xs[0] + xs[1] * x + xs[2] * x^2 +.... Avereno amin'ny endriny mitovy ny derivate amin'ity polyn\u00f4me ity.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nAmpio tranga fanandramana bebe kokoa.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Miverina marina raha toa ka mitombo na mihena tsy miova ny singa ao anaty lisitra.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Raha nomena lisitry ny isa (amin'ny singa roa farafahakeliny), ampiharo ny fanovana tsipika amin'io lisitra io, ka ny isa kely indrindra dia ho lasa 0 ary ny lehibe indrindra dia ho lasa 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets dia andian-dahatsoratra misy \"<\" sy \">\". miverina ho marina raha toa ka misy bracket fanokafana mifanandrify amin'ny bracket famaranana.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"Ny olana dia very ny kaody nampiasainy tamin'ny fanasokajiana. Nomeny anao ny lisitry ny salan'isan'ny mpianatra sasany ary tsy maintsy manoratra fiasa izay afaka mamoaka ny lisitry ny mari-pahaizana amin'ny al\u00e0lan'ny tabilao manaraka ianao: GPA  GPA  Lasibatra taratasy 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation ([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Miverena lisitry ny laharam-pahamehana amin'ny laharam-pahamehana amin'ny laharam-pahamehana amin'ny laharam-pahamehana. Ny isa tsirairay dia tokony ho voatanisa amin'ny isa mitovy amin'ny isan'ny fotoana miseho amin'ny factorization. Ny isa fidirana dia tokony hitovy amin'ny vokatra rehetra\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    Raha misy laharana iray maneho sampana iray amin'ny hazo izay manana node integer tsy ratsy ny asanao dia ny manaisotra ny iray amin'ireo node ary mamerina azy. Ny node noforonina dia tokony ho ny node miaraka amin'ny sanda kely indrindra. Raha misy node maromaro miaraka amin'ny sanda kely indrindra dia mamerina ny node izay manana index kely indrindra. Ny node noforonina dia tokony haverina ao anaty lisitra, [small_value, ny index-ny ], Raha tsy misy sanda na ny array nomena dia foana, miverina []. Ohatra 1: Input: [4,2,3] Output: [2, 1] Fanazavana: 2 no manana sanda kely indrindra, ary 2 no manana index kely indrindra. Ohatra 2: Input: [1,2,3] Output: [2, 1] Fanazavana: 2 no manana sanda kely indrindra, ary 2 no manana index kely indrindra. Ohatra 3: Input: []\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets string of \"(\" and \")\". return True eger her bracket vekirina heye a bracket girtina hevbe\u015f.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Guherandina base hejmar\u00ee ya hejmara input x ji bo base. n\u00fbnertiya string vegerandin pi\u015ft\u00ee veguhastina. hejmar\u00ean base k\u00eamtir ji 10 in.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Ji bo lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] encam div\u00ea 10 ji bo lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] encam div\u00ea 25 ji bo lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] encam div\u00ea 13 ji bo lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] encam div\u00ea 11 ji bo lst = [0,81,12,3,21,1] encam div\u00ea 3 ji bo lst = [0,1,8,1,2,1,7] encam div\u00ea 7 ji bo lst = [0,8,1,2,7] encam div\u00ea 10 ji bo lst = [0,1,1,2,2,2,2,1] encam div\u00ea 10 ji bo\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Fonksiyona f ku n wek parameter digire, p\u00eak b\u00eene \u00fb l\u00eesteya mezinb\u00fbna n vedigere, wek\u00ee ku nirxa h\u00eamana li endeks\u00ea i faktoriy\u00ea i ye eger i j\u00ee an j\u00ee jimara hejmar\u00ean ji 1 heta i be. i ji 1. factoriy\u00ea i ji 1 heta i (1 * 2 *... * i) pirkirine. M\u00eenak: f ((5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs koef\u00eesan\u00ean polinom\u00ea n\u00ee\u015fan dide. xs[0] + xs[1] * x + xs[2] * x^2 +.... Derivata v\u00ea polinom\u00ea di heman form\u00ea de veger\u00eene.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Ji bo hejmarek poz\u00eet\u00eef n, hilber\u00ea h\u00eajmara h\u00eajmaran veger\u00eene. 0 veger\u00eene eger hem\u00fb h\u00eajmaran j\u00ee hevbe\u015f bin. M\u00eenak: h\u00eajmaran ((1) == 1 h\u00eajmaran ((4) == 0 h\u00eajmaran ((235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Fonksiyonek biniv\u00eese ku stringek\u00ea digire \u00fb rast vedigere eger dir\u00eajahiya string hejmarek sereke be an j\u00ee derew be.\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Di v\u00ea Kata de, div\u00ea h\u00fbn r\u00eaza hejmar\u00ean ne-negat\u00eef li gor hejmara yek\u00ean di n\u00fbnertiya wan a biner\u00ee de bi r\u00eaza bilindb\u00fbn\u00ea r\u00eaz bikin. Ji bo hejmara wekhev ya yekan, r\u00eaz\u00ea li gor\u00ee nirxa dehan\u00een. Div\u00ea wiha were p\u00eakan\u00een:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    H\u00fbn l\u00eesteya hejmar\u00ean tam t\u00ea day\u00een. Fonksiyonek next_smallest biniv\u00eese ku h\u00eamana duyem\u00een a l\u00eestey\u00ea vedigere. Eger h\u00eamanek wiha tune be, None vedigere. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"The FibFib hejmar r\u00eazika a r\u00eazika wekhev ji bo Fibbonacci sequnece ku wek j\u00ear hatiye diyarkirin e: fibfib ((0) == 0 fibfib ((1) == 0 fibfib ((2) == 1 fibfib ((n) == fib ((n-1) + fibfib ((n-2) + fibfib ((n-3). Ji kerema xwe re function a ji bo bi bandor hesabkirina element n-em\u00een ji r\u00eazika hejmar fibfib biniv\u00eese.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Di v\u00ea wez\u00eefey\u00ea de, h\u00fbn d\u00ea ji bo string ku n\u00ee\u015fan dide hejmareke apples \u00fb orange ku di basket f\u00eak\u00ee belavkirin ev basket dihew\u00eene apples, orange, \u00fb f\u00eak\u00ee mango. Given string ku n\u00ee\u015fan dide hejmara gi\u015ft\u00ee ya orange \u00fb apples \u00fb integer ku hejmara gi\u015ft\u00ee ya f\u00eak\u00ee di basket veger\u00eenin hejmara f\u00eak\u00ee mango di basket. ji bo examble: fruit_distribution\"5(apples \u00fb 6 orange\", 19) ->19 - 5 - 6 = 8 fruit_distribution\"0 apples \u00fb 1 orange\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 apples \u00fb 3 orange\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 apples \u00fb 120) \",1 -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Niv\u00eeseke function ku array of hejmar\u00ean wek input \u00fb hejmara h\u00eaman\u00ean di array ku mezintir ji 10 \u00fb hem yekem \u00fb daw\u00ee digits ji hejmareke ne wekhev in, veger\u00eene.\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Di nav array a hejmar\u00ean ne-negat\u00eef de, kopiyek ji array\u00ea day\u00een veger\u00eene pi\u015ft\u00ee r\u00eazkirin\u00ea, h\u00fbn \u00ea array\u00ea day\u00een bi r\u00eaza bilindb\u00fbn\u00ea r\u00eazkirin, eger jimara (( nirxa endeks\u00ea ya yekem, nirxa endeks\u00ea ya daw\u00ee) neyek e, an j\u00ee r\u00eazkirin\u00ea bi r\u00eaza dak\u00ea\u015fandin\u00ea r\u00eazkirin, eger jimara (( nirxa endeks\u00ea ya yekem, nirxa endeks\u00ea ya daw\u00ee) j\u00ee e. T\u00eab\u00een\u00ee: * array\u00ea day\u00een neguhere. M\u00eenak: * sort_array[(]) => [] * sort_array[]] => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Ji ber ku ferhengek, eger hem\u00fb kil\u00eetan di nav t\u00eep\u00ean bi\u00e7\u00fbk de bin an hem\u00fb kil\u00eetan di nav t\u00eep\u00ean mezin de bin, eger ne wisa be, veger\u00eene False. Fonksiyon div\u00ea veger\u00eene False eger ferheng\u00ea day\u00ee vala be. M\u00eenak: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) div\u00ea veger\u00eene True. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) div\u00ea veger\u00eene False. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) div\u00ea veger\u00eene False. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Ji ber ku string 'text', string hevbe\u015f ya hash md5 xwe veger\u00eene. Eger 'text' stringek vala be, None veger\u00eene.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero l\u00eesteya hejmar\u00ean temam wek input digire. ew rast vedigere eger du h\u00eaman\u00ean cuda di l\u00eestey\u00ea de hebin ku jimara xwe ji sifir re, \u00fb bi awayek\u00ee din derew.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"2 ^ n modulo p veger\u00eene (ji hejmar\u00ean hi\u015fyar be).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Tu bi array arr ji integer dan \u00fb h\u00fbn div\u00ea ji bo vegera sum of mezintir\u00ee y\u00ean integer bi berhem\u00ean hem\u00fb n\u00ee\u015faney\u00ean her hejmar\u00ea di array, bi 1, -1 an 0 tems\u00eel kirin.\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Stranek ku hejmar\u00ean space-s\u00eenorkir\u00ee ji 0 heta n dest p\u00ea dikin vedigere.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Fonksiyonek biniv\u00eese ku l\u00eesteya stringan qeb\u00fbl bike. L\u00eeste peyv\u00ean cuda dihew\u00eene. Peyv bi hejmara her\u00ee z\u00eade ya karakter\u00ean yekane veger\u00eene. Eger \u00e7end string hejmara her\u00ee z\u00eade ya karakter\u00ean yekane hebin, peyv\u00ea ku di r\u00eaza leks\u00eekoograf\u00eek de yekem\u00een t\u00ea veger\u00eene. find_max (([\"name\", \"of\", \"string\"]) == \"string\" find_max (([\"name\", \"enam\", \"game\"]) == \"enam\" find_max (([\"aaaaaaa\", \"bb\", \"cc\"]) == \"\"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Tu d\u00ea nav\u00ea class (a string) \u00fb l\u00eesteya ji extension\u00ean day\u00een. The extension\u00ean ji bo barkirina ders\u00ean din ji bo class bikaran\u00een. H\u00eaza ji extension e wek li j\u00ear: Bila CAP hejmara t\u00eep\u00ean uppercase di nav\u00ea extension ya be, \u00fb bila SM hejmara t\u00eep\u00ean bi\u00e7\u00fbk di nav\u00ea extension ya be, h\u00eaza bi fraction CAP - SM day\u00een. Tu div\u00ea ji bo d\u00eetina extension her\u00ee xurt \u00fb vegera string di v\u00ea format\u00ea de: ClassName.StrongestExtensionName. Eger du an z\u00eadetir ji extension\u00ean bi heman h\u00eaza hene, div\u00ea h\u00fbn ji yek ku yekem\u00een di l\u00eestey\u00ea de t\u00ea hilbij\u00eare. Bo nim\u00fbne, eger tu bi \"Slices\" wek class \u00fb l\u00eesteya ji extension\u00ean day\u00een: ['SEviRNGSliCes', 'Cheese', 'StuFfed'] hing\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Return True e ku h\u00eaman\u00ean l\u00eestey\u00ea bi awayek\u00ee monoton\u00ee z\u00eade dibin an k\u00eam dibin.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Create a function ku her\u00ee mezin index ji element ku ne mezintir e ji an j\u00ee wekhev bi element rasterast ber\u00ee w\u00ea ye. Eger elementeke wiha tune ye, pa\u015f\u00ea vegere -1. array day\u00een d\u00ea nirx\u00ean dubare ne. nim\u00fbne: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Ji ber ku grid bi r\u00eaz\u00ean N \u00fb kolan\u00ean N (N > = 2) \u00fb k a integer poz\u00eet\u00eef, her hucreya grid\u00ea nirxek dihew\u00eene. Her integer di r\u00eaza [1, N * N] de yekser yekser li hucrey\u00ean grid\u00ea xuya dibe. H\u00fbn div\u00ea r\u00eaya her\u00ee k\u00eam a dir\u00eajahiya k di grid\u00ea de bib\u00eenin. H\u00fbn dikarin ji her hucreyek\u00ea dest p\u00ea bikin, \u00fb di her gav\u00ea de h\u00fbn dikarin ji bo hucrey\u00ean c\u00eeran vegerin, bi gotineke din, h\u00fbn dikarin ji hucrey\u00ean ku bi hucreya niha re li ser x\u00eazeke hev re parve bikin. Ji kerema xwe ve t\u00eab\u00een\u00ee bikin ku r\u00eaya dir\u00eajahiya k t\u00ea wateya serdana k hucreyan (ne hewce ne ku cuda be). H\u00fbn nikarin ji grid\u00ea derkevin. A r\u00eaya A (ji dir\u00ea\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    \u090f\u0917\u094b \u0927\u0928\u093e\u0924\u094d\u092e\u0915 \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 n \u0915\u0947 \u092e\u093e\u0928 \u0915\u0947 \u0906\u0927\u093e\u0930 \u092a\u0930, \u0930\u0909\u0906 \u0915\u0947 n \u0938\u094d\u0924\u0930 \u0915\u0947 \u092a\u0924\u094d\u0925\u0930 \u0915\u0947 \u0922\u0947\u0930 \u092c\u0928\u093e\u0935\u0947 \u0915\u0947 \u0939\u094b\u0908. \u092a\u0939\u093f\u0932\u093e \u0938\u094d\u0924\u0930 \u092e\u0947\u0902 n \u092a\u0924\u094d\u0925\u0930 \u092c\u093e. \u0905\u0917\u093f\u0932\u093e \u0938\u094d\u0924\u0930 \u092e\u0947\u0902 \u092a\u0924\u094d\u0925\u0930 \u0915\u0947 \u0938\u0902\u0916\u094d\u092f\u093e \u0908 \u092c\u093e: - \u0905\u0917\u0930 n \u0935\u093f\u0937\u092e \u092c\u093e \u0924 \u0905\u0917\u0932\u093e \u0935\u093f\u0937\u092e \u0938\u0902\u0916\u094d\u092f\u093e. - \u0905\u0917\u0930 n \u0938\u092e \u092c\u093e \u0924 \u0905\u0917\u0932\u093e \u0938\u092e \u0938\u0902\u0916\u094d\u092f\u093e. \u090f\u0917\u094b \u0938\u0942\u091a\u0940 \u092e\u0947\u0902 \u092a\u094d\u0930\u0924\u094d\u092f\u0947\u0915 \u0938\u094d\u0924\u0930 \u092e\u0947\u0902 \u092a\u0924\u094d\u0925\u0930 \u0915\u0947 \u0938\u0902\u0916\u094d\u092f\u093e \u0932\u094c\u091f\u093e\u0908\u0902, \u091c\u0939\u093e\u0901 \u0907\u0902\u0921\u0947\u0915\u094d\u0938 i \u092e\u0947\u0902 \u0924\u0924\u094d\u0935 \u0938\u094d\u0924\u0930 (i+1) \u092e\u0947\u0902 \u092a\u0924\u094d\u0925\u0930 \u0915\u0947 \u0938\u0902\u0916\u094d\u092f\u093e \u0915\u0947 \u092a\u094d\u0930\u0924\u093f\u0928\u093f\u0927\u093f\u0924\u094d\u0935 \u0915\u0930\u0947\u0932\u093e. \u0909\u0926\u093e\u0939\u0930\u0923:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    \u090f\u0917\u094b \u0935\u093e\u0915\u094d\u092f \u0915\u0947 \u092a\u094d\u0930\u0924\u093f\u0928\u093f\u0927\u093f\u0924\u094d\u0935 \u0915\u0930\u0947 \u0935\u093e\u0932\u093e \u090f\u0917\u094b \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0926\u093f\u0939\u0932 \u0917\u0907\u0932 \u092c\u093e, \u090f\u0939 \u092e\u0947\u0902 \u0915\u0941\u091b \u0936\u092c\u094d\u0926 \u092c\u093e\u0921\u093c\u0940 \u0938 \u091c\u0947\u0915\u0930\u093e \u0915\u0947 \u090f\u0917\u094b \u0938\u094d\u092a\u0947\u0938 \u0938\u0947 \u0905\u0932\u0917 \u0915\u0907\u0932 \u0917\u0907\u0932 \u092c\u093e, \u0906 \u0906\u092a \u0915\u0947 \u090f\u0917\u094b \u0905\u0907\u0938\u0928 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0932\u094c\u091f\u093e\u0935\u0947 \u0915\u0947 \u092c\u093e \u091c\u0947\u0939 \u092e\u0947\u0902 \u092e\u0942\u0932 \u0935\u093e\u0915\u094d\u092f \u0915\u0947 \u0936\u092c\u094d\u0926 \u092c\u093e\u0921\u093c\u0940 \u0938, \u091c\u0947\u0915\u0930 \u0932\u0902\u092c\u093e\u0908 \u0905\u092d\u093e\u091c\u094d\u092f \u0938\u0902\u0916\u094d\u092f\u093e \u092c\u093e, \u0928\u092f\u093e \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u092e\u0947\u0902 \u0936\u092c\u094d\u0926 \u0915\u0947 \u0915\u094d\u0930\u092e \u092e\u0942\u0932 \u0915\u0947 \u0915\u094d\u0930\u092e \u0915\u0947 \u0938\u092e\u093e\u0928 \u0939\u094b\u0916\u0947 \u0915\u0947 \u091a\u093e\u0939\u0940\u0902. \u0909\u0926\u093e\u0939\u0930\u0923 1: \u0907\u0928\u092a\u0941\u091f\u0903 \u0935\u093e\u0915\u094d\u092f = \"\u0908 \u090f\u0917\u094b \u092a\u0930\u0940\u0915\u094d\u0937\u0923 \u0939\" \u0906\u0909\u091f\u092a\u0941\u091f\u0903 \"\u0939\u094b \u092c\u093e\" \u0909\u0926\u093e\u0939\u0930\u0923 2: \u0907\u0928\u092a\u0941\u091f\u0903 \u0935\u093e\u0915\u094d\u092f = \"\u091a\u0932\u094b \u0938\u094d\u0935\u093f\u092e\u093f\u0902\u0917 \u0916\u093e\u0924\u093f\u0930 \u091a\u0932\u0932 \u091c\u093e\u0935\" \u0906\u0909\u091f\u092a\u0941\u091f\u0903 \"\u091c\u093e\u0935\u0947 \u0916\u093e\u0924\u093f\u0930\" \u092c\u093e\u0927\u093e\u0903 * 1 <= len(sentence) <= 100 * \u0935\u093e\u0915\u094d\u092f \u092e\u0947\u0902 \u0916\u093e\u0932\u0940 \u0905\u0915\u094d\u0937\u0930 \u092c\u093e\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" \u090f\u0917\u094b \u0926\u093f\u0939\u0932 \u0917\u0907\u0932 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0916\u093e\u0924\u093f\u0930, \u091b\u094b\u091f \u0905\u0915\u094d\u0937\u0930 \u0915\u0947 \u092c\u0921\u093c \u0905\u0915\u094d\u0937\u0930 \u092e\u0947\u0902 \u0906 \u092c\u0921\u093c \u0905\u0915\u094d\u0937\u0930 \u0915\u0947 \u091b\u094b\u091f \u0905\u0915\u094d\u0937\u0930 \u092e\u0947\u0902 \u092c\u0926\u0932 \u0926\u0940\u0902.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" \u090f\u0917\u094b \u0927\u0928\u093e\u0924\u094d\u092e\u0915 \u092b\u094d\u0932\u094b\u091f\u093f\u0902\u0917 \u092a\u0949\u0907\u0902\u091f \u0938\u0902\u0916\u094d\u092f\u093e \u0915\u0947 \u0926\u0947\u0916 \u0915\u0947, \u090f\u0915\u0930\u093e \u0915\u0947 \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u092d\u093e\u0917 (\u0938\u092c\u0938\u0947 \u092c\u0921\u093c \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u0926\u093f\u0939\u0932 \u0917\u0907\u0932 \u0938\u0902\u0916\u094d\u092f\u093e \u0938\u0947 \u091b\u094b\u091f) \u0906\u0909\u0930 \u0926\u0936\u092e\u0932\u0935 (\u092c\u093e\u0915\u0940 \u092d\u093e\u0917 \u0939\u092e\u0947\u0936\u093e 1 \u0938\u0947 \u091b\u094b\u091f) \u092e\u0947\u0902 \u0935\u093f\u092d\u093e\u091c\u093f\u0924 \u0915\u0907\u0932 \u091c\u093e \u0938\u0915\u0947\u0932\u093e. \u0938\u0902\u0916\u094d\u092f\u093e \u0915\u0947 \u0926\u0936\u092e\u0932\u0935 \u092d\u093e\u0917 \u0932\u094c\u091f\u093e\u0908\u0902. \u0909\u0926\u093e\u0939\u0930\u0923:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    \u090f\u0917\u094b \u092b\u0932\u0928 \u0932\u093f\u0916\u0947\u0902 \u091c\u0947 \u090f\u0917\u094b \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0932\u0947 \u0932\u0947 \u0906 \u0913\u0915\u0930 \u090f\u0917\u094b \u0915\u094d\u0930\u092e\u092c\u0926\u094d\u0927 \u0938\u0902\u0938\u094d\u0915\u0930\u0923 \u0932\u094c\u091f\u093e\u0935\u0947\u0932\u093e. \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0915\u0947 \u0915\u094d\u0930\u092e\u092c\u0926\u094d\u0927 \u0938\u0902\u0938\u094d\u0915\u0930\u0923, \u090f\u0917\u094b \u0905\u0907\u0938\u0928 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0939\u094b\u0932\u093e \u091c\u0939\u093e\u0901 \u0938\u092c \u0936\u092c\u094d\u0926 (\u0938\u094d\u092a\u0947\u0938 \u0938\u0947 \u0905\u0932\u0917) \u0915\u0947 \u090f\u0917\u094b \u0928\u092f\u093e \u0936\u092c\u094d\u0926 \u0938\u0947 \u092c\u0926\u0932 \u0926\u093f\u0939\u0932 \u091c\u093e\u0932\u093e \u091c\u0939\u093e\u0901 \u0938\u092c \u0905\u0915\u094d\u0937\u0930 \u0915\u0947 \u0915\u094d\u0930\u092e \u0915\u094d\u0930\u092e \u092e\u0947\u0902 \u0915\u094d\u0930\u092e\u092c\u0926\u094d\u0927 \u0915\u0907\u0932 \u091c\u093e\u0932\u093e. \u0928\u094b\u091f\u0903 \u0906\u092a\u0915\u0947 \u0935\u093e\u0915\u094d\u092f \u092e\u0947\u0902 \u0936\u092c\u094d\u0926 \u0906 \u0916\u093e\u0932\u0940 \u091c\u0917\u0939 \u0915\u0947 \u0915\u094d\u0930\u092e \u0930\u0916\u0947 \u0915\u0947 \u091a\u093e\u0939\u0940\u0902. \u0909\u0926\u093e\u0939\u0930\u0923 \u0916\u093e\u0924\u093f\u0930\u0903 anti_shuffle ((('Hi') 'Hi' anti_shuffle (('hello') \u0932\u094c\u091f\u093e\u0935\u0947\u0932\u093e 'ehllo' anti_shuffle (('Hello World!!!') \u0932\u094c\u091f\u093e\u0935\u0947\u0932\u093e 'Hello!!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets \"<\" \u0906 \">\" \u0915\u0947 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0939\u0935\u0947. \u0905\u0917\u0930 \u0939\u0930 \u0916\u094b\u0932\u0947 \u0935\u093e\u0932\u093e \u092c\u094d\u0930\u0948\u0915\u0947\u091f \u092e\u0947\u0902 \u090f\u0915 \u0920\u094b \u092c\u0902\u0926 \u0915\u0930\u0947 \u0935\u093e\u0932\u093e \u092c\u094d\u0930\u0948\u0915\u0947\u091f \u0939\u094b\u0916\u0947 \u0924\u092c \u0908 \u0938\u0939\u0940 \u0932\u0909\u0915\u0947 \u0932\u093e.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0915\u0947 \u090f\u0917\u094b \u0907\u0928\u092a\u0941\u091f \u0938\u0942\u091a\u0940 \u0915\u0947 \u0916\u093e\u0932\u0940 \u0909 \u0938\u092c \u0916\u093e\u0924\u093f\u0930 \u092b\u093c\u093f\u0932\u094d\u091f\u0930 \u0915\u0930\u0940\u0902 \u091c\u0947\u092e\u0947 \u0926\u093f\u0939\u0932 \u0917\u0907\u0932 \u0938\u092c\u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u092c\u093e\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"\u090f\u0917\u094b \u092b\u0932\u0928 \u0932\u093f\u0916\u0940\u0902 \u091c\u0947 \u0938\u0902\u0916\u094d\u092f\u093e \u0915\u0947 \u090f\u0917\u094b \u0938\u0930\u0923\u0940 \u0915\u0947 \u0907\u0928\u092a\u0941\u091f \u0915\u0947 \u0930\u0942\u092a \u092e\u0947\u0902 \u0932\u0947 \u0932\u0947 \u0906 \u090a \u0924\u0924\u094d\u0935 \u0915\u0947 \u0938\u0902\u0916\u094d\u092f\u093e \u0932\u094c\u091f\u093e\u0935\u0947 \u091c\u0947 10 \u0938\u0947 \u092c\u0921\u093c \u0939\u094b\u0916\u0947 \u0906 \u0938\u0902\u0916\u094d\u092f\u093e \u0915\u0947 \u092a\u0939\u093f\u0932\u093e \u0906 \u0906\u0916\u093f\u0930\u0940 \u0905\u0902\u0915 \u0926\u0941\u0928\u094b\u0902 \u0935\u093f\u0937\u092e (1, 3, 5, 7, 9) \u0939\u094b\u0916\u0947 \u0909\u0926\u093e\u0939\u0930\u0923 \u0916\u093e\u0924\u093f\u0930\u0903 specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"1 \u0938\u0947 \u092c\u0922\u093c\u093e\u0935\u0932 \u0917\u0907\u0932 \u0924\u0924\u094d\u0935 \u0915\u0947 \u0938\u093e\u0925\u0947 \u0930\u093f\u091f\u0930\u094d\u0928 \u0938\u0942\u091a\u0940\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    \u0935\u0930\u094d\u0923\u092e\u093e\u0932\u093e \u092e\u0947\u0902 \u0939\u0930 \u0935\u0930\u094d\u0923 \u0915\u0947 5 \u0938\u0947 \u0938\u094d\u0925\u093e\u0928\u093e\u0902\u0924\u0930\u093f\u0924 \u0915\u0930\u0915\u0947 \u090f\u0928\u094d\u0915\u094b\u0921\u0947\u0921 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0932\u094c\u091f\u093e\u0935\u0947\u0932\u093e.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"\u0908 \u0906\u0902\u0915\u0932\u0928 \u0915\u0930\u0940\u0902 \u0915\u093f \u0915\u093e \u0926\u093f\u0939\u0932 \u0917\u0907\u0932 \u0938\u0902\u0916\u094d\u092f\u093e n \u0915\u0947 \u0920\u0940\u0915 4 \u0927\u0928\u093e\u0924\u094d\u092e\u0915 \u0938\u092e \u0938\u0902\u0916\u094d\u092f\u093e \u0915\u0947 \u092f\u094b\u0917 \u0915\u0947 \u0930\u0942\u092a \u092e\u0947\u0902 \u0932\u093f\u0916\u0932 \u091c\u093e \u0938\u0915\u0947\u0932\u093e \u0909\u0926\u093e\u0939\u0930\u0923 is_equal_to_sum_even ({4) == False is_equal_to_sum_even ({6) == False is_equal_to_sum_even ({8) == True\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917\u094d\u0938 \u0915\u0947 \u0938\u0942\u091a\u0940 \u092e\u0947\u0902 \u0938\u0947, \u0938\u092c\u0938\u0947 \u0932\u0902\u092c\u093e \u0932\u094c\u091f\u093e\u0908. \u090f\u0915\u0939\u0940 \u0932\u0902\u092c\u093e\u0908 \u0915\u0947 \u0915\u0908 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917\u094d\u0938 \u0915\u0947 \u0938\u094d\u0925\u093f\u0924\u093f \u092e\u0947\u0902 \u092a\u0939\u093f\u0932\u093e \u0932\u094c\u091f\u093e\u0908. \u0907\u0928\u092a\u0941\u091f \u0938\u0942\u091a\u0940 \u0916\u093e\u0932\u0940 \u0939\u094b\u0916\u0947 \u092a\u0930 \u0928\u093e \u0932\u094c\u091f\u093e\u0908.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"\u0908 \u092b\u0932\u0928 \u090f\u0917\u094b \u0938\u0942\u091a\u0940 l \u0932\u0947\u0932\u093e \u0906\u0909\u0930 \u090f\u0917\u094b \u0938\u0942\u091a\u0940 l' \u0932\u094c\u091f\u093e\u0935\u0947\u0932\u093e, \u0905\u0907\u0938\u0928 \u0915\u093f l' \u0909 \u0938\u0942\u091a\u0915\u093e\u0902\u0915 \u092e\u0947\u0902 l \u0915\u0947 \u0938\u092e\u093e\u0928 \u0939\u094b \u091c\u0947 \u0924\u0940\u0928 \u0938\u0947 \u0935\u093f\u092d\u093e\u091c\u094d\u092f \u0928\u093e \u0939\u094b, \u091c\u092c\u0915\u093f \u0924\u0940\u0928 \u0938\u0947 \u0935\u093f\u092d\u093e\u091c\u094d\u092f \u0938\u0942\u091a\u0915\u093e\u0902\u0915 \u092e\u0947\u0902 \u090f\u0915\u0930 \u092e\u093e\u0928 l \u0915\u0947 \u0938\u0902\u092c\u0902\u0927\u093f\u0924 \u0938\u0942\u091a\u0915\u093e\u0902\u0915 \u0915\u0947 \u092e\u093e\u0928 \u0915\u0947 \u092c\u0930\u093e\u092c\u0930 \u0939\u094b\u0932\u093e, \u0932\u0947\u0915\u093f\u0928 \u0938\u0949\u0930\u094d\u091f \u0915\u0907\u0932 \u091c\u093e\u0932\u093e.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 arr \u0906\u0909\u0930 \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 k \u0915\u0947 \u090f\u0917\u094b \u0917\u0948\u0930-\u0916\u093e\u0932\u0940 \u0938\u0930\u0923\u0940 \u0915\u0947 \u0926\u093f\u0939\u0932 \u0917\u0907\u0932 \u092c\u093e, \u0924\u092c \u090f\u0906\u0930 \u0915\u0947 \u092a\u0939\u093f\u0932\u093e \u0915\u0947 \u0924\u0924\u094d\u0935\u0928 \u0938\u0947 \u0905\u0927\u093f\u0915\u0924\u092e \u0926\u0942 \u0905\u0902\u0915 \u0935\u093e\u0932\u093e \u0924\u0924\u094d\u0935\u0928 \u0915\u0947 \u092f\u094b\u0917 \u0932\u094c\u091f\u093e\u0908. \u0909\u0926\u093e\u0939\u0930\u0923\u0903 \u0907\u0928\u092a\u0941\u091f\u0903 \u090f\u0906\u0930 = [111,21,3,4000,5,6,7,8,9], \u0915\u0947 = 4 \u0906\u0909\u091f\u092a\u0941\u091f\u0903 24 # 21 + 3 \u0915\u0947 \u092f\u094b\u0917 \u092c\u093e\u0927\u093e\u0903 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"\u090f\u0917\u094b \u092b\u0932\u0928 \u092c\u0928\u093e\u0935\u0947 \u091c\u0947 \u090f\u0917\u094b \u092b\u093c\u093e\u0907\u0932 \u0915\u0947 \u0928\u093e\u0901\u0935 \u0915\u0947 \u092a\u094d\u0930\u0924\u093f\u0928\u093f\u0927\u093f\u0924\u094d\u0935 \u0915\u0930\u0947 \u0935\u093e\u0932\u0940 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0932\u0947, \u0906 \u0905\u0917\u0930 \u092b\u093e\u0907\u0932 \u0915\u0947 \u0928\u093e\u0901\u0935 \u092e\u093e\u0928\u094d\u092f \u092c\u093e \u0924 '\u0939\u093e\u0901' \u0932\u094c\u091f\u093e\u0935\u0947, \u0906 \u0905\u0917\u0930 \u092e\u093e\u0928\u094d\u092f \u0928 \u092c\u093e \u0924 '\u0928\u093e' \u0932\u094c\u091f\u093e\u0935\u0947. \u090f\u0917\u094b \u092b\u093e\u0907\u0932 \u0915\u0947 \u0928\u093e\u0901\u0935 \u0935\u0948\u0927 \u092e\u093e\u0928\u0932 \u091c\u093e\u0932\u093e \u0905\u0917\u0930 \u0905\u0909\u0930\u0940 \u0916\u093e\u0932\u0940 \u0905\u0917\u0930 \u0928\u0940\u091a\u0947 \u0926\u093f\u0939\u0932 \u0936\u0930\u094d\u0924 \u092a\u0942\u0930\u093e \u0939\u094b\u0916\u0947\u0902\u0903 - \u092b\u093e\u0907\u0932 \u0915\u0947 \u0928\u093e\u0901\u0935 \u092e\u0947\u0902 \u0924\u0940\u0928 \u0938\u0947 \u092c\u0947\u0938\u0940 \u0905\u0902\u0915 ('0'-'9') \u0928\u093e \u0939\u094b\u0916\u0947 \u0915\u0947 \u091a\u093e\u0939\u0940\u0902. - \u092b\u093e\u0907\u0932 \u0915\u0947 \u0928\u093e\u0901\u0935 \u092e\u0947\u0902 \u0920\u0940\u0915 \u090f\u0915 \u0920\u094b \u092c\u093f\u0902\u0926\u0941 '.' \u0939\u094b\u0916\u0947 \u0915\u0947 \u091a\u093e\u0939\u0940\u0902. - \u092c\u093f\u0902\u0926\u0941 \u0938\u0947 \u092a\u0939\u093f\u0932\u0947 \u0915\u0947 \u0938\u092c\u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0916\u093e\u0932\u0940 \u0928\u093e \u0939\u094b\u0916\u0947 \u0915\u0947 \u091a\u093e\u0939\u0940\u0902, \u0906 \u0908 \u0932\u093e\u0924\u0940\u0928\u0940 \u0905\u0932\u094d\u092b\u093e\u092c\u0947\u091f ('a'-'z' \u0906 'A'Z'-) \u0938\u0947 \u0936\u0941\u0930\u0942 \u0939\u094b\u0916\u0947 \u0915\u0947 \u091a\u093e\u0939\u0940\u0902. - \u092c\u093f\u0902\u0926\u0941 \u0915\u0947 \u092c\u093e\u0926 \u0915\u0947 \u0938\u092c\u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u092e\u0947\u0902 \u0938\u0947 \u090f\u0917\u094b \u0939\u094b\u0916\u0947 \u0915\u0947 \u091a\u093e\u0939\u0940\u0902\u0903 ['txt', 'exe', 'lld'] \u0909\u0926\u093e\u0939\u0930\u0923\u0903 file_name_check\"{example.txt.} # => '\u0939\u093e\u0901' file_name_check\"{ex\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"2^n \u092e\u0949\u0921\u0941\u0932\u094b p \u0932\u094c\u091f\u093e\u0908 (\u0938\u0902\u0916\u094d\u092f\u093e \u0915\u0947 \u092c\u093e\u0930\u0947 \u092e\u0947\u0902 \u091c\u093e\u0917\u0930\u0942\u0915 \u0930\u0939\u0947\u0902).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n \u090f\u0917\u094b \u092b\u0932\u0928 \u092c\u093e \u091c\u0947 1 \u0938\u0947 n \u0924\u0915 \u0915\u0947 \u0938\u0902\u0916\u094d\u092f\u093e \u0915\u0947 \u092f\u094b\u0917 \u092c\u0928\u093e\u0935\u0947\u0932\u093e.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" \u0938\u0902\u0916\u094d\u092f\u093e \u0915\u0947 \u090f\u0917\u094b \u0938\u0942\u091a\u0940 (\u0915\u092e \u0938\u0947 \u0915\u092e \u0926\u0942 \u0924\u0924\u094d\u0935 \u0915\u0947) \u0926\u093f\u0939\u0932 \u0917\u0907\u0932 \u092c\u093e, \u0909 \u0938\u0942\u091a\u0940 \u092e\u0947\u0902 \u090f\u0917\u094b \u0930\u0948\u0916\u093f\u0915 \u092a\u0930\u093f\u0935\u0930\u094d\u0924\u0928 \u0932\u093e\u0917\u0942 \u0915\u0907\u0932 \u091c\u093e, \u091c\u0947\u0935\u0928\u093e \u0938\u0947 \u0938\u092c\u0938\u0947 \u091b\u094b\u091f \u0938\u0902\u0916\u094d\u092f\u093e 0 \u0939\u094b \u091c\u093e\u0908 \u0906\u0909\u0930 \u0938\u092c\u0938\u0947 \u092c\u0921\u093c \u0938\u0902\u0916\u094d\u092f\u093e 1 \u0939\u094b \u091c\u093e\u0908.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"\u090f\u0917\u094b \u092b\u0932\u0928 \u090f\u0928\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f \u092c\u0928\u093e\u0908\u0902 \u091c\u0947 \u090f\u0917\u094b \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0915\u0947 \u0924\u0930\u094d\u0915 \u0915\u0947 \u0930\u0942\u092a \u092e\u0947\u0902 \u0932\u0947 \u0932\u0947 \u0906 \u0935\u0930\u094d\u0923\u092e\u093e\u0932\u093e \u0915\u0947 \u0918\u0941\u092e\u093e \u0915\u0947 \u090f\u0917\u094b \u090f\u0928\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f \u0915\u0907\u0932 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0932\u094c\u091f\u093e\u0935\u0947. \u0935\u0930\u094d\u0923\u092e\u093e\u0932\u093e \u0915\u0947 \u0905\u0907\u0938\u0928 \u0924\u0930\u0940\u0915\u093e \u0938\u0947 \u0918\u0941\u092e\u093e\u0935\u0932 \u091c\u093e\u090f \u0915\u0947 \u091a\u093e\u0939\u0940\u0902 \u0915\u093f \u0905\u0915\u094d\u0937\u0930 \u0926\u0942 \u0938\u094d\u0925\u093e\u0928 \u092a\u0930 \u0926\u0942 \u0938\u0947 \u0917\u0941\u0923\u093e \u0915\u0930\u0915\u0947 \u0928\u0940\u091a\u0947 \u0906 \u091c\u093e\u0935. \u0909\u0926\u093e\u0939\u0930\u0923 \u0916\u093e\u0924\u093f\u0930\u0903 \u090f\u0928\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f (hi) \u0932\u094c\u091f\u093e\u0935\u0947 'lm' \u090f\u0928\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f (asdfghjkl) \u0932\u094c\u091f\u093e\u0935\u0947 'ewhjklnop' \u090f\u0928\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f (gf) \u0932\u094c\u091f\u093e\u0935\u0947 'kj' \u090f\u0928\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f (et) \u0932\u094c\u091f\u093e\u0935\u0947 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    \u090f\u0917\u094b \u092b\u0932\u0928 count_nums \u0932\u093f\u0916\u0940\u0902 \u091c\u0947 \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u0915\u0947 \u090f\u0917\u094b \u0938\u0930\u0923\u0940 \u0932\u0947\u0932\u093e \u0906\u0909\u0930 \u0905\u0907\u0938\u0928 \u0924\u0924\u094d\u0935 \u0915\u0947 \u0938\u0902\u0916\u094d\u092f\u093e \u0932\u094c\u091f\u093e\u0935\u0947\u0932\u093e \u091c\u0947\u0915\u0930 \u0905\u0902\u0915 \u0915\u0947 \u092f\u094b\u0917 > 0 \u092c\u093e. \u0905\u0917\u0930 \u0915\u094c\u0928\u094b \u0938\u0902\u0916\u094d\u092f\u093e \u090b\u0923\u093e\u0924\u094d\u092e\u0915 \u092c\u093e, \u0924 \u0913\u0915\u0930 \u092a\u0939\u093f\u0932\u093e \u0939\u0938\u094d\u0924\u093e\u0915\u094d\u0937\u0930\u093f\u0924 \u0905\u0902\u0915 \u090b\u0923\u093e\u0924\u094d\u092e\u0915 \u0939\u094b\u0908\u0903 \u0909\u0926\u093e\u0939\u0930\u0923 \u0916\u093e\u0924\u093f\u0930 -123 \u092e\u0947\u0902 \u0905\u0902\u0915 -1, 2, \u0906\u0909\u0930 3 \u0915\u0947 \u0939\u0938\u094d\u0924\u093e\u0915\u094d\u0937\u0930\u093f\u0924 \u092c\u093e.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u0915\u0947 \u0938\u0942\u091a\u0940 \u0938\u0947, \u0909 \u0938\u092c \u0924\u0924\u094d\u0935 \u0915\u0947 \u0939\u091f\u093e \u0926\u0940\u0902 \u091c\u0947 \u090f\u0915 \u0938\u0947 \u0905\u0927\u093f\u0915 \u092c\u093e\u0930 \u0906\u0935\u0947\u0932\u093e. \u0907\u0928\u092a\u0941\u091f \u092e\u0947\u0902 \u091c\u0907\u0938\u0928 \u0915\u094d\u0930\u092e \u092c\u093e\u091a\u0932 \u092c\u093e, \u0913\u0907\u0938\u0928 \u0939\u0940 \u0915\u094d\u0930\u092e \u092e\u0947\u0902 \u0924\u0924\u094d\u0935 \u0915\u0947 \u0930\u0916\u0940\u0902.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Endurgevur bert jalig t\u00f8l \u00ed listanum.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Gev st\u00f8rsta primt\u00f8l av n. Um n > 1 er ikki primt.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Gevur upp ordiliga felags elementir fyri tveir listar.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets er ein streng av \"<\" og \">\". return True um hv\u00f8rt opnandi parket hevur eitt samsvarandi lokandi parket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Um N = 1000, ver\u00f0ur tali\u00f0 av talvum 1 og \u00fatgangsst\u00f8\u00f0i\u00f0 skal vera \"1\". Um N = 150, ver\u00f0ur tali\u00f0 av talvum 6 og \u00fatgangsst\u00f8\u00f0i\u00f0 skal vera \"110\". Um N = 147, ver\u00f0ur tali\u00f0 av talvum 12 og \u00fatgangsst\u00f8\u00f0i\u00f0 skal vera \"1100\".\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Gevur sannleika, um \u00f8ll t\u00f8l \u00ed listanum l eru undir markinum t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"V\u00edsir st\u00f8rsta element \u00ed listanum.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Gevst ein ikki t\u00f3m r\u00f8\u00f0 av heilum t\u00f8lum arr og eitt heil t\u00f8l k, so skal summari\u00f0 av elementunum vi\u00f0 \u00ed mesta lagi tveimum t\u00f8lum fr\u00e1 fyrstu k elementunum \u00ed arr, ver\u00f0a latin aftur. D\u00f8mi: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # summari\u00f0 av 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"T\u00fa f\u00e6rt ein lista vi\u00f0 heilum t\u00f8lum. T\u00fa skalt finna st\u00f8rsta prim-vir\u00f0i\u00f0 og lata summar av t\u00ed nummarinum. D\u00f8mi: Fyri lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] skal \u00fatg\u00e1vuna vera 10 Fyri lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] skal \u00fatg\u00e1vuna vera 25 Fyri lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] skal \u00fatg\u00e1vuna vera 13 Fyri lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] skal \u00fatg\u00e1vuna vera 11 Fyri lst = [0,81,12,31,21] skal \u00fatg\u00e1vuna vera 3\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    \u00cd hesum Kata, skalt t\u00fa ra\u00f0festa eina r\u00f8\u00f0 av ikki-negativum heilum talum eftir tali av einum \u00ed teirra binara representati\u00f3n \u00ed uppgongdari ra\u00f0fylgju.\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"T\u00fa hevur fingi\u00f0 til uppg\u00e1vu at skriva eina funkti\u00f3n, sum tekur \u00edm\u00f3ti einum hexadecimaltal sum einari strengi og telur tali\u00f0 av hexadecimaltalt\u00f8lum, sum eru primt\u00f8l (pr\u00edmt\u00f8l, ella eitt primt\u00f8l, er eitt nat\u00farligt tal st\u00f8rri enn 1, sum ikki er eitt produkt av tveimum sm\u00e6rri nat\u00farligum t\u00f8lum). Hexadecimalt\u00f8lini eru 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Pr\u00edmt\u00f8lini eru 2, 3, 5, 7, 11, 13, 17,... So t\u00fa m\u00e1st finna eitt tal av hesum t\u00f8lum: 2, 3, 5, 7, B (=decimal 11), D (=decimal 13). Vi\u00f0merking: T\u00fa kanst rokna vi\u00f0, at inngangurin alt\u00ed\u00f0 er r\u00e6ttur ella t\u00f3mur strengi, og symbolini A,B,C,D,E,F eru alt\u00ed\u00f0 st\u00f3rskri\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Til ein givnan lista vi\u00f0 heilum t\u00f8lum, skal ein tuple ver\u00f0a latin sum er eitt heild og eitt produkt av \u00f8llum heilum t\u00f8lum \u00ed einum lista.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"T\u00edn uppg\u00e1va er at skriva eina funkti\u00f3n, sum gevur sannleika, um eitt tal x er ein einf\u00f8ld potens av n, og falskt \u00ed \u00f8\u00f0rum f\u00f8rum. x er ein einf\u00f8ld potens av n, um n**int=x T.d.: er_einf\u00f8ld_potentia (a) (i) (i) (ii) => sannur er_einf\u00f8ld_potentia (i) (ii) => sannur er_einf\u00f8ld_potentia (i) (iii) => sannur er_einf\u00f8ld_potentia (i) (iii) => falskur er_einf\u00f8ld_potentia (i) (iii) => falskur er_einf\u00f8ld_potentia (i) (iii) => falskur\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Henda funkti\u00f3n tekur tvey positivar t\u00f8l x og y og gevur st\u00f8rsta javna heilt tal, sum er \u00ed r\u00e1sini [x, y] inklusivt. Um ta\u00f0 ikki er naka\u00f0 sl\u00edkt tal, so skal funkti\u00f3nin geva -1.\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"T\u00fa hevur tvey intervall, har hv\u00f8rt intervall er eitt pari av heilum t\u00f8lum. T.d. intervall = (start, end) = (1, 2). T\u00e6r givnu intervallini eru stongd, sum merkir, at intervall (start, end) inniheldur b\u00e6\u00f0i start og end. Fyri hv\u00f8rt givi\u00f0 intervall ver\u00f0ur rokna\u00f0 vi\u00f0, at starturin er minni enn ella l\u00edka vi\u00f0 endin. T\u00edn uppg\u00e1va er at finna \u00fat av, um longdin \u00e1 skerjingini av hesum b\u00e1\u00f0um intervallum er eitt primtal. D\u00f8mi: Skeringin av intervallunum (1, 3), (2, 4) er (2, 3) sum hevur longdina 1, sum ikki er eitt primtal. Um longdin \u00e1 skerjingini er eitt primtal, sendur t\u00fa \"JA\", annars sendur t\u00fa \"NEI\". Um teir b\u00e1\u00f0ir intervallini ikki skerjast, sendir t\u00fa \"NEI\". [input\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" V\u00eds longd \u00e1 givnu strengi\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    T\u00fa hevur eitt rektangul\u00e6rt r\u00e1sverk av brunnum. Hv\u00f8r r\u00f8\u00f0 umbo\u00f0ar eina brunn, og hv\u00f8r 1 \u00ed r\u00f8\u00f0ini umbo\u00f0ar eina vatnstykki. Hv\u00f8r brunnur hevur eina samsvarandi spann, sum kann br\u00fakast til at taka vatn \u00far, og allir spannir hava sama kapasitet. T\u00edn uppg\u00e1va er at br\u00faka spannirnar til at t\u00f8ma brunnirnar. \u00datgangin er, hvussu ofta t\u00fa skalt l\u00e6kka brunnirnar.\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Gev einari r\u00f8\u00f0 av ikki-negativum heilum t\u00f8lum, send eitt avrit av t\u00ed givnu r\u00f8\u00f0ini eftir at hava sortera\u00f0, so skal t\u00fa sortera ta givnu r\u00f8\u00f0ina \u00ed uppgongdarsvari, um summan ((fyrsta indekstvir\u00f0i, seinasta indekstvir\u00f0i) er \u00f3l\u00edkt, ella sortera hana \u00ed fallandi ra\u00f0, um summan ((fyrsta indekstvir\u00f0i, seinasta indekstvir\u00f0i) er javnt.\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" At f\u00e1a strenge listan \u00ed eina strenge\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Finn hvussu ofta ein givin undirstring kann finnast \u00ed upprunaliga stringini. Tel yvirskipa\u00f0 d\u00f8mi.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Skriva eina funkti\u00f3n, sum tekur eina talvu sum inngang og gevur tali\u00f0 av elementum \u00ed talvu, sum eru st\u00f8rri enn 10, og b\u00e6\u00f0i fyrsta og seinasta talvtalv er \u00f3liviligt (1, 3, 5, 7, 9). T.d. specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels er ein funkti\u00f3n, sum tekur strengi og gevur strengi uttan vokal.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, returns a tuple that has the number of even and odd integer palindromes that fall within the range ((1, n), inclusive. Example1: Input: 3 Output: (1, 2) Explanation: Integer palindrome are 1, 2, 3. ein teirra er javnur, og tveir teirra eru \u00f3javnir. Example2: Input: 12 Output: (4, 6) Explanation: Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. f\u00fdra teirra eru javnir, og 6 teirra eru \u00f3javnir.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels adalah fungsi nyang geucok string ngon geuwoe string hana vokal.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Diberi bilangan bulat positif N, kembalikan jumlah total digit-digitnya dalam biner. Contoh Untuk N = 1000, jumlah digit akan menjadi 1 output harus \"1\". Untuk N = 150, jumlah digit akan menjadi 6 output harus \"110\". Untuk N = 147, jumlah digit akan menjadi 12 output harus \"1100\". Variabel: @N bilangan bulat Keterbatasan: 0 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10000. Output: string bilangan biner\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Meunurot bilangan bulat positif n, meubalekkan hasil peuneubah dari angka ganjil. Meubalekkan 0 meunyo mandum angka na pasangan. Miseu jih: angka\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Meunurot grid deungen N bareh dan N kolom (N >= 2) dan bilangan bulat positif k, tiep sel dari grid nyan na nilai. tiep bilangan bulat dalam rentang [1, N * N] termasok deuh seucara eksak sekali bak sel-sel grid. Droeneuh harus meurumpok jalan minimal panyang k bak grid. Droeneuh jeut neujak dari sel, dan bak tiep langkah droeneuh jeut neujak bak sel-sel tetangga, ngon kata laen, droeneuh jeut neujak bak sel-sel yang na sagoe sama deungen droeneuh bak sel saat nyo. Neuteupue bahwa jalan panyang k berarti neujak bak sel-sel yang tepat (hana perle hana berbeda). Droeneuh hanjeut neujak bak grid. Jalan A (panjang k) dianggap kureng dari jalan B (panjang k) jika lheuh peuget daftar tersusun nilai-nilai bak sel-sel yang\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Bayangkan sebuah jalan yang lurus sempurna garis panjang yang tak terhingga. n mobil mengemudi dari kiri ke kanan; secara bersamaan, satu set berbeda dari n mobil mengemudi dari kanan ke kiri. dua set mobil mulai dari jarak yang sangat jauh satu sama lain. semua mobil bergerak dengan kecepatan yang sama. dua mobil dikatakan bertabrakan ketika mobil yang bergerak dari kiri ke kanan menabrak mobil yang bergerak dari kanan ke kiri. namun, mobil-mobil tersebut sangat kokoh dan kuat; akibatnya, mereka terus bergerak dalam lintasan mereka seolah-olah mereka tidak bertabrakan. fungsi ini menghasilkan jumlah tabrakan seperti itu.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input untuk fungsi ini adalah string yang mewakili nota musik dalam format ASCII khusus. Tugas anda adalah untuk menganalisa string ini dan mengembalikan daftar bilangan bulat yang sesuai dengan berapa banyak ketukan yang masing-masing tidak bertahan. Berikut adalah legenda: 'o' - catatan keseluruhan, bertahan empat ketukan 'o\" - setengah catatan, bertahan dua ketukan '. \" \" - catatan quater, bertahan satu ketukan\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero meuanggap daftar bilangan bulat seubagoe input. jih meupeugisa True meunyo na dua elemen yang berbeda dalam daftar yang jumlah jih sama deungen nol, dan False meunyo hana.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Meugisa string nyang meuaso angka nyang ji wateh le spasi mulai dari 0 sampoe n termasok.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    Neubri saboh daftar bilangan bulat. Neutuleh fungsi next_smallest (() nyang geuwoe elemen keu-2 paleng ubit lam daftar. Neupeugisa none meunyoe hana elemen lagee nyan. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Diberi sebuah array arr bilangan bulat dan bilangan bulat positif k, kembalikan daftar tersusun panjangnya k dengan jumlah maksimum k bilangan di arr. Contoh1: Input: arr = [-3, -4, 5], k = 3 Output: [-4, -3, 5] Contoh2: Input: arr = [4, -4, 4], k = 2 Output: [4, 4] Contoh3: Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Output: [2] Catatan: 1. panjang array akan berada di kisaran [1, 1000]. 2. elemen dalam array akan berada di kisaran [-1000, 1000]. 3. 0 <= k <= len (arr)\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Kembalikan elemen umum unik yang disortir untuk dua daftar.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"Tugas Tuleh fungsi nyang geucok string seubagoe input ngon geuwoe jumlah dari karakter ateuh mantong' kode ASCII. Contoh: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Meuseukat polinomial deungen koefisien xs bak titek x. puwoe xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Tulis fungsi yang menerima daftar string. Daftar berisi kata yang berbeda. Kembalikan kata dengan jumlah karakter unik maksimal. Jika beberapa string memiliki jumlah karakter unik maksimal, kembalikan yang pertama dalam urutan leksikografis.\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Peuget fungsi yang meucok bilangan bulat, float, atau string yang mewakili bilangan nyata, dan meupeutron variabel yang leubeh rayek dalam tipe variabel yang diberikan. Meulipat hana jika nilai-nilai sama. Catatan: Jika bilangan nyata diwakili sebagai string, titik terapung mungkin. atau, bandingkan_satu, 2,5) \u00e2 -> 2,5 bandingkan_satu, \"2,3\") \u00e2 -> \"2,3\" bandingkan_satu, \"5,1\", \"6\") \u00e2 -> \"6\" bandingkan_satu, \"1\", 1) \u00e2 -> Hana\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nTamah lom kasus uji coba.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    Contoh: * makan(5, 6, 10) -> [11, 4] * makan(4, 8, 9) -> [12, 1] * makan(1, 10, 10) -> [11, 0] * makan(2, 11, 5) -> [7, 0] Variabel: @number: bilangan bulat bilangan wortel yang telah anda makan. @need: bilangan bulat bilangan wortel yang perlu anda makan. @remaining: bilangan bulat bilangan wortel yang tersisa di stok Constrain: * 0= <= 0 * 1000 = <= 0 * 0 = <= 1000 = <= 1000 Sekalian bersenang-senanglah:)\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Peuteubiet fungsi nyang geupeutentei string tanggai nyang teubri dan geuwoe True meunyoe tanggai nyan sah. Laen jih False. Tanggai nyan sah meunyoe mandum aturan nyoe geupeutentei: 1. string tanggai hana kosong. 2. jumlah uroe hana kureung leubeh dari 1 atawa leubeh dari 31 uroe keu buleun 1,3,5,7,8,10,12. dan jumlah uroe hana kureung leubeh dari 1 atawa leubeh dari 30 uroe keu buleun 4,6,9,11. dan, jumlah uroe hana kureung leubeh dari 1 atawa leubeh dari 29 keu buleun 2. 3. buleun han jeut kureung leubeh dari 1 atawa leubeh dari 12.4. tanggai nyan harus lam format: mm-dd-yyyy misaljih: valid_date (('03-11-2000') => true_date (('15-01-2012') => false_date (('04-040-20') => false_date (('06-04-2020') => true_date (('06\/04\/2020\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"Peurlehan peunil\u00e9h peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t peuneug\u00f6t\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Contoh: Untuk lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] outputnya harus 10 Untuk lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] outputnya harus 25 Untuk lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] outputnya harus 13 Untuk lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] outputnya harus 11 Untuk lst = [0,81,12,3,21,1] outputnya harus 3 Untuk lst = [0,1,8,2,1,7] outputnya harus 7\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Meupeugisa elemen unik nyang ka ji urot lam daftar\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Seurutan Fibonacci dituri le mandum ureng, nyan ka geu peuruno le para matematikawan lam padum-padum abad nyang ka u likot. Namun, yang hana dituri le ureng adalah urutan Tribonacci. Urutan Tribonacci didefinisikan le pengulangan: tri(1) = 3 tri(n) = 1 + n \/ 2, jika n adalah genap. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), jika n adalah ganjil. Misal: tri(2) = 1 + (2 \/ 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Droeneuh geubri bilangan bulat non-negatif n, droeneuh harus neuba daftar bilangan n + 1 phon dari urutan Tribonacci. Contoh: tri(3) = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Emu ns\u025bm a \u025bw\u0254 list l no mu no mu dodow a w\u0254san de ba.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    S\u025b wode operand ne operator ka ho a, nea edi kan no y\u025b algebra mu adwuma, na nea \u025bt\u0254 so no y\u025b integers. Fa list abien no y\u025b algebra mu adwuma na fa kyer\u025b s\u025b nea \u025bkyer\u025b no y\u025b no. Basic algebra operation: Addition ( +) Subtraction ( - ) Multiplication ( *) Floor division ( \/\/) Exponentiation ( ** Example): operator['+', '*', '-'] array = [2, 3, 4, 5] result = 2 + 3 * 4 - 5 => result = 9 Hy\u025b no nsow: Operand no tenten y\u025b p\u025b s\u025b list a w\u0254de operand ka ho no tenten a w\u0254twe baako. Operand no y\u025b integers a \u025bny\u025b negative no nyinaa. Operator no w\u0254 operator baako, na list no nso w\u0254 operand mmienu.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"San k\u0254fa nne\u025bma a \u025bboro so w\u0254 din no mu.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Hwehw\u025b mp\u025bn dodow a substring bi w\u0254 mfitiase no mu. Hwehw\u025b ns\u025bm a \u025bboro so.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Kyer\u025bw adwuma a \u025bgye ntweaa a \u025bw\u0254 din din mu. Nkyer\u03b5kyer\u03b5mu no kura ns\u025bmfua ahorow. Fa as\u025bmfua no a ne nkyer\u025bwde dodow no ara y\u025b soronko no san. S\u025b ntweaa bebree w\u0254 nkyer\u025bwde dodow a \u025bsen biara a, fa nea edi kan w\u0254 nkyer\u025bwde mu no san.\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" S\u025bntire a w\u0254de ama no y\u025b palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Y\u025b adwuma bi a fa \u0254twease\u025b a egyina h\u0254 ma file din, na s\u025b \u0254twease\u025b no din y\u025b papa a, \u025bde 'Yiw' ma, na s\u025b \u025bnte saa a \u025bde 'Dabi' ma. S\u025b nea edidi so yi nyinaa ba a, \u025bno nkutoo na wobegye file din s\u025b \u025by\u025b papa: - \u0190ns\u025b s\u025b \u025bboro ntwer\u025bfua mmi\u025bnsa ('0'-'9') w\u0254 file no din mu. - File no din no mu no, \u025bkura dot baako p\u025b '.' - Substring a \u025bw\u0254 dot no anim no, \u025bns\u025b s\u025b \u025by\u025b hunu, na \u025bs\u025b s\u025b efi ase w\u0254 Latin nkyer\u025bwde alphapet ('a'-'z' ne 'A'-Z'). - Substring a \u025bw\u0254 dot no akyi no, \u025bs\u025b s\u025b \u025by\u025b nea edidi so yi mu baako: ['txt', 'exe', 'lld'] Mfatoho: file_name_check\"{example.txt.\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Hw\u025b s\u025b w\u0254 din a w\u0254de ato h\u0254 no mu no, s\u025b w\u0254fa din foforo bi a, \u025bb\u025bn ne ho sen nea w\u0254aka ho as\u025bm no.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    S\u025b w\u0254de positive integer n ma a, ma no nkyer\u025b n-digit positive integer a efi ase anaa ewie w\u0254 1 no dodow.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Fib4 a w'aka no y\u025b biribi a \u025bte s\u025b Fibbonacci a w'aka no s\u025b: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Y\u025bsr\u025b wo kyer\u025bw biribi a wode b\u025bte n-fa a \u025bw\u0254 fib4 a w'aka no mu.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    de ahy\u025bnsode a w\u0254de kyer\u025b no ase k\u0254ma no w\u0254 nkyer\u025bwde ahorow a \u025bw\u0254 af\u00e3 ahorow a emu biara y\u025b ahy\u025bnsode ahorow abi\u025bsa.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"San k\u0254fa nnum a \u025bw\u0254 din no mu no nkutoo.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    S\u025b w\u0254de 'text' ahoma ama a, fa n'ahoma md5 hash no ma no. S\u025b 'text' y\u025b ahoma hunu a, fa None ma no.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    Wama wo akontaahy\u025bde a \u025by\u025b papa n. \u0190s\u025b s\u025b woy\u025b akontaahy\u025bde a \u025bware n. A[y[ biara (1 \u2030\u00a4 i \u2030\u00a4 n), a[y[ a[y[ = i * i - i + 1. Fa a[y[ a[y[, a[j], a[k]) a a[y[ a[y[ a[y[ a[y[ a[y[ a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y[ a] a[y\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Saa adwuma yi fa akontabuo a \u025by\u025b papa x ne y na \u025bde akontabuo a \u025bkor\u0254n paa a \u025bgyina h\u0254 ma [x, y] a ne nyinaa ka ho no ma. S\u025b akontabuo a \u025bte saa nni h\u0254 a, \u025bnde \u025bs\u025b s\u025b adwuma no de -1. S\u025b nhw\u025bso: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    S\u025b wode \u0254kra a \u025bgyina h\u0254 ma no ma a, fa Roman numerals a \u025bne no y\u025b p\u025b s\u025b string, na fa no to h\u0254 ma no. Nhy\u025bso: 1 <= num <= 1000 Nhw\u025bso:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" De\u025b w\u0254de aba no y\u025b ns\u025bso a w\u0254de atwer\u025b a \u025bsi ns\u025bso\u0254 a \u025bsi ns\u025bso\u0254 k\u0254si ns\u025bso\u0254. Nkyer\u03b5kyer\u03b5mu a \u025bfata ne ns\u025bso\u0254, baako, mmienu, mmi\u025bnsa, anan, anum, nsia, nson, nw\u0254twe ne nkron. De ns\u025bso\u0254 a \u025bsi ns\u025bso\u0254 k\u0254si ak\u025bse\u025b no na \u025bsan ba.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Wob\u025bma wo ns\u025bmfua a \u025bw\u0254 h\u0254, na w'adwuma ne s\u025b wob\u025bkan ns\u025bmfua a \u025bhaw wo no. S\u025b as\u025bmfua a \u025bhaw wo y\u025b as\u025bmfua a efi ase \"me\". Ns\u025bmfua no mu no, w\u0254de '.', '?' anaa '!' na \u025btwa ho. S\u025b nhw\u025bso:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Saa adwuma yi mu no, nea \u025bw\u0254 mu ne s\u025b, \u0254f\u00e3 biara a \u025bw\u0254 mu no, \u0254f\u00e3 biara a \u025bw\u0254 mu no, w\u0254ayi no afi mu. Wo botae ne s\u025b wob\u025bpae saa akuw no mu ay\u025b no \u0254f\u00e3 biara na woayi w\u0254n mu no nyinaa.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Wob\u025bhu class (a string) din ne extensions. S\u025b w\u0254de extensions no b\u025bhy\u025b class no mu a, wob\u025bhu s\u025b: ma CAP ny\u025b nkyer\u025bwde ak\u025bse\u025b a \u025bw\u0254 extension no din mu, na ma SM ny\u025b nkyer\u025bwde nketewa a \u025bw\u0254 extension no din mu, na \u025bno na \u025bkyer\u025b s\u025bnea as\u025bmfua CAP - SM y\u025b den. \u0190s\u025b s\u025b wuhu className.StrongestExtensionName. S\u025b wow\u0254 extensions mmienu anaa nea \u025bboro saa a, \u025bs\u025b s\u025b wofa nea edi kan w\u0254 list no mu. S\u025b nhw\u025bso, s\u025b w\u0254de \"Slices\" ama wo s\u025b class ne extensions no din: ['SEviviRNGSliCes', 'Cheese', 'StuFfed'] a, \u025bs\u025b s\u025b wo san 'Slices.SEviRNGSliCes' na 'SviRNGSliCes' na \u025bkyer\u025b s\u025bnea \u025by\u025b den, efis\u025b extension no y\u025b strong\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Woama wo sika a wode b\u025btwe ne nea wode b\u025btwe w\u0254 bank account a ebedu no na ne nyinaa fi ase no. Wo adwuma ne s\u025b wob\u025bhu s\u025b bere bi mu no account no balance no so atew a, na saa bere no \u025bs\u025b s\u025b function no san true. S\u025b \u025bnte saa a \u025bs\u025b s\u025b san false.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"S\u025b wode \u0254f\u00e3 bi a \u025bkyer\u025b dua bi a \u025bw\u0254 ntini a \u025bnny\u025b negative w\u0254 h\u0254 a, wo adwuma ne s\u025b wob\u025byi ntini no baako na woayi no. S\u025b wohu ntini a \u025bboro so a \u025bkura akatua ketewaa bi a, fa nea \u025bkura akatua ketewaa bi no ma no. S\u025b wohu ntini a \u025bkura akatua ketewaa bi a, fa nea \u025bkura akatua ketewaa bi no ma no. S\u025b akatua ketewaa bi nni h\u0254 anaa nea w\u0254de ama no y\u025b hwee a, fa nea \u025bw\u0254 akatua ketewaa bi mu no ma no. Mfatoho 1: Akwankyer\u025b: [4,2,3] Akwankyer\u025b: [2, 1] Nkyer\u025bkyer\u025bmu: 2 y\u025b akatua ketewaa bi, na 2 y\u025b akatua ketewaa bi. Mfatoho 2: Akwankyer\u025b: [1,2,3] Akwankyer\u025b: [2, 1] Nkyer\u025bkyer\u025bmu: 2 y\u025b akatua ketewaa\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    S\u025b w\u0254de string s ma a, ka \u025bnne ak\u025bse\u025b a \u025bw\u0254 ntwer\u025be\u025b a emu y\u025b p\u025b mu. S\u025b nhw\u025bso: count_upper (('aBCdEf') de 1 count_upper (('abcdefg') de 0 count_upper (('dBBE') de 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"\u062a\u0637\u0628\u064a\u0642 \u062f\u0627\u0644\u0629 \u0643\u062a\u0623\u062e\u0630 \u0631\u0642\u0645 \u0635\u062d\u064a\u062d \u063a\u064a\u0631 \u0633\u0644\u0628\u064a \u0648\u062a\u0631\u062c\u0639 \u0635\u0641 \u0645\u0646 \u0623\u0648\u0644 n \u0623\u0631\u0642\u0627\u0645 \u0635\u062d\u064a\u062d\u0629 \u0647\u064a \u0623\u0631\u0642\u0627\u0645 \u0623\u0648\u0644\u064a\u0629 \u0648\u0623\u0642\u0644 \u0645\u0646 n. \u0639\u0644\u0649 \u0633\u0628\u064a\u0644 \u0627\u0644\u0645\u062b\u0627\u0644: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib \u064a\u0639\u064a\u062f \u0627\u0644\u0631\u0642\u0645 n-th \u0648\u0647\u0648 \u0631\u0642\u0645 \u0641\u064a\u0628\u0648\u0646\u0627\u062a\u0634\u064a \u0648\u0647\u0648 \u0623\u064a\u0636\u0627\u064b \u0639\u062f\u062f \u0623\u0648\u0644\u064a.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n \u0647\u064a \u062f\u0627\u0644\u0629 \u062a\u062c\u0645\u0639 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0645\u0646 1 \u0625\u0644\u0649 n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" \u0628\u0627\u0644\u0646\u0633\u0628\u0629 \u0644\u0639\u062f\u062f \u0645\u0639\u064a\u0646 n\u060c \u0627\u0639\u062b\u0631 \u0639\u0644\u0649 \u0623\u0643\u0628\u0631 \u0639\u062f\u062f \u064a\u0642\u0633\u0645 n \u0628\u0627\u0644\u062a\u0633\u0627\u0648\u064a\u060c \u0623\u0635\u063a\u0631 \u0645\u0646 n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" \u062a\u0635\u0641\u064a\u0629 \u0642\u0627\u0626\u0645\u0629 \u0627\u0644\u0633\u0644\u0627\u0633\u0644 \u0627\u0644\u0644\u064a \u0641\u064a\u0647\u0627 \u0648\u0627\u062d\u062f \u0627\u0644\u0633\u0644\u0627\u0633\u0644 \u0627\u0644\u0641\u0631\u0639\u064a\u0629\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    \u0648\u0628\u0627\u0644\u062d\u0627\u062c\u0629 \u0644\u0644\u064a \u0643\u0627\u064a\u0639\u0637\u064a \u0644\u064a\u0643 \u0634\u064a \u0635\u0641 \u0645\u0646 \u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629\u060c \u062e\u0627\u0635\u0643 \u062a\u0641\u0631\u0632 \u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629 \u0627\u0644\u0644\u064a \u0628\u064a\u0646 1 \u0648 9\u060c \u0648 \u062a\u063a\u064a\u0631 \u0627\u0644\u0645\u0635\u0641 \u0627\u0644\u0646\u0627\u062a\u062c\u060c \u0648 \u0645\u0646 \u0628\u0639\u062f \u062a\u0628\u062f\u0644 \u0643\u0644 \u0631\u0642\u0645 \u0628\u0627\u0633\u0645\u0647\u0627 \u0627\u0644\u0645\u0642\u0627\u0628\u0644 \u0645\u0646 \"\u0648\u0627\u062d\u062f\"\u060c \"\u0627\u062b\u0646\u064a\u0646\"\u060c \"\u062b\u0644\u0627\u062b\u0629\"\u060c \"\u0623\u0631\u0628\u0639\u0629\"\u060c \"\u062e\u0645\u0633\u0629\"\u060c \"\u0633\u062a\u0629\"\u060c \"\u0633\u0628\u0639\u0629\"\u060c \"\u062b\u0645\u0627\u0646\u064a\u0629\"\u060c \"\u062a\u0633\u0639\u0629\". \u0639\u0644\u0649 \u0633\u0628\u064a\u0644 \u0627\u0644\u0645\u062b\u0627\u0644: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> \u062a\u0631\u062a\u064a\u0628 arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> \u0627\u0644\u0631\u062f arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"\u062a\u0645\u0627\u0646\u064a\u0629\"\u060c \"\u062e\u0645\u0633\u0629\"\u060c \"\u062b\u0644\u0627\u062b\u0629\"\u060c \"\u0627\u062b\u0646\u064a\u0646\"\u060c \"\u062a\u0646\u064a\u0646\"\u060c \"\u0648\u0627\u062d\u062f\"\u060c \"\u0648\u0627\u062d\u062f\"] \u0625\u0630\u0627 \u0643\u0627\u0646 \u0627\u0644\u0645\u0635\u0641 \u0641\u0627\u0631\u063a\u060c \u064a\u0631\u062c\u0639 \u0635\u0641 \u0641\u0627\u0631\u063a: arr = [] return [] \u0625\u0630\u0627\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    \u062a\u0644\u0642\u064a\u062a \u0635\u0641 \u0635\u0641\u0648\u0641 \u0645\u0646 \u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629 \u0648 \u062e\u0627\u0635\u0643 \u062a\u062e\u0644\u0635 \u0645\u062c\u0645\u0648\u0639 \u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629 \u0645\u0636\u0631\u0648\u0628\u0629 \u0641\u064a \u0646\u0627\u062a\u062c \u0643\u0644 \u0639\u0644\u0627\u0645\u0627\u062a \u0644\u0643\u0644 \u0631\u0642\u0645 \u0641\u064a \u0627\u0644\u0645\u0635\u0641\u0648\u0641\u0629\u060c \u0645\u0645\u062b\u0644\u0629 \u0628 1\u060c -1 \u0623\u0648 0. \u0645\u0644\u0627\u062d\u0638\u0629: \u0644\u0627 \u062a\u0642\u062f\u0631 \u062a\u062e\u0644\u0635 \u0623\u064a \u0635\u0641\u0648\u0641 \u0644\u0635\u0641\u0648\u0641 \u0641\u0627\u0631\u063a\u0629.\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    \u064a\u0645\u0643\u0646 \u0644\u064a\u0643 \u062a\u0628\u062f\u0623 \u0645\u0646 \u0623\u064a \u062e\u0644\u064a\u0629\u060c \u0648 \u0641\u064a \u0643\u0644 \u062e\u0637\u0648\u0629 \u064a\u0645\u0643\u0646 \u0644\u064a\u0643 \u062a\u062a\u062d\u0631\u0643 \u0644\u0634\u064a \u062e\u0644\u0627\u064a\u0627 \u062c\u064a\u0631\u0627\u0646\u060c \u0648 \u0628\u0645\u0639\u0646\u0649 \u0622\u062e\u0631\u060c \u064a\u0645\u0643\u0646 \u0644\u064a\u0643 \u062a\u062a\u062d\u0631\u0643 \u0644\u0634\u064a \u062e\u0644\u0627\u064a\u0627 \u0643\u0627\u064a\u0643\u0648\u0646 \u0644\u064a\u0647\u0627 \u062d\u0627\u0641\u0629. \u0644\u0627 \u064a\u0645\u0643\u0646 \u0644\u064a\u0643 \u062a\u062a\u062d\u0631\u0643 \u062e\u0627\u0631\u062c \u0645\u0646 \u0627\u0644\u062e\u0644\u064a\u0629. \u064a\u0645\u0643\u0646 \u0644\u0634\u064a \u062e\u0644\u0627\u064a\u0627 A (\u0645\u0646 \u0637\u0648\u0644 k) \u062a\u062a\u0645\u062b\u0644 \u0641\u064a \u0623\u0642\u0644 \u0645\u0646 \u062e\u0644\u0627\u064a\u0627 B (\u0645\u0646 \u0637\u0648\u0644 k) \u0625\u0630\u0627 \u0628\u0639\u062f \u0645\u0627 \u062a\u0635\u0646\u0639 \u0627\u0644\u0642\u0648\u0627\u0626\u0645 \u0627\u0644\u0645\u0631\u062a\u0628\u0629 \u0644\u0644\u0642\u064a\u0645 \u0639\u0644\u0649 \u0627\u0644\u062e\u0644\u0627\u064a\u0627 A \u0648 B (\u0644\u0646\u062c\u0645 \u0646\u0633\u0645\u064a\u0647\u0627 l_stA \u0648 l_stB) \u060c \u0641\u0647\u064a \u0623\u0642\u0644 \u0645\u0646 \u0627\u0644\u062e\u0644\u0627\u064a\u0627 l_stA \u0645\u0646 \u0627\u0644\u0646\u0627\u062d\u064a\u0629 \u0627\u0644\u0644\u0643\u0633\u064a\u063a\u0631\u0627\u0641\u064a\u0629\u060c \u0648 \u0628\u0645\u0639\u0646\u0649 \u0622\u062e\u0631\u060c \u0641\u0647\u064a \u0623\u0642\u0644 \u0645\u0646 \u0627\u0644\u062e\u0644\u0627\u064a\u0627 l_stB\u060c \u0648 \u0628\u0644\u0645\u0639\u0646\u0649 \u0622\u062e\u0631\u060c \u0641\u0647\u064a \u062e\u0644\u0627\u064a\u0627 \u0643\u0627\u064a\u0643\u0648\u0646 \u0644\u064a\u0647\u0627 \u062d\u0627\u0641\u0629 \u0645\u0639 \u062e\u0644\u0627\u064a\u0627\u0643 \u0627\u0644\u062d\u0627\u0644\u064a\u0629. [\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"\u0639\u0627\u0648\u062f \u0628\u0627\u0644\u0639\u0646\u0627\u0635\u0631 \u0627\u0644\u0645\u0641\u0631\u062f\u0629 \u0627\u0644\u0645\u0641\u0631\u0642\u0629 \u0641\u064a \u0627\u0644\u0642\u0627\u0626\u0645\u0629\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    \u063a\u064a \u062a\u062a\u0627\u0648\u0644\u0643 \u0633\u0644\u0633\u0644\u0629 \u0645\u0646 \u0627\u0644\u0643\u0644\u0645\u0627\u062a \u0645\u0641\u0635\u0648\u0644\u0629 \u0628\u0627\u0644\u0641\u0648\u0627\u0635\u0644 \u0623\u0648 \u0627\u0644\u0641\u0631\u0627\u063a\u0627\u062a. \u0648\u0627\u062c\u0628\u0643 \u0647\u0648 \u062a\u0642\u0633\u064a\u0645 \u0627\u0644\u0633\u0644\u0633\u0644\u0629 \u0639\u0644\u0649 \u0643\u0644\u0645\u0627\u062a \u0648\u0625\u0631\u062c\u0627\u0639 \u0645\u062c\u0645\u0648\u0639\u0629 \u0645\u0646 \u0627\u0644\u0643\u0644\u0645\u0627\u062a. \u0639\u0644\u0649 \u0633\u0628\u064a\u0644 \u0627\u0644\u0645\u062b\u0627\u0644: words_string (((\"\u0633\u0644\u0627\u060c \u0627\u0633\u0645\u064a \u062c\u0648\u0646\") == [\"\u0633\u0644\u0627\"\u060c \"\u0633\u0645\u0627\"\u060c \"\u0627\u0633\u0645\u064a\"\u060c \"\u0647\u0648\"\u060c \"\u062c\u0648\u0646\"] words_string (((\"\u0648\u0627\u062d\u062f\u060c \u062c\u0648\u062c\u060c \u062a\u0644\u0627\u062a\u0629\u060c \u0631\u0628\u0639\u0629\u060c \u062e\u0645\u0633\u0629\u060c \u0633\u062a\u0629\") == [\"\u0648\u0627\u062d\u062f\"\u060c \"\u062c\u0648\u062c\"\u060c \"\u062a\u0644\u0627\u062a\u0629\"\u060c \"\u0631\u0628\u0639\u0629\"\u060c \"\u062e\u0645\u0633\u0629\"\u060c \"\u0633\u062a\u0629\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" \u0628\u0627\u0644\u0646\u0633\u0628\u0629 \u0644\u0633\u0644\u0633\u0644\u0629 \u0645\u0639\u064a\u0646\u0629\u060c \u062d\u0648\u0644 \u0627\u0644\u062d\u0631\u0648\u0641 \u0627\u0644\u0635\u063a\u064a\u0631\u0629 \u0644\u0644\u0643\u0628\u064a\u0631\u0629 \u0648\u0627\u0644\u0643\u0628\u064a\u0631\u0629 \u0644\u0644\u0643\u0628\u064a\u0631\u0629.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"\u0643\u062a\u0628 \u062f\u0627\u0644\u0629 \u062a\u0631\u062c\u0639 \u0627\u0644\u0635\u0627\u062f\u0642 \u0625\u0630\u0627 \u0643\u0627\u0646 \u0627\u0644\u0631\u0642\u0645 \u0627\u0644\u0645\u0639\u0637\u0649 \u0636\u0631\u0628 \u0644 3 \u0623\u0631\u0642\u0627\u0645 \u0623\u0648\u0644\u064a\u0629 \u0648 \u0643\u0627\u0630\u0628\u0629 \u0625\u0644\u0627. \u0645\u0639 \u0627\u0644\u0639\u0644\u0645 \u0628\u0644\u064a (\u0623) \u0623\u0642\u0644 \u0645\u0646 100.\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    \u062a\u0642\u064a\u064a\u0645 \u0645\u062a\u0639\u062f\u062f \u0627\u0644\u062d\u062f\u0648\u062f \u0645\u0639 \u0645\u0639\u0627\u0645\u0644 xs \u0641\u064a \u0627\u0644\u0646\u0642\u0637\u0629 x. \u0627\u0644\u0639\u0648\u062f\u0629 xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"\u062a\u0644\u0642\u064a\u062a \u0642\u0627\u0626\u0645\u0629 \u0645\u0646 \u0627\u0644\u0623\u0631\u0642\u0627\u0645. \u062e\u0627\u0635\u0643 \u062a\u062e\u0644\u0635 \u0645\u0646 \u0645\u062c\u0645\u0648\u0639 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0627\u0644\u0645\u0631\u0628\u0639\u0629 \u0641\u064a \u0627\u0644\u0642\u0627\u0626\u0645\u0629\u060c \u0648\u062a\u0631\u0642\u064a\u0645 \u0643\u0644 \u0639\u0646\u0635\u0631 \u0641\u064a \u0627\u0644\u0642\u0627\u0626\u0645\u0629 \u0639\u0644\u0649 \u0627\u0644\u0639\u062f\u062f \u0627\u0644\u0641\u0648\u0642\u064a. \u0645\u062b\u0627\u0644: \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644 \u0644\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"\u0639\u0646\u062f \u0625\u0639\u0637\u0627\u0621 \u0639\u062f\u062f \u0635\u062d\u064a\u062d \u0625\u064a\u062c\u0627\u0628\u064a N\u060c \u0627\u0631\u062c\u0639 \u0645\u062c\u0645\u0648\u0639 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0641\u064a \u0627\u0644\u0646\u0645\u0648\u0630\u062c \u0627\u0644\u062b\u0646\u0627\u0626\u064a. \u0645\u062b\u0627\u0644 \u0639\u0644\u0649 N = 1000\u060c \u0645\u062c\u0645\u0648\u0639 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0633\u064a\u0643\u0648\u0646 1\u060c \u0627\u0644\u0645\u062e\u0631\u062c \u064a\u062c\u0628 \u0623\u0646 \u064a\u0643\u0648\u0646 \"1\". \u0639\u0644\u0649 N = 150\u060c \u0645\u062c\u0645\u0648\u0639 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0633\u064a\u0643\u0648\u0646 6\u060c \u0627\u0644\u0645\u062e\u0631\u062c \u064a\u062c\u0628 \u0623\u0646 \u064a\u0643\u0648\u0646 \"110\". \u0639\u0644\u0649 N = 147, \u0645\u062c\u0645\u0648\u0639 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0633\u064a\u0643\u0648\u0646 12\u060c \u0627\u0644\u0645\u062e\u0631\u062c \u064a\u062c\u0628 \u0623\u0646 \u064a\u0643\u0648\u0646 \"1100\". \u0645\u062a\u063a\u064a\u0631\u0627\u062a: @N \u0639\u062f\u062f \u0635\u062d\u064a\u062d \u0642\u064a\u0648\u062f: 0 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10000. \u0627\u0644\u0645\u062e\u0631\u062c: \u0633\u0644\u0633\u0644\u0629 \u0645\u0646 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0627\u0644\u062b\u0646\u0627\u0626\u064a\u0629\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"\u064a\u0639\u064a\u062f \u0627\u0644\u0639\u0646\u0627\u0635\u0631 \u0627\u0644\u0645\u0634\u062a\u0631\u0643\u0629 \u0627\u0644\u0641\u0631\u064a\u062f\u0629 \u0627\u0644\u0645\u0631\u062a\u0628\u0629 \u0644\u0644\u064a\u0633\u062a\u064a\u0646.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"\u064a\u0639\u064a\u062f \u0627\u0644\u062d\u062f \u0627\u0644\u0623\u0642\u0635\u0649 \u0644\u0644\u064a\u0644\u064a \u064a\u0645\u0643\u0646 \u0644\u0644\u064a\u0644\u064a \u0645\u0648\u062c\u0648\u062f \u0641\u064a \u0627\u0644\u0642\u0627\u0626\u0645\u0629.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"\u0643\u0627\u064a\u0628\u0627\u0646 \u0644\u064a\u0643 \u0634\u064a \u0634\u064a \u0634\u064a\u0631\u0648\u0642 \u062f\u064a\u0627\u0644 \u0627\u0644\u0646\u062a\u0627\u0626\u062c \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648 \u0627\u0644\u0627\u062e\u062a\u0628\u0627\u0631\u0627\u062a \u0648\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"\u0627\u0631\u062c\u0639 \u0631\u0642\u0645 \u0641\u064a\u0628\u0648\u0646\u0627\u062a\u0634\u064a \u0627\u0644\u062a\u0627\u0633\u0639.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"\u0627\u0631\u062c\u0639 \u0623\u0643\u0628\u0631 \u0639\u0627\u0645\u0644 \u0623\u0648\u0644\u064a \u0644\u0640 n. \u0627\u0641\u062a\u0631\u0636 \u0623\u0646 n > 1 \u0648\u0644\u064a\u0633 \u0623\u0648\u0644\u064a.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    \u4f60\u4fc2\u4e00\u500b\u9913,\u5df2\u7d93\u98df\u5497\u4e00\u5b9a\u6578\u5605\u80e1\u535c,\u4f46\u4f60\u9700\u8981\u591a\u5572\u80e1\u535c\u53bb\u5b8c\u6210\u4e00\u65e5\u5605\u98df\u7269.\u4f60\u61c9\u8a72\u8fd4\u4e00\u500b\u6578\u5217 [ \u5403\u5b8c\u5b8c\u5b8c\u98df\u5f8c\u5605\u80e1\u535c\u7e3d\u6578,\u98df\u5b8c\u98df\u5f8c\u5269\u8fd4\u5605\u80e1\u535c\u6578 ] \u5982\u679c\u5269\u8fd4\u5605\u80e1\u535c\u5514\u5920,\u4f60\u5c31\u6703\u98df\u66ec\u5269\u9918\u5605\u80e1\u535c,\u4f46\u4f60\u4f9d\u7136\u6703\u9913. \u4f8b: * eat(5, 6, 10) -> [11, 4] * eat(4, 8, 9) -> [12, 1] * eat(1, 10, 10) -> [11, 0] * eat(2, 11, 5) -> [7, 0] \u8b8a\u91cf: @number: \u6574\u6578: \u4f60\u5df2\u7d93\u98df\u5497\u5605\u80e1\u535c\u6578. @need:: \u6574\u6578: \u4f60\u9700\u8981\u98df\u5605\u80e1\u535c\u6578. @remaining:: \u6574\u6578: \u5269\u9918\u5605\u80e1\u535c\u6578. Constrain: * 0\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" \u8fd4\u56de\u5305\u542b\u75310\u5230n\u5305\u542b\u7684\u7a7a\u95f4\u5212\u5206\u7684\u6570\u5217.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f,\u5982\u679cn\u662f\u4e2a\u7d20\u6570,\u5b83\u5e94\u8be5\u8fd4\u56dex\u7684\u503c,\u5426\u5219\u5219\u5e94\u8be5\u8fd4\u56dey\u7684\u503c.\u4f8b\u5982:\u5bf9\u4e8ex_or_y{7, 34, 12) == 34\u5bf9\u4e8ex_or_y{15, 8, 5) == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    \u7ed9\u5b9a\u4e00\u7ec4\u975e\u8d1f\u6570\u6574\u6570,\u6392\u5e8f\u540e\u8fd4\u56de\u7ed9\u5b9a\u7684\u6570\u7ec4\u7684\u526f\u672c,\u5982\u679c\u548c (\u7b2c\u4e00\u7d22\u5f15\u503c,\u6700\u540e\u7d22\u5f15\u503c) \u662f\u5947\u6570,\u4f60\u4f1a\u4ee5\u4e0a\u5347\u987a\u5e8f\u6392\u5e8f\u7ed9\u5b9a\u7684\u6570\u7ec4,\u6216\u8005\u5982\u679c\u548c (\u7b2c\u4e00\u7d22\u5f15\u503c,\u6700\u540e\u7d22\u5f15\u503c) \u662f\u5076\u6570,\u5219\u4ee5\u4e0b\u964d\u987a\u5e8f\u6392\u5e8f. \u6ce8\u610f: *\u4e0d\u8981\u6539\u53d8\u7ed9\u5b9a\u7684\u6570\u7ec4. \u4f8b: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \u5bf9\u4e8e\u7ed9\u5b9a\u7684\u8f93\u5165\u6570\u5217\u8868,\u8ba1\u7b97\u8fd9\u4e2a\u6570\u636e\u96c6\u7684\u5e73\u5747\u503c\u5468\u56f4\u7684\u5e73\u5747\u7edd\u5bf9\u504f\u5dee.\u5e73\u5747\u7edd\u5bf9\u504f\u5dee\u662f\u6bcf\u4e2a\u5143\u7d20\u4e0e\u4e2d\u5fc3\u70b9 (\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u7684\u5e73\u5747\u503c) \u4e4b\u95f4\u7684\u5e73\u5747\u7edd\u5bf9\u5dee\u5f02:MAD =\u5e73\u5747\u503c.x - x_mean. \u4f8b:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    \u5728\u8fd9\u4e2a\u4efb\u52a1\u4e2d,\u4f60\u4f1a\u5f97\u5230\u4e00\u4e2a\u5b57\u7b26\u4e32,\u8868\u793a\u4e00\u4e2a\u6570\u91cf\u7684\u679c\u548c\u5b50,\u8fd9\u4e9b\u679c\u5206\u5e03\u5728\u4e00\u4e2a\u6c34\u679c\u7bee\u5b50\u91cc.\u8fd9\u4e2a\u7bee\u5b50\u91cc\u6709\u679c,\u5b50\u548c\u679c\u679c.\u7ed9\u51fa\u4ee3\u8868\u679c\u548c\u679c\u7684\u603b\u6570\u7684\u5b57\u7b26\u4e32\u548c\u4ee3\u8868\u7bee\u5b50\u91cc\u6c34\u679c\u603b\u6570\u7684\u6574\u6570,\u8fd4\u56de\u7bee\u5b50\u91cc\u679c\u7684\u6570\u91cf.\u4f8b\u5982: fruit_distribution\"5(\u679c\u548c6\u4e2a\u5b50\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0\u679c\u548c1\u4e2a\u5b50\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2\u679c\u548c3\u4e2a\u5b50\",100) -> 100 - 2 - 3 = 95 fruit_distribution\"100\u679c\u548c120) \",1 -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" \u5728\u6bcf\u4e24\u4e2a\u8fde\u7eed\u7684\u8f93\u5165\u5217\u8868\u5143\u7d20\u4e4b\u95f4\u63d2\u5165\u4e00\u4e2a\"\u5206\u754c\u7b26\"\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" \u5165\u529b\u4fc2\u5169\u500b\u5b57\u7b26\u4e32 a \u540c b \u53ea\u5305\u542b 1 \u540c 0.\u55ba\u5462\u5572\u8f38\u5165\u5605\u5b57\u7b26\u4e32\u4e0a\u57f7\u884c\u4e8c\u9032\u5236 XOR,\u4e26\u5c07\u7d50\u679c\u8fd4\u56de\u5b57\u7b26\u4e32.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    \u7ed9\u5b9a\u4e00\u7ec4\u6574\u6570,\u6c42\u51fa\u9700\u8981\u66f4\u6539\u7684\u5143\u7d20\u7684\u6700\u5c0f\u6570\u91cf,\u4f7f\u5f97\u8be5\u6570\u7ec4\u6210\u4e3a\u5e73\u884c\u5217.\u5e73\u884c\u5217\u662f\u5411\u540e\u548c\u5411\u524d\u8bfb\u53d6\u76f8\u540c\u7684\u6570\u7ec4.\u5728\u4e00\u6b21\u66f4\u6539\u4e2d,\u4f60\u53ef\u4ee5\u5c06\u4e00\u4e2a\u5143\u7d20\u66f4\u6539\u4e3a\u4efb\u4f55\u5176\u4ed6\u5143\u7d20.\u4f8b\u5982: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1,2,3,4,3,2,2]) == 1 smallest_change (([1,2,3,2,1,2,2,1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    \u55ba\u5462\u500b Kata \u4e2d,\u4f60\u5fc5\u9808\u6839\u64da\u4e8c\u9032\u5236\u8868\u793a\u5605 1 \u6578\u6392\u5e8f\u4e00\u500b\u6578\u5217\u5605\u975e\u8ca0\u6574\u6578.\u985e\u4f3c\u5605 1 \u6578,\u8981\u6839\u64da\u5341\u9032\u5236\u6578\u503c\u6392\u5e8f.\u4f62\u5fc5\u9808\u4fc2\u5481\u57f7\u884c:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" \u5165\u529b\u662f\u7531\"\u96f6\"\u5230\"\u4e5d\"\u7684\u6578\u5b57\u5b57\u4e32. \u6709\u6548\u9078\u64c7\u662f\"\u96f6\"\",\u4e00\"\",\u4e8c\"\",\u4e09\"\",\u56db\"\",\u4e94\"\",\u516d\"\",\u4e03\"\",\u516b\"\u548c\"\u4e5d\". \u8fd4\u56de\u5f9e\u6700\u5c0f\u5230\u6700\u5927\u6392\u5e8f\u6578\u5b57\u4e32\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"\u8f49\u63db\u6574\u6578 x \u8f49\u63db\u6210\u4e00\u500b\u5713,\u8f49\u63db\u6210\u53f3\u8f49\u63db\u6210\u4e00\u500b\u5b57\u7b26\u4e32.\u5982\u679c\u8f49\u63db > \u6578\u5b57\u6578,\u8fd4\u56de\u6578\u5b57\u6578\u5b57\u53cd\u8f49.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"\u4f60\u6709\u5169\u500b\u6b63\u6574\u6578 n \u548c m,\u4f60\u7684\u4efb\u52d9\u662f\u8a08\u7b97\u5f9e n \u5230 m (\u5305\u62ec n \u548c m) \u7684\u6574\u6578\u7684\u5e73\u5747\u6578.\u5c07\u7b54\u6848\u5713\u5230\u6700\u8fd1\u7684\u6574\u6578,\u7136\u5f8c\u5c07\u5176\u8f49\u63db\u70ba\u4e8c\u9032\u5236.\u5982\u679c n \u5927\u65bc m,\u8fd4\u56de -1. \u4f8b: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b1111\" rounded_avg ((20, 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    \u8fd4\u56de\u4e00\u500b\u7531\u4e09\u500b\u5b57\u7b26\u7d44\u6210\u5605\u7de8\u78bc\u5b57\u7b26\u4e32.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \u6aa2\u67e5\u4e00\u4e0b\u4fc2\u54aa\u6709\u5169\u500b\u6578\u5b57\u4fc2\u6bd4\u6578\u503c\u66f4\u8fd1\u5605\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    \u4f60\u5f97\u5230\u4e00\u500b\u4ee3\u8868\u53e5\u5b50\u5605\u5b57\u4e32,\u53e5\u5b50\u5305\u542b\u5e7e\u500b\u7528\u7a7a\u683c\u9694\u958b\u5605\u55ae\u8a5e,\u4f60\u5fc5\u9808\u8fd4\u56de\u4e00\u500b\u5305\u542b\u539f\u53e5\u5b50\u5605\u55ae\u8a5e\u5605\u5b57\u4e32,\u5176\u9577\u5ea6\u4fc2\u7d20\u6578,\u65b0\u5b57\u4e32\u5605\u55ae\u8a5e\u6392\u5e8f\u61c9\u8a72\u4fc2\u540c\u539f\u53e5\u5b50\u4e00\u6a23\u5605. Example1: Input: sentence = \"This is a test\" Output: \"is\" Example2: Input: sentence = \"let go for swimming\" Output: \"go for\" \u9650\u5236: * 1 <= len(sentence) <= 100 *\u53e5\u5b50\u53ea\u5305\u542b\u5b57\u6bcd\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"\u6211\u8ad7\u5927\u5bb6\u90fd\u8a18\u5f97\u7576\u4f60\u7d42\u65bc\u77e5\u9053\u67d0\u500b\u9577\u671f\u7b49\u5f85\u5605\u4e8b\u4ef6\u5605\u7d50\u679c\u6642\u5605\u611f\u89ba. \u4f60\u55f0\u4e00\u523b\u5605\u611f\u89ba\u540c\u60f3\u6cd5\u7d55\u5c0d\u503c\u5f97\u8a18\u9304\u540c\u57cb\u6bd4\u8f03. \u4f60\u5605\u4efb\u52d9\u4fc2\u6c7a\u5b9a\u4e00\u500b\u4eba\u4fc2\u54aa\u6b63\u78ba\u5730\u731c\u51fa\u4e00\u7cfb\u5217\u6bd4\u8cfd\u5605\u7d50\u679c. \u4f60\u4ffe\u5497\u5169\u500b\u7b49\u9577\u5ea6\u5605\u5206\u6578\u540c\u57cb\u731c\u6e2c\u5605\u6578\u5217,\u6bcf\u500b\u7d22\u5f15\u90fd\u986f\u793a\u4e00\u500b\u6bd4\u8cfd. \u8fd4\u56de\u4e00\u7d44\u540c\u6a23\u9577\u5ea6\u5605\u6578\u5217,\u8868\u793a\u6bcf\u4e00\u500b\u731c\u6e2c\u5605\u5dee\u8ddd. \u5982\u679c\u4f62\u54cb\u731c\u5f97\u5571,\u500b\u6578\u503c\u4fc20,\u5982\u679c\u5514\u4fc2,\u500b\u6578\u503c\u5c31\u4fc2\u731c\u6e2c\u540c\u5206\u6578\u4e4b\u9593\u5605\u7d55\u5c0d\u5dee\u7570. \u4f8b\u5982: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare ((([0,5,0,4,0,1,0,4]]) -> [4,4,0,1,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"\u5462\u500b\u51fd\u6578\u6703\u53d6\u4e00\u500b\u5217\u8868 l,\u4e26\u8fd4\u56de\u4e00\u500b\u5217\u8868 l',\u4f7f\u5f97\u5728\u4e0d\u80fd\u88ab\u4e09\u9664\u7684\u6307\u6a19\u4e2d,l' \u540c l\u76f8\u540c,\u800c\u5728\u53ef\u4ee5\u88ab\u4e09\u9664\u7684\u6307\u6a19\u4e2d,l \u7684\u503c\u7b49\u65bc\u5c0d\u61c9\u7684 l \u6307\u6578\u7684\u503c,\u4f46\u5df2\u88ab\u6392\u5e8f.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" \u9664\u4efb\u4f55python\u503c\u7684\u7ed9\u5b9a\u5217\u8868,\u53ea\u5bf9\u6574\u6570\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" \u55ae\u7d14\u4ee5\u4e00\u500b\u5148\u982d\u958b\u59cb\u5605\u5b57\u7b26\u4e32\u4f86\u904e\u6ffe\u8f38\u5165\u4e32\u5605\u5217\u8868.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" \u8fd4\u56de\u7ed9\u5b9a\u7684\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"\u5beb\u4e00\u500b\u51fd\u6578,\u63a5\u53d7\u4e00\u500b\u5b57\u7b26\u4e32\u5217\u8868. \u5217\u8868\u5305\u542b\u4e0d\u540c\u55ae\u8a5e.\u8fd4\u56de\u6700\u591a\u7368\u4e00\u7121\u4e8c\u5b57\u7b26\u6578\u5b57\u7684\u55ae\u8a5e. \u5982\u679c\u591a\u500b\u5b57\u7b26\u4e32\u6709\u6700\u591a\u7368\u4e00\u7121\u4e8c\u5b57\u7b26\u6578\u5b57,\u8fd4\u56de\u7b2c\u4e00\u500b\u55ae\u8a5e\u9806\u5e8f. find_max (([\"name\"\",of\"\",string\"]) == \"string\" find_max (([\"name\"\",enam\"\",game\"]) == \"enam\" find_max (([\"aaaaaaa\"\",bb\"\",cc\"]) == \"\"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Return True \u8fd4\u56de list \u5143\u7d20\u662f\u55ae\u8abf\u5730\u589e\u52a0\u6216\u6e1b\u5c11.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    \u101e\u1004\u103a\u101d\u1083\u1088 \u101c\u1086\u1088\u1015\u107c\u103a string 'text' \u107c\u1086\u1078\u102d\u102f\u1004\u103a \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a md5 hash equivalent string \u1019\u107c\u103a\u1038\u107c\u107c\u103a\u1089\u101e\u1031 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a None\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1015\u107c\u103a\u101d\u1086\u1089\u107c\u107c\u103a\u1089 \u1015\u1035\u107c\u103a\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1010\u1035\u1019\u103a \u1022\u107c\u103a\u1010\u1035\u1019\u103a\u1011\u1030\u107c\u103a\u1088 n \u101a\u101d\u103a\u1089\u104b \u1010\u1031\u101c\u1086\u1088\u1081\u1035\u1010\u103a\u1038 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1010\u1035\u1019\u103a\u1011\u1030\u107c\u103a\u1088 \u1022\u107c\u103a\u1010\u1035\u1019\u103a\u1011\u1030\u107c\u103a\u1088 a \u1022\u107c\u103a\u1019\u102e\u1038\u1010\u1062\u1004\u103a\u1038\u101a\u1062\u101d\u103a\u1038 n \u107c\u107c\u103a\u1089\u101a\u1030\u1087\u101a\u101d\u103a\u1089\u104b \u1010\u103d\u107c\u103a\u1088\u1010\u1083\u1087 i (1 \u2030\u00a4 i \u2030\u00a4 n) \u1075\u1030\u1088\u1022\u107c\u103a\u107c\u107c\u103a\u1089 \u1075\u1083\u1088\u1076\u107c\u103a a[i] = i * i - i + 1 \u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1015\u107c\u103a \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1015\u1035\u107c\u103a \u101e\u1062\u1019\u103a\u1022\u107c\u103a (a[i], a[j], a[k]) \u1076\u103d\u1004\u103a a \u1010\u102e\u1088\u1022\u107c\u103a i < j < k \u101c\u1084\u1088 a[i] + a[j] + a[k] \u107c\u1086\u1089\u1015\u1035\u107c\u103a \u1010\u1030\u101d\u103a\u107c\u1019\u103a\u1076\u103d\u1004\u103a 3 \u107c\u107c\u103a\u1089\u101a\u1030\u1087\u101a\u101d\u103a\u1089\u104b \u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u1087: Input: n = 5 Output: 1 \u1076\u1031\u1083\u1088\u101e\u1015\u103a\u1038\u101c\u1085\u1004\u103a\u1038: a = [1, 3, 7, 13, 21] \u1022\u107c\u103a\u1010\u1035\u1019\u103a\u1011\u1030\u107c\u103a\u1088\u1022\u107c\u103a\u101c\u1035\u101d\u103a\u107c\u1086\u1089 \u1015\u1035\u107c\u103a (1, 7, 13) \u107c\u107c\u103a\u1089\u101a\u101d\u103a\u1089\u104b\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 FibFib \u107c\u1086\u1089 \u1019\u107c\u103a\u1038\u1019\u102d\u1030\u107c\u103a\u1075\u107c\u103a\u1010\u1004\u103a\u1038 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 Fibbonacci \u1022\u107c\u103a\u1019\u1075\u103a\u1038\u1019\u107c\u103a\u1088\u101d\u1086\u1089\u107c\u1004\u103a\u1087\u107c\u1086: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3 \u1076\u1085\u107c\u103a\u1038\u1010\u1031\u1083\u1088 \u1010\u1085\u1019\u103a\u1088\u1015\u107c\u103a \u1010\u1030\u101d\u103a\u1022\u102d\u1004\u103a \u1010\u1083\u1087\u1010\u1031\u107c\u1015\u103a\u1089\u101e\u103d\u107c\u103a\u1087 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 n-th \u1076\u103d\u1004\u103a \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 fibfib \u107c\u107c\u103a\u1089\u1076\u1083\u1088\u101c\u1084\u1088\u104b\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" \u1010\u103d\u107c\u103a\u1088\u1010\u1083\u1087 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 n \u107c\u107c\u103a\u1089\u1081\u1083 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u101a\u1082\u103a\u1087\u101e\u102f\u1010\u103a\u1038 \u1022\u107c\u103a\u1078\u1085\u1075\u103a\u1087 n \u1081\u103a\u1082\u1088\u1015\u1035\u107c\u103a\u1022\u107c\u103a\u101c\u1035\u1075\u103a\u1089\u101c\u102d\u1030\u101d\u103a n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"\u1015\u1031\u1083\u1038\u101d\u1083\u1088\u1081\u101d\u103a\u1038\u1015\u107c\u103a\u101d\u1086\u1089 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1010\u1035\u1019\u103a \u1022\u107c\u103a\u1022\u1019\u103a\u1087\u1078\u1082\u103a\u1088 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1022\u1019\u103a\u1087\u101e\u102f\u1019\u103a\u1038\u107c\u107c\u103a\u1089\u107c\u1086 \u1011\u1085\u1019\u103a\u101e\u1082\u103a\u1087 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1022\u1019\u103a\u1087\u1019\u102d\u1030\u107c\u103a\u1075\u107c\u103a \u1078\u102d\u1030\u101d\u103a\u1038\u1022\u107c\u103a\u1019\u102e\u1038\u1010\u102e\u1088 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1022\u1019\u103a\u1087\u1019\u102d\u1030\u107c\u103a\u1075\u107c\u103a\u107c\u107c\u103a\u1089\u104b \u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u1087\u1019\u107c\u103a\u1038\u1010\u1084\u1089 \u1011\u1085\u1019\u103a\u101e\u1082\u103a\u1087 ([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" \u1078\u107c\u103a\u1022\u101d\u103a \u101e\u1035\u107c\u103a\u1088\u1019\u1062\u1086 \u1022\u107c\u103a\u1015\u1083\u1038 \u101e\u1035\u107c\u103a\u1088\u1019\u1062\u1086 \u1022\u107c\u103a\u1015\u107c\u103a\u101d\u1086\u1089\u107c\u107c\u103a\u1089\u1075\u1030\u107a\u103a\u1038\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    \u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u10871: Input: sentence = \"this is a test\" Output: \"is\" Example2: Input: sentence = \"let go for swimming\" Output: \"go for\" Constraints: * 1 <= len(sentence) <= 100 * sentence contains only letters\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    \u1011\u1010\u103a\u1038\u101e\u1062\u1004\u103a\u1088 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1076\u102d\u102f\u1075\u103a\u1089\u1010\u103d\u107c\u103a\u1038 \u1022\u107c\u103a\u1019\u102e\u1038 \u1010\u1030\u101d\u103a\u1075\u102f\u107c\u103a\u1038 xs \u1010\u102e\u1088 \u1010\u102e\u1088 x \u107c\u107c\u103a\u1089\u101e\u1031 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Return True is \u101e\u1035\u107c\u103a\u1088\u1019\u1062\u1086 \u1022\u107c\u103a\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1019\u107c\u103a\u1038 \u1010\u102d\u1030\u101d\u103a\u1038\u1076\u102d\u102f\u107c\u103a\u1088 \u1022\u1019\u103a\u1087\u107c\u107c\u103a \u101c\u1030\u1010\u103a\u1038\u101a\u103d\u1019\u103a\u1038\u1019\u1083\u1038 \u101c\u1030\u107a\u103a\u1088\u1022\u1019\u103a\u1087\u1019\u102e\u1038\u101c\u103d\u1004\u103a\u1088\u1019\u1075\u103a\u1038\u1019\u107c\u103a\u1038\u104b\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"\u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u101a\u1082\u103a\u1087\u101e\u102f\u1010\u103a\u1038 \u107c\u1082\u103a\u1038\u101e\u1035\u107c\u103a\u1088\u1019\u1062\u1086\u107c\u107c\u103a\u1089\u104b\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    \u1015\u1031\u1083\u1038\u101d\u1083\u1088\u1081\u101d\u103a\u1038\u1015\u107c\u103a string s \u107c\u1086\u1078\u102d\u102f\u1004\u103a \u1075\u1035\u1015\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088\u1010\u1030\u101d\u103a\u1019\u1084\u1088\u101c\u102d\u1075\u103a\u1088\u1010\u1030\u101d\u103a\u101a\u1082\u103a\u1087 \u1022\u107c\u103a\u1015\u1083\u1038 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1078\u1085\u107c\u103a\u1087\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u101e\u103d\u107c\u103a\u1087 \u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u1087\u1019\u107c\u103a\u1038: count_upper (('aBCdEf') \u1076\u102d\u102f\u107c\u103a\u1038\u1015\u107c\u103a 1 count_upper (('abcdefg') \u1076\u102d\u102f\u107c\u103a\u1038\u1015\u107c\u103a 0 count_upper (('dBBE') \u1076\u102d\u102f\u107c\u103a\u1038\u1015\u107c\u103a 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"\u101e\u1035\u107c\u103a\u1088\u1019\u1062\u1086 \u1022\u107c\u103a\u101c\u1086\u1088\u1076\u102d\u102f\u107c\u103a\u1038\u1019\u1083\u1038\u107c\u107c\u103a\u1089 \u1019\u102e\u1038\u101d\u1086\u1089 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1010\u102d\u1030\u101d\u103a\u1038\u101c\u102d\u1030\u101d\u103a\u1019\u1083\u1038\u1011\u1085\u1004\u103a\u1088 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"\u1010\u1031\u101c\u1086\u1088\u1010\u1085\u1019\u103a\u1088\u1015\u107c\u103a \u1010\u1030\u101d\u103a\u1022\u102d\u1004\u103a\u1022\u107c\u103a\u1010\u1031\u1019\u1075\u103a\u1038\u1019\u107c\u103a\u1088\u1015\u107c\u103a \u101d\u107c\u103a\u1038\u1011\u102e\u1089 \u101c\u1084\u1088 \u1076\u102d\u102f\u107c\u103a\u1038\u1019\u102d\u1030\u101d\u103a\u1038 True \u101e\u1004\u103a\u101d\u1083\u1088 \u101d\u107c\u103a\u1038\u1011\u102e\u1089\u107c\u107c\u103a\u1089 \u1019\u1062\u107c\u103a\u1087\u1019\u1085\u107c\u103a\u1088 \u1015\u1031\u1083\u1038\u1022\u1019\u103a\u1087\u107c\u107c\u103a False \u101d\u107c\u103a\u1038\u1011\u102e\u1089\u107c\u107c\u103a\u1089 \u1019\u1062\u107c\u103a\u1087\u1019\u1085\u107c\u103a\u1088 \u101e\u1004\u103a\u101d\u1083\u1088 \u1015\u1075\u103a\u1038\u1015\u102d\u1030\u1004\u103a\u1022\u107c\u103a\u1078\u103d\u1019\u103a\u1038\u1019\u1083\u1038\u107c\u1086\u1089 \u1075\u102f\u1019\u103a\u1087\u1011\u1030\u107c\u103a\u1088\u101d\u1086\u1089: 1. \u101d\u107c\u103a\u1038\u1011\u102e\u1089\u107c\u107c\u103a\u1089 \u1022\u1019\u103a\u1087\u101c\u1086\u1088\u1015\u1035\u107c\u103a\u1022\u107c\u103a\u1022\u1019\u103a\u1087\u1019\u102e\u1038\u1010\u102e\u1088\u1015\u103d\u1004\u103a\u1087 2. \u101d\u107c\u103a\u1038\u1011\u102e\u1089\u107c\u1086\u1089 \u1022\u1019\u103a\u1087\u101a\u103d\u1019\u103a\u1038 1 \u1022\u1019\u103a\u1087\u107c\u107c\u103a \u107c\u1019\u103a\u101c\u102d\u1030\u101d\u103a 31 \u101d\u107c\u103a\u1038 \u1010\u103d\u107c\u103a\u1088\u1010\u1083\u1087 \u101c\u102d\u1030\u107c\u103a 1,3,5,7,8,10,12 \u101c\u1084\u1088 \u101d\u107c\u103a\u1038\u1011\u102e\u1089\u107c\u1086\u1089 \u1022\u1019\u103a\u1087\u101a\u103d\u1019\u103a\u1038 1 \u1022\u1019\u103a\u1087\u107c\u107c\u103a \u107c\u1019\u103a\u101c\u102d\u1030\u101d\u103a 30 \u101d\u107c\u103a\u1038 \u1010\u103d\u107c\u103a\u1088\u1010\u1083\u1087 \u101c\u102d\u1030\u107c\u103a 4,6,9,11 \u101c\u1084\u1088 \u101d\u107c\u103a\u1038\u1011\u102e\u1089\u107c\u1086\u1089 \u1022\u1019\u103a\u1087\u101a\u103d\u1019\u103a\u1038 1 \u1022\u1019\u103a\u1087\u107c\u107c\u103a \u107c\u1019\u103a\u101c\u102d\u1030\u101d\u103a 29 \u1010\u103d\u107c\u103a\u1088\u1010\u1083\u1087 \u101c\u102d\u1030\u107c\u103a 2. \u101c\u102d\u1030\u107c\u103a\u1011\u102e\u1089\u107c\u1086\u1089 \u1022\u1019\u103a\u1087\u1011\u102f\u1075\u103a\u1087\u101c\u102e\u1015\u1035\u107c\u103a 1 \u1022\u1019\u103a\u1087\u107c\u107c\u103a \u107c\u1019\u103a\u101c\u102d\u1030\u101d\u103a 12. \u101d\u107c\u103a\u1038\u1011\u102e\u1089\u107c\u1086\u1089 \u1011\u102f\u1075\u103a\u1087\u101c\u102e\u1019\u102e\u1038\u101d\u1086\u1089\u107c\u1082\u103a\u1038 \u1015\u102d\u1030\u1004\u103a\u107e\u1062\u1004\u103a: mm-dd-yyyy \u1019\u102d\u1030\u107c\u103a\u107c\u1004\u103a\u1087: valid_date (('03-11-2000') => true_date (('15-01-2012') => false\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"\u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u1087: even_odd_count (-1) ==> (1, 1) even_odd_count (-12) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" \u1076\u1031\u1083\u1088\u1011\u1062\u1019\u103a\u1022\u107c\u103a\u101c\u1086\u1088\u101e\u1082\u103a\u1087\u101d\u1086\u1089\u107c\u1086\u1089 \u1015\u1035\u107c\u103a\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1078\u1085\u1075\u103a\u1087\u101d\u1086\u1089\u1010\u102e\u1088\u1081\u103d\u1004\u103a\u1088\u1019\u107c\u103a\u1038\u101e\u1031 \u1015\u1035\u107c\u103a\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1010\u1084\u1087\u1022\u101d\u103a '\u101e\u102f\u107c\u103a' \u1010\u1031\u1083\u1087\u1011\u102d\u102f\u1004\u103a '\u101e\u102d\u1015\u103a\u1038' \u107c\u107c\u103a\u1089\u101a\u101d\u103a\u1089\u104b \u1022\u107c\u103a\u1010\u1031\u101c\u1086\u1088\u101c\u102d\u1030\u1075\u103a\u1088\u107c\u107c\u103a\u1089\u1015\u1035\u107c\u103a '\u101e\u102f\u107c\u103a'\u104a '\u107c\u102d\u102f\u1004\u103a\u1088'\u104a '\u101e\u103d\u1004\u103a'\u104a '\u101e\u1062\u1019\u103a'\u104a '\u101e\u102e\u1087'\u104a '\u1081\u1083\u1088'\u104a '\u1081\u1030\u1075\u103a\u1038'\u104a '\u1078\u1035\u1010\u103a\u1038'\u104a '\u1022\u1035\u1010\u103a\u1038' \u101c\u1084\u1088 '\u101e\u102d\u1015\u103a\u1038' \u1078\u102d\u1030\u101d\u103a\u1038\u107c\u1086\u1089\u101a\u101d\u103a\u1089\u104b \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1078\u1085\u1075\u103a\u1087\u101d\u1086\u1089\u1010\u102e\u1088\u101c\u1035\u1075\u103a\u1089\u101e\u102f\u1010\u103a\u1038 \u1010\u1031\u1083\u1087\u1011\u102d\u102f\u1004\u103a \u1022\u107c\u103a\u101a\u1082\u103a\u1087\u101e\u102f\u1010\u103a\u1038\u101e\u1031 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1019\u102e\u1038\u1010\u102e\u1088\u107c\u1082\u103a\u1038\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u107c\u107c\u103a\u1089 \u101c\u1062\u1086\u1088\u1015\u107c\u103a\u1076\u102d\u102f\u107c\u103a\u1038\u101a\u101d\u103a\u1089\u104b\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"\u1011\u1085\u1019\u103a\u101e\u1082\u103a\u1087\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 x \u101c\u1084\u1088 y \u101e\u103d\u1004\u103a\u1010\u1030\u101d\u103a\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"\u1015\u1031\u1083\u1038\u101d\u1083\u1088 \u101c\u1086\u1088\u1015\u107c\u103a string \u1022\u107c\u103a\u1010\u1085\u107c\u103a\u1038\u1010\u1062\u1004\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u1078\u1085\u1075\u103a\u1087\u101d\u1086\u1089 \u1010\u102e\u1088\u1075\u1084\u1088 \u1076\u103d\u1004\u103a\u1088\u1075\u1084\u1088 \u1076\u103d\u1004\u103a\u1088\u107c\u107c\u103a\u1089\u107c\u1086 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a \u107c\u1019\u103a\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1022\u107c\u103a\u101c\u1086\u1088\u1081\u107c\u103a\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    \u101c\u103d\u1004\u103a\u1088\u1081\u1035\u1010\u103a\u1038\u101e\u1062\u1004\u103a\u1088 algebra \u1022\u107c\u103a\u101c\u1019\u103a\u1087\u101c\u103d\u1004\u103a\u1088\u1019\u107c\u103a\u1038\u1010\u1084\u1089 \u1015\u1035\u107c\u103a \u101c\u103d\u1004\u103a\u1088\u1011\u1085\u1019\u103a\u101e\u1082\u103a\u1087 (+) \u101c\u103d\u1004\u103a\u1088\u1011\u103d\u107c\u103a (-)) \u101c\u103d\u1004\u103a\u1088\u1075\u102f\u107c\u103a\u1038 (*) \u101c\u103d\u1004\u103a\u1088\u1078\u1085\u1075\u103a\u1087\u107d\u1084 (\/) \u101c\u103d\u1004\u103a\u1088\u1010\u1085\u1075\u103a\u1088 \u1010\u1030\u101d\u103a\u1010\u1085\u107c\u103a\u1038 (**) \u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u1087: \u101c\u103d\u1004\u103a\u1088\u1081\u1035\u1010\u103a\u1038\u101e\u1062\u1004\u103a\u1088 operator['+', '*', '-'] array = [2, 3, 4, 5] result = 2 + 3 * 4 - 5 => result = 9 \u1076\u1031\u1083\u1088\u1010\u103d\u1004\u103a\u1038: \u1010\u1062\u1004\u103a\u1038\u101a\u1062\u101d\u103a\u1038 list of operator \u107c\u1086\u1089 \u1019\u102d\u1030\u107c\u103a\u1010\u1062\u1004\u103a\u1038\u101a\u1062\u101d\u103a\u1038 list of operand minus one \u1022\u107c\u103a\u101c\u1019\u103a\u1087\u101c\u103d\u1004\u103a\u1088\u1019\u107c\u103a\u1038\u1010\u1084\u1089 \u1015\u1035\u107c\u103a \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1022\u1019\u103a\u1087\u1019\u102e\u1038 \u1010\u1030\u101d\u103a\u1011\u103d\u107c\u103a\u107c\u107c\u103a\u1089 Operator \u107c\u107c\u103a\u1089 \u1019\u102e\u1038 operator \u1022\u107c\u103a\u101c\u1019\u103a\u1087\u101c\u103d\u1004\u103a\u1088\u1019\u107c\u103a\u1038 1 \u1022\u107c\u103a \u101c\u1084\u1088 list of operand \u107c\u107c\u103a\u1089 \u1019\u102e\u1038 operands \u1022\u107c\u103a\u101c\u1019\u103a\u1087\u101c\u103d\u1004\u103a\u1088\u1019\u107c\u103a\u1038 2 \u1022\u107c\u103a Operand \u107c\u107c\u103a\u1089\u1019\u102e\u1038 2 \u1022\u107c\u103a Operand \u107c\u107c\u103a\u1089\u1019\u102e\u1038 1 \u1022\u107c\u103a Operand \u107c\u107c\u103a\u1089\u1019\u102e\u1038 1 \u1022\u107c\u103a Operand \u107c\u107c\u103a\u1089\u1019\u102e\u1038 2 \u1022\u107c\u103a Operand \u107c\u107c\u103a\u1089\u1019\u102e\u1038 1 \u1022\u107c\u103a Operator \u107c\u107c\u103a\u1089\u1019\u102e\u1038 1 \u1022\u107c\u103a Operand \u107c\u107c\u103a\u1089\u1019\u102e\u1038 2 \u1022\u107c\u103a Operand \u107c\u107c\u103a\u1089\u1019\u102e\u1038 2 \u1022\u107c\u103a Oper\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"\u1015\u1031\u1083\u1038\u101d\u1083\u1088\u1081\u101d\u103a\u1038\u101c\u1086\u1088\u1015\u107c\u103a\u1078\u102d\u102f\u101d\u103a\u1088 class (string) \u101c\u1084\u1088 \u101e\u1035\u107c\u103a\u1088\u1019\u1062\u1086 extension \u1019\u107c\u103a\u1038\u107c\u1086\u1078\u102d\u102f\u1004\u103a \u1010\u1031\u101c\u1086\u1088\u1078\u1082\u103a\u1089 extension \u1019\u107c\u103a\u1038\u101e\u1031 \u1010\u1062\u1004\u103a\u1087\u1015\u107c\u103a class \u1010\u1062\u1004\u103a\u1087\u1022\u107c\u103a\u104b \u1081\u1085\u1004\u103a\u1038 extension \u1019\u107c\u103a\u1038\u107c\u1086\u1089 \u1010\u1031\u101c\u1086\u1088\u1019\u102d\u1030\u107c\u103a\u107c\u1004\u103a\u1087 CAP \u1015\u1035\u107c\u103a\u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1010\u1030\u101d\u103a\u101a\u1082\u103a\u1087 \u107c\u1082\u103a\u1038\u1078\u102d\u102f\u101d\u103a\u1088 extension \u1019\u107c\u103a\u1038\u101c\u1084\u1088 SM \u1015\u1035\u107c\u103a\u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088 \u1010\u1030\u101d\u103a\u101c\u1035\u1075\u103a\u1089 \u107c\u1082\u103a\u1038\u1078\u102d\u102f\u101d\u103a\u1088 extension \u1019\u107c\u103a\u1038\u107c\u1086 \u1010\u1031\u101c\u1086\u1088\u1078\u1082\u103a\u1089 \u1010\u1030\u101d\u103a\u1078\u1085\u1075\u103a\u1087 CAP - SM \u101e\u1031 \u1010\u1062\u1004\u103a\u1087\u1015\u107c\u103a\u104b \u1010\u1031\u101c\u1086\u1088\u1081\u1083 \u1010\u1030\u101d\u103a\u1078\u1085\u1075\u103a\u1087\u1022\u107c\u103a\u1081\u1085\u1004\u103a\u1038\u101e\u1031\u1015\u102d\u1030\u107c\u103a\u1088\u101e\u1031 \u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a string \u1022\u107c\u103a\u1019\u102d\u1030\u107c\u103a\u107c\u1004\u103a\u1087 ClassName.StrongestExtensionName \u107c\u1086\u1089\u101e\u1031 \u1010\u1062\u1004\u103a\u1087\u1015\u107c\u103a\u104b \u1015\u1031\u1083\u1038\u101d\u1083\u1088 \u1019\u102e\u1038\u1010\u1030\u101d\u103a\u1078\u1085\u1075\u103a\u1087\u1022\u107c\u103a\u1081\u1085\u1004\u103a\u1038\u1019\u102d\u1030\u107c\u103a\u1075\u107c\u103a \u101e\u103d\u1004\u103a\u1022\u107c\u103a\u107c\u1086 \u1010\u1031\u101c\u1086\u1088\u101c\u102d\u1030\u1075\u103a\u1088 \u1010\u1030\u101d\u103a\u1078\u1085\u1075\u103a\u1087\u1022\u107c\u103a\u1022\u103d\u1075\u103a\u1087\u1019\u1083\u1038 \u1022\u103d\u107c\u103a\u1010\u1062\u1004\u103a\u1038\u101e\u102f\u1010\u103a\u1038 \u107c\u1082\u103a\u1038\u101e\u1035\u107c\u103a\u1088\u1019\u1062\u1086\u107c\u107c\u103a\u1089\u104b \u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u1087\u1019\u107c\u103a\u1038 \u101e\u1004\u103a\u101d\u1083\u1088\u1081\u101d\u103a\u1038\u101c\u1086\u1088\u1015\u107c\u103a \"Slices\" \u1019\u102d\u1030\u107c\u103a\u107c\u1004\u103a\u1087 class \u101c\u1084\u1088 \u101e\u1035\u107c\u103a\u1088\u1019\u1062\u1086 extension: ['SEviviRNGSliCes', 'Cheese', 'StuFfed'] \u107c\u1086 \u1010\u1031\u101c\u1086\u1088\u1076\u102d\u102f\u107c\u103a\u1038\u1022\u101d\u103a 'Slices.SEviRNGSliCes'\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"\u101e\u1004\u103a\u101d\u1083\u1088\u1081\u101d\u103a\u1038\u101c\u1086\u1088\u1076\u1031\u1083\u1088\u1075\u1082\u1062\u1019\u103a\u1038\u107c\u1086 \u107c\u1083\u1088\u1075\u1062\u107c\u103a\u1081\u101d\u103a\u1038\u107c\u1086\u1089 \u1010\u1031\u101c\u1086\u1088\u1081\u1083 \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088\u1010\u1030\u101d\u103a\u1078\u101d\u103a\u1089 \u1022\u107c\u103a\u1078\u1019\u103a\u101e\u102f\u1010\u103a\u1038 \u1022\u107c\u103a\u101a\u1030\u1087\u107c\u1082\u103a\u1038\u1075\u1084\u1088 \u1010\u1030\u101d\u103a\u101e\u103d\u107c\u103a\u1089 \u101e\u103d\u1004\u103a\u1010\u1030\u101d\u103a \u107d\u1062\u1086\u1087\u1076\u1082\u1083 \u1076\u1031\u1083\u1088\u1075\u1082\u1062\u1019\u103a\u1038 (\u1010\u1030\u101d\u103a\u1022\u107c\u103a\u1078\u1019\u103a\u101e\u102f\u1010\u103a\u1038) \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088\u1010\u1030\u101d\u103a\u1078\u101d\u103a\u1089 \u1010\u102e\u1088\u1010\u1084\u1087\u101c\u1084\u1088 \u1010\u1030\u101d\u103a\u1022\u107c\u103a\u1078\u1019\u103a\u101e\u102f\u1010\u103a\u1038 \u1022\u1019\u103a\u1087\u101c\u1086\u1088\u107c\u1015\u103a\u1089\u101e\u103d\u107c\u103a\u1087 \u101e\u1004\u103a\u101d\u1083\u1088\u1081\u101d\u103a\u1038\u1022\u1019\u103a\u1087\u101c\u1086\u1088 \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088\u1010\u1030\u101d\u103a\u1078\u101d\u103a\u1089 \u1022\u107c\u103a\u101c\u1086\u1088\u1019\u1075\u103a\u1038\u1019\u107c\u103a\u1088\u101d\u1086\u1089\u107d\u1062\u1086\u1087\u107c\u102d\u1030\u101d\u103a\u107c\u1086 \u1010\u1031\u101c\u1086\u1088\u1076\u102d\u102f\u107c\u103a\u1038 \u1010\u1030\u101d\u103a\u101c\u102d\u1075\u103a\u1088\u1022\u107c\u103a\u1022\u1019\u103a\u1087\u1019\u102e\u1038\u1010\u1030\u101d\u103a\u107c\u107c\u103a\u1089\u107c\u1086 \u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u1087: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 Fib4 \u107c\u1086\u1089 \u1019\u107c\u103a\u1038\u1019\u102d\u1030\u107c\u103a\u1075\u107c\u103a\u1010\u1004\u103a\u1038 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 Fibbonacci \u1022\u107c\u103a\u1019\u1075\u103a\u1038\u1019\u107c\u103a\u1088\u101d\u1086\u1089\u107c\u1004\u103a\u1087\u107c\u1086 fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). \u1076\u1085\u107c\u103a\u1038\u1010\u1031\u1083\u1088 \u1010\u1085\u1019\u103a\u1088\u1015\u107c\u103a \u1010\u1030\u101d\u103a\u1022\u102d\u1004\u103a\u1022\u107c\u103a\u1010\u1031\u107c\u1015\u103a\u1089\u101e\u103d\u107c\u103a\u1087\u101c\u1086\u1088 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 n-th \u1076\u103d\u1004\u103a \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 fib4 \u107c\u107c\u103a\u1089\u1076\u1083\u1088\u101c\u1084\u1088\u104b \u101a\u1083\u1087\u1015\u1031\u1078\u1082\u103a\u1089\u1010\u102d\u102f\u101d\u103a\u1038 \u101c\u103d\u1004\u103a\u1088\u1076\u102d\u102f\u107c\u103a\u1038\u1010\u1084\u1087\u104b\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets \u107c\u1086\u1089\u1015\u1035\u107c\u103a string \u1022\u107c\u103a\u1015\u1083\u1038\u101d\u1086\u1089 \"<\" \u101c\u1084\u1088 \">\" \u107c\u1086\u101e\u1031 \u101e\u1004\u103a\u101d\u1083\u1088 bracket \u1022\u107c\u103a\u1015\u102d\u102f\u1010\u103a\u1087\u101d\u1086\u1089\u107c\u107c\u103a\u1089 \u1019\u102e\u1038 bracket \u1022\u107c\u103a\u1022\u102d\u102f\u1010\u103a\u1038\u101d\u1086\u1089\u107c\u107c\u103a\u1089\u107c\u1086 return True\u104b\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"\u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u1087\u1019\u107c\u103a\u1038\u1010\u1084\u1089 \u1015\u1031\u1083\u1038\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] \u107c\u1086\u1078\u102d\u102f\u1004\u103a \u1010\u1031\u101c\u1086\u1088\u1022\u103d\u1075\u103a\u1087 10 \u1010\u1030\u101d\u103a \u1015\u1031\u1083\u1038\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] \u107c\u1086\u1078\u102d\u102f\u1004\u103a \u1010\u1031\u101c\u1086\u1088\u1022\u103d\u1075\u103a\u1087 25 \u1010\u1030\u101d\u103a \u1015\u1031\u1083\u1038\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] \u107c\u1086\u1078\u102d\u102f\u1004\u103a \u1010\u1031\u101c\u1086\u1088\u1022\u103d\u1075\u103a\u1087 13 \u1010\u1030\u101d\u103a \u1015\u1031\u1083\u1038\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] \u107c\u1086\u1078\u102d\u102f\u1004\u103a \u1010\u1031\u101c\u1086\u1088\u1022\u103d\u1075\u103a\u1087 11 \u1010\u1030\u101d\u103a \u1015\u1031\u1083\u1038\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 lst = [0,81,12,3,21,21] \u107c\u1086\u1078\u102d\u102f\u1004\u103a \u1010\u1031\u101c\u1086\u1088\u1022\u103d\u1075\u103a\u1087 3 \u1010\u1030\u101d\u103a \u1015\u1031\u1083\u1038\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 lst = [1,8,1,2,1,7] \u107c\u1086\u1078\u102d\u102f\u1004\u103a \u1010\u1031\u101c\u1086\u1088\u1022\u103d\u1075\u103a\u1087 7 \u1010\u1030\u101d\u103a \u1015\u1031\u1083\u1038\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 l\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"\u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u1087\u1019\u107c\u103a\u1038: \u1010\u103d\u107c\u103a\u1088\u1010\u1083\u1087 lst = [1,2,3] \u1022\u107c\u103a\u1022\u103d\u1075\u103a\u1087\u1019\u107c\u103a\u1038\u1010\u1031\u101c\u1086\u1088\u1015\u1035\u107c\u103a 14 \u1010\u103d\u107c\u103a\u1088\u1010\u1083\u1087 lst = [1,4,9] \u1022\u107c\u103a\u1022\u103d\u1075\u103a\u1087\u1019\u107c\u103a\u1038\u1010\u1031\u101c\u1086\u1088\u1015\u1035\u107c\u103a 98 \u1010\u103d\u107c\u103a\u1088\u1010\u1083\u1087 lst = [1,3,5,7] \u1022\u107c\u103a\u1022\u103d\u1075\u103a\u1087\u1019\u107c\u103a\u1038\u1010\u1031\u101c\u1086\u1088\u1015\u1035\u107c\u103a 84 \u1010\u103d\u107c\u103a\u1088\u1010\u1083\u1087 lst = [1.4,4.2,0] \u1022\u107c\u103a\u1022\u103d\u1075\u103a\u1087\u1019\u107c\u103a\u1038\u1010\u1031\u101c\u1086\u1088\u1015\u1035\u107c\u103a 29 \u1010\u103d\u107c\u103a\u1088\u1010\u1083\u1087 lst = [-2.4,1,1] \u1022\u107c\u103a\u1022\u103d\u1075\u103a\u1087\u1019\u107c\u103a\u1038\u1010\u1031\u101c\u1086\u1088\u1015\u1035\u107c\u103a 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" \u0db8\u0dd9\u0db8 \u0dc1\u0dca \u0dbb\u0dd2\u0dad\u0dba\u0da7 \u0d86\u0daf\u0dcf\u0db1\u0dba \u0dc0\u0db1\u0dca\u0db1\u0dda \u0dc3\u0d82\u0d9c\u0dd3\u0dad \u0db1\u0ddd\u0da7\u0dca\u0da7\u0dd4 \u0db1\u0dd2\u0dbb\u0dd6\u0db4\u0dab\u0dba \u0d9a\u0dbb\u0db1 \u0db1\u0dd6\u0dbd\u0d9a\u0dca \u0dc0\u0dd2\u0dc1\u0dda\u0dc2 ASCII \u0d86\u0d9a\u0dd8\u0dad\u0dd2\u0dba\u0d9a\u0dd2\u0db1\u0dca. \u0d94\u0db6\u0dda \u0d9a\u0dcf\u0dbb\u0dca\u0dba\u0dba \u0dc0\u0db1\u0dca\u0db1\u0dda \u0db8\u0dd9\u0db8 \u0db1\u0dd6\u0dbd \u0dc0\u0dd2\u0d9c\u0dca \u0dbb\u0dc4 \u0d9a\u0dbb \u0d91\u0d9a\u0dca \u0d91\u0d9a\u0dca \u0db1\u0ddc\u0db4\u0dc0\u0dad\u0dd2\u0db1 \u0dc3\u0dca\u0db4\u0db1\u0dca\u0daf\u0db1 \u0d9c\u0dab\u0db1\u0da7 \u0d85\u0db1\u0dd4\u0dbb\u0dd6\u0db4 \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0d9a\u0dca \u0dbd\u0db6\u0dcf \u0daf\u0dd3\u0db8\u0dba\u0dd2. \u0db8\u0dd9\u0db1\u0dca\u0db1 \u0db4\u0dd4\u0dbb\u0dcf\u0dc0\u0dd8\u0dad\u0dca\u0dad\u0dba\u0d9a\u0dca: 'o' - \u0dc3\u0db8\u0dca\u0db4\u0dd6\u0dbb\u0dca\u0dab \u0db1\u0ddd\u0da7\u0dca\u0da7\u0dd4\u0dc0, \u0dc3\u0dca\u0db4\u0db1\u0dca\u0daf\u0db1 \u0dc4\u0dad\u0dbb\u0d9a\u0dca \u0db4\u0dc0\u0dad\u0dd3 'o\" - \u0d85\u0dbb\u0dca\u0db0 \u0db1\u0ddd\u0da7\u0dca\u0da7\u0dd4\u0dc0, \u0dc3\u0dca\u0db4\u0db1\u0dca\u0daf\u0db1 \u0daf\u0dd9\u0d9a\u0d9a\u0dca \u0db4\u0dc0\u0dad\u0dd3 '. \" \" - \u0dc4\u0dad\u0dbb\u0dda \u0db1\u0ddd\u0da7\u0dca\u0da7\u0dd4\u0dc0, \u0d91\u0d9a\u0dca \u0dc3\u0dca\u0db4\u0db1\u0dca\u0daf\u0db1\u0dba\u0d9a\u0dca \u0db4\u0dc0\u0dad\u0dd3\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0d85\u0dbb\u0dcf \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0dc0\u0dd2\u0da7, \u0d85\u0dbb\u0dcf \u0db4\u0dd0\u0dbd\u0dd2\u0db1\u0dca\u0da9\u0dca \u0dbb\u0ddd\u0db8 \u0db6\u0dc0\u0da7 \u0db4\u0dad\u0dca \u0d9a\u0dd2\u0dbb\u0dd3\u0db8 \u0dc3\u0db3\u0dc4\u0dcf \u0dc0\u0dd9\u0db1\u0dc3\u0dca \u0d9a\u0dc5 \u0dba\u0dd4\u0dad\u0dd4 \u0d85\u0dc0\u0db8 \u0db8\u0dd6\u0dbd\u0daf\u0dca \u0dbb\u0dc0\u0dca \u0dba \u0d9c\u0dab\u0db1 \u0dc3\u0ddc\u0dba\u0dcf \u0d9c\u0db1\u0dca\u0db1. \u0db4\u0dd0\u0dbd\u0dd2\u0db1\u0dca\u0da9\u0dca \u0dbb\u0ddd\u0db8 \u0d85\u0dbb\u0dcf \u0dba\u0db1\u0dd4 \u0d91\u0d9a\u0db8 \u0d86\u0d9a\u0dcf\u0dbb\u0dba\u0d9a\u0dd2\u0db1\u0dca \u0db4\u0dd2\u0da7\u0dd4\u0db4\u0dc3\u0da7 \u0dc3\u0dc4 \u0d89\u0daf\u0dd2\u0dbb\u0dd2\u0dba\u0da7 \u0d9a\u0dd2\u0dba\u0dc0\u0db1 \u0d85\u0dbb\u0dcf \u0dc0\u0dda. \u0d91\u0d9a\u0dca \u0dc0\u0dd9\u0db1\u0dc3\u0dca \u0d9a\u0dd2\u0dbb\u0dd3\u0db8\u0d9a\u0dd2\u0db1\u0dca \u0d94\u0db6\u0da7 \u0d91\u0d9a\u0dca \u0db8\u0dd6\u0dbd\u0daf\u0dca \u0dbb\u0dc0\u0dca \u0dba\u0dba\u0d9a\u0dca \u0dc0\u0dd9\u0db1\u0dad\u0dca \u0d95\u0db1\u0dd1\u0db8 \u0db8\u0dd6\u0dbd\u0daf\u0dca \u0dbb\u0dc0\u0dca \u0dba\u0dba\u0d9a\u0dca \u0db6\u0dc0\u0da7 \u0dc0\u0dd9\u0db1\u0dc3\u0dca \u0d9a\u0dc5 \u0dc4\u0dd0\u0d9a\u0dd2\u0dba. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab\u0dba\u0d9a\u0dca \u0dbd\u0dd9\u0dc3: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0dda \u0daf\u0dd2\u0d9c\u0db8 \u0db1\u0dd6\u0dbd \u0db1\u0dd0\u0dc0\u0dad \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1. \u0d91\u0d9a\u0db8 \u0daf\u0dd2\u0d9c\u0da7 \u0db1\u0dd6\u0dbd\u0dca \u0d9a\u0dd2\u0dc4\u0dd2\u0db4\u0dba\u0d9a\u0dca \u0dad\u0dd2\u0db6\u0dda \u0db1\u0db8\u0dca \u0db4\u0dc5\u0db8\u0dd4\u0dc0\u0dd0\u0db1\u0dca\u0db1 \u0db1\u0dd0\u0dc0\u0dad \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1. \u0d86\u0daf\u0dcf\u0db1 \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0 \u0dc4\u0dd2\u0dc3\u0dca \u0db1\u0db8\u0dca \u0d9a\u0dd2\u0dc3\u0dd2\u0dc0\u0d9a\u0dca \u0db1\u0dd0\u0dc0\u0dad \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1 \u0d91\u0db4\u0dcf.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0dc3\u0db8\u0dca\u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0d9a\u0dd2\u0db1\u0dca, \u0d85\u0db1\u0dd4\u0d9a\u0dca \u0dbb\u0db8\u0dba\u0dda \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0db8\u0ddc\u0dc4\u0ddc\u0dad \u0daf\u0d9a\u0dca\u0dc0\u0dcf \u0dc3\u0ddc\u0dba\u0dcf\u0d9c\u0dad\u0dca \u0d8b\u0db4\u0dbb\u0dd2\u0db8 \u0d85\u0d82\u0d9c \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0d9a\u0dca \u0da2\u0db1\u0db1\u0dba \u0d9a\u0dbb\u0db1\u0dca\u0db1.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" \u0d86\u0daf\u0dcf\u0db1 \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0dda \u0dc3\u0dd1\u0db8 \u0d85\u0d9b\u0dab\u0dca\u0da9 \u0d85\u0d82\u0d9c \u0daf\u0dd9\u0d9a\u0d9a\u0dca \u0d85\u0dad\u0dbb\u0db8 \"\u0dc3\u0dd3\u0db8\u0dcf \u0db8\u0dcf\u0dba\u0dd2\u0db8\" \u0d85\u0d82\u0d9a\u0dba\u0d9a\u0dca \u0d87\u0dad\u0dd4\u0dbd\u0dad\u0dca \u0d9a\u0dbb\u0db1\u0dca\u0db1 `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    \u0d94\u0db6\u0da7 2 \u0db8\u0dcf\u0db1 \u0daf\u0dad\u0dca\u0dad \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad, \u0db1\u0dba\u0dd2\u0da7\u0dca \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4 \u0dbd\u0dd9\u0dc3, \u0d91\u0dba \u0db1\u0dca \u0dba\u0dcf\u0dc3\u0dba\u0da7 \u0dc3\u0db8\u0dcf\u0db1 \u0dba, \u0d9a\u0dd9\u0dc3\u0dda \u0dc0\u0dd9\u0dad\u0dad\u0dca, \u0db1\u0dca \u0dba\u0dcf\u0dc3 \u0db8\u0dd9\u0db1\u0dca \u0db1\u0ddc\u0dc0, \u0dc3\u0dd1\u0db8 \u0db4\u0dda\u0dc5\u0dd2\u0dba\u0d9a\u0da7\u0db8 \u0dc0\u0dd9\u0db1\u0dc3\u0dca \u0dad\u0dd3\u0dbb\u0dd4 \u0d9c\u0dab\u0db1\u0d9a\u0dca \u0d85\u0da9\u0d82\u0d9c\u0dd4 \u0dc0\u0dd2\u0dba \u0dc4\u0dd0\u0d9a\u0dd2\u0dba. lst, \u0dc3\u0dc4 \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf\u0dc0 x \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0dc0\u0dd2\u0da7, \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0dda x \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf\u0dc0 \u0dc3\u0ddc\u0dba\u0dcf \u0d9c\u0db1\u0dca\u0db1, \u0dc3\u0dc4 \u0dad\u0dca \u0dbb\u0dd2\u0dad\u0dca\u0dc0 \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0 \u0d86\u0db4\u0dc3\u0dd4 \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1, [(x1, y1), (x2, y2)...] \u0dc3\u0dd1\u0db8 \u0da7\u0dd4\u0db4\u0dbd\u0dca \u0d91\u0d9a\u0d9a\u0dca\u0db8 \u0d9b\u0dab\u0dca\u0da9\u0dcf\u0d82\u0d9a\u0dba\u0d9a\u0dd2 - (\u0db4\u0dda\u0dc5\u0dd2\u0dba, \u0dad\u0dd3\u0dbb\u0dd4), 0 \u0dc3\u0dd2\u0da7 \u0d86\u0dbb\u0db8\u0dca\u0db7 \u0dc0\u0dda. \u0d86\u0dbb\u0db8\u0dca\u0db7\u0dba\u0dda \u0daf\u0dd3 \u0d85\u0db1\u0dd4\u0d9a\u0dd6\u0dbd\u0dad\u0dcf \u0d89\u0dc4\u0dc5 \u0dba\u0db1 \u0db4\u0dd2\u0dc5\u0dd2\u0dc0\u0dd9\u0dbd\u0da7 \u0db4\u0dda\u0dc5\u0dd2 \u0d85\u0db1\u0dd4\u0dc0 \u0dc0\u0dbb\u0dca\u0d9c \u0d9a\u0dbb\u0db1\u0dca\u0db1. \u0d91\u0dc3\u0dda\u0db8, \u0dad\u0dd3\u0dbb\u0dd4 \u0dc0\u0dbd \u0d85\u0db1\u0dd4\u0d9a\u0dd6\u0dbd\u0dad\u0dcf \u0db4\u0dc4\u0dc5 \u0dba\u0db1 \u0db4\u0dd2\u0dc5\u0dd2\u0dc0\u0dd9\u0dbd\u0da7 \u0db4\u0dda\u0dc5\u0dd2 \u0d85\u0db1\u0dd4\u0dc0 \u0dc0\u0dbb\u0dca\u0d9c \u0d9a\u0dbb\u0db1\u0dca\u0db1. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab: get_row [1,\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    \u0db0\u0db1\u0dcf\u0dad\u0dca\u0db8\u0d9a \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0daf\u0dd9\u0d9a\u0d9a\u0dca \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0dc0\u0dd2\u0da7, a \u0dc3\u0dc4 b \u0d85\u0dad\u0dbb \u0d87\u0dad\u0dd2 \u0dc3\u0db8 \u0d85\u0d82\u0d9a \u0d89\u0dc4\u0dc5 \u0dba\u0db1 \u0db4\u0dd2\u0dc5\u0dd2\u0dc0\u0dd9\u0dbd\u0da7 \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab\u0dba\u0d9a\u0dca \u0dbd\u0dd9\u0dc3: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\u0db8\u0dd9\u0db8 \u0dc1\u0dca \u0dbb\u0dd2\u0dad\u0dba \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0d9a\u0dca \u0d9c\u0db1\u0dd3. \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0dda \u0dc3\u0dd2\u0dba\u0dbd\u0dd4\u0db8 \u0db4\u0dca \u0dbb\u0dc0\u0dda\u0dc1\u0dba\u0db1\u0dca \u0dc3\u0db3\u0dc4\u0dcf, \u0dc1\u0dca \u0dbb\u0dd2\u0dad\u0dba \u0d91\u0dc4\u0dd2 \u0daf\u0dbb\u0dca\u0dc1\u0d9a\u0dba 3 \u0d9a \u0d9c\u0dd4\u0dab\u0dba\u0d9a\u0dca \u0db1\u0db8\u0dca \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0db4\u0dca \u0dbb\u0dc0\u0dda\u0dc1\u0dba \u0dc0\u0dbb\u0dca\u0d9c \u0d9a\u0dc5 \u0dba\u0dd4\u0dad\u0dd4 \u0d85\u0dad\u0dbb \u0d91\u0dc4\u0dd2 \u0daf\u0dbb\u0dca\u0dc1\u0d9a\u0dba 4 \u0d9a \u0d9c\u0dd4\u0dab\u0dba\u0d9a\u0dca \u0db1\u0db8\u0dca \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0db4\u0dca \u0dbb\u0dc0\u0dda\u0dc1\u0dba \u0d9d\u0db1 \u0d9a\u0dbb\u0dba\u0dd2. \u0dc1\u0dca \u0dbb\u0dd2\u0dad\u0dba \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0dda \u0db4\u0dca \u0dbb\u0dc0\u0dda\u0dc1\u0dba\u0db1\u0dca \u0dc0\u0dd9\u0db1\u0dc3\u0dca \u0db1\u0ddc\u0d9a\u0dbb\u0db1\u0dd4 \u0d87\u0dad. \u0d91\u0dc4\u0dd2 \u0daf\u0dbb\u0dca\u0dc1\u0d9a 3 \u0dc4\u0ddd 4 \u0d9a \u0d9c\u0dd4\u0dab\u0dba\u0d9a\u0dca \u0db1\u0ddc\u0dc0\u0dda. \u0d91\u0dc0\u0dd2\u0da7 \u0dc1\u0dca \u0dbb\u0dd2\u0dad\u0dba \u0dc3\u0dd2\u0dba\u0dbd\u0dd4\u0db8 \u0db4\u0dca \u0dbb\u0dc0\u0dda\u0dc1\u0dba\u0db1\u0dca\u0d9c\u0dda \u0d91\u0d9a\u0dad\u0dd4\u0dc0 \u0db1\u0dd0\u0dc0\u0dad \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0dba\u0dd2. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab: lst = [1,2,3] \u0dc3\u0db3\u0dc4\u0dcf \u0db4\u0dca \u0dbb\u0dad\u0dd2\u0daf\u0dcf\u0db1\u0dba 6 \u0dc0\u0dd2\u0dba \u0dba\u0dd4\u0dad\u0dd4\u0dba lst = [] \u0dc3\u0db3\u0dc4\u0dcf \u0db4\u0dca \u0dbb\u0dad\u0dd2\u0daf\u0dcf\u0db1\u0dba 0 \u0dc0\u0dd2\u0dba \u0dba\u0dd4\u0dad\u0dd4\u0dba lst = [-1,-5,2,-1,-5] \u0dc3\u0db3\u0dc4\u0dcf \u0db4\u0dca \u0dbb\u0dad\u0dd2\u0daf\u0dcf\u0db1\u0dba -126 \u0dc0\u0dd2\u0dba \u0dba\u0dd4\u0dad\u0dd4\u0dba\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0d85\u0dbb\u0dcf \u0d91\u0d9a\u0d9a\u0dca \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0dc0\u0dd2\u0da7, \u0dc4\u0dd2\u0dc3\u0dca \u0db1\u0ddc\u0dc0\u0db1 \u0d95\u0db1\u0dd1\u0db8 \u0d8b\u0db4 \u0d85\u0dbb\u0dcf\u0d9a\u0dba\u0d9a \u0d85\u0dc0\u0db8 \u0d91\u0d9a\u0dad\u0dd4\u0dc0 \u0dc3\u0ddc\u0dba\u0dcf \u0d9c\u0db1\u0dca\u0db1. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab\u0dba minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"\u0d94\u0db6\u0da7 \u0daf\u0dc1\u0db8 \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0d86\u0d9a\u0dd8\u0dad\u0dd2\u0dba\u0dda \u0d85\u0d82\u0d9a\u0dba\u0d9a\u0dca \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dd4 \u0d87\u0dad. \u0d94\u0db6\u0dda \u0d9a\u0dcf\u0dbb\u0dca\u0dba\u0dba \u0d91\u0dba \u0daf\u0dca\u0dc0\u0dd2\u0db8\u0dba \u0d86\u0d9a\u0dd8\u0dad\u0dd2\u0dba\u0da7 \u0db4\u0dbb\u0dd2\u0dc0\u0dbb\u0dca\u0dad\u0db1\u0dba \u0d9a\u0dd2\u0dbb\u0dd3\u0db8\u0dba\u0dd2. \u0dc1\u0dca \u0dbb\u0dd2\u0dad\u0dba \u0daf\u0dca\u0dc0\u0dd2\u0db8\u0dba \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf\u0dc0\u0d9a\u0dca \u0db1\u0dd2\u0dba\u0ddd\u0da2\u0db1\u0dba \u0d9a\u0dbb\u0db1 \u0dc3\u0dd1\u0db8 \u0d85\u0d9a\u0dca\u0dc2\u0dbb\u0dba\u0d9a\u0dca\u0db8 \u0dc3\u0dc4\u0dd2\u0dad \u0db1\u0dd6\u0dbd\u0d9a\u0dca \u0d86\u0db4\u0dc3\u0dd4 \u0dbd\u0db6\u0dcf \u0daf\u0dd2\u0dba \u0dba\u0dd4\u0dad\u0dd4\u0dba. \u0db1\u0dd6\u0dbd\u0dd9\u0dc4\u0dd2 \u0dc3\u0dd1\u0db8 \u0d85\u0d9a\u0dca\u0dc2\u0dbb\u0dba\u0d9a\u0dca\u0db8 '0' \u0dc4\u0ddd '1' \u0dc0\u0db1\u0dd4 \u0d87\u0dad. \u0db1\u0dd6\u0dbd \u0d86\u0dbb\u0db8\u0dca\u0db7\u0dba\u0dda \u0dc3\u0dc4 \u0d85\u0dc0\u0dc3\u0dcf\u0db1\u0dba\u0dda 'db' \u0d85\u0d9a\u0dca\u0dc2\u0dbb \u0d9a\u0dd2\u0dc4\u0dd2\u0db4\u0dba\u0d9a\u0dca \u0d85\u0db8\u0dad\u0dbb \u0dc0\u0db1\u0dd4 \u0d87\u0dad. \u0d86\u0d9a\u0dd8\u0dad\u0dd2\u0dba\u0da7 \u0d8b\u0daf\u0dc0\u0dca \u0d9a\u0dd2\u0dbb\u0dd3\u0db8 \u0dc3\u0db3\u0dc4\u0dcf \u0d85\u0db8\u0dad\u0dbb \u0d85\u0d9a\u0dca\u0dc2\u0dbb \u0dad\u0dd2\u0db6\u0dda. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab: decimal_to_binary(15) # \"db1111db\" \u0daf\u0dc1\u0db8_to_binary32) # \"db100000db\" \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0dba\u0dd2\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"\u0d85\u0dc0\u0d9a\u0dcf\u0dc1\u0dba \u0dc0\u0dd9\u0db1\u0dca \u0d9a\u0dbb\u0db1 \u0dbd\u0daf \u0d9a\u0dd4\u0da9\u0dcf \u0d85\u0d9a\u0dd4\u0dbb\u0dd4 \u0db1\u0dd2\u0dba\u0ddd\u0da2\u0db1\u0dba \u0d9a\u0dbb\u0db1 \u0db1\u0dd6\u0dbd\u0d9a\u0dca \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0dc0\u0dd2\u0da7, \u0dc0\u0da9\u0dcf\u0dad\u0dca\u0db8 \u0db4\u0dd4\u0db1\u0dbb\u0dcf\u0dc0\u0dbb\u0dca\u0dad\u0db1\u0dba \u0dc0\u0db1 \u0d85\u0d9a\u0dd4\u0dbb\u0dd9\u0dc4\u0dd2 \u0dc1\u0db6\u0dca\u0daf\u0d9a\u0ddd\u0dc2\u0dba\u0d9a\u0dca \u0d86\u0db4\u0dc3\u0dd4 \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1. \u0d85\u0d9a\u0dd4\u0dbb\u0dd4 \u0d9a\u0dd2\u0dc4\u0dd2\u0db4\u0dba\u0d9a\u0dca \u0d91\u0d9a\u0db8 \u0dc3\u0dd2\u0daf\u0dd4\u0dc0\u0dd3\u0db8\u0d9a\u0dca \u0dad\u0dd2\u0db6\u0dda \u0db1\u0db8\u0dca, \u0d92\u0dc0\u0dcf \u0dc3\u0dd2\u0dba\u0dbd\u0dca\u0dbd\u0db8 \u0d86\u0db4\u0dc3\u0dd4 \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab\u0dba: \u0dc4\u0dd2\u0dc3\u0dca\u0da7\u0ddd\u0d9c\u0dca \u0dbb\u0dd1\u0db8\u0dca ((('a b c') == {'a': 1, 'b': 1, 'c': 1} \u0dc4\u0dd2\u0dc3\u0dca\u0da7\u0ddd\u0d9c\u0dca \u0dbb\u0dd1\u0db8\u0dca ((('a b b a') == {'a': 2, 'b': 2} \u0dc4\u0dd2\u0dc3\u0dca\u0da7\u0ddd\u0d9c\u0dca \u0dbb\u0dd1\u0db8\u0dca ((('a b c a b') == {'a': 2, 'b': 2} \u0dc4\u0dd2\u0dc3\u0dca\u0da7\u0ddd\u0d9c\u0dca \u0dbb\u0dd1\u0db8\u0dca ((('b b a') == {'b 4}': \u0dc4\u0dd2\u0dc3\u0dca\u0da7\u0ddd\u0d9c\u0dca \u0dbb\u0dd1\u0db8\u0dca ((')) == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    \u0d85\u0d9a\u0dca\u0dc2\u0dbb 3 \u0d9a\u0dd2\u0db1\u0dca \u0dba\u0dd4\u0dad\u0dca \u0da0\u0d9a\u0dca \u0dbb \u0d9a\u0dab\u0dca\u0da9\u0dcf\u0dba\u0db8\u0dca \u0dc0\u0dbd\u0dd2\u0db1\u0dca \u0d9a\u0dda\u0dad\u0db1\u0dba \u0d9a\u0dbb\u0db1 \u0dbd\u0daf \u0db1\u0dd6\u0dbd\u0dca \u0db1\u0dd0\u0dc0\u0dad \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0dba\u0dd2.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0d86\u0daf\u0dcf\u0db1 \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0d9a\u0dca \u0dc3\u0db3\u0dc4\u0dcf, \u0db8\u0dd9\u0db8 \u0daf\u0dad\u0dca\u0dad \u0d9a\u0da7\u0dca\u0da7\u0dbd\u0dba\u0dda \u0db8\u0db0\u0dca \u0dba\u0db8 \u0d85\u0d9c\u0dba \u0dc0\u0da7\u0dcf \u0db8\u0db0\u0dca \u0dba\u0db8 \u0db1\u0dd2\u0dbb\u0db4\u0dda\u0d9a\u0dca\u0dc2 \u0d85\u0db4\u0d9c\u0db8\u0db1\u0dba \u0d9c\u0dab\u0db1\u0dba \u0d9a\u0dbb\u0db1\u0dca\u0db1. \u0db8\u0db0\u0dca \u0dba\u0db8 \u0db1\u0dd2\u0dbb\u0db4\u0dda\u0d9a\u0dca\u0dc2 \u0d85\u0db4\u0d9c\u0db8\u0db1\u0dba \u0dba\u0db1\u0dd4 \u0d91\u0d9a\u0dca \u0d91\u0d9a\u0dca \u0db8\u0dd6\u0dbd\u0daf\u0dca \u0dbb\u0dc0\u0dca \u0dba\u0dba \u0dc3\u0dc4 \u0db8\u0db0\u0dca \u0dba\u0dc3\u0dca\u0dae\u0dcf\u0db1\u0dba\u0d9a\u0dca \u0d85\u0dad\u0dbb \u0dc3\u0dcf\u0db8\u0dcf\u0db1\u0dca \u0dba \u0db1\u0dd2\u0dbb\u0db4\u0dda\u0d9a\u0dca\u0dc2 \u0dc0\u0dd9\u0db1\u0dc3\u0dba\u0dd2 (\u0db8\u0dd9\u0db8 \u0d85\u0dc0\u0dc3\u0dca\u0dae\u0dcf\u0dc0\u0dda \u0daf\u0dd3 \u0db8\u0db0\u0dca \u0dba): MAD = \u0dc3\u0dcf\u0db8\u0dcf\u0db1\u0dca \u0dba  x - x_mean  \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab\u0dba:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0db1\u0dd6\u0dbd \u0db4\u0dcf\u0dbd\u0dd2\u0db1\u0dca\u0da9\u0dca \u0dbb\u0ddd\u0db8\u0dca \u0d91\u0d9a\u0d9a\u0dca\u0daf\u0dd0\u0dba\u0dd2 \u0db4\u0dbb\u0dd3\u0d9a\u0dca\u0dc2\u0dcf \u0d9a\u0dbb\u0dba\u0dd2\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"\u0db0\u0db1\u0dcf\u0dad\u0dca\u0db8\u0d9a \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf\u0dc0\u0d9a\u0dca n \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0dc0\u0dd2\u0da7, \u0d85\u0db8\u0dd4 \u0d89\u0dbd\u0d9a\u0dca\u0d9a\u0db8\u0dca \u0dc0\u0dbd \u0d9c\u0dd4\u0dab\u0dba \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1. \u0dc3\u0dd2\u0dba\u0dbd\u0dd4 \u0d89\u0dbd\u0d9a\u0dca\u0d9a\u0db8\u0dca \u0dc3\u0db8 \u0db1\u0db8\u0dca 0 \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab\u0dba\u0d9a\u0dca \u0dbd\u0dd9\u0dc3: \u0d89\u0dbd\u0d9a\u0dca\u0d9a\u0db8\u0dca ((1) == 1 \u0d89\u0dbd\u0d9a\u0dca\u0d9a\u0db8\u0dca ((4) == 0 \u0d89\u0dbd\u0d9a\u0dca\u0d9a\u0db8\u0dca ((235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    \u0db0\u0db1\u0dcf\u0dad\u0dca\u0db8\u0d9a \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf\u0dc0\u0d9a\u0dca n \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0dc0\u0dd2\u0da7, \u0dc3\u0dd3\u0db8\u0dcf\u0dc0 \u0dad\u0dd4\u0dc5\u0da7 \u0dc0\u0dd0\u0da7\u0dd9\u0db1 \u0dc3\u0db8 \u0dc3\u0dc4 \u0d85\u0db8\u0dd4 \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0db4\u0dcf\u0dbd\u0dd2\u0db1\u0dca\u0da9\u0dca \u0dbb\u0ddd\u0db8\u0dca \u0d9c\u0dab\u0db1\u0d9a\u0dca \u0d87\u0dad\u0dd2 \u0da7\u0dd2\u0dba\u0dd4\u0db4\u0dbd\u0dba\u0d9a\u0dca \u0d86\u0db4\u0dc3\u0dd4 \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab\u0dba1: \u0d86\u0daf\u0dcf\u0db1\u0dba: 3 \u0db4\u0dca \u0dbb\u0dad\u0dd2\u0daf\u0dcf\u0db1\u0dba: (1, 2) \u0db4\u0dd0\u0dc4\u0dd0\u0daf\u0dd2\u0dbd\u0dd2 \u0d9a\u0dd2\u0dbb\u0dd3\u0db8: \u0dc3\u0db8 \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0db4\u0dcf\u0dbd\u0dd2\u0db1\u0dca\u0da9\u0dca \u0dbb\u0ddd\u0db8\u0dca 1, 2, 3. \u0d92\u0dc0\u0dcf\u0dba\u0dd2\u0db1\u0dca \u0d91\u0d9a\u0d9a\u0dca \u0dc3\u0db8 \u0dc3\u0dc4 \u0daf\u0dd9\u0d9a\u0d9a\u0dca \u0d85\u0db8\u0dd4 \u0dba. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab\u0dba 2: \u0d86\u0daf\u0dcf\u0db1\u0dba: 12 \u0db4\u0dca \u0dbb\u0dad\u0dd2\u0daf\u0dcf\u0db1\u0dba: (4, 6) \u0db4\u0dd0\u0dc4\u0dd0\u0daf\u0dd2\u0dbd\u0dd2 \u0d9a\u0dd2\u0dbb\u0dd3\u0db8: \u0dc3\u0db8 \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0db4\u0dcf\u0dbd\u0dd2\u0db1\u0dca\u0da9\u0dca \u0dbb\u0ddd\u0db8\u0dca 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. \u0d92\u0dc0\u0dcf\u0dba\u0dd2\u0db1\u0dca \u0dc4\u0dad\u0dbb\u0d9a\u0dca \u0dc3\u0db8 \u0dc3\u0dc4 6 \u0d85\u0db8\u0dd4 \u0dba. \u0dc3\u0da7\u0dc4\u0db1: 1. 1 <= n <= 10^3 2. \u0da7\u0dd2\u0dba\u0dd4\u0db4\u0dbd\u0dba \u0db4\u0dd2\u0dc5\u0dd2\u0dc0\u0dd9\u0dbd\u0dd2\u0db1\u0dca \u0dc3\u0db8 \u0dc3\u0dc4 \u0d85\u0db8\u0dd4 \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0db4\u0dcf\u0dbd\u0dd2\u0db1\u0dca\u0da9\u0dca \u0dbb\u0ddd\u0db8\u0dca \u0d9c\u0dab\u0db1 \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    \u0dab \u0db1\u0ddc\u0dc0\u0db1 \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0dc3\u0db8\u0dd6\u0dc4\u0dba\u0d9a\u0dca \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0dc0\u0dd2\u0da7, \u0d91\u0db8 \u0dc3\u0db8\u0dd6\u0dc4\u0dba\u0dda \u0db4\u0dd2\u0da7\u0db4\u0dad\u0d9a\u0dca \u0db1\u0dd0\u0dc0\u0dad \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1, \u0d94\u0db6 \u0d91\u0db8 \u0dc3\u0db8\u0dd6\u0dc4\u0dba \u0dc0\u0dbb\u0dca\u0db0\u0db1\u0dcf\u0dad\u0dca\u0db8\u0d9a\u0dc0 \u0dc0\u0dbb\u0dca\u0d9c \u0d9a\u0dbb\u0dba\u0dd2, \u0d91\u0db8 \u0dc3\u0db8\u0dd6\u0dc4\u0dba \u0d85\u0db8\u0dd4\u0dad\u0dd4 \u0db1\u0db8\u0dca, \u0dc4\u0ddd \u0d91\u0dba \u0db4\u0dc4\u0dc5\u0da7 \u0dc0\u0dbb\u0dca\u0d9c \u0d9a\u0dbb\u0dba\u0dd2. \u0dc3\u0da7\u0dc4\u0db1: * \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0dc3\u0db8\u0dd6\u0dc4\u0dba \u0dc0\u0dd9\u0db1\u0dc3\u0dca \u0db1\u0ddc\u0d9a\u0dbb\u0db1\u0dca\u0db1. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"\u0d94\u0db6\u0da7 \u0d9a\u0dcf\u0dbd \u0db4\u0dbb\u0dd2\u0da0\u0dca\u0da1\u0dda\u0daf \u0daf\u0dd9\u0d9a\u0d9a\u0dca \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad, \u0d91\u0dc4\u0dd2\u0daf\u0dd3 \u0dc3\u0dd1\u0db8 \u0d9a\u0dcf\u0dbd \u0db4\u0dbb\u0dd2\u0da0\u0dca\u0da1\u0dda\u0daf\u0dba\u0d9a\u0dca\u0db8 \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0dba\u0dd4\u0d9c\u0dbd\u0dba\u0d9a\u0dd2. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab\u0dba\u0d9a\u0dca \u0dbd\u0dd9\u0dc3, \u0d9a\u0dcf\u0dbd \u0db4\u0dbb\u0dd2\u0da0\u0dca\u0da1\u0dda\u0daf\u0dba = (\u0d86\u0dbb\u0db8\u0dca\u0db7\u0dba, \u0d85\u0dc0\u0dc3\u0dcf\u0db1\u0dba) = (1, 2). \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0d9a\u0dcf\u0dbd \u0db4\u0dbb\u0dd2\u0da0\u0dca\u0da1\u0dda\u0daf\u0dba\u0db1\u0dca \u0dc0\u0dc3\u0dcf \u0d87\u0dad, \u0d91\u0dba\u0dd2\u0db1\u0dca \u0d85\u0daf\u0dc4\u0dc3\u0dca \u0dc0\u0db1\u0dca\u0db1\u0dda \u0d9a\u0dcf\u0dbd \u0db4\u0dbb\u0dd2\u0da0\u0dca\u0da1\u0dda\u0daf\u0dba (\u0d86\u0dbb\u0db8\u0dca\u0db7\u0dba, \u0d85\u0dc0\u0dc3\u0dcf\u0db1\u0dba) \u0d86\u0dbb\u0db8\u0dca\u0db7\u0dba \u0dc3\u0dc4 \u0d85\u0dc0\u0dc3\u0dcf\u0db1\u0dba \u0dba\u0db1 \u0daf\u0dd9\u0d9a\u0db8 \u0d87\u0dad\u0dd4\u0dc5\u0dad\u0dca \u0db6\u0dc0\u0dba\u0dd2. \u0dc3\u0dd1\u0db8 \u0dbd\u0db6\u0dcf \u0daf\u0dd3 \u0d87\u0dad\u0dd2 \u0d9a\u0dcf\u0dbd \u0db4\u0dbb\u0dd2\u0da0\u0dca\u0da1\u0dda\u0daf\u0dba\u0d9a\u0dca \u0dc3\u0db3\u0dc4\u0dcf\u0db8, \u0d91\u0dc4\u0dd2 \u0d86\u0dbb\u0db8\u0dca\u0db7\u0dba \u0d91\u0dc4\u0dd2 \u0d85\u0dc0\u0dc3\u0dcf\u0db1\u0dba\u0da7 \u0dc0\u0da9\u0dcf \u0d85\u0da9\u0dd4 \u0dc4\u0ddd \u0dc3\u0db8\u0dcf\u0db1 \u0dba\u0dd0\u0dba\u0dd2 \u0d8b\u0db4\u0d9a\u0dbd\u0dca\u0db4\u0db1\u0dba \u0d9a\u0dd9\u0dbb\u0dda. \u0d94\u0db6\u0dda \u0d9a\u0dcf\u0dbb\u0dca\u0dba\u0dba \u0dc0\u0db1\u0dca\u0db1\u0dda \u0db8\u0dd9\u0db8 \u0d9a\u0dcf\u0dbd \u0db4\u0dbb\u0dd2\u0da0\u0dca\u0da1\u0dda\u0daf \u0daf\u0dd9\u0d9a\u0dda \u0da1\u0dda\u0daf\u0dba\u0dda \u0daf\u0dd2\u0d9c \u0db4\u0dca \u0dbb\u0dcf\u0dae\u0db8\u0dd2\u0d9a \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf\u0dc0\u0d9a\u0dca \u0daf\u0dd0\u0dba\u0dd2 \u0dad\u0dd3\u0dbb\u0dab\u0dba \u0d9a\u0dd2\u0dbb\u0dd3\u0db8\u0dba\u0dd2. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab\u0dba\u0d9a\u0dca \u0dbd\u0dd9\u0dc3, \u0d9a\u0dcf\u0dbd \u0db4\u0dbb\u0dd2\u0da0\u0dca\u0da1\u0dda\u0daf\u0dba\u0db1\u0dca (1, 3), (2, 4) \u0dc4\u0dd2 \u0da1\u0dda\u0daf\u0dba\u0dda \u0daf\u0dd2\u0d9c (2, 3) \u0dc0\u0db1 \u0d85\u0dad\u0dbb \u0d91\u0dc4\u0dd2 \u0daf\u0dd2\u0d9c \u0db4\u0dca \u0dbb\u0dcf\u0dae\u0db8\u0dd2\u0d9a \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf\u0dc0\u0d9a\u0dca \u0db1\u0ddc\u0dc0\u0dda. \u0da1\u0dda\u0daf\u0dba\u0dda\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"string \u0d91\u0d9a\u0d9a\u0dca \u0d85\u0dbb\u0d9c\u0dd9\u0db1 True \u0d91\u0d9a\u0d9a\u0dca \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1 function \u0d91\u0d9a\u0d9a\u0dca \u0dbd\u0dd2\u0dba\u0db1\u0dca\u0db1. string \u0d91\u0d9a \u0db4\u0dca \u0dbb\u0dba\u0dd2\u0db8\u0dca \u0db1\u0db8\u0dca True \u0dc4\u0ddd False \u0db1\u0db8\u0dca False. \u0d8b\u0daf\u0dcf\u0dc4\u0dbb\u0dab prime_length (\u0d85\u0d9a\u0dd4\u0dbb\u0dd4) == True prime_length (\u0d85\u0d9a\u0dd4\u0dbb\u0dd4) == True prime_length (\u0d85\u0d9a\u0dd4\u0dbb\u0dd4) == True prime_length (\u0d85\u0d9a\u0dd4\u0dbb\u0dd4) == True prime_length (\u0d85\u0d9a\u0dd4\u0dbb\u0dd4) == True prime_length (\u0d85\u0d9a\u0dd4\u0dbb\u0dd4) == True prime_length (\u0d85\u0d9a\u0dd4\u0dbb\u0dd4) == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"x \u0dc3\u0dc4 y \u0d85\u0d82\u0d9a \u0daf\u0dd9\u0d9a \u0d91\u0d9a\u0dad\u0dd4 \u0d9a\u0dbb\u0db1\u0dca\u0db1\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" \u062f\u0628\u0631\u064a \u0644\u0646\u062a\u0627\u064a \u0627\u0631\u0642 (\u062f\u0631\u064a \u062f\u0648\u0627 \u0627\u064a\u0644\u064a\u0645\u0646) \u060c \u0645\u06a0\u0627\u062c\u0631 \u06a4\u0645\u0628\u0627\u06a0\u0648\u0646\u0646 \u0644\u064a\u0646\u064a\u0627\u0631 \u0643\u0627\u0648 \u0644\u0646\u062a\u0627\u064a \u06bd\u0648\u0627\u064a\u060c \u062c\u0627\u062f\u064a \u0627\u0631\u0642 \u064a\u06a0 \u0643\u0648\u0631\u064a\u06a0 \u062c\u0627\u0648\u062a \u0643\u0627\u0648 \u0660 \u06a0\u0646 \u064a\u06a0 \u06a4\u0627\u0644\u064a\u06a0 \u0631\u0627\u064a\u064a\u0643 \u062c\u0627\u0648\u062a \u0643\u0627\u0648 \u0661\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    \u062f\u0628\u0631\u064a \u0633\u0627\u0628\u0648\u0647 \u0627\u0631\u0631\u064a \u0627\u0646\u062a\u064a\u06ac\u0631\u0647 \u0646\u0648\u0645\u060c \u062c\u0627\u0648\u062a \u0633\u0648\u0645 \u0645\u064a\u0646\u064a\u0645\u0648\u0645 \u0633\u0627\u0628\u0648\u0647 \u0627\u0631\u0631\u064a \u0646\u0648\u0645 \u064a\u06a0 \u0647\u0627\u0646 \u0628\u064a\u0644\u0627. \u0686\u0648\u0646\u062a\u0648\u0647 minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    \u062f\u0627\u0644\u0645 \u0643\u0627\u062a \u0627\u064a\u0646\u060c \u0643\u0627\u0645\u0648 \u06a4\u0631\u0644\u0648 \u0645\u0646\u0686\u0627\u0631\u064a \u0627\u0631\u0631\u064a \u06a4\u062f \u0627\u0646\u062a\u064a\u06ac\u0631\u064a \u064a\u06a0 \u0647\u0627\u0646 \u0646\u06ac\u0627\u062a\u064a\u0641 \u0628\u0631\u062f\u0627\u0633\u0631\u0643\u0646 \u0643\u0627\u0621\u062f\u0623\u0646 \u0627\u0648\u0646\u062a\u0648\u0642 \u062f\u06a4\u0631\u062a\u064a\u0645\u0628\u06a0\u0643\u0646 \u062f\u0627\u0644\u0645 \u0627\u0648\u0631\u062f\u064a\u0646 \u0628\u0627\u064a\u0646\u0631\u064a \u062f\u0627\u0644\u0645 \u0627\u0648\u0631\u062f\u064a\u0646 \u0645\u06a0\u0648\u0631\u06a0. \u0627\u0648\u0646\u062a\u0648\u0642 \u0643\u0627\u0621\u062f\u0623\u0646 \u064a\u06a0 \u0633\u0627\u0645\u060c \u0645\u0646\u0686\u0627\u0631\u064a \u0628\u0631\u062f\u0627\u0633\u0631\u0643\u0646 \u0642\u062f\u0631 \u062f\u064a\u0633\u064a\u0645\u0644. \u0643\u0627\u0645\u064a \u06a4\u0631\u0644\u0648 \u0645\u0645\u06a4\u0631\u0643\u0646\u0644\u0643\u0646 \u0644\u0627\u06ac\u064a:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    \u0645\u0646\u0648\u0644\u064a\u0633 \u0641\u0627\u0646\u0633\u064a count_nums \u064a\u06a0 \u0645\u06a0\u06ac\u0648\u0646\u0627\u0643\u0646 \u0627\u0631\u0631\u064a \u0627\u0646\u062a\u064a\u06ac\u0631\u0647 \u062f\u0627\u0646 \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 \u06a4\u06a0\u06ac\u0648\u0646\u0623\u0646 \u0627\u064a\u0644\u064a\u0645\u0646 \u064a\u06a0 \u0646\u0627 \u0633\u0648\u0645\u0628\u06a0\u0646 \u062f\u064a\u06ac\u064a\u062a > 0. \u062c\u0643 \u0627\u062f \u0646\u0648\u0645\u0628\u0648\u0631 \u0646\u06ac\u0627\u062a\u064a\u0641\u060c \u0644\u0627\u0644\u0648 \u062f\u064a\u06ac\u064a\u062a \u06a4\u0631\u062a\u0627\u0645 \u064a\u06a0 \u062f\u062a\u0648\u0642\u064a\u06bd \u0627\u0643\u0646 \u062f\u062a\u0648\u0642\u064a \u0646\u06ac\u0627\u062a\u064a\u0641: \u0686\u0648\u0646\u062a\u0648\u0647\u06bd -123 \u0646\u0627 \u062f\u064a\u06ac\u064a\u062a -1, 2\u060c \u062f\u0627\u0646 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    \u062f\u06a4\u0627\u0648\u062f\u06a0 \u06a4\u0648\u0633\u064a\u062a\u064a\u0641 \u0627\u064a\u0646\u062a\u06ac\u0631\u064a n\u060c \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 \u0633\u0628\u0648\u0627\u0647 \u0644\u064a\u0645\u062a \u064a\u06a0 \u062f\u06a4\u0631\u062a\u0648\u0627 \u064a\u06a0 \u062f\u06a4\u0631\u062a\u0648\u0627 \u062f\u0627\u0644\u0645 \u0633\u064a\u06a9\u0648\u064a\u064a\u0646\u0633 \u0643\u0648\u0644\u0627\u062a\u0632. \u0643\u0648\u0646\u0686\u064a\u062a\u0631 \u0643\u0648\u0644\u0627\u062a\u0632 \u0627\u062f\u0627\u0644\u0647 \u0643\u0648\u0646\u0686\u064a\u062a\u0631 \u062f\u0627\u0644\u0645 \u0645\u0627\u062a\u0645\u0627\u062a\u064a\u0643 \u064a\u06a0 \u0628\u0631\u062a\u0646\u062a\u06a0\u0646 \u062f\u06a0\u0646 \u0633\u064a\u06a9\u0648\u064a\u064a\u0646\u0633 \u064a\u06a0 \u062f\u06a4\u0631\u062a\u0648\u0627 \u062f\u06a0\u0646 \u0686\u0627\u0631\u0627 \u064a\u06a0 \u062f\u06a4\u0631\u062a\u0648\u0627: \u0645\u0648\u0644\u0627 \u062f\u06a0\u0646 \u0633\u0645\u0648\u0627 \u0627\u064a\u0646\u062a\u06ac\u0631\u064a \u06a4\u0648\u0633\u064a\u062a\u064a\u0641 n. \u0644\u0627\u0644\u0648 \u0633\u062a\u064a\u0627\u06a4 \u0627\u0635\u0637\u0644\u0627\u062d \u062f\u06a4\u064a\u0644\u064a\u0647 \u062f\u0631\u064a \u0633\u064a\u06a9\u0648\u064a\u064a\u0646\u0633 \u064a\u06a0 \u0633\u0628\u0644\u0648\u0645\u06bd \u0633\u06a4\u0631\u062a\u064a \u064a\u06a0 \u062f\u06a4\u0631\u062a\u0648\u0627: \u0627\u06a4\u0627\u0628\u064a\u0644\u0627 \u0633\u064a\u06a9\u0648\u064a\u064a\u0646\u0633 \u0633\u0628\u0644\u0648\u0645\u06bd \u0627\u062f\u0627\u0644\u0647 \u06a4\u0648\u0631\u060c \u0633\u064a\u06a9\u0648\u064a\u064a\u0646\u0633 \u064a\u06a0 \u0633\u0628\u0644\u0648\u0645\u06bd \u0627\u062f\u0627\u0644\u0647 \u06a4\u0648\u0644\u0633 \u0633\u064a\u06a9\u0648\u064a\u064a\u0646\u0633 \u064a\u06a0 \u0633\u0628\u0644\u0648\u0645\u06bd \u0627\u062f\u0627\u0644\u0647 3 \u0643\u0627\u0644\u064a \u0633\u064a\u06a9\u0648\u064a\u064a\u0646\u0633 \u06a4\u0648\u0631 \u062f\u06a4\u0631\u062a\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" \u0643\u0648\u0646\u0643\u0627\u062a\u064a\u0646\u0627\u062a \u0644\u064a\u0647\u062a \u0633\u062a\u0631\u0627\u064a\u0646 \u062f\u0627\u0644\u0645 \u0633\u0627\u062a\u0648 \u0633\u062a\u0631\u0627\u064a\u0646\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" \u06a4\u06a0\u0627\u0631\u0647 \u06a4\u06a0\u0627\u0631\u0647 \u0627\u064a\u0646 \u0627\u062f\u0627\u0644\u0647 \u0633\u0648\u0631\u062a \u064a\u06a0 \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 \u0628\u0628\u0631\u0627\u06a4 \u06ac\u0631\u0648\u06a4 \u0627\u0648\u0646\u062a\u0648\u0642 \u06a4\u06a0\u0627\u0631\u0647 \u064a\u06a0 \u062f\u06a4\u0631\u062a\u0648\u0627\u0646 \u0627\u06ac\u0648\u06a0 \u064a\u06a0 \u062f\u06a4\u0631\u0628\u0627\u06ac\u0627\u064a\u0643\u0646 \u0627\u0648\u0644\u064a\u0647 \u06a4\u06a0\u0627\u0631\u0647. \u0627\u0648\u0646\u062a\u0648\u0642 \u0633\u062a\u064a\u0627\u06a4 \u06ac\u0631\u0648\u06a4\u060c \u06a4\u06a0\u0627\u0631\u0647 \u06a4\u06a0\u0627\u0631\u0647 \u06a4\u06a0\u0627\u0631\u0647 \u06a4\u06a0\u0627\u0631\u0647 \u064a\u06a0 \u06a4\u0627\u0644\u064a\u06a0 \u062f\u0627\u0644\u0645. \u0686\u0648\u0646\u062a\u0648\u0647\u06bd (() (()) \u0645\u0645\u06a4\u0648\u06bd\u0627\u0621\u064a \u0645\u0627\u06a9\u0633\u064a\u0645\u0627 \u062f\u0648\u0627 \u06a4\u06a0\u0627\u0631\u0647 \u06a4\u06a0\u0627\u0631\u0647 \u062f\u0631\u06a4\u062f ((())) \u0645\u0645\u06a4\u0648\u06bd\u0627\u0621\u064a \u062a\u064a\u06ac.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"\u0645\u0631\u0648\u06a4\u0627\u0643\u0646 \u06a4\u0631\u0646\u0647 \u062c\u0627\u0648\u0647 \u062c\u0643 \u06a4\u06bd\u0648\u0643\u0648\u06a0 \u062f\u0628\u0631\u064a\u0643\u0646\u060c \u062f\u0627\u0646 \u06a4\u06a0\u0643\u0643\u0648\u062a\u0646 \u0644\u0627\u06ac\u064a.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"\u062f\u06a4\u0627\u0648\u06ac\u064a\u062a \u0633\u0627\u0628\u0648\u0647 \u0627\u064a\u0646\u062a\u06ac\u0631\u064a. \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 \u0633\u0627\u0628\u0648\u0647 \u062a\u0648\u06a4\u0644 \u064a\u06a0 \u0646\u0627 \u0644\u064a\u06a0\u0643\u0648\u06a0\u0646 \u062f\u064a\u06ac\u064a\u062a \u06a4\u0648\u0646 \u062f\u0627\u0646 \u06a4\u0648\u0646. \u0686\u0648\u0646\u062a\u0648\u0647: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" \u062f\u0628\u0631\u064a \u0633\u062a\u0631\u0627\u064a\u0646\u060c \u062c\u0627\u062f\u064a\u0643\u0646 \u0644\u064a \u0643\u0627\u0631\u0627\u0643\u062a\u0631 \u064a\u06a0 \u0628\u0631\u0628\u064a\u062f\u0627 (\u0644\u0627\u06a4\u0631\u0643\u0646\u0644\u0647 \u0643\u064a\u0633) \u062c\u064a\u0647 \u062a\u0631\u0645\u0627\u0633\u0648\u0642 \u062f\u0631\u064a\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"\u062f\u06a4\u0627\u0648\u06ac\u064a\u062a \u06a4\u0648\u0633\u064a\u062a\u064a\u0641 \u0627\u064a\u0646\u062a\u06ac\u0631 n\u060c \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 \u06a4\u0631\u0648\u062f\u0648\u0643 \u062f\u064a\u06ac\u064a\u062a \u06a4\u0631\u06ac\u064a. \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 0 \u062c\u0643 \u0633\u0645\u0648\u0627 \u062f\u064a\u06ac\u064a\u062a \u0627\u062f\u0627\u0644\u0647 \u06a4\u0631\u06ac\u064a. \u0686\u0648\u0646\u062a\u0648\u0647\u06bd: \u062f\u064a\u06ac\u064a\u062a\u0633 ((1) == 1 \u062f\u064a\u06ac\u064a\u062a\u0633 ((4) == 0 \u062f\u064a\u06ac\u064a\u062a\u0633 ((235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    \u0627\u0643\u0648 \u062f\u0628\u0631\u064a\u0643\u0646 \u0644\u064a\u0633\u062a \u06a4\u06a0\u06ac\u0645\u06a4\u0648\u06a0\u0646. \u0645\u0646\u0648\u0644\u064a\u0633 \u0641\u06a0\u0633\u064a next_smallest (() \u064a\u06a0 \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 \u0627\u064a\u0644\u064a\u0645\u0646 \u0643\u062f\u0648\u0627 \u06a4\u06a0\u06ac\u0645\u06a4\u0648\u06a0\u0646 \u062f\u0627\u0644\u0645 \u0644\u064a\u0633\u062a. \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 \u0646\u064a\u0647 \u062c\u0643 \u0627\u064a\u0644\u064a\u0645\u0646 \u0627\u064a\u062a \u062a\u064a\u062f\u0642 \u0627\u062f. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == \u0647\u064a\u06a0\u06ac \u0627\u062f next_smallest (([1, 1]) == \u0647\u064a\u06a0\u06ac \u0627\u062f\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"\u0641\u0643\u062a\u0648\u0631\u064a\u0644 \u0628\u0631\u0627\u0632\u064a\u0644\u064a \u062f\u062f\u0641\u064a\u0646\u064a\u0633\u064a\u0643\u0646 \u0633\u064a\u0648\u0628\u0627\u06ac\u0648\u0627\u064a: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! \u062f \u0645\u0627\u0646 n > 0\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"\u062c\u0643 \u0643\u064a\u062a \u062f\u0628\u0631\u064a \u062f\u0648\u0627 \u0639\u062f\u062f \u0627\u064a\u0646\u062a\u064a\u062c\u0631 \u06a4\u0648\u0633\u064a\u062a\u064a\u0641 n \u062f\u0627\u0646 m\u060c \u062f\u0627\u0646 \u06a4\u0631\u0643\u0627\u0631\u0627 \u0643\u064a\u062a \u0627\u062f\u0627\u0644\u0647 \u0627\u0648\u0646\u062a\u0648\u0642 \u0645\u06a0\u062d\u0633\u0627\u0628 \u06a4\u0631\u062a\u06a0\u0647\u0646 \u0639\u062f\u062f \u0627\u064a\u0646\u062a\u064a\u062c\u0631 \u062f\u0631\u064a n \u0633\u0645\u06a4\u0627\u064a m (\u062a\u0646\u062a\u0648\u0643\u0646 n \u062f\u0627\u0646 m). \u0645\u06a0\u0648\u0631\u0648\u0646\u0643\u0646 \u062c\u0648\u0627\u06a4\u0646 \u0643\u06a4\u062f \u0639\u062f\u062f \u0627\u064a\u0646\u062a\u064a\u062c\u0631 \u064a\u06a0 \u06a4\u0627\u0644\u064a\u06a0 \u0643\u0648\u0643\u0648\u06a0 \u062f\u0627\u0646 \u0645\u06a0\u0648\u0631\u0648\u0646\u0643\u0646 \u0643\u06a4\u062f \u0639\u062f\u062f \u0628\u0627\u064a\u0646\u0631\u064a. \u062c\u0643 n \u0644\u0628\u064a\u0647 \u0628\u0633\u0631 \u062f\u0631\u064a m\u060c \u0645\u06a0\u0648\u0631\u0648\u0646\u0643\u0646 -1. \u0686\u0648\u0646\u062a\u0648\u0647: rounded_avg ((1\u060c 5) => \"0b11\" rounded_avg ((7\u060c 5) => -1 rounded_avg ((10\u060c 20) => \"0b11\" rounded_avg ((20\u060c 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs \u0645\u0646\u062f\u0627\u0643\u0646 \u0643\u0648\u0627\u064a\u0641\u064a\u0633\u064a\u0646 \u06a4\u0648\u0644\u064a\u0646\u0648\u0645. xs[0] + xs[1] * x + xs[2] * x^2 +.... \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 \u062f\u0631\u064a\u06cf\u064a\u062a\u0627\u062a \u06a4\u0648\u0644\u064a\u0646\u0648\u0645 \u06bd\u0646 \u062f\u0627\u0644\u0645 \u0628\u0646\u062a\u0648\u0642 \u064a\u06a0 \u0633\u0627\u0645.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    \u06a4\u0627\u0648\u0686\u064a\u062a \u062c\u0643 \u062f\u0648\u0627 \u0643\u0627\u062a \u0646\u0627 \u062d\u0631\u0648\u0641 \u064a\u06a0 \u0633\u0627\u0645.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" \u0645\u06a0\u0645\u0628\u064a\u0644 \u0646\u0648\u0645\u0628\u0648\u0631 \"\u062f\u064a\u0644\u064a\u0645\u064a\u062a\u064a\u0631\" \u0627\u0646\u062a\u0627\u0631\u0627 \u0633\u062a\u064a\u0627\u06a4 \u062f\u0648\u0627 \u0627\u064a\u0644\u064a\u0645\u0646 \u064a\u06a0 \u0628\u0631\u062a\u0631\u0627\u06a0\u0643\u062a \u062f\u0631\u064a \u0644\u064a\u0633\u062a \u06a4\u06a0\u0645\u0628\u064a\u0644\u0646 \u2200\u0646\u0648\u0645\u0628\u0648\u0631\"\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"\u0645\u0646\u0648\u0644\u064a\u0633 \u0641\u0627\u0646\u0633\u064a \u064a\u06a0 \u0645\u0646\u0648\u0644\u064a\u0633 \u0644\u0646\u062a\u0627\u064a \u0633\u0648\u0631\u062a \u0633\u0628\u0627\u06ac\u0627\u064a \u06a4\u0627\u0631\u0627\u0645\u064a\u062a\u0631\u060c \u0645\u06a0\u062d\u0630\u0641 \u0633\u0648\u0631\u062a \u064a\u06a0 \u0644\u06a0\u0633\u0648\u06a0\u06bd \u062a\u064a\u062f\u0642 \u0628\u0631\u0628\u064a\u0630\u0627 \u062f\u0631\u064a\u06bd\u060c \u062f\u0627\u0646 \u0645\u06bd\u0631\u0648\u0633\u064a\u06a9\u0646 \u0633\u0648\u0631\u062a \u064a\u06a0 \u062f\u06a4\u0631\u062a\u0648\u0627\u0646 \u0627\u0762\u0648\u06a0 \u062f\u06a0\u0646 \u06a4\u0631\u062a\u0646\u062f\u064a\u06a0\u0646 \u064a\u06a0 \u062f\u06a4\u0631\u062a\u0648\u0627\u0646 \u0627\u0762\u0648\u06a0\u060c \u0633\u0648\u0631\u062a \u0627\u064a\u062a \u0633\u062f\u0627\u06a0\u0644\u0647 \u0633\u0628\u0627\u0762\u0627\u064a \u0633\u0648\u0631\u062a \u0633\u0648\u0631\u062a \u062f\u0627\u0646 \u062a\u064a\u062f\u0642 \u0633\u0628\u0627\u0762\u0627\u064a \u0627\u0631\u0631 \u064a\u06a0 \u062f\u06a4\u0631\u062a\u0648\u0627\u0646 \u0627\u0762\u0648\u06a0\u060c \u062f\u0627\u0646 \u0627\u064a \u0645\u0648\u06a0\u06a9\u064a\u0646 \u0645\u0645\u06a4\u0648\u06bd\u0627\u0621\u064a \u062f\u0648\u06a4\u0644\u064a\u06a9\u064a\u062a. \u0633\u0648\u0631\u062a \u0633\u0648\u0631\u062a \u0627\u064a\u062a \u06a4\u0631\u0644\u0648 \u062f\u06a4\u0631\u062a\u0648\u0627\u0646 \u0627\u0762\u0648\u06a0 \u062f\u06a0\u0646 \u06a4\u0631\u062a\u0646\u062f\u064a\u06a0\u0646 \u0633\u0648\u0631\u062a \u062f\u06a0\u0646 \u06a4\u0631\u062a\u0646\u062f\u064a\u06a0\u0646 \u0633\u0648\u0631\u062a. \u0627\u06a4\u0627\u0628\u064a\u0644\u0627 \u062f\u0648\u0627 \u06a4\u0631\u062a\u0646\u062f\u064a\u06a0\u0646 \u0628\u0631\u0628\u064a\u0630\u0627\u060c \u0633\u0648\u0631\u062a \u0633\u0648\u0631\u062a \u0627\u064a\u062a \u06a4\u0631\u0644\u0648 \u062f\u06a4\u0631\u062a\u0646\u062f\u064a\u06a0\u0646 \u062f\u06a0\u0646\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"\u0645\u0646\u0648\u0644\u064a\u0633 \u0641\u0627\u0646\u0633\u064a \u064a\u06a0 \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 \u06a4\u0631\u0643\u0645\u0628\u0627\u06a0\u0646 \u062f\u0631\u064a 3 \u06a4\u0631\u0645\u064a\u062a \u062f\u0627\u0646 \u0641\u0648\u0644 \u0633\u0647\u064a\u06a0\u06ac \u062a\u064a\u062f\u0642. \u0686\u0648\u0646\u062a\u0648\u0647: is_multiply_prime ((30) == True 30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets \u0627\u062f\u0627\u0644\u0647 \u0633\u062a\u0631\u064a\u06a0 \"(\" \u062f\u0627\u0646 \")\". return True \u0627\u06a4\u0627\u0628\u064a\u0644\u0627 \u0633\u062a\u064a\u0627\u06a4 bracket \u06a4\u0645\u0628\u0648\u0643\u0627\u064a\u0646 \u0627\u062f\u0627\u0644\u0647 \u0628\u0631\u0643\u0627\u0621\u064a\u062a\u0646 \u062f\u06a0\u0646 bracket \u06a4\u0645\u0628\u0648\u0643\u0627\u064a\u0646.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Sa soli vei iko e dua na array ni integers ka o gadreva mo lesu tale na levu ni levu ni integers vakaikuritaki ena ivoli ni ivakatakilakila kece ni naba yadua ena array, ka matataka na 1, -1 se 0.\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Vakasaqara ke sa palindrome na laini ni laini e soli\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Na cakacaka oqo e taura e rua na naba ni vinaka x kei na y ka sa lesu tale na levu duadua na iwiliwili taucoko ni dinau ka tiko ena na range [x, y] wili kina. Kevaka e sega ni dua na naba vakaoqo, sa na qai lesu tale na cakacaka -1.\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Ni sa soli vei iko e dua na laini s kei na dua na naba ni veika bula n, o sa vakacuruma e dua na cakacaka ka lesu mai e dua na lisi ni vosa mai na laini s ka tiko kina na vakau ni vosa n, me rawa ni ra na basika na vosa oqo ena laini s. Kevaka e lala na laini s na kena ibalebale ni dodonu me lesu mai e dua na lisi lala. Nanuma: o na rawa ni nanuma na laini ni curu e tiko ga na matanivola kei na veitawasei.\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Dikeva mada ke tautauvata na matanivola ena rua na vosa.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Sa soli vei iko e dua na lisi ni nabavuni. E gadrevi mo lesu mai na iwiliwili ni nabavuni ena lisi e soli, vakavolivolita na veika yadua ena lisi ki na int e cake ((Ceiling) taumada.\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Na vakasama ni Collatz e dua na vakasama ena fika ka baleta e dua na ituvatuva e vakamacalataki vakaoqo: tekivu ena dua na integer ni vinaka n. Sa qai yadua na vosa e rawati mai na vosa e liu me vaka oqo: kevaka e dua na vosa e liu e tautauvata, na vosa ka tarava e dua na veimama ni vosa e liu. Kevaka e dua na vosa e liu e sega ni tautauvata, na vosa ka tarava e 3 na gauna na vosa e liu ka vakuri 1.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Sa soli vei iko e 2 na vosa. E gadrevi mo lesu tale ki na Dina kevaka na ikarua ni vosa se dua vei ira na kena veimau e dua na substring ena imatai ni vosa cycpattern_check (((\"abcd\",\"abd\") => Lasu cycpattern_check (((\"kalou\",\"ell\") => Dina cycpattern_check (((\"whassup\",\"psus\") => Lasu cycpattern_check (((\"abab\",\"baa\") => Dina cycpattern_check (((\"efef\",\"eeff\") => Lasu cycpattern_check (((hims\",\"simen\") => Dina\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero e taura e dua na lisi ni integers me vaka e dua na curu. e lesu mai na dina kevaka e tiko e rua na iyaya duidui ena lisi ka na levu ni ki na zero, kei na lasu ke sega.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Me caka e dua na cakacaka ka taura e dua na laini ka matataka na yaca ni dua na faile, ka lesu mai 'Io' kevaka na yaca ni faile e donu, ka lesu mai 'Sega' kevaka e sega. E dua na yaca ni faile e okati me donu kevaka ka walega kevaka e taucoko na veika oqo: - E sega ni dodonu me sivia na tolu na digidigi ('0'-'9') ena yaca ni faile. - Na yaca ni faile e tiko kina e dua na tikini '.' - Na substring ni bera na tikini e dodonu me sega ni lala, ka tekivu ena dua na ivola mai na na na latin alphapet ('a'-'z' kei na 'A''-Z'). - Na substring ni oti na tikini e dodonu me dua vei ira oqo: ['txt', 'exe', 'lld'] ivakaraitaki: file_name_check\"{example\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero e taura e dua na lisi ni integers me vaka e dua na curu. e lesu tale na dina kevaka e tiko e tolu na iyaya duidui ena lisi ni iwiliwili ki na zero, kei na lasu ke sega.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels e dua na cakacaka ka taura na wa ka lesu na wa ka sega ni vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Me caka e dua na cakacaka encrypt ka taura e dua na laini me vaka e dua na kena ivakamacala ka lesu mai e dua na laini encrypted vata kei na matanivola sa veisoliyaki. Na matanivola me na veisoliyaki ena dua na sala me vaka na matanivola sa toso sobu ena rua vakaikuritaki ki na rua na vanua. Kena ivakaraitaki: encrypt (('hi') lesu mai 'lm' encrypt (('asdfghjkl') lesu mai 'ewhjklnop' encrypt (('gf') lesu mai 'kj' encrypt (('et') lesu mai 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"Na mataveilawa e dua na tabana ni dua na kau ka tiko kina na sega ni ca na nodes ni integer na nomu itavi me ra digitaka e dua na nodes ka lesu mai. Na nodes ni digitaka e dodonu me na nodes vata kei na lailai sara mada ga na isau. Kevaka e vuqa na nodes vata kei na lailai sara mada ga na isau e kunei lesu mai na nodes ka tiko na lailai sara na ivakatakilakila. Na nodes ni digitaka e dodonu me lesu mai ena dua na lisi, [smallest_value, kena ivakatakilakila ], Kevaka e sega ni dua na isau se na mataveilawa e soli tu, lesu mai []. Kena ivakaraitaki: 1: curu: [4,2,3] Ivakaraitaki: [2, 1] Vakamacala: 2 e tiko na lailai sara mada ga na isau, kei na 2 e tiko na lailai sara na ivakatakilakila. Kena ivakaraitaki\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Me baleta e dua na lisi ni integers, lesu mai e dua na tuple ka tiko e dua na iwiliwili kei na dua na ivoli ni integers kece ena dua na lisi. e dodonu me tautauvata kei na 0 na iwiliwili lala ka dodonu me tautauvata kei na 1 na iwiliwili lala.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Vakalesuya mai e dua na laini e tiko kina na space-delimited na naba tekivu mai na 0 ki na n okati kina.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Na Brazil na factoral e vakamacalataki me vaka: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! na vanua e n > 0 Me kena ivakaraitaki:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Me soli e rua na integers vinaka a kei na b, lesu tale na digits ni se bera ni yaco ena maliwa ni a kei na b, ena kena ivakarau cake. Kena ivakaraitaki: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    E vakadikeva na polynomial vata kei na coefficients xs ena tikina x. lesu xs[0] + xs[1] * x + xs[1] * x ^ 2 +.... xs[n] * x ^ n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    E dua na array ni integer kei na dua na integer vinaka k, lesu mai e dua na lisi ni kena balavu k vata kei na levu duadua na iwiliwili k ena arr. ivakaraitaki1: curu: arr = [-3, -4, 5], k = 3 na isau: [-4, -3, 5] ivakaraitaki2: curu: arr = [4, -4, 4], k = 2 na isau: [4, 4] ivakaraitaki3: curu: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 na isau: [2] Nanuma: 1. na balavu ni na ituvatuva ena tiko ena maliwa ni [1, 1000]. 2. na veika ena na ituvatuva ena tiko ena maliwa ni [-1000, 1000].\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    E dua na laini s, wilika na iwiliwili ni vowels ni uppercase ena na idusidusi ni veibuku. Kena ivakaraitaki: count_upper (('aBCdEf') lesu 1 count_upper (('abcdefg') lesu 0 count_upper (('dBBE') lesu 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Oku soneha ulala wovina viosi, ci fetika lika lolondaka vi kuete etendelo ale etendelo lionduko.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Soneha ocimal\u1ebdho cimue ci tava okuti ci kuata olondondimbukiso violohaku vialua, pole ka ci kuata olondimbukiso violohaku vialua, kuenda ci pondola oku tiuka londimbukiso ya kapiwa. Ocina caco ci lomboloka okuti, olonjanja viosi o sukila oku soneha olondimbukiso violohaku vialua, pole, lalimue eteke o sukila oku soneha olondimbukiso violohaku vialua. Ondimbukiso yaco yi lekisa okuti, olondaka viosi via kapiwamo vi kuete etendelo limuamue. Nda olondimbukiso viaco vi kuete etendelo limuamue, ci lekisa okuti, olondimbukiso viaco via kapiwa lonjila yimue ya litepa. O pondola oku sima okuti, olondimbukiso viosi vi kuete etendelo limuamue.\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero yi tambula ulala wolonduko viosi. yi tiuka lika nda kuli olonduko vitatu via litepa vi kuete ulala wolonduko viosi, kuenje yi tiuka lika nda kuli olonduko vitatu via litepa vi kuete ulala wolonduko viosi.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Soneha ocindekaise cimue ci tava oku sanga ulala wolonduko via litepa. Ocisonehua ci kuete olondaka via litepa. Tioka londaka yi kuete etendelo liololetala via litepa. Nda ovinimbu vialua vi kuete etendelo liololetala via litepa, tioka londuko ya tete yi sangiwa vocisonehua.\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Ocicapa ci lekisa etendelo liolohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violo\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Nda tua sanga ulala wolondimbukiso okuti, vovikanda viaco mu sangiwa lika olonduko, tu sukila oku soneha onduko yaco, kuenda etendelo lionduko yaco.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    O pondola oku sanga olondaka via litepa vovinimbu vimue, kuenje o sukila oku vi pitulula. O pondola oku sanga olondaka via litepa vovinimbu vialua, oku vi pitulula, kuenda oku vi soneha oco vi ku kuatise.\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Oku pitamo kuetendelo limue lia tukuiwa, ci lekisa oku litepa ku kasi pokati ketendelo liaco kuenda etendelo liosimbu.\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Soneha ocindekaise cimue ci lekisa etendelo liololetala kuenda o tiuka londuko ya True nda etendelo liaco li kuete etendelo liokaliye ale False nda etendelo liaco ka li kuete etendelo liokaliye.\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    K\u0169l\u0129h\u0129sa nda olondaka viaco vivali vi kuete elomboloko limuamue.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    O pondola oku sanga ocimal\u1ebdho cimue ci lekisa etendelo liolohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa violohuluwa\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Sanda oku k\u0169l\u0129h\u0129sa nda volonduko violo atendelo mua kongela atendelo avali a velapo okuti etendelo liaco ka li sokisiwa.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"O programa yimue ya leluka yi sukila oku tiula ondando y y nda n yi kuete etendelo liokaliye kuenda yi sukila oku tiula ondando y y nda ka ci t\u1ebdliwa.\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Nda wa sanga etendelo limue liosimbu, o sukila oku li soneha velimi lio Helasi. * Nda wa sanga etendelo liokaliye, o sukila oku li soneha velimi lio Helasi.\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Seteka oku linga ondimbukiso yimue yi lekisa etendelo liololetala, ale olondimbukiso vikuavo vi lekisa etendelo lioci\u00f1a cimue, kuenje o tioka kondimbukiso ya velapo.\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Nda ocimal\u1ebdho cimue ci kuete ocimal\u1ebdho cimuamue, tenda etendelo liololetala vinene vi kuete olonduko via litepa.\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"Olio li tukula etendelo li soka 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Olombinga viatete vi lomboloka 2, 3, 5, 7, 11, 13, 17,... Omo liaco, o sukila oku n\u00f5la etendelo liolombinga viku\u00e3imo: 2, 3, 5, 7, B (= ocimal\u1ebdho 11), D (= ocimal\u1ebdho 13). Ivaluka okuti: O pondola oku sima okuti ocimal\u1ebdho ci kasi ciwa ale ka ci kasi ciwa, kuenda olondimbukiso A,B,C,D,E,F, vi kasi \u00f1o londaka yitito.\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"O sukila oku tiuka ku True nda ondaka yavali ale oku \u00f1ualapo kuayo ku kuete ocimal\u1ebdho cimue ci kasi vocinimbu catete. cycpattern_check{\"abcd\",\"abd\") => False cycpattern_check{\"hello\",\"ell\") => True cycpattern_check{\"whassup\",\"psus\") => False cycpattern_check{\"abab\",\"baa\") => True cycpattern_check{\"efef\",\"eeff\") => False cycpattern_check{\"hims\",\"simen\") => True\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Ocimunga ci kuete atosi a litepa a kapiwa vocinimbu cimue ale vovinimbu vimue, kuenje o ci kapa vocinimbu cimue ale vovinimbu vimue.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Nda tua sanga etendelo limue ka li kuete atendelo osi, tu sukila oku pitulula etendelo liolo atendelo osi a sangiwa ketendelo liatete.\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    \"T\u0259ma\u0257 \u0259nes eqal asikin \u0259n magrad \u0259nes d\u01ce\u0263 magrad \u0259d asikin \u0259nes d\u01ce\u0263 magrad \u0259d asikin \u0259nes d\u01ce\u0263 magrad. \" \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Awen eqqal tiditt a fal iddikud eqqal a ezzaran tolas war eqqel tiditt a fal wadden\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels eqqal alxidm\u0103t ta taj string tolas t asilmad string wala vowels\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Ye ass\u0259k\u0259n atiw\u0259jan \u0259n ma\u0257inan \u0259n ijji, ass\u0259k\u0259n \u0259n ass\u0259m\u0259s\u0259du iknan \u0263or am\u0259k \u0259n am\u0259k \u0259n ass\u0259rtay \u0259n ilavitan. Ass\u0259m\u0259s\u0259du iknan eqal am\u0259grad iknan jar harat\u0259n kul ad edag \u0259n am\u0259k (ad\u0259k\u0259n d\u01ce\u0263 edag wen): MAD = am\u0259k. x - x_mean. Almital:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"Eqal aynayan \u0259sim \u0259n semestre \u0259d emagare ilzam ye ihuk \u0259n edanatan. Emagare iga algorithme \u0259nes fal igi \u0259n edan. A\u0161ahat iyan eqal as taqal ayfan \u0259mik wa eqalan amitkalan fal igi \u0259n edanatan. Iha ali\u0263i \u0259n GPAs fal iyad emagaran \u0259d ilzam adiqil ayktaban \u0259\u0161i\u0263il wa adobat adiqil ali\u0263i \u0259n edanatan \u0259n \u0259li\u0263itan d\u01ce\u0263 amitkal \u0259n tabarat taqalat: GPA. \u018fli\u0263itan \u0259n \u0259li\u0263itan 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: al\u0263isab \u0259n edanatan (..) [4.0, 3, 1.7, 2, 3.5]) ==> ['\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Brazilian factorial eqqal: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! \u0263ur n > 0 almital:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"\"Aqalan atiwafan ima\u0257inan d\u01ce\u0263 \u0259mik \u0259n d\u00e9\u0259imal \u0259d \u0259\u0161i\u0263il iness eqal asimililiy \u0259nes d\u01ce\u0263 \u0259mik \u0259n \u0259sin. A\u0161i\u0263il adiqil ayfan asisuhu \u0259n \u0259mik, d\u01ce\u0263 hak \u0259mik eqalan \u0259mik \u0259n \u0259sin. Hak \u0259mik d\u01ce\u0263 \u0259mik eqalan '0' me\u0263 '1'. Addobat adiqil ayfan \u0259sin \u0259mik \u0259n 'db' d\u01ce\u0263 santo \u0259d d\u01ce\u0263 samando \u0259n \u0259mik. \u018fmik \u0259n \u0259mik eqalan ayfan fal t\u0259muqunt. Almital: d\u00e9\u0259imal_to_binary (_15) # asisuhu \"\"db1111db\"\" d\u00e9\u0259imal_to_binary32) # asisuhu \"\"db100000db\"\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" D\u01ce\u0263 asikin \u0259n tartit \u0259n haratan \u0259n Python atiwafanen fal entiertan \u0263as\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Awen eqqal alxidm\u0103t ta tajjach nen iddikud n ima\u0257inan wi azzarnen n e\u0263af d wi madroynen n almital: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"D\u01ce\u0263 asikin \u0259n asikin \u0259n haratan kul \u0259n haratan d\u01ce\u0263 edag iyan d\u01ce\u0263 alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n alma\u0263na \u0259n al\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    Isasa\u0263ra \u0259mik \u0259n ams\u0259du \u0259n ams\u0259du \u0259n ams\u0259du \u0259n ams\u0259du \u0259n ams\u0259du \u0259n ams\u0259du \u0259n ams\u0259du \u0259n ams\u0259du \u0259n ams\u0259du \u0259n ams\u0259du.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"\u018flk\u0259ttab \u0259n \u0259\u0161i\u0263il itaj\u0259n tab\u0259de \u0259n ma\u0257inan sund ijji \u0259n edaj ad ass\u0259m\u0259du \u0259n ma\u0257inan \u0259n tab\u0259de ogarnen 10 ad haratan azarnen ad samdo \u0259n ma\u0257inan aqalan ams\u0259du (1, 3, 5, 7, 9). sund specialFilter ([15, -73, 14, -15]) => 1 specialFilter ([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Isuj win isuj n ismawan win tizarat s tizarat s tizarat n string n asuj\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Fibonacci eqqal a fal ijja majrad n matematik da\u0263 iwityan win u\u0161ray mucham awa war n issen addinat eqqal Tribonacci Sequence. Tribonacci Sequence eqqal a fal ijja majrad n tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri: tri\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Awen eqqal iddikud n alwaq wa id iddikud n 7 eqqal iddikud n iddikud n addikud andarran n n a tan osa\u0263nen s 11 me\u0263 13\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" D\u01ce\u0263 asikin \u0259n es\u0257an, af\u0259nazat ma\u0257inan \u0259n edan\u0259n azlaynen (d\u01ce\u0263 iba \u0259n \u0259mik) \u0259n es\u0257an\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Ilzam ad ikteb alxidmat ta tikna am\u0161\u01ddkki n data tolas ad t id isammuti tiditt a fal am\u0161\u01ddkki wen eqqal am\u0161\u01ddkki n data fal war eqqel am\u0161\u01ddkki n data eqqalan am\u0161\u01ddkki n data a fal fal ilzam achare\u0263a tan win fuk: 1. am\u0161\u01ddkki wan data war eqqel ebas 2. iddikud n awtay war ifnaz fal 1 me\u0263 ojjar 31 n awtay i awtay wan 1,3,5,7,8,10,12 d iddikud n awtay war ifnaz fal 1 me\u0263 ojjar 30 n awtay i awtay wan 4,6,9,11 d iddikud n awtay war ifnaz fal 1 me\u0263 ojjar 29 i awtay wan 2 3. awtay war addobat ad ifnaz fal 1 me\u0263 ojjar 12 4. am\u0161\u01ddkki wan data ilzam ad eqqil da\u0263 dumu: mm-dd-\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Eqal \u0259\u0161i\u0263il wa itagan ima\u0257inan \u0259mdanen, \u0259mik \u0259n t\u0259zunawen me\u0263 \u0259mik \u0259n t\u0259zunawen \u0259n haditan \u0259knanen, \u0259d wa isaknen awa ogaran t\u0259m\u0263ire d\u01ce\u0263 \u0259mik \u0259n t\u0259zunawen \u0259nes. Winan ila harat afal hadi aqalan ogdahan.\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"\"Aqalan atiwafanen \u0259sin \u0259\u0161\u0259\u0263ir s \u0259d c, ilzam ad ekfu \u0259\u0161\u0259\u0263ir kul \u0259n \u0259\u0161\u0259\u0263ir s eqalan ogdahan \u0259d \u0259\u0161\u0259\u0263ir c, izar anhiy as \u0259\u0161\u0259\u0263ir wa eqalan \u0259\u0161\u0259\u0263ir eqal palindrome. \u0259\u0161\u0259\u0263ir eqal asitawan palindrome afal eqalan olahan d\u01ce\u0263 a\u015bahat \u0259d d\u01ce\u0263 a\u015bahat. A\u015bahat adiqil adiqil aykan tuple ahanen \u0259\u0161\u0259\u0263ir wa eqalan \u0259\u0161\u0259\u0263ir \u0259d tidit\/tabarat fal asikin. Almital fal s = \"\"abcde\"\", c = \"\"ae\"\", agaraw adiqil (\"bcd\"\",Tid\u0259t) fal s = \"\"abcdef\"\", c = \"\"b\"\" agaraw adiqil (\"acdef\"\",Tid\u0259t) fal s = \"\"\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"A fal eqqal string eha tijililw\u0103yen ti madroynen azz\u0103rnen s am\u0103dal, is\u0103lan ti alma\u0263na n tijililw\u0103yen ti illanen am\u0103tikwi d id\u0103g\u0103n n id\u0103g\u0103n win alma\u0263na wen. A fal ti illan ti tijililw\u0103yen ajjotnen, is\u0103lan ti fuk nasan. almit\u0103l: histogram ((a b c) == {'a': 1, 'b': 1, 'c': 1} histogram ((a b b a') == {'a': 2, 'b': 2} histogram ((a b c a b') == {'a': 2, 'b': 2} histogram ((b b a') == {'b 4}: histogram (('a') == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"\u018flk\u0259ttab \u0259n \u0259\u0161i\u0263il itaj\u0259n ass\u0259rtay \u0259n t\u0259zunt \u0259n t\u0259zunt.T\u0259zunt t\u0259la ismawan abdanen.\u018flk\u0259ttab \u0259n t\u0259zunt \u0259n t\u0259zunt \u0259n t\u0259zunt \u0259n t\u0259zunt \u0259n t\u0259zunt \u0259n t\u0259zunt \u0259n t\u0259zunt \u0259n t\u0259zunt \u0259n t\u0259zunt \u0259n t\u0259zunt.\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nAwen eqqal a ehan edag n asidu n isalan\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"D\u01ce\u0263 \u0259\u0161i\u0263il wen, \u0259mik eqalan \u0259sin ma\u0257inan wi \u0259knanen x \u0259d y \u0259d isaknin ogaran t\u0259m\u0263ire ama\u0257in \u0259mdan d\u01ce\u0263 tartit [x, y] d\u01ce\u0263 tartit. Afal wala iyan ma\u0257inan, \u0259\u0161i\u0263il adiqil aygan -1. sund: ali\u0263i_ima\u0257inan 12, 15 = 14 ali\u0263i_ima\u0257inan 13, 12 = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"\u0623\u0639\u0637\u064a\u062a \u0631\u0642\u0645 \u0635\u062d\u064a\u062d \u0645\u0648\u062c\u0628 n\u060c \u0627\u0631\u062c\u0639 \u0636\u0631\u0628 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0627\u0644\u0641\u0631\u062f\u064a\u0629. \u0627\u0631\u062c\u0639 0 \u0625\u0630\u0627 \u0643\u0627\u0646\u062a \u062c\u0645\u064a\u0639 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0632\u0648\u062c\u064a\u0629. \u0639\u0644\u0649 \u0633\u0628\u064a\u0644 \u0627\u0644\u0645\u062b\u0627\u0644: \u0627\u0644\u0623\u0631\u0642\u0627\u0645 ((1) == 1 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 ((4) == 0 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 ((235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels \u0647\u0648 \u062f\u0627\u0644\u0629 \u062a\u0623\u062e\u0630 \u0627\u0644\u0633\u0644\u0633\u0644\u0629 \u0648\u062a\u0639\u064a\u062f \u0627\u0644\u0633\u0644\u0633\u0644\u0629 \u0628\u062f\u0648\u0646 \u062d\u0631\u0648\u0641 \u0639\u0644\u0629.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    \u0645\u0639 \u0645\u062c\u0645\u0648\u0639\u0629 \u0645\u0646 \u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629 \u063a\u064a\u0631 \u0627\u0644\u0633\u0627\u0644\u0628\u0629\u060c \u0627\u0631\u062c\u0639 \u0646\u0633\u062e\u0629 \u0645\u0646 \u0627\u0644\u0645\u062c\u0645\u0648\u0639\u0629 \u0627\u0644\u0645\u062d\u062f\u062f\u0629 \u0628\u0639\u062f \u0627\u0644\u062a\u0631\u062a\u064a\u0628\u060c \u0633\u062a\u0642\u0648\u0645 \u0628\u062a\u0631\u062a\u064a\u0628 \u0627\u0644\u0645\u062c\u0645\u0648\u0639\u0629 \u0627\u0644\u0645\u062d\u062f\u062f\u0629 \u0628\u0627\u0644\u062a\u0631\u062a\u064a\u0628 \u0627\u0644\u0635\u0627\u0639\u062f \u0625\u0630\u0627 \u0643\u0627\u0646\u062a \u0627\u0644\u0645\u062c\u0645\u0648\u0639\u0629 ((\u0642\u064a\u0645\u0629 \u0627\u0644\u0645\u0624\u0634\u0631 \u0627\u0644\u0623\u0648\u0644\u0649\u060c \u0627\u0644\u0642\u064a\u0645\u0629 \u0627\u0644\u0645\u0624\u0634\u0631 \u0627\u0644\u0623\u062e\u064a\u0631\u0629) \u0641\u0631\u064a\u062f\u0629\u060c \u0623\u0648 \u062a\u0631\u062a\u064a\u0628\u0647\u0627 \u0628\u0627\u0644\u062a\u0631\u062a\u064a\u0628 \u0627\u0644\u0647\u0627\u0628\u0637 \u0625\u0630\u0627 \u0643\u0627\u0646\u062a \u0627\u0644\u0645\u062c\u0645\u0648\u0639\u0629 ((\u0642\u064a\u0645\u0629 \u0627\u0644\u0645\u0624\u0634\u0631 \u0627\u0644\u0623\u0648\u0644\u0649\u060c \u0627\u0644\u0642\u064a\u0645\u0629 \u0627\u0644\u0645\u0624\u0634\u0631 \u0627\u0644\u0623\u062e\u064a\u0631\u0629) \u0632\u0648\u062c\u064a\u0629. \u0645\u0644\u0627\u062d\u0638\u0629: * \u0644\u0627 \u062a\u063a\u064a\u0631 \u0627\u0644\u0645\u062c\u0645\u0648\u0639\u0629 \u0627\u0644\u0645\u062d\u062f\u062f\u0629. \u0623\u0645\u062b\u0644\u0629: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" \u0644\u0648 \u0627\u0639\u0637\u064a\u062a \u0642\u0627\u0626\u0645\u0629 \u0645\u0646 \u0627\u0644\u0627\u0631\u0642\u0627\u0645 (\u0645\u0646 \u0639\u0646\u0635\u0631\u064a\u0646 \u0639\u0644\u0649 \u0627\u0644\u0627\u0642\u0644) \u060c \u0627\u0637\u0644\u0628 \u062a\u062d\u0648\u064a\u0644 \u062e\u0637\u064a \u0639\u0644\u0649 \u062a\u0644\u0643 \u0627\u0644\u0642\u0627\u0626\u0645\u0629\u060c \u0628\u062d\u064a\u062b \u064a\u0635\u0628\u062d \u0623\u0635\u063a\u0631 \u0631\u0642\u0645 0 \u0648\u0627\u0644\u0623\u0643\u0628\u0631 \u064a\u0635\u0628\u062d 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    \u0633\u062a\u0639\u0637\u064a\u0643 \u0633\u0644\u0633\u0644\u0629 \u0643\u0644\u0645\u0627\u062a\u060c \u0648\u0645\u0647\u0645\u062a\u0643 \u0647\u064a \u062d\u0633\u0627\u0628 \u0639\u062f\u062f \u0627\u0644\u0645\u0645\u0644\u0627\u062a. \u0627\u0644\u0645\u0645\u0644\u0629 \u0647\u064a \u062c\u0645\u0644\u0629 \u062a\u0628\u062f\u0623 \u0628\u0627\u0644\u0643\u0644\u0645\u0629 \"I\".\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" \u0637\u0648\u0644 \u0627\u0644\u0639\u0648\u062f\u0629 \u0644\u0644\u0633\u0644\u0633\u0644\u0629 \u0627\u0644\u0645\u0639\u0637\u0627\u0629\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"\u0627\u0643\u062a\u0628 \u062f\u0627\u0644\u0629 \u062a\u0623\u062e\u0630 \u0633\u0644\u0633\u0644\u0629 \u0643\u0645\u062f\u062e\u0644 \u0648\u062a\u0639\u064a\u062f \u0645\u062c\u0645\u0648\u0639 \u0627\u0644\u062d\u0631\u0648\u0641 \u0627\u0644\u0639\u0644\u064a\u0627 \u0641\u0642\u0637' \u0631\u0645\u0648\u0632 ASCII. \u0623\u0645\u062b\u0644\u0629: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"\u0627\u0643\u062a\u0628 \u0648\u0638\u064a\u0641\u0629 \u062a\u0634\u0641\u064a\u0631 \u062a\u0623\u062e\u0630 \u0633\u0644\u0633\u0644\u0629 \u0643\u062d\u0631\u0641 \u0648\u062a\u0639\u064a\u062f \u0633\u0644\u0633\u0644\u0629 \u0645\u0634\u0641\u0631\u0629 \u0645\u0639 \u062a\u062f\u0648\u064a\u0631 \u0627\u0644\u0623\u0628\u062c\u062f\u064a\u0629. \u064a\u062c\u0628 \u062a\u062f\u0648\u064a\u0631 \u0627\u0644\u0623\u0628\u062c\u062f\u064a\u0629 \u0628\u0637\u0631\u064a\u0642\u0629 \u062a\u062a\u062d\u0648\u0644 \u0627\u0644\u062d\u0631\u0648\u0641 \u0625\u0644\u0649 \u0623\u0633\u0641\u0644 \u0628\u0645\u0636\u0627\u0639\u0641\u0629 \u0627\u062b\u0646\u064a\u0646 \u0625\u0644\u0649 \u0645\u0643\u0627\u0646\u064a\u0646. \u0639\u0644\u0649 \u0633\u0628\u064a\u0644 \u0627\u0644\u0645\u062b\u0627\u0644: \u062a\u0634\u0641\u064a\u0631 ((('hi') \u064a\u0639\u064a\u062f 'lm' \u062a\u0634\u0641\u064a\u0631 ((('asdfghjkl') \u064a\u0639\u064a\u062f 'ewhjklnop' \u062a\u0634\u0641\u064a\u0631 ((('gf') \u064a\u0639\u064a\u062f 'kj' \u062a\u0634\u0641\u064a\u0631 ((('et') \u064a\u0639\u064a\u062f 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    \u0645\u0639 \u0639\u062f\u062f \u0635\u062d\u064a\u062d \u0645\u0648\u062c\u0628 n\u060c \u0627\u0631\u062c\u0639 \u062a\u0648\u0628\u0644 \u064a\u062d\u062a\u0648\u064a \u0639\u0644\u0649 \u0639\u062f\u062f \u0645\u0646 palindromes \u0627\u0644\u0635\u062d\u064a\u062d\u0629 \u0648\u0627\u0644\u063a\u0631\u064a\u0628\u0629 \u0627\u0644\u062a\u064a \u062a\u0642\u0639 \u0641\u064a \u0627\u0644\u0646\u0637\u0627\u0642 ((1\u060c n) \u060c \u0628\u0645\u0627 \u0641\u064a \u0630\u0644\u0643. \u0645\u062b\u0627\u06441: \u0627\u0644\u0645\u062f\u062e\u0644: 3 \u0627\u0644\u0646\u0627\u062a\u062c: (1, 2) \u0627\u0644\u062a\u0641\u0633\u064a\u0631: \u0639\u062f\u062f \u0635\u062d\u064a\u062d \u0647\u0648 1\u060c 2\u060c 3. \u0648\u0627\u062d\u062f \u0645\u0646\u0647\u0645 \u0632\u0648\u062c\u060c \u0648\u0627\u062b\u0646\u064a\u0646 \u0645\u0646\u0647\u0645 \u063a\u0631\u064a\u0628. \u0645\u062b\u0627\u06442: \u0645\u062f\u062e\u0644: 12 \u0627\u0644\u0646\u0627\u062a\u062c: (4, 6) \u0627\u0644\u062a\u0641\u0633\u064a\u0631: \u0639\u062f\u062f \u0635\u062d\u064a\u062d \u0647\u0648 1\u060c 2\u060c 3\u060c 4\u060c 5\u060c 6\u060c 7\u060c 8\u060c 9\u060c 11. \u0623\u0631\u0628\u0639\u0629 \u0645\u0646\u0647\u0645 \u0632\u0648\u062c\u064a\u0646\u060c \u0648 6 \u0645\u0646\u0647\u0645 \u063a\u0631\u064a\u0628\u064a\u0646. \u0645\u0644\u0627\u062d\u0638\u0629: 1 <= n <= 10^3 2. \u062a\u0648\u0628\u0644 \u0642\u062f \u0639\u0627\u062f \u0639\u062f\u062f \u0639\u062f\u062f \u0635\u062d\u064a\u062d \u0648\u0641\u0627\u0631\u0642 \u0628\u0627\u0644\u062a\u0631\u062a\u064a\u0628.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" \u0627\u062e\u062a\u0628\u0627\u0631 \u0627\u0630\u0627 \u0627\u0644\u0633\u0644\u0633\u0644\u0629 \u0627\u0644\u0645\u0639\u0637\u0627\u0629 \u0628\u0627\u0644\u0646\u062f\u0631\u0648\u0645 \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    \u062a\u062e\u064a\u0644 \u0637\u0631\u064a\u0642 \u0645\u0633\u062a\u0642\u064a\u0645 \u062c\u062f\u0627\u064b. n \u0633\u064a\u0627\u0631\u0627\u062a \u062a\u0633\u064a\u0631 \u0645\u0646 \u0627\u0644\u064a\u0633\u0627\u0631 \u0627\u0644\u0649 \u0627\u0644\u064a\u0645\u064a\u0646\u060c \u0648\u0641\u064a \u0646\u0641\u0633 \u0627\u0644\u0648\u0642\u062a \u0645\u062c\u0645\u0648\u0639\u0629 \u0645\u062e\u062a\u0644\u0641\u0629 \u0645\u0646 n \u0633\u064a\u0627\u0631\u0627\u062a \u062a\u0633\u064a\u0631 \u0645\u0646 \u0627\u0644\u064a\u0645\u064a\u0646 \u0627\u0644\u0649 \u0627\u0644\u064a\u0633\u0627\u0631. \u0645\u062c\u0645\u0648\u0639\u062a\u064a\u0646 \u0645\u0646 \u0627\u0644\u0633\u064a\u0627\u0631\u0627\u062a \u062a\u0628\u062f\u0627 \u0628\u0639\u064a\u062f\u0629 \u062c\u062f\u0627\u064b \u0639\u0646 \u0628\u0639\u0636\u0647\u0627 \u0627\u0644\u0628\u0639\u0636. \u0643\u0644 \u0627\u0644\u0633\u064a\u0627\u0631\u0627\u062a \u062a\u062a\u062d\u0631\u0643 \u0628\u0646\u0641\u0633 \u0627\u0644\u0633\u0631\u0639\u0629. \u064a\u0642\u0627\u0644 \u0627\u0646 \u0633\u064a\u0627\u0631\u062a\u064a\u0646 \u062a\u062a\u0635\u0627\u062f\u0645 \u0639\u0646\u062f\u0645\u0627 \u062a\u0635\u0637\u062f\u0645 \u0633\u064a\u0627\u0631\u0629 \u062a\u062a\u062d\u0631\u0643 \u0645\u0646 \u0627\u0644\u064a\u0633\u0627\u0631 \u0627\u0644\u0649 \u0627\u0644\u064a\u0645\u064a\u0646 \u0628\u0633\u064a\u0627\u0631\u0629 \u062a\u062a\u062d\u0631\u0643 \u0645\u0646 \u0627\u0644\u064a\u0645\u064a\u0646 \u0627\u0644\u0649 \u0627\u0644\u064a\u0633\u0627\u0631. \u0648\u0645\u0639 \u0630\u0644\u0643\u060c \u0627\u0644\u0633\u064a\u0627\u0631\u0627\u062a \u0642\u0648\u064a\u0629 \u0627\u0644\u0649 \u0645\u0627 \u0644\u0627 \u0646\u0647\u0627\u064a\u0629\u061b \u0648\u0646\u062a\u064a\u062c\u0629 \u0644\u0630\u0644\u0643\u060c \u0641\u0647\u064a \u062a\u0633\u062a\u0645\u0631 \u0641\u064a \u0627\u0644\u062a\u062d\u0631\u0643 \u0641\u064a \u0645\u0633\u0627\u0631\u0647\u0627 \u0643\u0645\u0627 \u0644\u0648 \u0644\u0645 \u062a\u062a\u0635\u0627\u062f\u0645. \u0647\u0630\u0647 \u0627\u0644\u062f\u0627\u0644\u0629 \u062a\u0635\u062f\u0631 \u0639\u062f\u062f \u0645\u062b\u0644 \u0647\u0630\u0647 \u0627\u0644\u062a\u0635\u0627\u062f\u0645\u0627\u062a.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"\u0645\u0639 \u0648\u062c\u0648\u062f \u0642\u0627\u0626\u0645\u0629 \u063a\u064a\u0631 \u0641\u0627\u0631\u063a\u0629 \u0645\u0646 \u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629\u060c \u0627\u0636\u0641 \u0627\u0644\u0639\u0646\u0627\u0635\u0631 \u0627\u0644\u0632\u0648\u062c\u064a\u0629 \u0627\u0644\u062a\u064a \u0641\u064a \u0627\u0644\u0645\u0624\u0634\u0631\u0627\u062a \u0627\u0644\u0641\u0631\u062f\u064a\u0629. \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" \u0641\u0644\u062a\u0631 \u0627\u0644\u0642\u0627\u0626\u0645\u0629 \u0627\u0644\u0645\u0642\u062f\u0645\u0629 \u0645\u0646 \u0623\u064a \u0642\u064a\u0645\u0629 \u0628\u0627\u064a\u062b\u0648\u0646 \u0644\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629 \u0641\u0642\u0637\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    \u0645\u0639\u0637\u0648\u0641 \u0639\u0644\u0649 \u0635\u0641 \u0645\u0646 \u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629\u060c \u0631\u062a\u0628 \u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629 \u0627\u0644\u062a\u064a \u062a\u062a\u0631\u0627\u0648\u062d \u0628\u064a\u0646 1 \u0648 9\u060c \u0648 \u0639\u0643\u0633 \u0627\u0644\u0645\u0635\u0641 \u0627\u0644\u0646\u0627\u062a\u062c\u060c \u062b\u0645 \u0627\u0633\u062a\u0628\u062f\u0644 \u0643\u0644 \u0631\u0642\u0645 \u0628\u0627\u0633\u0645\u0647 \u0627\u0644\u0645\u0642\u0627\u0628\u0644\u0629 \u0645\u0646 \"\u0648\u0627\u062d\u062f\"\u060c \"\u0627\u062b\u0646\u064a\u0646\"\u060c \"\u062b\u0644\u0627\u062b\u0629\"\u060c \"\u0623\u0631\u0628\u0639\u0629\"\u060c \"\u062e\u0645\u0633\u0629\"\u060c \"\u0633\u062a\u0629\"\u060c \"\u0633\u0628\u0639\u0629\"\u060c \"\u062b\u0645\u0627\u0646\u064a\u0629\"\u060c \"\u062a\u0633\u0639\u0629\". \u0639\u0644\u0649 \u0633\u0628\u064a\u0644 \u0627\u0644\u0645\u062b\u0627\u0644: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> \u0631\u062a\u0628 arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> arr \u0639\u0643\u0633 -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"\u062b\u0645\u0627\u0646\u064a\u0629\"\u060c \"\u0623\u0631\u0628\u0639\u0629\"\u060c \"\u062b\u0644\u0627\u062b\u0629\"\u060c \"\u0627\u062b\u0646\u064a\u0646\"\u060c \"\u0627\u062b\u0646\u064a\u0646\"\u060c \"\u0627\u062b\u0646\u064a\u0646\"\u060c \"\u0648\u0627\u062d\u062f\"\u060c \"\u0648\u0627\u062d\u062f\"] \u0625\u0630\u0627 \u0643\u0627\u0646 \u0627\u0644\u0645\u0635\u0641 \u0641\u0627\u0631\u063a\u064b\u0627\u060c \u0627\u0631\u062c\u0639 \u0635\u0641 \u0641\u0627\u0631\u063a: arr = [] return [] \u0625\u0630\u0627 \u0643\u0627\u0646 \u0627\u0644\u0645\u0635\u0641 \u0644\u062f\u064a\u0647 \u0623\u064a\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n \u0647\u0648 \u062f\u0627\u0644\u0629 \u062a\u0636\u064a\u0641 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0645\u0646 1 \u0625\u0644\u0649 n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" \u0644\u0644\u064a\u0633\u062a \u0627\u0644\u0645\u0639\u0637\u0649 \u0645\u0646 \u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629\u060c \u0627\u0631\u062c\u0639 \u062a\u0648\u0628\u0644 \u064a\u062a\u0643\u0648\u0646 \u0645\u0646 \u0645\u062c\u0645\u0648\u0639 \u0648\u0645\u0636\u0627\u0639\u0641 \u0644\u0643\u0644 \u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629 \u0641\u064a \u0627\u0644\u0642\u0627\u0626\u0645\u0629. \u0627\u0644\u0645\u062c\u0645\u0648\u0639 \u0627\u0644\u0641\u0627\u0631\u063a \u064a\u062c\u0628 \u0623\u0646 \u064a\u0643\u0648\u0646 \u064a\u0633\u0627\u0648\u064a 0 \u0648\u0627\u0644\u0645\u0636\u0627\u0639\u0641 \u0627\u0644\u0641\u0627\u0631\u063a \u064a\u062c\u0628 \u0623\u0646 \u064a\u0643\u0648\u0646 \u064a\u0633\u0627\u0648\u064a 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"\u0627\u0643\u062a\u0628 \u062f\u0627\u0644\u0629 \u062a\u0642\u0628\u0644 \u0642\u0627\u0626\u0645\u0629 \u0645\u0646 \u0627\u0644\u0633\u0644\u0627\u0633\u0644. \u0627\u0644\u0642\u0627\u0626\u0645\u0629 \u062a\u062d\u062a\u0648\u064a \u0639\u0644\u0649 \u0643\u0644\u0645\u0627\u062a \u0645\u062e\u062a\u0644\u0641\u0629. \u0627\u0631\u062c\u0639 \u0627\u0644\u0643\u0644\u0645\u0629 \u0645\u0639 \u0627\u0644\u062d\u062f \u0627\u0644\u0623\u0642\u0635\u0649 \u0644\u0639\u062f\u062f \u0627\u0644\u0623\u062d\u0631\u0641 \u0627\u0644\u0641\u0631\u064a\u062f\u0629. \u0625\u0630\u0627 \u0643\u0627\u0646 \u0647\u0646\u0627\u0643 \u0639\u062f\u062f \u0645\u0646 \u0627\u0644\u0633\u0644\u0627\u0633\u0644 \u0645\u0639 \u0627\u0644\u062d\u062f \u0627\u0644\u0623\u0642\u0635\u0649 \u0644\u0639\u062f\u062f \u0627\u0644\u0623\u062d\u0631\u0641 \u0627\u0644\u0641\u0631\u064a\u062f\u0629\u060c \u0627\u0631\u062c\u0639 \u0623\u0648\u0644 \u062d\u0631\u0641 \u0641\u064a \u0627\u0644\u062a\u0631\u062a\u064a\u0628 \u0627\u0644\u0645\u0641\u0631\u062f.\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    \u0645\u0639 \u0639\u062f\u062f \u0635\u062d\u064a\u062d \u0645\u062b\u0628\u062a n\u060c \u0627\u0631\u062c\u0639 \u0642\u0627\u0626\u0645\u0629 \u0645\u0631\u062a\u0628\u0629 \u0641\u064a\u0647\u0627 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0627\u0644\u063a\u064a\u0631 \u0639\u0627\u062f\u0644\u0629 \u0641\u064a \u062a\u0633\u0644\u0633\u0644 \u0643\u0648\u0644\u0627\u062a\u0632. \u062a\u062e\u0645\u064a\u0646 \u0643\u0648\u0644\u0627\u062a\u0632 \u0647\u0648 \u062a\u062e\u0645\u064a\u0646 \u0641\u064a \u0627\u0644\u0631\u064a\u0627\u0636\u064a\u0627\u062a \u064a\u062a\u0639\u0644\u0642 \u0628\u062a\u0633\u0644\u0633\u0644 \u0645\u062d\u062f\u062f \u0639\u0644\u0649 \u0627\u0644\u0646\u062d\u0648 \u0627\u0644\u062a\u0627\u0644\u064a: \u0627\u0628\u062f\u0623 \u0628\u0623\u064a \u0639\u062f\u062f \u0635\u062d\u064a\u062d \u0645\u062b\u0628\u062a n. \u062b\u0645 \u0643\u0644 \u0645\u0635\u0637\u0644\u062d \u064a\u062a\u0645 \u0627\u0644\u062d\u0635\u0648\u0644 \u0639\u0644\u064a\u0647 \u0645\u0646 \u0627\u0644\u0645\u0635\u0637\u0644\u062d \u0627\u0644\u0633\u0627\u0628\u0642 \u0639\u0644\u0649 \u0627\u0644\u0646\u062d\u0648 \u0627\u0644\u062a\u0627\u0644\u064a: \u0625\u0630\u0627 \u0643\u0627\u0646 \u0627\u0644\u0645\u0635\u0637\u0644\u062d \u0627\u0644\u0633\u0627\u0628\u0642 \u0632\u0648\u062c\u060c \u0627\u0644\u0645\u0635\u0637\u0644\u062d \u0627\u0644\u062a\u0627\u0644\u064a \u0647\u0648 \u0646\u0635\u0641 \u0627\u0644\u0645\u0635\u0637\u0644\u062d \u0627\u0644\u0633\u0627\u0628\u0642. \u0625\u0630\u0627 \u0643\u0627\u0646 \u0627\u0644\u0645\u0635\u0637\u0644\u062d \u0627\u0644\u0633\u0627\u0628\u0642 \u0641\u0631\u064a\u062f\u060c \u0627\u0644\u0645\u0635\u0637\u0644\u062d \u0627\u0644\u062a\u0627\u0644\u064a \u0647\u0648 3 \u0645\u0631\u0627\u062a \u0627\u0644\u0645\u0635\u0637\u0644\u062d \u0627\u0644\u0633\u0627\u0628\u0642 \u0632\u0627\u0626\u062f 1. \u0627\u0644\u062a\u062e\u0645\u064a\u0646 \u0647\u0648 \u0623\u0646\u0647 \u0628\u063a\u0636 \u0627\u0644\u0646\u0638\u0631 \u0639\u0646 \u0642\u064a\u0645\u0629 n\u060c \u0633\u064a\u062a\u0645 \u0627\u0644\u0648\u0635\u0648\u0644 \u0625\u0644\u0649 1. \u0645\u0644\u0627\u062d\u0638\u0629: 1. \u0643\u0648\u0644\u0627\u062a\u0632 (((1) \u0647\u0648 [1]. 2. \u0627\u0644\u0642\u0627\u0626\u0645\u0629 \u0627\u0644\u0645\u0631\u062c\u0639\u0629 \u0645\u0631\u062a\u0628\u0629 \u0628\u062a\u0631\u062a\u064a\u0628 \u0645\u062a\u0632\u0627\u064a\u062f. \u0639\u0644\u0649 \u0633\u0628\u064a\u0644 \u0627\u0644\u0645\u062b\u0627\u0644: get_odd_collatz (((5) \u064a\u0639\u064a\u062f [1, 5] # \u062a\u0633\u0644\u0633\u0644 \u0643\u0648\u0644\u0627\u062a\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"\u0647\u0630\u0647 \u0627\u0644\u0648\u0638\u064a\u0641\u0629 \u062a\u0623\u062e\u0630 \u0642\u0627\u0626\u0645\u0629 l \u0648\u062a\u0639\u064a\u062f \u0642\u0627\u0626\u0645\u0629 l' \u0628\u062d\u064a\u062b \u062a\u0643\u0648\u0646 l' \u0645\u062a\u0637\u0627\u0628\u0642\u0629 \u0645\u0639 l \u0641\u064a \u0627\u0644\u0645\u0624\u0634\u0631\u0627\u062a \u0627\u0644\u0641\u0631\u062f\u064a\u0629\u060c \u0628\u064a\u0646\u0645\u0627 \u0642\u064a\u0645\u0647\u0627 \u0641\u064a \u0627\u0644\u0645\u0624\u0634\u0631\u0627\u062a \u0627\u0644\u0632\u0648\u062c\u064a\u0629 \u062a\u0633\u0627\u0648\u064a \u0642\u064a\u0645 \u0627\u0644\u0645\u0624\u0634\u0631\u0627\u062a \u0627\u0644\u0632\u0648\u062c\u064a\u0629 \u0644\u0640 l\u060c \u0648\u0644\u0643\u0646 \u0645\u0631\u062a\u0628\u0629.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    \u0627\u0643\u062a\u0628 \u062f\u0627\u0644\u0629 \u062a\u0623\u062e\u0630 \u0633\u0644\u0633\u0644\u0629 \u0648\u062a\u0631\u062c\u0639 \u0646\u0633\u062e\u0629 \u0645\u0631\u062a\u0628\u0629 \u0645\u0646\u0647\u0627. \u0646\u0633\u062e\u0629 \u0645\u0631\u062a\u0628\u0629 \u0645\u0646 \u0633\u0644\u0633\u0644\u0629\u060c \u0647\u064a \u0633\u0644\u0633\u0644\u0629 \u062d\u064a\u062b \u064a\u062a\u0645 \u0627\u0633\u062a\u0628\u062f\u0627\u0644 \u0643\u0644 \u0627\u0644\u0643\u0644\u0645\u0627\u062a (\u0645\u0641\u0635\u0648\u0644\u0629 \u0639\u0646 \u0637\u0631\u064a\u0642 \u0627\u0644\u0641\u0631\u0627\u063a) \u0628\u0643\u0644\u0645\u0629 \u062c\u062f\u064a\u062f\u0629 \u062d\u064a\u062b \u064a\u062a\u0645 \u062a\u0631\u062a\u064a\u0628 \u062c\u0645\u064a\u0639 \u0627\u0644\u062d\u0631\u0648\u0641 \u0628\u062a\u0631\u062a\u064a\u0628 \u062a\u0635\u0627\u0639\u062f\u064a \u0628\u0646\u0627\u0621 \u0639\u0644\u0649 \u0642\u064a\u0645\u0629 ascii. \u0645\u0644\u0627\u062d\u0638\u0629: \u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u0627\u0644\u0627\u062d\u062a\u0641\u0627\u0638 \u0628\u062a\u0631\u062a\u064a\u0628 \u0627\u0644\u0643\u0644\u0645\u0627\u062a \u0648\u0627\u0644\u0641\u0631\u0627\u063a\u0627\u062a \u0627\u0644\u0641\u0627\u0631\u063a\u0629 \u0641\u064a \u0627\u0644\u062c\u0645\u0644\u0629. \u0639\u0644\u0649 \u0633\u0628\u064a\u0644 \u0627\u0644\u0645\u062b\u0627\u0644: anti_shuffle ((('Hi') \u064a\u0631\u062c\u0639 'Hi' anti_shuffle ((('hello') \u064a\u0631\u062c\u0639 'ehllo' anti_shuffle (('Hello World!!!') \u064a\u0631\u062c\u0639 'Hello!!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" \u0627\u0644\u0645\u062f\u062e\u0644\u0627\u062a \u0647\u064a \u0633\u0644\u0633\u0644\u062a\u064a\u0646 a \u0648 b \u062a\u062a\u0643\u0648\u0646 \u0645\u0646 1 \u0648 0 \u0641\u0642\u0637. \u0642\u0645 \u0628\u062a\u0646\u0641\u064a\u0630 XOR \u062b\u0646\u0627\u0626\u064a \u0639\u0644\u0649 \u0647\u0630\u0647 \u0627\u0644\u0645\u062f\u062e\u0644\u0627\u062a \u0648 \u0627\u0631\u062c\u0639 \u0627\u0644\u0646\u062a\u064a\u062c\u0629 \u0643\u0633\u0644\u0633\u0644\u0629.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" \u0642\u0648\u0633\u064a\u0646 \u0647\u0648 \u0633\u0644\u0633\u0644\u0629 \u0645\u0646 \"<\" \u0648 \">\". return True \u0627\u0630\u0627 \u0643\u0644 \u0642\u0648\u0633 \u0627\u0641\u062a\u062a\u0627\u062d\u064a\u0629 \u0644\u0647\u0627 \u0642\u0648\u0633 \u0627\u063a\u0644\u0627\u0642 \u0645\u062a\u0637\u0627\u0628\u0642.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    \u0645\u0639 \u0648\u062c\u0648\u062f \u0635\u0641 \u063a\u064a\u0631 \u0641\u0627\u0631\u063a \u0645\u0646 \u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629 arr \u0648 k\u060c \u0627\u0631\u062c\u0639 \u0645\u062c\u0645\u0648\u0639 \u0627\u0644\u0639\u0646\u0627\u0635\u0631 \u0645\u0639 \u0631\u0642\u0645\u064a\u0646 \u0643\u062d\u062f \u0623\u0642\u0635\u0649 \u0645\u0646 \u0627\u0644\u0639\u0646\u0627\u0635\u0631 k \u0627\u0644\u0623\u0648\u0644\u0649 \u0645\u0646 arr. \u0645\u062b\u0627\u0644: \u0627\u0644\u0645\u062f\u062e\u0644\u0627\u062a: arr = [111,21,3,4000,5,6,7,8,9], k = 4 \u0627\u0644\u0646\u0627\u062a\u062c: 24 # \u0645\u062c\u0645\u0648\u0639 21 + 3 \u0627\u0644\u0642\u064a\u0648\u062f: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"\u2d54\u2d30\u2d37 \u2d5c\u2d5c\u2d53\u2d3c\u2d3d\u2d30 \u2d62\u2d49\u2d59\u2d4e \u2d4f \u2d5c\u2d54\u2d4e\u2d5c (\u2d5c\u2d30\u2d4f\u2d33\u2d33\u2d30) \u2d37 \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d49\u2d59\u2d56\u2d63\u2d4f. \u2d49\u2d59\u2d56\u2d63\u2d4f\u2d4f \u2d30\u2d37 \u2d5c\u2d5c\u2d53\u2d59\u2d4e\u2d54\u2d30\u2d59\u2d4f \u2d49 \u2d53\u2d59\u2d59\u2d3d\u2d5b\u2d4e \u2d4f \u2d5c\u2d54\u2d4e\u2d49\u2d4f \u2d62\u2d30\u2d39\u2d4f\u2d49\u2d4f \u2d59 \u2d5c\u2d54\u2d4e\u2d5c. \u2d5c\u2d30\u2d37\u2d53\u2d59\u2d49 \u2d4f \u2d53\u2d59\u2d56\u2d63\u2d4f \u2d5c\u2d33\u2d30 \u2d63\u2d53\u2d4f\u2d37 \u2d30\u2d62\u2d30: \u2d30\u2d37 \u2d5c\u2d33 CAP \u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d5c\u2d30\u2d4e\u2d47\u2d55\u2d30\u2d4f\u2d5c \u2d33 \u2d62\u2d49\u2d59\u2d4e \u2d4f \u2d53\u2d59\u2d56\u2d63\u2d4f, \u2d37 \u2d30\u2d37 \u2d5c\u2d33 SM \u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d4f \u2d5c\u2d49\u2d54\u2d54\u2d30 \u2d5c\u2d30\u2d4e\u2d65\u2d65\u2d62\u2d30\u2d4f\u2d5c \u2d33 \u2d62\u2d49\u2d59\u2d4e \u2d4f \u2d53\u2d59\u2d56\u2d63\u2d4f, \u2d5c\u2d30\u2d37\u2d53\u2d59\u2d49 \u2d5c\u2d5c\u2d53\u2d3c\u2d3d\u2d30 \u2d59 \u2d5c\u2d3d\u2d54\u2d54\u2d30 CAP - SM. \u2d54\u2d30\u2d37 \u2d5c\u2d59\u2d59\u2d53\u2d3c\u2d56 \u2d5c\u2d30\u2d37\u2d53\u2d59\u2d49 \u2d5c\u2d30\u2d45\u2d30\u2d5c\u2d30\u2d54\u2d5c \u2d37 \u2d5c\u2d54\u2d4e\u2d5c \u2d33 \u2d53\u2d59\u2d56\u2d63\u2d4f \u2d30\u2d37: ClassName.StrongestExtensionName. \u2d49\u2d56 \u2d33\u2d30\u2d4f \u2d59\u2d49\u2d4f \u2d49\u2d59\u2d56\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"\u2d49\u2d33 \u2d37\u2d30\u2d54\u2d59 \u2d62\u2d30\u2d4f \u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d30\u2d4e\u2d37\u2d37\u2d30\u2d37, \u2d30\u2d54 \u2d49\u2d59\u2d59\u2d3d\u2d5b\u2d4e \u2d5c\u2d30\u2d31\u2d4d\u2d53\u2d5c \u2d4f\u2d4f\u2d30 \u2d33 \u2d4d\u2d4d\u2d30\u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d49\u2d4e\u2d4e\u2d54\u2d61\u2d30\u2d59\u2d4f \u2d37 \u2d61\u2d49\u2d4f \u2d61\u2d49\u2d4f \u2d61\u2d49\u2d4f \u2d61\u2d30\u2d54 \u2d30\u2d4e\u2d37\u2d62\u2d30: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"\u2d30\u2d54 \u2d49\u2d5c\u2d5c\u2d54\u2d30\u2d54 \u2d49\u2d3c\u2d54\u2d37\u2d49\u2d59\u2d4f \u2d49\u2d4e\u2d62\u2d49\u2d61\u2d4f\u2d4f \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d4e\u2d49\u2d4d\u2d4f \u2d33 \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" \u2d30\u2d59\u2d3d\u2d5b\u2d4e \u2d59 \u2d5c\u2d30\u2d61\u2d53\u2d54\u2d49 \u2d30\u2d37 \u2d49\u2d33\u2d30 \u2d62\u2d30\u2d4f \u2d53\u2d3d\u2d5b\u2d5b\u2d4e \u2d4f\u2d4f\u2d30 \u2d33 \u2d4d\u2d4d\u2d30\u2d4f\u2d5c \u2d3d\u2d49\u2d33\u2d30\u2d4f \u2d4f \u2d5c\u2d54\u2d53\u2d31\u2d31\u2d30 \u2d4f \u2d5c\u2d31\u2d55\u2d30\u2d4f\u2d3d\u2d49\u2d59\u2d49\u2d4f \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d4e\u2d33\u2d30\u2d4d\u2d4f. \u2d30\u2d61\u2d5c\u2d5c\u2d30\u2d59 \u2d4f\u2d4f\u2d3d \u2d49\u2d33\u2d30 \u2d30\u2d37 \u2d5c\u2d31\u2d39\u2d49\u2d37 \u2d5c\u2d54\u2d53\u2d31\u2d31\u2d30 \u2d30\u2d37 \u2d33 \u2d5c\u2d49\u2d31\u2d55\u2d30\u2d4f\u2d3d\u2d49\u2d59\u2d49\u2d4f \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d4e\u2d33\u2d30\u2d4d\u2d4f \u2d37 \u2d30\u2d37 \u2d5c\u2d54\u2d30\u2d54 \u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d5c\u2d31\u2d55\u2d30\u2d4f\u2d3d\u2d49\u2d59\u2d49\u2d4f \u2d30\u2d37. \u2d5c\u2d49\u2d31\u2d55\u2d30\u2d4f\u2d3d\u2d49\u2d59\u2d49\u2d4f \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d4e\u2d33\u2d30\u2d4d\u2d4f (\u2d62\u2d30\u2d5c\u2d5c\u2d53\u2d62 \u2d49\u2d4a\u2d4a \u2d4f \u2d53\u2d3d\u2d5b\u2d5b\u2d4e \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d4e\u2d33\u2d30\u2d4d\u2d4f) \u2d37 \u2d53\u2d54 \u2d5c\u2d5c\u2d53\u2d59\u2d4e\u2d33\u2d30\u2d4d\u2d4f \u2d33 \u2d53\u2d33\u2d4f\u2d59\u2d53 \u2d4f \u2d3d\u2d54\u2d30 \u2d62\u2d33\u2d30\u2d5c\u2d5c \u2d62\u2d30\u2d4f. \u2d53\u2d54 \u2d5c\u2d59\u2d59\u2d4f \u2d3d\u2d54\u2d30 \u2d4f \u2d61\u2d30\u2d4f\u2d59\u2d30 \u2d33 \u2d53\u2d3d\u2d5b\u2d5b\u2d4e \u2d4f \u2d5c\u2d31\u2d55\u2d30\u2d4f\u2d3d\u2d49\u2d59\u2d5c. \u2d30\u2d4e\u2d37\u2d62\u2d30:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"\u2d59\u2d59\u2d3d\u2d54 \u2d5c\u2d30\u2d61\u2d53\u2d54\u2d49 \u2d4f\u2d4f\u2d30 \u2d49\u2d5c\u2d5c\u2d53\u2d4e\u2d65\u2d4f \u2d30\u2d4e\u2d39\u2d30\u2d4f \u2d30\u2d4e\u2d37\u2d37\u2d30\u2d37 \u2d53\u2d54 \u2d49\u2d54\u2d49\u2d4f \u2d37 \u2d30\u2d54 \u2d49\u2d5c\u2d5c\u2d30\u2d3d\u2d3d\u2d30 \u2d62\u2d30\u2d4f \u2d53\u2d59\u2d4f\u2d59\u2d4d \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d49\u2d4e\u2d63\u2d61\u2d53\u2d54\u2d30 \u2d4f\u2d4f\u2d30 \u2d49\u2d33\u2d30\u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f\u2d4f \u2d49\u2d4e\u2d63\u2d61\u2d53\u2d54\u2d30 \u2d37 \u2d49\u2d4e\u2d65\u2d65\u2d49\u2d4f\u2d4f \u2d4f\u2d49\u2d33 \u2d4f n. \u2d59 \u2d53\u2d4e\u2d37\u2d62\u2d30: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    \u2d49\u2d33 \u2d37\u2d30\u2d54\u2d3d \u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d30\u2d4e\u2d37\u2d37\u2d30\u2d37 \u2d30\u2d4e\u2d4f\u2d49\u2d33, \u2d59\u2d59\u2d53\u2d5c\u2d54 \u2d30\u2d4e\u2d62\u2d30\u2d61\u2d30\u2d59 \u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f \u2d55\u2d53\u2d4e\u2d30\u2d4f \u2d59 \u2d5c\u2d30\u2d4d\u2d56\u2d30 \u2d4f \u2d53\u2d3d\u2d5c\u2d53\u2d4e, \u2d37 \u2d59\u2d59\u2d53\u2d3c\u2d56 \u2d59 \u2d49\u2d4e\u2d37\u2d62\u2d30\u2d61\u2d4f \u2d49\u2d4e\u2d65\u2d65\u2d49\u2d4f. \u2d5c\u2d49\u2d4e\u2d65\u2d30: 1 <= num <= 1000 \u2d49\u2d4e\u2d37\u2d62\u2d30\u2d5c\u2d4f:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"\u2d30\u2d37 \u2d4f\u2d54\u2d30\u2d54 \u2d30\u2d4e\u2d33\u2d33\u2d30\u2d54\u2d53 \u2d30\u2d4e\u2d63\u2d61\u2d30\u2d54\u2d53 \u2d30\u2d45\u2d30\u2d5c\u2d30\u2d54 \u2d4f n. \u2d4f\u2d59\u2d59\u2d4f \u2d49\u2d59 n > 1 \u2d37 \u2d53\u2d54 \u2d49\u2d33\u2d49 \u2d30\u2d4e\u2d63\u2d61\u2d30\u2d54\u2d53.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"\u2d30\u2d56\u2d30\u2d61\u2d30\u2d59 \u2d30\u2d4e\u2d62\u2d49\u2d61\u2d4f \u2d4f\u2d4f\u2d30 \u2d49\u2d47\u2d47\u2d30\u2d4f \u2d30\u2d37 \u2d62\u2d30\u2d3d\u2d3d\u2d30 \u2d30\u2d5c\u2d49\u2d33 \u2d4f x \u2d4e\u2d3d \u2d49\u2d33\u2d30 n \u2d30\u2d4e\u2d39\u2d30\u2d4f \u2d30\u2d4e\u2d63\u2d61\u2d30\u2d54\u2d53, \u2d37 \u2d49\u2d47\u2d47\u2d30\u2d4f \u2d30\u2d37 \u2d62\u2d30\u2d3d\u2d3d\u2d30 \u2d30\u2d5c\u2d49\u2d33 \u2d4f y \u2d4e\u2d3d \u2d53\u2d54 \u2d49\u2d33\u2d49. \u2d49\u2d4e\u2d37\u2d62\u2d30\u2d5c\u2d4f: \u2d49 x_or_y{7, 34, 12) == 34 \u2d49 x_or_y{15, 8, 5) == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero \u2d37\u2d30 \u2d49\u2d5c\u2d5c\u2d30\u2d4e\u2d65 \u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d30\u2d4e\u2d4e \u2d53\u2d3d\u2d5b\u2d5b\u2d53\u2d4e. \u2d37\u2d30 \u2d62\u2d30\u2d3d\u2d3d\u2d30 \u2d5c\u2d49\u2d37\u2d5c \u2d4e\u2d3d \u2d4d\u2d4d\u2d30\u2d4f \u2d59\u2d49\u2d4f \u2d49\u2d3c\u2d54\u2d37\u2d49\u2d59\u2d4f \u2d49\u2d4e\u2d63\u2d30\u2d54\u2d30\u2d62\u2d4f \u2d33 \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f\u2d4f\u2d30 \u2d49\u2d5c\u2d5c\u2d4e\u2d53\u2d4f\u2d4f \u2d59 \u2d53\u2d4e\u2d62\u2d30, \u2d37 \u2d5c\u2d49\u2d37\u2d5c \u2d4e\u2d3d \u2d53\u2d54 \u2d49\u2d4d\u2d4d\u2d49.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"\u2d37\u2d30 \u2d5c\u2d5c\u2d53\u2d3c\u2d3d\u2d30 \u2d49 \u2d3d\u2d54\u2d30 \u2d4f \u2d53\u2d61\u2d49\u2d3d\u2d49\u2d4d s. \u2d4e\u2d3d \u2d5c\u2d33\u2d30 s[i] \u2d62\u2d30\u2d5c \u2d5c\u2d31\u2d54\u2d30\u2d5c, \u2d59\u2d59\u2d53\u2d5c\u2d4d \u2d5c\u2d30\u2d61\u2d49\u2d3d\u2d49\u2d4d\u2d5c \u2d4f\u2d4f\u2d59 \u2d59\u2d33 \u2d37\u2d37\u2d30\u2d61 \u2d59 \u2d30\u2d3c\u2d4d\u2d4d\u2d30 \u2d4f\u2d56\u2d37 \u2d59 \u2d53\u2d31\u2d54\u2d30\u2d54\u2d33, \u2d4e\u2d3d \u2d53\u2d54 \u2d5c\u2d4d\u2d4d\u2d30. \u2d4e\u2d3d \u2d53\u2d54 \u2d5c\u2d4d\u2d4d\u2d30 \u2d33 \u2d53\u2d61\u2d49\u2d3d\u2d49\u2d4d \u2d3d\u2d54\u2d30 \u2d4f \u2d5c\u2d31\u2d54\u2d30\u2d5c\u2d49\u2d4f, \u2d59\u2d59\u2d53\u2d5c\u2d4d \u2d5c\u2d30\u2d61\u2d49\u2d3d\u2d49\u2d4d\u2d5c. \u2d5c\u2d30\u2d61\u2d61\u2d53\u2d54\u2d49 \u2d30\u2d37 \u2d5c\u2d54\u2d30 \u2d30\u2d37 \u2d5c\u2d59\u2d3d\u2d54 \u2d5c\u2d30\u2d61\u2d49\u2d3d\u2d49\u2d4d\u2d5c \u2d4f\u2d4f\u2d30 \u2d37 \u2d62\u2d53\u2d5b\u2d3d\u2d30\u2d4f. \u2d49\u2d4e\u2d37\u2d62\u2d30\u2d5c\u2d4f solve{\"1234\") = \"4321\"{\"ab\") = \"AB\"{\"#a@C\") = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs \u2d37\u2d30 \u2d49\u2d59\u2d4e\u2d37\u2d62\u2d30 \u2d49\u2d4e\u2d59\u2d3d\u2d30\u2d54\u2d4f \u2d4f \u2d3d\u2d49\u2d33\u2d30\u2d4f \u2d4f \u2d49\u2d59\u2d3d\u2d3d\u2d49\u2d4d\u2d4f. xs[0] + xs[1] * x + xs[2] * x^2 +.... \u2d37\u2d30 \u2d49\u2d5c\u2d5c\u2d54\u2d30\u2d54 \u2d5c\u2d30\u2d59\u2d4f\u2d3c\u2d4d\u2d53\u2d4d\u2d5c \u2d4f \u2d3d\u2d49\u2d33\u2d30\u2d4f \u2d4f \u2d49\u2d59\u2d3d\u2d3d\u2d49\u2d4d\u2d4f \u2d59 \u2d62\u2d30\u2d5c \u2d5c\u2d30\u2d4d\u2d56\u2d30.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" \u2d30\u2d59\u2d3d\u2d5b\u2d4e \u2d49\u2d33\u2d30 \u2d62\u2d30\u2d4f \u2d53\u2d3d\u2d5b\u2d5b\u2d53\u2d4e \u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d59\u2d33 \"\u2d59\u2d62\u2d30\" \u2d30\u2d54 \"\u2d5c\u2d65\u2d30\". \u2d49\u2d59\u2d5c\u2d30\u2d62\u2d4f \u2d49\u2d63\u2d54\u2d3c\u2d30\u2d4f \u2d33\u2d30\u2d4f \"\u2d59\u2d62\u2d30\", \"\u2d62\u2d49\u2d61\u2d4f\", \" \u2d59\u2d49\u2d4f\", \" \u2d3d\u2d55\u2d30\u2d39\", \"\u2d3d\u2d3d\u2d53\u2d65\", \"\u2d4e\u2d4e\u2d53\u2d59\", \"\u2d5a\u2d39\u2d49\u2d5a\", \"\u2d30\u2d59\u2d59\u2d30\", \"\u2d30\u2d59\u2d30\" \u2d37 \"\u2d5c\u2d65\u2d30\". \u2d37\u2d30 \u2d49\u2d5c\u2d5c\u2d54\u2d30\u2d54 \u2d53\u2d3d\u2d5b\u2d5b\u2d53\u2d4e \u2d59 \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d4e\u2d49\u2d4d\u2d4f \u2d59\u2d33 \u2d49\u2d4e\u2d65\u2d65\u2d62\u2d30\u2d4f\u2d4f \u2d30\u2d54 \u2d49\u2d4e\u2d47\u2d47\u2d54\u2d30\u2d4f\u2d4f.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets \u2d49\u2d33\u2d30 \u2d62\u2d30\u2d4f \u2d53\u2d61\u2d49\u2d3d\u2d49 \u2d4f \"(\" \u2d37 \"\". return True \u2d4e\u2d3d \u2d37\u2d30 \u2d5c\u2d4d\u2d4d\u2d30 \u2d3d\u2d53 \u2d5c\u2d30\u2d61\u2d49\u2d3d\u2d49\u2d5c \u2d4f \u2d53\u2d55\u2d65\u2d65\u2d53\u2d4e \u2d37 \u2d5c\u2d65\u2d55\u2d49\u2d33\u2d5c \u2d4f \u2d53\u2d47\u2d47\u2d4f.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    \u2d37\u2d30 \u2d5c\u2d5c\u2d53\u2d3c\u2d3d\u2d30 \u2d49 \u2d3d\u2d53 \u2d62\u2d30\u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f n. \u2d49\u2d47\u2d47\u2d30\u2d4f \u2d37 \u2d30\u2d37 \u2d5c\u2d59\u2d59\u2d3d\u2d54\u2d37 \u2d62\u2d30\u2d4f \u2d53\u2d59\u2d4f\u2d59\u2d4d \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f a \u2d4f \u2d5c\u2d49\u2d56\u2d63\u2d49 n. \u2d49 \u2d3d\u2d53 i (1 \u00e2\u2030\u00a4 i \u00e2\u2030\u00a4 n), \u2d30\u2d5c\u2d49\u2d33 \u2d4f a[i] = i * i - i + 1. \u2d30\u2d54\u2d4f \u2d49\u2d3d\u2d3d\u2d30 \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d4e\u2d54\u2d4f (a[i], a[j], a[k]) \u2d4f a \u2d33 i < j < k, \u2d37 a[i] + a[j] + a[k] \u2d49\u2d33\u2d30 \u2d30\u2d4e\u2d33\u2d33\u2d30\u2d54\u2d53 \u2d4f 3. \u2d30\u2d4e\u2d37\u2d62\u2d30: Input: n = 5 Output: 1 \u2d30\u2d59\u2d3c\u2d54\u2d53: a = [1, 3, 7, 13, 21] \u2d30\u2d4e\u2d33\u2d33\u2d30\u2d54\u2d53 \u2d30\u2d4e\u2d62\u2d49\u2d61\u2d4f \u2d49\u2d33\u2d30\u2d4f (1, 7, 13).\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    \u2d49\u2d33 \u2d37\u2d30\u2d54\u2d3d \u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d30\u2d4e\u2d37\u2d37\u2d30\u2d37 \u2d30\u2d4e\u2d4f\u2d49\u2d33 n, \u2d59\u2d59\u2d53\u2d3c\u2d56 \u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d53\u2d54 \u2d49\u2d4e\u2d59\u2d30\u2d59\u2d30\u2d4f \u2d33 \u2d53\u2d59\u2d4f\u2d59\u2d4d \u2d4f \u2d3d\u2d53\u2d4d\u2d30\u2d5c\u2d63. \u2d5c\u2d30\u2d61\u2d4f\u2d33\u2d49\u2d4e\u2d5c \u2d4f \u2d3d\u2d53\u2d4d\u2d30\u2d5c\u2d63 \u2d5c\u2d33\u2d30 \u2d62\u2d30\u2d5c \u2d5c\u2d30\u2d61\u2d4f\u2d33\u2d49\u2d4e\u2d5c \u2d33 \u2d5c\u2d53\u2d59\u2d4f\u2d30\u2d3d\u2d5c \u2d4f\u2d4f\u2d30 \u2d49\u2d65\u2d4d\u2d49\u2d4f \u2d59 \u2d53\u2d59\u2d4f\u2d59\u2d4d \u2d49\u2d5c\u2d5c\u2d53\u2d63\u2d54\u2d30\u2d62\u2d4f \u2d59 \u2d53\u2d4e\u2d3d \u2d30\u2d37: \u2d59\u2d59\u2d4f\u2d5c \u2d59 \u2d3d\u2d53 \u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d30\u2d4e\u2d4f\u2d49\u2d33 n. \u2d37\u2d3c\u2d3c\u2d49\u2d54 \u2d4f \u2d56\u2d49\u2d3d\u2d30\u2d4f\u2d4f, \u2d3d\u2d53 \u2d5c\u2d30\u2d33\u2d53\u2d54\u2d49 \u2d37\u2d30 \u2d5c\u2d5c\u2d62\u2d30\u2d61\u2d3c\u2d30 \u2d59\u2d33 \u2d5c\u2d30\u2d33\u2d53\u2d54\u2d49 \u2d49\u2d63\u2d54\u2d49\u2d4f \u2d59 \u2d53\u2d4e\u2d3d \u2d30\u2d37: \u2d49\u2d33 \u2d5c\u2d30\u2d33\u2d53\u2d54\u2d49 \u2d49\u2d63\u2d54\u2d49\u2d4f \u2d5c\u2d33\u2d30 \u2d5c\u2d63\u2d37\u2d49\u2d33\u2d5c, \u2d5c\u2d30\u2d33\u2d53\u2d54\u2d49 \u2d5c\u2d30\u2d39\u2d3c\u2d30\u2d55\u2d5c \u2d5c\u2d33\u2d30 \u2d62\u2d30\u2d4f \u2d53\u2d63\u2d33\u2d4f \u2d4f \u2d5c\u2d33\u2d53\u2d54\u2d49 \u2d49\u2d63\u2d54\u2d49\u2d4f. \u2d49\u2d33 \u2d5c\u2d30\u2d33\u2d53\u2d54\u2d49 \u2d5c\u2d30\u2d63\u2d37\u2d49\u2d33\u2d5c \u2d5c\u2d33\u2d30 \u2d5c\u2d63\u2d37\u2d49\u2d33\u2d5c, \u2d5c\u2d30\u2d33\u2d53\u2d54\u2d49 \u2d5c\u2d30\u2d39\u2d3c\u2d30\u2d55\u2d5c \u2d5c\u2d33\u2d30 3\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" \u2d30\u2d37 \u2d4f\u2d54\u2d30\u2d54 \u2d30\u2d4e\u2d5f\u2d5f\u2d53 \u2d30\u2d4e\u2d5b\u2d5b\u2d30\u2d54\u2d4f \u2d30\u2d45\u2d30\u2d5c\u2d30\u2d54 \u2d4f \u2d59\u2d49\u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f a \u2d37 b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\" \u2d5c\u2d30\u2d61\u2d61\u2d53\u2d54\u2d49 \u2d30\u2d37 \u2d54\u2d30\u2d37 \u2d5c\u2d3d\u2d3d\u2d30 \u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f. \u2d49 \u2d3d\u2d53\u2d4d\u2d4d\u2d53 \u2d49\u2d4e\u2d39\u2d30\u2d4f\u2d4f \u2d33 \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c, \u2d5c\u2d30\u2d61\u2d61\u2d53\u2d54\u2d49 \u2d30\u2d37 \u2d54\u2d30\u2d37 \u2d5c\u2d3d\u2d3d\u2d59 \u2d30\u2d4e\u2d39\u2d30\u2d4f \u2d30\u2d4e\u2d37\u2d37\u2d30\u2d37 \u2d33 \u2d49\u2d33\u2d54 \u2d4e\u2d3d \u2d49\u2d33\u2d30 \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f\u2d4f\u2d59 \u2d30\u2d4e\u2d33\u2d33\u2d30\u2d54\u2d53 \u2d4f 3 \u2d37 \u2d54\u2d30\u2d37 \u2d5c\u2d3d\u2d3d\u2d59 \u2d30\u2d4e\u2d39\u2d30\u2d4f \u2d30\u2d4e\u2d37\u2d37\u2d30\u2d37 \u2d33 \u2d49\u2d33\u2d54 \u2d4e\u2d3d \u2d49\u2d33\u2d30 \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f\u2d4f\u2d59 \u2d30\u2d4e\u2d33\u2d33\u2d30\u2d54\u2d53 \u2d4f 4 \u2d37 \u2d53\u2d54 \u2d49\u2d33\u2d49 \u2d30\u2d4e\u2d33\u2d33\u2d30\u2d54\u2d53 \u2d4f 3. \u2d5c\u2d30\u2d61\u2d61\u2d53\u2d54\u2d49 \u2d30\u2d37 \u2d53\u2d54 \u2d5c\u2d59\u2d4f\u2d3c\u2d4d \u2d49\u2d4e\u2d39\u2d30\u2d4f\u2d4f \u2d33 \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f\u2d4f\u2d30 \u2d53\u2d54 \u2d49\u2d33\u2d49\u2d4f \u2d49\u2d4e\u2d33\u2d33\u2d30\u2d54\u2d4f \u2d4f 3 \u2d4f\u2d56 4. \u2d5c\u2d30\u2d61\u2d61\u2d53\u2d54\u2d49 \u2d30\u2d37 \u2d54\u2d30\u2d37 \u2d5c\u2d54\u2d30\u2d54 \u2d5c\u2d30\u2d33\u2d53\u2d5c \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f\u2d4f \u2d33 \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c. \u2d49\u2d4e\u2d37\u2d62\u2d30\u2d5c\u2d4f: \u2d49 lst = [1,2,3] \u2d49\u2d47\u2d47\u2d30\u2d4f \u2d30\u2d37 \u2d5c\u2d33 \u2d5c\u2d62\u2d30\u2d3c\u2d53\u2d5c 6 \u2d49\u2d47\u2d47\u2d30\u2d4f \u2d30\u2d37\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"\u2d30\u2d54 \u2d49\u2d5c\u2d5c\u2d54 True \u2d4e\u2d3d \u2d33\u2d30\u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f\u2d4f \u2d33 \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c l \u2d37\u2d37\u2d30\u2d61 \u2d4f \u2d53\u2d3d\u2d61\u2d5c\u2d5c\u2d30\u2d62 t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n \u2d5c\u2d33\u2d30 \u2d62\u2d30\u2d5c \u2d5c\u2d4e\u2d54\u2d59\u2d4d\u2d5c \u2d4f\u2d4f\u2d30 \u2d49\u2d5c\u2d5c\u2d4e\u2d53\u2d4f\u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f\u2d4f \u2d59\u2d33 1 \u2d30\u2d54 n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \u2d59\u2d33 \u2d5c\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f, \u2d59\u2d59\u2d53\u2d3c\u2d56 \u2d30\u2d3d\u2d3d\u2d61 \u2d49\u2d3c\u2d54\u2d37\u2d49\u2d59\u2d4f \u2d4f\u2d4f\u2d30 \u2d49\u2d5c\u2d5c\u2d4a\u2d55\u2d30\u2d4f \u2d53\u2d33\u2d33\u2d30\u2d54 \u2d4f \u2d62\u2d30\u2d5c \u2d5c\u2d49\u2d3d\u2d3d\u2d4d\u2d5c. \u2d43\u2d39\u2d53 \u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d49\u2d3c\u2d54\u2d37\u2d49\u2d59\u2d4f \u2d4f\u2d4f\u2d30 \u2d47\u2d47\u2d49\u2d4e\u2d4f \u2d30\u2d4e\u2d4e \u2d61\u2d49\u2d4f\u2d4f\u2d30 \u2d33 \u2d5c\u2d3d\u2d5b\u2d5b\u2d53\u2d4e\u2d5c.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    \u2d59\u2d54\u2d59\u2d4f \u2d5c\u2d30\u2d61\u2d61\u2d53\u2d54\u2d49 \u2d4f\u2d4f\u2d30 \u2d49\u2d5c\u2d5c\u2d53\u2d4e\u2d65\u2d4f \u2d62\u2d30\u2d4f \u2d53\u2d61\u2d49\u2d3d\u2d49 \u2d30\u2d4f\u2d4e\u2d4f\u2d30\u2d39 \u2d37 \u2d30\u2d54 \u2d49\u2d5c\u2d5c\u2d54\u2d30\u2d54 \u2d62\u2d30\u2d5c \u2d5c\u2d53\u2d4f\u2d56\u2d49\u2d4d\u2d5c \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d4f\u2d4e\u2d30\u2d4d\u2d30\u2d4f. \u2d5c\u2d30\u2d61\u2d49\u2d3d\u2d49 \u2d30\u2d4f\u2d4e\u2d4f\u2d30\u2d39 \u2d4f \u2d53\u2d61\u2d49\u2d3d\u2d49, \u2d49\u2d33\u2d30 \u2d62\u2d30\u2d4f \u2d53\u2d61\u2d49\u2d3d\u2d49 \u2d33 \u2d5c\u2d5c\u2d53\u2d59\u2d4f\u2d3c\u2d30\u2d4d\u2d4f \u2d3d\u2d53\u2d4d\u2d4d\u2d53 \u2d5c\u2d33\u2d53\u2d54\u2d49\u2d61\u2d49\u2d4f (\u2d5c\u2d53\u2d59\u2d31\u2d39\u2d30\u2d4f\u2d5c \u2d59 \u2d53\u2d59\u2d30\u2d62\u2d54\u2d30\u2d54) \u2d59 \u2d62\u2d30\u2d5c \u2d5c\u2d33\u2d53\u2d54\u2d49 \u2d5c\u2d30\u2d4e\u2d30\u2d62\u2d4f\u2d53\u2d5c \u2d33 \u2d5c\u2d5c\u2d53\u2d59\u2d4f\u2d4e\u2d30\u2d4d\u2d30\u2d4f \u2d3d\u2d53\u2d4d\u2d4d\u2d53 \u2d49\u2d59\u2d3d\u2d3d\u2d49\u2d4d\u2d4f \u2d59 \u2d53\u2d59\u2d59\u2d53\u2d37\u2d59 \u2d30\u2d4e\u2d47\u2d54\u2d30\u2d4f \u2d45\u2d3c \u2d61\u2d30\u2d5c\u2d49\u2d33 \u2d4f ascii. \u2d5c\u2d30\u2d56\u2d39\u2d3c\u2d5c: \u2d49\u2d47\u2d47\u2d30\u2d4f\u2d37 \u2d30\u2d37 \u2d5c\u2d43\u2d39\u2d53 \u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d5c\u2d33\u2d53\u2d54\u2d49\u2d61\u2d49\u2d4f \u2d37 \u2d49\u2d59\u2d30\u2d62\u2d54\u2d30\u2d54\u2d4f \u2d33 \u2d5c\u2d33\u2d53\u2d54\u2d49. \u2d59 \u2d53\u2d4e\u2d37\u2d62\u2d30: anti_shuffle ((('Hi') \u2d30\u2d54 \u2d49\u2d5c\u2d5c\u2d54\u2d30\u2d54 'Hi' anti_shuffle ((('hello') \u2d30\u2d54 \u2d49\u2d5c\u2d5c\u2d54\u2d30\u2d54 'ehllo' anti_shuffle ((\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    \u2d33 \u2d53\u2d4e\u2d59\u2d37\u2d53\u2d59 \u2d4f \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d53\u2d54 \u2d49\u2d33\u2d33\u2d53\u2d5c\u2d4f, \u2d59\u2d59\u2d53\u2d3c\u2d56 \u2d5c\u2d30\u2d3d\u2d53\u2d31\u2d49\u2d62\u2d5c \u2d4f \u2d53\u2d4e\u2d59\u2d37\u2d53\u2d59 \u2d37\u2d3c\u2d3c\u2d49\u2d54 \u2d4f \u2d53\u2d59\u2d4e\u2d59\u2d30\u2d59\u2d30, \u2d54\u2d30\u2d37 \u2d5c\u2d59\u2d59\u2d53\u2d37\u2d59\u2d37 \u2d30\u2d4e\u2d59\u2d37\u2d53\u2d59 \u2d59 \u2d53\u2d59\u2d59\u2d53\u2d37\u2d59 \u2d30\u2d4e\u2d47\u2d54\u2d30\u2d4f \u2d4e\u2d3d \u2d49\u2d33\u2d30 \u2d61\u2d30\u2d5c\u2d49\u2d33 \u2d4f \u2d53\u2d56\u2d4e\u2d49\u2d59 \u2d30\u2d4e\u2d63\u2d61\u2d30\u2d54\u2d53, \u2d61\u2d30\u2d5c\u2d49\u2d33 \u2d4f \u2d53\u2d56\u2d4e\u2d49\u2d59 \u2d30\u2d4e\u2d33\u2d33\u2d30\u2d54\u2d53, \u2d53\u2d54 \u2d49\u2d4e\u2d62\u2d30\u2d4f\u2d30\u2d61\u2d4f, \u2d4f\u2d56\u2d37 \u2d59 \u2d53\u2d59\u2d59\u2d53\u2d37\u2d59 \u2d59 \u2d53\u2d59\u2d59\u2d53\u2d37\u2d59 \u2d30\u2d4e\u2d33\u2d33\u2d30\u2d54\u2d53 \u2d4e\u2d3d \u2d49\u2d33\u2d30 \u2d61\u2d30\u2d5c\u2d49\u2d33 \u2d4f \u2d53\u2d56\u2d4e\u2d49\u2d59 \u2d30\u2d4e\u2d63\u2d61\u2d30\u2d54\u2d53, \u2d61\u2d30\u2d5c\u2d49\u2d33 \u2d4f \u2d53\u2d56\u2d4e\u2d49\u2d59 \u2d30\u2d4e\u2d33\u2d33\u2d30\u2d54\u2d53, \u2d49\u2d4e\u2d62\u2d30\u2d4f\u2d30\u2d61\u2d4f. \u2d5c\u2d30\u2d56\u2d39\u2d3c\u2d5c: * \u2d53\u2d54 \u2d5c\u2d59\u2d59\u2d53\u2d37\u2d59\u2d37 \u2d30\u2d4e\u2d59\u2d37\u2d53\u2d59. \u2d30\u2d4e\u2d37\u2d62\u2d30: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"\u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f Fib4 \u2d5c\u2d33\u2d30 \u2d62\u2d30\u2d5c \u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d63\u2d53\u2d4f\u2d37 \u2d5c\u2d30\u2d4d\u2d33\u2d30\u2d4e\u2d5c \u2d4f \u2d3c\u2d49\u2d31\u2d53\u2d4f\u2d30\u2d5b\u2d49 \u2d4f\u2d4f\u2d30 \u2d49\u2d5c\u2d5c\u2d53\u2d59\u2d4f\u2d4e\u2d4d\u2d4f \u2d59: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). \u2d59\u2d3d\u2d54 \u2d62\u2d30\u2d5c \u2d5c\u2d4e\u2d54\u2d59\u2d4d\u2d5c \u2d43\u2d4e\u2d30 \u2d30\u2d37 \u2d5c\u2d59\u2d59\u2d49\u2d5f\u2d4f \u2d59 \u2d5c\u2d63\u2d4e\u2d54\u2d5c \u2d49\u2d3c\u2d54\u2d37\u2d49\u2d59\u2d4f \u2d4f \u2d61\u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d4f fib4. \u2d53\u2d54 \u2d5c\u2d59\u2d59\u2d4e\u2d54\u2d59 \u2d5c\u2d49\u2d54\u2d54\u2d30.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    }
]